<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>沂水博客</title>
  
  <subtitle>编程和心历记录</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://linyishui.top/"/>
  <updated>2019-11-18T08:54:23.757Z</updated>
  <id>http://linyishui.top/</id>
  
  <author>
    <name>沂水</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>死亡会是解脱吗</title>
    <link href="http://linyishui.top/2019111201.html"/>
    <id>http://linyishui.top/2019111201.html</id>
    <published>2019-11-12T10:03:51.000Z</published>
    <updated>2019-11-18T08:54:23.757Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script>        <div id="aplayer-uLhpSJwS" class="aplayer aplayer-tag-marker" style="margin-bottom: 20px;">            <pre class="aplayer-lrc-content"></pre>        </div>        <script>          var ap = new APlayer({            element: document.getElementById("aplayer-uLhpSJwS"),            narrow: false,            autoplay: false,            showlrc: false,            music: {              title: "曾经我也想过一了百了",              author: "中島美嘉",              url: "https://music-1258215793.cos.ap-shanghai.myqcloud.com/JP/%E4%B8%AD%E5%B3%B6%E7%BE%8E%E5%98%89%20-%20%E5%83%95%E3%81%8C%E6%AD%BB%E3%81%AE%E3%81%86%E3%81%A8%E6%80%9D%E3%81%A3%E3%81%9F%E3%81%AE%E3%81%AF.mp3",              pic: "http://p1.music.126.net/HE-K4mxyNGF84xlyuxx9Wg==/109951163825342747.jpg",              lrc: ""            }          });          window.aplayers || (window.aplayers = []);          window.aplayers.push(ap);        </script>        <div id="aplayer-ogKukIQl" class="aplayer aplayer-tag-marker" style="margin-bottom: 20px;">            <pre class="aplayer-lrc-content"></pre>        </div>        <script>          var ap = new APlayer({            element: document.getElementById("aplayer-ogKukIQl"),            narrow: false,            autoplay: false,            showlrc: false,            music: {              title: "僕らの手には何もないけど、",              author: "RAM WIRE",              url: "https://music-1258215793.cos.ap-shanghai.myqcloud.com/JP/RAM%20WIRE%20-%20%E5%83%95%E3%82%89%E3%81%AE%E6%89%8B%E3%81%AB%E3%81%AF%E4%BD%95%E3%82%82%E3%81%AA%E3%81%84%E3%81%91%E3%81%A9%E3%80%81.mp3",              pic: "http://p2.music.126.net/V1o9XDhAnI1ayWW5elJwFQ==/109951163338252165.jpg",              lrc: ""            }          });          window.aplayers || (window.aplayers = []);          window.aplayers.push(ap);        </script>        <div id="aplayer-kGMAJNzx" class="aplayer aplayer-tag-marker" style="margin-bottom: 20px;">            <pre class="aplayer-lrc-content"></pre>        </div>        <script>          var ap = new APlayer({            element: document.getElementById("aplayer-kGMAJNzx"),            narrow: false,            autoplay: false,            showlrc: false,            music: {              title: "ごはんを食べよう",              author: "Goose house",              url: "https://music-1258215793.cos.ap-shanghai.myqcloud.com/Goose%20house%20-%20%E3%81%94%E3%81%AF%E3%82%93%E3%82%92%E9%A3%9F%E3%81%B9%E3%82%88%E3%81%86.mp3",              pic: "http://p1.music.126.net/niXAzTEt2zlFpcLiPedX3g==/5754843859843186.jpg",              lrc: ""            }          });          window.aplayers || (window.aplayers = []);          window.aplayers.push(ap);        </script><p>&emsp;&emsp;可能会有那么一刻感叹自己的人生很空虚，世界好像和我无关，就算在这里死掉也不会有人会发现吧。</p><p>&emsp;&emsp;可能会有那么一刻觉得活着好累，死了就会好一些吧。</p><p>&emsp;&emsp;可能会有那么一刻无力反抗背上的压力，想着死了就轻松了吧。</p><p>&emsp;&emsp;活着似乎总是要担负一些东西，嘴里说着要放下一切，只有死去的那一刻才能真的放下吧。</p><p>&emsp;&emsp;世界是这样吗，不像幻想中那么美好、那么宽容，我好像也没那么坚强。</p><p>&emsp;&emsp;也曾想向世界传递善意，但身边的世界好像是空空的，是不是只有坏的记忆才能留在人的心里。</p><p>&emsp;&emsp;也曾想对世界倾诉，但好像没人有在乎，渐渐的也不知道该怎么说话了。</p><p>&emsp;&emsp;是啊，大家活着都很累啊，慢慢地封闭了自己的内心。</p><p>&emsp;&emsp;为了不受伤害而戴上的面具，也遮挡住了阳光，勉强才能维持着正常人的姿态。</p><p>&emsp;&emsp;“你没事吧”，“休息一下就好了”，“为家人考虑一下”，“再多坚强一些”，“还是内心不够强大”，“看不起这种自私的人”</p><p>&emsp;&emsp;说什么把握当下，生命要活得精彩，只是漂亮话罢了。</p><p>&emsp;&emsp;永别的时候告诉自己这不是放弃，是放下了。</p><p>&emsp;&emsp;好像这一生积攒的勇气终于释放了，好像扮演了一生的舞台剧终于谢幕了。</p><p>&emsp;&emsp;黑暗中死的无声无息，似乎从来没有存在过，直到最后也没有选择在阳光下，是担心围观的人肆意评论吗，人的恶意从来不会消失吧。</p><p>&emsp;&emsp;曾经也活着啊，匆匆的这一生有什么意义？</p><p>&emsp;&emsp;可能最后时刻的你也曾许愿，如果有来生，希望和能相互拥抱的人相遇。</p><p>&emsp;&emsp;哪怕一直聊着没有营养的话题，只想这样呆在一起。</p><p>&emsp;&emsp;就算还是一样活的辛苦，至少能感受到温暖。</p><p>&emsp;&emsp;希望那时可以相信这世界一切美好的存在，希望我也能成为温暖别人的存在。</p><p>&emsp;&emsp;但死了就什么都没有了，如果坚持到明天会不会有不同？</p><p>&emsp;&emsp;已放下所有的你，也许在明天的街头，可以邂逅一个阳光一样的人，也许再尝试一次就能找到一个同样孤独的人相拥取暖。</p><p>&emsp;&emsp;也许是一个多年未联系的老友，敞开心扉后，发现被社会打磨的油滑的他内心也还保留着一颗温热的心。</p><p>&emsp;&emsp;即便因奔忙无法相见，即便相互已无法变得坦率，但只要能够回到每个人都怀念的那个地方的话，是能让时光从那个时候开始延续吧</p><p>&emsp;&emsp;找到一个活下去的理由，只要能继续努力的活着，一切都还有重来的机会。</p><p>&emsp;&emsp;原本以为做不到的事情实际却可以做到的，世界渐渐变得广阔，因为相信现在所处的世界，即使一无所有仍可以顽强的活下去。</p><p>&emsp;&emsp;是啊，活着就是一件麻烦的事情，觉得不行了就暂停一下，无法面对了就逃避一下，总有一天，我们会从所有束缚我们的事之中，从肉眼看不到的微痛之中，得以解放。</p>        <div id="aplayer-qSQkRtag" class="aplayer aplayer-tag-marker" style="margin-bottom: 20px;">            <pre class="aplayer-lrc-content"></pre>        </div>        <script>          var ap = new APlayer({            element: document.getElementById("aplayer-qSQkRtag"),            narrow: false,            autoplay: false,            showlrc: false,            music: {              title: "面会菜",              author: "林生祥",              url: "https://music-1258215793.cos.ap-shanghai.myqcloud.com/OM/%E6%9E%97%E7%94%9F%E7%A5%A5%20-%20%E9%9D%A2%E4%BC%9A%E8%8F%9C.mp3",              pic: "http://p2.music.126.net/cLoAM3X8pIuCil_oJpxjWw==/18511377767183768.jpg",              lrc: ""            }          });          window.aplayers || (window.aplayers = []);          window.aplayers.push(ap);        </script><blockquote><p>&emsp;&emsp;这篇博客算是记录一下最近几年的一些感想吧，经历了一些生活中、网络中发生的事情会有些感受，这些碎片式的感受还挺难整理的，很多回忆融合到一起，写的时候有些混乱了，写着写着也搞不清想要说什么了。<br>&emsp;&emsp;有些事情发生了，可能并没有一个简单的答案，局外人却可以随心所欲的谈论自己的观点，虽然他们可能什么都不知道，却能没有责任的随便开口。事情已经发生了，当事人也没办法为自己辩护了。<br>&emsp;&emsp;</p></blockquote>]]></content>
    
    <summary type="html">
    
      
      
        &lt;link rel=&quot;stylesheet&quot; class=&quot;aplayer-secondary-style-marker&quot; href=&quot;\assets\css\APlayer.min.css&quot;&gt;&lt;script src=&quot;\assets\js\APlayer.min.js&quot; cla
      
    
    </summary>
    
      <category term="日志" scheme="http://linyishui.top/categories/%E6%97%A5%E5%BF%97/"/>
    
    
      <category term="diary" scheme="http://linyishui.top/tags/diary/"/>
    
  </entry>
  
  <entry>
    <title>Docker（一）概览</title>
    <link href="http://linyishui.top/2019100701.html"/>
    <id>http://linyishui.top/2019100701.html</id>
    <published>2019-10-07T02:34:47.000Z</published>
    <updated>2019-12-10T10:11:19.198Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="Docker概览（一）概览"><a href="#Docker概览（一）概览" class="headerlink" title="Docker概览（一）概览"></a><strong>Docker概览（一）概览</strong></h1><h2 id="第一节-容器的发展"><a href="#第一节-容器的发展" class="headerlink" title="第一节 容器的发展"></a><strong>第一节 容器的发展</strong></h2><h3 id="1-1-过去"><a href="#1-1-过去" class="headerlink" title="1.1 过去"></a><strong>1.1 过去</strong></h3><p>&emsp;&emsp;过去服务器只能运行单一应用，旧时代的Windows和Linux系统都没有相应的技术手段来保证能够在一台服务器上稳定安全的同时运行多个应用。所以每当业务部门需要新增一个应用就要采购一台新的服务器，而对于应用所需服务器性能只能凭经验来推测，所以不得不买性能要大幅优于所需的硬件，最终必然造成大量的浪费。</p><h3 id="1-2-虚拟机"><a href="#1-2-虚拟机" class="headerlink" title="1.2 虚拟机"></a><strong>1.2 虚拟机</strong></h3><p>&emsp;&emsp;为了解决上述问题，VMware公司开发了<strong>虚拟机</strong>，终于可以有一种允许多应用能稳定安全运行在同一台服务器的技术。虚拟机是一项划时代的技术，让现有的资产可以发挥更多的作用。</p><p>&emsp;&emsp;但虚拟机需要依赖于其专用的操作系统，而OS会占用额外的CPU、RAM和存储，这些资源本可以用来运行更多的应用。每个OS都需要补丁和监控，还有一些情况下OS需要许可证才可以运行。还有一些挑战如虚拟机启动会较慢，可移植性很差等等。</p><h3 id="1-3-容器"><a href="#1-3-容器" class="headerlink" title="1.3 容器"></a><strong>1.3 容器</strong></h3><p>&emsp;&emsp;后来，像谷歌这样的公司开始采用容器（Container）技术来解决虚拟机的这些缺点。容器不会独占OS，从而节省了大量的系统资源，也省下了花费在许可证和为OS打补丁的运维成本。容器还有启动快和便于迁移等优势，从PC迁移到云上或再迁移到数据中心的虚拟机或物理机上都非常简单。</p><h3 id="1-4-Linux容器"><a href="#1-4-Linux容器" class="headerlink" title="1.4 Linux容器"></a><strong>1.4 Linux容器</strong></h3><p>&emsp;&emsp;现代的容器技术起源于Linux，是很多力量持续贡献的产物，这些年对容器影响较大的技术包括：内核命名空间、控制组、联合文件系统、当然还有Docker。</p><h3 id="1-5-Docker"><a href="#1-5-Docker" class="headerlink" title="1.5 Docker"></a><strong>1.5 Docker</strong></h3><p>&emsp;&emsp;容器技术的复杂度一直以来是导致其没有被普遍应用的原因，但Docker技术的诞生改变了这一情况。Docker使容器变得简单。</p><h3 id="1-6-Windows容器"><a href="#1-6-Windows容器" class="headerlink" title="1.6 Windows容器"></a><strong>1.6 Windows容器</strong></h3><p>&emsp;&emsp;近些年微软致力于在Windows平台发展Docker和容器技术，实现容器所需的核心Windows内核技术被统称为Windows容器。用户空间通过Docker来完成与Windows容器的交互，所以同Linux上使用Docker几乎一直。</p><p>&emsp;&emsp;运行中的容器共享宿主机的内核，这意味着基于Windows的容器化应用在Linux上是无法运行的，但目前Windows版Docker已可以在Windows模式和Linux模式间切换。Docker发展速度日新月异，请及时了解最新技术进展。</p><h3 id="1-7-Kubernetes"><a href="#1-7-Kubernetes" class="headerlink" title="1.7 Kubernetes"></a><strong>1.7 Kubernetes</strong></h3><p>&emsp;&emsp;Kubernetes是谷歌的一个开源项目，是容器编排领域的领头羊。简单理解就是Docker之上的一个平台，采用Docker作为其底层容器操作。</p><p>&emsp;&emsp;Kubernetes采用Docker作为其默认容器运行时（container runtime），包括Kubernetes启动和停止容器，以及镜像拉取等。Kubernetes提供了一个可插拔的容器运行时接口CRI，帮助Kubernetes实现将运行时环境从Docker快速替换为其他容器运行时，未来Kubernetes会将默认由Docker转为containerd。</p><hr><h2 id="第二节-了解Docker"><a href="#第二节-了解Docker" class="headerlink" title="第二节 了解Docker"></a><strong>第二节 了解Docker</strong></h2><h3 id="2-1-简介"><a href="#2-1-简介" class="headerlink" title="2.1 简介"></a><strong>2.1 简介</strong></h3><p>&emsp;&emsp;Docker是一种运行于Linux和Windows上的软件，<strong>用于创建、管理和编排容器</strong>。Docker是在GitHub上开发的Moby开源项目的一部分。Docker公司是整个Moby开源项目的维护者，还提供包含支持服务的商业版本的Docker。</p><blockquote><p><em>“Docker”一词来自英国口语，意为码头工人（Dock Worker），即从船上装卸货物的人</em></p></blockquote><h3 id="2-2-Docker运行时与编排引擎"><a href="#2-2-Docker运行时与编排引擎" class="headerlink" title="2.2 Docker运行时与编排引擎"></a><strong>2.2 Docker运行时与编排引擎</strong></h3><p>&emsp;&emsp;多数技术人员在谈到Docker时，主要是指Docker引擎。<strong>Docker引擎是用于运行和编排容器的基础设施工具</strong>。有VMware管理经验的读者可以将其类比为ESXi（运行虚拟机的核心管理程序），而Docker引擎是运行容器的核心容器运行时。</p><p>&emsp;&emsp;其他Docker公司或第三方的产品都是围绕Docker引擎进行开发和集成的。如图2.2所示，Docker引擎位于中心，其他产品基于Docker引擎的核心功能进行集成。</p><p><img src="https://pic-1258215793.cos.ap-shanghai.myqcloud.com/content/20191001/201910010111.png" alt="围绕Docker引擎进行开发和集成的产品"></p><p>&emsp;&emsp;Docker引擎可以从Docker网站下载，也可以基于GitHub上的源码进行构建。无论是开源版本还是商业版本，都有Linux和Windows版本。Docker引擎主要有两个版本：企业版（EE）和社区 版（CE）。每个季度，企业版和社区版都会发布一个稳定版本。社区版本会提供4个月的支持，而企业版本会提供12个月的支持。社区版还会通过Edge方式发布月度版。</p><h3 id="2-3-Docker开源项目（Moby）"><a href="#2-3-Docker开源项目（Moby）" class="headerlink" title="2.3 Docker开源项目（Moby）"></a><strong>2.3 Docker开源项目（Moby）</strong></h3><p>&emsp;&emsp;“Docker”一词也会用于指代开源Docker项目。其中包含一系列可以从Docker官网下载和安装的工具，比如Docker服务端和Docker客户端。不过，该项目在2017年于Austin举办的DockerCon上正式命名为Moby项目。由于这次改名，GitHub上的docker/docker库也被转移到了moby/moby。</p><p>&emsp;&emsp;Moby项目的目标是基于开源的方式，发展成为Docker上游，并将Docker拆分为更多的模块化组件。Moby项目托管于GitHub的Moby代码库，包括子项目和工具列表。核心的Docker引擎项目位于GitHub的moby/moby，但是引擎中的代码正持续被拆分和模块化。</p><p>&emsp;&emsp;多数项目及其工具都是基于Golang编写的，这是谷歌推出的一种新的系统级编程语言，又叫Go语言。使用Go语言的读者，将更容易为该项目贡献代码。</p><h3 id="2-4-容器生态"><a href="#2-4-容器生态" class="headerlink" title="2.4 容器生态"></a><strong>2.4 容器生态</strong></h3><p>&emsp;&emsp;Docker公司的一个核心哲学通常被称为“含电池，但可拆卸”（Batteries included but removable）。意思是许多Docker内置的组件都可以替换为第三方的组件，网络技术栈就是一个很好的例子。Docker核心产品内置有网络解决方案。但是网络技术栈是可插拔的，这意味着Docker内置的网络方案可以被替换为第三方的方案，许多人都会这样使用。</p><p>&emsp;&emsp;早期的时候，经常出现第三方插件比 Docker 提供的内置组件更好的情况。然而这会对Docker公司的商业模式造成冲击。毕竟，Docker公司需要依靠盈利来维持基业长青。因此，“内置的电池”变得越来越好用了。这也导致了生态内部的紧张关系和竞争的加剧。简单来说，Docker内置的“电池”仍然是可插拔的，然而越来越不需要将它们移除了。</p><h3 id="2-5-开放容器计划"><a href="#2-5-开放容器计划" class="headerlink" title="2.5 开放容器计划"></a><strong>2.5 开放容器计划</strong></h3><p>&emsp;&emsp;如果不谈及<strong>开放容器计划</strong>（The Open Container Initiative, OCI）的话，对Docker和容器生态的探讨总是不完整的。</p><p>&emsp;&emsp;<strong>OCI是一个旨在对容器基础架构中的基础组件</strong>（如镜像格式与容器运行时）进行标准化的管理委员会。简短的历史介绍是，一个名为CoreOS的公司不喜欢Docker的某些行事方式。因此它就创建了一个新的开源标准，称作“appc”，该标准涉及诸如镜像格式和容器运行时等方面。此外它还开发了一个名为rkt（发音“rocket”）的实现。</p><p>&emsp;&emsp;两个处于竞争状态的标准将容器生态置于一种尴尬的境地。这使容器生态陷入了分裂的危险中，同时也令用户和消费者陷入两难。虽然竞争是一件好事，但是标准的竞争通常不是。因为它会导致困扰，降低用户接受度，对谁都无益。</p><p>&emsp;&emsp;考虑到这一点，所有相关方都尽力用成熟的方式处理此事，共同成立了OCI——一个旨在管理容器标准的轻量级的、敏捷型的委员会。当前OCI已经发布了两份规范（标准）：镜像规范和运行时规范。Docker 1.11版本中，Docker引擎架构已经遵循OCI运行时规范了。到目前为止，OCI已经取得了不错的成效，将容器生态团结起来。OCI在Linux基金会的支持下运作，Docker公司和CoreOS公司都是主要贡献者。</p><hr><h2 id="第三节-安装Docker"><a href="#第三节-安装Docker" class="headerlink" title="第三节 安装Docker"></a><strong>第三节 安装Docker</strong></h2><p>&emsp;&emsp;Docker可以安装在Windows、Mac、Linux之上。除此之外还可以在云上安装，也可以在个人笔记本电脑上安装等等。本节仅整理比较重要的几种安装方式。</p><blockquote><p>1.桌面安装:</p><ul><li>Windows版Docker（Docker for Windows）</li><li>Mac版Docker（Docker for Mac）</li></ul><p>2.服务器安装: </p><ul><li>Linux</li><li>Windows Server 2016</li></ul><p>3.Docker引擎升级</p><p>4.Docker存储驱动的选择</p></blockquote><h3 id="3-1-Windows版Docker（DfW）"><a href="#3-1-Windows版Docker（DfW）" class="headerlink" title="3.1 Windows版Docker（DfW）"></a><strong>3.1 Windows版Docker（DfW）</strong></h3><p>&emsp;&emsp;Windows版Docker需要运行在一个安装了64位Windows 10 操作系统的计算机上，通过启动一个独立的引擎来提供Docker环境。</p><p>&emsp;&emsp;Windows版Docker是一个社区版本（Community Edition，CE）的应用，并不是为生产环境设计的。Windows版Docker在某些版本特性上可能是延后支持的。这是因为Docker公司对该产品的定位是稳定性第一，新特性其次。</p><blockquote><p>在安装之前，Windows版Docker的环境有以下要求:</p><ul><li>Windows 10 Pro / Enterprise / Education（1607 Anniversary Update、 Build 14393或者更新的版本）。 </li><li>Windows必须是64位的版本。 </li><li>需要启用Windows操作系统中的Hyper-V和容器特性。</li></ul></blockquote><h4 id="开启Hyper-V和容器"><a href="#开启Hyper-V和容器" class="headerlink" title="开启Hyper-V和容器"></a><strong>开启Hyper-V和容器</strong></h4><p>&emsp;&emsp;接下来的步骤会假设读者的计算机已经开启了BIOS设置中的硬件虚拟化支持。如果没有开启，则需要在机器上执行下面的步骤。</p><blockquote><p>首先，读者需要确认在Windows 10操作系统中，Hyper-V和容器特性已安装并且开启。</p><ol><li>右键单击Windows开始按钮并选择“应用和功能”页面。</li><li>单击“程序和功能”链接。</li><li>单击“启用或关闭Windows功能”。</li><li>确认Hyper-V和容器复选框已经被勾选，并单击确定按钮。</li></ol></blockquote><p>&emsp;&emsp;按上述步骤操作完成后，会安装并开启Hyper-V和容器特性，需要重启操作系统。之后就可以安装Windows版Docker。</p><blockquote><ol><li>访问Docker的下载页面，并单击其中的Download for Windows按钮。</li><li>单击后会跳转到Docker商店，需要读者使用自己的Docker ID进行登录。</li><li>单击任意Get Docker下载链接。Docker for Windows分为稳定版（Stable）和抢鲜版（Edge）。抢鲜版当中包含一些新特性，但是可能不够稳定。单击下载链接后，会将名为Docker for Windows Installer.exe的安装包下载到默认下载目录。</li><li>找到上一步下载的安装包并运行即可。</li></ol></blockquote><h4 id="家庭版手动伪装专业版"><a href="#家庭版手动伪装专业版" class="headerlink" title="家庭版手动伪装专业版"></a><strong>家庭版手动伪装专业版</strong></h4><p>&emsp;&emsp;windows10家庭版无法安装docker，没有Hyper-V等组件，需要下载docker toolbox安装，当然也可以直接将以下代码保存到.cmd文件并用管理员权限执行来安装Hyper-V。</p><figure class="highlight jboss-cli"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">pushd <span class="string">"%~dp0"</span></span><br><span class="line">dir <span class="string">/b</span> %SystemRoot%\servicing\Packages\*Hyper-V*<span class="string">.mum</span> &gt;hyper-v.txt</span><br><span class="line">for <span class="string">/f</span> %%i in <span class="params">('findstr /i . hyper-v.txt 2^&gt;nul')</span> do dism <span class="string">/online</span> <span class="string">/norestart</span> <span class="string">/add-package</span>:<span class="string">"%SystemRoot%\servicing\Packages\%%i"</span></span><br><span class="line">del hyper-v.txt</span><br><span class="line">Dism <span class="string">/online</span> <span class="string">/enable-feature</span> <span class="string">/featurename</span><span class="function">:Microsoft-Hyper-V-All</span> <span class="string">/LimitAccess</span> <span class="string">/ALL</span></span><br></pre></td></tr></table></figure><p>&emsp;&emsp;管理员身份执行以下cmd文件，伪装成win10专业版</p><figure class="highlight jboss-cli"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">REG ADD <span class="string">"HKEY_LOCAL_MACHINE\software\Microsoft\Windows NT\CurrentVersion"</span> <span class="string">/v</span> EditionId <span class="string">/T</span> REG_EXPAND_SZ <span class="string">/d</span> </span><br><span class="line">Professional <span class="string">/F</span></span><br></pre></td></tr></table></figure><p>&emsp;&emsp;但执行失败，所以还是用toolbox来安装了。</p><blockquote><p><a href="http://mirrors.aliyun.com/docker-toolbox/windows/docker-toolbox/" target="_blank" rel="noopener">http://mirrors.aliyun.com/docker-toolbox/windows/docker-toolbox/</a></p></blockquote><h4 id="正式安装"><a href="#正式安装" class="headerlink" title="正式安装"></a><strong>正式安装</strong></h4><p>&emsp;&emsp;以管理员身份运行安装向导，并按照提示一步一步完成整个安装过程。安装完成后Docker会作为系统服务自动启动，并且在Windows的通知栏看到Docker的大鲸鱼图标。</p><p>&emsp;&emsp;打开命令行或者PowerShell界面，并尝试执行下面的命令：</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">Client:</span> </span><br><span class="line"><span class="attr"> Version:</span>       <span class="number">18.01</span><span class="number">.0</span><span class="bullet">-ce</span> </span><br><span class="line"> <span class="string">API</span> <span class="attr">version:</span>   <span class="number">1.35</span> </span><br><span class="line"> <span class="string">Go</span> <span class="attr">version:</span>    <span class="string">go1.9.2</span> </span><br><span class="line"> <span class="string">Git</span> <span class="attr">commit:</span>    <span class="number">03596</span><span class="string">f5</span> </span><br><span class="line"><span class="attr"> Built:</span> <span class="string">Wed</span> <span class="string">Jan</span> <span class="number">10</span> <span class="number">20</span><span class="string">:05:55</span> <span class="number">2018</span> </span><br><span class="line"> <span class="string">OS/Arch:</span>       <span class="string">windows/amd64</span> </span><br><span class="line"><span class="attr"> Experimental:</span>  <span class="literal">false</span> </span><br><span class="line"><span class="attr"> Orchestrator:</span>  <span class="string">swarm</span></span><br><span class="line"><span class="attr">Server:</span> </span><br><span class="line"><span class="attr"> Engine:</span>  </span><br><span class="line"><span class="attr">  Version:</span>      <span class="number">18.01</span><span class="number">.0</span><span class="bullet">-ce</span>  </span><br><span class="line">  <span class="string">API</span> <span class="attr">version:</span>  <span class="number">1.35</span> <span class="string">(minimum</span> <span class="string">version</span> <span class="number">1.12</span><span class="string">)</span>  </span><br><span class="line">  <span class="string">Go</span> <span class="attr">version:</span>   <span class="string">go1.9.2</span>  </span><br><span class="line">  <span class="string">Git</span> <span class="attr">commit:</span>   <span class="number">03596</span><span class="string">f5</span>  </span><br><span class="line"><span class="attr">  Built:</span>        <span class="string">Wed</span> <span class="string">Jan</span> <span class="number">10</span> <span class="number">20</span><span class="string">:13:12</span> <span class="number">2018</span>  </span><br><span class="line">  <span class="string">OS/Arch:</span>      <span class="string">linux/amd64</span>  </span><br><span class="line"><span class="attr">  Experimental:</span> <span class="literal">false</span></span><br></pre></td></tr></table></figure><p>&emsp;&emsp;注意观察命令输出内容，其中Server部分中的OS/Arch属性展示了当前的操作系统是linux/amd64。这是因为在默认安装方式中，Docker daemon是运行在Hyper-V虚拟机中的一个轻量级Linux上的。这种情况下只能在Windows版Docker上运行Linux容器。</p><p>&emsp;&emsp;如果想要运行原生Windows容器（Native Windows Container），可以右击Windows通知栏中的Docker鲸鱼图标，并选择“切换到Windows容器”。使用下面的命令也可以完成切换（进入\Program Files\Docker\Docker目录下执行）。</p><figure class="highlight taggerscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">C:<span class="symbol">\P</span>rogram Files<span class="symbol">\D</span>ocker<span class="symbol">\D</span>ocker&gt; .<span class="symbol">\d</span>ockercli -SwitchDaemon</span><br></pre></td></tr></table></figure><p>&emsp;&emsp;如果已经开启了Windows容器特性，则只需要花费数秒就能完成切换。一旦切换完成，在命令行中执行docker version指令的输出内容如下。</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">C:</span><span class="string">\&gt;</span> <span class="string">docker</span> <span class="string">version</span> </span><br><span class="line"><span class="attr">Client:</span> </span><br><span class="line"> <span class="string">&lt;Snip&gt;</span></span><br><span class="line"><span class="attr">Server:</span> </span><br><span class="line"><span class="attr"> Engine:</span>  </span><br><span class="line"><span class="attr">  Version:</span>      <span class="number">18.01</span><span class="number">.0</span><span class="bullet">-ce</span>  </span><br><span class="line">  <span class="string">API</span> <span class="attr">version:</span>  <span class="number">1.35</span> <span class="string">(minimum</span> <span class="string">version</span> <span class="number">1.24</span><span class="string">)</span>  </span><br><span class="line">  <span class="string">Go</span> <span class="attr">version:</span>   <span class="string">go1.9.2</span></span><br><span class="line">  <span class="string">Git</span> <span class="attr">commit:</span>   <span class="number">03596</span><span class="string">f5</span>  </span><br><span class="line"><span class="attr">  Built:</span>        <span class="string">Wed</span> <span class="string">Jan</span> <span class="number">10</span> <span class="number">20</span><span class="string">:20:36</span> <span class="number">2018</span>  </span><br><span class="line">  <span class="string">OS/Arch:</span>      <span class="string">windows/amd64</span>  </span><br><span class="line"><span class="attr">  Experimental:</span> <span class="literal">true</span></span><br></pre></td></tr></table></figure><p>&emsp;&emsp;可以看到，现在Server版本信息变成了windows/amd64，这意味着Docker daemon运行在原生Windows内核上，并且只能运行Windows容器了。同时也可以发现，Experimental这个属性的值为true。这表示当前运行的Docker版本是实验版本。可以通过运行dockercli -Version命令来查看当前的Docker版本。dockercli命令在C:\Program Files\Docker\Docker目录下。</p><p>&emsp;&emsp;Windows版Docker包括Docker引擎（客户端和daemon）、Docker Compose、Docker Machine以及Docker Notary命令行。通过下列命令确认各个模块已经成功安装。</p><figure class="highlight vim"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">C:\&gt; docker --<span class="keyword">version</span> </span><br><span class="line">Docker <span class="keyword">version</span> <span class="number">18.01</span>.<span class="number">0</span>-<span class="keyword">ce</span>, build <span class="number">03596</span>f5</span><br><span class="line"></span><br><span class="line">C:\&gt; docker-compose --<span class="keyword">version</span> </span><br><span class="line">docker-compose <span class="keyword">version</span> <span class="number">1.18</span>.<span class="number">0</span>, build <span class="number">8</span>dd22a96</span><br><span class="line"></span><br><span class="line">C:\&gt; docker-machine --<span class="keyword">version</span> </span><br><span class="line">docker-machine.<span class="keyword">exe</span> <span class="keyword">version</span> <span class="number">0.13</span>.<span class="number">0</span>, build <span class="number">9</span>ba6da9</span><br><span class="line"></span><br><span class="line">C:\&gt; notary <span class="keyword">version</span> </span><br><span class="line">notary </span><br><span class="line"> Version:    <span class="number">0.4</span>.<span class="number">3</span> </span><br><span class="line"> Git commi<span class="variable">t:</span> <span class="number">9211198</span></span><br></pre></td></tr></table></figure><h3 id="3-2-Mac版Docker（DfM）"><a href="#3-2-Mac版Docker（DfM）" class="headerlink" title="3.2　Mac版Docker（DfM）"></a><strong>3.2　Mac版Docker（DfM）</strong></h3><p>&emsp;&emsp;Mac版Docker并不是为生产环境而设计的，Mac版Docker就是一个流畅、简单并且稳定版的boot2docker。对于Mac版Docker来说，提供基于Mac原生操作系统中Darwin内核的Docker引擎没有什么意义。所以在Mac版Docker当中，Docker daemon是运行在一个轻量级的Linux VM之上的。Mac版Docker通过对外提供daemon和API的方式与Mac环境实现无缝集成，这意味着我们可以在Mac上打开终端并直接使用Docker命令。</p><p>&emsp;&emsp;尽管在Mac上实现了无缝集成，还是要谨记Mac版Docker底层是基于Linux VM运行的，所以说Mac版Docker只能运行基于Linux的Docker容器。不过这样已经很好了，因为大部分容器实际上都是基于Linux的。</p><p>&emsp;&emsp;安装过程暂略，个人还未有Mac产品。</p><h3 id="3-3-在Linux上安装Docker"><a href="#3-3-在Linux上安装Docker" class="headerlink" title="3.3　在Linux上安装Docker"></a><strong>3.3　在Linux上安装Docker</strong></h3><p>&emsp;&emsp;在Linux上安装Docker是常见的安装场景，并且安装过程非常简单。通常难点在于Linux不同发行版之间的轻微区别，比如Ubuntu和CentOS之间的差异。接下来的示例基于Ubuntu版本Linux，同样适用于更低或者更高的版本。理论上，下面的示例在CentOS的各种版本上也是可以执行的。至于Linux操作系统是安装在自己的数据中心，还是第三方公有云，或是笔记本的虚拟机上，都没有任何的区别。唯一需求就是这台机器是Linux操作系统，并且能够访问 <a href="https://get.docker.com。" target="_blank" rel="noopener">https://get.docker.com。</a></p><p>&emsp;&emsp;首先需要选择安装的Docker版本。当前有两个版本可供选择： 社区版（Community Edition，CE）和企业版（Enterprise Edition，EE）。</p><p>&emsp;&emsp;下面使用wget命令来运行一个Shell脚本，完成Docker CE的安装。更多其他在Linux上安装Docker的方式，可以打开Docker主页面，单击页面中Get Started按钮来获取。</p><p>&emsp;&emsp;（1）在Linux机器上打开一个新的Shell</p><p>&emsp;&emsp;（2）使用wget从<a href="https://get.docker.com获取并运行Docker安装脚本，然后采用Shell中管道（pipe）的方式来执行这个脚本。" target="_blank" rel="noopener">https://get.docker.com获取并运行Docker安装脚本，然后采用Shell中管道（pipe）的方式来执行这个脚本。</a></p><figure class="highlight livecodeserver"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">$ wget -qO- <span class="keyword">https</span>://<span class="built_in">get</span>.docker.com/ | sh</span><br><span class="line"></span><br><span class="line">modprobe: FATAL: Module aufs <span class="keyword">not</span> found /lib/modules/<span class="number">4.4</span><span class="number">.0</span><span class="number">-36</span>-generic + sh -c <span class="string">'sleep 3; yum -y -q install docker-engine'</span> </span><br><span class="line">&lt;Snip&gt; </span><br><span class="line">If you would like <span class="built_in">to</span> use Docker <span class="keyword">as</span> <span class="keyword">a</span> non-root user, you should now consider adding your user <span class="built_in">to</span> <span class="keyword">the</span> <span class="string">"docker"</span> group <span class="keyword">with</span> something like:</span><br><span class="line"></span><br><span class="line">sudo usermod -aG docker your-user</span><br><span class="line"></span><br><span class="line">Remember that you will have <span class="built_in">to</span> <span class="built_in">log</span> out <span class="keyword">and</span> back <span class="keyword">in</span>...</span><br></pre></td></tr></table></figure><p>&emsp;&emsp;（3）最好通过非root用户来使用Docker。这时需要添加非root用户到本地Docker Unix组当中。下面的命令展示了如何把名为npoulton的用户添加到Docker组中，以及如何确认操作是否执行成功。请自行使用系统中的有效用户。</p><figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">$ sudo usermod -aG docker npoulton</span><br><span class="line"></span><br><span class="line">$ cat /etc<span class="built_in">/group </span>| grep docker </span><br><span class="line">docker:x:999:npoulton</span><br></pre></td></tr></table></figure><p>&emsp;&emsp;如果当前登录用户就是要添加到Docker组中的用户的话，则需要重新登录，组权限设置才会生效。这样Docker已经在Linux机器上安装成功。运行下面命令来确认安装结果。</p><figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">$ docker --version</span><br><span class="line">$ docker<span class="built_in"> system </span><span class="builtin-name">info</span> </span><br><span class="line"></span><br><span class="line">--有问题可以尝试重启docker</span><br><span class="line">service docker restart</span><br></pre></td></tr></table></figure><h3 id="3-4-在Windows-Server-2016上安装Docker"><a href="#3-4-在Windows-Server-2016上安装Docker" class="headerlink" title="3.4 在Windows Server 2016上安装Docker"></a><strong>3.4 在Windows Server 2016上安装Docker</strong></h3><p>&emsp;&emsp;暂略</p><h3 id="3-5-Docker引擎（Engine）升级"><a href="#3-5-Docker引擎（Engine）升级" class="headerlink" title="3.5 Docker引擎（Engine）升级"></a><strong>3.5 Docker引擎（Engine）升级</strong></h3><p>&emsp;&emsp;升级Docker引擎（Engine）是一项重要的任务，尤其是生产环境。 </p><p>&emsp;&emsp;需要重视升级操作的每个前置条件，包括确保容器配置了正确的重启策略；在Swarm Mode模式下使用服务时，需要确保正确配置了draining node。当完成了上述前置条件的检查之后，可以通过如下步骤完成升级操作。</p><blockquote><ol><li>停止Docker守护程序。</li><li>移除旧版本Docker。</li><li>安装新版本Docker。</li><li>配置新版本的Docker为开机自启动。</li><li>确保容器重启成功。</li></ol></blockquote><p>&emsp;&emsp;不同版本的Linux在升级Docker的时候，命令可能略有区别。</p><h4 id="在Ubuntu-16-04上升级Docker-CE"><a href="#在Ubuntu-16-04上升级Docker-CE" class="headerlink" title="在Ubuntu 16.04上升级Docker CE"></a><strong>在Ubuntu 16.04上升级Docker CE</strong></h4><p>&emsp;&emsp;假设已经完成了全部的升级前置步骤并且Docker处于可以 升级的状态，同时还可以用root用户身份运行升级命令。以root用户运行升级命令是不推荐的，但是可以简化示例。需要通过sudo来执行下列指令。</p><p>&emsp;&emsp;（1）更新APT包列表。</p><figure class="highlight q"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ apt-<span class="built_in">get</span> <span class="keyword">update</span></span><br></pre></td></tr></table></figure><p>&emsp;&emsp;（2）卸载当前Docker。</p><figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ apt-<span class="builtin-name">get</span> <span class="builtin-name">remove</span> docker docker-engine docker-ce docker.io -y</span><br></pre></td></tr></table></figure><p>&emsp;&emsp;在之前的版本中，Docker引擎的包名可能有多个。这条命令能够确保已经安装的Docker包全部被删除。</p><p>&emsp;&emsp;（3）安装新版本Docker。</p><p>&emsp;&emsp;有不同版本的Docker可供选择，并且有多种方式可以安装Docker。 无论是Docker CE还是Docker EE，都有不止一种安装方式。例如， Docker CE可以通过apt或者deb包管理方式进行安装，也可以使用Docker 官网上的脚本。</p><p>&emsp;&emsp;接下来的命令会使用get.docker.com的脚本完成最新版本Docker CE 的安装和配置。</p><figure class="highlight vim"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ wget -qO- http<span class="variable">s:</span>//<span class="built_in">get</span>.docker.<span class="keyword">com</span>/ | <span class="keyword">sh</span></span><br></pre></td></tr></table></figure><p>（4）将Docker配置为开机自启动。</p><figure class="highlight crystal"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">$ systemctl enable docker</span><br><span class="line">Synchronizing state <span class="keyword">of</span> docker.service... </span><br><span class="line">Executing /<span class="class"><span class="keyword">lib</span>/<span class="title">systemd</span>/<span class="title">systemd</span>-<span class="title">sysv</span>-<span class="title">install</span> <span class="title">enable</span> <span class="title">docker</span></span></span><br><span class="line">$ systemctl is-enabled docker </span><br><span class="line">enabled</span><br></pre></td></tr></table></figure><p>&emsp;&emsp;此时可能想重启自己的节点。这样可以确保刚安装的Docker不会对系统开机有任何的影响。</p><p>&emsp;&emsp;（5）检查并确保每一个容器和服务都已经重启成功。</p><figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">$ docker container ls </span><br><span class="line">CONTAINER ID    IMAGE     COMMAND       CREATED           STATUS</span><br><span class="line"></span><br><span class="line">97e599aca9f5    alpine    <span class="string">"sleep 1d"</span>    14 minutes ago    Up 1 minute</span><br><span class="line"></span><br><span class="line">$ docker<span class="built_in"> service </span>ls </span><br><span class="line">ID              NAME          MODE         REPLICAS     IMAGE </span><br><span class="line">ibyotlt1ehjy    prod-equus1   replicated   1/1          alpine:latest</span><br></pre></td></tr></table></figure><p>&emsp;&emsp;请注意，更新Docker还有其他的方法，此处只是介绍了基于Ubuntu Linux 16.04 版本的方式。</p><h4 id="在Windows-Server-2016上升级Docker-EE"><a href="#在Windows-Server-2016上升级Docker-EE" class="headerlink" title="在Windows Server 2016上升级Docker EE"></a><strong>在Windows Server 2016上升级Docker EE</strong></h4><p>&emsp;&emsp;暂略</p><h3 id="3-6-Docker存储驱动的选择"><a href="#3-6-Docker存储驱动的选择" class="headerlink" title="3.6 Docker存储驱动的选择"></a><strong>3.6 Docker存储驱动的选择</strong></h3><p>&emsp;&emsp;每个Docker容器都有一个<strong>本地存储空间</strong>，用于保存层叠的<strong>镜像层</strong>（Image Layer）以及挂载的容器<strong>文件系统</strong>。默认情况下，容器的所有读写操作都发生在其镜像层上或挂载的文件系统中，所以存储是每个容器的性能和稳定性不可或缺的一个环节。</p><p>&emsp;&emsp;以往，本地存储是通过<strong>存储驱动</strong>（Storage Driver）进行管理的，有时候也被称为Graph Driver或者GraphDriver。虽然存储驱动在上层抽象设计中都采用了<strong>栈式镜像层存储</strong>和<strong>写时复制</strong>（Copy-on-Write）的设计思想，但是Docker在Linux底层支持几种不同的存储驱动的具体实现，每一种实现方式都采用不同方法实现了镜像层和写时复制。虽然底层实现的差异不影响用户与Docker之间的交互，但是对Docker的性能和稳定性至关重要。</p><p>&emsp;&emsp;在Linux上，Docker可选择的一些存储驱动包括AUFS（最原始也是 最老的）、Overlay2（可能是未来的最佳选择）、Device Mapper、Btrfs 和ZFS。</p><p>&emsp;&emsp;Docker在Windows操作系统上只支持一种存储驱动，即Windows Filter。</p><p>&emsp;&emsp;存储驱动的选择是节点级别的。这意味着每个Docker主机只能选择一种存储驱动，而不能为每个容器选择不同的存储驱动。在Linux上，读者可以通过修改/etc/docker/daemon.json文件来修改存储引擎配置，修改完成之后需要重启Docker才能够生效。下面的代码片段展示了如何将存储驱动设置为overlay2。</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&#123;  <span class="attr">"storage-driver"</span>: <span class="string">"overlay2"</span> &#125;</span><br></pre></td></tr></table></figure><p>&emsp;&emsp;如果修改了正在运行Docker主机的存储引擎类型，则现有的镜像和容器在重启之后将不可用，这是因为每种存储驱动在主机上存储镜像层的位置是不同的（通常在/var/lib/docker/  \<storagedriver>/…目录下）。修改了存储驱动的类型，Docker就无法找到原有的镜像和容器了。切换到原来的存储驱动，之前的镜像和容器就可以继续使用了。</storagedriver></p><p>&emsp;&emsp;如果希望在切换存储引擎之后还能够继续使用之前的镜像和容器，需要将镜像保存为Docker格式，上传到某个镜像仓库，修改本地 Docker存储引擎并重启，之后从镜像仓库将镜像拉取到本地，最后重启容器。</p><p>&emsp;&emsp;通过下面的命令来检查Docker当前的存储驱动类型。</p><figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">$ docker<span class="built_in"> system </span><span class="builtin-name">info</span> </span><br><span class="line">&lt;Snip&gt; </span><br><span class="line">Storage Driver: overlay2  </span><br><span class="line">  Backing Filesystem: xfs  </span><br><span class="line">  Supports d_type: <span class="literal">true</span>  </span><br><span class="line">  Native Overlay Diff: <span class="literal">true</span> </span><br><span class="line">&lt;Snip&gt;</span><br></pre></td></tr></table></figure><p>&emsp;&emsp;选择存储驱动并正确地配置在Docker环境中是一件重要的事情，特别是在生产环境中，建议参阅Docker官网上由Linux发行商提供的最新文档来做出选择。</p><h4 id="3-6-1-Device-Mapper配置"><a href="#3-6-1-Device-Mapper配置" class="headerlink" title="3.6.1 Device Mapper配置"></a><strong>3.6.1 Device Mapper配置</strong></h4><p>&emsp;&emsp;大部分Linux存储驱动不需要或需要很少的配置。但是，Device Mapper通常需要合理配置之后才能表现出良好的性能。</p><p>&emsp;&emsp;默认情况下，Device Mapper采用loopback mounted sparse file作为底层实现来为Docker提供存储支持。如果需要的是开箱即用并且对性能没什么要求，那么这种方式是可行的。但这并不适用于生产环境。实际上，默认方式的性能很差，并不支持生产环境。</p><p>&emsp;&emsp;为了达到Device Mapper在生产环境中的最佳性能，读者需要将底层实现修改为direct-lvm模式。这种模式下通过使用基于裸块设备（Raw Block Device）的LVM精简池（LVM thin pool）来获取更好的性<br>能。</p><p>&emsp;&emsp;在Docker 17.06以及更高的版本中可以配置direct-lvm作为存储驱动，但到当前该方式存在某种限制。其中最主要的一点是，这种方式只能配置一个块设备，并且只有在第一次安装后才能设置生效。未来可能会有改进，但就目前情况来看配置单一块设备这种方式在性能和可靠性上都有一定的风险。</p><h4 id="3-6-2-让Docker自动设置direct-lvm"><a href="#3-6-2-让Docker自动设置direct-lvm" class="headerlink" title="3.6.2 让Docker自动设置direct-lvm"></a><strong>3.6.2 让Docker自动设置direct-lvm</strong></h4><p>&emsp;&emsp;下面的步骤会将Docker配置存储驱动为Device Mapper，并使用direct-lvm模式。</p><p>&emsp;&emsp;（1）将下面的存储驱动配置添加到/etc/docker/daemon.json当中。</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">&#123; </span><br><span class="line">  <span class="attr">"storage-driver"</span>: <span class="string">"devicemapper"</span>, </span><br><span class="line">  <span class="attr">"storage-opts"</span>: [  </span><br><span class="line">    <span class="string">"dm.directlvm_device=/dev/xdf"</span>,  </span><br><span class="line">    <span class="string">"dm.thinp_percent=95"</span>,  </span><br><span class="line">    <span class="string">"dm.thinp_metapercent=1"</span>,  <span class="string">"dm.thinp_autoextend_threshold=80"</span>,  <span class="string">"dm.thinp_autoextend_percent=20"</span>,  <span class="string">"dm.directlvm_device_force=false"</span> </span><br><span class="line">  ] </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>&emsp;&emsp;Device Mapper和LVM是很复杂的知识点，并不在讨论范围之内。下面简单介绍一下各配置项的含义。</p><blockquote><ul><li>dm.directlvm_device：设置了块设备的位置。为了存储的最佳<br>性能以及可用性，块设备应当位于高性能存储设备（如本地SSD） 或者外部RAID存储阵列之上。 </li><li>dm.thinp_percent=95：设置了镜像和容器允许使用的最大存储 空间占比，默认是95%。 </li><li>dm.thinp_metapercent：设置了元数据存储（MetaData Storage）允许使用的存储空间大小。默认是1%。 </li><li>dm.thinp_autoextend_threshold：设置了LVM自动扩展精简池 的阈值，默认是80%。 </li><li>dm.thinp_autoextend_percent：表示当触发精简池（thin pool）自动扩容机制的时候，扩容的大小应当占现有空间的比例。 </li><li>dm.directlvm_device_force：允许用户决定是否将块设备格式 化为新的文件系统。</li></ul></blockquote><p>&emsp;&emsp;（2）重启Docker。</p><p>&emsp;&emsp;（3）确认Docker已成功运行，并且块设备配置已被成功加载。</p><figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ docker version </span><br><span class="line">$ docker<span class="built_in"> system </span>info</span><br></pre></td></tr></table></figure><p>&emsp;&emsp;即使Docker在direct-lvm模式下只能设置单一块设备，其性能也会显著优于loopback模式。</p><h4 id="3-6-3-手动配置Device-Mapper的direct-lvm"><a href="#3-6-3-手动配置Device-Mapper的direct-lvm" class="headerlink" title="3.6.3 手动配置Device Mapper的direct-lvm"></a><strong>3.6.3 手动配置Device Mapper的direct-lvm</strong></h4><p>&emsp;&emsp;完整介绍如何进行Device Mapper direct-lvm的手动配置有些超出范畴。但是，下面列出的内容是我们需要了解并在配置的时候仔细斟酌的。</p><blockquote><ul><li><strong>块设备</strong>（Block Device）：在使用direct-lvm模式的时候，读者需要有可用的块设备。这些块设备应该位于高性能的存储设备之上，比如本地SSD或者外部高性能LUN存储。如果Docker环境部署在企业私有云（On-Premise）之上，那么外部LUN存储可以使用FC、iSCSI，或者其他支持块设备协议的存储阵列。如果Docker环境部署在公有云之上，那么可以采用公有云厂商提供的任何高性能的块设备（通常基于SSD）。 </li><li><strong>LVM</strong>配置：Docker的Device Mapper存储驱动底层利用LVM（Logical Volume Manager）来实现，因此需要配置LVM所需的物理设备、卷组、逻辑卷和精简池。读者应当使用专用的物理卷并将其配置在相同的卷组当中。这个卷组不应当被Docker之外的工作负载所使用。此外还需要配置额外两个逻辑卷，分别用于存储数据和源数据信息。另外，要创建LVM配置文件、指定LVM自动扩容的触发阈值，以及自动扩容的大小，并且为自动扩容配置相应的监控，保证自动扩容会被触发。 </li><li>Docker配置：修改Docker配置文件之前要先保存原始文件（etc/docker/daemon.json），然后再进行修改。读者环境中的dm.thinpooldev配置项对应值可能跟下面的示例内容有所不同，需要修改为合适的配置。</li></ul></blockquote><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&#123;  </span><br><span class="line">  <span class="attr">"storage-driver"</span>: <span class="string">"devicemapper"</span>,  </span><br><span class="line">  <span class="attr">"storage-opts"</span>: [</span><br><span class="line">    <span class="string">"dm.thinpooldev=/dev/mapper/docker-thinpool"</span>,  <span class="string">"dm.use_deferred_removal=true"</span>,  <span class="string">"dm.use_deferred_deletion=true"</span>  </span><br><span class="line">  ] </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>&emsp;&emsp;修改并保存配置后，可以重启Docker daemon。如果想获取更多细节信息，可以参考Docker文档，或者咨询Docker 技术账户管理员。</p><hr><h2 id="第四节-纵观Docker"><a href="#第四节-纵观Docker" class="headerlink" title="第四节 纵观Docker"></a><strong>第四节 纵观Docker</strong></h2><p>&emsp;&emsp;在继续深入研究Docker之前，需要先对Docker进行一个整体介绍。主要包含两部分内容：运维（Ops）视角。 开发（Dev）视角。</p><h3 id="4-1-运维视角"><a href="#4-1-运维视角" class="headerlink" title="4.1 运维视角"></a><strong>4.1 运维视角</strong></h3><p>&emsp;&emsp;在安装Docker的时候，会涉及两个主要组件：Docker客户端和 Docker daemon（有时也被称为“服务端”或者“引擎”）。daemon实现了Docker引擎的API。</p><p>&emsp;&emsp;使用Linux默认安装时，客户端与daemon之间的通信是通过本地IPC/UNIX Socket完成的（/var/run/docker.sock）；在Windows上是通过名为npipe:////./pipe/docker_engine的管道（pipe）完成的。可以使用docker version命令来检测客户端和服务端是否都已经成功运行，并且可以互相通信。</p><p>&emsp;&emsp;如果能成功获取来自客户端和服务端的响应，那么可以继续后面的操作。如果正在使用Linux，并且服务端返回了异常响应，则可尝试在命令的前面加上sudo——sudo docker version。如果加上sudo之后命令正常运行，那么需要将当前用户加入到docker用户组，或者给后面的命令都加上sudo前缀。</p><h4 id="4-1-1-镜像"><a href="#4-1-1-镜像" class="headerlink" title="4.1.1 镜像"></a><strong>4.1.1 镜像</strong></h4><p>&emsp;&emsp;将<strong>Docker镜像</strong>理解为一个包含了OS文件系统和应用的对象会很有帮助，与<strong>虚拟机模板</strong>类似。虚拟机模板本质上是处于关机状态的虚拟机。在Docker世界中，镜像实际上等价于未运行的容器，可以将镜像比作类（Class）。</p><p>&emsp;&emsp;在Docker主机上运行docker image ls命令。</p><figure class="highlight crmsh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ docker image ls </span><br><span class="line">REPOSITORY    <span class="keyword">TAG</span>     <span class="title">IMAGE</span> ID     CREATED     SIZE</span><br></pre></td></tr></table></figure><p>&emsp;&emsp;如果运行命令环境是刚完成Docker安装的主机，或者是Play With Docker，那么Docker主机中应当没有任何镜像，命令输出内容会如上所示。</p><p>&emsp;&emsp;在Docker主机上获取镜像的操作被称为<strong>拉取</strong>（pulling）。如果使用Linux，那么会拉取ubuntu:latest镜像；如果使用Windows，则会拉取microsoft/powershell:nanoserver镜像（本人环境是centos，所以直接docker pull centos）。</p><figure class="highlight groovy"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">latest:</span> Pulling from library/ubuntu </span><br><span class="line"><span class="number">50</span><span class="string">aff78429b1:</span> Pull complete </span><br><span class="line"><span class="string">f6d82e297bce:</span> Pull complete </span><br><span class="line"><span class="number">275</span><span class="string">abb2c8a6f:</span> Pull complete</span><br><span class="line"><span class="number">9</span><span class="string">f15a39356d6:</span> Pull complete </span><br><span class="line"><span class="string">fc0342a94c89:</span> Pull complete </span><br><span class="line"><span class="string">Digest:</span> <span class="string">sha256:</span>fbaf303...c0ea5d1212 </span><br><span class="line"><span class="string">Status:</span> Downloaded newer image <span class="keyword">for</span> <span class="string">ubuntu:</span>latest</span><br></pre></td></tr></table></figure><p>&emsp;&emsp;再次运行docker image ls命令来查看刚刚拉取的镜像。</p><figure class="highlight lsl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">$ docker images </span><br><span class="line">REPOSITORY       TAG      IMAGE ID       CREATED       SIZE </span><br><span class="line">ubuntu           latest   <span class="number">00</span>fd29ccc6f1   <span class="number">3</span> weeks ago   <span class="number">111</span>MB</span><br><span class="line">centos           latest   <span class="number">0</span>f3e07c0138f   <span class="number">2</span> months ago  <span class="number">220</span>MB</span><br></pre></td></tr></table></figure><p>&emsp;&emsp;关于镜像的存储位置以及镜像内部构成，会在后续进行整理。现在只需知道镜像包含了基础操作系统，以及应用程序运行所需的代码和依赖包。刚才拉取的ubuntu镜像有一个精简版的Ubuntu Linux文件系统，其中包含部分Ubuntu常用工具。而Windows示例中拉取的microsoft/powershell镜像，则包含了带有PowerShell的 Windows Nano Server操作系统。如果拉取了如nginx或者microsoft/iis这样的应用容器，则会得到一个包含操作系统的镜像，并且在镜像中还包括了运行Nginx或IIS所需的代码。</p><p>&emsp;&emsp;重要的是，Docker的每个镜像都有自己的唯一ID。用户可以通过引用镜像的ID或名称来使用镜像。如果用户选择使用镜像ID，通常只需要输入ID开头的几个字符即可——因为ID是唯一的，Docker知道用户想引用的具体镜像是哪个。</p><h4 id="4-1-2-容器"><a href="#4-1-2-容器" class="headerlink" title="4.1.2 容器"></a><strong>4.1.2 容器</strong></h4><p>&emsp;&emsp;到目前为止，我们已经拥有一个拉取到本地的镜像，可以使用docker container run命令从镜像来启动容器。</p><p>&emsp;&emsp;在Linux中启动容器的命令如下。</p><figure class="highlight dockerfile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$ docker container <span class="keyword">run</span><span class="bash"> -it ubuntu:latest /bin/bash </span></span><br><span class="line"><span class="bash">$ docker container run -it centos:latest /bin/bash </span></span><br><span class="line"><span class="bash">root@6dc20d508db0:/<span class="comment">#</span></span></span><br></pre></td></tr></table></figure><p>&emsp;&emsp;在Windows中启动容器的命令如下。</p><figure class="highlight dockerfile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&gt; docker container <span class="keyword">run</span><span class="bash"> -it microsoft/powershell:nanoserver pwsh.exe</span></span><br><span class="line"><span class="bash"></span></span><br><span class="line"><span class="bash">Windows PowerShell </span></span><br><span class="line"><span class="bash">Copyright (C) 2016 Microsoft Corporation. All rights reserved. </span></span><br><span class="line"><span class="bash">PS C:\&gt;</span></span><br></pre></td></tr></table></figure><p>&emsp;&emsp;每个实例中的提示符都发生了变化，是因为-it参数会将Shell切换到容器终端，现在已经位于容器内部了。</p><p>&emsp;&emsp;接下来分析一下docker container run命令：docker container run告诉Docker daemon启动新的容器。其中-it参数告诉Docker开启容器的交互模式并将当前的Shell连接到<strong>容器终端</strong>。接下来，命令告诉Docker，用户想基于ubuntu:latest镜像启动容器（如果用户使用Windows，则是基于 microsoft/powershell:nanoserver镜像）。最后，命令告诉Docker，用户想要在容器内部运行哪个进程。对于Linux示例来说是运行Bash Shell，对于Windows示例来说则是运行PowerShell。</p><p>&emsp;&emsp;在容器内部运行ps命令查看当前正在运行的全部进程。</p><p>&emsp;&emsp;Linux示例如下。</p><figure class="highlight tap"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">root@6dc20d508db0:/<span class="comment"># ps -elf </span></span><br><span class="line">F S UID    PID  PPID   NI ADDR SZ WCHAN  STIME TTY  TIME CMD </span><br><span class="line">4 S root    <span class="number"> 1 </span>   <span class="number"> 0 </span>  <span class="number"> 0 </span>- <span class="number"> 4560 </span>wait   13:38 ?    00:00:00 /bin/bash </span><br><span class="line">0 R root    <span class="number"> 9 </span>   <span class="number"> 1 </span>  <span class="number"> 0 </span>- <span class="number"> 8606 </span>-      13:38 ?    00:00:00 ps -elf</span><br></pre></td></tr></table></figure><p>&emsp;&emsp;Windows示例如下。</p><figure class="highlight tap"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">PS C:\&gt; ps</span><br><span class="line"></span><br><span class="line">Handles   NPM(K)   PM(K)   WS(K)   CPU(s)     Id   SI ProcessName </span><br><span class="line">-------   ------   -----   -----   ------     --   -- ----------      </span><br><span class="line">     <span class="number"> 0 </span>      <span class="number"> 5 </span>   <span class="number"> 964 </span>  <span class="number"> 1292 </span>    0.00  <span class="number"> 4716 </span>  <span class="number"> 4 </span>CExecSvc      </span><br><span class="line">     <span class="number"> 0 </span>      <span class="number"> 5 </span>   <span class="number"> 592 </span>   <span class="number"> 956 </span>    0.00  <span class="number"> 4524 </span>  <span class="number"> 4 </span>csrss      </span><br><span class="line">     <span class="number"> 0 </span>      <span class="number"> 0 </span>     <span class="number"> 0 </span>     <span class="number"> 4 </span>             <span class="number"> 0 </span>  <span class="number"> 0 </span>Idle      </span><br><span class="line">     <span class="number"> 0 </span>     <span class="number"> 18 </span>  <span class="number"> 3984 </span>  <span class="number"> 8624 </span>    0.13   <span class="number"> 700 </span>  <span class="number"> 4 </span>lsass      </span><br><span class="line">     <span class="number"> 0 </span>     <span class="number"> 52 </span> <span class="number"> 26624 </span> <span class="number"> 19400 </span>    1.64  <span class="number"> 2100 </span>  <span class="number"> 4 </span>powershell      </span><br><span class="line">     <span class="number"> 0 </span>     <span class="number"> 38 </span> <span class="number"> 28324 </span> <span class="number"> 49616 </span>    1.69  <span class="number"> 4464 </span>  <span class="number"> 4 </span>powershell      </span><br><span class="line">     <span class="number"> 0 </span>      <span class="number"> 8 </span>  <span class="number"> 1488 </span>  <span class="number"> 3032 </span>    0.06  <span class="number"> 2488 </span>  <span class="number"> 4 </span>services      </span><br><span class="line">     <span class="number"> 0 </span>      <span class="number"> 2 </span>   <span class="number"> 288 </span>   <span class="number"> 504 </span>    0.00  <span class="number"> 4508 </span>  <span class="number"> 0 </span>smss      </span><br><span class="line">     <span class="number"> 0 </span>      <span class="number"> 8 </span>  <span class="number"> 1600 </span>  <span class="number"> 3004 </span>    0.03   <span class="number"> 908 </span>  <span class="number"> 4 </span>svchost      </span><br><span class="line">     <span class="number"> 0 </span>     <span class="number"> 12 </span>  <span class="number"> 1492 </span>  <span class="number"> 3504 </span>    0.06  <span class="number"> 4572 </span>  <span class="number"> 4 </span>svchost      </span><br><span class="line">     <span class="number"> 0 </span>     <span class="number"> 15 </span> <span class="number"> 20284 </span> <span class="number"> 23428 </span>    5.64  <span class="number"> 4628 </span>  <span class="number"> 4 </span>svchost      </span><br><span class="line">     <span class="number"> 0 </span>     <span class="number"> 15 </span>  <span class="number"> 3704 </span>  <span class="number"> 7536 </span>    0.09  <span class="number"> 4688 </span>  <span class="number"> 4 </span>svchost      </span><br><span class="line">     <span class="number"> 0 </span>     <span class="number"> 28 </span>  <span class="number"> 5708 </span>  <span class="number"> 6588 </span>    0.45  <span class="number"> 4712 </span>  <span class="number"> 4 </span>svchost      </span><br><span class="line">     <span class="number"> 0 </span>     <span class="number"> 10 </span>  <span class="number"> 2028 </span>  <span class="number"> 4736 </span>    0.03  <span class="number"> 4840 </span>  <span class="number"> 4 </span>svchost      </span><br><span class="line">     <span class="number"> 0 </span>     <span class="number"> 11 </span>  <span class="number"> 5364 </span>  <span class="number"> 4824 </span>    0.08  <span class="number"> 4928 </span>  <span class="number"> 4 </span>svchost      </span><br><span class="line">     <span class="number"> 0 </span>      <span class="number"> 0 </span>   <span class="number"> 128 </span>   <span class="number"> 136 </span>   37.02     <span class="number"> 4 </span>  <span class="number"> 0 </span>System      </span><br><span class="line">     <span class="number"> 0 </span>      <span class="number"> 7 </span>   <span class="number"> 920 </span>  <span class="number"> 1832 </span>    0.02  <span class="number"> 3752 </span>  <span class="number"> 4 </span>wininit      </span><br><span class="line">     <span class="number"> 0 </span>      <span class="number"> 8 </span>  <span class="number"> 5472 </span> <span class="number"> 11124 </span>    0.77  <span class="number"> 5568 </span>  <span class="number"> 4 </span>WmiPrvSE</span><br></pre></td></tr></table></figure><p>&emsp;&emsp;Linux容器中仅包含两个进程。</p><blockquote><ul><li>PID 1：代表/bin/bash进程，该进程是通过docker container run命令来通知容器运行的。 </li><li>PID 9：代表ps -elf进程，查看当前运行中进程所使用的命令/程序。</li></ul></blockquote><p>&emsp;&emsp;命令输出中展示的ps -elf进程存在一定的误导，因为这个程序在ps命令退出后就结束了。这意味着容器内长期运行的进程其实只有/bin/bash。</p><p>&emsp;&emsp;Windows容器运行中的进程会更多，这是由 Windows 操作系统工作方式决定的。虽然Windows容器中的进程比Linux容器要多，但与常见的Windows服务器相比，其进程数量却是明显偏少的。</p><p>&emsp;&emsp;按Ctrl-PQ组合键，可以在退出容器的同时还保持容器运行。这样Shell就会返回到Docker主机终端。可以通过查看Shell提示符来确认。</p><p>&emsp;&emsp;现在已经返回到Docker主机的Shell提示符，再次运行ps命令。</p><p>&emsp;&emsp;Linux示例如下。</p><figure class="highlight tap"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">$ ps -elf </span><br><span class="line">F S UID       PID  PPID    NI ADDR SZ WCHAN  TIME CMD </span><br><span class="line">4 S root       <span class="number"> 1 </span>   <span class="number"> 0 </span>   <span class="number"> 0 </span>- <span class="number"> 9407 </span>-      00:00:03 /sbin/init </span><br><span class="line">1 S root       <span class="number"> 2 </span>   <span class="number"> 0 </span>   <span class="number"> 0 </span>-    <span class="number"> 0 </span>-      00:00:00 [kthreadd] </span><br><span class="line">1 S root       <span class="number"> 3 </span>   <span class="number"> 2 </span>   <span class="number"> 0 </span>-    <span class="number"> 0 </span>-      00:00:00 [ksoftirqd/0] </span><br><span class="line">1 S root       <span class="number"> 5 </span>   <span class="number"> 2 </span>    -20    <span class="number"> 0 </span>-      00:00:00 [kworker/0:0H] </span><br><span class="line">1 S root       <span class="number"> 7 </span>   <span class="number"> 2 </span>   -0 -    <span class="number"> 0 </span>-      00:00:00 [rcu_sched] </span><br><span class="line">&lt;Snip&gt; </span><br><span class="line">0 R ubuntu <span class="number"> 22783 </span>22475    <span class="number"> 0 </span>- <span class="number"> 9021 </span>-      00:00:00 ps -elf</span><br></pre></td></tr></table></figure><p>&emsp;&emsp;Windows示例如下。</p><figure class="highlight lsl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">&gt; ps </span><br><span class="line">Handles   NPM(K)    PM(K)    WS(K)    CPU(s)     Id  SI ProcessName </span><br><span class="line">-------   ------    -----    -----    ------     --  -- ----------    </span><br><span class="line">    <span class="number">220</span>       <span class="number">11</span>     <span class="number">7396</span>     <span class="number">7872</span>      <span class="number">0.33</span>   <span class="number">1732</span>   <span class="number">0</span> amazon-ssm-agen     </span><br><span class="line">     <span class="number">84</span>        <span class="number">5</span>      <span class="number">908</span>     <span class="number">2096</span>      <span class="number">0.00</span>   <span class="number">2428</span>   <span class="number">3</span> CExecSvc     </span><br><span class="line">     <span class="number">87</span>        <span class="number">5</span>      <span class="number">936</span>     <span class="number">1336</span>      <span class="number">0.00</span>   <span class="number">4716</span>   <span class="number">4</span> CExecSvc    </span><br><span class="line">    <span class="number">203</span>       <span class="number">13</span>     <span class="number">3600</span>    <span class="number">13132</span>      <span class="number">2.53</span>   <span class="number">3192</span>   <span class="number">2</span> conhost</span><br><span class="line">    <span class="number">210</span>       <span class="number">13</span>     <span class="number">3768</span>    <span class="number">22948</span>      <span class="number">0.08</span>   <span class="number">5260</span>   <span class="number">2</span> conhost    </span><br><span class="line">    <span class="number">257</span>       <span class="number">11</span>     <span class="number">1808</span>      <span class="number">992</span>      <span class="number">0.64</span>    <span class="number">524</span>   <span class="number">0</span> csrss    </span><br><span class="line">    <span class="number">116</span>        <span class="number">8</span>     <span class="number">1348</span>       <span class="number">580</span>     <span class="number">0.08</span>    <span class="number">592</span>   <span class="number">1</span> csrss     </span><br><span class="line">     <span class="number">85</span>        <span class="number">5</span>      <span class="number">532</span>      <span class="number">1136</span>     <span class="number">0.23</span>   <span class="number">2440</span>   <span class="number">3</span> csrss    </span><br><span class="line">    <span class="number">242</span>       <span class="number">11</span>     <span class="number">1848</span>       <span class="number">952</span>     <span class="number">0.42</span>   <span class="number">2708</span>   <span class="number">2</span> csrss     </span><br><span class="line">     <span class="number">95</span>        <span class="number">5</span>      <span class="number">592</span>       <span class="number">980</span>     <span class="number">0.00</span>   <span class="number">4524</span>   <span class="number">4</span> csrss    </span><br><span class="line">    <span class="number">137</span>        <span class="number">9</span>     <span class="number">7784</span>      <span class="number">6776</span>     <span class="number">0.05</span>   <span class="number">5080</span>   <span class="number">2</span> docker    </span><br><span class="line">    <span class="number">401</span>       <span class="number">17</span>    <span class="number">22744</span>     <span class="number">14016</span>    <span class="number">28.59</span>   <span class="number">1748</span>   <span class="number">0</span> dockerd    </span><br><span class="line">    <span class="number">307</span>       <span class="number">18</span>    <span class="number">13344</span>      <span class="number">1628</span>     <span class="number">0.17</span>    <span class="number">936</span>   <span class="number">1</span> dwm    </span><br><span class="line">    &lt;SNIP&gt;   </span><br><span class="line">   <span class="number">1888</span>        <span class="number">0</span>      <span class="number">128</span>       <span class="number">136</span>    <span class="number">37.17</span>      <span class="number">4</span>   <span class="number">0</span> System    </span><br><span class="line">    <span class="number">272</span>       <span class="number">15</span>     <span class="number">3372</span>      <span class="number">2452</span>     <span class="number">0.23</span>   <span class="number">3340</span>   <span class="number">2</span> TabTip     </span><br><span class="line">     <span class="number">72</span>        <span class="number">7</span>     <span class="number">1184</span>         <span class="number">8</span>     <span class="number">0.00</span>   <span class="number">3400</span>   <span class="number">2</span> TabTip32    </span><br><span class="line">    <span class="number">244</span>       <span class="number">16</span>     <span class="number">2676</span>      <span class="number">3148</span>     <span class="number">0.06</span>   <span class="number">1880</span>   <span class="number">2</span> taskhostw    </span><br><span class="line">    <span class="number">142</span>        <span class="number">7</span>     <span class="number">6172</span>      <span class="number">6680</span>     <span class="number">0.78</span>   <span class="number">4952</span>   <span class="number">3</span> WmiPrvSE    </span><br><span class="line">    <span class="number">148</span>        <span class="number">8</span>     <span class="number">5620</span>     <span class="number">11028</span>     <span class="number">0.77</span>   <span class="number">5568</span>   <span class="number">4</span> WmiPrvSE</span><br></pre></td></tr></table></figure><p>&emsp;&emsp;可以看到与容器相比，Docker主机中运行的进程数要多很多。 Windows容器中运行的进程要远少于Windows主机，Linux容器中的进程数也远少于Linux主机。</p><p>&emsp;&emsp;在之前的步骤当中，是使用Ctrl-PQ组合键来退出容器的。在容器内部使用该操作可以退出当前容器，但不会杀死容器进程。可以通过docker container ls命令查看系统内全部处于运行状态的容器。</p><figure class="highlight mel"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$ docker <span class="keyword">container</span> <span class="keyword">ls</span> </span><br><span class="line">CONTAINER ID   IMAGE          COMMAND      CREATED  STATUS    NAMES </span><br><span class="line">e2b69eeb55cb   ubuntu:latest  <span class="string">"/bin/bash"</span>  <span class="number">7</span> mins   Up <span class="number">7</span> <span class="keyword">min</span>  vigilant_borg</span><br></pre></td></tr></table></figure><p>&emsp;&emsp;上述的输出显示只有一个运行中的容器，就是前面示例中创建的那个容器，证明了容器在退出后依然是运行的。</p><h4 id="4-1-3-连接到运行中的容器"><a href="#4-1-3-连接到运行中的容器" class="headerlink" title="4.1.3 连接到运行中的容器"></a><strong>4.1.3 连接到运行中的容器</strong></h4><p>&emsp;&emsp;执行docker container exec命令，可以将Shell连接到一个运行中的容器终端。因为之前示例中的容器仍在运行，所以下面的示例会创建到该容器的新连接。</p><p>&emsp;&emsp;Linux示例如下。</p><figure class="highlight elixir"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable">$ </span>docker container exec -it vigilant_borg bash </span><br><span class="line">root<span class="variable">@e2b69eeb55cb</span><span class="symbol">:/</span><span class="comment">#</span></span><br></pre></td></tr></table></figure><p>&emsp;&emsp;示例中的容器名为“vigilant_brog”。每个人环境中的容器名称会不同（本机是thirsty_hermann），所以请记得将“vigilant_brog”替换为自己Docker主机上运行中的容器名称或者ID。</p><p>&emsp;&emsp;Windows示例如下。</p><figure class="highlight mathematica"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&gt; docker container exec -it pensive_hamilton pwsh.exe</span><br><span class="line"></span><br><span class="line">Windows PowerShell </span><br><span class="line">Copyright (<span class="keyword">C</span>) <span class="number">2016</span> Microsoft Corporation. <span class="keyword">All</span> rights reserved. </span><br><span class="line">PS <span class="keyword">C</span>:\&gt;</span><br></pre></td></tr></table></figure><p>&emsp;&emsp;注意，Shell提示符又发生了变化。此时已登录到了容器内部。docker container exec命令的格式是docker container exec \<options> \<container-name or="" container-id=""> \&lt;command/app&gt;。在示例中，将本地Shell连接到容器是通过-it参数实现的。本例中使用名称引用容器，并且告诉Docker运行Bash Shell（在Windows示例中是 PowerShell）。使用十六进制ID的方式也可以很容易地引用具体容器。</container-name></options></p><p>&emsp;&emsp;再次使用Ctrl-PQ组合键退出容器。Shell提示符应当退回到Docker主机中。</p><p>&emsp;&emsp;再次运行docker container ls命令来确认容器仍处于运行状态。</p><figure class="highlight mel"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ docker <span class="keyword">container</span> <span class="keyword">ls</span> CONTAINER ID   IMAGE          COMMAND      CREATED  STATUS    NAMES e2b69eeb55cb   ubuntu:latest  <span class="string">"/bin/bash"</span>  <span class="number">9</span> mins   Up <span class="number">9</span> <span class="keyword">min</span>  vigilant_borg</span><br></pre></td></tr></table></figure><p>&emsp;&emsp;通过docker container stop和docker container rm命令来停止并杀死容器。切记需要将示例中的名称/ID替换为读者自己的容器对应的名称和ID。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> docker container stop vigilant_borg vigilant_borg</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> docker container rm vigilant_borg vigilant_borg</span></span><br></pre></td></tr></table></figure><p>&emsp;&emsp;通过运行docker container ls命令，并指定-a参数来确认容器 已经被成功删除。添加-a的作用是让Docker列出所有容器，甚至包括那些处于停止状态的。</p><figure class="highlight inform7"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ docker <span class="keyword">container</span> ls -a </span><br><span class="line"><span class="keyword">CONTAINER</span> ID    IMAGE    COMMAND    CREATED    STATUS    PORTS    NAMES</span><br></pre></td></tr></table></figure><h3 id="4-2-开发视角"><a href="#4-2-开发视角" class="headerlink" title="4.2 开发视角"></a><strong>4.2 开发视角</strong></h3><p>&emsp;&emsp;<strong>容器即应用！</strong>，接下来会分析一份应用代码中的Dockerfile并将其容器化，最终以容器的方式运行。</p><p>&emsp;&emsp;进入到仓库文件目录之下，查看其内容。</p><figure class="highlight tap"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">$ cd psweb </span><br><span class="line">$ ls -l </span><br><span class="line">total<span class="number"> 28 </span></span><br><span class="line">-rw-rw-r--<span class="number"> 1 </span>ubuntu ubuntu <span class="number"> 341 </span>Sep<span class="number"> 29 </span>12:15 app.js </span><br><span class="line">-rw-rw-r--<span class="number"> 1 </span>ubuntu ubuntu <span class="number"> 216 </span>Sep<span class="number"> 29 </span>12:15 circle.yml </span><br><span class="line">-rw-rw-r--<span class="number"> 1 </span>ubuntu ubuntu <span class="number"> 338 </span>Sep<span class="number"> 29 </span>12:15 Dockerfile </span><br><span class="line">-rw-rw-r--<span class="number"> 1 </span>ubuntu ubuntu <span class="number"> 421 </span>Sep<span class="number"> 29 </span>12:15 package.json </span><br><span class="line">-rw-rw-r--<span class="number"> 1 </span>ubuntu ubuntu <span class="number"> 370 </span>Sep<span class="number"> 29 </span>12:15 README.md </span><br><span class="line">drwxrwxr-x<span class="number"> 2 </span>ubuntu ubuntu<span class="number"> 4096 </span>Sep<span class="number"> 29 </span>12:15 test </span><br><span class="line">drwxrwxr-x<span class="number"> 2 </span>ubuntu ubuntu<span class="number"> 4096 </span>Sep<span class="number"> 29 </span>12:15 views</span><br></pre></td></tr></table></figure><p>&emsp;&emsp;Linux的示例是一个简单的Node.js Web应用。Windows示例是一个简单的ASP.NET Web应用。每个仓库中都包含一个名为Dockerfile的文件。Dockerfile是一个纯文本文件，其中描述了如何将应用构建到Docker镜像当中。</p><p>&emsp;&emsp;查看Dockerfile的全部内容。</p><figure class="highlight dockerfile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">$ cat Dockerfile</span><br><span class="line"></span><br><span class="line"><span class="keyword">FROM</span> alpine </span><br><span class="line"><span class="keyword">LABEL</span><span class="bash"> maintainer=<span class="string">"nigelpoulton@hotmail.com"</span> </span></span><br><span class="line"><span class="bash">RUN apk add --update nodejs nodejs-npm </span></span><br><span class="line"><span class="bash">COPY . /src </span></span><br><span class="line"><span class="bash">WORKDIR /src </span></span><br><span class="line"><span class="bash">RUN  npm install </span></span><br><span class="line"><span class="bash">EXPOSE  8080 </span></span><br><span class="line"><span class="bash">ENTRYPOINT [<span class="string">"node"</span>, <span class="string">"./app.js"</span>]</span></span><br></pre></td></tr></table></figure><p>&emsp;&emsp;现在只需要知道Dockerfile的每一行都代表一个用于构建镜像的指令即可。使用docker image build命令，根据Dockerfile中的指令来创建新的镜像。示例中新建的Docker镜像名为test:latest。一定要在包含应用代码和Dockerfile的目录下执行这些命令。</p><figure class="highlight vim"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">$ docker image build -t tes<span class="variable">t:latest</span> .</span><br><span class="line"></span><br><span class="line">Sending build context <span class="keyword">to</span> Docker daemon <span class="number">74.75</span>kB </span><br><span class="line">Step <span class="number">1</span>/<span class="number">8</span> : FROM alpine </span><br><span class="line">lates<span class="variable">t:</span> Pulling from library/alpine </span><br><span class="line"><span class="number">88286</span>f41530e: Pull <span class="built_in">complete</span> </span><br><span class="line">Diges<span class="variable">t:</span> <span class="built_in">sha256</span>:f006ecbb824...<span class="number">0</span>c103f4820a417d </span><br><span class="line">Statu<span class="variable">s:</span> Downloaded newer image <span class="keyword">for</span> alpine:latest </span><br><span class="line"> ---&gt; <span class="number">76</span>da55c8019d </span><br><span class="line"><span class="symbol">&lt;Snip&gt;</span></span><br><span class="line">Successfully built f154cb3ddbd4 </span><br><span class="line">Successfully tagged tes<span class="variable">t:latest</span></span><br></pre></td></tr></table></figure><p>&emsp;&emsp;一旦构建完成，就可以确认主机上是否存在test:latest镜像。</p><figure class="highlight subunit"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">$ docker image ls </span><br><span class="line">REPO     TAG        IMAGE ID         CREATED         SIZE </span><br><span class="line"><span class="keyword">Test     </span>latest     f154cb3ddbd4     1 minute ago    55.6MB </span><br><span class="line">...</span><br></pre></td></tr></table></figure><p>&emsp;&emsp;现在已经拥有一个新的Docker镜像，其中包含了应用程序。从镜像启动容器，并测试应用。Linux代码如下。</p><figure class="highlight haml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">$ docker container run -d \  </span><br><span class="line">  -<span class="ruby">-name web1 \  </span></span><br><span class="line"><span class="ruby">  --publish <span class="number">8080</span><span class="symbol">:</span><span class="number">8080</span> \ </span></span><br><span class="line"><span class="ruby">  <span class="symbol">test:</span>latest</span></span><br></pre></td></tr></table></figure><p>&emsp;&emsp;打开Web浏览器，在地址栏中输入容器运行所在的Docker主机的DNS名称或者IP地址，并在后面加上端口号8080。然后就能看到图4.1的Web页面。</p><p><img src="https://pic-1258215793.cos.ap-shanghai.myqcloud.com/content/20191001/201910010112.png" alt="Linux系统测试应用Web界面"></p><p>&emsp;&emsp;Windows代码如下。</p><figure class="highlight haml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&gt; docker container run -d \  </span><br><span class="line">  -<span class="ruby">-name web1 \  </span></span><br><span class="line"><span class="ruby">  --publish <span class="number">8080</span><span class="symbol">:</span><span class="number">80</span> \  </span></span><br><span class="line"><span class="ruby">  <span class="symbol">test:</span>latest</span></span><br></pre></td></tr></table></figure><p>&emsp;&emsp;打开Web浏览器，在地址栏中输入容器运行所在的Docker主机的DNS名称或者IP地址，并在后面加上端口号8080，然后就能看到图4.2的Web页面。</p><p><img src="https://pic-1258215793.cos.ap-shanghai.myqcloud.com/content/20191001/201910010112.png" alt="Windows系统测试应用Web界面"></p><p>&emsp;&emsp;已经成功将应用代码构建到了Docker镜像当中，然后以容器的方式启动该镜像，这个过程叫作<strong>应用容器化</strong>。</p><hr><p><em>参考博客和文章书籍等：</em></p><blockquote><p>《深入浅出Docker》</p></blockquote><p><em>因博客主等未标明不可引用，若部分内容涉及侵权请及时告知，我会尽快修改和删除相关内容</em></p>]]></content>
    
    <summary type="html">
    
      简单介绍Docker概览（一）容器，内容包括：等。
    
    </summary>
    
      <category term="技术文档" scheme="http://linyishui.top/categories/%E6%8A%80%E6%9C%AF%E6%96%87%E6%A1%A3/"/>
    
    
      <category term="docker" scheme="http://linyishui.top/tags/docker/"/>
    
  </entry>
  
  <entry>
    <title>函数式编程的技巧</title>
    <link href="http://linyishui.top/2019100401.html"/>
    <id>http://linyishui.top/2019100401.html</id>
    <published>2019-10-04T07:12:28.000Z</published>
    <updated>2019-12-06T02:57:01.771Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="函数式编程的技巧"><a href="#函数式编程的技巧" class="headerlink" title="函数式编程的技巧"></a><strong>函数式编程的技巧</strong></h1><h2 id="第一节-无处不在的函数"><a href="#第一节-无处不在的函数" class="headerlink" title="第一节 无处不在的函数"></a><strong>第一节 无处不在的函数</strong></h2><p>&emsp;&emsp;我们知道函数式编程是指函数或方法的行为就像数学函数一样——没有任何副作用。对于程序员来说，这个术语还意味着函数可以像任何其他值一样随意使用：可以作为参数传递，可以作为返回值，还能存储在数据结构中。能够像普通变量一样使用的函数被称为<strong>一等函数</strong>，通过操作符\:\:创建的方法引用，可以像使用函数值一样使用方法，也能使用Lambda表达式直接表示方法的值。</p><h3 id="1-1-高阶函数"><a href="#1-1-高阶函数" class="headerlink" title="1.1 高阶函数"></a><strong>1.1 高阶函数</strong></h3><p>&emsp;&emsp;在之前我们使用一等函数只是为了将代码传递给流处理操作，达到行为参数化的效果。我们可以接受函数作为参数同时返回另一个函数。</p><figure class="highlight lisp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Comparator&lt;Apple&gt; c = comparing(<span class="name">Apple</span>:<span class="symbol">:getWeight</span>)<span class="comment">;</span></span><br></pre></td></tr></table></figure><p><img src="https://pic-1258215793.cos.ap-shanghai.myqcloud.com/content/20191001/201910010107.png" alt="comparing方法接受一个函数作为参数同时返回另一个函数"></p><p>&emsp;&emsp;在Java 8中函数不仅可以作为参数传递，也可以作为结果返回，能赋值给本地变量，也可以插入到某个数据结构。comparing方法是一个高阶函数，我们知道传递给流的操作应该是无副作用的，高阶函数也适用这一原则。</p><blockquote><p>高阶函数要满足的要求：</p><ul><li>接受至少一个函数作为参数</li><li>返回的结果是一个函数</li></ul></blockquote><h3 id="1-2-科里化"><a href="#1-2-科里化" class="headerlink" title="1.2 科里化"></a><strong>1.2 科里化</strong></h3><p>&emsp;&emsp;科里化是一种可以帮助我们模块化函数、提高代码重用性的技术。</p><p>&emsp;&emsp;假设我们需要实现单位转换的需求，一般单位转换会涉及到转换因子以及基线调整，如摄氏度转换为华氏度：CtoF(x)=x*9/5 + 32。</p><figure class="highlight aspectj"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 单位转换</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> x 需要转换的值</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> f 转换因子</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> b 基线值</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> 结果</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">static</span> <span class="function"><span class="keyword">double</span> <span class="title">converter</span><span class="params">(<span class="keyword">double</span> x, <span class="keyword">double</span> f, <span class="keyword">double</span> b)</span></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> x * f + b;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>&emsp;&emsp;但一些情况下（如公里和英里转换），可能不会同时用到三个参数，这时我们可能首先想到的是方法重载，但其实有一些更简单的办法。如下列curriedConverter方法，可以生产带一个参数的转换方法，这样一来我们就复用了转换逻辑，代码也更灵活了。</p><figure class="highlight aspectj"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 工厂方法生产单位转换公式</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> f 转换因子</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> b 基线值</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> 单位转换公式</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">static</span> <span class="function">DoubleUnaryOperator <span class="title">curriedConverter</span><span class="params">(<span class="keyword">double</span> f, <span class="keyword">double</span> b)</span></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> (<span class="keyword">double</span> x) -&gt; x * f + b;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="function"><span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">    DoubleUnaryOperator converterCtoF = curriedConverter(<span class="number">9.0</span>/<span class="number">5</span>, <span class="number">32</span>);</span><br><span class="line">    DoubleUnaryOperator converterUSDtoGBP= curriedConverter(<span class="number">0.6</span>, <span class="number">0</span>);</span><br><span class="line">    DoubleUnaryOperator converterKmtoMi = curriedConverter(<span class="number">0.6214</span>, <span class="number">0</span>);</span><br><span class="line">    <span class="keyword">double</span> c = converterCtoF.applyAsDouble(<span class="number">100</span>);<span class="comment">//212.0</span></span><br><span class="line">    <span class="keyword">double</span> gbp = converterUSDtoGBP.applyAsDouble(<span class="number">1000</span>);<span class="comment">//600.0</span></span><br><span class="line">    <span class="keyword">double</span> km = converterKmtoMi.applyAsDouble(<span class="number">1</span>_000_000);<span class="comment">//621400.0</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>&emsp;&emsp;科里化是一种将具备2个参数的函数f转换为使用一个参数的函数g，并且这个函数的返回值也是一个函数，它会作为新函数的一个参数。后者的返回值和初始函数的返回值相同，即f(x, y) = (g(x))(y)。所以我们可以把一个有6个参数的函数科里化为一个接受2、4、6号参数，并返回一个接受5号参数的函数，这个返回的函数又返回一个接受剩下的1号和3号参数的函数。</p><hr><h2 id="第二节-持久化数据结构"><a href="#第二节-持久化数据结构" class="headerlink" title="第二节 持久化数据结构"></a><strong>第二节 持久化数据结构</strong></h2><p>&emsp;&emsp;函数式编程中常见的数据结构叫法：函数式数据结构，不可变数据结构，持久化数据结构。函数式方法不允许修改任何全局数据结构或者任何作为参数传入的结构，一旦允许对这些数据进行修改，那么多次调用就可能得到不同的结构，这违背了引用透明性原则，我们也就无法将方法简单的看作从参数到结果的映射。</p><h3 id="2-1-破坏式更新和函数式更新的比较"><a href="#2-1-破坏式更新和函数式更新的比较" class="headerlink" title="2.1 破坏式更新和函数式更新的比较"></a><strong>2.1 破坏式更新和函数式更新的比较</strong></h3><p>&emsp;&emsp;假设我们要对火车旅行从A地到B地进行建模，代码如下。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 单向链表实现对火车旅行建模</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TrainJourney</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">int</span> price;<span class="comment">//当前路途段价格</span></span><br><span class="line">    <span class="keyword">public</span> TrainJourney onward;<span class="comment">//下一段路途</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">TrainJourney</span><span class="params">(<span class="keyword">int</span> p, TrainJourney t)</span></span>&#123;</span><br><span class="line">        price = p;</span><br><span class="line">        onward = t;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 将代表X到Y和Y到Z两段路途串接起来</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> a 路途段a</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> b 路途段b</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> 新的路途段</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">static</span> TrainJourney <span class="title">link</span><span class="params">(TrainJourney a, TrainJourney b)</span></span>&#123;</span><br><span class="line">        <span class="comment">//a为空则直接返回b</span></span><br><span class="line">        <span class="keyword">if</span>(a == <span class="keyword">null</span>) <span class="keyword">return</span> b;</span><br><span class="line">        TrainJourney t = a;</span><br><span class="line">        <span class="keyword">while</span> (t.onward != <span class="keyword">null</span>)&#123;</span><br><span class="line">            <span class="comment">//当a的下个路途段不为空时，将t引用指向下个路途段</span></span><br><span class="line">            t = t.onward;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//将a路途段链表的最后一节指向b路途段</span></span><br><span class="line">        t.onward = b;</span><br><span class="line">        <span class="keyword">return</span> a;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>&emsp;&emsp;link方法有一个问题，它会破坏性的更新a，让b加入到a的链表中，执行后a不再表示从X到Y的路途段，而是新的X到Z的路途段。所以现实中可能会导致什么问题？本来应该从X到Y的旅客，因为数据被破坏了会多坐几站到最新的终点站。</p><p>&emsp;&emsp;函数式编程要杜绝这种带副作用的方法，为了计算需要创建现存数据结构的副本，这样的做法也适用于标准的面向对象程序设计。当然有异议的是这样可能会导致过度的对象复制，可能你会说你记住了这个副作用，在别处会注意这个缺陷，但最终还是挖坑留给了维护人员。我们通过递归的方式改写link方法，代码如下。</p><figure class="highlight aspectj"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 递归函数式的将代表X到Y和Y到Z两段路途串接起来</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> a 路途段a</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> b 路途段b</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> 新的路途段</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">static</span> <span class="function">TrainJourney <span class="title">append</span><span class="params">(TrainJourney a, TrainJourney b)</span></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> a == <span class="keyword">null</span> ? b : <span class="keyword">new</span> TrainJourney(a.price, append(a.onward, b));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>&emsp;&emsp;append方法是函数式的，而且并未创建整个新TrainJourney对象的副本：如果a是n个元素的序列，b是m个元素的序列，那么调用此函数后，返回的是一个n+m个元素的序列，这个序列的前n个元素是新创建的，而后m个元素是和b共享的。要注意的是，append方法生成的结果不能被用户破坏，否则会影响到b的使用者。</p><p><img src="https://pic-1258215793.cos.ap-shanghai.myqcloud.com/content/20191001/201910010108.png" alt="破坏式和函数式数据结构对比"></p><h3 id="2-2-案例：二叉查找树"><a href="#2-2-案例：二叉查找树" class="headerlink" title="2.2 案例：二叉查找树"></a><strong>2.2 案例：二叉查找树</strong></h3><p>&emsp;&emsp;我们实现一个二叉查找树，代码如下。</p><figure class="highlight zephir"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 二叉查找树</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Tree</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> String key;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> val;</span><br><span class="line">    <span class="keyword">private</span> Tree left,right;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//构造器和成员方法</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TreeProcessor</span> </span>&#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 查找树中给定字符串对应键值的整型value</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> k 给定字符串</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> defaultval 默认value</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> t 二叉查找树</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> 对应整型value</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> lookup(String k, <span class="keyword">int</span> defaultval, Tree t)&#123;</span><br><span class="line">        <span class="keyword">if</span> (t == <span class="keyword">null</span>) <span class="keyword">return</span> defaultval;</span><br><span class="line">        <span class="keyword">if</span> (k.equals(t.getKey())) <span class="keyword">return</span> t.getVal();</span><br><span class="line">        <span class="keyword">return</span> lookup(k, defaultval, k.compareTo(t.getKey()) &lt; <span class="number">0</span> ? t.getLeft() : t.getRight());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//处理Tree的其他方法</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>&emsp;&emsp;如果需要对映射中指定键对应的值做更新，我们可能会如下列代码实现。</p><figure class="highlight haxe"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 更新键对应值</span></span><br><span class="line"><span class="comment"> * @param k 给定字符串</span></span><br><span class="line"><span class="comment"> * @param newval 新值</span></span><br><span class="line"><span class="comment"> * @param t 二叉查找树</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> void update(<span class="keyword">String</span> k, int <span class="keyword">new</span><span class="type">val</span>, Tree t)&#123;</span><br><span class="line">    <span class="keyword">if</span> (t == <span class="literal">null</span>)&#123;</span><br><span class="line">        <span class="comment">/* 增加一个新的节点 */</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (k.equals(t.getKey())) t.setVal(<span class="keyword">new</span><span class="type">val</span>);</span><br><span class="line">    <span class="keyword">else</span> update(k, <span class="keyword">new</span><span class="type">val</span>, k.compareTo(t.getKey()) &lt; <span class="number">0</span> ? t.getLeft() : <span class="type">t</span>.getRight());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>&emsp;&emsp;新增节点最简单的方法是在递归过程中让update直接返回其刚遍历的树，如下列代码所示。</p><figure class="highlight haxe"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> Tree update(<span class="keyword">String</span> k, int <span class="keyword">new</span><span class="type">val</span>, Tree t)&#123;</span><br><span class="line">    <span class="keyword">if</span> (t == <span class="literal">null</span>)&#123;</span><br><span class="line">        t = <span class="keyword">new</span> <span class="type">Tree</span>(k, <span class="keyword">new</span><span class="type">val</span>, <span class="literal">null</span>, <span class="literal">null</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (k.equals(t.getKey())) t.setVal(<span class="keyword">new</span><span class="type">val</span>);</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> ( k.compareTo(t.getKey()) &lt; <span class="number">0</span>) t.setLeft(update(k, <span class="keyword">new</span><span class="type">val</span>, t.getLeft()));</span><br><span class="line">    <span class="keyword">else</span> t.setRight(update(k, <span class="keyword">new</span><span class="type">val</span>, t.getRight()));</span><br><span class="line">    <span class="keyword">return</span> t;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>&emsp;&emsp;以上两种实现都会对现有的树进行修改，意味着树的使用者都会感知到这些修改。</p><h3 id="2-3-采用函数式的方法"><a href="#2-3-采用函数式的方法" class="headerlink" title="2.3 采用函数式的方法"></a><strong>2.3 采用函数式的方法</strong></h3><p>&emsp;&emsp;如果要用函数式的方法实现键值更新，需要为新的键值创建一个新的节点，还有创建从树的根节点到新节点路径上的所有节点（副本）。通常情况下，这个操作的代价并不会很大，如果树的深度为d，且保持着一定的平衡性，那么这个树的节点总数为2^d，我们只需要创建树的一小部分节点。我们实现时没有使用if-then-else，目的是强调函数式的思想，但也可以用if-then-else实现这些。</p><figure class="highlight haxe"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 函数式的更新键对应值</span></span><br><span class="line"><span class="comment"> * @param k 给定字符串</span></span><br><span class="line"><span class="comment"> * @param newval 新值</span></span><br><span class="line"><span class="comment"> * @param t 二叉查找树</span></span><br><span class="line"><span class="comment"> * @return 新的二叉查找树</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> Tree fupdate(<span class="keyword">String</span> k, int <span class="keyword">new</span><span class="type">val</span>, Tree t)&#123;</span><br><span class="line">    <span class="keyword">return</span> (t == <span class="literal">null</span>) ?</span><br><span class="line">            <span class="keyword">new</span> <span class="type">Tree</span>(k, <span class="keyword">new</span><span class="type">val</span>, <span class="literal">null</span>, <span class="literal">null</span>) :<span class="type"></span></span><br><span class="line"><span class="type">            k</span>.equals(t.getKey()) ?</span><br><span class="line">                    <span class="keyword">new</span> <span class="type">Tree</span>(k, <span class="keyword">new</span><span class="type">val</span>, t.getLeft(), t.getRight()) :<span class="type"></span></span><br><span class="line"><span class="type">                    k</span>.compareTo(t.getKey()) &lt; <span class="number">0</span> ?</span><br><span class="line">                            <span class="keyword">new</span> <span class="type">Tree</span>(t.getKey(), t.getVal(), fupdate(k, <span class="keyword">new</span><span class="type">val</span>, t.getLeft()), t.getRight()) :<span class="type"></span></span><br><span class="line"><span class="type">                            new Tree</span>(t.getKey(), t.getVal(), t.getLeft(), fupdate(k, <span class="keyword">new</span><span class="type">val</span>, t.getRight()));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>&emsp;&emsp;update和fupdate这两种实现有什么区别呢？update的用户只会共享一份数据结构，对于此数据结构的修改会影响到所有用户，用户应该也想要及时了解程序任何部分所做的更新。fupdate则是纯函数式的，它会创建一个新树并将其作为结果返回，通过参数的方式实现共享。</p><p><img src="https://pic-1258215793.cos.ap-shanghai.myqcloud.com/content/20191001/201910010109.png" alt="对树结构进行更新时，现存数据结构不会被破坏"></p><p>&emsp;&emsp;这种函数式的数据结构通常被称为<strong>持久化的</strong>——数据结构的值始终保持一致，不受其他部分变化的影响（数据库中的持久化表示数据生命周期比程序的执行周期更长的数据）。持久化的数据结构有一个附加条件：所有使用持久化数据结构的用户都需要遵守不修改原则。如果忽视此条件去修改fupdate结果（如修改共享的Emily的年龄），会被所有使用此结果的用户感知，造成无法预知的影响。</p><p>&emsp;&emsp;fupdate可能有更高效的方式：基于不对现存结构进行修改规则，对仅有细微差别的这些通用数据结构可以考虑使用共享存储。可以通过编译器将Tree类的字段key、val、left和right改为final，需要注意的是final只能应用于类的字段，无法应用于它指向的对象，如果需要对对象保护，需要对其中的字段声明final。</p><p>&emsp;&emsp;有些时候你可能需要对树结构的更新对某些用户可见，为了实现这一需求，我们可以通过两种方式：第一种是典型的Java解决方案：对对象进行更新时，需要特别小心，慎重的考虑是否需要在改动之前保存对象的一分副本；另一种是函数式的解决方案：逻辑上，我们在做任何改动之前都会创建一份新的数据结构，只要确保按照用户的需求传递给他正确版本的数据结构就可以了。后者甚至可以通过API强制实施，如果数据结构的某些用户需要进行可见性的改动，应该调用API返回最新版的数据结构。而对于另外一些客户应用，不希望发生任何可见的改动，就直接使用它们保存的备份。</p><hr><h2 id="第三节-Stream的延迟计算"><a href="#第三节-Stream的延迟计算" class="headerlink" title="第三节 Stream的延迟计算"></a><strong>第三节 Stream的延迟计算</strong></h2><p>&emsp;&emsp;Stream的局限是其只能使用一次，所以无法声明一个递归的Stream。</p><h3 id="3-1-自定义的Stream"><a href="#3-1-自定义的Stream" class="headerlink" title="3.1 自定义的Stream"></a><strong>3.1 自定义的Stream</strong></h3><p>&emsp;&emsp;回顾流相关内容时生成质数的例子，代码如下。</p><figure class="highlight arduino"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="built_in">Stream</span>&lt;Integer&gt; primes(<span class="keyword">int</span> n)&#123;</span><br><span class="line">    <span class="built_in">return</span> <span class="built_in">Stream</span>.iterate(<span class="number">2</span>, i -&gt; i + <span class="number">1</span>)</span><br><span class="line">                 .filter(MyMathUtils::isPrime)</span><br><span class="line">                 .limit(n);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">boolean</span> isPrime(<span class="keyword">int</span> candidate)&#123;</span><br><span class="line">    <span class="keyword">int</span> candidateRoot = (<span class="keyword">int</span>) Math.<span class="built_in">sqrt</span>((<span class="keyword">double</span>) candidate);</span><br><span class="line">    <span class="built_in">return</span> IntStream.rangeClosed(<span class="number">2</span>, candidateRoot).noneMatch(i -&gt; candidate % i == <span class="number">0</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>&emsp;&emsp;上述实现每次都要遍历每个数字，查看它是否能被候选数字整除，实际上我们只需要测试已被判定为质数的数字。理想情况下，Stream应该实现实时筛掉能被质数整除的数字。</p><blockquote><p>为了实现这一想法，我们需要：</p><ol><li>一个数字构成的Stream，用来筛选质数</li><li>从该Stream中取出第一个数字，它是一个质数（初始时为2）</li><li>紧接着从Stream尾部开始，筛选掉所有能被该数字整除的元素</li><li>最后剩下的结果即新的Stream，继续用其进行质数的查找，因为要回到第一步，所以此算法是递归的。</li></ol></blockquote><p>&emsp;&emsp;第一步，构造由数字组成的Stream。</p><figure class="highlight aspectj"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="function">IntStream <span class="title">numbers</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">return</span> IntStream.<span class="title">iterate</span><span class="params">(<span class="number">2</span>, n -&gt; n + <span class="number">1</span>)</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>&emsp;&emsp;第二步，取得首元素</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">int</span> <span class="title">head</span><span class="params">(IntStream numbers)</span></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> numbers.findFirst().getAsInt();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>&emsp;&emsp;第三步，对尾部元素进行筛选</p><figure class="highlight aspectj"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="function">IntStream <span class="title">tail</span><span class="params">(IntStream numbers)</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">return</span> numbers.<span class="title">skip</span><span class="params">(<span class="number">1</span>)</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">    IntStream numbers = numbers();</span><br><span class="line">    <span class="keyword">int</span> head = head(numbers);</span><br><span class="line">    IntStream filtered = tail(numbers).filter(n -&gt; n % head != <span class="number">0</span>);</span><br></pre></td></tr></table></figure><p>&emsp;&emsp;第四步，递归的创建由质数组成的Stream</p><figure class="highlight processing"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> IntStream primes(IntStream numbers)&#123;</span><br><span class="line">    <span class="built_in">int</span> head = head(numbers);</span><br><span class="line">    <span class="keyword">return</span> IntStream.<span class="built_in">concat</span>(</span><br><span class="line">            IntStream.of(head),</span><br><span class="line">            primes(tail(numbers).<span class="built_in">filter</span>(n -&gt; n % head != <span class="number">0</span>))</span><br><span class="line">    );</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>&emsp;&emsp;不幸的是执行第四步会抛出异常：“java.lang.IllegalStateException: stream has already been operated upon or closed”，因为试图使用两个终端操作：findFirst和skip将Stream切分成头尾两部分，一旦执行一次终端操作流就会终止。</p><p>&emsp;&emsp;此操作还附带一个更严重的问题：静态方法IntStream.concat接受两个Stream实例作为参数，但由于第二个参数是primes方法的直接递归调用，最终会导致无限递归的状况（当然Java的Stream不能递归）。而函数式语言Scala和Haskell的Stream具备的这些通用特性和模型仍能帮助到我们。我们需要一种方法来推迟primes中对concat的第二个参数计算，一般称之为<strong>延迟计算</strong>、<strong>非限制式计算</strong>或<strong>名调用</strong>，只有在需要处理那个质数时才对Stream进行计算。在Scala中操作符#::实现了延迟链接的功能。</p><figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">def numbers(n: Int) Stream[Int] = n #:: numbers(n+1)</span><br><span class="line">def primes(numbers: Stream[Int]): Stream[Int] = &#123;</span><br><span class="line">    numbers.head #:: primes(numbers.tail<span class="built_in"> filter </span>(n -&gt; n % numbers.head != 0))</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>&emsp;&emsp;在Java中执行一次方法调用，传递的所有参数在第一时间会被立即计算出来；而在Scala中，通过#::操作符，连接操作会立刻返回，而元素的计算会推迟到实际计算需要的时候才开始。</p><h3 id="3-2-创建自己的延迟列表"><a href="#3-2-创建自己的延迟列表" class="headerlink" title="3.2 创建自己的延迟列表"></a><strong>3.2 创建自己的延迟列表</strong></h3><p>&emsp;&emsp;Stream具有延迟执行的特性，流就像一个黑盒，接收请求并生成结果。当你向流提交一系列操作请求时，这些请求只是被异议保存起来，只有当请求一个终端操作时，才会实际的进行计算。这样设计的优点是Stream只需要被遍历一次，不需要为每个操作都遍历一次元素。</p><p>&emsp;&emsp;延迟列表是一种更加通用的Stream形式，提供了一种极好的方式去理解高阶函数，你可以将函数作为值存储在某个数据结构中，等到需要调用时可以创建更多的数据结构。</p><p><img src="https://pic-1258215793.cos.ap-shanghai.myqcloud.com/content/20191001/201910010110.png" alt="LinkedList的元素存在于内存中LazyList的元素由函数在需要使用时动态创建，可以看作实时延展的"></p><h4 id="3-2-1-一个基本的链接列表"><a href="#3-2-1-一个基本的链接列表" class="headerlink" title="3.2.1 一个基本的链接列表"></a><strong>3.2.1 一个基本的链接列表</strong></h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">MyList</span>&lt;<span class="title">T</span>&gt; </span>&#123;</span><br><span class="line">    <span class="function">T <span class="title">head</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="function">MyList&lt;T&gt; <span class="title">tail</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">default</span> <span class="keyword">boolean</span> <span class="title">isEmpty</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyLinkedList</span>&lt;<span class="title">T</span>&gt; <span class="keyword">implements</span> <span class="title">MyList</span>&lt;<span class="title">T</span>&gt; </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> T head;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> MyList&lt;T&gt; tail;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">MyLinkedList</span><span class="params">(T head, MyList&lt;T&gt; tail)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.head = head;</span><br><span class="line">        <span class="keyword">this</span>.tail = tail;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> T <span class="title">head</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> head;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> MyList&lt;T&gt; <span class="title">tail</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> tail;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isEmpty</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Empty</span>&lt;<span class="title">T</span>&gt; <span class="keyword">implements</span> <span class="title">MyList</span>&lt;<span class="title">T</span>&gt; </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> T <span class="title">head</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> UnsupportedOperationException();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> MyList&lt;T&gt; <span class="title">tail</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> UnsupportedOperationException();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        MyList&lt;Integer&gt; l = <span class="keyword">new</span> MyLinkedList&lt;&gt;(<span class="number">5</span>, <span class="keyword">new</span> MyLinkedList&lt;&gt;(<span class="number">10</span>,<span class="keyword">new</span> Empty&lt;&gt;()));</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><h4 id="3-2-2-一个基础的延迟列表"><a href="#3-2-2-一个基础的延迟列表" class="headerlink" title="3.2.2 一个基础的延迟列表"></a><strong>3.2.2 一个基础的延迟列表</strong></h4><p>&emsp;&emsp;对链表进行改造，使其符合延迟列表的要求。最简单的方法是避免让tail立刻出现在内存中，用Supplier包装一层，对应的函数代码会产生列表的下个节点。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">LazyList</span>&lt;<span class="title">T</span>&gt; <span class="keyword">implements</span> <span class="title">MyList</span>&lt;<span class="title">T</span>&gt; </span>&#123;</span><br><span class="line">    <span class="keyword">final</span> T head;</span><br><span class="line">    <span class="keyword">final</span> Supplier&lt;MyList&lt;T&gt;&gt; tail;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">LazyList</span><span class="params">(T head, Supplier&lt;MyList&lt;T&gt;&gt; tail)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.head = head;</span><br><span class="line">        <span class="keyword">this</span>.tail = tail;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> T <span class="title">head</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> head;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> MyList&lt;T&gt; <span class="title">tail</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> tail.get();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isEmpty</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>&emsp;&emsp;调用Supplier的get方法会触发延迟列表的节点创建，就像工厂会创建新的对象一样。我们可以通过递归传递函数创建一系列的数字序列。</p><figure class="highlight livescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 创建由数字构成的无限延迟列表</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">public static LazyList&lt;Integer&gt; <span class="keyword">from</span>(int n)&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> LazyList&lt;&gt;<span class="function"><span class="params">(n, () -&gt; <span class="keyword">from</span>(n+<span class="number">1</span>))</span>;</span></span><br><span class="line"><span class="function">&#125;</span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function"><span class="title">public</span> <span class="title">static</span> <span class="title">void</span> <span class="title">main</span><span class="params">(String[] args)</span> &#123;</span></span><br><span class="line"><span class="function">    <span class="title">LazyList</span>&lt;<span class="title">Integer</span>&gt; <span class="title">numbers</span> = <span class="title">LazyList</span>.<span class="title">from</span><span class="params">(<span class="number">2</span>)</span>;</span></span><br><span class="line"><span class="function">    <span class="title">int</span> <span class="title">two</span> = <span class="title">numbers</span>.<span class="title">head</span><span class="params">()</span>;</span></span><br><span class="line"><span class="function">    <span class="title">int</span> <span class="title">three</span> = <span class="title">numbers</span>.<span class="title">tail</span><span class="params">()</span>.<span class="title">head</span><span class="params">()</span>;</span></span><br><span class="line"><span class="function">    <span class="title">int</span> <span class="title">four</span> = <span class="title">numbers</span>.<span class="title">tail</span><span class="params">()</span>.<span class="title">tail</span><span class="params">()</span>.<span class="title">head</span><span class="params">()</span>;</span></span><br><span class="line"><span class="function">    <span class="title">System</span>.<span class="title">out</span>.<span class="title">println</span><span class="params">(two + <span class="string">" "</span> + three + <span class="string">" "</span> + four)</span>;//2 3 4</span></span><br><span class="line"><span class="function">&#125;</span></span><br></pre></td></tr></table></figure><h4 id="3-2-3-回到生成质数"><a href="#3-2-3-回到生成质数" class="headerlink" title="3.2.3 回到生成质数"></a><strong>3.2.3 回到生成质数</strong></h4><p>&emsp;&emsp;如果我们直接用LazyList替换实现的primes函数，如下代码所示，会因为filter方法未定义不能通过编译。</p><figure class="highlight livescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">public static MyList&lt;Integer&gt; primes(MyList&lt;Integer&gt; numbers)&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> LazyList&lt;&gt;(</span><br><span class="line">            numbers.head(),</span><br><span class="line">            <span class="function"><span class="params">()</span> -&gt;</span> primes(numbers.tail().filter(n<span class="function"> -&gt;</span> n % numbers.head() != <span class="number">0</span>))</span><br><span class="line">    );</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="3-2-4-实现一个延迟筛选器"><a href="#3-2-4-实现一个延迟筛选器" class="headerlink" title="3.2.4 实现一个延迟筛选器"></a><strong>3.2.4 实现一个延迟筛选器</strong></h4><p>&emsp;&emsp;我们在MyList接口添加方法定义，并在LazyList中实现filter方法，代码如下。</p><figure class="highlight livescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line">public interface MyList&lt;T&gt; &#123;</span><br><span class="line">    ......</span><br><span class="line">    MyList&lt;T&gt; filter(Predicate&lt;T&gt; p);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public <span class="class"><span class="keyword">class</span> <span class="title">LazyList</span>&lt;<span class="title">T</span>&gt; <span class="title">implements</span> <span class="title">MyList</span>&lt;<span class="title">T</span>&gt; &#123;</span></span><br><span class="line">    ......</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public MyList&lt;T&gt; filter(Predicate&lt;T&gt; p)&#123;</span><br><span class="line">        <span class="keyword">return</span> isEmpty() ?</span><br><span class="line">                <span class="keyword">this</span> : p.test<span class="function"><span class="params">(head())</span> ? <span class="title">new</span> <span class="title">LazyList</span>&lt;&gt;<span class="params">(head(), () -&gt; tail().filter(p))</span> : <span class="title">tail</span><span class="params">()</span>.<span class="title">filter</span><span class="params">(p)</span>;</span></span><br><span class="line"><span class="function">    &#125;</span></span><br><span class="line"><span class="function">&#125;</span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function">    <span class="title">public</span> <span class="title">static</span> <span class="title">MyList</span>&lt;<span class="title">Integer</span>&gt; <span class="title">primes</span><span class="params">(MyList&lt;Integer&gt; numbers)</span>&#123;</span></span><br><span class="line"><span class="function">        <span class="title">return</span> <span class="title">new</span> <span class="title">LazyList</span>&lt;&gt;<span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">                numbers.head(),</span></span></span><br><span class="line"><span class="function"><span class="params">                () -&gt; primes(numbers.tail().filter(n -&gt; n % numbers.head() != <span class="number">0</span>))</span></span></span><br><span class="line"><span class="function"><span class="params">        )</span>;</span></span><br><span class="line"><span class="function">    &#125;</span></span><br><span class="line"><span class="function">    </span></span><br><span class="line"><span class="function">    <span class="title">public</span> <span class="title">static</span> <span class="title">void</span> <span class="title">main</span><span class="params">(String[] args)</span> &#123;</span></span><br><span class="line"><span class="function">        //延迟列表实现生成质数</span></span><br><span class="line"><span class="function">        <span class="title">LazyList</span>&lt;<span class="title">Integer</span>&gt; <span class="title">numbers</span> = <span class="title">LazyList</span>.<span class="title">from</span><span class="params">(<span class="number">2</span>)</span>;</span></span><br><span class="line"><span class="function">        <span class="title">int</span> <span class="title">two</span> = <span class="title">primes</span><span class="params">(numbers)</span>.<span class="title">head</span><span class="params">()</span>;</span></span><br><span class="line"><span class="function">        <span class="title">int</span> <span class="title">three</span> = <span class="title">primes</span><span class="params">(numbers)</span>.<span class="title">tail</span><span class="params">()</span>.<span class="title">head</span><span class="params">()</span>;</span></span><br><span class="line"><span class="function">        <span class="title">int</span> <span class="title">four</span> = <span class="title">primes</span><span class="params">(numbers)</span>.<span class="title">tail</span><span class="params">()</span>.<span class="title">tail</span><span class="params">()</span>.<span class="title">head</span><span class="params">()</span>;</span></span><br><span class="line"><span class="function">        <span class="title">System</span>.<span class="title">out</span>.<span class="title">println</span><span class="params">(two + <span class="string">" "</span> + three + <span class="string">" "</span> + four)</span>;//2 3 5</span></span><br><span class="line"><span class="function">    &#125;</span></span><br></pre></td></tr></table></figure><p>&emsp;&emsp;尝试循环打印延迟数组中的质数，这个程序不会一直运行下去，最终会因栈溢出而终止，因为Java不支持尾部调用消除。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> &lt;T&gt; <span class="function"><span class="keyword">void</span> <span class="title">printAll</span><span class="params">(MyList&lt;T&gt; <span class="built_in">list</span>)</span></span>&#123;</span><br><span class="line">    <span class="keyword">while</span> (!<span class="built_in">list</span>.isEmpty())&#123;</span><br><span class="line">        System.out.println(<span class="built_in">list</span>.head());</span><br><span class="line">        <span class="built_in">list</span> = <span class="built_in">list</span>.tail();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//递归写法</span></span><br><span class="line"><span class="keyword">static</span> &lt;T&gt; <span class="function"><span class="keyword">void</span> <span class="title">printAll</span><span class="params">(MyList&lt;T&gt; <span class="built_in">list</span>)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(<span class="built_in">list</span>.isEmpty())</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    System.out.println(<span class="built_in">list</span>.head());</span><br><span class="line">    printAll(<span class="built_in">list</span>.tail());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="3-2-5-使用场景"><a href="#3-2-5-使用场景" class="headerlink" title="3.2.5 使用场景"></a><strong>3.2.5 使用场景</strong></h4><p>&emsp;&emsp;比如我们要编写游戏程序，可以定义一些数据结构来存放要加载的物体，具体内容可以在运行时创建，而不用花大量的时间在一开始就创建好，最终的结果是一个延迟树，而不是延迟列表，我们主要讲延迟列表是为了和Stream形成对比。</p><p>&emsp;&emsp;延迟操作的性能一般情况下都要比提前操作要好，但有时比如我们只访问列表前10个元素，每个节点会创建两次，最终创建20个节点，原因在于每次实时访问列表元素时，tail的Supplier都会被重复调用；我们可以设定tail中的Supplier方法只在第一次实时访问时才执行调用，可以在LazyList中添加一个私有的Optional&lt;LazyList<t>&gt;类型字段alreadyComputed，tail方法会根据情况查询及更新该字段的值。</t></p><hr><h2 id="第四节-模式匹配"><a href="#第四节-模式匹配" class="headerlink" title="第四节 模式匹配"></a><strong>第四节 模式匹配</strong></h2><p>&emsp;&emsp;函数式编程的模式匹配和正则表达式的模式匹配容易混淆，是为了解决因为需求变更等原因导致if-else-then或switch代码数量迅速膨胀的问题。</p><p>&emsp;&emsp;假设我们用类Expr对一种数学语言建模，包含数字和二进制操作符。</p><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Expr</span> </span>&#123; ... &#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Number</span> <span class="keyword">extends</span> <span class="title">Expr</span> </span>&#123; int <span class="keyword">val</span>; ... &#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">BinOp</span> <span class="keyword">extends</span> <span class="title">Expr</span> </span>&#123; <span class="type">String</span> opname; <span class="type">Expr</span> left; <span class="type">Expr</span> right; ... &#125;</span><br></pre></td></tr></table></figure><p>&emsp;&emsp;假设我们要通过方法来简化某个表达式，比如5+0=5可以简化为5 -&gt; new BinOp(“+”, new Number(5), new Number(0))可以简化为Number(5)，实现代码可能会如下。</p><figure class="highlight gauss"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">Expr</span> simplifyExpression(<span class="keyword">Expr</span> <span class="keyword">expr</span>)&#123;</span><br><span class="line">    <span class="keyword">if</span>(<span class="keyword">expr</span> instanceof BinOp</span><br><span class="line">         &amp;&amp; ((BinOp) <span class="keyword">expr</span>).opname.equals(<span class="string">"+"</span>))</span><br><span class="line">         &amp;&amp; ((BinOp) <span class="keyword">expr</span>).right instanceof Number</span><br><span class="line">         &amp;&amp; ... <span class="comment">//变得非常笨拙</span></span><br><span class="line">         &amp;&amp; ...)&#123;</span><br><span class="line">             <span class="keyword">return</span> (BinOp) <span class="keyword">expr</span>.left;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="4-1-访问者设计模式"><a href="#4-1-访问者设计模式" class="headerlink" title="4.1 访问者设计模式"></a><strong>4.1 访问者设计模式</strong></h3><p>&emsp;&emsp;访问者设计模式，需要创建一个单独的类，此类封装了一个算法，可以“访问”某种数据类型。访问者类会接受某种数据类型的实例作为输入，它可以访问实例所有的成员。</p><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">BinOp</span> <span class="keyword">extends</span> <span class="title">Expr</span> </span>&#123;</span><br><span class="line">    ...</span><br><span class="line">    public <span class="type">Expr</span> accept(<span class="type">SimplifyExprVistor</span> v)&#123;</span><br><span class="line">        <span class="keyword">return</span> v.visit(<span class="keyword">this</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>&emsp;&emsp;SimplifyExprVistor可以访问BinOp对象并解包其中的内容。</p><figure class="highlight cs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">SimplifyExprVistor</span>&#123;</span><br><span class="line">    ...</span><br><span class="line">    <span class="function"><span class="keyword">public</span> Expr <span class="title">visit</span>(<span class="params">BinOp e</span>)</span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(<span class="string">"+"</span>.<span class="keyword">equals</span>(e.opname) &amp;&amp; e.right instanceof Number &amp;&amp; ...)&#123;</span><br><span class="line">            <span class="keyword">return</span> e.left;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> e;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="4-2-用模式匹配力挽狂澜"><a href="#4-2-用模式匹配力挽狂澜" class="headerlink" title="4.2 用模式匹配力挽狂澜"></a><strong>4.2 用模式匹配力挽狂澜</strong></h3><p>&emsp;&emsp;通过模式匹配这个特性，我们可以更简单的来解决上述问题。但此特性在Java 8版本还未支持，所以用Scala语言来展示其作用。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">def simplifyExpression(expr: Expr): Expr = expr match&#123;</span><br><span class="line">    <span class="keyword">case</span> BinOp(<span class="string">"+"</span>, e, <span class="built_in">Number</span>(<span class="number">0</span>)) =&gt; e <span class="comment">//加0</span></span><br><span class="line">    <span class="keyword">case</span> BinOp(<span class="string">"*"</span>, e, <span class="built_in">Number</span>(<span class="number">1</span>)) =&gt; e <span class="comment">//乘以1</span></span><br><span class="line">    <span class="keyword">case</span> BinOp(<span class="string">"/"</span>, e, <span class="built_in">Number</span>(<span class="number">1</span>)) =&gt; e <span class="comment">//除以1</span></span><br><span class="line">    <span class="keyword">case</span> <span class="function"><span class="params">_</span> =&gt;</span> expr                     <span class="comment">//不能简化expr</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>&emsp;&emsp;Scala语法如下，通配符判断和Java中的default:扮演同样的角色。Java中的模式判断被限制在基础类型、枚举类型、包装类型以及String类型。模式匹配可以避免出现大量嵌套的switch或if-then-else语句与字段选择操作相互交织的情况。</p><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Expression match &#123; <span class="keyword">case</span> <span class="built_in">Pattern</span> =&gt; Expression ... &#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//和Java的switch相似</span></span><br><span class="line"><span class="keyword">switch</span> (Expression) &#123; <span class="keyword">case</span> Constant : Statement ... &#125;</span><br></pre></td></tr></table></figure><p>&emsp;&emsp;Lambda表达式反而可以比较简洁的实现单层的模式匹配。</p><hr><h2 id="第五节-杂项"><a href="#第五节-杂项" class="headerlink" title="第五节 杂项"></a><strong>第五节 杂项</strong></h2><h3 id="5-1-缓存或记忆表"><a href="#5-1-缓存或记忆表" class="headerlink" title="5.1 缓存或记忆表"></a><strong>5.1 缓存或记忆表</strong></h3><p>&emsp;&emsp;假设有一个方法computeNumberOfNodesUsingCache(Range)，用来计算一个树形网络中给定区间内的节点数目。假设此网络不会发生变化，即数据结构是不可变的，computeNumberOfNodesUsingCache需要递归遍历，所以方法的开销还是很大的。如果我们能保证引用透明性，就可以有一种方法来避免这种冗余的开销：<strong>记忆表</strong>——为方法添加一个封装器，在其中加入一块缓存（比如一个HashMap），当封装器被调用时，首先查看缓存，看请求的（参数，结果）是否已存于缓存中，如果存在就直接返回缓存结果，否则调用computeNumberOfNodesUsingCache。严格的来看，这种实现并非纯粹的函数式解决方案，因为会修改多个调用者共享的数据结构，但这段代码的封装版本的确是引用透明的。</p><figure class="highlight fortran"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">final</span> Map&lt;<span class="built_in">Range</span>, <span class="keyword">Integer</span>&gt; numberOfNodes = new HashMap&lt;&gt;();</span><br><span class="line"><span class="keyword">Integer</span> computeNumberOfNodesUsingCache(<span class="built_in">Range</span> <span class="built_in">range</span>)&#123;</span><br><span class="line">    <span class="keyword">Integer</span> result = numberOfNodes.get(<span class="built_in">range</span>);</span><br><span class="line">    <span class="keyword">if</span>(result <span class="comment">!= null)&#123;</span></span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line">    result = computeNumberOfNodesUsingCache(<span class="built_in">range</span>);</span><br><span class="line">    numberOfNodes.put(<span class="built_in">range</span>, result);</span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">//Java <span class="number">8</span>改进了Map接口，提供了computeIfAbsent方法来处理这种情况</span><br><span class="line"><span class="keyword">Integer</span> computeNumberOfNodesUsingCache(<span class="built_in">Range</span> <span class="built_in">range</span>)&#123;</span><br><span class="line">    <span class="keyword">return</span> numberOfNodes.computeIfAbsent(<span class="built_in">range</span>, this::computeNumberOfNodes)</span><br></pre></td></tr></table></figure><p>&emsp;&emsp;numberOfNodes处于可变共享状态，并且HashMap也没有同步，这意味着这段代码不是线程安全的。如果多核对numberOfNodes执行并发调用，就算用（锁保护的）HashTable 或（并发无锁的）ConcurrentHashMap，可能都无法达到预期的性能，因为这中间又存在由于发现某个值不再Map中，需要将对应的键值对插回到Map而引起的竞态条件。这意味着多个核上的进程可能算出的结果相同，又都需要将其加入到Map中。</p><p>&emsp;&emsp;一旦并发和可变对象揉到一起所引起的复杂度要远超我们的想象，而函数式编程可以从根本上解决这一问题。以函数式的方式进行设计，不用担心是否采用了正确的同步方式，因为没有任何共享的可变状态。</p><h3 id="5-2-“返回同样的对象”意味着什么"><a href="#5-2-“返回同样的对象”意味着什么" class="headerlink" title="5.2 “返回同样的对象”意味着什么"></a><strong>5.2 “返回同样的对象”意味着什么</strong></h3><p>&emsp;&emsp;回顾2.3实现的fupdate方法，通过变量t指向一棵现存的树，调用fupdate(“Will”, 26, t)会生成一个新树。我们假设该树会被赋值给变量t2，那么再调用一次fupdate(“Will”, 26, t)并赋值给t3，应该会生成一个同样数据的新树。那么fupdate还符合引用透明性吗？因为引用透明性原则意味着使用相同的参数会产生相同的结果，但 t2 != t3，所以fupdate应该不符合引用透明性原则。</p><p>&emsp;&emsp;但即使如此，t2和t3使用时在逻辑上没有区别，关于这一点也有很多的辩论，<strong>对于函数式编程通常不使用==（引用相等），而是使用equal对数据结构值进行比较</strong>，所以这样看来fupdate还是符合引用透明性原则的。</p><h3 id="5-3-结合器"><a href="#5-3-结合器" class="headerlink" title="5.3 结合器"></a><strong>5.3 结合器</strong></h3><p>&emsp;&emsp;函数式编程时经常会使用到高阶函数，接受两个或多个函数，并返回另一个函数，最终实现效果类似于把这些函数进行了结合。<strong>结合器</strong>就是用来表示这种思想的术语，Java 8中很多API都源自于此思想，如CompletableFuture类中的thenCombine，接受两个CompletableFuture方法和一个BiFunction方法，返回另一个CompletableFuture方法。</p><p>&emsp;&emsp;如下代码体现出函数组合的思想，效果就是先执行f再执行g。</p><figure class="highlight coq"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">static &lt;A,B,C&gt; <span class="keyword">Function</span>&lt;A,C&gt; compose(<span class="keyword">Function</span>&lt;B,C&gt; g, <span class="keyword">Function</span>&lt;A,B&gt; f)&#123;</span><br><span class="line">    <span class="keyword">return</span> x -&gt; g.<span class="built_in">apply</span>(f.<span class="built_in">apply</span>(x));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>&emsp;&emsp;假设我们想要对一个参数使用函数f连续的进行n次操作，类似于循环。</p><figure class="highlight fortran"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">static &lt;A&gt; <span class="function"><span class="keyword">Function</span></span>&lt;A,A&gt; <span class="built_in">repeat</span>(<span class="built_in">int</span> n, <span class="function"><span class="keyword">Function</span></span>&lt;A,A&gt; f)&#123;</span><br><span class="line">    //n为<span class="number">0</span>直接返回标识符表示什么也不做，否则执行f，重复执行n-<span class="number">1</span>次，最后再执行一次</span><br><span class="line">    <span class="keyword">return</span> n==<span class="number">0</span> ? x -&gt; x</span><br><span class="line">                : compose(f, <span class="built_in">repeat</span>(n-<span class="number">1</span>, f));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>&emsp;&emsp;这个想法稍作变更可以对迭代概念的更丰富外延进行建模，甚至包括对在迭代直接传递可变状态的函数式模型，但这里只是对函数式编程做一个全局的介绍就不继续展开了。</p><hr><p><em>参考博客和文章书籍等：</em></p><blockquote><p>《Java8实战》</p></blockquote><p><em>因博客主等未标明不可引用，若部分内容涉及侵权请及时告知，我会尽快修改和删除相关内容</em></p>]]></content>
    
    <summary type="html">
    
      介绍Java 8中引入的函数式编程的技巧，内容包括：第一节 无处不在的函数（高阶函数、科里化），第二节 持久化数据结构（破坏式更新和函数式更新的比较、案例：二叉查找树、采用函数式的方法），Stream的延迟计算（自定义的Stream、创建自己的延迟列表），第四节 模式匹配（访问者设计模式、用模式匹配力挽狂澜），第五节 杂项（缓存或记忆表、“返回同样的对象”意味着什么、结合器）等。
    
    </summary>
    
      <category term="技术文档" scheme="http://linyishui.top/categories/%E6%8A%80%E6%9C%AF%E6%96%87%E6%A1%A3/"/>
    
    
      <category term="java" scheme="http://linyishui.top/tags/java/"/>
    
      <category term="functional" scheme="http://linyishui.top/tags/functional/"/>
    
  </entry>
  
  <entry>
    <title>函数式的思考</title>
    <link href="http://linyishui.top/2019100301.html"/>
    <id>http://linyishui.top/2019100301.html</id>
    <published>2019-10-03T03:31:13.000Z</published>
    <updated>2019-12-05T07:09:40.827Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="函数式的思考"><a href="#函数式的思考" class="headerlink" title="函数式的思考"></a><strong>函数式的思考</strong></h1><h2 id="第一节-引文"><a href="#第一节-引文" class="headerlink" title="第一节 引文"></a><strong>第一节 引文</strong></h2><p>&emsp;&emsp;函数式编程是一种新的编程风格，核心就是<strong>把函数作为值</strong>。利用函数式编程可以用更少的时间，写出更清晰、简洁的代码。函数所指的这部分代码，可以被来回传递并加以组合，从而产生强大的编程语汇。</p><hr><h2 id="第二节-实现和维护系统"><a href="#第二节-实现和维护系统" class="headerlink" title="第二节 实现和维护系统"></a><strong>第二节 实现和维护系统</strong></h2><p>&emsp;&emsp;假设我们需要接手一个不熟悉项目，如果我们比较有经验可能会先搜索一下代码中是否有使用synchronized关键字，如果有就意味着要面对修复并发导致的缺陷的可能。为了让程序易于使用，希望最好项目的类结构能直接反映出系统的结构，具有良好的<strong>耦合性</strong>（软件系统各组件之间是否相互独立）和<strong>内聚性</strong>（系统的各相关部分之间如何协作）。对于程序员来说，大部分日常工作应该是代码维护时的调试：代码遭遇无法预测的情况而崩溃，为什么这样？如何进入这种状态的？而函数式编程的<strong>无副作用</strong>和<strong>不变性</strong>对于这一问题大有裨益。</p><h3 id="2-1-共享的可变数据"><a href="#2-1-共享的可变数据" class="headerlink" title="2.1 共享的可变数据"></a><strong>2.1 共享的可变数据</strong></h3><p>&emsp;&emsp;<strong>无法预知的变量修改问题</strong>源自于共享的数据结构被你所维护的代码中的多个方法读取和更新。正式由于使用了这种结构导致我们很难追踪到程序的各个组成部分所发生的变化。<strong>如果一个方法既不修改它内嵌类的状态，也不修改其他对象的状态，使用return返回所有的计算结果</strong>，那么我们就可以称其为<strong>纯粹的</strong>或<strong>无副作用的</strong>。</p><p>&emsp;&emsp;多个类同时共享一个可变对象，很难说到底哪个类真正拥有对象，如下图所示。</p><p><img src="https://pic-1258215793.cos.ap-shanghai.myqcloud.com/content/20191001/201910010102.png" alt="多个类同时共享一个可变对象，很难说到底哪个类真正拥有对象"></p><blockquote><p>副作用就是函数的效果超过了其自身的范畴，一些例子：</p><ul><li>除了构造器内的初始化操作，还对类中数据结构的任何修改，包括字段的赋值操作（如setter）</li><li>抛出一个异常</li><li>进行输入/输出操作，比如向文件写数据</li></ul></blockquote><p>&emsp;&emsp;所以为了实现无副作用，我们应该考虑不可变对象，可以放心的共享，不需要创建任何副本。但真正的生产系统是否能够由这种设计来实现？答案是可以，并且如何系统的各个组件能够遵守这一原则，系统就可以在无锁的情况下适用多核的并发机制，任何一个方法都不会对其他方法造成干扰。</p><h3 id="2-2-声明式编程"><a href="#2-2-声明式编程" class="headerlink" title="2.2 声明式编程"></a><strong>2.2 声明式编程</strong></h3><p>&emsp;&emsp;编程实现系统有两种思考方式：一种专注于如何实现，一种专注于要做什么。前者适合经典的面向对象编程，特点就是和计算机底层词汇相似，如赋值、条件分支以及循环，这种编程会被叫做<strong>命令式编程</strong>。后者则将如何实现的细节留给函数库，这种思想叫<strong>内部迭代</strong>，我们的语言看起来会更像问题陈述，这种风格的编程被称为<strong>声明式编程</strong>。</p><h3 id="2-3-为什么要采用函数式编程"><a href="#2-3-为什么要采用函数式编程" class="headerlink" title="2.3 为什么要采用函数式编程"></a><strong>2.3 为什么要采用函数式编程</strong></h3><p>&emsp;&emsp;函数式编程具体实践了声明式编程和无副作用计算，可以使我们更容易的构建和维护系统。实现函数式编程必要的一些特性，如构造操作和传递行为可以使我们的程序更便于阅读、易于编写。</p><hr><h2 id="第三节-什么是函数式编程"><a href="#第三节-什么是函数式编程" class="headerlink" title="第三节 什么是函数式编程"></a><strong>第三节 什么是函数式编程</strong></h2><p>&emsp;&emsp;一种使用函数进行编程的方式。函数式编程中的函数对应一个数学函数，接收参数返回结果但不会有副作用，不同于Java中常见的函数，没有可变共享变量的参与。当我们定义函数式时，想要表达的是像数学函数那样没有副作用，我们能否在函数内部执行一些非函数式操作，只要其结果不会暴露出来？或者程序可以存在副作用但不会被其它调用者感知？为了准确的区别二者，我们称第一种为<strong>纯粹的函数式编程</strong>，第二种为<strong>函数式编程</strong>。</p><p>&emsp;&emsp;我们可以把函数式编程看作一个<strong>黑盒模型</strong>：输入-&gt;函数-&gt;输出。下图分别为带有副作用的函数和没有副作用的函数。</p><p><img src="https://pic-1258215793.cos.ap-shanghai.myqcloud.com/content/20191001/201910010103.png" alt="带有副作用的函数"></p><p><img src="https://pic-1258215793.cos.ap-shanghai.myqcloud.com/content/20191001/201910010104.png" alt="没有副作用的函数"></p><h3 id="3-1-函数式Java编程"><a href="#3-1-函数式Java编程" class="headerlink" title="3.1 函数式Java编程"></a><strong>3.1 函数式Java编程</strong></h3><p>&emsp;&emsp;实际Java编程中，我们无法以纯粹的函数式编程来实现一个程序，但可以为系统的核心组件编写接近纯粹式函数式的实现。首先，要确保代码的副作用不能被感知到。比如有一个函数在进入方法体执行时会对一个字段值+1，退出方法体前会对字段值-1。对于单线程来说，这个函数没有副作用。但多线程时，其他线程可以查看该字段的值，甚至并发调用它，那么此函数就不能称为函数式的实现了。当然我们可以通过加锁来对方法体进行封装，从而掩盖这一问题，但同时也失去了在多核处理器上的两个核并发执行两个方法调用的能力。虽然最终符合了函数式的定义，但实际上降低了运行效率。</p><p>&emsp;&emsp;所以我们的准则是，<strong>被称为函数式的函数或方法都只能修改本地变量</strong>。除此之外，<strong>引用的对象都只能是不可修改的对象</strong>（期望所有字段都是final）。但<strong>实际上也会允许对方法中全新创建的对象中的字段进行更新</strong>，不过这些字段对于其他对象是不可见的，也不会因为保存而对后续调用造成影响。</p><p>&emsp;&emsp;如果被称为函数式，<strong>函数或方法不能抛出任何异常</strong>。一旦抛出异常就意味着结果被终止了，但这点其实和数学函数也有冲突，这些数学操作可以被称作<strong>局部函数式</strong>，当输入正常返回确定的结果，但对于一些输入其结果是<strong>未定义的</strong>，甚至不返回结果（比如除法除数为0）。所以有些人认为通过抛出异常来对这类情况建模是合理的，但捕获异常是一种非函数式的控制流，这种操作违背了我们定义的黑盒模型，从而增加了一组代表异常处理的箭头：-&gt;异常。</p><p><img src="https://pic-1258215793.cos.ap-shanghai.myqcloud.com/content/20191001/201910010105.png" alt="抛出一个异常的方法"></p><p>&emsp;&emsp;不使用异常的方案就是使用<strong>Optional<t></t></strong>类型，避免直接使用原始或引用类型作为函数返回值，而是Optional<t>包装返回值。当然我们需要检查函数返回值是否为一个空的Optional对象，这种方式似乎很繁琐，所以我们可以像非纯粹的函数式那样选择在本地局部地使用异常，避免通过接口将结果暴露给其他方法，这样既利用了函数式的优点，也不会过度的使代码膨胀。</t></p><p>&emsp;&emsp;当我们实现的函数存在副作用时，请隐藏这些非函数式行为，否则就不要调用这些方法（换句话说，你要确保它们对数据结构的任何修改对于调用者都是不可见的，可以通过首次复制，或者捕获任何可能抛出的异常来实现这一目的）。如后续3.4的实战代码中我们隐藏了方法insertAll调用库函数List.add所产生的副作用。</p><h3 id="3-2-引用透明性"><a href="#3-2-引用透明性" class="headerlink" title="3.2 引用透明性"></a><strong>3.2 引用透明性</strong></h3><p>&emsp;&emsp;<strong>没有可感知的副作用</strong>隐含着<strong>引用透明性</strong>，如果一个函数只要传递同样的参数值，必定会返回同样的结果，可以称这个函数是引用透明的。比如String.replace方法总是返回同样的结果，而不是更新它的this对象，就是引用透明的，可以被看作函数式。所以引用透明性可以看作是函数式的特征，相对的Random.nextInt方法就不会被看作函数式方法。</p><p>&emsp;&emsp;一种复杂的情况是，比如一个方法会返回一个集合，但如果调用两次会返回两个不同的集合对象，虽然它们有相同的元素值。如果我们把集合当作可变的对象值，那么这个方法就是不透明的。但如果我们把这些结合作为单纯的值（不可修改），这时两个集合被看作是相同集合是合理的，那么这个方法就是透明的。通常，<strong>在函数式编程中，你应该选择使用引用透明的函数</strong>。</p><h3 id="3-3-面向对象编程和函数式编程的对比"><a href="#3-3-面向对象编程和函数式编程的对比" class="headerlink" title="3.3 面向对象编程和函数式编程的对比"></a><strong>3.3 面向对象编程和函数式编程的对比</strong></h3><p>&emsp;&emsp;Java 8认为这些函数式风格只是面向对象的一个极端，由硬件发展和程序员的期望而带来了这些从面向对象到函数式的变化，实际上Java程序员经常会混用两种编程风格，可能会使用包含了可变内部状态的迭代器遍历某个数据结构，同时又通过函数式的方式计算数据结构中变量之和。</p><h3 id="3-4-函数式编程实战"><a href="#3-4-函数式编程实战" class="headerlink" title="3.4 函数式编程实战"></a><strong>3.4 函数式编程实战</strong></h3><p>&emsp;&emsp;假设我们需要对给定的一个集合求其所有子集，思路就是通过归纳法递归进行元素间的排列组合，实现方法subsets，递归的每一次都会拿出一个元素并求剩余集合元素的子集，再和拿出的元素排列组合得出结果。</p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ActualCombat</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> void main(String[] args) &#123;</span><br><span class="line">        <span class="keyword">List</span>&lt;Integer&gt; <span class="keyword">list</span> = Arrays.asList(<span class="number">1</span>,<span class="number">4</span>,<span class="number">9</span>);</span><br><span class="line">        subsets(<span class="keyword">list</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 给定一个集合，求集合所有子集</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> list 集合</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> 子集数组</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">List</span>&lt;<span class="keyword">List</span>&lt;Integer&gt;&gt; subsets(<span class="keyword">List</span>&lt;Integer&gt; <span class="keyword">list</span>)&#123;</span><br><span class="line">        <span class="keyword">if</span>(<span class="keyword">list</span>.isEmpty())&#123;</span><br><span class="line">            <span class="comment">//如果输入集合为空，其子集只包含空集</span></span><br><span class="line">            <span class="keyword">List</span>&lt;<span class="keyword">List</span>&lt;Integer&gt;&gt; ans = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">            ans.add(Collections.emptyList());</span><br><span class="line">            <span class="keyword">return</span> ans;</span><br><span class="line">        &#125;</span><br><span class="line">        Integer first = <span class="keyword">list</span>.get(<span class="number">0</span>);</span><br><span class="line">        System.out.println(<span class="string">"first: "</span> + first);</span><br><span class="line">        <span class="keyword">List</span>&lt;Integer&gt; rest = <span class="keyword">list</span>.subList(<span class="number">1</span>, <span class="keyword">list</span>.size());</span><br><span class="line"></span><br><span class="line">        <span class="comment">//否则就取出一个元素first，找出剩余部分的所有子集，并将其赋予subans。subans构成了结果的另一半。</span></span><br><span class="line">        <span class="keyword">List</span>&lt;<span class="keyword">List</span>&lt;Integer&gt;&gt; subans = subsets(rest);</span><br><span class="line">        <span class="comment">//答案的另一半是subans2，它包含了subans中的所有集合，但是经过调整，在每个列表的第一个元素之前添加了first</span></span><br><span class="line">        <span class="keyword">List</span>&lt;<span class="keyword">List</span>&lt;Integer&gt;&gt; subans2 = insertAll(first,subans);</span><br><span class="line">        <span class="comment">//将两个答案整合一起完成任务</span></span><br><span class="line">        <span class="keyword">return</span> concat(subans,subans2);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 将移出元素和当前子集组合</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> first 移出的当前首元素</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> lists 已生成的子集数组</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> 当前子集数组</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">List</span>&lt;<span class="keyword">List</span>&lt;Integer&gt;&gt; insertAll(Integer first,</span><br><span class="line">                                         <span class="keyword">List</span>&lt;<span class="keyword">List</span>&lt;Integer&gt;&gt; lists)&#123;</span><br><span class="line">        <span class="keyword">List</span>&lt;<span class="keyword">List</span>&lt;Integer&gt;&gt; result = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">List</span>&lt;Integer&gt; <span class="keyword">list</span> : lists)&#123;</span><br><span class="line">            <span class="comment">//复制列表，从而使你有机会对其进行添加操作。</span></span><br><span class="line">            <span class="comment">//即使底层是可变的，你也不应该复制底层的结构（不过Integer底层是不可变的）</span></span><br><span class="line">            <span class="keyword">List</span>&lt;Integer&gt; copyList = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">            copyList.add(first);</span><br><span class="line">            copyList.addAll(<span class="keyword">list</span>);</span><br><span class="line">            result.add(copyList);</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(<span class="string">"insertAll: "</span>);</span><br><span class="line">        result.<span class="keyword">forEach</span>(System.out::println);</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 合并子集数组元素</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> a 数组a</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> b 数组b</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> 最终结果</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">List</span>&lt;<span class="keyword">List</span>&lt;Integer&gt;&gt; concat(<span class="keyword">List</span>&lt;<span class="keyword">List</span>&lt;Integer&gt;&gt; a,</span><br><span class="line">                                      <span class="keyword">List</span>&lt;<span class="keyword">List</span>&lt;Integer&gt;&gt; b)&#123;</span><br><span class="line">        <span class="keyword">List</span>&lt;<span class="keyword">List</span>&lt;Integer&gt;&gt; r = <span class="keyword">new</span> ArrayList&lt;&gt;(a);</span><br><span class="line">        r.addAll(b);</span><br><span class="line">        System.out.println(<span class="string">"concat: "</span>);</span><br><span class="line">        r.<span class="keyword">forEach</span>(System.out::println);</span><br><span class="line">        <span class="keyword">return</span> r;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>&emsp;&emsp;运行结果如下。</p><figure class="highlight accesslog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line">first: <span class="number">1</span></span><br><span class="line">first: <span class="number">4</span></span><br><span class="line">first: <span class="number">9</span></span><br><span class="line">insertAll: </span><br><span class="line"><span class="string">[9]</span></span><br><span class="line">concat: </span><br><span class="line"><span class="string">[]</span></span><br><span class="line"><span class="string">[9]</span></span><br><span class="line">insertAll: </span><br><span class="line"><span class="string">[4]</span></span><br><span class="line"><span class="string">[4, 9]</span></span><br><span class="line">concat: </span><br><span class="line"><span class="string">[]</span></span><br><span class="line"><span class="string">[9]</span></span><br><span class="line"><span class="string">[4]</span></span><br><span class="line"><span class="string">[4, 9]</span></span><br><span class="line">insertAll: </span><br><span class="line"><span class="string">[1]</span></span><br><span class="line"><span class="string">[1, 9]</span></span><br><span class="line"><span class="string">[1, 4]</span></span><br><span class="line"><span class="string">[1, 4, 9]</span></span><br><span class="line">concat: </span><br><span class="line"><span class="string">[]</span></span><br><span class="line"><span class="string">[9]</span></span><br><span class="line"><span class="string">[4]</span></span><br><span class="line"><span class="string">[4, 9]</span></span><br><span class="line"><span class="string">[1]</span></span><br><span class="line"><span class="string">[1, 9]</span></span><br><span class="line"><span class="string">[1, 4]</span></span><br><span class="line"><span class="string">[1, 4, 9]</span></span><br></pre></td></tr></table></figure><p>&emsp;&emsp;首先实现insertAll时会有一个坑，如果直接list.add(first)，库函数List.add会修改传递的参数。为了使insertAll函数式的运行，我们利用Integer对象无法修改这一优势，否则需要为每个元素创建一个副本，将复制操作放入insertAll内，而不是调用者中。</p><p>&emsp;&emsp;concat方法的简单实现如下，但为了实现纯粹的函数式我们最终如上实现，虽然会在函数内部对对象进行修改，但<strong>基于参数返回的结果却未修改任意一个参数</strong>。简单实现版本只能基于这样一个条件：参数a不会再被使用，否则就可能会造成影响。</p><figure class="highlight lasso"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">static <span class="built_in">List</span>&lt;<span class="built_in">List</span>&lt;<span class="built_in">Integer</span>&gt;&gt; concat(<span class="built_in">List</span>&lt;<span class="built_in">List</span>&lt;<span class="built_in">Integer</span>&gt;&gt; a,</span><br><span class="line">                                  <span class="built_in">List</span>&lt;<span class="built_in">List</span>&lt;<span class="built_in">Integer</span>&gt;&gt; b)&#123;</span><br><span class="line">    a.addAll(b);</span><br><span class="line">    <span class="keyword">return</span> a;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><h2 id="第四节-递归和迭代"><a href="#第四节-递归和迭代" class="headerlink" title="第四节 递归和迭代"></a><strong>第四节 递归和迭代</strong></h2><p>&emsp;&emsp;纯粹的函数式编程通常不包含while或for这样的迭代构造器，因为这样的构造器通常隐藏着陷阱，诱使我们修改对象。比如while循环的条件状态必须要更新，但很多情况下循环是非常有用的，而我们也可以在不被感知的情况下修改局部变量。我们通常使用的for-each循环可以用迭代器的方式重写。</p><figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span>(Apple a : apples)&#123;</span><br><span class="line">    <span class="built_in">..</span><span class="built_in">..</span><span class="built_in">..</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Iterator&lt;Apple&gt; it = apples.iterator();</span><br><span class="line"><span class="keyword">while</span>(it.hasNext())&#123;</span><br><span class="line">    Apple apple = it.next();</span><br><span class="line">    <span class="built_in">..</span><span class="built_in">..</span><span class="built_in">..</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>&emsp;&emsp;当改变发生时，包括使用next方法对迭代器状态的改变，以及while循环内部对apple变量的赋值，这些对于方法的调用者是不可见的。但如果使用for-each循环，如下搜索算法时会带来问题，因为循环体会对调用方共享的数据结构进行修改。</p><figure class="highlight lasso"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="literal">void</span> searchForGold(<span class="built_in">List</span>&lt;<span class="built_in">String</span>&gt; <span class="built_in">list</span>, Stats stats)&#123;</span><br><span class="line">    fot(<span class="built_in">String</span> s : <span class="built_in">list</span>)&#123;</span><br><span class="line">        <span class="keyword">if</span>(<span class="string">"gold"</span>.<span class="keyword">equals</span>(s))&#123;</span><br><span class="line">            stats.incrementFor(<span class="string">"gold"</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>&emsp;&emsp;对于函数式而言，循环体带来乐一个无法避免的副作用：它会修改stats对象的状态，而这和程序的其他部分是共享的。为了解决这种副作用，正确的方案是用无需修改的递归重写来避免迭代。通过递归可以消除每步都需要更新的迭代变量，如实现一个计算阶乘的函数。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 迭代式阶乘计算</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">int</span> <span class="title">factorialIterative</span><span class="params">(<span class="keyword">int</span> n)</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> r = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>;i &lt;= n;i++)&#123;</span><br><span class="line">        r *= i;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> r;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 递归式阶乘计算</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">long</span> <span class="title">factorialRecursive</span><span class="params">(<span class="keyword">long</span> n)</span></span>&#123;</span><br><span class="line">   <span class="keyword">return</span> n == <span class="number">1</span> ? <span class="number">1</span> : n * factorialRecursive(n<span class="number">-1</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Stream式阶乘计算</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">long</span> <span class="title">factorialStreams</span><span class="params">(<span class="keyword">long</span> n)</span></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> LongStream.rangeClosed(<span class="number">1</span>,n)</span><br><span class="line">            .reduce(<span class="number">1</span>, (<span class="keyword">long</span> a, <span class="keyword">long</span> b) -&gt; a * b);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>&emsp;&emsp;当然我们也可以使用Stream流来实现阶乘计算。递归方式在Java中效率相比迭代会差一些，递归式方法调用的开销会比迭代执行单一机器级的分支指令大很多，因为每次执行factorialRecursive方法调用都需要在调用栈上创建一个新的栈帧，用于保存每个方法调用的状态，这个操作会一直指导程序运行直到结束，意味着递归迭代方法会依据它接收到的输入成比例的消耗内存。</p><p>&emsp;&emsp;函数式语言提供了一个方案来解决这个效率问题：<strong>尾—调优化</strong>（tail-call optimization），基本思想是你可以编写阶乘的一个迭代定义，不过迭代调用会发生在函数的最后，这种新型的迭代调用经过优化后的执行速度会快很多。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 递归式阶乘计算: 尾-调优化</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">long</span> <span class="title">factorialTailRecursive</span><span class="params">(<span class="keyword">long</span> n)</span></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> factorialHelper(<span class="number">1</span>,n);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">long</span> <span class="title">factorialHelper</span><span class="params">(<span class="keyword">long</span> acc, <span class="keyword">long</span> n)</span></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> n == <span class="number">1</span> ? acc : factorialHelper(acc * n, n<span class="number">-1</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>&emsp;&emsp;factorialHelper是尾-递类型的函数，递归调用会发生在方法的最后。factorialRecursive递归会先进行递归，递归结果最后进行运算；而factorialHelper则先运算，将运算结果直接作为参数进行递归。factorialRecursive方法会每次调用创建一个栈帧，而factorialHelper不需要在不同的栈帧上保存每次递归运算的中间值，编译器能够自行决定复用某个栈帧进行计算，阶乘的中间值直接被用作参数传递给此方法，也就不用为每个递归调用分配单独的栈帧用于跟踪每次调用的中间值——通过方法的参数可以直接访问直接值。</p><p><img src="https://pic-1258215793.cos.ap-shanghai.myqcloud.com/content/20191001/201910010106.png" alt="栈帧和尾递阶乘的差异"></p><p>&emsp;&emsp;但Java 8版本时还未能支持这种优化，而一些现代的语言如Scala或Groovy都支持了这种递归优化，最终的效果和迭代不相上下。这意味着坚持纯粹的函数式编程既能享受其好处，也不会损失执行的效率。所以在Java 8时，建议使用Stream代替迭代操作，如果采用递归能够不带来副作用且更容易实现那应该采用递归，毕竟开发的效率往往比执行的细微差异在大多数时候要更重要。</p><hr><p><em>参考博客和文章书籍等：</em></p><blockquote><p>《Java8实战》</p></blockquote><p><em>因博客主等未标明不可引用，若部分内容涉及侵权请及时告知，我会尽快修改和删除相关内容</em></p>]]></content>
    
    <summary type="html">
    
      介绍Java 8中引入的函数式编程，内容包括：第一节 引文，第二节 实现和维护系统（共享的可变数据、声明式编程、为什么要采用函数式编程），第三节 什么是函数式编程（函数式Java编程、引用透明性、面向对象编程和函数式编程的对比、函数式编程实战），第四节 递归和迭代等。
    
    </summary>
    
      <category term="技术文档" scheme="http://linyishui.top/categories/%E6%8A%80%E6%9C%AF%E6%96%87%E6%A1%A3/"/>
    
    
      <category term="java" scheme="http://linyishui.top/tags/java/"/>
    
      <category term="functional" scheme="http://linyishui.top/tags/functional/"/>
    
  </entry>
  
  <entry>
    <title>新的日期和时间API</title>
    <link href="http://linyishui.top/2019100101.html"/>
    <id>http://linyishui.top/2019100101.html</id>
    <published>2019-10-01T08:24:37.000Z</published>
    <updated>2019-12-05T07:01:30.088Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="日期时间"><a href="#日期时间" class="headerlink" title="日期时间"></a><strong>日期时间</strong></h1><h2 id="第一节-背景"><a href="#第一节-背景" class="headerlink" title="第一节 背景"></a><strong>第一节 背景</strong></h2><p>&emsp;&emsp;Java API提供了很多有用的组件，对于日期和时间上的支持如在Java 1.0时提供了java.util.Date类，这个类无法表示日期，只能以毫秒的精度表示时间。而且在设计上有很多缺陷，比如年份从1900开始，月份从0开始，又比如toString方法会返回时区，但Date类并不支持时区。</p><p>&emsp;&emsp;在Java 1.1时就因此废弃了Date类的许多方法，并引入了java.util.Calendar类。但Calendar也有设计上的缺陷，导致写出的代码非常容易出错，比如月份依旧从0开始，并且同时存在Date类和Calendar类也让一些开发者困惑，二者具有各自的特性，比如Date类的DateFormat方法。</p><p>&emsp;&emsp;这些问题导致开发者转投第三方的日期和时间库，比如Joda-Time。Java 8时Oracle希望在Java API中提供高质量的日期和时间支持，比如在java.time包中整合了Joda-Time的一些特性。</p><hr><h2 id="第二节-LocalDate、LocalTime、Instant、Duration、Period"><a href="#第二节-LocalDate、LocalTime、Instant、Duration、Period" class="headerlink" title="第二节 LocalDate、LocalTime、Instant、Duration、Period"></a><strong>第二节 LocalDate、LocalTime、Instant、Duration、Period</strong></h2><h3 id="2-1-LocalDate和LocalTime"><a href="#2-1-LocalDate和LocalTime" class="headerlink" title="2.1 LocalDate和LocalTime"></a><strong>2.1 LocalDate和LocalTime</strong></h3><p>&emsp;&emsp;LocalDate是一个final类，实现了Temporal, TemporalAdjuster, ChronoLocalDate, Serializable这四个接口，可以通过静态工厂of来创建实例。</p><figure class="highlight axapta"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">LocalDate <span class="keyword">date</span> = LocalDate.of(<span class="number">2018</span>,<span class="number">4</span>,<span class="number">16</span>);<span class="comment">//2018-04-01</span></span><br><span class="line"><span class="keyword">int</span> year = <span class="keyword">date</span>.getYear();<span class="comment">//2018</span></span><br><span class="line">Month month = <span class="keyword">date</span>.getMonth();<span class="comment">//APRIL</span></span><br><span class="line"><span class="keyword">int</span> day = <span class="keyword">date</span>.getDayOfMonth();<span class="comment">//16</span></span><br><span class="line">DayOfWeek dow = <span class="keyword">date</span>.getDayOfWeek();<span class="comment">//MONDAY</span></span><br><span class="line"><span class="keyword">int</span> len = <span class="keyword">date</span>.lengthOfMonth();<span class="comment">//30</span></span><br><span class="line"><span class="keyword">boolean</span> leap = <span class="keyword">date</span>.isLeapYear();<span class="comment">//false</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//今天</span></span><br><span class="line">LocalDate today = LocalDate.now();<span class="comment">//2019-10-01</span></span><br><span class="line"><span class="comment">//get(TemporalField field)获取时间信息，TemporalField接口定义了如何访问temporal对象某个字段的值，ChronoField枚举实现了接口</span></span><br><span class="line"><span class="keyword">int</span> yearFromField = today.get(ChronoField.YEAR);<span class="comment">//2019</span></span><br><span class="line"><span class="keyword">int</span> monthFromField = today.get(ChronoField.MONTH_OF_YEAR);<span class="comment">//10</span></span><br><span class="line"><span class="keyword">int</span> dayFromField = today.get(ChronoField.DAY_OF_MONTH);<span class="comment">//1</span></span><br></pre></td></tr></table></figure><p>&emsp;&emsp;LocalTime也是一个final类，实现了Temporal, TemporalAdjuster, Comparable<localtime>, Serializable这四个接口。</localtime></p><figure class="highlight verilog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//LocalTime</span></span><br><span class="line">LocalTime <span class="keyword">time</span> = LocalTime<span class="variable">.of</span>(<span class="number">13</span>,<span class="number">45</span>,<span class="number">20</span>);<span class="comment">//13:45:20</span></span><br><span class="line"><span class="keyword">int</span> hour = <span class="keyword">time</span><span class="variable">.getHour</span>();<span class="comment">//13</span></span><br><span class="line"><span class="keyword">int</span> minute = <span class="keyword">time</span><span class="variable">.getMinute</span>();<span class="comment">//45</span></span><br><span class="line"><span class="keyword">int</span> second = <span class="keyword">time</span><span class="variable">.getSecond</span>();<span class="comment">//20</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//解析字符串构建实例</span></span><br><span class="line">LocalDate date1 = LocalDate<span class="variable">.parse</span>(<span class="string">"2019-06-06"</span>);</span><br><span class="line">LocalTime time1 = LocalTime<span class="variable">.parse</span>(<span class="string">"14:46:21"</span>);</span><br></pre></td></tr></table></figure><h3 id="2-2-合并日期和时间"><a href="#2-2-合并日期和时间" class="headerlink" title="2.2 合并日期和时间"></a><strong>2.2 合并日期和时间</strong></h3><p>&emsp;&emsp;LocalDateTime是LocalDate和LocalTime的复合类，也是一个final类，实现了Temporal, TemporalAdjuster, ChronoLocalDateTime<localdate>, Serializable这四个接口。</localdate></p><figure class="highlight lsl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">LocalDateTime dt1 = LocalDateTime.of(<span class="number">2014</span>,Month.MARCH,<span class="number">18</span>,<span class="number">13</span>,<span class="number">45</span>,<span class="number">20</span>);<span class="comment">//2014-03-18T13:45:20</span></span><br><span class="line">LocalDateTime dt2 = LocalDateTime.of(date,time);<span class="comment">//2018-04-01T13:45:20</span></span><br><span class="line">LocalDateTime dt3 = date.atTime(<span class="number">15</span>,<span class="number">47</span>,<span class="number">22</span>);<span class="comment">//2018-04-01T15:47:22</span></span><br><span class="line">LocalDateTime dt4 = date.atTime(time);<span class="comment">//2018-04-01T13:45:20</span></span><br><span class="line">LocalDateTime dt5 = time.atDate(date);<span class="comment">//2018-04-01T13:45:20</span></span><br><span class="line"><span class="comment">//由复合类拆回LocalDate和LocalTime</span></span><br><span class="line">LocalDate date2 = dt1.toLocalDate();</span><br><span class="line">LocalTime time2 = dt1.toLocalTime();</span><br></pre></td></tr></table></figure><h3 id="2-3-机器的日期和时间格式"><a href="#2-3-机器的日期和时间格式" class="headerlink" title="2.3 机器的日期和时间格式"></a><strong>2.3 机器的日期和时间格式</strong></h3><p>&emsp;&emsp;Instant类描述了计算机对时间的建模，表示一个持续时间段上某个点的单一大整型数，也是一个final类，实现了Temporal, TemporalAdjuster, Comparable<instant>, Serializable这四个接口。</instant></p><figure class="highlight lsl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Instant i1 = Instant.ofEpochSecond(<span class="number">3</span>);<span class="comment">//1970-01-01T00:00:03Z</span></span><br><span class="line">Instant i2 = Instant.ofEpochSecond(<span class="number">3</span>,<span class="number">0</span>);<span class="comment">//第二个参数用来调整纳秒，i1到i4应该几乎是相同的。</span></span><br><span class="line">Instant i3 = Instant.ofEpochSecond(<span class="number">2</span>,<span class="number">1</span>_000_000_000);</span><br><span class="line">Instant i4 = Instant.ofEpochSecond(<span class="number">4</span>,<span class="number">-1</span>_000_000_000);</span><br></pre></td></tr></table></figure><p>&emsp;&emsp;Instant的now()方法可以帮你获取当前时刻的时间戳，但Instant是为机器使用而设计，包含的是由秒及纳秒构成的数字，所以它无法处理为开发者设计的时间单位。</p><figure class="highlight processing"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">int</span> <span class="built_in">day</span> = Instant.now().<span class="built_in">get</span>(ChronoField.DAY_OF_MONTH);<span class="comment">//java.time.temporal.UnsupportedTemporalTypeException: Unsupported field: DayOfMonth</span></span><br></pre></td></tr></table></figure><h3 id="2-4-定义Duration或Period"><a href="#2-4-定义Duration或Period" class="headerlink" title="2.4 定义Duration或Period"></a><strong>2.4 定义Duration或Period</strong></h3><p>&emsp;&emsp;所有类都实现了接口Temporal，Temporal定义了如何读取和操纵为时间建模的对象的值。</p><p>&emsp;&emsp;Duration类是为两个Temporal对象间duration而设计的，可以通过between方法接收两个相同类型参数进行实例化。也是一个final类，实现了TemporalAmount, Comparable<duration>, Serializable这三个接口。</duration></p><figure class="highlight lasso"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">LocalDate <span class="built_in">date</span> = LocalDate.of(<span class="number">2018</span>,<span class="number">4</span>,<span class="number">1</span>);<span class="comment">//2018-04-01</span></span><br><span class="line">LocalTime time1 = LocalTime.parse(<span class="string">"14:46:21"</span>);</span><br><span class="line">LocalTime time2 = LocalTime.parse(<span class="string">"15:46:21"</span>);</span><br><span class="line">LocalDateTime dt1 = time1.atDate(<span class="built_in">date</span>);<span class="comment">//2018-04-01T15:47:22</span></span><br><span class="line">LocalDateTime dt2 = time2.atDate(<span class="built_in">date</span>);<span class="comment">//2018-04-01T15:47:22</span></span><br><span class="line">Instant it1 = Instant.ofEpochSecond(<span class="number">3</span>);</span><br><span class="line">Instant it2 = Instant.ofEpochSecond(<span class="number">4</span>);</span><br><span class="line"><span class="built_in">Duration</span> d1 = <span class="built_in">Duration</span>.between(time1,time2);</span><br><span class="line"><span class="built_in">Duration</span> d2 = <span class="built_in">Duration</span>.between(dt1,dt2);</span><br><span class="line"><span class="built_in">Duration</span> d3 = <span class="built_in">Duration</span>.between(it1,it2);</span><br><span class="line"></span><br><span class="line"><span class="built_in">Duration</span> threeMinutes = <span class="built_in">Duration</span>.ofMinutes(<span class="number">3</span>);</span><br><span class="line"><span class="built_in">Duration</span> threeMinutes1 = <span class="built_in">Duration</span>.of(<span class="number">3</span>, ChronoUnit.MINUTES);</span><br></pre></td></tr></table></figure><p>&emsp;&emsp;Period类可以对年月日的方式对多个时间单位建模。也是一个final类，实现了ChronoPeriod, Serializable这两个接口。</p><figure class="highlight lsl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Period tenDays = Period.between(LocalDate.of(<span class="number">2014</span>,<span class="number">3</span>,<span class="number">8</span>),</span><br><span class="line">        LocalDate.of(<span class="number">2014</span>,<span class="number">3</span>,<span class="number">18</span>));</span><br><span class="line">Period tenDays1 = Period.ofDays(<span class="number">10</span>);</span><br><span class="line">Period threeWeeks = Period.ofWeeks(<span class="number">3</span>);</span><br><span class="line">Period twoYearsSixMonthsOneDay = Period.of(<span class="number">2</span>,<span class="number">6</span>,<span class="number">1</span>);</span><br></pre></td></tr></table></figure><p>&emsp;&emsp;下列表格记录日期—时间类中表示时间间隔的通用方法。</p><table><thead><tr><th style="text-align:left">方法名</th><th style="text-align:left">是否是静态方法</th><th style="text-align:left">方法描述</th></tr></thead><tbody><tr><td style="text-align:left">between</td><td style="text-align:left">是</td><td style="text-align:left">创建两个时间点之间的interval</td></tr><tr><td style="text-align:left">from</td><td style="text-align:left">是</td><td style="text-align:left">由一个临时时间点创建interval</td></tr><tr><td style="text-align:left">of</td><td style="text-align:left">是</td><td style="text-align:left">由它的组成部分创建interval的实例</td></tr><tr><td style="text-align:left">parse</td><td style="text-align:left">是</td><td style="text-align:left">由字符串创建interval的实例</td></tr><tr><td style="text-align:left">addTo</td><td style="text-align:left">否</td><td style="text-align:left">创建该interval的副本，并将其叠加到某个指定的temporal对象</td></tr><tr><td style="text-align:left">get</td><td style="text-align:left">否</td><td style="text-align:left">读取该interval的状态</td></tr><tr><td style="text-align:left">isNegative</td><td style="text-align:left">否</td><td style="text-align:left">检查该interval是否为负值，不包含零</td></tr><tr><td style="text-align:left">isZero</td><td style="text-align:left">否</td><td style="text-align:left">检查该interval的时长是否为零</td></tr><tr><td style="text-align:left">minus</td><td style="text-align:left">否</td><td style="text-align:left">通过减去一定的时间创建该interval的副本</td></tr><tr><td style="text-align:left">multipliedBy</td><td style="text-align:left">否</td><td style="text-align:left">将interval的值乘以某个标量创建该interval的副本</td></tr><tr><td style="text-align:left">nagated</td><td style="text-align:left">否</td><td style="text-align:left">以忽略某个时长的方式创建该interval的副本</td></tr><tr><td style="text-align:left">plus</td><td style="text-align:left">否</td><td style="text-align:left">以增加某个时长的方式创建该interval的副本</td></tr><tr><td style="text-align:left">subtractFrom</td><td style="text-align:left">否</td><td style="text-align:left">从指定的temporal对象中减去该interval</td></tr></tbody></table><p>&emsp;&emsp;上述所有介绍到的日期时间对象都是不可修改的，为了更好地支持函数式编程，确保线程安全，保持领域模式一致性而做出的重大设计决定。为了应对一些需要变换的场景，日期时间API也额外提供了一些方法来创建可变版本。</p><hr><h2 id="第三节-操纵、解析和格式化日期"><a href="#第三节-操纵、解析和格式化日期" class="headerlink" title="第三节 操纵、解析和格式化日期"></a><strong>第三节 操纵、解析和格式化日期</strong></h2><p>&emsp;&emsp;通过方法withAttribute方法来创建LocalDate的修改版本，方法会创建一个对象的副本，并按照需要去修改它的属性。</p><figure class="highlight lsl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">LocalDate ld1 = LocalDate.of(<span class="number">2014</span>,<span class="number">3</span>,<span class="number">18</span>);<span class="comment">//2014-03-18</span></span><br><span class="line">LocalDate ld2 = ld1.withYear(<span class="number">2018</span>);<span class="comment">//2018-03-18</span></span><br><span class="line">LocalDate ld3 = ld2.withDayOfMonth(<span class="number">25</span>);<span class="comment">//2018-03-25</span></span><br><span class="line">LocalDate ld4 = ld3.with(ChronoField.MONTH_OF_YEAR,<span class="number">9</span>);<span class="comment">//2018-09-25</span></span><br></pre></td></tr></table></figure><p>&emsp;&emsp;也可以使用重载方法接收一个TemporalField对象。这些方法都声明于Temporal接口，所有的日期时间API类都实现了这些方法，使用get和with方法我们可以将Temporal对象值得读取和修改区分开。若Temporal对象不支持请求访问的字段，它会抛出一个UnsupportedTemporalTypeException异常。</p><p>&emsp;&emsp;我们能以声明的方式操纵LocalDate对象，通过plus和minus方法对TemporalUnit对象增加或减少一个数字从而前溯或回滚至某个时间段。</p><figure class="highlight lsl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">LocalDate date1 = LocalDate.of(<span class="number">2014</span>,<span class="number">3</span>,<span class="number">18</span>);<span class="comment">//2014-03-18</span></span><br><span class="line">LocalDate date2 = date1.plusWeeks(<span class="number">1</span>);<span class="comment">//2014-03-25</span></span><br><span class="line">LocalDate date3 = date2.minusYears(<span class="number">3</span>);<span class="comment">//2011-03-25</span></span><br><span class="line">LocalDate date4 = date3.plus(<span class="number">6</span>, ChronoUnit.MONTHS);<span class="comment">//2011-09-25</span></span><br></pre></td></tr></table></figure><p>&emsp;&emsp;下列表格记录时间点的日期—时间类的通用方法。</p><table><thead><tr><th style="text-align:left">方法名</th><th style="text-align:left">是否是静态方法</th><th style="text-align:left">方法描述</th></tr></thead><tbody><tr><td style="text-align:left">from</td><td style="text-align:left">是</td><td style="text-align:left">依据传入的Temporal对象创建对象实例</td></tr><tr><td style="text-align:left">now</td><td style="text-align:left">是</td><td style="text-align:left">依据系统时钟创建Temporal对象</td></tr><tr><td style="text-align:left">of</td><td style="text-align:left">是</td><td style="text-align:left">由Temporal对象的某个部分创建该对象的实例</td></tr><tr><td style="text-align:left">parse</td><td style="text-align:left">是</td><td style="text-align:left">由字符串创建Temporal对象的实例</td></tr><tr><td style="text-align:left">atOffset</td><td style="text-align:left">否</td><td style="text-align:left">将Temporal对象和某个时区偏移相结合</td></tr><tr><td style="text-align:left">atZone</td><td style="text-align:left">否</td><td style="text-align:left">将Temporal对象和某个时区相结合</td></tr><tr><td style="text-align:left">format</td><td style="text-align:left">否</td><td style="text-align:left">使用某个指定的格式器将Temporal对象转换为字符串（Instant类不提供该方法）</td></tr><tr><td style="text-align:left">get</td><td style="text-align:left">否</td><td style="text-align:left">读取Temporal对象的某一部分的值</td></tr><tr><td style="text-align:left">minus</td><td style="text-align:left">否</td><td style="text-align:left">创建Temporal对象的一个副本，通过将当前Temporal对象的值减去一定的时长创建该副本</td></tr><tr><td style="text-align:left">plus</td><td style="text-align:left">否</td><td style="text-align:left">创建Temporal对象的一个副本，通过将当前Temporal对象的值加上一定的时长创建该副本</td></tr><tr><td style="text-align:left">with</td><td style="text-align:left">否</td><td style="text-align:left">以Temporal对象为模板，对某些状态进行修改创建该对象的副本</td></tr></tbody></table><h3 id="3-1-TemporalAdjuster"><a href="#3-1-TemporalAdjuster" class="headerlink" title="3.1 TemporalAdjuster"></a><strong>3.1 TemporalAdjuster</strong></h3><p>&emsp;&emsp;有时我们需要调整特定需求的时间间隔，如调整到下个周日、下个工作日、本月的最后一天等等。这时我们可以使用with的重载版本，接收一个TemporalAdjuster对象，可以更加灵活的处理日期。</p><figure class="highlight clean"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">LocalDate date1 = LocalDate.<span class="keyword">of</span>(<span class="number">2014</span>,<span class="number">3</span>,<span class="number">18</span>);<span class="comment">//2014-03-18</span></span><br><span class="line">LocalDate date2 = date1.<span class="keyword">with</span>(nextOrSame(DayOfWeek.SUNDAY));<span class="comment">//2014-03-23</span></span><br><span class="line">LocalDate date3 = date2.<span class="keyword">with</span>(lastDayOfMonth());<span class="comment">//2014-03-31</span></span><br></pre></td></tr></table></figure><p>&emsp;&emsp;下列表格记录TemporalAdjuster中包含的工厂方法。</p><table><thead><tr><th style="text-align:left">方法名</th><th style="text-align:left">方法描述</th></tr></thead><tbody><tr><td style="text-align:left">dayOfWeekInMonth</td><td style="text-align:left">创建一个新的日期，它的值为同一个月中每一周的第几天</td></tr><tr><td style="text-align:left">firstDayOfMonth</td><td style="text-align:left">创建一个新的日期，它的值为当月的第一天</td></tr><tr><td style="text-align:left">firstDayOfNextMonth</td><td style="text-align:left">创建一个新的日期，它的值为下月的第一天</td></tr><tr><td style="text-align:left">firstDayOfNextYear</td><td style="text-align:left">创建一个新的日期，它的值为明年的第一天</td></tr><tr><td style="text-align:left">firstDayOfYear</td><td style="text-align:left">创建一个新的日期，它的值为当年的第一天</td></tr><tr><td style="text-align:left">firstInMonth</td><td style="text-align:left">创建一个新的日期，它的值为同一个月中，第一个符合星期几要求的值</td></tr><tr><td style="text-align:left">lastDayOfMonth</td><td style="text-align:left">创建一个新的日期，它的值为当月的最后一天</td></tr><tr><td style="text-align:left">lastDayOfNextMonth</td><td style="text-align:left">创建一个新的日期，它的值为下月的最后一天</td></tr><tr><td style="text-align:left">lastDayOfNextYear</td><td style="text-align:left">创建一个新的日期，它的值为明年的最后一天</td></tr><tr><td style="text-align:left">lastDayOfYear</td><td style="text-align:left">创建一个新的日期，它的值为今年的最后一天</td></tr><tr><td style="text-align:left">lastInMonth</td><td style="text-align:left">创建一个新的日期，它的值为同一个月中，最后一个符合星期几要求的值</td></tr><tr><td style="text-align:left">next/previous</td><td style="text-align:left">创建一个新的日期，并将其值设定为日期调整后或者调整前，第一个符合指定星期几要求的日期</td></tr><tr><td style="text-align:left">nextOfSame/previousOrSame</td><td style="text-align:left">创建一个新的日期，并将其值设定为日期调整后或者调整前，第一个符合指定星期几要求的日期，如果该日期已符合要求，直接返回该对象</td></tr></tbody></table><p>&emsp;&emsp;即使上述方法不能满足你的需求，还可以自定义自己的TemporalAdjuster。TemporalAdjuster是一个函数式接口，可以看作一个UnaryOperator<temporal>。</temporal></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@FunctionalInterface</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">TemporalAdjuster</span> </span>&#123;</span><br><span class="line">    <span class="function">Temporal <span class="title">adjustInto</span><span class="params">(Temporal temporal)</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="3-1-1-自定义TemporalAdjuster"><a href="#3-1-1-自定义TemporalAdjuster" class="headerlink" title="3.1.1 自定义TemporalAdjuster"></a><strong>3.1.1 自定义TemporalAdjuster</strong></h4><p>&emsp;&emsp;可以实现类NextWorkingDay，并实现adjustInto方法。也可以直接通过方法参数化直接通过Lambda表达式来实现。推荐使用TemporalAdjusters的静态工厂方法ofDateAdjuster来实现。</p><figure class="highlight aspectj"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="function"><span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//通过类实现</span></span><br><span class="line">        LocalDate ta1 = date1.with(<span class="keyword">new</span> NextWorkingDay());<span class="comment">//2014-03-19</span></span><br><span class="line">        <span class="comment">//通过Lambda表达式实现</span></span><br><span class="line">        LocalDate ta2 = date1.with(temporal -&gt; &#123;</span><br><span class="line">            DayOfWeek dow = DayOfWeek.of(temporal.get(ChronoField.DAY_OF_WEEK));</span><br><span class="line">            <span class="keyword">int</span> dayToAdd = <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">if</span>(dow == DayOfWeek.FRIDAY) dayToAdd = <span class="number">3</span>;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span>(dow == DayOfWeek.SATURDAY) dayToAdd = <span class="number">2</span>;</span><br><span class="line">            <span class="function"><span class="keyword">return</span> temporal.<span class="title">plus</span><span class="params">(dayToAdd, ChronoUnit.DAYS)</span></span>;</span><br><span class="line">        &#125;);<span class="comment">//2014-03-19</span></span><br><span class="line">        <span class="comment">//推荐使用工厂方法ofDateAdjuster</span></span><br><span class="line">        TemporalAdjuster nextWorkingDay = TemporalAdjusters.ofDateAdjuster(</span><br><span class="line">                temporal -&gt; &#123;</span><br><span class="line">                    DayOfWeek dow = DayOfWeek.of(temporal.get(ChronoField.DAY_OF_WEEK));</span><br><span class="line">                    <span class="keyword">int</span> dayToAdd = <span class="number">1</span>;</span><br><span class="line">                    <span class="keyword">if</span>(dow == DayOfWeek.FRIDAY) dayToAdd = <span class="number">3</span>;</span><br><span class="line">                    <span class="keyword">else</span> <span class="keyword">if</span>(dow == DayOfWeek.SATURDAY) dayToAdd = <span class="number">2</span>;</span><br><span class="line">                    <span class="function"><span class="keyword">return</span> temporal.<span class="title">plus</span><span class="params">(dayToAdd, ChronoUnit.DAYS)</span></span>;</span><br><span class="line">                &#125;</span><br><span class="line">        );<span class="comment">//2014-03-19</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 计算明天的日期，同时过滤掉周六和周日这些节假日</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">NextWorkingDay</span> <span class="keyword">implements</span> <span class="title">TemporalAdjuster</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="function">Temporal <span class="title">adjustInto</span><span class="params">(Temporal temporal)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//读取当前日期</span></span><br><span class="line">        DayOfWeek dow = DayOfWeek.of(temporal.get(ChronoField.DAY_OF_WEEK));</span><br><span class="line">        <span class="comment">//正常情况加1天</span></span><br><span class="line">        <span class="keyword">int</span> dayToAdd = <span class="number">1</span>;</span><br><span class="line">        <span class="comment">//周五加3天</span></span><br><span class="line">        <span class="keyword">if</span>(dow == DayOfWeek.FRIDAY) dayToAdd = <span class="number">3</span>;</span><br><span class="line">        <span class="comment">//周六加2天</span></span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(dow == DayOfWeek.SATURDAY) dayToAdd = <span class="number">2</span>;</span><br><span class="line">        <span class="comment">//返回修改的日期</span></span><br><span class="line">        <span class="function"><span class="keyword">return</span> temporal.<span class="title">plus</span><span class="params">(dayToAdd, ChronoUnit.DAYS)</span></span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="3-2-打印输出及解析日期—时间对象"><a href="#3-2-打印输出及解析日期—时间对象" class="headerlink" title="3.2 打印输出及解析日期—时间对象"></a><strong>3.2 打印输出及解析日期—时间对象</strong></h3><p>&emsp;&emsp;java.time.format为格式化和解析日期—时间对象而设计，最重要的类是DateTimeFormatter。可以利用DateTimeFormatter生成各种常用格式的日期—时间字符串，也可以解析字符串创建日期对象。相比老版本的DateFormat，所有DateTimeFormatter实例都是线程安全的。</p><figure class="highlight gauss"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">String</span> s1 = date1.<span class="keyword">format</span>(DateTimeFormatter.BASIC_ISO_DATE);<span class="comment">//20140318</span></span><br><span class="line"><span class="keyword">String</span> s2 = date1.<span class="keyword">format</span>(DateTimeFormatter.ISO_LOCAL_DATE);<span class="comment">//2014-03-18</span></span><br><span class="line"></span><br><span class="line">LocalDate lds1 = LocalDate.<span class="built_in">parse</span>(<span class="string">"20140318"</span>,DateTimeFormatter.BASIC_ISO_DATE);</span><br><span class="line">LocalDate lds2 = LocalDate.<span class="built_in">parse</span>(<span class="string">"2014-03-18"</span>,DateTimeFormatter.ISO_LOCAL_DATE);</span><br></pre></td></tr></table></figure><p>&emsp;&emsp;通过ofPattern指定日期—时间格式，当然可以根据需求自定义想要的格式，如果需要更加细粒度的控制，DateTimeFormatterBuilder类还提供了更复杂的格式器，可以区分大小写的解析、柔性解析（允许解析器使用启发式的机制去解析输入，不精确地匹配指定的模式）、填充，以及在格式器中指定可选节。</p><figure class="highlight gauss"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//指定模式创建DateTimeFormatter</span></span><br><span class="line">DateTimeFormatter formatter = DateTimeFormatter.ofPattern(<span class="string">"dd/MM/yyyy"</span>);</span><br><span class="line"><span class="keyword">String</span> formattedDate = date1.<span class="keyword">format</span>(formatter);<span class="comment">//18/03/2014</span></span><br><span class="line">LocalDate fromFormattedDate = LocalDate.<span class="built_in">parse</span>(formattedDate,formatter);</span><br><span class="line"></span><br><span class="line"><span class="comment">//本地化DateTimeFormatter</span></span><br><span class="line">DateTimeFormatter formatterCN = DateTimeFormatter.ofPattern(<span class="string">"yyyy年 MMMM dd日"</span>, Locale.CHINA);</span><br><span class="line"><span class="keyword">String</span> formattedCNDate = date1.<span class="keyword">format</span>(formatterCN);<span class="comment">//2014年 三月 18日</span></span><br><span class="line">LocalDate fromFormattedCNDate = LocalDate.<span class="built_in">parse</span>(formattedCNDate,formatterCN);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//自定义DateTimeFormatter</span></span><br><span class="line">DateTimeFormatter CNFormatter = <span class="keyword">new</span> DateTimeFormatterBuilder()</span><br><span class="line">        .appendText(ChronoField.YEAR)</span><br><span class="line">        .appendLiteral(<span class="string">"年 "</span>)</span><br><span class="line">        .appendText(ChronoField.MONTH_OF_YEAR)</span><br><span class="line">        .appendLiteral(<span class="string">" "</span>)</span><br><span class="line">        .appendText(ChronoField.DAY_OF_MONTH)</span><br><span class="line">        .appendLiteral(<span class="string">"日 "</span>)</span><br><span class="line">        .toFormatter(Locale.CHINA);</span><br><span class="line"><span class="keyword">String</span> stringCNFormatter = date1.<span class="keyword">format</span>(CNFormatter);<span class="comment">//2014年 三月 18日</span></span><br></pre></td></tr></table></figure><h3 id="3-3-处理不同的时区和历法"><a href="#3-3-处理不同的时区和历法" class="headerlink" title="3.3 处理不同的时区和历法"></a><strong>3.3 处理不同的时区和历法</strong></h3><p>&emsp;&emsp;时区的处理是新版API新增的重要功能，java.time.ZoneId类替代了java.util.TimeZone，其设计目标就是让你无需操心时区处理的繁琐。</p><figure class="highlight protobuf"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//地区Id标识：&#123;区域&#125;/&#123;城市&#125;</span></span><br><span class="line">ZoneId romeZone = ZoneId.of(<span class="string">"Europe/Rome"</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">//通过方法toZoneId将旧的时区对象转换为ZoneId</span></span><br><span class="line">ZoneId zoneId = TimeZone.getDefault().toZoneId();</span><br><span class="line"></span><br><span class="line"><span class="comment">//有了ZoneId就可以和日期—时间对象结合成ZonedDateTime实例，代表了对应时区的时间点</span></span><br><span class="line">ZonedDateTime zdt1 = date1.atStartOfDay(romeZone);<span class="comment">//2014-03-18T00:00+01:00[Europe/Rome]</span></span><br><span class="line">LocalDateTime dateTime = date1.atTime(<span class="number">18</span>,<span class="number">13</span>,<span class="number">45</span>);</span><br><span class="line">ZonedDateTime zdt2 = dateTime.atZone(romeZone);<span class="comment">//2014-03-18T18:13:45+01:00[Europe/Rome]</span></span><br><span class="line">Instant instant = Instant.now();</span><br><span class="line">ZonedDateTime zdt3 = instant.atZone(romeZone);<span class="comment">//2019-10-01T03:37:34.201+01:00[Europe/Rome]</span></span><br></pre></td></tr></table></figure><p>&emsp;&emsp;下图对ZonedDateTime的组成部分进行了说明，有助于理解ZonedDateTime和LocalDate、LocalTime、LocalDateTime之间的差异。</p><p><img src="https://pic-1258215793.cos.ap-shanghai.myqcloud.com/content/20191001/201910010101.png" alt="理解ZonedDateTime"></p><figure class="highlight haxe"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//通过ZoneId将Instant转为LocalDateTime</span></span><br><span class="line">LocalDateTime timeFromInstant = LocalDateTime.ofInstant(instant,romeZone);<span class="comment">//2019-12-04T03:52:42.845</span></span><br><span class="line">System.out.println(<span class="string">"timeFromInstant "</span> + timeFromInstant);</span><br><span class="line"></span><br><span class="line"><span class="comment">//表示此时间和伦敦格林尼治子午线时间的差异</span></span><br><span class="line">ZoneOffset <span class="keyword">new</span><span class="type">YorkOffSet</span> = ZoneOffset.of(<span class="string">"-05:00"</span>);</span><br><span class="line"><span class="comment">//但上述方式并未考虑任何夏令时的影响，因此不推荐。</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//ZoneOffset是ZoneId的子类，可以通过其创建OffsetDateTime</span></span><br><span class="line">OffsetDateTime dateTimeInNewYork = OffsetDateTime.of(dateTime,<span class="keyword">new</span><span class="type">YorkOffSet</span>);<span class="comment">//2014-03-18T18:13:45-05:00</span></span><br><span class="line">System.out.println(<span class="string">"dateTimeInNewYork "</span> + dateTimeInNewYork);</span><br><span class="line"></span><br><span class="line"><span class="comment">//可以直接生成Instant</span></span><br><span class="line">Instant fromOffsetLocalDateTime = dateTimeInNewYork.toInstant();</span><br><span class="line"><span class="comment">//LocalDateTime则需要ZoneOffset参数才能生成Instant</span></span><br><span class="line">Instant fromLocalDateTime = dateTime.toInstant(<span class="keyword">new</span><span class="type">YorkOffSet</span>);</span><br></pre></td></tr></table></figure><p>&emsp;&emsp;除了ISO历法日历系统，Java 8还提供了4种其他日历系统分别对应一个类：ThaiBuddhisDate、MinguoDate、JapaneseDate、HijranDate。所有这些类以及LocalDate都实现了ChronoLocalDate接口，能够对公历的日期进行建模。</p><figure class="highlight protobuf"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//根据LocalDate（Temporal对象）创建实例</span></span><br><span class="line">JapaneseDate japaneseDate = JapaneseDate.from(date1);</span><br><span class="line"></span><br><span class="line"><span class="comment">//可以为某个Locale显式的创建日历系统</span></span><br><span class="line">Chronology japaneseChronology = Chronology.ofLocale(Locale.JAPAN);</span><br><span class="line">ChronoLocalDate now = japaneseChronology.dateNow();<span class="comment">//2019-10-01</span></span><br></pre></td></tr></table></figure><p>&emsp;&emsp;API设计者建议避免使用ChronoLocalDate，原因是开发者可能会在代码中做一些假设，而这些假设在不同的日历系统中可能会不成立。比如假设一个月天数不会超过31天，一年12个月，或一年中月数是固定的，因为这些假设请使用LocalDate，包括存储、操作和业务规则的解读。如果是本地化的输出或输入场景，可以尝试使用ChronoLocalDate。</p><hr><p><em>参考博客和文章书籍等：</em></p><blockquote><p>《Java8实战》</p></blockquote><p><em>因博客主等未标明不可引用，若部分内容涉及侵权请及时告知，我会尽快修改和删除相关内容</em></p>]]></content>
    
    <summary type="html">
    
      介绍Java 8中引入的新的日期—时间API，内容包括：第一节—背景，第二节—LocalDate、LocalTime、Instant、Duration、Period（LocalDate和LocalTime、合并日期和时间 机器的日期和时间格式 定义Duration或Period），第三节—操纵、解析和格式化日期（TemporalAdjuster、打印输出及解析日期—时间对象、处理不同的时区和历法）等。
    
    </summary>
    
      <category term="技术文档" scheme="http://linyishui.top/categories/%E6%8A%80%E6%9C%AF%E6%96%87%E6%A1%A3/"/>
    
    
      <category term="java" scheme="http://linyishui.top/tags/java/"/>
    
      <category term="date" scheme="http://linyishui.top/tags/date/"/>
    
      <category term="time" scheme="http://linyishui.top/tags/time/"/>
    
  </entry>
  
  <entry>
    <title>CompletableFuture组合式异步编程</title>
    <link href="http://linyishui.top/2019092801.html"/>
    <id>http://linyishui.top/2019092801.html</id>
    <published>2019-09-28T03:37:33.000Z</published>
    <updated>2019-12-05T06:55:40.972Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="CompletableFuture组合式异步编程"><a href="#CompletableFuture组合式异步编程" class="headerlink" title="CompletableFuture组合式异步编程"></a><strong>CompletableFuture组合式异步编程</strong></h1><h2 id="第一节-引文"><a href="#第一节-引文" class="headerlink" title="第一节 引文"></a><strong>第一节 引文</strong></h2><p>&emsp;&emsp;相比直接使用线程的方式，使用分支/合并框架和并行流能以更简单、更有效的方式来实现并行的效果。如今的互联网程序通常是混聚的方式：使用来自多个来源的内容，将这些内容聚合在一起，来实现功能需求。</p><p><img src="https://pic-1258215793.cos.ap-shanghai.myqcloud.com/content/20190901/201909010149.png" alt="典型的混聚式应用"></p><p>&emsp;&emsp;我们在应用中可能需要和互联网上的多个Web服务通信，但我们并不希望因为等待某些服务的响应而阻塞应用程序的运行，浪费掉数十亿宝贵的CPU时钟周期。如分支/合并框架和并行流这些工具可以帮我们实现并行处理：将一个操作切分为多个子操作，在多个不同的核、CPU甚至是机器上并行地执行这些子操作。</p><p>&emsp;&emsp;如果你的意图是想实现并发，而不是并行，或者你的主要目标是在同一个CPU上执行几个松耦合的任务，充分利用CPU的核，让其足够的忙碌从而最大化程序的吞吐量，那么你真正想做的是避免因为等待远程服务的返回，或者对数据库的查询，而阻塞线程的执行，浪费掉宝贵的计算资源。Future接口，尤其是其新版实现CompletableFuture是处理这种情况的利器。</p><p><img src="https://pic-1258215793.cos.ap-shanghai.myqcloud.com/content/20190901/201909010150.png" alt="并发和并行"></p><hr><h2 id="第二节-Future接口"><a href="#第二节-Future接口" class="headerlink" title="第二节 Future接口"></a><strong>第二节 Future接口</strong></h2><p>&emsp;&emsp;Java 5时引入了Future接口，设计初衷是对将来某个时刻会发生的结果进行建模。它模拟了一种异步计算，返回一个执行运算结果的引用，当运算结束后，这个引用被返回给调用方。所以在执行Future接口中的耗时运算时，调用线程可以被解放出来做其他工作，而不是一直等待运算完成。</p><p>&emsp;&emsp;如下代码，使用Future以异步的方式执行一个耗时的操作。我们在需要异步操作结果才能继续运行时再调用get方法获取操作的结果，如果耗时操作不能像我们期待那样顺利的得出结果，也可以通过参数设定等待时间。</p><figure class="highlight gradle"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> main(String[] args) &#123;</span><br><span class="line">    <span class="comment">//创建一个ExecutorService，可以通过它向线程池提交任务</span></span><br><span class="line">    ExecutorService executor = Executors.newCachedThreadPool();</span><br><span class="line">    <span class="comment">//向ExecutorService提交一个Callable对象</span></span><br><span class="line">    Future&lt;<span class="keyword">Double</span>&gt; future = executor.submit(<span class="keyword">new</span> Callable&lt;<span class="keyword">Double</span>&gt;() &#123;</span><br><span class="line">        @Override</span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">Double</span> <span class="keyword">call</span>() <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">            <span class="comment">//以异步方式在新的线程中执行耗时的操作</span></span><br><span class="line">            <span class="keyword">return</span> doSomeLongComputation();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;);</span><br><span class="line">    <span class="comment">//异步操作进行的同时可以做其他事情</span></span><br><span class="line">    doSomethingElse();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="comment">//获取异步操作的结果，如果最终被阻塞，无法得到结果，则最多等待1秒钟后退出</span></span><br><span class="line">        <span class="keyword">Double</span> result = future.get(<span class="number">1</span>, TimeUnit.SECONDS);</span><br><span class="line">    &#125;<span class="keyword">catch</span> (ExecutionException ex)&#123;</span><br><span class="line">        <span class="comment">//计算抛出一个异常</span></span><br><span class="line">    &#125;<span class="keyword">catch</span> (InterruptedException ex)&#123;</span><br><span class="line">        <span class="comment">//当前线程在等待过程中被中断</span></span><br><span class="line">    &#125;<span class="keyword">catch</span> (TimeoutException ex)&#123;</span><br><span class="line">        <span class="comment">//在Future对象完成之前已过期</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="https://pic-1258215793.cos.ap-shanghai.myqcloud.com/content/20190901/201909010151.png" alt="使用Future以异步方式执行长时间操作"></p><h3 id="Future简介"><a href="#Future简介" class="headerlink" title="Future简介"></a><strong>Future简介</strong></h3><p>&emsp;&emsp;可以参考<a href="../2019080601.html" title="Title">Future接口，常见的线程池中的FutureTask实现</a>。</p><h3 id="Future接口的局限性"><a href="#Future接口的局限性" class="headerlink" title="Future接口的局限性"></a><strong>Future接口的局限性</strong></h3><p>&emsp;&emsp;Future接口提供了方法（isDone）来检测异步计算是否已经结束，等待异步操作结束，以及获取计算的结果。但这些特性并不能让我们编写足够简洁的并发代码，比如我们很难表述Future结果间的依赖性：“当长时间计算任务完成时，请将该计算的结果通知另一个长时间运行的计算任务，这两个计算任务都完成后，将计算的结果与另一个查询操作结果合并”。</p><blockquote><p>Future不能满足的一些需求：</p><ul><li>将两个异步计算合并为一个，两个异步计算间相互独立，同时第二个又依赖于第一个的结果</li><li>等待Future集合中的所有任务都完成</li><li>仅等待Future集合中最快的任务完成，并返回其结果</li><li>仅通过编程方式完成一个Future任务的执行，以手工设定异步操作结果的方式</li><li>应对Future的完成事件，即当Future的完成事件发生时会收到通知，并能用Future计算的结果进行下一步的操作，而不是简单的阻塞等待结果</li></ul></blockquote><hr><h2 id="第三节-实现异步API"><a href="#第三节-实现异步API" class="headerlink" title="第三节 实现异步API"></a><strong>第三节 实现异步API</strong></h2><h3 id="3-1-使用CompletableFuture构建异步应用"><a href="#3-1-使用CompletableFuture构建异步应用" class="headerlink" title="3.1 使用CompletableFuture构建异步应用"></a><strong>3.1 使用CompletableFuture构建异步应用</strong></h3><p>&emsp;&emsp;假设一个需求：最佳价格查询器，需要查询多个在线商店，依据给定的产品或服务找出最低的价格</p><blockquote><ol><li>学会如何为客户提供异步API</li><li>掌握如何让使用了同步API的代码变为非阻塞代码。了解如何使用流水线将两个接续的异步操作合并为一个异步计算操作。</li><li>学会如何以响应式的方式处理异步操作的完成事件</li></ol></blockquote><blockquote><p>同步API和异步API?</p><ul><li><strong>同步API</strong>：同步API是对传统方法调用的称呼，调用方会在被调用方运行时等待，被调用方运行结束返回，调用方取得返回值继续运行。即使两者在不同的线程中运行，调用方还是要等被调用方结束运行，这就是<strong>阻塞式调用</strong>。</li><li><strong>异步API</strong>：异步API则会直接返回，或者至少在被调用方法计算完成之前，将它剩余的计算任务交给另一个线程去做，该线程和调用方是异步的，这种方式是<strong>非阻塞式调用</strong>。执行剩余计算的线程会把计算结果返回给调用方，返回的方式要么是通过回调函数，要么是通过调用方再执行一个“等待直到计算完成”的方法调用。</li></ul></blockquote><h3 id="3-2-同步API"><a href="#3-2-同步API" class="headerlink" title="3.2 同步API"></a><strong>3.2 同步API</strong></h3><p>&emsp;&emsp;我们首先根据需求用传统方式实现API，代码如下。</p><figure class="highlight aspectj"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Shop</span> </span>&#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 获取价格</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> product 产品</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> 价格</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="function"><span class="keyword">double</span> <span class="title">getPrice</span><span class="params">(String product)</span></span>&#123;</span><br><span class="line">        <span class="comment">//需要查询商店的数据库</span></span><br><span class="line">        <span class="comment">//可能要联系其他外部服务，比如商店的供应商，和制造商相关的推广折扣</span></span><br><span class="line">        <span class="comment">//ToDo</span></span><br><span class="line">        <span class="function"><span class="keyword">return</span> <span class="title">calculatePrice</span><span class="params">(product)</span></span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 计算获取价格</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> product 产品</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> 价格</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="function"><span class="keyword">double</span> <span class="title">calculatePrice</span><span class="params">(String product)</span></span>&#123;</span><br><span class="line">        delay();</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> Random().nextDouble() * product.charAt(<span class="number">0</span>) + product.charAt(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 模拟耗时操作，1s延迟</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="function"><span class="keyword">void</span> <span class="title">delay</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">try</span>&#123;</span><br><span class="line">            Thread.sleep(<span class="number">1000</span>L);</span><br><span class="line">        &#125;<span class="keyword">catch</span> (InterruptedException ex)&#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="3-3-将同步方法转换为异步方法"><a href="#3-3-将同步方法转换为异步方法" class="headerlink" title="3.3 将同步方法转换为异步方法"></a><strong>3.3 将同步方法转换为异步方法</strong></h3><p>&emsp;&emsp;我们通过CompletableFuture来实现这一转换，如下代码。创建一个代表异步计算的CompletableFuture实例，它在计算完成时会包含计算的结果，接着调用fork创建了另一个线程去执行实际的价格计算工作，不等待计算完成，直接返回一个Future实例。</p><figure class="highlight zephir"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 获取价格—异步</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> product 产品</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> 价格-暂不可知</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> Future&lt;<span class="keyword">Double</span>&gt; getPriceAsync(String product)&#123;</span><br><span class="line">    <span class="comment">//创建CompletableFuture对象，它会包含计算的结果</span></span><br><span class="line">    CompletableFuture&lt;<span class="keyword">Double</span>&gt; futurePrice = <span class="keyword">new</span> CompletableFuture&lt;&gt;();</span><br><span class="line">    <span class="comment">//开启一个新的线程来执行计算</span></span><br><span class="line">    <span class="keyword">new</span> Thread(() -&gt; &#123;</span><br><span class="line">        <span class="keyword">double</span> price = calculatePrice(product);</span><br><span class="line">        <span class="comment">//设置Future的返回值</span></span><br><span class="line">        futurePrice.complete(price);</span><br><span class="line">    &#125;).start();</span><br><span class="line">    <span class="comment">//无需等待还未结束的计算，直接返回Future&lt;Double&gt;对象</span></span><br><span class="line">    <span class="keyword">return</span> futurePrice;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>&emsp;&emsp;我们尝试调用异步API，代码如下。用户向商店查询了某种商品的价格，商店实现了异步API，所以直接取到了Future返回。在等待结果的过程中，用户可以做一些其他操作，等到客户要执行的操作依赖于商品价格时，再调用futurePrice.get()。执行此操作后，客户要么获得Future封装的值，要么发生阻塞直到异步任务完成。</p><figure class="highlight cs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">Test</span> &#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span>(<span class="params">String[] args</span>) </span>&#123;</span><br><span class="line">        Shop shop = <span class="keyword">new</span> Shop(<span class="string">"BestShop"</span>);</span><br><span class="line">        <span class="keyword">long</span> start = System.nanoTime();</span><br><span class="line">        Future&lt;Double&gt; futurePrice = shop.getPriceAsync(<span class="string">"my favorite product"</span>);</span><br><span class="line">        <span class="keyword">long</span> invocationTime = ((System.nanoTime() - start) / <span class="number">1</span>_000_000);</span><br><span class="line">        System.<span class="keyword">out</span>.println(<span class="string">"Invocation returned after "</span> + invocationTime + <span class="string">" msecs"</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//执行更多任务，比如查询其他商店</span></span><br><span class="line">        doSomethingElse();</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">double</span> price = futurePrice.<span class="keyword">get</span>();</span><br><span class="line">            System.<span class="keyword">out</span>.printf(<span class="string">"Price is %.2f%n"</span>,price);</span><br><span class="line">        &#125;<span class="keyword">catch</span> (Exception ex)&#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException(ex);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">long</span> retrievalTime = ((System.nanoTime() - start) / <span class="number">1</span>_000_000);</span><br><span class="line">        System.<span class="keyword">out</span>.println(<span class="string">"Price returned after "</span> + retrievalTime + <span class="string">" msecs"</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">doSomethingElse</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">        <span class="keyword">try</span>&#123;</span><br><span class="line">            System.<span class="keyword">out</span>.println(<span class="string">"doSomethingElse"</span>);</span><br><span class="line">            Thread.sleep(<span class="number">1000</span>L);</span><br><span class="line">        &#125;<span class="keyword">catch</span> (InterruptedException ex)&#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>&emsp;&emsp;执行代码结果如下，异步API的返回远远早于价格计算完成的时间。</p><figure class="highlight applescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Invocation returned <span class="keyword">after</span> <span class="number">182</span> msecs</span><br><span class="line">doSomethingElse</span><br><span class="line">Price <span class="keyword">is</span> <span class="number">155.07</span></span><br><span class="line">Price returned <span class="keyword">after</span> <span class="number">1224</span> msecs</span><br></pre></td></tr></table></figure><h3 id="3-4-错误处理"><a href="#3-4-错误处理" class="headerlink" title="3.4 错误处理"></a><strong>3.4 错误处理</strong></h3><p>&emsp;&emsp;如果上述代码在计算过程中发生了错误呢？用于提示错误的异常会被限制在视图计算商品价格的当前线程内，最终会杀死该线程，而这会导致等待get方法返回结果的客户端永久的封闭。</p><p>&emsp;&emsp;我们可以调用get方法的重载版本设置一个等待时间，防止永久的等待。但这种方法我们无法得知计算时到底发生了什么问题，如果我们想让客户端能了解商店无法提供请求商品价格的原因，可以使用CompletableFuture的completeExceptionally方法，将导致CompletableFuture发生问题的异常抛出。</p><figure class="highlight zephir"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//设置一个等待时间</span></span><br><span class="line"><span class="keyword">double</span> price = futurePrice.get(<span class="number">1</span>, TimeUnit.SECONDS);</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> Future&lt;<span class="keyword">Double</span>&gt; getPriceAsync(String product)&#123;</span><br><span class="line">    <span class="comment">//创建CompletableFuture对象，它会包含计算的结果</span></span><br><span class="line">    CompletableFuture&lt;<span class="keyword">Double</span>&gt; futurePrice = <span class="keyword">new</span> CompletableFuture&lt;&gt;();</span><br><span class="line">    <span class="comment">//开启一个新的线程来执行计算</span></span><br><span class="line">    <span class="keyword">new</span> Thread(() -&gt; &#123;</span><br><span class="line">        <span class="keyword">try</span>&#123;</span><br><span class="line">            <span class="keyword">double</span> price = calculatePrice(product);</span><br><span class="line">            <span class="comment">//设置Future的返回值</span></span><br><span class="line">            futurePrice.complete(price);</span><br><span class="line">        &#125;<span class="keyword">catch</span> (<span class="keyword">Exception</span> ex)&#123;</span><br><span class="line">            <span class="comment">//抛出导致失败的异常，完成此次Future操作</span></span><br><span class="line">            futurePrice.completeExceptionally(ex);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;).start();</span><br><span class="line">    <span class="comment">//无需等待还未结束的计算，直接返回Future&lt;Double&gt;对象</span></span><br><span class="line">    <span class="keyword">return</span> futurePrice;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="3-5-通过工厂方法supplyAsync优化CompletableFuture"><a href="#3-5-通过工厂方法supplyAsync优化CompletableFuture" class="headerlink" title="3.5 通过工厂方法supplyAsync优化CompletableFuture"></a><strong>3.5 通过工厂方法supplyAsync优化CompletableFuture</strong></h3><p>&emsp;&emsp;CompletableFuture提供了很多精巧的工厂方法来帮助我们更容易的实现流程，还不用操心实现的细节，可以重写getPriceAsync方法如下。此实现和上述是等价的，也具有错误处理机制。</p><figure class="highlight fortran"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> Future&lt;<span class="keyword">Double</span>&gt; getPriceAsync(String <span class="built_in">product</span>)&#123;</span><br><span class="line">    <span class="keyword">return</span> CompletableFuture.supplyAsync(() -&gt; calculatePrice(<span class="built_in">product</span>));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>&emsp;&emsp;supplyAsync方法接受一个Supplier参数，返回CompletableFuture对象，此对象完成异步执行后会读取调用生产者方法的返回值。生产者方法会交由ForkJoinPool池中的某个执行线程（Executor）运行。重载版本添加了参数Executor，表示你可以自行指定执行线程。</p><figure class="highlight cs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> &lt;U&gt; <span class="function">CompletableFuture&lt;U&gt; <span class="title">supplyAsync</span>(<span class="params">Supplier&lt;U&gt; supplier</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> asyncSupplyStage(asyncPool, supplier);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> &lt;U&gt; <span class="function">CompletableFuture&lt;U&gt; <span class="title">supplyAsync</span>(<span class="params">Supplier&lt;U&gt; supplier,</span></span></span><br><span class="line"><span class="function"><span class="params">                                                   Executor executor</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> asyncSupplyStage(screenExecutor(executor), supplier);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">static</span> &lt;U&gt; <span class="function">CompletableFuture&lt;U&gt; <span class="title">asyncSupplyStage</span>(<span class="params">Executor e,</span></span></span><br><span class="line"><span class="function"><span class="params">                                                 Supplier&lt;U&gt; f</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (f == <span class="literal">null</span>) <span class="keyword">throw</span> <span class="keyword">new</span> NullPointerException();</span><br><span class="line">    CompletableFuture&lt;U&gt; d = <span class="keyword">new</span> CompletableFuture&lt;U&gt;();</span><br><span class="line">    e.execute(<span class="keyword">new</span> AsyncSupply&lt;U&gt;(d, f));</span><br><span class="line">    <span class="keyword">return</span> d;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="3-6-避免阻塞"><a href="#3-6-避免阻塞" class="headerlink" title="3.6 避免阻塞"></a><strong>3.6 避免阻塞</strong></h3><p>&emsp;&emsp;如果我们无法控制API的实现，可能最终拿到的API都是同步阻塞式的方法，那么要如何以异步的方式来查询多个商店，避免被单一的请求阻塞？</p><p>&emsp;&emsp;假设我们需要根据产品名查询多个商店中对应的价格，首先可以试一下用Stream来实现这一需求。</p><figure class="highlight haxe"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">List&lt;Shop&gt; shops = Arrays.asList(<span class="keyword">new</span> <span class="type">Shop</span>(<span class="string">"BestPrice"</span>),</span><br><span class="line">        <span class="keyword">new</span> <span class="type">Shop</span>(<span class="string">"LetsSaveBig"</span>),</span><br><span class="line">        <span class="keyword">new</span> <span class="type">Shop</span>(<span class="string">"MyFavoriteShop"</span>),</span><br><span class="line">        <span class="keyword">new</span> <span class="type">Shop</span>(<span class="string">"BuyItAll"</span>));</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 查询产品商店名和价格</span></span><br><span class="line"><span class="comment"> * @param product 产品</span></span><br><span class="line"><span class="comment"> * @return</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> List&lt;<span class="keyword">String</span>&gt; findPrices(<span class="keyword">String</span> product)&#123;</span><br><span class="line">    <span class="keyword">return</span> shops.stream()</span><br><span class="line">            .map(shop -&gt; <span class="keyword">String</span>.format(<span class="string">"%s price is %.2f"</span>,shop.getName(),shop.getPrice(product)))</span><br><span class="line">            .collect(Collectors.toList());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>&emsp;&emsp;测试一下findPrices性能，运行大概需要4s，对四个商店的查询是顺序执行的，一个查询操作会阻塞另一个，而每个查询大概都需要1s的时间计算产品价格。</p><figure class="highlight d"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">long</span> start = System.nanoTime();</span><br><span class="line">List&lt;String&gt; result = findPrices(<span class="string">"myPhone27S"</span>);</span><br><span class="line">System.<span class="keyword">out</span>.println(result);</span><br><span class="line"><span class="built_in">long</span> duration = (System.nanoTime() - start) / <span class="number">1_000_000</span>;</span><br><span class="line">System.<span class="keyword">out</span>.println(<span class="string">"Done in "</span> + duration + <span class="string">" msecs"</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">//输出如下</span></span><br><span class="line">[BestPrice price <span class="keyword">is</span> <span class="number">188.28</span>, LetsSaveBig price <span class="keyword">is</span> <span class="number">207.11</span>, MyFavoriteShop price <span class="keyword">is</span> <span class="number">223.33</span>, BuyItAll price <span class="keyword">is</span> <span class="number">165.98</span>]</span><br><span class="line">Done <span class="keyword">in</span> <span class="number">4152</span> msecs</span><br></pre></td></tr></table></figure><p>&emsp;&emsp;试着用并行流进行优化，避免顺序计算，结果总耗时降低到1s多，效果还是很明显的。</p><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">public <span class="keyword">static</span> <span class="built_in">List</span>&lt;<span class="built_in">String</span>&gt; findPrices(<span class="built_in">String</span> product)&#123;</span><br><span class="line">    <span class="keyword">return</span> shops.parallelStream()</span><br><span class="line">            .map(shop -&gt; <span class="built_in">String</span>.format(<span class="string">"%s price is %.2f"</span>,shop.getName(),shop.getPrice(product)))</span><br><span class="line">            .collect(Collectors.toList());</span><br><span class="line">&#125;</span><br><span class="line">            </span><br><span class="line"><span class="comment">//输出如下</span></span><br><span class="line">[BestPrice price <span class="keyword">is</span> <span class="number">178.36</span>, LetsSaveBig price <span class="keyword">is</span> <span class="number">162.40</span>, MyFavoriteShop price <span class="keyword">is</span> <span class="number">160.91</span>, BuyItAll price <span class="keyword">is</span> <span class="number">214.49</span>]</span><br><span class="line">Done <span class="keyword">in</span> <span class="number">1127</span> msecs</span><br></pre></td></tr></table></figure><p>&emsp;&emsp;再试着用CompletableFuture将findPrices方法中对不同商店的同步调用替换为异步调用。</p><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">public <span class="keyword">static</span> <span class="built_in">List</span>&lt;<span class="built_in">String</span>&gt; findPricesAsync(<span class="built_in">String</span> product)&#123;</span><br><span class="line">    <span class="comment">//通过CompletableFuture以异步方式计算每种商品的价格</span></span><br><span class="line">    <span class="built_in">List</span>&lt;CompletableFuture&lt;<span class="built_in">String</span>&gt;&gt; priceFuture =</span><br><span class="line">            shops.stream()</span><br><span class="line">                    .map(shop -&gt; CompletableFuture.supplyAsync(</span><br><span class="line">                            () -&gt; <span class="built_in">String</span>.format(<span class="string">"%s price is %.2f"</span>,shop.getName(),shop.getPrice(product))</span><br><span class="line">                    )).collect(Collectors.toList());</span><br><span class="line">    <span class="comment">//等待所有异步操作结束，join方法与Future.get()含义相同，但不会抛出检测的异常</span></span><br><span class="line">    <span class="keyword">return</span> priceFuture.stream().map(CompletableFuture::join).collect(Collectors.toList());</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//输出如下</span></span><br><span class="line">[BestPrice price <span class="keyword">is</span> <span class="number">137.63</span>, LetsSaveBig price <span class="keyword">is</span> <span class="number">128.50</span>, MyFavoriteShop price <span class="keyword">is</span> <span class="number">146.31</span>, BuyItAll price <span class="keyword">is</span> <span class="number">193.07</span>]</span><br><span class="line">Done <span class="keyword">in</span> <span class="number">1193</span> msecs</span><br></pre></td></tr></table></figure><p>&emsp;&emsp;我们使用了两个不同的Stream流水线，而不是在同一个处理流的流水线上链接两个map操作，考虑流操作之间的延迟性，如果在单一流水线中处理流，发像不同商家的请求只能以同步、顺序执行的方式才会成功。所以单一流水线时每个CompletableFuture对象只能在前一个操作结束之后执行查询指定商家的动作，通知join方法返回计算结果。</p><p>&emsp;&emsp;下图显式了为什么Stream的延迟特性会引起顺序执行，以及如何避免。</p><p><img src="https://pic-1258215793.cos.ap-shanghai.myqcloud.com/content/20190901/201909010152.png" alt="为什么Stream的延迟特性会引起顺序执行，以及如何避免"></p><p>&emsp;&emsp;使用CompletableFuture后的效率并不比并行流要高，究竟是因为什么？首先并行流能提高效率是因为它能并行的执行四个任务，那如果我们把商家增加到线程无法一一分配的数量呢？我在加到8个的时候还能保持在1s，但如果商家再多时间就会马上增加一倍。多出的商家只能等前面任务结束才能执行。如果是CompletableFuture版本呢？结果也会在达到线程上限时成倍增加耗时。</p><figure class="highlight actionscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Done <span class="keyword">in</span> <span class="number">1191</span> msecs <span class="comment">//8个商家</span></span><br><span class="line">Done <span class="keyword">in</span> <span class="number">2131</span> msecs <span class="comment">//9个商家</span></span><br></pre></td></tr></table></figure><p>&emsp;&emsp;两种方法都采用同样的通用线程池，具体线程数取决于Runtime.getRuntime().availableProcessors()。CompletableFuture的优势在于允许对执行其（Executor）进行配置，特别是线程池的大小，这是并行流所无法提供的。</p><h3 id="3-7-定制执行器"><a href="#3-7-定制执行器" class="headerlink" title="3.7 定制执行器"></a><strong>3.7 定制执行器</strong></h3><p>&emsp;&emsp;线程数量如何选择是一个问题，这里不作扩展，在并发编程部分再作整理。我们先用商店数目来作线程数，然后给一个上限以防服务器超负荷崩溃。</p><figure class="highlight d"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//创建一个线程数为100以及商店数目中较小数字数量的线程池</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> Executor executor = Executors.newFixedThreadPool(</span><br><span class="line">        Math.min(shops.size(), <span class="number">100</span>), <span class="keyword">new</span> ThreadFactory() &#123;</span><br><span class="line">            <span class="keyword">@Override</span></span><br><span class="line">            <span class="keyword">public</span> Thread newThread(Runnable r) &#123;</span><br><span class="line">                Thread t = <span class="keyword">new</span> Thread(r);</span><br><span class="line">                <span class="comment">//使用守护线程，不会阻止程序的关停</span></span><br><span class="line">                t.setDaemon(<span class="literal">true</span>);</span><br><span class="line">                <span class="keyword">return</span> t;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">);</span><br><span class="line"></span><br><span class="line">    List&lt;CompletableFuture&lt;String&gt;&gt; priceFuture =</span><br><span class="line">            shops.stream()</span><br><span class="line">                    .map(shop -&gt; CompletableFuture.supplyAsync(</span><br><span class="line">                            () -&gt; shop.getName() + <span class="string">" price is "</span> + shop.getPrice(product),executor)</span><br><span class="line">                    ).collect(Collectors.toList());</span><br><span class="line"></span><br><span class="line"><span class="comment">//输出如下</span></span><br><span class="line">[BestPrice price <span class="keyword">is</span> <span class="number">159.6635803338069</span>, LetsSaveBig price <span class="keyword">is</span> <span class="number">211.5815957999706</span>, MyFavoriteShop price <span class="keyword">is</span> <span class="number">163.89033905158914</span>, BuyItAll price <span class="keyword">is</span> <span class="number">207.90324683524352</span>, aaa price <span class="keyword">is</span> <span class="number">228.41628707718928</span>, bbb price <span class="keyword">is</span> <span class="number">217.44062760239154</span>, ccc price <span class="keyword">is</span> <span class="number">228.53941558431086</span>, ddd price <span class="keyword">is</span> <span class="number">124.72630278636122</span>, ddd price <span class="keyword">is</span> <span class="number">207.93080231005356</span>]</span><br><span class="line">Done <span class="keyword">in</span> <span class="number">1074</span> msecs</span><br></pre></td></tr></table></figure><p>&emsp;&emsp;经过线程优化后，耗时又降低到了1s。</p><blockquote><p>怎样选择流和CompletableFuture？</p><ul><li>如果要进行的是计算密集型操作，且没有I/O，推荐使用流。因为实现简单，效率也可能是最高的，如果所有线程都是计算密集型，就没有必要创建大于CPU核心数的线程了。</li><li>如果并行工作的单元还涉及到等待I/O的操作，则选择CompletableFuture灵活性会更好，还有一个原因是并行流不能清楚了判断触发等待的原因。</li></ul></blockquote><h3 id="3-8-对多个异步任务进行流水线操作"><a href="#3-8-对多个异步任务进行流水线操作" class="headerlink" title="3.8 对多个异步任务进行流水线操作"></a><strong>3.8 对多个异步任务进行流水线操作</strong></h3><h4 id="3-8-1-实现折扣服务"><a href="#3-8-1-实现折扣服务" class="headerlink" title="3.8.1 实现折扣服务"></a><strong>3.8.1 实现折扣服务</strong></h4><p>&emsp;&emsp;我们假设所以商店都同意使用一个集中式的折扣服务，总共有五种不同的折扣代码，对应不同的折扣率。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 折扣</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Discount</span> &#123;</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">enum</span> Code&#123;</span><br><span class="line">        NONE(<span class="number">0</span>),SILVER(<span class="number">5</span>),GOLD(<span class="number">10</span>),PLATINUM(<span class="number">15</span>),DIAMOND(<span class="number">20</span>);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">private</span> final <span class="keyword">int</span> percentage;</span><br><span class="line"></span><br><span class="line">        Code(<span class="keyword">int</span> percentage) &#123;</span><br><span class="line">            <span class="keyword">this</span>.percentage = percentage;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> String <span class="title">applyDiscount</span><span class="params">(Quote quote)</span></span>&#123;</span><br><span class="line">        <span class="comment">//将折扣代码应用于商品原价</span></span><br><span class="line">        <span class="keyword">return</span> quote.getShopName() + <span class="string">" price is "</span> +</span><br><span class="line">                Discount.apply(quote.getPrice(),quote.getDiscountCode());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">double</span> <span class="title">apply</span><span class="params">(<span class="keyword">double</span> price, Code code)</span></span>&#123;</span><br><span class="line">        <span class="comment">//模拟Discount服务的响应延迟</span></span><br><span class="line">        delay();</span><br><span class="line">        <span class="keyword">return</span> price * (<span class="number">100</span> - code.percentage) / <span class="number">100</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>&emsp;&emsp;然后实现getPrice方法增加了返回随机折扣价格，更新了所有商家的价格返回格式。</p><figure class="highlight gauss"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 获取商品以及随机折扣</span></span><br><span class="line"><span class="comment"> * @param product 产品</span></span><br><span class="line"><span class="comment"> * @return 价格</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">public <span class="keyword">String</span> getPrice(<span class="keyword">String</span> product)&#123;</span><br><span class="line">    double price = calculatePrice(product);</span><br><span class="line">    Discount.<span class="built_in">Code</span> <span class="built_in">code</span> = Discount.<span class="built_in">Code</span>.values()[<span class="keyword">new</span> Random().nextInt(Discount.<span class="built_in">Code</span>.values().length)];</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">String</span>.<span class="keyword">format</span>(<span class="string">"%s:%.2f:%s"</span>,name,price,<span class="built_in">code</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>&emsp;&emsp;实现了Quote类对新的返回格式字符串进行解析，静态工厂方法parse得到实例。</p><figure class="highlight processing"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 解析商店返回字符串</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> class Quote &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">String</span> shopName;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">double</span> price;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> Discount.Code discountCode;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> Quote parse(<span class="keyword">String</span> s)&#123;</span><br><span class="line">        <span class="keyword">String</span>[] <span class="built_in">split</span> = s.<span class="built_in">split</span>(<span class="string">":"</span>);</span><br><span class="line">        <span class="keyword">String</span> shopName = <span class="built_in">split</span>[<span class="number">0</span>];</span><br><span class="line">        <span class="keyword">double</span> price = Double.parseDouble(<span class="built_in">split</span>[<span class="number">1</span>]);</span><br><span class="line">        Discount.Code discountCode = Discount.Code.valueOf(<span class="built_in">split</span>[<span class="number">2</span>]);</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> Quote(shopName,price,discountCode);</span><br><span class="line">    &#125;</span><br><span class="line">    ......</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="3-8-2-构造同步和异步操作"><a href="#3-8-2-构造同步和异步操作" class="headerlink" title="3.8.2 构造同步和异步操作"></a><strong>3.8.2 构造同步和异步操作</strong></h4><p>&emsp;&emsp;然后就是使用这些方法了，首先我们用最直接的顺序执行方式，实现getPrices方法。我们运行并观察性能，结果耗时10s，其中顺序查询5个商店耗时5s，又加上了Discount服务为5个商店返回价格申请折扣消耗5s。</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">List</span>&lt;<span class="type">String</span>&gt; getPrices(<span class="type">String</span> product)&#123;</span><br><span class="line">    <span class="keyword">return</span> shops.stream().<span class="built_in">map</span>(shop -&gt; shop.getPrice(product))</span><br><span class="line">            <span class="comment">//通过Quote对shop返回字符串进行解析</span></span><br><span class="line">            .<span class="built_in">map</span>(<span class="type">Quote</span>::parse)</span><br><span class="line">            <span class="comment">//调用applyDiscount方法为每个Quote申请折扣</span></span><br><span class="line">            .<span class="built_in">map</span>(<span class="type">Discount</span>::applyDiscount)</span><br><span class="line">            .collect(<span class="type">Collectors</span>.toList());</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//输出如下</span></span><br><span class="line">[<span class="type">BestPrice</span> price <span class="keyword">is</span> <span class="number">118.42199999999998</span>, <span class="type">LetsSaveBig</span> price <span class="keyword">is</span> <span class="number">166.13099999999997</span>, <span class="type">MyFavoriteShop</span> price <span class="keyword">is</span> <span class="number">136.0765</span>, <span class="type">BuyItAll</span> price <span class="keyword">is</span> <span class="number">166.00799999999998</span>, <span class="type">ShopEasy</span> price <span class="keyword">is</span> <span class="number">195.2365</span>]</span><br><span class="line"><span class="type">Done</span> <span class="keyword">in</span> <span class="number">10088</span> msecs</span><br></pre></td></tr></table></figure><p>&emsp;&emsp;直接转为并行流，耗时下降到2s。</p><figure class="highlight actionscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Done <span class="keyword">in</span> <span class="number">2116</span> msecs</span><br></pre></td></tr></table></figure><p><img src="https://pic-1258215793.cos.ap-shanghai.myqcloud.com/content/20190901/201909010153.png" alt="构造同步操作和异步任务"></p><p>&emsp;&emsp;通过CompletableFuture以异步方式重新实现getPrices方法。大概流程：shop对象——(supplyAsync)——&gt;shop.getPrice——(thenApply)——&gt;new Quote——(thenCompose)——&gt;applyDiscount——(join)——&gt;price对象。</p><figure class="highlight lasso"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> static <span class="built_in">List</span>&lt;<span class="built_in">String</span>&gt; getPricesAsync(<span class="built_in">String</span> product)&#123;</span><br><span class="line">    <span class="built_in">List</span>&lt;CompletableFuture&lt;<span class="built_in">String</span>&gt;&gt; priceFuture =</span><br><span class="line">            shops.stream()</span><br><span class="line">                    <span class="comment">//以异步的方式取得每个shop中指定产品的价格</span></span><br><span class="line">                    .<span class="built_in">map</span>(shop -&gt; CompletableFuture.supplyAsync(</span><br><span class="line">                            () -&gt; shop.getPrice(product),executor))</span><br><span class="line">                    <span class="comment">//当Quote对象存在时，对返回值进行转换</span></span><br><span class="line">                    .<span class="built_in">map</span>(future -&gt; future.thenApply(Quote<span class="type">::parse</span>))</span><br><span class="line">                    <span class="comment">//使用另一个异步任务构造期望的Future，申请折扣</span></span><br><span class="line">                    .<span class="built_in">map</span>(future -&gt; future.thenCompose(</span><br><span class="line">                            quote -&gt; CompletableFuture.supplyAsync(</span><br><span class="line">                                    () -&gt; Discount.applyDiscount(quote),executor)))</span><br><span class="line">                    .collect(Collectors.toList());</span><br><span class="line">    <span class="comment">//等待流中所有Future执行完毕，提取各自返回值</span></span><br><span class="line">    <span class="keyword">return</span> priceFuture.stream().<span class="built_in">map</span>(CompletableFuture<span class="type">::join</span>).collect(Collectors.toList());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>&emsp;&emsp;<strong>获取价格</strong>，第一步以异步方式对shop查询，获得Stream&lt;CompletableFuture<string>&gt;，当操作结束每个CompletableFuture对象都包含着对应shop返回的字符串。</string></p><p>&emsp;&emsp;<strong>解析报价</strong>，第二步将字符串转为订单，因为解析过程一般不涉及远程服务或I/O操作，几乎都会在第一时间进行，可以采用同步操作。当CompletableFuture最终结束运行时，传递Lambda表达式给thenApply，将流中的每个CompletableFuture<string>转换为CompletableFuture<quote>。</quote></string></p><p>&emsp;&emsp;<strong>为计算折扣价格构造Future</strong>，第三步涉及到远程服务Discount，为从商店中获取的原价申请折扣率。这一步需要远程执行，所以应该异步执行。所以我们像第一步那样调用supplyAsync。最终实现了两步异步操作，用了两个CompletableFuture对象进行建模。我们想要把这两步操作以<strong>级联</strong>的方式串接起来工作。</p><p>&emsp;&emsp;从shop对象获取价格，把价格转换为Quote，拿到返回的Quote对象，参数传递给Discount服务，取得最终折扣价格。thenCompose方法允许我们对两个异步操作进行流水线，第一个操作完成时将结果作为参数传递给第二个操作。这样即使Future在向不同的商店收集报价时，主线程还能继续执行其他重要操作。thenCompose也有Async命名结尾版本，会为后续任务新开一个线程。这里选择thenCompose的原因是更高效一些，减少了线程切换的开销。</p><p>&emsp;&emsp;最后一步收集后，我们可以得到List&lt;CompletableFuture<string>&gt;，等待CompletableFuture对象都执行完毕，利用join方法取得返回值。</string></p><h4 id="3-8-3-将两个CompletableFuture对象整合起来，无论它们是否存在依赖"><a href="#3-8-3-将两个CompletableFuture对象整合起来，无论它们是否存在依赖" class="headerlink" title="3.8.3 将两个CompletableFuture对象整合起来，无论它们是否存在依赖"></a><strong>3.8.3 将两个CompletableFuture对象整合起来，无论它们是否存在依赖</strong></h4><p>&emsp;&emsp;getPricesAsync方法中我们对CompletableFuture对象调用了thenCompose，并传递了第二个CompletableFuture，第二个需要第一个的执行结果作为输入。有的时候我们需要将两个完全不相干的CompletableFuture对象的结果整合起来，且不希望二者是顺序执行。</p><p>&emsp;&emsp;thenCombine方法接受参数CompletionStage和BiFunction，BiFunction定义了两个CompletableFuture完成计算后如何合并。Async版本会把合并操作提交到线程池，由另一个任务异步执行。</p><figure class="highlight aspectj"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> &lt;U,V&gt; CompletableFuture&lt;V&gt; thenCombine(</span><br><span class="line">    CompletionStage&lt;? <span class="keyword">extends</span> U&gt; other,</span><br><span class="line">    BiFunction&lt;? <span class="keyword">super</span> T,? <span class="keyword">super</span> U,? <span class="keyword">extends</span> V&gt; fn) &#123;</span><br><span class="line">    <span class="function"><span class="keyword">return</span> <span class="title">biApplyStage</span><span class="params">(<span class="keyword">null</span>, other, fn)</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> &lt;U,V&gt; CompletableFuture&lt;V&gt; thenCombineAsync(</span><br><span class="line">    CompletionStage&lt;? <span class="keyword">extends</span> U&gt; other,</span><br><span class="line">    BiFunction&lt;? <span class="keyword">super</span> T,? <span class="keyword">super</span> U,? <span class="keyword">extends</span> V&gt; fn, Executor executor) &#123;</span><br><span class="line">    <span class="keyword">return</span> biApplyStage(screenExecutor(executor), other, fn);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> &lt;U&gt; CompletableFuture&lt;Void&gt; thenAcceptBoth(</span><br><span class="line">    CompletionStage&lt;? <span class="keyword">extends</span> U&gt; other,</span><br><span class="line">    BiConsumer&lt;? <span class="keyword">super</span> T, ? <span class="keyword">super</span> U&gt; action) &#123;</span><br><span class="line">    <span class="function"><span class="keyword">return</span> <span class="title">biAcceptStage</span><span class="params">(<span class="keyword">null</span>, other, action)</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> &lt;U,V&gt; CompletableFuture&lt;V&gt; biApplyStage(</span><br><span class="line">    Executor e, CompletionStage&lt;U&gt; o,</span><br><span class="line">    BiFunction&lt;? <span class="keyword">super</span> T,? <span class="keyword">super</span> U,? <span class="keyword">extends</span> V&gt; f) &#123;</span><br><span class="line">    CompletableFuture&lt;U&gt; b;</span><br><span class="line">    <span class="keyword">if</span> (f == <span class="keyword">null</span> || (b = o.toCompletableFuture()) == <span class="keyword">null</span>)</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> NullPointerException();</span><br><span class="line">    CompletableFuture&lt;V&gt; d = <span class="keyword">new</span> CompletableFuture&lt;V&gt;();</span><br><span class="line">    <span class="keyword">if</span> (e != <span class="keyword">null</span> || !d.biApply(<span class="keyword">this</span>, b, f, <span class="keyword">null</span>)) &#123;</span><br><span class="line">        BiApply&lt;T,U,V&gt; c = <span class="keyword">new</span> BiApply&lt;T,U,V&gt;(e, d, <span class="keyword">this</span>, b, f);</span><br><span class="line">        bipush(b, c);</span><br><span class="line">        c.tryFire(SYNC);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> d;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>&emsp;&emsp;假设我们需要实现汇率转换的功能，以异步的方式来进行商店价格查询和远程的汇率查询，最后将二者结果进行合并，因为只是相乘合并，所以用Async版本新开线程有些浪费资源。</p><figure class="highlight coffeescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">public Future&lt;Double&gt; a(Shop shop,String product)&#123;</span><br><span class="line">    Future&lt;Double&gt; futurePriceUSD =</span><br><span class="line">            CompletableFuture.supplyAsync(</span><br><span class="line">                    () -&gt; shop.getPrice(product)</span><br><span class="line">            ).thenCombine(</span><br><span class="line">                    CompletableFuture.supplyAsync(</span><br><span class="line">                            () -&gt; ExchangeService.getRate(ExchangeService.Money.EUR, ExchangeService.Money.USD)</span><br><span class="line">                    ), <span class="function"><span class="params">(price, rate)</span> -&gt;</span> price * rate</span><br><span class="line">            );</span><br><span class="line">    <span class="keyword">return</span> futurePriceUSD;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="https://pic-1258215793.cos.ap-shanghai.myqcloud.com/content/20190901/201909010154.png" alt="合并两个相互独立的异步任务"></p><h4 id="3-8-4-回顾Future和CompletableFuture"><a href="#3-8-4-回顾Future和CompletableFuture" class="headerlink" title="3.8.4 回顾Future和CompletableFuture"></a><strong>3.8.4 回顾Future和CompletableFuture</strong></h4><p>&emsp;&emsp;我们通过实践可以感受到CompletableFuture相比Future的巨大优势，CompletableFuture可以利用Lambda表达式以声明式的API用最简单有效的方式吧多个同步或一部操作结合起来。</p><p>&emsp;&emsp;如果我们只用Future来实现上个汇率转换会如何？</p><figure class="highlight gradle"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> Future&lt;<span class="keyword">Double</span>&gt; converterFuture(Shop shop,String product)&#123;</span><br><span class="line">    <span class="comment">//创建ExecutorService将任务提交到线程池</span></span><br><span class="line">    ExecutorService executor = Executors.newCachedThreadPool();</span><br><span class="line">    <span class="comment">//创建一个查询汇率转换的Future</span></span><br><span class="line">    <span class="keyword">final</span> Future&lt;<span class="keyword">Double</span>&gt; futureRate = executor.submit(<span class="keyword">new</span> Callable&lt;<span class="keyword">Double</span>&gt;() &#123;</span><br><span class="line">        @Override</span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">Double</span> <span class="keyword">call</span>() <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">            <span class="keyword">return</span> ExchangeService.getRate(ExchangeService.Money.EUR, ExchangeService.Money.USD);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;);</span><br><span class="line">    Future&lt;<span class="keyword">Double</span>&gt; futurePriceUSD = executor.submit(<span class="keyword">new</span> Callable&lt;<span class="keyword">Double</span>&gt;() &#123;</span><br><span class="line">        @Override</span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">Double</span> <span class="keyword">call</span>() <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">            <span class="keyword">double</span> priceInEUR = shop.getPrice(product);</span><br><span class="line">            <span class="keyword">return</span> priceInEUR * futureRate.get();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;);</span><br><span class="line">    <span class="keyword">return</span> futurePriceUSD;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>&emsp;&emsp;对比两种实现，就可以对CompletableFuture的优势有直观感受。</p><h3 id="3-9-响应CompletableFuture的completion事件"><a href="#3-9-响应CompletableFuture的completion事件" class="headerlink" title="3.9 响应CompletableFuture的completion事件"></a><strong>3.9 响应CompletableFuture的completion事件</strong></h3><p>&emsp;&emsp;我们模拟远程服务调用都是通过1s的等待，但实际网络环境中延迟区别很大，可能因为服务器负荷、网络延迟等等。我们目前对价格的查询需要取得所有商店返回值才能显示，但实际上我们可能想要每个商店只要返回价格就第一时间显示返回值。</p><figure class="highlight arduino"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> final Random <span class="built_in">random</span> = <span class="keyword">new</span> Random();</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 模拟耗时操作，0.5s - 2.5s随机延迟</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> randomDelay()&#123;</span><br><span class="line">    <span class="keyword">int</span> <span class="built_in">delay</span> = <span class="number">500</span> + <span class="built_in">random</span>.nextInt(<span class="number">2000</span>);</span><br><span class="line">    <span class="built_in">try</span>&#123;</span><br><span class="line">        Thread.sleep(<span class="built_in">delay</span>);</span><br><span class="line">    &#125;<span class="built_in">catch</span> (InterruptedException ex)&#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>&emsp;&emsp;所以首先我们不能用List来存放所有价格查询结果，应该直接处理CompletableFuture流，每个CompletableFuture对象都在为某个商店执行。</p><figure class="highlight livescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 重构findPrices方法返回一个Future构成的流</span></span><br><span class="line"><span class="comment"> * @param product</span></span><br><span class="line"><span class="comment"> * @return</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">public Stream&lt;CompletableFuture&lt;String&gt;&gt; findPricesStream(String product)&#123;</span><br><span class="line">    <span class="keyword">return</span> shops.stream()</span><br><span class="line">            .map(shop<span class="function"> -&gt;</span> CompletableFuture.supplyAsync(</span><br><span class="line">                    <span class="function"><span class="params">()</span> -&gt;</span> shop.getPrice(product),executor))</span><br><span class="line">            .map(future<span class="function"> -&gt;</span> future.thenApply(Quote::parse))</span><br><span class="line">            .map(future<span class="function"> -&gt;</span> future.thenCompose(</span><br><span class="line">                    quote<span class="function"> -&gt;</span> CompletableFuture.supplyAsync(</span><br><span class="line">                            <span class="function"><span class="params">()</span> -&gt;</span> Discount.applyDiscount(quote),executor</span><br><span class="line">                    )));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>&emsp;&emsp;接下来我们要为CompletableFuture注册一个操作，此操作需要在CompletableFuture完成执行后使用其返回值。thenAccept方法接收CompletableFuture执行完毕后的返回值做参数。</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-tag">findPricesStream</span>("<span class="selector-tag">myPhone27S</span>")<span class="selector-class">.map</span>(<span class="selector-tag">f</span> <span class="selector-tag">-</span>&gt; <span class="selector-tag">f</span><span class="selector-class">.thenAccept</span>(<span class="selector-tag">System</span><span class="selector-class">.out</span><span class="selector-pseudo">::println))</span>;</span><br></pre></td></tr></table></figure><p>&emsp;&emsp;当CompletableFuture计算结束，返回一个CompletableFuture<void>，所以map方法返回Stream&lt;CompletableFuture<void>&gt;，最终的返回我们能做的事情很有限，只能等待其运行结束。可能我们还希望让最慢的商店也可以打印价格，可以把Stream的所有CompletableFuture<void>放到一个数组中，等待所有的任务执行完成。</void></void></void></p><figure class="highlight processing"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">CompletableFuture[] futures = </span><br><span class="line">        findPricesStream(<span class="string">"myPhone27S"</span>)</span><br><span class="line">                .<span class="built_in">map</span>(f -&gt; f.thenAccept(System.out::<span class="built_in">println</span>))</span><br><span class="line">                .toArray(<span class="built_in">size</span> -&gt; <span class="keyword">new</span> CompletableFuture[<span class="built_in">size</span>]);</span><br><span class="line"><span class="comment">//allOf方法接收一个由CompletableFuture构成的数组，数组对象执行完毕后，返回一个CompletableFuture&lt;Void&gt;对象</span></span><br><span class="line">CompletableFuture.allOf(futures).<span class="built_in">join</span>();</span><br></pre></td></tr></table></figure><p>&emsp;&emsp;如果希望在有任何一个执行完就不再等待，比如查询多个汇率服务器，只要得到一个就满足需求，可以使用工厂方法anyOf，接收一个由CompletableFuture构成的数组，数组对象执行完毕后，返回一个CompletableFuture<object>对象。</object></p><hr><p><em>参考博客和文章书籍等：</em></p><blockquote><p>《Java8实战》</p></blockquote><p><em>因博客主等未标明不可引用，若部分内容涉及侵权请及时告知，我会尽快修改和删除相关内容</em></p>]]></content>
    
    <summary type="html">
    
      介绍Java 8引入的CompletableFuture组合式异步编程，主要内容包括：引文，Future接口（Future简介、Future接口的局限性），实现异步API（使用CompletableFuture构建异步应用、同步API、将同步方法转换为异步方法、错误处理、通过工厂方法supplyAsync优化CompletableFuture、避免阻塞、定制执行器、对多个异步任务进行流水线操作、响应CompletableFuture的completion事件）等。
    
    </summary>
    
      <category term="技术文档" scheme="http://linyishui.top/categories/%E6%8A%80%E6%9C%AF%E6%96%87%E6%A1%A3/"/>
    
    
      <category term="java" scheme="http://linyishui.top/tags/java/"/>
    
  </entry>
  
  <entry>
    <title>Optional</title>
    <link href="http://linyishui.top/2019092701.html"/>
    <id>http://linyishui.top/2019092701.html</id>
    <published>2019-09-27T03:12:22.000Z</published>
    <updated>2019-12-05T06:44:56.402Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="Optional"><a href="#Optional" class="headerlink" title="Optional"></a><strong>Optional</strong></h1><h2 id="第一节-引文"><a href="#第一节-引文" class="headerlink" title="第一节 引文"></a><strong>第一节 引文</strong></h2><p>&emsp;&emsp;对于Java编程来说，NullPointerException——空指针异常可以说是最经常遇到的异常了，这是引入null引用的代价，最初只是因为对“不存在的值”进行建模时这样实现起来非常容易，但后果就是使程序员需要对对象的字段进行检查，判断它的值是否为所期望，但结果却指向了一个空指针，并立即抛出了NullPointerException。如Java这些语言采用空引用的设计最初只是为了和老的语言保持兼容，但为此却付出了很多的代价。</p><p>&emsp;&emsp;函数式语言会通过更多的描述性数据类型来避免null，Java 8提供了Optional<t>类，使用它可以有效的避免NullPointerException。</t></p><p><img src="https://pic-1258215793.cos.ap-shanghai.myqcloud.com/content/20190901/201909010145.png" alt="使用Optional定义的Car类"></p><p>&emsp;&emsp;Optional<t>类是一个容器类，可以包含也可以不包含值，代表一个值存在或不存在，其方法可以明确地处理值不存在的情况。</t></p><blockquote><ul><li>isPresent() 在值存在时返回true，否则返回false。</li><li>isPresent(Consumer<t> block) 在值存在时执行给定代码块。</t></li><li>T get() 在值存在时返回值，否则抛出异常NoSuchElement。</li><li>T orElse() 在值存在时返回值，否则返回一个默认值。</li></ul></blockquote><hr><h2 id="第二节-如何为缺失的值建模"><a href="#第二节-如何为缺失的值建模" class="headerlink" title="第二节 如何为缺失的值建模"></a><strong>第二节 如何为缺失的值建模</strong></h2><h3 id="Java中的null"><a href="#Java中的null" class="headerlink" title="Java中的null"></a><strong>Java中的null</strong></h3><p>&emsp;&emsp;如下述代码便会抛出NullPointerException，导致程序的终止。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Person</span> &#123;</span></span><br><span class="line">    <span class="keyword">private</span> Car car;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Car <span class="title">getCar</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> car;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Car</span> &#123;</span></span><br><span class="line">    <span class="keyword">private</span> Insurance insurance;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Insurance <span class="title">getInsurance</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> insurance;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Insurance</span> &#123;</span></span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getName</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> name;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test</span> &#123;</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        getCarInsuranceName(<span class="keyword">new</span> Person());<span class="comment">//Exception in thread "main" java.lang.NullPointerException</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> String <span class="title">getCarInsuranceName</span><span class="params">(Person person)</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> person.getCar().getInsurance().getName();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>&emsp;&emsp;为了避免空指针异常，通常我们要在需要的地方添加null的检查，如下述情况，是一种深层质疑的防御式检查。但很明显这种方式不具有扩展性，也牺牲了代码的可读性。</p><figure class="highlight aspectj"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="function">String <span class="title">getCarInsuranceName</span><span class="params">(Person person)</span></span>&#123;<span class="comment">//防御式检查减少NullPointerException</span></span><br><span class="line">    <span class="keyword">if</span>(person != <span class="keyword">null</span>)&#123;</span><br><span class="line">        Car car = person.getCar();</span><br><span class="line">        <span class="keyword">if</span>(car != <span class="keyword">null</span>)&#123;</span><br><span class="line">            Insurance insurance = car.getInsurance();</span><br><span class="line">            <span class="keyword">if</span>(insurance != <span class="keyword">null</span>)&#123;</span><br><span class="line">                <span class="function"><span class="keyword">return</span> insurance.<span class="title">getName</span><span class="params">()</span></span>;<span class="comment">//业务上设定公司必然有名字，所以可以避免了这一层检查，但不会直接反映在建模中</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="string">"Unknown"</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>&emsp;&emsp;我们可以换一种尝试，避免深层递归的if语句块，而是每次遭遇null就返回字符串常量”Unknown”。这种方式使代码极难维护，且容易出现错误。</p><blockquote><p>null导致的问题？</p><ul><li><strong>错误之源</strong>：导致的NullPointerException是Java开发中最典型的异常。</li><li><strong>代码膨胀</strong>：使代码充斥着深度嵌套的null检查，代码的可读性糟糕透顶。</li><li><strong>毫无意义</strong>：null本身没有任何语义，它代表的是在静态类型语言中以一种错误的方式对缺失变量值得建模。</li><li><strong>破坏哲学</strong>：Java一直试图让程序员忽略指针的存在，但null指针是例外。</li><li><strong>留下漏洞</strong>：null不属于任何类型，可以被赋值给任意引用类型的变量，导致当这个变量被传递给系统的另一个部分后，无从获知这个null变量最初的赋值是何类型。</li></ul></blockquote><h3 id="其他语言中null的替代品"><a href="#其他语言中null的替代品" class="headerlink" title="其他语言中null的替代品"></a><strong>其他语言中null的替代品</strong></h3><p>&emsp;&emsp;稍微新一些的语言如Groovy，通过引入<strong>安全导航操作符</strong>（Safe Navigation Operator，?）可以安全的访问可能为null的变量。如下述代码，person对象可能没有car对象，但安全导航操作符可以避免抛出空指针异常，而是在遭遇null时将null引用沿着调用链传递下去，返回一个null。</p><figure class="highlight flix"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">carInsuranceName</span> </span>= person?.car?.insurance?.name</span><br></pre></td></tr></table></figure><p>&emsp;&emsp;我们遇到空指针异常时会自然的用if判断来规避异常，但这只是暂时的掩盖了问题，且使得以后的调查和修复变得更加困难。而安全导航操作符也只是一个更强大的扫把，让我们毫无顾虑的犯错。</p><p>&emsp;&emsp;另外一些语言如Haskell、Scala试图从另外一个角度来处理这个问题。Haskell中包含了一个Maybe类型，本质上是对optional值得封装。Maybe类型的变量可以是指定类型的值，也可以什么都不是，但没有null引用的概念。Scala类似的结构是Option[T]，必须显式的调用Option类型的available操作，检查该变量是否有值，但其实也是一种变相的“null检查”。</p><p>&emsp;&emsp;Java 8则从这些中吸取了灵感，引入了Optional<t>的新类。</t></p><hr><h2 id="第三节-Optional类"><a href="#第三节-Optional类" class="headerlink" title="第三节 Optional类"></a><strong>第三节 Optional类</strong></h2><p>&emsp;&emsp;当变量存在时，Optional只是对类简单封装。变量不存在时，缺失的值会被建模成一个空的Optional对象，由Optional.empty()返回。</p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">Optional</span>&lt;<span class="title">T</span>&gt; </span>&#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Common instance for &#123;<span class="doctag">@code</span> empty()&#125;.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> Optional<span class="meta">&lt;?</span>&gt; <span class="keyword">EMPTY</span> = <span class="keyword">new</span> Optional&lt;&gt;();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> Optional() &#123;</span><br><span class="line">        this.value = <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span>&lt;T&gt; Optional&lt;T&gt; <span class="keyword">empty</span>() &#123;</span><br><span class="line">        @SuppressWarnings(<span class="string">"unchecked"</span>)</span><br><span class="line">        Optional&lt;T&gt; t = (Optional&lt;T&gt;) <span class="keyword">EMPTY</span>;</span><br><span class="line">        <span class="keyword">return</span> t;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>&emsp;&emsp;null引用和Optional.empty()有什么区别呢？如果尝试引用一个null则会导致空指针异常，但后者则可以，它是Optional类的一个有效对象，多种场景都可以调用。使用Optional就可以不用再通过理解业务模型来决定null是否属于一个变量的有效范畴。</p><figure class="highlight cs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">Person</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> Optional&lt;Car&gt; car;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Optional&lt;Car&gt; <span class="title">getCar</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> car;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">Car</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> Optional&lt;Insurance&gt; insurance;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Optional&lt;Insurance&gt; <span class="title">getInsurance</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> insurance;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">Insurance</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> String name;<span class="comment">//保险公司必须有名字</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getName</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> name;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>&emsp;&emsp;所以我们只要声明为Optional，表示此变量是允许缺失的，而未声明的也无需再用if判断来规避空指针异常，这样只会掩盖错误。始终如一的采用Optional可以非常清晰的界定出变量值的缺失是结构上的问题，还是算法上的缺陷，又或是数据中的问题。引入Optional并非是要消除null引用，而是帮助我们更好的设计出普适的API。</p><hr><h2 id="第四节-Optional应用"><a href="#第四节-Optional应用" class="headerlink" title="第四节 Optional应用"></a><strong>第四节 Optional应用</strong></h2><h3 id="创建Optional对象"><a href="#创建Optional对象" class="headerlink" title="创建Optional对象"></a><strong>创建Optional对象</strong></h3><p>&emsp;&emsp;声明</p><figure class="highlight fortran"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">//声明一个空的<span class="keyword">Optional</span>对象</span><br><span class="line"><span class="keyword">Optional</span>&lt;Car&gt; optCar1 = <span class="keyword">Optional</span>.empty();</span><br><span class="line"></span><br><span class="line">//通过一个非空的值来创建<span class="keyword">Optional</span>对象</span><br><span class="line"><span class="keyword">Optional</span>&lt;Car&gt; optCar2 = <span class="keyword">Optional</span>.of(new Car());</span><br><span class="line"></span><br><span class="line">//创建一个允许null值的<span class="keyword">Optional</span>对象</span><br><span class="line"><span class="keyword">Optional</span>&lt;Car&gt; optCar3 = <span class="keyword">Optional</span>.ofNullable(null);</span><br></pre></td></tr></table></figure><h3 id="使用map从Optional对象中提取和转换值"><a href="#使用map从Optional对象中提取和转换值" class="headerlink" title="使用map从Optional对象中提取和转换值"></a><strong>使用map从Optional对象中提取和转换值</strong></h3><p>&emsp;&emsp;Optional的map方法类似于流的map方法，将所提供的函数操作应用于流的每个元素，这里可以把Optional看作特殊的集合，至多只有一个元素，如果包含值就把值作为参数传递给map，然后对值进行转换；如果值为空，就什么也不做。</p><figure class="highlight gauss"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//传统方法</span></span><br><span class="line"><span class="keyword">String</span> name = <span class="built_in">null</span>;</span><br><span class="line"><span class="keyword">if</span>(insurance != <span class="built_in">null</span>)&#123;</span><br><span class="line">    name = insurance.<span class="built_in">getName</span>();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//Optional</span></span><br><span class="line">Optional&lt;Insurance&gt; optInsurance = Optional.ofNullable(insurance);</span><br><span class="line">Optional&lt;<span class="keyword">String</span>&gt; name = optInsurance.map(Insurance::<span class="built_in">getName</span>);</span><br></pre></td></tr></table></figure><p><img src="https://pic-1258215793.cos.ap-shanghai.myqcloud.com/content/20190901/201909010146.png" alt="Stream和Optional的map方法对比"></p><h3 id="使用flatMap链接Optional对象"><a href="#使用flatMap链接Optional对象" class="headerlink" title="使用flatMap链接Optional对象"></a><strong>使用flatMap链接Optional对象</strong></h3><p>&emsp;&emsp;如果我们想用Optional重构getCarInsuranceName方法，第一反应自然是用map方法重写，但改写后却无法通过编译。原因就是map方法返回的是Optional<t>类型的值，而getCar返回值是Optional<car>对应T，所以第一次map返回Optional&lt;Optional<car>&gt;，对其调用getInsurance自然是非法的。</car></car></t></p><figure class="highlight lasso"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//传统方法——未深度质疑</span></span><br><span class="line"><span class="keyword">public</span> static <span class="built_in">String</span> getCarInsuranceName(Person person)&#123;</span><br><span class="line">    <span class="keyword">return</span> person.getCar().getInsurance().getName();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//map重写</span></span><br><span class="line"><span class="keyword">public</span> static <span class="built_in">String</span> getCarInsuranceName(Person person)&#123;</span><br><span class="line">    Optional&lt;Person&gt; optPerson = Optional.of(person);</span><br><span class="line">    Optional&lt;<span class="built_in">String</span>&gt; name = optPerson.<span class="built_in">map</span>(Person<span class="type">::getCar</span>)</span><br><span class="line">                                     .<span class="built_in">map</span>(Car<span class="type">::getInsurance</span>)</span><br><span class="line">                                     .<span class="built_in">map</span>(Insurance<span class="type">::getName</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>&emsp;&emsp;这个时候我们应该回忆起流的flatMap方法，接受一个函数参数，函数的返回值是另一个流，将函数作用在流的每个元素上，最终获得一个新的流的流。由方法生成的流会扁平化为一个流，我们现在想要的就是把两层Optional合并为一个。</p><p><img src="https://pic-1258215793.cos.ap-shanghai.myqcloud.com/content/20190901/201909010147.png" alt="Stream和Optional的flatMap方法对比"></p><figure class="highlight lasso"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//flatMap重写</span></span><br><span class="line"><span class="keyword">public</span> static <span class="built_in">String</span> getCarInsuranceName(Person person)&#123;</span><br><span class="line">    Optional&lt;Person&gt; optPerson = Optional.of(person);</span><br><span class="line">    <span class="keyword">return</span> optPerson.flatMap(Person<span class="type">::getCar</span>)</span><br><span class="line">                    .flatMap(Car<span class="type">::getInsurance</span>)</span><br><span class="line">                    .<span class="built_in">map</span>(Insurance<span class="type">::getName</span>)</span><br><span class="line">                    .orElse(<span class="string">"Unknown"</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>&emsp;&emsp;optPerson是Optional封装的Person，调用flatMap(Person::getCar)后，第一步，某个Function作为参数被传递给optPerson，对其进行转换。所以Function是调用getCar方法，返回一个Optional<car>类型的对象，Optional<person>也会转换为Optional&lt;Optional<car>&gt;，最终被flatMap操作合并。orElse方法在Optional值为空时返回一个默认值。</car></person></car></p><p><img src="https://pic-1258215793.cos.ap-shanghai.myqcloud.com/content/20190901/201909010148.png" alt="使用Optional解引用串接的Person/Car/Insurance"></p><blockquote><p>Optional无法序列化，因为设计者当时未考虑将其作为类的字段使用，仅仅是为了支持能返回Optional对象的语法，所以如果需要序列化时，类字段请不要包装Optional，提供一个能访问声明为Optional、变量值可能缺失的接口即可。</p></blockquote><h3 id="默认行为及解引用Optional对象"><a href="#默认行为及解引用Optional对象" class="headerlink" title="默认行为及解引用Optional对象"></a><strong>默认行为及解引用Optional对象</strong></h3><p>&emsp;&emsp;Optional类提供了多种方法读取Optional实例中的变量值。</p><blockquote><ul><li>get()：变量存在，直接返回封装的变量值，否则抛出NoSuchElementException异常，相比null引用并未有多大改进。</li><li>orElse(T other)：允许在Optional对象不包含值时提供一个默认值。</li><li>orElseThrow(Supplier&lt;? extends X&gt; exceptionSupplier)：是orElse方法的延迟调用版，Supplier方法在Optional对象不包含值时执行调用。当创建默认值是一件耗时费力的工作时应该采用此方法（借此提高性能），或者需要某方法只有在Optional为空时才能调用。</li><li>ifPresent(Consumer&lt;? super T&gt;)：在变量值存在时执行一个作为参数传入的方法，否则不做任何操作</li></ul></blockquote><h3 id="两个Optional对象的组合"><a href="#两个Optional对象的组合" class="headerlink" title="两个Optional对象的组合"></a><strong>两个Optional对象的组合</strong></h3><p>&emsp;&emsp;findCheapestInsurance方法接受两个参数Person和Car，通过一系列复杂的业务逻辑，找出满足该组合的最便宜的保险公司。如果我们想要实现一个null安全的版本，可能会如nullSafeFindCheapestInsurance这样实现。从参数我们就可以得知person和car都可能为空，这种时候方法的返回值不会包含任何值。但这种实现和findCheapestInsurance并没有太多本质上的区别。</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> Insurance findCheapestInsurance(Person person, Car car)&#123;</span><br><span class="line">    Insurance cheapestCompany = <span class="literal">null</span>;</span><br><span class="line">    <span class="comment">//不同的保险公司提供的查询服务</span></span><br><span class="line">    <span class="comment">//对比所有数据</span></span><br><span class="line">    <span class="keyword">return</span> cheapestCompany;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> Optional&lt;Insurance&gt; nullSafeFindCheapestInsurance(Optional&lt;Person&gt; person, Optional&lt;Car&gt; car)&#123;</span><br><span class="line">    <span class="keyword">if</span>(person.isPresent() &amp;&amp; car.isPresent())&#123;</span><br><span class="line">        <span class="keyword">return</span> Optional.of(findCheapestInsurance(person.<span class="keyword">get</span>(),car.<span class="keyword">get</span>()))</span><br><span class="line">    &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> Optional.empty();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>&emsp;&emsp;可以通过如三元操作符那样无需任何条件判断的结构，用一行语句来实现方法，代码如下。首先对person调用flatMap，如果是空值则传递的Lambda表达式不会执行，所以此次调用会直接返回一个空的Optional对象。如果不是空值，则此次调用会传递Lambda表达式，执行转换，并最终返回一个Optional<insurance>对象。函数体中对第二个Optional对象car执行了map操作，若car为空值则返回一个空的Optional对象，所以整个nullSafeFindCheapestInsurance的最终返回值也是一个空的Optional对象。如果两个参数变量值都存在，那么作为参数传递给map方法的Lambda表达式能够使用这两个值安全的调用findCheapestInsurance。</insurance></p><figure class="highlight fortran"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">Optional</span>&lt;Insurance&gt; nullSafeFindCheapestInsurance(<span class="keyword">Optional</span>&lt;Person&gt; person, <span class="keyword">Optional</span>&lt;Car&gt; car)&#123;</span><br><span class="line">    <span class="keyword">return</span> person.flatMap(p -&gt; car.map(c -&gt; findCheapestInsurance(p,c)));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="使用filter剔除特定的值"><a href="#使用filter剔除特定的值" class="headerlink" title="使用filter剔除特定的值"></a><strong>使用filter剔除特定的值</strong></h3><p>&emsp;&emsp;在对引用对象的一些属性进行操作时，每次都要事先对null引用进行判断。如下代码中判断保险公司名称，这种情况可以通过filter方法来改写。</p><figure class="highlight cs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//检查保险公司名称是否为XX，首先要判断引用是否为null</span></span><br><span class="line"><span class="keyword">if</span>(insurance != <span class="literal">null</span> &amp;&amp; <span class="string">"CambridgeInsurance"</span>.<span class="keyword">equals</span>(insurance.getName()))&#123;</span><br><span class="line">    System.<span class="keyword">out</span>.println(<span class="string">"OK"</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//filter方法改写</span></span><br><span class="line">Optional&lt;Insurance&gt; optInsurance = Optional.ofNullable(insurance);</span><br><span class="line">optInsurance.filter(insurance1 -&gt; <span class="string">"CambridgeInsurance"</span>.<span class="keyword">equals</span>(insurance.getName())).ifPresent(x -&gt; System.<span class="keyword">out</span>.println(<span class="string">"OK"</span>));</span><br></pre></td></tr></table></figure><p>&emsp;&emsp;filter方法接受一个谓词作为参数，如果Optional对象值存在，且符合谓词的条件，filter方法会返回其值。否则返回一个空的Optional对象。</p><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a><strong>总结</strong></h3><table><thead><tr><th style="text-align:left">方法</th><th style="text-align:left">概述</th></tr></thead><tbody><tr><td style="text-align:left">empty</td><td style="text-align:left">返回一个空的Optional实例</td></tr><tr><td style="text-align:left">filter</td><td style="text-align:left">如果值存在且满足提供的谓词，就返回包含该值的Optional对象；否则返回一个空的Optional对象</td></tr><tr><td style="text-align:left">flatMap</td><td style="text-align:left">如果值存在，就对该值执行提供的mapping函数调用，返回一个Optional类型的值，否则返回一个空的Optional对象</td></tr><tr><td style="text-align:left">get</td><td style="text-align:left">如果值存在，就将被Optional封装的值返回，否则抛出一个NoSuchElementException异常</td></tr><tr><td style="text-align:left">ifPresent</td><td style="text-align:left">如果值存在，就执行使用该值的方法调用，否则什么也不做</td></tr><tr><td style="text-align:left">isPresent</td><td style="text-align:left">如果值存在，就返回true，否则返回false</td></tr><tr><td style="text-align:left">map</td><td style="text-align:left">如果值存在，就对该值执行提供的mapping函数调用</td></tr><tr><td style="text-align:left">of</td><td style="text-align:left">将指定值用Optional封装之后返回，如果该值为null，则抛出一个NoSuchElementException异常</td></tr><tr><td style="text-align:left">ofNullable</td><td style="text-align:left">将指定值用Optional封装之后返回，如果该值为null，则返回一个空的Optional对象</td></tr><tr><td style="text-align:left">orElse</td><td style="text-align:left">如果有值则将其返回，否则返回一个默认值</td></tr><tr><td style="text-align:left">orElseGet</td><td style="text-align:left">如果有值则将其返回，否则返回一个由指定的Supplier接口生成的值</td></tr><tr><td style="text-align:left">orElseThrow</td><td style="text-align:left">如果有值则将其返回，否则抛出一个由指定的Supplier接口生成的异常</td></tr></tbody></table><hr><h2 id="第五节-Optional实战"><a href="#第五节-Optional实战" class="headerlink" title="第五节 Optional实战"></a><strong>第五节 Optional实战</strong></h2><p>&emsp;&emsp;有效的使用Optional意味着我们需要直面潜在缺失值的处理，为了保持后向兼容性，很难对老版本的Java API进行改动，使其也使用Optional，但可以通过一些工具方法来修复或绕过这些问题。</p><h3 id="用Optional封装可能为null的值"><a href="#用Optional封装可能为null的值" class="headerlink" title="用Optional封装可能为null的值"></a><strong>用Optional封装可能为null的值</strong></h3><p>&emsp;&emsp;Java API几乎都会以返回一个null来表示需要值的缺失，所以可以通过Optional封装返回值的方式进行优化。</p><figure class="highlight processing"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Map&lt;<span class="keyword">String</span>,<span class="keyword">Object</span>&gt; <span class="built_in">map</span> = <span class="keyword">new</span> <span class="keyword">HashMap</span>&lt;&gt;();</span><br><span class="line"><span class="comment">//当映射不包含键对应的值会返回null</span></span><br><span class="line"><span class="keyword">Object</span> value = <span class="built_in">map</span>.<span class="built_in">get</span>(<span class="string">"key"</span>);</span><br><span class="line"><span class="comment">//Optional改写</span></span><br><span class="line">Optional&lt;<span class="keyword">Object</span>&gt; optValue = Optional.ofNullable(<span class="built_in">map</span>.<span class="built_in">get</span>(<span class="string">"key"</span>));</span><br></pre></td></tr></table></figure><h3 id="异常与Optional的对比"><a href="#异常与Optional的对比" class="headerlink" title="异常与Optional的对比"></a><strong>异常与Optional的对比</strong></h3><p>&emsp;&emsp;Java API中，因为一些原因函数无法返回某个值，这种情况除了返回null，比较常见的替代做法是抛出一个异常。比如Integer.parseInt(String)，如果String无法解析到对应的整形，就会抛出一个NumberFormatException异常。所以我们就需要用try/catch语句来处理异常情况。</p><figure class="highlight arduino"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> Optional&lt;Integer&gt; stringToInt(<span class="keyword">String</span> s)&#123;</span><br><span class="line">    <span class="built_in">try</span> &#123;</span><br><span class="line">        <span class="built_in">return</span> Optional.of(Integer.<span class="built_in">parseInt</span>(s));</span><br><span class="line">    &#125;<span class="built_in">catch</span> (NumberFormatException ex)&#123;</span><br><span class="line">        <span class="built_in">return</span> Optional.empty();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>&emsp;&emsp;我们可以通过上述代码进行改写，通过空的Optional对象来对无法返回的值进行建模。虽然无法修改最初的Java方法，但无碍我们进行这些改进。建议把类似需要改进的方法封装到一个工具类中，称作OptionalUtily。直接调用OptionalUtily.stringToInt方法就将String转换为Optional<integer>对象。</integer></p><h3 id="基础类型的Optional"><a href="#基础类型的Optional" class="headerlink" title="基础类型的Optional"></a><strong>基础类型的Optional</strong></h3><p>&emsp;&emsp;Optional和流一样也提供了基础类版本——OptionalInt、OptionalDouble、OptionalLong，对于流来说基础类版本在适合的场景可以有效的提高性能，但对于Optional因为对象最多只包含一个值，所以并不会有性能上的差异。基础类型Optional不支持map、flatMap和filter方法这些最有用的方法。基础类型的Optional也不能组合构成新的Optional。</p><hr><p><em>参考博客和文章书籍等：</em></p><blockquote><p>《Java8实战》</p></blockquote><p><em>因博客主等未标明不可引用，若部分内容涉及侵权请及时告知，我会尽快修改和删除相关内容</em></p>]]></content>
    
    <summary type="html">
    
      介绍Java 8中加入的Optional，内容包括：引文，如何为缺失的值建模（Java中的null、其他语言中null的替代品），Optional类，Optional应用（创建Optional对象、使用map从Optional对象中提取和转换值、使用flatMap链接Optional对象、默认行为及解引用Optional对象、两个Optional对象的组合、使用filter剔除特定的值、总结），Optional实战（用Optional封装可能为null的值、异常与Optional的对比、基础类型的Optional）等。
    
    </summary>
    
      <category term="技术文档" scheme="http://linyishui.top/categories/%E6%8A%80%E6%9C%AF%E6%96%87%E6%A1%A3/"/>
    
    
      <category term="java" scheme="http://linyishui.top/tags/java/"/>
    
      <category term="optional" scheme="http://linyishui.top/tags/optional/"/>
    
  </entry>
  
  <entry>
    <title>重构、测试和调试</title>
    <link href="http://linyishui.top/2019092601.html"/>
    <id>http://linyishui.top/2019092601.html</id>
    <published>2019-09-26T10:12:04.000Z</published>
    <updated>2019-12-05T06:31:59.836Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="Java8的新特性"><a href="#Java8的新特性" class="headerlink" title="Java8的新特性"></a><strong>Java8的新特性</strong></h1><h2 id="第一节-为改善可读性和灵活性重构代码"><a href="#第一节-为改善可读性和灵活性重构代码" class="headerlink" title="第一节 为改善可读性和灵活性重构代码"></a><strong>第一节 为改善可读性和灵活性重构代码</strong></h2><p>&emsp;&emsp;学会了Lambda和流后我们可以在新项目中使用这些新特性，而一些老项目我们可能也想要用新的方式来重构代码，提高代码的可读性和灵活性。</p><p>&emsp;&emsp;用Lambda表达式可以相比匿名类更简洁，代码会更灵活，在需求有变更时，行为参数化的模式可以更有效的来应对。</p><blockquote><p>为何说Java 8的新特性可以提高可读性？</p><ul><li>减少冗长的代码，代码更容易理解。</li><li>通过方法引用和Stream API，代码会更直观。</li></ul></blockquote><blockquote><p>如何通过Java 8的新特性提高可读性？</p><ul><li>重构代码，用Lambda表达式取代匿名类</li><li>用方法引用重构Lambda表达式</li><li>用Stream API重构命令式的数据处理</li></ul></blockquote><h3 id="1-1-匿名类到Lambda表达式"><a href="#1-1-匿名类到Lambda表达式" class="headerlink" title="1.1 匿名类到Lambda表达式"></a><strong>1.1 匿名类到Lambda表达式</strong></h3><p>&emsp;&emsp;用Lambda表达式代替匿名类时要注意二者的不同，如this和super在二者有不同的含义，对于匿名类this是类自身，而Lambda则表示包含类。匿名类可以屏蔽包含类变量，Lambda表达式则不行。对于重载的场景，Lambda表达式可能会有些歧义，多个函数可能都合法，可以通过显式的类型转换来解决此问题。</p><h3 id="1-2-Lambda表达式到方法引用"><a href="#1-2-Lambda表达式到方法引用" class="headerlink" title="1.2 Lambda表达式到方法引用"></a><strong>1.2 Lambda表达式到方法引用</strong></h3><p>&emsp;&emsp;方法名可以更直接的表达代码的意图，请尽量使用静态辅助方法。</p><h3 id="1-3-命令式数据处理到Stream"><a href="#1-3-命令式数据处理到Stream" class="headerlink" title="1.3 命令式数据处理到Stream"></a><strong>1.3 命令式数据处理到Stream</strong></h3><p>&emsp;&emsp;所有使用迭代器这种处理模式来处理集合的代码都应该转换为Stream API的方式，流更能清楚的表达数据处理管道的意图，通过短路和延迟载入以及多核架构可以进行优化处理。</p><p>&emsp;&emsp;将命令式数据处理转换到Stream不是一件容易的事情，需要考虑控制流语句，选择恰当的流操作，不过已有一些工具可以辅助进行这一步转换。</p><h3 id="1-4-增加代码灵活性"><a href="#1-4-增加代码灵活性" class="headerlink" title="1.4 增加代码灵活性"></a><strong>1.4 增加代码灵活性</strong></h3><h4 id="1-4-1-采用函数式接口"><a href="#1-4-1-采用函数式接口" class="headerlink" title="1.4.1 采用函数式接口"></a><strong>1.4.1 采用函数式接口</strong></h4><p>&emsp;&emsp;Lambda表达式的使用依赖于函数式接口，我们可以基于两种模式来重构代码：<strong>有条件的延迟执行</strong>和<strong>环绕执行</strong>。</p><h4 id="1-4-2-有条件的延迟执行"><a href="#1-4-2-有条件的延迟执行" class="headerlink" title="1.4.2 有条件的延迟执行"></a><strong>1.4.2 有条件的延迟执行</strong></h4><p>&emsp;&emsp;控制语句经常会被混杂在业务逻辑代码之中，典型的场景就是安全性检查以及日志输出，如下述代码所示。</p><figure class="highlight less"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-tag">if</span>(logger.isLoggable(Level.FINER))&#123;</span><br><span class="line">    <span class="selector-tag">logger</span><span class="selector-class">.finer</span>(<span class="string">"Problem: "</span> + generateDiagnostic());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>&emsp;&emsp;在上述代码中日志器的状态被isLoggable暴露给了客户端代码，在每次输出日志前都要查询日志器对象的状态，可以尝试下列改造。</p><figure class="highlight 1c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">logger.<span class="built_in">log</span>(Level.FINER, <span class="string">"Problem: "</span> + generateDiagnostic());</span><br></pre></td></tr></table></figure><p>&emsp;&emsp;这样隐藏了日志器状态，也少去了条件判断，log方法会在内部检查日志对象是否已被设置为恰当的日志等级。但日志消息的输出与否每次仍需要进行判断，即使你已经传递了参数，不开启日志。</p><figure class="highlight livescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">logger.log<span class="function"><span class="params">(Level.FINER, () -&gt; <span class="string">"Problem: "</span> + generateDiagnostic())</span>;</span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function"><span class="title">public</span> <span class="title">void</span> <span class="title">log</span><span class="params">(Level level, Supplier&lt;String&gt; msgSupplier)</span> &#123;</span></span><br><span class="line"><span class="function">    <span class="title">if</span> <span class="params">(logger.isLoggable(level))</span> &#123;</span></span><br><span class="line"><span class="function">        <span class="title">log</span><span class="params">(level, msgSupplier.get())</span>;</span></span><br><span class="line"><span class="function">    &#125;</span></span><br><span class="line"><span class="function">&#125;</span></span><br></pre></td></tr></table></figure><p>&emsp;&emsp;Java 8提供了log方法的重载版，提供了Supplier参数，主要思路就是<strong>延迟消息构造</strong>：如果你需要频繁的从客户端去查询一个对象的状态，只是为了传递参数、调用该对象的一个方法，那么就可以考虑实现一个新的方法，以Lambda或方法表达式作为参数，新方法在检查完该对象的状态后才调用原来的方法，这样的一层处理会使代码结构更清晰和易读，封装性更好。</p><h4 id="1-4-3-环绕执行"><a href="#1-4-3-环绕执行" class="headerlink" title="1.4.3 环绕执行"></a><strong>1.4.3 环绕执行</strong></h4><p>&emsp;&emsp;环绕执行模式：<strong>如资源处理等场景往往需要打开一个资源，进行处理，然后关闭资源，准备和清理会环绕着执行处理的那些重要代码</strong>。业务代码虽然各不相同，但都有同样的准备和清理阶段。我们可以重用准备和清理阶段的逻辑，减少重复冗余的代码，如下所示，我们把打开和关闭文件看作重复操作，抽离出不同的处理方法。</p><figure class="highlight armasm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">//通过函数式接口<span class="keyword">BufferedReaderProcesser，可以传递各种Lambda表达式对BufferedReader对象进行处理</span></span><br><span class="line"><span class="keyword">String </span>oneLine = processFile((<span class="keyword">BufferedReader </span><span class="keyword">b) </span>-&gt; <span class="keyword">b.readLine());</span></span><br><span class="line"><span class="keyword">String </span>twoLine = processFile((<span class="keyword">BufferedReader </span><span class="keyword">b) </span>-&gt; <span class="keyword">b.readLine() </span>+ <span class="keyword">b.readLine());</span></span><br><span class="line"><span class="keyword"></span></span><br><span class="line"><span class="keyword">public </span>static <span class="keyword">String </span>processFile(<span class="keyword">BufferedReaderProcesser </span>p)throws IOException&#123;</span><br><span class="line">    try(<span class="keyword">BufferedReader </span><span class="keyword">br </span>= new <span class="keyword">BufferedReader(new </span>FileReader(<span class="string">"d:/data.txt"</span>)))&#123;</span><br><span class="line">        return p.process(<span class="keyword">br);</span></span><br><span class="line"><span class="keyword"> </span>   &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="symbol">public</span> interface <span class="keyword">BufferedReaderProcesser&#123;</span></span><br><span class="line"><span class="keyword"> </span>   <span class="keyword">String </span>process(<span class="keyword">BufferedReader </span><span class="keyword">b)throws </span>IOException<span class="comment">;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><h2 id="第二节-使用Lambda重构面向对象的设计模式"><a href="#第二节-使用Lambda重构面向对象的设计模式" class="headerlink" title="第二节 使用Lambda重构面向对象的设计模式"></a><strong>第二节 使用Lambda重构面向对象的设计模式</strong></h2><p>&emsp;&emsp;新特性的出现往往会代替旧的编程模式，如Java 5时引入的for-each，因为其稳健性和简洁性，已在大部分场合代替了显式使用迭代器的方式。Java 7时推出的&lt;&gt;菱形操作符使创建实例时无需显式使用泛型，也推动了开发者们使用类型接口进行程序设计。</p><p>&emsp;&emsp;Lambda表达式为传统设计模式所面对的问题提供了更高效和简单的新解决方案，以下会简单整理几个常见的设计模式，以及Lambda表达式对于这些设计模式的实现优化。</p><h3 id="2-1-策略模式"><a href="#2-1-策略模式" class="headerlink" title="2.1 策略模式"></a><strong>2.1 策略模式</strong></h3><blockquote><ul><li>一个代表某个算法的接口</li><li>一个或多个此接口的具体实现</li><li>一个或多个使用策略对象的客户</li></ul></blockquote><p><img src="https://pic-1258215793.cos.ap-shanghai.myqcloud.com/content/20190901/201909010137.png" alt="策略模式"></p><p>&emsp;&emsp;我们通过传统的方式实现一个策略模式的实例——字符串校验器，用户根据需求实现策略对象。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 策略接口-校验策略</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">ValidationStratery</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">boolean</span> <span class="title">execute</span><span class="params">(String s)</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 策略实现-是否全部小写</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">IsAllLowerCase</span> <span class="keyword">implements</span> <span class="title">ValidationStratery</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">execute</span><span class="params">(String s)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> s.matches(<span class="string">"[a-z]+"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 策略实现-是否数字</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">IsNumeric</span> <span class="keyword">implements</span> <span class="title">ValidationStratery</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">execute</span><span class="params">(String s)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> s.matches(<span class="string">"\\d+"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 策略接口实现类-校验器</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Validator</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> ValidationStratery stratery;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Validator</span><span class="params">(ValidationStratery v)</span></span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.stratery = v;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">validate</span><span class="params">(String s)</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> stratery.execute(s);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//多个使用策略对象的客户</span></span><br><span class="line">        Validator numberValidator = <span class="keyword">new</span> Validator(<span class="keyword">new</span> IsNumeric());</span><br><span class="line">        <span class="keyword">boolean</span> b1 = numberValidator.validate(<span class="string">"aaaa"</span>);</span><br><span class="line">        System.out.println(<span class="string">"b1 : "</span> + b1);<span class="comment">//false</span></span><br><span class="line">        Validator lowerCaseValidator = <span class="keyword">new</span> Validator(<span class="keyword">new</span> IsAllLowerCase());</span><br><span class="line">        <span class="keyword">boolean</span> b2 = lowerCaseValidator.validate(<span class="string">"bbbb"</span>);</span><br><span class="line">        System.out.println(<span class="string">"b2 : "</span> + b2);<span class="comment">//true</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>&emsp;&emsp;通过Lambda表达式改写，代码如下。我们有函数式接口ValidationStratery，无需通过类来构建策略实现，实现的代码块通过Lambda表达式来参数化。</p><figure class="highlight livescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">Validator numberValidatorL = <span class="keyword">new</span> Validator<span class="function"><span class="params">((String s) -&gt; s.matches(<span class="string">"\\d+"</span>))</span>;</span></span><br><span class="line"><span class="function"><span class="title">boolean</span> <span class="title">b3</span> = <span class="title">numberValidatorL</span>.<span class="title">validate</span><span class="params">(<span class="string">"aaaa"</span>)</span>;</span></span><br><span class="line"><span class="function"><span class="title">System</span>.<span class="title">out</span>.<span class="title">println</span><span class="params">(<span class="string">"b3 : "</span> + b3)</span>;//<span class="title">false</span></span></span><br><span class="line"><span class="function"><span class="title">Validator</span> <span class="title">lowerCaseValidatorL</span> = <span class="title">new</span> <span class="title">Validator</span><span class="params">((String s) -&gt; s.matches(<span class="string">"[a-z]+"</span>))</span>;</span></span><br><span class="line"><span class="function"><span class="title">boolean</span> <span class="title">b4</span> = <span class="title">lowerCaseValidatorL</span>.<span class="title">validate</span><span class="params">(<span class="string">"bbbb"</span>)</span>;</span></span><br><span class="line"><span class="function"><span class="title">System</span>.<span class="title">out</span>.<span class="title">println</span><span class="params">(<span class="string">"b4 : "</span> + b4)</span>;//<span class="title">true</span></span></span><br></pre></td></tr></table></figure><h3 id="2-2-模板方法"><a href="#2-2-模板方法" class="headerlink" title="2.2 模板方法"></a><strong>2.2 模板方法</strong></h3><p>&emsp;&emsp;有时你会希望使用某个算法，但需要对其中某些代码行进行改进从而达到想要的效果，模板方法模式可以解决这一需求。通常会使用抽象类来来表示算法，需要修改的部分方法可以通过继承来实现。</p><p>&emsp;&emsp;如下列在线银行需求，processCustomer方法搭建了在线银行算法的框架，不同的支行可以通过继承OnlineBanking类，对该方法提供差异性的实现。</p><figure class="highlight cs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 在线银行：用户输入账户，应用从数据库获取用户详细信息，最终完成一些让用户满意的操作，不同分行的满意方式会不同。</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">abstract</span> <span class="keyword">class</span> <span class="title">OnlineBanking</span> &#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 获取客户提供的ID，然后使客户满意</span></span><br><span class="line"><span class="comment">     * @param id 账户</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">processCustomer</span>(<span class="params"><span class="keyword">int</span> id</span>)</span>&#123;</span><br><span class="line">        Customer c = DataBase.getCustomerWithId(id);</span><br><span class="line">        makeCustomerHappy(c);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title">makeCustomerHappy</span>(<span class="params">Customer c</span>)</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>&emsp;&emsp;引入Lambda表达式，我们就可以不用再继承OnlineBanking类，只须传递不同的实现即可。</p><figure class="highlight aspectj"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 重载processCustomer，引入函数式接口参数</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> id 账户</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> makeCustomerHappy 不同实现</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="function"><span class="keyword">void</span> <span class="title">processCustomer</span><span class="params">(<span class="keyword">int</span> id, Consumer&lt;Customer&gt; makeCustomerHappy)</span></span>&#123;</span><br><span class="line">    Customer c = DataBase.getCustomerWithId(id);</span><br><span class="line">    makeCustomerHappy.accept(c);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="function"><span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">new</span> OnlineBankingNotAbs().processCustomer(<span class="number">1</span>,(Customer c) -&gt; System.out.println(<span class="string">"Hello "</span> + c.getName()));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="2-3-观察者模式"><a href="#2-3-观察者模式" class="headerlink" title="2.3 观察者模式"></a><strong>2.3 观察者模式</strong></h3><p>&emsp;&emsp;某些事件发生时（如状态转变），如果一个对象（主题）需要自动的通知多个对象（观察者），就会采用观察者模式。</p><p><img src="https://pic-1258215793.cos.ap-shanghai.myqcloud.com/content/20190901/201909010138.png" alt="观察者模式"></p><p>&emsp;&emsp;假设我们要为Twitter实现一个定制化的通知系统，如果一些报社订阅了新闻，在新闻中包含他们关注的关键字时会得到特别通知，实现代码如下。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 观察者接口</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Observer</span> </span>&#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 当接收到一条新闻时，会调用此方法</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> tweet 内容</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">notify</span><span class="params">(String tweet)</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 观察者—纽约时报</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">NYTimes</span> <span class="keyword">implements</span> <span class="title">Observer</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">notify</span><span class="params">(String tweet)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(tweet != <span class="keyword">null</span> &amp;&amp; tweet.contains(<span class="string">"money"</span>))&#123;</span><br><span class="line">            System.out.println(<span class="string">"Breaking news in NY! "</span> + tweet);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 观察者—卫报</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Guardian</span> <span class="keyword">implements</span> <span class="title">Observer</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">notify</span><span class="params">(String tweet)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(tweet != <span class="keyword">null</span> &amp;&amp; tweet.contains(<span class="string">"queen"</span>))&#123;</span><br><span class="line">            System.out.println(<span class="string">"Yet another news in London... "</span> + tweet);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 观察者—世界报</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Lemonde</span> <span class="keyword">implements</span> <span class="title">Observer</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">notify</span><span class="params">(String tweet)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(tweet != <span class="keyword">null</span> &amp;&amp; tweet.contains(<span class="string">"wine"</span>))&#123;</span><br><span class="line">            System.out.println(<span class="string">"Today cheese, wine and news! "</span> + tweet);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 主题—通知接口</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Subject</span> </span>&#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 注册观察者</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> o 观察者</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">registerObserver</span><span class="params">(Observer o)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 通知观察者</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> tweet 内容</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">notifyObservers</span><span class="params">(String tweet)</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 主题实现—通知器</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Feed</span> <span class="keyword">implements</span> <span class="title">Subject</span> </span>&#123;</span><br><span class="line">    <span class="comment">//观察者集合</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> List&lt;Observer&gt; observers = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">registerObserver</span><span class="params">(Observer o)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.observers.add(o);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">notifyObservers</span><span class="params">(String tweet)</span> </span>&#123;</span><br><span class="line">        observers.forEach(o -&gt; o.notify(tweet));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Feed f = <span class="keyword">new</span> Feed();</span><br><span class="line">        f.registerObserver(<span class="keyword">new</span> NYTimes());</span><br><span class="line">        f.registerObserver(<span class="keyword">new</span> Guardian());</span><br><span class="line">        f.registerObserver(<span class="keyword">new</span> Lemonde());</span><br><span class="line">        f.notifyObservers(<span class="string">"The queen said her favourite book is Java 8 in Action!"</span>);</span><br><span class="line">        <span class="comment">//Yet another news in London... The queen said her favourite book is Java 8 in Action!</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>&emsp;&emsp;如果引入Lambda表达式，我们就没必要去构建每个观察者的实现类了，无需显式的实例化观察者对象，直接传递Lambda表达式来表示需要执行的行为即可。</p><figure class="highlight livescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">Feed f1 = <span class="keyword">new</span> Feed();</span><br><span class="line">f1.registerObserver<span class="function"><span class="params">((String tweet) -&gt; &#123;</span></span></span><br><span class="line"><span class="function"><span class="params">    <span class="keyword">if</span>(tweet != <span class="literal">null</span> &amp;&amp; tweet.contains(<span class="string">"money"</span>))&#123;</span></span></span><br><span class="line"><span class="function"><span class="params">        System.out.println(<span class="string">"Breaking news in NY! "</span> + tweet);</span></span></span><br><span class="line"><span class="function"><span class="params">    &#125;</span></span></span><br><span class="line"><span class="function"><span class="params">&#125;)</span>;</span></span><br><span class="line"><span class="function"><span class="title">f1</span>.<span class="title">registerObserver</span><span class="params">((String tweet) -&gt; &#123;</span></span></span><br><span class="line"><span class="function"><span class="params">    <span class="keyword">if</span>(tweet != <span class="literal">null</span> &amp;&amp; tweet.contains(<span class="string">"queen"</span>))&#123;</span></span></span><br><span class="line"><span class="function"><span class="params">        System.out.println(<span class="string">"Yet another news in London... "</span> + tweet);</span></span></span><br><span class="line"><span class="function"><span class="params">    &#125;</span></span></span><br><span class="line"><span class="function"><span class="params">&#125;)</span>;</span></span><br><span class="line"><span class="function"><span class="title">f1</span>.<span class="title">registerObserver</span><span class="params">((String tweet) -&gt; &#123;</span></span></span><br><span class="line"><span class="function"><span class="params">    <span class="keyword">if</span>(tweet != <span class="literal">null</span> &amp;&amp; tweet.contains(<span class="string">"wine"</span>))&#123;</span></span></span><br><span class="line"><span class="function"><span class="params">        System.out.println(<span class="string">"Today cheese, wine and news! "</span> + tweet);</span></span></span><br><span class="line"><span class="function"><span class="params">    &#125;</span></span></span><br><span class="line"><span class="function"><span class="params">&#125;)</span>;</span></span><br><span class="line"><span class="function"><span class="title">f1</span>.<span class="title">notifyObservers</span><span class="params">(<span class="string">"The queen said her favourite book is Java 8 in Action!"</span>)</span>;</span></span><br></pre></td></tr></table></figure><p>&emsp;&emsp;如果代码块很复杂，甚至还包含状态的话就不应该再使用Lambda表达式来代替类了。</p><h3 id="2-4-责任链模式"><a href="#2-4-责任链模式" class="headerlink" title="2.4 责任链模式"></a><strong>2.4 责任链模式</strong></h3><p>&emsp;&emsp;责任链模式则是一种创建处理对象序列的通用方案。一个处理对象可能需要在完成一些工作后，将结果传递给另一个对象，这个对象接着做一些工作，再转交给下个对象，以此类推。</p><p>&emsp;&emsp;通常此模式通过定义一个代表处理对象的抽象类来实现，successor记录后续对象，一旦对象完成工作，就会将工作转交给后继。</p><figure class="highlight aspectj"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">ProcessingObject</span>&lt;<span class="title">T</span>&gt; </span>&#123;</span><br><span class="line">    <span class="keyword">protected</span> ProcessingObject&lt;T&gt; successor;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> <span class="function"><span class="keyword">void</span> <span class="title">setSuccessor</span><span class="params">(ProcessingObject&lt;T&gt; successor)</span></span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.successor = successor;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> <span class="function">T <span class="title">handle</span><span class="params">(T input)</span></span>&#123;</span><br><span class="line">        T r = handleWork(input);</span><br><span class="line">        <span class="keyword">if</span>(successor != <span class="keyword">null</span>)&#123;</span><br><span class="line">            <span class="function"><span class="keyword">return</span> successor.<span class="title">handle</span><span class="params">(r)</span></span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> r;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">abstract</span> <span class="keyword">protected</span> <span class="function">T <span class="title">handleWork</span><span class="params">(T input)</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="https://pic-1258215793.cos.ap-shanghai.myqcloud.com/content/20190901/201909010139.png" alt="责任链模式"></p><p>&emsp;&emsp;这种实现就是模板方法设计模式，我们尝试继承并实现抽象方法，代码如下。</p><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">public <span class="class"><span class="keyword">class</span> <span class="title">HeaderTextProcessing</span> <span class="keyword">extends</span> <span class="title">ProcessingObject&lt;String&gt;</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">protected</span> <span class="type">String</span> handleWork(<span class="type">String</span> input) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">"From Raoul, Mario, and Alan: "</span> + input;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">public <span class="class"><span class="keyword">class</span> <span class="title">SpellCheckerProcessing</span> <span class="keyword">extends</span> <span class="title">ProcessingObject&lt;String&gt;</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">protected</span> <span class="type">String</span> handleWork(<span class="type">String</span> input) &#123;</span><br><span class="line">        <span class="keyword">return</span> input.replaceAll(<span class="string">"labda"</span>,<span class="string">"lambda"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">public <span class="class"><span class="keyword">class</span> <span class="title">Test</span> </span>&#123;</span><br><span class="line">    public static void main(<span class="type">String</span>[] args) &#123;</span><br><span class="line">        <span class="type">ProcessingObject</span>&lt;<span class="type">String</span>&gt; p1 = <span class="keyword">new</span> <span class="type">HeaderTextProcessing</span>();</span><br><span class="line">        <span class="type">ProcessingObject</span>&lt;<span class="type">String</span>&gt; p2 = <span class="keyword">new</span> <span class="type">SpellCheckerProcessing</span>();</span><br><span class="line"></span><br><span class="line">        <span class="comment">//将两个处理链接起来</span></span><br><span class="line">        p1.setSuccessor(p2);</span><br><span class="line"></span><br><span class="line">        <span class="type">String</span> result = p1.handle(<span class="string">"Aren`t labdas really sexy?!!"</span>);</span><br><span class="line">        <span class="type">System</span>.out.println(result);<span class="comment">//From Raoul, Mario, and Alan: Aren`t lambdas really sexy?!!</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>&emsp;&emsp;如果引入Lambda表达式，我们可以不用构建不同的处理对象，而是将对象作为UnaryOperator的一个实例，并通过andThen进行连接。</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">UnaryOperator&lt;<span class="built_in">String</span>&gt; headerTextProcessing = (<span class="built_in">String</span> input) -&gt; <span class="string">"From Raoul, Mario, and Alan: "</span> + input;</span><br><span class="line">UnaryOperator&lt;<span class="built_in">String</span>&gt; spellCheckerProcessing = (<span class="built_in">String</span> input) -&gt; input.replaceAll(<span class="string">"labda"</span>,<span class="string">"lambda"</span>);</span><br><span class="line"><span class="comment">//将两个方法结合起来</span></span><br><span class="line">Function&lt;<span class="built_in">String</span>, <span class="built_in">String</span>&gt; pipeline = headerTextProcessing.andThen(spellCheckerProcessing);</span><br><span class="line"><span class="built_in">String</span> result1 = pipeline.apply(<span class="string">"Aren`t labdas really sexy?!!"</span>);</span><br><span class="line">System.out.println(result1);<span class="comment">//From Raoul, Mario, and Alan: Aren`t lambdas really sexy?!!</span></span><br></pre></td></tr></table></figure><h3 id="2-5-工厂模式"><a href="#2-5-工厂模式" class="headerlink" title="2.5 工厂模式"></a><strong>2.5 工厂模式</strong></h3><p>&emsp;&emsp;工厂模式可以隐藏实例化的逻辑而完成对象的创建。我们不会再暴露构造函数或配置给客户，也使客户创建产品时更加容易。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ProductFactory</span> &#123;</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Product <span class="title">createProduct</span><span class="params">(String name)</span></span>&#123;</span><br><span class="line">        <span class="keyword">switch</span> (name)&#123;</span><br><span class="line">            <span class="keyword">case</span> <span class="string">"loan"</span> : <span class="keyword">return</span> <span class="keyword">new</span> Loan();<span class="comment">//贷款</span></span><br><span class="line">            <span class="keyword">case</span> <span class="string">"stock"</span> : <span class="keyword">return</span> <span class="keyword">new</span> Stock();<span class="comment">//股票</span></span><br><span class="line">            <span class="keyword">case</span> <span class="string">"bond"</span> : <span class="keyword">return</span> <span class="keyword">new</span> Bond();<span class="comment">//债券</span></span><br><span class="line">            <span class="keyword">default</span>: <span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException(<span class="string">"No such product "</span> + name);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">        Product p = ProductFactory.createProduct(<span class="string">"loan"</span>);</span><br></pre></td></tr></table></figure><p>&emsp;&emsp;如果引入Lambda表达式，我们可以首先引用构造函数构建Map，通过函数式接口Supplier来传递构造器引用。但如果我们需要多个参数来构建产品时，这种方案的扩展性不是很好，你需要提供不同的函数接口，而无法采用统一使用一个简单接口的方式。</p><figure class="highlight arduino"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> Product createProductL(<span class="keyword">String</span> name)&#123;</span><br><span class="line">    Supplier&lt;Product&gt; p = <span class="built_in">map</span>.<span class="built_in">get</span>(name);</span><br><span class="line">    <span class="built_in">if</span>(p != null) <span class="built_in">return</span> p.<span class="built_in">get</span>();</span><br><span class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(<span class="string">"No such product "</span> + name);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">final <span class="keyword">static</span> Map&lt;<span class="keyword">String</span>, Supplier&lt;Product&gt;&gt; <span class="built_in">map</span> = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line"><span class="keyword">static</span> &#123;</span><br><span class="line">    <span class="built_in">map</span>.<span class="built_in">put</span>(<span class="string">"loan"</span>,Loan::<span class="keyword">new</span>);</span><br><span class="line">    <span class="built_in">map</span>.<span class="built_in">put</span>(<span class="string">"stock"</span>,Stock::<span class="keyword">new</span>);</span><br><span class="line">    <span class="built_in">map</span>.<span class="built_in">put</span>(<span class="string">"bond"</span>,Bond::<span class="keyword">new</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">    Product p1 = ProductFactory.createProductL(<span class="string">"loan"</span>);</span><br></pre></td></tr></table></figure><hr><h2 id="第三节-测试Lambda表达式"><a href="#第三节-测试Lambda表达式" class="headerlink" title="第三节 测试Lambda表达式"></a><strong>第三节 测试Lambda表达式</strong></h2><p>&emsp;&emsp;Lambda表达式都是匿名函数无函数名，测试上会有问题，无法直接通过函数名的方式来调用。我们可以通过某个字段来访问Lambda函数，然后测试表达式所生成函数接口实例的行为。</p><figure class="highlight groovy"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> testMoveRightBy()<span class="keyword">throws</span> Exception&#123;</span><br><span class="line">    Point p1 = <span class="keyword">new</span> Point(<span class="number">5</span>, <span class="number">5</span>);</span><br><span class="line">    Point p2 = p1.moveRightBy(<span class="number">10</span>);</span><br><span class="line">    </span><br><span class="line">    assertEquals(<span class="number">15</span>, p2.getX());</span><br><span class="line">    assertEquals(<span class="number">5</span>, p2.getY());</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">static</span> Comparator&lt;Point&gt; compareByXAndThenY = Comparator.comparing(<span class="string">Point:</span>:getX).thenComparing(<span class="string">Point:</span>:getY);</span><br></pre></td></tr></table></figure><p>&emsp;&emsp;Lambda表达式的初衷是封装一些逻辑给另外一个方法调用，所以不应该声明Lambda表达式为public，它们只是具体的实现细节，而是应该对使用Lambda表达式的方法进行测试。</p><p>&emsp;&emsp;有些时候我们会遇到一些比较复杂的Lambda表达式，包含了大量的业务逻辑，如需要处理复杂情况的定价算法。Lambda表达式可以转换为方法引用。</p><hr><h2 id="第四节-调试"><a href="#第四节-调试" class="headerlink" title="第四节 调试"></a><strong>第四节 调试</strong></h2><p>&emsp;&emsp;当代码出现异常需要调试时，我们有两项武器：(1)查看栈跟踪 (2)输出日志</p><h3 id="4-1-查看栈跟踪"><a href="#4-1-查看栈跟踪" class="headerlink" title="4.1 查看栈跟踪"></a><strong>4.1 查看栈跟踪</strong></h3><p>&emsp;&emsp;首先需要调查程序在何处发生异常，为何会发生异常？程序的每次方法调用都会产生相应的调用信息，包括程序中方法调用的位置、该方法调用使用的参数、被调用方法的本地变量，这些信息都保存在栈帧上。程序失败时，你会获得它的栈跟踪，通过一个又一个的栈帧，通过这些信息你可以获取到程序失败时的方法调用列表。</p><p>&emsp;&emsp;因为Lambda表达式没有名字，其栈跟踪会很难分析，如以下代码运行时发生异常，因为没有函数名所以编译器只能为它们指定一个名字，即使替换为方法引用，依然会有类似很难分析的栈跟踪。</p><figure class="highlight mipsasm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">public class Debugging &#123;</span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        List&lt;Point&gt; points = Arrays.asList(new Point(<span class="number">12</span>, <span class="number">2</span>),null)<span class="comment">;</span></span><br><span class="line">        points.stream().map(p -&gt; p.getX()).forEach(System.out::println)<span class="comment">;</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">Exception in thread <span class="string">"main"</span> <span class="keyword">java.lang.NullPointerException</span></span><br><span class="line"><span class="keyword"></span><span class="built_in">at</span> categories.<span class="keyword">java.a7stream.test.Debugging.lambda$main$0(Debugging.java:9)</span></span><br><span class="line"><span class="keyword"></span><span class="built_in">at</span> <span class="keyword">java.util.stream.ReferencePipeline$3$1.accept(ReferencePipeline.java:193)</span></span><br><span class="line"><span class="keyword"></span><span class="built_in">at</span> <span class="keyword">java.util.Spliterators$ArraySpliterator.forEachRemaining(Spliterators.java:948)</span></span><br><span class="line"><span class="keyword"></span><span class="built_in">at</span> <span class="keyword">java.util.stream.AbstractPipeline.copyInto(AbstractPipeline.java:481)</span></span><br><span class="line"><span class="keyword"></span><span class="built_in">at</span> <span class="keyword">java.util.stream.AbstractPipeline.wrapAndCopyInto(AbstractPipeline.java:471)</span></span><br><span class="line"><span class="keyword"></span><span class="built_in">at</span> <span class="keyword">java.util.stream.ForEachOps$ForEachOp.evaluateSequential(ForEachOps.java:151)</span></span><br><span class="line"><span class="keyword"></span><span class="built_in">at</span> <span class="keyword">java.util.stream.ForEachOps$ForEachOp$OfRef.evaluateSequential(ForEachOps.java:174)</span></span><br><span class="line"><span class="keyword"></span><span class="built_in">at</span> <span class="keyword">java.util.stream.AbstractPipeline.evaluate(AbstractPipeline.java:234)</span></span><br><span class="line"><span class="keyword"></span><span class="built_in">at</span> <span class="keyword">java.util.stream.ReferencePipeline.forEach(ReferencePipeline.java:418)</span></span><br><span class="line"><span class="keyword"></span><span class="built_in">at</span> categories.<span class="keyword">java.a7stream.test.Debugging.main(Debugging.java:9)</span></span><br></pre></td></tr></table></figure><h3 id="4-2-使用日志调试"><a href="#4-2-使用日志调试" class="headerlink" title="4.2 使用日志调试"></a><strong>4.2 使用日志调试</strong></h3><p>&emsp;&emsp;对流水线进行调试，可以使用forEach把流操作的结果日志输出或记录到日志文件。不过一旦调用forEach，整个流就会恢复运行，这时就是流操作peek大显身手的时候，peek的设计初衷就是在流的每个元素恢复运行之前，插入执行一个动作，且不像forEach那样恢复整个流的运行，而是在一个元素上完成操作之后，它只会讲操作顺承到流水线中的下一个操作。</p><figure class="highlight xl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">List&lt;Integer&gt; numbers = Arrays.asList(<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>);</span><br><span class="line">numbers.stream()</span><br><span class="line">        .<span class="function"><span class="title">map</span>(x -&gt;</span> x + <span class="number">17</span>)</span><br><span class="line">        .<span class="function"><span class="title">filter</span>(x -&gt;</span> x % <span class="number">2</span> == <span class="number">0</span>)</span><br><span class="line">        .limit(<span class="number">3</span>)</span><br><span class="line">        .forEach(System.out::println);</span><br><span class="line">List&lt;Integer&gt; result = numbers.stream()</span><br><span class="line">        .<span class="function"><span class="title">peek</span>(x -&gt;</span> System.out.println(<span class="string">"from stream: "</span> + x)) <span class="comment">//输出来自数据源的当前元素值</span></span><br><span class="line">        .<span class="function"><span class="title">map</span>(x -&gt;</span> x + <span class="number">17</span>)</span><br><span class="line">        .<span class="function"><span class="title">peek</span>(x -&gt;</span> System.out.println(<span class="string">"after map: "</span> + x)) <span class="comment">//输出map操作的结果</span></span><br><span class="line">        .<span class="function"><span class="title">filter</span>(x -&gt;</span> x % <span class="number">2</span> == <span class="number">0</span>)</span><br><span class="line">        .<span class="function"><span class="title">peek</span>(x -&gt;</span> System.out.println(<span class="string">"after filter: "</span> + x)) <span class="comment">//输出经过filter操作之后，剩下的元素个数</span></span><br><span class="line">        .limit(<span class="number">3</span>)</span><br><span class="line">        .<span class="function"><span class="title">peek</span>(x -&gt;</span> System.out.println(<span class="string">"after limit: "</span> + x)) <span class="comment">//输出经过limit操作之后，剩下的元素个数</span></span><br><span class="line">        .collect(Collectors.toList());</span><br></pre></td></tr></table></figure><p><img src="https://pic-1258215793.cos.ap-shanghai.myqcloud.com/content/20190901/201909010140.png" alt="使用peek查看Stream流水线中的数据流的值"></p><p>&emsp;&emsp;打印结果如下，forEach只能打印出流水线操作之后的结果，而peek则可以了解流水线操作中每一步的输出结果。</p><figure class="highlight livecodeserver"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">20</span></span><br><span class="line"><span class="number">22</span></span><br><span class="line"><span class="built_in">from</span> stream: <span class="number">2</span></span><br><span class="line"><span class="keyword">after</span> map: <span class="number">19</span></span><br><span class="line"><span class="built_in">from</span> stream: <span class="number">3</span></span><br><span class="line"><span class="keyword">after</span> map: <span class="number">20</span></span><br><span class="line"><span class="keyword">after</span> <span class="built_in">filter</span>: <span class="number">20</span></span><br><span class="line"><span class="keyword">after</span> limit: <span class="number">20</span></span><br><span class="line"><span class="built_in">from</span> stream: <span class="number">4</span></span><br><span class="line"><span class="keyword">after</span> map: <span class="number">21</span></span><br><span class="line"><span class="built_in">from</span> stream: <span class="number">5</span></span><br><span class="line"><span class="keyword">after</span> map: <span class="number">22</span></span><br><span class="line"><span class="keyword">after</span> <span class="built_in">filter</span>: <span class="number">22</span></span><br><span class="line"><span class="keyword">after</span> limit: <span class="number">22</span></span><br></pre></td></tr></table></figure><hr><p><em>参考博客和文章书籍等：</em></p><blockquote><p>《Java8实战》</p></blockquote><p><em>因博客主等未标明不可引用，若部分内容涉及侵权请及时告知，我会尽快修改和删除相关内容</em> H  H</p>]]></content>
    
    <summary type="html">
    
      介绍Java 8中加入的流——重构、测试和调试，内容包括：为改善可读性和灵活性重构代码（匿名类到Lambda表达式、Lambda表达式到方法引用、命令式数据处理到Stream、增加代码灵活性），使用Lambda重构面向对象的设计模式（策略模式、模板方法、观察者模式、责任链模式、工厂模式），测试Lambda表达式，调试等。
    
    </summary>
    
      <category term="技术文档" scheme="http://linyishui.top/categories/%E6%8A%80%E6%9C%AF%E6%96%87%E6%A1%A3/"/>
    
    
      <category term="java" scheme="http://linyishui.top/tags/java/"/>
    
      <category term="stream" scheme="http://linyishui.top/tags/stream/"/>
    
  </entry>
  
  <entry>
    <title>流（四）并行化处理</title>
    <link href="http://linyishui.top/2019092501.html"/>
    <id>http://linyishui.top/2019092501.html</id>
    <published>2019-09-25T10:38:14.000Z</published>
    <updated>2019-12-05T06:26:38.627Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="流（四）并行化处理"><a href="#流（四）并行化处理" class="headerlink" title="流（四）并行化处理"></a><strong>流（四）并行化处理</strong></h1><h2 id="第九节-并行化数据处理"><a href="#第九节-并行化数据处理" class="headerlink" title="第九节 并行化数据处理"></a><strong>第九节 并行化数据处理</strong></h2><p>&emsp;&emsp;在早期版本中，并行处理数据集合非常麻烦。第一，我们要把包含数据的数据结构分成若干子部分。第二，我们要给每个子部分分配一个独立的线程。第三，我们需要在恰当的时候对它们进行同步来避免竞争条件，等待所有线程完成，最后把这些结果合并。</p><p>&emsp;&emsp;Java 7时引入了<strong>分支/合并框架</strong>，使这些操作更稳定。</p><h3 id="9-1-并行流"><a href="#9-1-并行流" class="headerlink" title="9.1 并行流"></a><strong>9.1 并行流</strong></h3><p>&emsp;&emsp;<strong>并行流就是一个把内容分成多个数据块，并用不同线程分别处理每个数据块的流</strong>。通过parallelStream()方法把集合转换为并行流。通过parallel()方法将顺序流转为并行流。sequential()方法可以使并行流转为顺序流。所以结合这两个方法可以细化的控制哪些操作并行执行哪些操作顺序执行，但最后一次会决定整个流水线何种执行。</p><figure class="highlight zephir"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 计算从1到给定数字的和</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> n 值</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> 和</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">long</span> sequentialSum(<span class="keyword">long</span> n)&#123;</span><br><span class="line">    <span class="keyword">return</span> Stream.iterate(<span class="number">1</span>L, i -&gt; i + <span class="number">1</span>)</span><br><span class="line">            .limit(n)</span><br><span class="line">            .reduce(<span class="number">0</span>L, <span class="keyword">Long</span>::sum);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 迭代计算从1到给定数字的和</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> n 值</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> 和</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">long</span> iterativeSum(<span class="keyword">long</span> n)&#123;</span><br><span class="line">    <span class="keyword">long</span> result = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">long</span> i = <span class="number">1</span>L;i &lt;= n;i++)&#123;</span><br><span class="line">        result += i;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 并行计算从1到给定数字的和</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> n 值</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> 和</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">long</span> parallelSum(<span class="keyword">long</span> n)&#123;</span><br><span class="line">    <span class="keyword">return</span> Stream.iterate(<span class="number">1</span>L, i -&gt; i + <span class="number">1</span>)</span><br><span class="line">            .limit(n)</span><br><span class="line">            .parallel() <span class="comment">//将流转为并行流</span></span><br><span class="line">            .reduce(<span class="number">0</span>L, <span class="keyword">Long</span>::sum);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>&emsp;&emsp;同一个归纳操作会把各个子流的部分归纳结果合并起来，得到整个原始流的归纳结果，并行归纳操作如下图所示。</p><p><img src="https://pic-1258215793.cos.ap-shanghai.myqcloud.com/content/20190901/201909010132.png" alt="并行归纳操作"></p><p>&emsp;&emsp;parallel()只是改变了一个布尔标识，流本身不会有其他变化。</p><p>&emsp;&emsp;并行流的内部使用了默认的ForkJoinPool，默认线程数量为处理器数量(Runtime.getRuntime().availableProcessors()获取)。</p><h4 id="对比并行流和顺序流性能"><a href="#对比并行流和顺序流性能" class="headerlink" title="对比并行流和顺序流性能"></a><strong>对比并行流和顺序流性能</strong></h4><p>&emsp;&emsp;测试并行流性能，代码如下。</p><figure class="highlight zephir"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">    System.out.println(<span class="string">"Sequential sum done in "</span> + measureSumPerf(ParallelTest::sequentialSum, <span class="number">10</span>_000_000) + <span class="string">" mscs"</span>);</span><br><span class="line">    System.out.println(<span class="string">"Iterative sum done in "</span> + measureSumPerf(ParallelTest::iterativeSum, <span class="number">10</span>_000_000) + <span class="string">" mscs"</span>);</span><br><span class="line">    System.out.println(<span class="string">"Parallel sum done in "</span> + measureSumPerf(ParallelTest::parallelSum, <span class="number">10</span>_000_000) + <span class="string">" mscs"</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">long</span> measureSumPerf(<span class="function"><span class="keyword">Function</span>&lt;<span class="title">Long</span>, <span class="title">Long</span>&gt; <span class="title">adder</span>, <span class="title">long</span> <span class="title">n</span>)</span>&#123;</span><br><span class="line">    <span class="keyword">long</span> fastest = <span class="keyword">Long</span>.MAX_VALUE;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>;i &lt; <span class="number">10</span>;i++)&#123;<span class="comment">//测试运行10次</span></span><br><span class="line">        <span class="keyword">long</span> start = System.nanoTime();</span><br><span class="line">        <span class="keyword">long</span> sum = adder.apply(n);<span class="comment">//执行函数</span></span><br><span class="line">        <span class="keyword">long</span> duration = (System.nanoTime() - start) / <span class="number">1</span>_000_000;<span class="comment">//取运行时间的毫秒值</span></span><br><span class="line">        <span class="keyword">if</span>(duration &lt; fastest)<span class="comment">//检查执行是否是最快的一个</span></span><br><span class="line">            fastest = duration;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> fastest;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>&emsp;&emsp;执行结果如下。传统for循环迭代版本相比顺序流要快很多，因为它更底层以及不需要对原始类型做任何装箱/拆箱操作。但并行流却意外的比顺序流还要多消耗一倍时间。</p><figure class="highlight fortran"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">Sequential</span> <span class="built_in">sum</span> done <span class="keyword">in</span> <span class="number">181</span> mscs</span><br><span class="line">Iterative <span class="built_in">sum</span> done <span class="keyword">in</span> <span class="number">5</span> mscs</span><br><span class="line">Parallel <span class="built_in">sum</span> done <span class="keyword">in</span> <span class="number">378</span> mscs</span><br></pre></td></tr></table></figure><blockquote><p>并行版本慢的原因：</p><ul><li>iterate生成的是装箱的对象，必须要拆箱才能求和</li><li>很难吧iterate分成多个独立块执行（在实现斐波那契数列有提到iterate不利于并行化）</li></ul></blockquote><p>&emsp;&emsp;iterate迭代操作很难并行化，每次应用时都要依赖于前一次应用的结果。所以我们实际上并没有使操作并行，每次还要把求和操作分配到另一个线程，额外增加了开销。</p><p>&emsp;&emsp;如何优化上述代码使其达到并行化效果呢？首先我们通过LongStream.rangeClosed方法直接生成原始类型long数值，对比顺序流效率可以感受拆箱的开销。</p><figure class="highlight zephir"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 没有装箱的求和函数</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> n 值</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> 和</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">long</span> rangedSum(<span class="keyword">long</span> n)&#123;</span><br><span class="line">    <span class="keyword">return</span> LongStream.rangeClosed(<span class="number">1</span>, n).reduce(<span class="number">0</span>L, <span class="keyword">Long</span>::sum);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>&emsp;&emsp;执行结果如下，数值流避免了非针对性流这些没必要的自动装箱/拆箱操作，最终明显的降低了开销，选择合适的数据结构比并行化算法更显得重要。</p><figure class="highlight fortran"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">Range</span> <span class="built_in">sum</span> done <span class="keyword">in</span> <span class="number">7</span> mscs</span><br></pre></td></tr></table></figure><p>&emsp;&emsp;尝试把数值流应用于并行流，再观察开销。</p><figure class="highlight zephir"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 并行没有装箱的计算从1到给定数字的和</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> n 值</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> 和</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">long</span> parallelRangedSum(<span class="keyword">long</span> n)&#123;</span><br><span class="line">    <span class="keyword">return</span> LongStream.rangeClosed(<span class="number">1</span>, n)</span><br><span class="line">            .parallel()</span><br><span class="line">            .reduce(<span class="number">0</span>L, <span class="keyword">Long</span>::sum);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>&emsp;&emsp;执行结果如下，终于并行结果要快于顺序执行了，因为这次终于分开了数据块进行了并行运算。</p><figure class="highlight fortran"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Parallel <span class="built_in">range</span> <span class="built_in">sum</span> done <span class="keyword">in</span> <span class="number">2</span> mscs</span><br></pre></td></tr></table></figure><p>&emsp;&emsp;并行化其实有额外的代价，需要对流做递归划分，把每个子流的归纳操作分配到不同的线程，把操作的结果合并到一个值等。而且在多核之间移动数据也有很大的开销，所以最重要的是要<strong>保证在内核中并行执行工作的时间要比在内核间传输数据的时间长</strong>，要合理的选择并行化。</p><h4 id="正确使用并行流"><a href="#正确使用并行流" class="headerlink" title="正确使用并行流"></a><strong>正确使用并行流</strong></h4><p>&emsp;&emsp;错误的运用并行流的主要原因是使用的算法改变了某些共享状态。</p><p>&emsp;&emsp;下述代码sideEffectSum方法类似于我们常用的指令式迭代求和，其算法本质上就是顺序的，因为累加器的total变量每次访问都会出现竞争，我们可以尝试并行化它，看最终执行效果。</p><figure class="highlight zephir"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 通过累加器类对前n个自然数求和</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> n 值</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> 和</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">long</span> sideEffectSum(<span class="keyword">long</span> n)&#123;</span><br><span class="line">        Accumulator accumulator = <span class="keyword">new</span> Accumulator();</span><br><span class="line">        LongStream.rangeClosed(<span class="number">1</span>, n).<span class="keyword">forEach</span>(accumulator::add);</span><br><span class="line">        <span class="keyword">return</span> accumulator.total;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 通过累加器类对前n个自然数求和（并行化）</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> n 值</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> 和</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">long</span> sideEffectParallelSum(<span class="keyword">long</span> n)&#123;</span><br><span class="line">        Accumulator accumulator = <span class="keyword">new</span> Accumulator();</span><br><span class="line">        LongStream.rangeClosed(<span class="number">1</span>, n).parallel().<span class="keyword">forEach</span>(accumulator::add);</span><br><span class="line">        <span class="keyword">return</span> accumulator.total;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 累加器</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Accumulator</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">long</span> total = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">public</span> void add(<span class="keyword">long</span> value)&#123;</span><br><span class="line">        total += value;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>&emsp;&emsp;执行结果如下，并行时每次执行结果都是错误值，因为我们并行化的多线程处理操作都不是原子操作，<strong>根源就在于forEach所调用的函数会改变多线程共享变量的状态</strong>，所以并行化时应该避免共享可变状态。</p><figure class="highlight oxygene"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">Result</span>&lt;<span class="number">1</span>&gt;: <span class="number">50000005000000</span></span><br><span class="line"><span class="keyword">Result</span>&lt;<span class="number">2</span>&gt;: <span class="number">50000005000000</span></span><br><span class="line"><span class="keyword">Result</span>&lt;<span class="number">3</span>&gt;: <span class="number">50000005000000</span></span><br><span class="line"><span class="keyword">Result</span>&lt;<span class="number">4</span>&gt;: <span class="number">50000005000000</span></span><br><span class="line"><span class="keyword">Result</span>&lt;<span class="number">5</span>&gt;: <span class="number">50000005000000</span></span><br><span class="line"><span class="keyword">Result</span>&lt;<span class="number">6</span>&gt;: <span class="number">50000005000000</span></span><br><span class="line"><span class="keyword">Result</span>&lt;<span class="number">7</span>&gt;: <span class="number">50000005000000</span></span><br><span class="line"><span class="keyword">Result</span>&lt;<span class="number">8</span>&gt;: <span class="number">50000005000000</span></span><br><span class="line"><span class="keyword">Result</span>&lt;<span class="number">9</span>&gt;: <span class="number">50000005000000</span></span><br><span class="line"><span class="keyword">Result</span>&lt;<span class="number">10</span>&gt;: <span class="number">50000005000000</span></span><br><span class="line">Side effect sum done <span class="keyword">in</span> <span class="number">7</span> mscs</span><br><span class="line"><span class="keyword">Result</span>&lt;<span class="number">1</span>&gt;: <span class="number">8130267751928</span></span><br><span class="line"><span class="keyword">Result</span>&lt;<span class="number">2</span>&gt;: <span class="number">7068326376926</span></span><br><span class="line"><span class="keyword">Result</span>&lt;<span class="number">3</span>&gt;: <span class="number">8906998285116</span></span><br><span class="line"><span class="keyword">Result</span>&lt;<span class="number">4</span>&gt;: <span class="number">8213474338667</span></span><br><span class="line"><span class="keyword">Result</span>&lt;<span class="number">5</span>&gt;: <span class="number">9907376000941</span></span><br><span class="line"><span class="keyword">Result</span>&lt;<span class="number">6</span>&gt;: <span class="number">8850837255635</span></span><br><span class="line"><span class="keyword">Result</span>&lt;<span class="number">7</span>&gt;: <span class="number">7447244528787</span></span><br><span class="line"><span class="keyword">Result</span>&lt;<span class="number">8</span>&gt;: <span class="number">8092934175612</span></span><br><span class="line"><span class="keyword">Result</span>&lt;<span class="number">9</span>&gt;: <span class="number">8285103974383</span></span><br><span class="line"><span class="keyword">Result</span>&lt;<span class="number">10</span>&gt;: <span class="number">7964325408454</span></span><br><span class="line">Side effect <span class="keyword">parallel</span> sum done <span class="keyword">in</span> <span class="number">88</span> mscs</span><br></pre></td></tr></table></figure><h4 id="高效使用并行流"><a href="#高效使用并行流" class="headerlink" title="高效使用并行流"></a><strong>高效使用并行流</strong></h4><p>&emsp;&emsp;给出准确的使用并行流建议是不现实的，不同的场景和需求都会有无法定量的差异存在。</p><blockquote><ul><li><strong>多做测试</strong>：顺序流转为并行流是很容易的，但并行流未必比顺序流更快，所以请多测试。</li><li><strong>注意装箱</strong>：自动装箱和拆箱操作会大大降低性能，请多留意。</li><li><strong>避免有序</strong>：一些操作注定在并行流上效率要差于顺序流，特别是limit和findFirst等依赖于元素顺序的操作，如findAny因为不需要有序就要比findFirst快，unordered方法可以把有序流转为无序流，在满足有些需求的情况下能提高这些操作的性能。</li><li><strong>单次成本</strong>：假设N是元素总数，Q是单个元素通过流水线的成本，Q值越大则表示并行化更高效的可能性更大，我们要注意流水线的总计算成本。</li><li><strong>避免小数据</strong>：小量数据对于并行化总不会是一个好的应用场景，带来的好处抵不上额外开销。</li><li><strong>数据结构的分解效率</strong>：一些数据结构的拆分效率需要额外注意，如ArrayList的拆分就比LinkedList高效，实现Spliterator可以掌握分解流程。</li><li><strong>流与中间操作的影响</strong>：流自身的特点，以及流水线的中间操作修改流的方式，都会影响到分解过程的性能。如一个SIZED流可以分为大小相等的两块，每块都可以高效并行处理，但筛选操作丢弃的个数却无法预测，会导致流自身大小未知。</li><li><strong>终端合并的代价</strong>：要考虑终端操作合并步骤的代价，如果最后代价太大，可能会超过并行带来的性能提升。</li></ul></blockquote><table><thead><tr><th style="text-align:left">源</th><th style="text-align:center">可分解性</th></tr></thead><tbody><tr><td style="text-align:left">ArrayList</td><td style="text-align:center">极佳</td></tr><tr><td style="text-align:left">LinkedList</td><td style="text-align:center">差</td></tr><tr><td style="text-align:left">IntStream.range</td><td style="text-align:center">极佳</td></tr><tr><td style="text-align:left">Stream.iterate</td><td style="text-align:center">差</td></tr><tr><td style="text-align:left">HashSet</td><td style="text-align:center">好</td></tr><tr><td style="text-align:left">TreeSet</td><td style="text-align:center">好</td></tr></tbody></table><h3 id="9-2-分支-合并框架"><a href="#9-2-分支-合并框架" class="headerlink" title="9.2 分支/合并框架"></a><strong>9.2 分支/合并框架</strong></h3><p>&emsp;&emsp;分支/合并框架的目的是以递归的方式将可以并行的任务拆分为更小的子任务，将每个子任务的结果合并成整体结果。它是ExecutorService接口的一个实现，把子任务分配给线程池（ForkJoinPool）中的工作线程。</p><h4 id="RecursiveTask"><a href="#RecursiveTask" class="headerlink" title="RecursiveTask"></a><strong>RecursiveTask</strong></h4><p>&emsp;&emsp;R是并行化任务产生的结果类型，若任务不返回结果，则是RecursiveAction类型。</p><p>&emsp;&emsp;定义RecursiveTask只须实现compute方法，此方法同时定义了将任务拆分成子任务的逻辑，以及无法再拆分或不方便再拆分时，生成单个子任务结果的逻辑。</p><p>&emsp;&emsp;此方法的实现如下述伪代码，只不过是著名的分治算法的并行版本。</p><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="title">if</span><span class="params">(任务足够小或不可分)</span></span>&#123;</span><br><span class="line">    顺序计算该任务</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    将任务分成两个子任务</span><br><span class="line">    递归调用本方法，拆分每个子任务，等待所有子任务完成</span><br><span class="line">    合并每个子任务的结果</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>&emsp;&emsp;递归的任务拆分过程如下图所示。</p><p><img src="https://pic-1258215793.cos.ap-shanghai.myqcloud.com/content/20190901/201909010133.png" alt="分支/合并过程"></p><p>&emsp;&emsp;我们可以实现一个分支合并任务进行并行求和，代码如下。</p><figure class="highlight aspectj"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 分支合并框架进行并行求和</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ForkJoinSumCalculator</span> <span class="keyword">extends</span> <span class="title">RecursiveTask</span>&lt;<span class="title">Long</span>&gt; </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">long</span>[] numbers;<span class="comment">//要进行求和的数组</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">int</span> start;<span class="comment">//子任务处理的数组起始位置</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">int</span> end;<span class="comment">//子任务处理的数组终止位置</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">long</span> THRESHOLD = <span class="number">10</span>_000;<span class="comment">//停止分解子任务的数组大小</span></span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">protected</span> <span class="function">Long <span class="title">compute</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> length = start - end;<span class="comment">//要进行求和的部分大小</span></span><br><span class="line">        <span class="keyword">if</span>(length &lt;= THRESHOLD)&#123;<span class="comment">//如果大小小于或等于阈值，就执行顺序计算结果</span></span><br><span class="line">            <span class="function"><span class="keyword">return</span> <span class="title">computeSequentially</span><span class="params">()</span></span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//创建一个子任务为数组的前一半求和</span></span><br><span class="line">        ForkJoinSumCalculator leftTask = <span class="keyword">new</span> ForkJoinSumCalculator(numbers,start,start + length/<span class="number">2</span>);</span><br><span class="line">        <span class="comment">//利用另一个ForkJoinPool线程异步执行新创建的子任务</span></span><br><span class="line">        leftTask.fork();</span><br><span class="line">        <span class="comment">//创建一个子任务为数组的后一半求和</span></span><br><span class="line">        ForkJoinSumCalculator rightTask = <span class="keyword">new</span> ForkJoinSumCalculator(numbers,start + length/<span class="number">2</span>,end);</span><br><span class="line">        <span class="comment">//同步执行第二个子任务，有可能允许进一步递归划分</span></span><br><span class="line">        Long rightResult = rightTask.compute();</span><br><span class="line">        <span class="comment">//读取第一个子任务的结果，如果未完成则等待</span></span><br><span class="line">        Long leftResult = leftTask.join();</span><br><span class="line">        <span class="comment">//任务结果为两个子任务结果合并</span></span><br><span class="line">        <span class="keyword">return</span> leftResult + rightResult;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 顺序求和</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> 和</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="function"><span class="keyword">long</span> <span class="title">computeSequentially</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">long</span> sum = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = start;i &lt; end;i++)&#123;</span><br><span class="line">            sum += numbers[i];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> sum;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">ForkJoinSumCalculator</span><span class="params">(<span class="keyword">long</span>[] numbers)</span></span>&#123;<span class="comment">//公共构造器用于创建主任务</span></span><br><span class="line">        <span class="keyword">this</span>(numbers,<span class="number">0</span>,numbers.length);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="title">ForkJoinSumCalculator</span><span class="params">(<span class="keyword">long</span>[] numbers, <span class="keyword">int</span> start, <span class="keyword">int</span> end)</span> </span>&#123;<span class="comment">//私有构造器用于以递归的方式创建子任务</span></span><br><span class="line">        <span class="keyword">this</span>.numbers = numbers;</span><br><span class="line">        <span class="keyword">this</span>.start = start;</span><br><span class="line">        <span class="keyword">this</span>.end = end;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>&emsp;&emsp;然后再通过forkJoinSum方法调用算法进行并行计算。</p><figure class="highlight gradle"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 通过分支合并框架对前n个自然数求和</span></span><br><span class="line"><span class="comment"> * @param n 值</span></span><br><span class="line"><span class="comment"> * @return 和</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">long</span> forkJoinSum(<span class="keyword">long</span> n)&#123;</span><br><span class="line">    <span class="comment">//LongStream生成前n个自然数的数组</span></span><br><span class="line">    <span class="keyword">long</span>[] numbers = LongStream.rangeClosed(<span class="number">1</span>, n).toArray();</span><br><span class="line">    <span class="comment">//根据数组实例化ForkJoinTask</span></span><br><span class="line">    ForkJoinTask&lt;<span class="keyword">Long</span>&gt; <span class="keyword">task</span> = <span class="keyword">new</span> ForkJoinSumCalculator(numbers);</span><br><span class="line">    <span class="comment">//实例化ForkJoinPool并把任务交给其调用方法</span></span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> ForkJoinPool().invoke(<span class="keyword">task</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>&emsp;&emsp;执行结果如下，相比并行流版本要慢一些，因为要把整个数字流都放入一个long[]后才可以在ForkJoinSumCalculator任务中调用数组。实际应用中，使用多个ForkJoinPool没有什么意义，所以一般将其实例静态化成为单例，方便在软件中重用。</p><figure class="highlight lasso"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Fork <span class="keyword">join</span> <span class="keyword">sum</span> done <span class="keyword">in</span> <span class="number">47</span> mscs</span><br></pre></td></tr></table></figure><p>&emsp;&emsp;当把ForkJoinSumCalculator任务传给ForkJoinPool时，这个任务就有池中的一个线程执行，这个线程会调用任务的compute方法。该方法会检查任务十分小到足以顺序执行，如果不够小则会把要求和的数组分成两半，分给两个新的ForkJoinSumCalculator，而它们也由ForkJoinPool安排执行。因此这一过程可以递归重复，把原任务分成更小的任务，直到满足不方便或不可能再进一步拆分的条件。这时顺序计算每个任务的结果，然后由分支过程创建的任务二叉树遍历回到它的根。接下来会合并每个子任务的部分结果，从而得到总任务的结果。这个过程如下图所示。</p><p><img src="https://pic-1258215793.cos.ap-shanghai.myqcloud.com/content/20190901/201909010134.png" alt="分支/合并算法"></p><h4 id="正确使用分支-合并框架"><a href="#正确使用分支-合并框架" class="headerlink" title="正确使用分支/合并框架"></a><strong>正确使用分支/合并框架</strong></h4><blockquote><ul><li><strong>阻塞</strong>：对一个任务调用join方法会阻塞调用者，直到任务执行出结果。所以最好在两个任务的计算都开始后再调用它，否则每个子任务间要相互等待。</li><li><strong>invoke</strong>：不要在RecursiveTask内部使用ForkJoinPool的invoke方法，只有顺序代码才应该由invoke方法启动来进行并行计算，应该始终直接调用compute或fork方法。</li><li><strong>fork</strong>：对子任务调用fork方法可以把它加入ForkJoinPool，但要注意同时对两个子任务调用fork效率会比直接对一个调用compute低。这样可以为一个子任务重用同一线程，从而避免了线程池中多分配一个任务所造成的开销。</li><li><strong>测试</strong>：对分支合并框架的并行计算进行测试会有些麻烦，比如我们常用IDE的栈跟踪来寻找问题，但分支合并计算中调用compute的线程并不是概念上的调用方，后者是调用fork的那个。</li><li><strong>合理使用</strong>：和并行流一样，多核环境使用分支合并框架不一定会比顺序计算快。只有一个任务可以分解成多个独立的子任务，才能使并行化时性能有提升。子任务的运行时间应该大于拆分子任务所消耗的时间。比如将输入输出放到一个子任务，把计算放到另一个子任务，这样就可以同时进行二者。还有分支合并框架需要“预热”或者说执行几遍才会被JIT编译器优化，所以测量性能时要注意多跑几遍。编译器内置的优化可能会给顺序的版本带来一些优势。</li></ul></blockquote><p>&emsp;&emsp;使用分支合并框架，我们需要制定一个策略：决定任务是进一步拆分还是已小到可以顺序求值。</p><h4 id="工作窃取"><a href="#工作窃取" class="headerlink" title="工作窃取"></a><strong>工作窃取</strong></h4><p>&emsp;&emsp;在求和例子中，我们设定求和数组达到1万个项目就不再创建子任务，这个策略比较随意，假设我们有一个1000万项目的数组，那么就需要开辟1000个子任务，而我们的PC可能只有4核。理想的情况下，我们划分的每个子任务都有相同的运行时间，但实际会因为划分策略效率低，或其他不可预知的原因导致子任务间运行差别很大。</p><p>&emsp;&emsp;分支合并框架采用一种叫<strong>工作窃取</strong>的技术来解决这一问题。子任务差不多会被平均分配到ForkJoinPool的所有线程上，每个线程都会为分配的任务保存一个双向链式队列，每完成一个任务就会从队列取出下一个任务执行，所以有些线程会提前完成分配的任务，这时此线程会随机选择一个线程，然后从其队列尾巴上“偷走”一个任务。所以这种模式下，更多的子任务有利于工作线程间平衡负载。</p><p>&emsp;&emsp;工作窃取被用来在线程池中的工作线程间重新分配和平衡任务。闲置线程会不断地尝试窃取别的线程的任务，一个线程中的任务切分为两个子任务时就会被一个闲置线程拿走一个，这个过程可以不断递归，直到规定子任务应顺序执行的条件为真。</p><p><img src="https://pic-1258215793.cos.ap-shanghai.myqcloud.com/content/20190901/201909010135.png" alt="分支/合并框架使用的工作窃取算法"></p><h3 id="9-3-Spliterator"><a href="#9-3-Spliterator" class="headerlink" title="9.3 Spliterator"></a><strong>9.3 Spliterator</strong></h3><p>&emsp;&emsp;我们在使用并行流时并没有指定拆分多个任务的逻辑，所以应该有一种自动机制来帮助我们做了这一工作。<strong>可分迭代器-Spliterator</strong>，和迭代器-Iterator一样都用于遍历数据源中的元素，区别就是Spliterator专门为并行执行而设计。Java 8为集合框架包含的所有数据结构提供了一个默认的Spliterator实现。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Spliterator</span>&lt;<span class="title">T</span>&gt; </span>&#123;<span class="comment">//T是Spliterator遍历元素的类型</span></span><br><span class="line">    <span class="comment">//类似于Iterator，顺序的遍历Spliterator中的元素，如果还有其他元素需要遍历返回true</span></span><br><span class="line">    <span class="function"><span class="keyword">boolean</span> <span class="title">tryAdvance</span><span class="params">(Consumer&lt;? <span class="keyword">super</span> T&gt; action)</span></span>;</span><br><span class="line">    <span class="comment">//可以把一些元素划分给另一个Spliterator，并使其并行处理</span></span><br><span class="line">    <span class="function">Spliterator&lt;T&gt; <span class="title">trySplit</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="comment">//估计还需要遍历的元素个数，未必准确</span></span><br><span class="line">    <span class="function"><span class="keyword">long</span> <span class="title">estimateSize</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="comment">//此迭代器本身特性ID</span></span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">characteristics</span><span class="params">()</span></span>;</span><br><span class="line">    ......</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>&emsp;&emsp;Spliterator还有一个功能是在第一次遍历、第一次拆分或第一次查询估计大小时绑定元素的数据源，而不是在创建时绑定。这样的Spliterator被称为<strong>延迟绑定</strong>的Spliterator。</p><h4 id="拆分过程"><a href="#拆分过程" class="headerlink" title="拆分过程"></a><strong>拆分过程</strong></h4><p>&emsp;&emsp;将Stream拆分为多个部分的算法是一个递归过程。</p><blockquote><ol><li>对一个Spliterator调用trySplit，生成第二个Spliterator</li><li>对这两个Spliterator调用trySplit，就有了四个Spliterator。</li><li>对每一个Spliterator不断地分割，直到trySplit返回null表示数据结构不能再分割了。</li><li>最终所有的Spliterator调用trySplit都返回null，终止。</li></ol></blockquote><p><img src="https://pic-1258215793.cos.ap-shanghai.myqcloud.com/content/20190901/201909010136.png" alt="递归拆分过程"></p><p>&emsp;&emsp;拆分过程受Spliterator的特性的影响，而特性由characteristics方法声明。</p><h4 id="Spliterator的特性"><a href="#Spliterator的特性" class="headerlink" title="Spliterator的特性"></a><strong>Spliterator的特性</strong></h4><table><thead><tr><th style="text-align:left">特性</th><th style="text-align:left">含义</th></tr></thead><tbody><tr><td style="text-align:left">ORDERED</td><td style="text-align:left">元素有既定的顺序(如List)，因此Spliterator在遍历和划分时也会遵守这一顺序</td></tr><tr><td style="text-align:left">DISTINCT</td><td style="text-align:left">对于任意一对遍历过的元素x和y，x.equals(y)返回false</td></tr><tr><td style="text-align:left">SORTED</td><td style="text-align:left">遍历的元素按照一个预定义的顺序排序</td></tr><tr><td style="text-align:left">SIZED</td><td style="text-align:left">该Spliterator由一个已知大小的源建立(如Set)，因此estimatedSize()返回的是准确值</td></tr><tr><td style="text-align:left">NONNULL</td><td style="text-align:left">保证遍历的元素不会为null</td></tr><tr><td style="text-align:left">IMMUTABLE</td><td style="text-align:left">Spliterator的数据源不能修改，意味着遍历时不能添加、删除或修改任何元素</td></tr><tr><td style="text-align:left">CONCURRENT</td><td style="text-align:left">Spliterator的数据源可以被其他线程同时修改而无需同步</td></tr><tr><td style="text-align:left">SUBSIZED</td><td style="text-align:left">Spliterator和所有由它拆分出来的Spliterator都是SIZED</td></tr></tbody></table><h4 id="自定义Spliterator"><a href="#自定义Spliterator" class="headerlink" title="自定义Spliterator"></a><strong>自定义Spliterator</strong></h4><p>&emsp;&emsp;假设需要统计一个字符串的单词数（任意空格为分隔符），我们首先用传统的迭代版本实现。</p><figure class="highlight processing"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 统计字符串中单词个数</span></span><br><span class="line"><span class="comment"> * @param s 字符串</span></span><br><span class="line"><span class="comment"> * @return 单词个数</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="built_in">int</span> countWordsIteratively(<span class="keyword">String</span> s)&#123;</span><br><span class="line">    <span class="built_in">int</span> counter = <span class="number">0</span>;</span><br><span class="line">    <span class="built_in">boolean</span> lastSpace = <span class="keyword">true</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="built_in">char</span> c : s.toCharArray())&#123;<span class="comment">//逐个遍历字符串的所有字符</span></span><br><span class="line">        <span class="keyword">if</span>(Character.isWhitespace(c))&#123;</span><br><span class="line">            lastSpace = <span class="keyword">true</span>;</span><br><span class="line">        &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">if</span>(lastSpace) counter++;<span class="comment">//上个字符是空格，而当前字符不是空格，计数器+1</span></span><br><span class="line">            lastSpace = <span class="keyword">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> counter;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//传统迭代版本</span></span><br><span class="line">    <span class="keyword">final</span> <span class="keyword">String</span> SENTENCE = <span class="string">" Nel   mezzo del cammin  di nostra  vita "</span> +</span><br><span class="line">            <span class="string">"mi  ritrovai in una  selva oscura"</span> +</span><br><span class="line">            <span class="string">" che la  dritta via era   smarrita"</span>;</span><br><span class="line">    System.out.<span class="built_in">println</span>(<span class="string">"Found "</span> + countWordsIteratively(SENTENCE) + <span class="string">" words"</span>);<span class="comment">//Found 19 words</span></span><br></pre></td></tr></table></figure><p>&emsp;&emsp;然后我们尝试用函数式的风格来重写单词计数器，因为归约时必须要保存两个状态，所以只能创建一个WordCounter类来封装状态，每次遍历到一个元素会调用accumulate方法，定义了WordCounter如何更新状态（我们并不做状态修改，而选择了用新的WordCounter来存储新的状态），combine方法合并流的两个子部分的结果。</p><figure class="highlight aspectj"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">WordCounter</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">int</span> counter;<span class="comment">//当前统计数目</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">boolean</span> lastSpace;<span class="comment">//上个字符是否空格</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="function">WordCounter <span class="title">accumulate</span><span class="params">(Character c)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(Character.isWhitespace(c))&#123;<span class="comment">//如果此字符是空格</span></span><br><span class="line">            <span class="comment">//上个字符是空格，返回当前计数器；</span></span><br><span class="line">            <span class="comment">// 上个字符不是空格，返回新的计数器，并标记lastSpace</span></span><br><span class="line">            <span class="keyword">return</span> lastSpace ? <span class="keyword">this</span> : <span class="keyword">new</span> WordCounter(counter, <span class="keyword">true</span>);</span><br><span class="line">        &#125;<span class="keyword">else</span> &#123;<span class="comment">//此字符不是空格</span></span><br><span class="line">            <span class="comment">//上个字符是空格，返回新计数器，统计+1，重置lastSpace；</span></span><br><span class="line">            <span class="comment">// 上个字符不是空格，返回当前计数器</span></span><br><span class="line">            <span class="keyword">return</span> lastSpace ? <span class="keyword">new</span> WordCounter(counter+<span class="number">1</span>, <span class="keyword">false</span>) : <span class="keyword">this</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="function">WordCounter <span class="title">combine</span><span class="params">(WordCounter wordCounter)</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> WordCounter(counter + wordCounter.counter,wordCounter.lastSpace);<span class="comment">//lastSpace不重要</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 通过自定义WordCounter对字符流进行计算</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> stream 流</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> 单词个数</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="function"><span class="keyword">int</span> <span class="title">countWords</span><span class="params">(Stream&lt;Character&gt; stream)</span></span>&#123;</span><br><span class="line">        WordCounter wordCounter = stream.reduce(<span class="keyword">new</span> WordCounter(<span class="number">0</span>,<span class="keyword">true</span>),</span><br><span class="line">                WordCounter::accumulate,</span><br><span class="line">                WordCounter::combine);</span><br><span class="line">        <span class="function"><span class="keyword">return</span> wordCounter.<span class="title">getCounter</span><span class="params">()</span></span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//函数式版本</span></span><br><span class="line">        <span class="comment">//首先把字符串转换为流</span></span><br><span class="line">        Stream&lt;Character&gt; stream = IntStream.range(<span class="number">0</span>,SENTENCE.length()).mapToObj(SENTENCE::charAt);</span><br><span class="line">        <span class="comment">//然后进行归约计算字数</span></span><br><span class="line">        <span class="comment">//保留两个变量状态：当前统计数目，上个字符是否空格</span></span><br><span class="line">        System.out.println(<span class="string">"Found "</span> + countWords(stream) + <span class="string">" words"</span>);<span class="comment">//Found 19 words</span></span><br></pre></td></tr></table></figure><p>&emsp;&emsp;现在我们尝试把WordCounter并行的工作，但结果却不正确，原因就是字符串会在任意位置拆分，所以有些词会被拆分为两个词，所以并行流导致了结果出错。</p><figure class="highlight stata"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Stream&lt;Character&gt; stream1 = IntStream.<span class="keyword">range</span>(0,SENTENCE.<span class="built_in">length</span>()).mapToObj(SENTENCE::charAt);</span><br><span class="line">System.<span class="keyword">out</span>.println(<span class="string">"Found "</span> + countWords(stream1.parallel()) + <span class="string">" words"</span>);<span class="comment">//Found 41 words</span></span><br></pre></td></tr></table></figure><p>&emsp;&emsp;解决这个问题我们需要确保String只在词尾切分，所以要改变流的切分方式，只能自定义Spliterator，让这个迭代器只会在两个词间进行切分。</p><figure class="highlight d"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 单词切分迭代器</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> WordCounterSpliterator implements Spliterator&lt;Character&gt; &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> String <span class="built_in">string</span>;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> currentChar = <span class="number">0</span>;<span class="comment">//当前坐标</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">@Override</span></span><br><span class="line">    <span class="keyword">public</span> boolean tryAdvance(Consumer&lt;? <span class="keyword">super</span> Character&gt; action) &#123;</span><br><span class="line">        action.accept(<span class="built_in">string</span>.charAt(currentChar++));<span class="comment">//处理当前字符串</span></span><br><span class="line">        <span class="keyword">return</span> currentChar &lt; <span class="built_in">string</span>.length();<span class="comment">//若还有字符串要处理，返回true</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">@Override</span></span><br><span class="line">    <span class="keyword">public</span> Spliterator&lt;Character&gt; trySplit() &#123;</span><br><span class="line">        <span class="keyword">int</span> currentSize = <span class="built_in">string</span>.length() - currentChar;</span><br><span class="line">        <span class="keyword">if</span>(currentSize &lt; <span class="number">10</span>)&#123;<span class="comment">//此时切分的已足够小，返回null进行顺序处理</span></span><br><span class="line">            <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//开始试探拆分的位置为当前字符串中间</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> splitPos = currentSize / <span class="number">2</span> + currentChar; splitPos &lt; <span class="built_in">string</span>.length() ; splitPos++)&#123;</span><br><span class="line">            <span class="comment">//让拆分位置前进到下一个空格</span></span><br><span class="line">            <span class="keyword">if</span>(Character.isWhitespace(<span class="built_in">string</span>.charAt(splitPos)))&#123;</span><br><span class="line">                <span class="comment">//创建一个新的WordCounterSpliterator来解析开始到拆分位置的部分</span></span><br><span class="line">                Spliterator&lt;Character&gt; spliterator = <span class="keyword">new</span> WordCounterSpliterator(<span class="built_in">string</span>.substring(currentChar,splitPos));</span><br><span class="line">                <span class="comment">//再把此Spliterator的起始位置设置为拆分位置</span></span><br><span class="line">                currentChar = splitPos;</span><br><span class="line">                <span class="keyword">return</span> spliterator;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="built_in">long</span> estimateSize() &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">string</span>.length() - currentChar;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">int</span> characteristics() &#123;</span><br><span class="line">        <span class="keyword">return</span> ORDERED + SIZED + SUBSIZED + NONNULL + IMMUTABLE;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> WordCounterSpliterator(String <span class="built_in">string</span>) &#123;</span><br><span class="line">        <span class="keyword">this</span>.<span class="built_in">string</span> = <span class="built_in">string</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">        Spliterator&lt;Character&gt; spliterator = <span class="keyword">new</span> WordCounterSpliterator(SENTENCE);</span><br><span class="line">        <span class="comment">//第二个参数为true表示创建并行流</span></span><br><span class="line">        Stream&lt;Character&gt; stream2 = StreamSupport.stream(spliterator, <span class="literal">true</span>);</span><br><span class="line">        System.<span class="keyword">out</span>.println(<span class="string">"Found "</span> + countWords(stream2) + <span class="string">" words"</span>);<span class="comment">//Found 19 words</span></span><br></pre></td></tr></table></figure><p>&emsp;&emsp;tryAdvance方法把字符串当前字符传给了Consumer，并使当前坐标+1。Consumer把要处理的字符传给了归约函数accumulate。</p><p>&emsp;&emsp;trySplit方法设定了下限10，然后把试探的拆分位置设在当前字符串中间，然后找到空格就创建一个新的Spliterator来遍历从当前位置到拆分位置的子串；把当前位置设置为拆分位置，因为之前的部分将由新的Spliterator处理。</p><hr><p><em>参考博客和文章书籍等：</em></p><blockquote><p>《Java8实战》</p></blockquote><p><em>因博客主等未标明不可引用，若部分内容涉及侵权请及时告知，我会尽快修改和删除相关内容</em></p>]]></content>
    
    <summary type="html">
    
      介绍Java 8中加入的流——第四节，内容包括：并行流，分支/合并框架(RecursiveTask、正确使用、工作窃取)，Spliterator(拆分过程、特性、自定义Spliterator)。
    
    </summary>
    
      <category term="技术文档" scheme="http://linyishui.top/categories/%E6%8A%80%E6%9C%AF%E6%96%87%E6%A1%A3/"/>
    
    
      <category term="java" scheme="http://linyishui.top/tags/java/"/>
    
      <category term="stream" scheme="http://linyishui.top/tags/stream/"/>
    
      <category term="spliterator" scheme="http://linyishui.top/tags/spliterator/"/>
    
  </entry>
  
  <entry>
    <title>流（三）收集器</title>
    <link href="http://linyishui.top/2019092401.html"/>
    <id>http://linyishui.top/2019092401.html</id>
    <published>2019-09-24T10:38:07.000Z</published>
    <updated>2019-12-05T03:57:55.549Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="流（三）收集器"><a href="#流（三）收集器" class="headerlink" title="流（三）收集器"></a><strong>流（三）收集器</strong></h1><h2 id="第八节-用流收集数据"><a href="#第八节-用流收集数据" class="headerlink" title="第八节 用流收集数据"></a><strong>第八节 用流收集数据</strong></h2><h3 id="8-1-收集器"><a href="#8-1-收集器" class="headerlink" title="8.1 收集器"></a><strong>8.1 收集器</strong></h3><p>&emsp;&emsp;收集器简洁灵活的定义了collect用来生成结果集合的标准，collect操作本质是一个归约操作，遍历流中的每个元素，进行转换操作，将结果累积到一个数据结构中并最终输出。</p><figure class="highlight tp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&lt;<span class="keyword">R</span>, A&gt; <span class="keyword">R</span> collect(Collector&lt;? super T, A, <span class="keyword">R</span>&gt; collector);</span><br><span class="line"></span><br><span class="line">&lt;<span class="keyword">R</span>&gt; <span class="keyword">R</span> collect(Supplier&lt;<span class="keyword">R</span>&gt; supplier,</span><br><span class="line">              BiConsumer&lt;<span class="keyword">R</span>, ? super T&gt; accumulator,</span><br><span class="line">              BiConsumer&lt;<span class="keyword">R</span>, <span class="keyword">R</span>&gt; combiner);</span><br></pre></td></tr></table></figure><p>&emsp;&emsp;Collector接口的实现决定了如何对流进行归约操作，Collectors提供了许多常用的静态工厂方法，主要提供了三个功能：将流元素归约为一个值，元素分组，元素分区。</p><h3 id="8-2-归约和汇总"><a href="#8-2-归约和汇总" class="headerlink" title="8.2 归约和汇总"></a><strong>8.2 归约和汇总</strong></h3><p>&emsp;&emsp;具体使用场景可以参考以下实例代码。</p><figure class="highlight gradle"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//统计：统计菜单有多少道菜肴</span></span><br><span class="line"><span class="keyword">long</span> dishedNum = menu.stream().<span class="keyword">collect</span>(Collectors.counting());</span><br><span class="line"><span class="keyword">long</span> dishedNum1 = menu.stream().<span class="keyword">count</span>();</span><br><span class="line"></span><br><span class="line"><span class="comment">//求最大/最小值：找出热量最高的菜肴</span></span><br><span class="line">Comparator&lt;Dish&gt; dishCaloriesComparator = Comparator.comparingInt(Dish::getCalories);</span><br><span class="line">Optional&lt;Dish&gt; mostCaloriesDish = menu.stream().<span class="keyword">collect</span>(Collectors.maxBy(dishCaloriesComparator));</span><br><span class="line">Optional&lt;Dish&gt; mostCaloriesDish1 = menu.stream().max(dishCaloriesComparator);</span><br><span class="line"></span><br><span class="line"><span class="comment">//汇总求和：求所有菜肴总热量</span></span><br><span class="line"><span class="keyword">int</span> totalCalories = menu.stream().<span class="keyword">collect</span>(Collectors.summingInt(Dish::getCalories));</span><br><span class="line"><span class="comment">////这种写法最简洁，且性能最好，避免了自动拆箱</span></span><br><span class="line"><span class="keyword">int</span> totalCalories1 = menu.stream().mapToInt(Dish::getCalories).sum();</span><br><span class="line">    </span><br><span class="line"><span class="comment">//汇总求平均：求所有菜肴热量平均值</span></span><br><span class="line"><span class="keyword">double</span> averageCalories = menu.stream().<span class="keyword">collect</span>(Collectors.averagingInt(Dish::getCalories));</span><br><span class="line"></span><br><span class="line"><span class="comment">//一次遍历求所有汇总结果</span></span><br><span class="line">IntSummaryStatistics statistics = menu.stream().<span class="keyword">collect</span>(Collectors.summarizingInt(Dish::getCalories));</span><br><span class="line">System.out.<span class="keyword">println</span>(statistics);<span class="comment">//IntSummaryStatistics&#123;count=9, sum=4200, min=120, average=466.666667, max=800&#125;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//连接字符串</span></span><br><span class="line">String shortMenu = menu.stream().map(Dish::getName).<span class="keyword">collect</span>(Collectors.joining());</span><br><span class="line">System.out.<span class="keyword">println</span>(shortMenu);<span class="comment">//porkbeefchickenfrench friesriceseason fruitpizzaprawnssalmon</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//加分隔符</span></span><br><span class="line">String shortMenu1 = menu.stream().map(Dish::getName).<span class="keyword">collect</span>(Collectors.joining(<span class="string">", "</span>));</span><br><span class="line">System.out.<span class="keyword">println</span>(shortMenu1);<span class="comment">//pork, beef, chicken, french fries, rice, season fruit, pizza, prawns, salmon</span></span><br></pre></td></tr></table></figure><p>&emsp;&emsp;下图为summingInt收集器的累积过程。</p><p><img src="https://pic-1258215793.cos.ap-shanghai.myqcloud.com/content/20190901/201909010126.png" alt="summingInt收集器的累积过程"></p><p>&emsp;&emsp;前面都是常用情况的便捷工具，Collectors提供的reducing()则需要三个参数(初始值，转换函数，操作)。有一个重载的单参数reducing()，流中第一个元素作为起点，转换函数为默认输入参数。</p><figure class="highlight livescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">int totalCalories3 = menu.stream<span class="function"><span class="params">()</span>.<span class="title">collect</span><span class="params">(Collectors.reducing(<span class="number">0</span>,Dish::getCalories,(i,j) -&gt; i + j))</span>;</span></span><br><span class="line"><span class="function"><span class="title">int</span> <span class="title">totalCalories4</span> = <span class="title">menu</span>.<span class="title">stream</span><span class="params">()</span>.<span class="title">map</span><span class="params">(Dish::getCalories)</span>.<span class="title">reduce</span><span class="params">(<span class="number">0</span>,(i,j) -&gt; i + j)</span>;</span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function">//单参数<span class="title">reducing</span><span class="params">()</span>，</span></span><br><span class="line"><span class="function"><span class="title">Optional</span>&lt;<span class="title">Dish</span>&gt; <span class="title">mostCaloriesDish2</span> = <span class="title">menu</span>.<span class="title">stream</span><span class="params">()</span></span></span><br><span class="line"><span class="function">        .<span class="title">collect</span><span class="params">(Collectors.reducing(</span></span></span><br><span class="line"><span class="function"><span class="params">                (d1,d2) -&gt; d1.getCalories() &gt; d2.getCalories() ? d1 :d2))</span>;</span></span><br></pre></td></tr></table></figure><p>&emsp;&emsp;下图为totalCalories3计算菜单总热量的归约过程。</p><p><img src="https://pic-1258215793.cos.ap-shanghai.myqcloud.com/content/20190901/201909010127.png" alt="计算菜单总热量的归约过程"></p><figure class="highlight aspectj"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> &lt;T, U&gt;</span><br><span class="line">Collector&lt;T, ?, U&gt; reducing(U identity,</span><br><span class="line">                            Function&lt;? <span class="keyword">super</span> T, ? <span class="keyword">extends</span> U&gt; mapper,</span><br><span class="line">                            BinaryOperator&lt;U&gt; op) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> CollectorImpl&lt;&gt;(</span><br><span class="line">            boxSupplier(identity),</span><br><span class="line">            (a, t) -&gt; &#123; a[<span class="number">0</span>] = op.apply(a[<span class="number">0</span>], mapper.apply(t)); &#125;,</span><br><span class="line">            (a, b) -&gt; &#123; a[<span class="number">0</span>] = op.apply(a[<span class="number">0</span>], b[<span class="number">0</span>]); <span class="keyword">return</span> a; &#125;,</span><br><span class="line">            a -&gt; a[<span class="number">0</span>], CH_NOID);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//单参数</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> &lt;T&gt; Collector&lt;T, ?, Optional&lt;T&gt;&gt;</span><br><span class="line">reducing(BinaryOperator&lt;T&gt; op) &#123;</span><br><span class="line">    <span class="class"><span class="keyword">class</span> <span class="title">OptionalBox</span> <span class="keyword">implements</span> <span class="title">Consumer</span>&lt;<span class="title">T</span>&gt; </span>&#123;</span><br><span class="line">        T value = <span class="keyword">null</span>;</span><br><span class="line">        <span class="keyword">boolean</span> present = <span class="keyword">false</span>;</span><br><span class="line"></span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="keyword">public</span> <span class="function"><span class="keyword">void</span> <span class="title">accept</span><span class="params">(T t)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">if</span> (present) &#123;</span><br><span class="line">                value = op.apply(value, t);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> &#123;</span><br><span class="line">                value = t;</span><br><span class="line">                present = <span class="keyword">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> CollectorImpl&lt;T, OptionalBox, Optional&lt;T&gt;&gt;(</span><br><span class="line">            OptionalBox::<span class="keyword">new</span>, OptionalBox::accept,</span><br><span class="line">            (a, b) -&gt; &#123; <span class="keyword">if</span> (b.present) a.accept(b.value); <span class="keyword">return</span> a; &#125;,</span><br><span class="line">            a -&gt; Optional.ofNullable(a.value), CH_NOID);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="collect和reduce的区别"><a href="#collect和reduce的区别" class="headerlink" title="collect和reduce的区别"></a><strong>collect和reduce的区别</strong></h4><p>&emsp;&emsp;二者往往可以实现相同的功能，reduce方法旨在把两个值结合起来生成一个新值，是一个不可变的归约。collect方法则相反，设计上就是要改变容器，从而累积要输出的结果。还有一点就是collect方法相比reduce更适合并行工作。</p><h3 id="8-3-分组"><a href="#8-3-分组" class="headerlink" title="8.3 分组"></a><strong>8.3 分组</strong></h3><p>&emsp;&emsp;Collectors提供了静态工厂方法groupingBy，参数Function叫<strong>分类函数</strong>，用来把流中元素分成不同的组。</p><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">Map</span>&lt;Dish.<span class="built_in">Type</span>, <span class="built_in">List</span>&lt;Dish&gt;&gt; dishesByType = menu.stream().collect(Collectors.groupingBy(Dish::getType));</span><br><span class="line">dishesByType.forEach((k,v) -&gt; System.out.println(k + <span class="string">"-&gt;"</span> + v));</span><br><span class="line"></span><br><span class="line"><span class="comment">//groupingBy</span></span><br><span class="line">public <span class="keyword">static</span> &lt;T, K&gt; Collector&lt;T, ?, <span class="built_in">Map</span>&lt;K, <span class="built_in">List</span>&lt;T&gt;&gt;&gt;</span><br><span class="line">groupingBy(<span class="built_in">Function</span>&lt;? <span class="keyword">super</span> T, ? <span class="keyword">extends</span> K&gt; classifier) &#123;</span><br><span class="line">    <span class="keyword">return</span> groupingBy(classifier, toList());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="https://pic-1258215793.cos.ap-shanghai.myqcloud.com/content/20190901/201909010128.png" alt="在分组的过程中对流中的项目进行分类"></p><p>&emsp;&emsp;实际开发中，用来分类的Type可能不存在，但我们可以<strong>自定义</strong>，并用Lambda表达式来描述逻辑。</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//以热量分组</span></span><br><span class="line">Map&lt;CaloricLevel,List&lt;Dish&gt;&gt; dishesByCaloricLevel = menu.stream().collect(Collectors.groupingBy(</span><br><span class="line">    dish -&gt; &#123;</span><br><span class="line">        <span class="keyword">if</span>(dish.getCalories() &lt;= <span class="number">400</span>) <span class="keyword">return</span> CaloricLevel.DIET;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(dish.getCalories() &lt;= <span class="number">700</span>) <span class="keyword">return</span> CaloricLevel.NORMAL;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">return</span> CaloricLevel.FAT;</span><br><span class="line">    &#125;</span><br><span class="line">));</span><br><span class="line">dishesByCaloricLevel.forEach((k,v) -&gt; System.<span class="keyword">out</span>.println(k + <span class="string">"-&gt;"</span> + v));</span><br></pre></td></tr></table></figure><p>&emsp;&emsp;<strong>多级分组</strong>需要调用双参数版本的groupingBy方法，可以扩展至任意层级的树形结构Map。</p><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//多级分组</span></span><br><span class="line"><span class="built_in">Map</span>&lt;Dish.<span class="built_in">Type</span>, <span class="built_in">Map</span>&lt;CaloricLevel, <span class="built_in">List</span>&lt;Dish&gt;&gt;&gt; dishesByTypeCaloricLevel =</span><br><span class="line">        menu.stream().collect(</span><br><span class="line">                Collectors.groupingBy(Dish::getType,</span><br><span class="line">                        Collectors.groupingBy(dish -&gt;&#123;</span><br><span class="line">                            <span class="keyword">if</span>(dish.getCalories() &lt;= <span class="number">400</span>) <span class="keyword">return</span> CaloricLevel.DIET;</span><br><span class="line">                            <span class="keyword">else</span> <span class="keyword">if</span>(dish.getCalories() &lt;= <span class="number">700</span>) <span class="keyword">return</span> CaloricLevel.NORMAL;</span><br><span class="line">                            <span class="keyword">else</span> <span class="keyword">return</span> CaloricLevel.FAT;</span><br><span class="line">                        &#125;))</span><br><span class="line">        );</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">public <span class="keyword">static</span> &lt;T, K, A, D&gt;</span><br><span class="line">Collector&lt;T, ?, <span class="built_in">Map</span>&lt;K, D&gt;&gt; groupingBy(<span class="built_in">Function</span>&lt;? <span class="keyword">super</span> T, ? <span class="keyword">extends</span> K&gt; classifier,</span><br><span class="line">                                      Collector&lt;? <span class="keyword">super</span> T, A, D&gt; downstream) &#123;</span><br><span class="line">    <span class="keyword">return</span> groupingBy(classifier, HashMap::<span class="keyword">new</span>, downstream);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>&emsp;&emsp;下图表示n层嵌套映射和n维分类表间的等价关系。</p><p><img src="https://pic-1258215793.cos.ap-shanghai.myqcloud.com/content/20190901/201909010129.png" alt="n层嵌套映射和n维分类表间的等价关系"></p><p>&emsp;&emsp;<strong>按子组收集数据</strong>: groupingBy方法的第二个参数可以是任意Collector的实现，不一定非要是groupingBy。collectingAndThen方法则可以在收集器完成处理后转换返回类型，需要参数：收集器和转换函数，最后返回一个收集器。</p><figure class="highlight lasso"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//分类汇总求和</span></span><br><span class="line"><span class="built_in">Map</span>&lt;Dish.<span class="keyword">Type</span>, Long&gt; typesCount =</span><br><span class="line">        menu.stream().collect(</span><br><span class="line">                Collectors.groupingBy(Dish<span class="type">::getType</span>,Collectors.counting()));</span><br><span class="line"></span><br><span class="line"><span class="comment">//分类汇总取最大值</span></span><br><span class="line"><span class="built_in">Map</span>&lt;Dish.<span class="keyword">Type</span>, Optional&lt;Dish&gt;&gt; mostCaloricByType =</span><br><span class="line">        menu.stream().collect(</span><br><span class="line">                Collectors.groupingBy(Dish<span class="type">::getType</span>,Collectors.maxBy(Comparator.comparing(Dish<span class="type">::getCalories</span>))));</span><br><span class="line"></span><br><span class="line"><span class="comment">//收集后转换类型</span></span><br><span class="line"><span class="built_in">Map</span>&lt;Dish.<span class="keyword">Type</span>, Dish&gt; mostCaloricByType1 =</span><br><span class="line">        menu.stream().collect(</span><br><span class="line">                Collectors.groupingBy(Dish<span class="type">::getType</span>,Collectors.collectingAndThen(</span><br><span class="line">                        Collectors.maxBy(Comparator.comparing(Dish<span class="type">::getCalories</span>)),Optional<span class="type">::get</span>)));</span><br><span class="line">mostCaloricByType1.forEach((k,v) -&gt; System.out.println(k + <span class="string">"-&gt;"</span> + v));</span><br></pre></td></tr></table></figure><p>&emsp;&emsp;原始流先根据分类函数分为多个子流，每个子流再由第二个收集器进行处理，归约收集器返回取得的最大值Optional<dish>，collectingAndThen收集器返回从Optional<dish>提取的值，最后第二级收集器的结果成为分组映射的值。</dish></dish></p><h3 id="8-4-分区"><a href="#8-4-分区" class="headerlink" title="8.4 分区"></a><strong>8.4 分区</strong></h3><p>&emsp;&emsp;分区是分组的特殊情况，<strong>由一个谓词作为分类函数</strong>，即分区函数。分区函数返回一个布尔值，意味着得到的分组Map的键值为Boolean，所以只能分为两组。</p><figure class="highlight lasso"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">Map</span>&lt;<span class="built_in">Boolean</span>, <span class="built_in">List</span>&lt;Dish&gt;&gt; partitionedMenu = menu.stream().collect(Collectors.partitioningBy(Dish<span class="type">::isVegetarian</span>));</span><br></pre></td></tr></table></figure><p>&emsp;&emsp;分区也可以像分组那样多级组合，可以看作是特殊的使用谓词来做分组函数的分组。</p><h3 id="8-5-收集器接口"><a href="#8-5-收集器接口" class="headerlink" title="8.5 收集器接口"></a><strong>8.5 收集器接口</strong></h3><p>&emsp;&emsp;Collector接口为实现具体的归约操作（收集器）提供了范本，</p><blockquote><ul><li>T是流中要收集的项目的泛型。</li><li>A是累加器的类型，累加器在收集过程中用于累积部分结果的对象。</li><li>R是收集操作得到的对象类型。</li></ul></blockquote><figure class="highlight dts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br></pre></td><td class="code"><pre><span class="line">public interface Collector<span class="params">&lt;T, A, R&gt;</span> &#123;</span><br><span class="line">    <span class="comment">//创建并返回新的可变结果容器的函数</span></span><br><span class="line">    Supplier<span class="params">&lt;A&gt;</span> supplier();</span><br><span class="line"></span><br><span class="line">    <span class="comment">//将值折叠到可变结果容器中的函数</span></span><br><span class="line">    BiConsumer<span class="params">&lt;A, T&gt;</span> accumulator();</span><br><span class="line"></span><br><span class="line">    <span class="comment">//接受两个部分结果并将其合并的函数。</span></span><br><span class="line">    <span class="comment">//组合器函数可以将状态从一个参数折叠到另一个参数并返回该参数，或者返回一个新的结果容器。</span></span><br><span class="line">    BinaryOperator<span class="params">&lt;A&gt;</span> combiner();</span><br><span class="line"></span><br><span class="line">    <span class="comment">//执行从中间累积类型A到最终结果类型R的最终转换</span></span><br><span class="line">    Function<span class="params">&lt;A, R&gt;</span> finisher();</span><br><span class="line"></span><br><span class="line">    <span class="comment">//返回Collector.Characteristics的Set，指示此收集器的特征。这个集合应该是不可变的。</span></span><br><span class="line">    Set<span class="params">&lt;Characteristics&gt;</span> characteristics();</span><br><span class="line"></span><br><span class="line">    <span class="comment">//返回由给定的supplier、accumulator和combiner函数描述的新Collector。生成的Collector具有Collector.Characteristics.IDENTITY_FINISH特征。</span></span><br><span class="line">    public static<span class="params">&lt;T, R&gt;</span> Collector<span class="params">&lt;T, R, R&gt;</span> of(Supplier<span class="params">&lt;R&gt;</span> supplier,</span><br><span class="line">                                              BiConsumer<span class="params">&lt;R, T&gt;</span> accumulator,</span><br><span class="line">                                              BinaryOperator<span class="params">&lt;R&gt;</span> combiner,</span><br><span class="line">                                              Characteristics... characteristics) &#123;</span><br><span class="line">        Objects.requireNonNull(supplier);</span><br><span class="line">        Objects.requireNonNull(accumulator);</span><br><span class="line">        Objects.requireNonNull(combiner);</span><br><span class="line">        Objects.requireNonNull(characteristics);</span><br><span class="line">        Set<span class="params">&lt;Characteristics&gt;</span> cs = (characteristics.length == <span class="number">0</span>)</span><br><span class="line">                                  ? Collectors.CH_ID</span><br><span class="line">                                  : Collections.unmodifiableSet(EnumSet.of(Collector.Characteristics.IDENTITY_FINISH,</span><br><span class="line">                                                                           characteristics));</span><br><span class="line">        return new Collectors.CollectorImpl<span class="params">&lt;&gt;</span>(supplier, accumulator, combiner, cs);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//返回由给定的supplier、accumulator、combiner和finisher函数描述的新Collector。</span></span><br><span class="line">    public static<span class="params">&lt;T, A, R&gt;</span> Collector<span class="params">&lt;T, A, R&gt;</span> of(Supplier<span class="params">&lt;A&gt;</span> supplier,</span><br><span class="line">                                                 BiConsumer<span class="params">&lt;A, T&gt;</span> accumulator,</span><br><span class="line">                                                 BinaryOperator<span class="params">&lt;A&gt;</span> combiner,</span><br><span class="line">                                                 Function<span class="params">&lt;A, R&gt;</span> finisher,</span><br><span class="line">                                                 Characteristics... characteristics) &#123;</span><br><span class="line">        Objects.requireNonNull(supplier);</span><br><span class="line">        Objects.requireNonNull(accumulator);</span><br><span class="line">        Objects.requireNonNull(combiner);</span><br><span class="line">        Objects.requireNonNull(finisher);</span><br><span class="line">        Objects.requireNonNull(characteristics);</span><br><span class="line">        Set<span class="params">&lt;Characteristics&gt;</span> cs = Collectors.CH_NOID;</span><br><span class="line">        if (characteristics.length &gt; <span class="number">0</span>) &#123;</span><br><span class="line">            cs = EnumSet.noneOf(Characteristics.class);</span><br><span class="line">            Collections.addAll(cs, characteristics);</span><br><span class="line">            cs = Collections.unmodifiableSet(cs);</span><br><span class="line">        &#125;</span><br><span class="line">        return new Collectors.CollectorImpl<span class="params">&lt;&gt;</span>(supplier, accumulator, combiner, finisher, cs);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//表示Collector属性的特性，可用于优化缩减实现。</span></span><br><span class="line">    enum <span class="class">Characteristics </span>&#123;</span><br><span class="line">        <span class="comment">//指示此收集器是并发的，这意味着结果容器可以支持与来自多个线程的同一结果容器同时调用的累加器函数。</span></span><br><span class="line">        <span class="comment">//如果CONCURRENT收集器也不是UNORDERED，则仅当应用于无序数据源时，才应并发计算该收集器。</span></span><br><span class="line">        CONCURRENT,</span><br><span class="line"></span><br><span class="line">        <span class="comment">//指示集合操作不承诺保留输入元素的相遇顺序。（如果结果容器没有内在顺序，例如Set，则可能是这样的。）</span></span><br><span class="line">        UNORDERED,</span><br><span class="line"></span><br><span class="line">        <span class="comment">//表示分页装订器函数是标识函数，可以省略。如果设置了，则从A到R的未检查强制转换必须成功。</span></span><br><span class="line">        IDENTITY_FINISH</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="8-5-1-supplier"><a href="#8-5-1-supplier" class="headerlink" title="8.5.1 supplier"></a><strong>8.5.1 supplier</strong></h4><p>&emsp;&emsp;supplier方法返回一个结果为空的Supplier<a>，也就是一个无参数函数，被调用时会创建一个空的累加器实例，供数据收集过程使用。对于把累加器本身作为结果返回的收集器（如toList），在对空流操作时，这个空的累加器也代表着收集过程的结果。</a></p><h4 id="8-5-2-accumulator"><a href="#8-5-2-accumulator" class="headerlink" title="8.5.2 accumulator"></a><strong>8.5.2 accumulator</strong></h4><p>&emsp;&emsp;accumulator方法会返回执行归约操作的函数。当遍历到流的第n个元素时，此函数执行时会有两个参数：保存归约结果的累加器，和第n个元素。此函数会返回void，因为累加器是原位更新，即函数的执行改变了它的内部状态</p><h4 id="8-5-3-finisher"><a href="#8-5-3-finisher" class="headerlink" title="8.5.3 finisher"></a><strong>8.5.3 finisher</strong></h4><p>&emsp;&emsp;在遍历完流后，finisher方法返回在累积过程的最后要调用的一个函数，以便将累加器对象转换为整个集合操作的最终结果。</p><p>&emsp;&emsp;这三个方法已足够对流进行顺序归约，下图为顺序归约过程的逻辑步骤。</p><p><img src="https://pic-1258215793.cos.ap-shanghai.myqcloud.com/content/20190901/201909010130.png" alt="顺序归约过程的逻辑步骤"></p><h4 id="8-5-4-combiner"><a href="#8-5-4-combiner" class="headerlink" title="8.5.4 combiner"></a><strong>8.5.4 combiner</strong></h4><p>&emsp;&emsp;combiner方法会返回一个供归约操作使用的函数，它定义了对流的各个子部分进行并行处理时，各个子部分归约所得到的累加器要如何进行合并。</p><p>&emsp;&emsp;有了此方法就可以对流进行并行归约了，过程要用到分支/合并框架和Spliterator抽象。</p><blockquote><ul><li>原始流会以递归的方式拆分为子流，直到定义流是否需要进一步拆分的一个条件为非。</li><li>所以子流都可以并行处理，每个子流都可以进行顺序归约算法。</li><li>使用收集器combiner返回的函数，将所有部分结果两两合并。</li></ul></blockquote><p>&emsp;&emsp;下图为使用combiner方法来并行化归约过程。</p><p><img src="https://pic-1258215793.cos.ap-shanghai.myqcloud.com/content/20190901/201909010131.png" alt="使用combiner方法来并行化归约过程"></p><h4 id="8-5-5-characteristics"><a href="#8-5-5-characteristics" class="headerlink" title="8.5.5 characteristics"></a><strong>8.5.5 characteristics</strong></h4><p>&emsp;&emsp;characteristics会返回一个不可变的Characteristics集合，它定义了收集器的行为——尤其是关于流是否可以进行并行归约，以及可以使用哪些优化的提示。</p><blockquote><p>枚举类Characteristics包含三个项目</p><ul><li>UNORDERED：归约结果不受流中项目的遍历和累积顺序的影响。</li><li>CONCURRENT：accumulator函数可以从多个线程同时调用，且该收集器可以进行并行归约流。如果收集器没有标注UNORDERED，则仅当应用于无序数据源时才应并发归约。</li><li>IDENTITY_FINISH：表明完成器方法返回的函数是一个恒等函数，可以跳过。这种情况下，累加器对象会直接用作归约过程的最终结果。也意味着将累加器A不加检查的转换为结果R是安全的。</li></ul></blockquote><h4 id="8-5-6-融合实现ToListCollector"><a href="#8-5-6-融合实现ToListCollector" class="headerlink" title="8.5.6 融合实现ToListCollector"></a><strong>8.5.6 融合实现ToListCollector</strong></h4><figure class="highlight ruby"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">public <span class="class"><span class="keyword">class</span> <span class="title">ToListCollector</span>&lt;T&gt; <span class="title">implements</span> <span class="title">Collector</span>&lt;T, <span class="title">List</span>&lt;T&gt;, <span class="title">List</span>&lt;T&gt;&gt; &#123;</span></span><br><span class="line">    @Override</span><br><span class="line">    public Supplier&lt;List&lt;T<span class="meta">&gt;&gt; </span>supplier() &#123;<span class="regexp">//</span>创建集合操作的起始点</span><br><span class="line">        <span class="keyword">return</span> ArrayList::new;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public BiConsumer&lt;List&lt;T&gt;, T&gt; accumulator() &#123;<span class="regexp">//</span>累积遍历过的项目，原位修改累加器</span><br><span class="line">        <span class="keyword">return</span> List::add;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public Function&lt;List&lt;T&gt;, List&lt;T<span class="meta">&gt;&gt; </span>finisher() &#123;<span class="regexp">//</span>恒等函数</span><br><span class="line">        <span class="keyword">return</span> Function.identity();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public BinaryOperator&lt;List&lt;T<span class="meta">&gt;&gt; </span>combiner() &#123;<span class="regexp">//</span>修改第一个累加器，将其和第二个累加器内容合并</span><br><span class="line">        <span class="keyword">return</span> (list1, list2) -&gt; &#123;</span><br><span class="line">            list1.addAll(list2);</span><br><span class="line">            <span class="keyword">return</span> list1;</span><br><span class="line">        &#125;;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public Set&lt;Characteristics&gt; characteristics() &#123;<span class="regexp">//</span>累加器不是UNORDERED的，因为我们想保留顺序</span><br><span class="line">        <span class="keyword">return</span> Collections.unmodifiableSet(EnumSet.of(Characteristics.IDENTITY_FINISH,Characteristics.CONCURRENT));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>&emsp;&emsp;我们实现的这个收集器和Collectors.toList()区别只是在一些优化上。collect()有一个三参数的重载方法(supplier,accumulator,combiner)，</p><figure class="highlight lasso"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">List</span>&lt;Dish&gt; dishes = menu.stream().collect(Collectors.toList());</span><br><span class="line"><span class="comment">//toList是一个工厂方法由单例生成，ToListCollector则需要实例化</span></span><br><span class="line"><span class="built_in">List</span>&lt;Dish&gt; dishes1 = menu.stream().collect(<span class="literal">new</span> ToListCollector&lt;&gt;());</span><br><span class="line"><span class="comment">//简单但不易读，且收集器永远是IDENTITY_FINISH+CONCURRENT且非UNORDERED的</span></span><br><span class="line"><span class="built_in">List</span>&lt;Dish&gt; dishes2 = menu.stream().collect(ArrayList<span class="type">::new</span>, <span class="built_in">List</span><span class="type">::add</span>,<span class="built_in">List</span><span class="type">::addAll</span>);</span><br></pre></td></tr></table></figure><h3 id="8-6-实现收集器"><a href="#8-6-实现收集器" class="headerlink" title="8.6 实现收集器"></a><strong>8.6 实现收集器</strong></h3><figure class="highlight zephir"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">Map&lt;<span class="keyword">Boolean</span>, <span class="keyword">List</span>&lt;Integer&gt;&gt; primes = partitionPrimes(<span class="number">5</span>);</span><br><span class="line">primes.<span class="keyword">forEach</span>((k,v) -&gt; System.out.println(k + <span class="string">"-&gt;"</span> + v));</span><br><span class="line"><span class="comment">//false-&gt;[4]</span></span><br><span class="line"><span class="comment">//true-&gt;[2, 3, 5]</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> Map&lt;<span class="keyword">Boolean</span>, <span class="keyword">List</span>&lt;Integer&gt;&gt; partitionPrimes(<span class="keyword">int</span> n)&#123;</span><br><span class="line">    <span class="keyword">return</span> IntStream.rangeClosed(<span class="number">2</span>, n).boxed().collect(Collectors.partitioningBy(candidate -&gt; isPrime(candidate)));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">boolean</span> isPrime(<span class="keyword">int</span> candidate)&#123;</span><br><span class="line">    <span class="keyword">int</span> candidateRoot = (<span class="keyword">int</span>) Math.sqrt((<span class="keyword">double</span>) candidate);</span><br><span class="line">    <span class="keyword">return</span> IntStream.rangeClosed(<span class="number">2</span>, candidateRoot).noneMatch(i -&gt; candidate % i == <span class="number">0</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>&emsp;&emsp;若除数本身不是质数则无需测试，只需要用被测试数之前的质数来测试，但我们所使用的收集器在收集过程无法访问部分结果，也就是我们无法访问已经找到的质数列表。</p><figure class="highlight aspectj"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="function"><span class="keyword">boolean</span> <span class="title">isPrime</span><span class="params">(List&lt;Integer&gt; primes, <span class="keyword">int</span> candidate)</span></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> primes.stream().noneMatch(i -&gt; candidate % i == <span class="number">0</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>&emsp;&emsp;我们需要筛选已找到的质数中小于被测数的，通过filter只能对整个流进行筛选，如果流很大会造成问题，我们只要在质数大于被测数平方根的时候停下就行了。因此实现如下takeWhile方法。</p><figure class="highlight zephir"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">boolean</span> isPrime(<span class="keyword">List</span>&lt;Integer&gt; primes, <span class="keyword">int</span> candidate)&#123;</span><br><span class="line">    <span class="keyword">int</span> candidateRoot = (<span class="keyword">int</span>) Math.sqrt((<span class="keyword">double</span>) candidate);</span><br><span class="line">    <span class="keyword">return</span> takeWhile(primes, i -&gt; i &lt;= candidateRoot).stream().noneMatch(i -&gt; candidate % i == <span class="number">0</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> &lt;A&gt; <span class="keyword">List</span>&lt;A&gt; takeWhile(<span class="keyword">List</span>&lt;A&gt; <span class="keyword">list</span>, Predicate&lt;A&gt; p)&#123;<span class="comment">//给定一个排序集合和一个谓词，返回元素满足谓词的最长前缀</span></span><br><span class="line">    <span class="keyword">int</span> i = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(A item : <span class="keyword">list</span>)&#123;</span><br><span class="line">        <span class="keyword">if</span>(!p.test(item))&#123;<span class="comment">//检查列表中的当前项目是否符合谓词</span></span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">list</span>.subList(<span class="number">0</span>, i);<span class="comment">//不满足就返回该项目之前的前缀子列表</span></span><br><span class="line">        &#125;</span><br><span class="line">        i++;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">list</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>&emsp;&emsp;takeWhile方法是及时的，但我们需要一个延迟求值的方法来与noneMatch合并，需要熟悉Stream API的实现原理才可以实现。有了算法我们可以手动实现一个收集器了，代码如下。</p><figure class="highlight lasso"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> class PrimeNumbersCollector implements Collector&lt;<span class="built_in">Integer</span>,</span><br><span class="line">                                                        <span class="built_in">Map</span>&lt;<span class="built_in">Boolean</span>, <span class="built_in">List</span>&lt;<span class="built_in">Integer</span>&gt;&gt;,</span><br><span class="line">                                                        <span class="built_in">Map</span>&lt;<span class="built_in">Boolean</span>, <span class="built_in">List</span>&lt;<span class="built_in">Integer</span>&gt;&gt;&gt; &#123;</span><br><span class="line">    @Override</span><br><span class="line">    <span class="keyword">public</span> Supplier&lt;<span class="built_in">Map</span>&lt;<span class="built_in">Boolean</span>, <span class="built_in">List</span>&lt;<span class="built_in">Integer</span>&gt;&gt;&gt; supplier() &#123;</span><br><span class="line">        <span class="comment">//创建了作为累加器的map，并为true和false键初始化了空列表。</span></span><br><span class="line">        <span class="keyword">return</span> () -&gt; <span class="literal">new</span> HashMap&lt;<span class="built_in">Boolean</span>, <span class="built_in">List</span>&lt;<span class="built_in">Integer</span>&gt;&gt;()&#123;</span><br><span class="line">            &#123;</span><br><span class="line">                put(<span class="literal">true</span>,<span class="literal">new</span> ArrayList&lt;&gt;());</span><br><span class="line">                put(<span class="literal">false</span>,<span class="literal">new</span> ArrayList&lt;&gt;());</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    <span class="keyword">public</span> BiConsumer&lt;<span class="built_in">Map</span>&lt;<span class="built_in">Boolean</span>, <span class="built_in">List</span>&lt;<span class="built_in">Integer</span>&gt;&gt;, <span class="built_in">Integer</span>&gt; accumulator() &#123;</span><br><span class="line">        <span class="keyword">return</span> (<span class="built_in">Map</span>&lt;<span class="built_in">Boolean</span>, <span class="built_in">List</span>&lt;<span class="built_in">Integer</span>&gt;&gt; acc, <span class="built_in">Integer</span> candidate) -&gt; &#123;</span><br><span class="line">            acc.get(isPrime(acc.get(<span class="literal">true</span>),candidate)) <span class="comment">//根据isPrime结果获取质数或非质数列表</span></span><br><span class="line">                    .add(candidate); <span class="comment">//将被测数添加到相应列表</span></span><br><span class="line">        &#125;;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    <span class="keyword">public</span> BinaryOperator&lt;<span class="built_in">Map</span>&lt;<span class="built_in">Boolean</span>, <span class="built_in">List</span>&lt;<span class="built_in">Integer</span>&gt;&gt;&gt; combiner() &#123;</span><br><span class="line">        <span class="comment">//此收集器是无法并行运算的，因为算法本身是顺序的，所以当前combiner()无法被调用</span></span><br><span class="line">        <span class="keyword">return</span> (<span class="built_in">Map</span>&lt;<span class="built_in">Boolean</span>, <span class="built_in">List</span>&lt;<span class="built_in">Integer</span>&gt;&gt; map1, <span class="built_in">Map</span>&lt;<span class="built_in">Boolean</span>, <span class="built_in">List</span>&lt;<span class="built_in">Integer</span>&gt;&gt; map2) -&gt; &#123;</span><br><span class="line">            map1.get(<span class="literal">true</span>).addAll(map2.get(<span class="literal">true</span>));</span><br><span class="line">            map1.get(<span class="literal">false</span>).addAll(map2.get(<span class="literal">false</span>));</span><br><span class="line">            <span class="keyword">return</span> map1;</span><br><span class="line">        &#125;;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    <span class="keyword">public</span> Function&lt;<span class="built_in">Map</span>&lt;<span class="built_in">Boolean</span>, <span class="built_in">List</span>&lt;<span class="built_in">Integer</span>&gt;&gt;, <span class="built_in">Map</span>&lt;<span class="built_in">Boolean</span>, <span class="built_in">List</span>&lt;<span class="built_in">Integer</span>&gt;&gt;&gt; finisher() &#123;</span><br><span class="line">        <span class="keyword">return</span> Function.identity();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    <span class="keyword">public</span> <span class="built_in">Set</span>&lt;Characteristics&gt; characteristics() &#123;</span><br><span class="line">        <span class="keyword">return</span> Collections.unmodifiableSet(EnumSet.of(Characteristics.IDENTITY_FINISH));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 判断是否为质数</span></span><br><span class="line"><span class="comment">     * @param primes 已有质数列表</span></span><br><span class="line"><span class="comment">     * @param candidate 当前被测数</span></span><br><span class="line"><span class="comment">     * @return 结果</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="built_in">boolean</span> isPrime(<span class="built_in">List</span>&lt;<span class="built_in">Integer</span>&gt; primes, int candidate)&#123;</span><br><span class="line">        int candidateRoot = (int) Math.sqrt((double) candidate);</span><br><span class="line">        <span class="keyword">return</span> takeWhile(primes, i -&gt; i &lt;= candidateRoot).stream().noneMatch(i -&gt; candidate % i == <span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 查找符合谓词的元素集合</span></span><br><span class="line"><span class="comment">     * @param list 元素列表</span></span><br><span class="line"><span class="comment">     * @param p 谓词</span></span><br><span class="line"><span class="comment">     * @return 符合元素集合</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> &lt;A&gt; <span class="built_in">List</span>&lt;A&gt; takeWhile(<span class="built_in">List</span>&lt;A&gt; <span class="built_in">list</span>, Predicate&lt;A&gt; p)&#123;</span><br><span class="line">        int i = <span class="number">0</span>;</span><br><span class="line">        for(A item : <span class="built_in">list</span>)&#123;</span><br><span class="line">            <span class="keyword">if</span>(!p.test(item))&#123;<span class="comment">//检查列表中的当前项目是否符合谓词</span></span><br><span class="line">                <span class="keyword">return</span> <span class="built_in">list</span>.subList(<span class="number">0</span>, i);<span class="comment">//不满足就返回该项目之前的前缀子列表</span></span><br><span class="line">            &#125;</span><br><span class="line">            i++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">list</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> static <span class="built_in">Map</span>&lt;<span class="built_in">Boolean</span>, <span class="built_in">List</span>&lt;<span class="built_in">Integer</span>&gt;&gt; partitionPrimesWithPrimeNumbersCollector(int n)&#123;</span><br><span class="line">        <span class="keyword">return</span> IntStream.rangeClosed(<span class="number">2</span>, n).boxed().collect(<span class="literal">new</span> PrimeNumbersCollector());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">Map</span>&lt;<span class="built_in">Boolean</span>, <span class="built_in">List</span>&lt;<span class="built_in">Integer</span>&gt;&gt; primes1 = partitionPrimesWithPrimeNumbersCollector(<span class="number">5</span>);</span><br></pre></td></tr></table></figure><p>&emsp;&emsp;可以写一些测试代码对比一下性能提升比例，本机测试如下，大概提升了30%性能。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Fastest execution <span class="keyword">done</span> <span class="keyword">in</span> 626 msecs</span><br><span class="line">Fastest execution <span class="keyword">done</span> <span class="keyword">in</span> 445 msecs</span><br></pre></td></tr></table></figure><hr><p><em>参考博客和文章书籍等：</em></p><blockquote><p>《Java8实战》</p></blockquote><p><em>因博客主等未标明不可引用，若部分内容涉及侵权请及时告知，我会尽快修改和删除相关内容</em></p>]]></content>
    
    <summary type="html">
    
      介绍Java 8中加入的流——第三节，内容包括：收集器，归约和汇总(collect、reduce)，分组，分区，收集器接口(supplier、accumulator、finisher、combiner、characteristics、融合实现ToListCollector)，实现收集器。
    
    </summary>
    
      <category term="技术文档" scheme="http://linyishui.top/categories/%E6%8A%80%E6%9C%AF%E6%96%87%E6%A1%A3/"/>
    
    
      <category term="java" scheme="http://linyishui.top/tags/java/"/>
    
      <category term="stream" scheme="http://linyishui.top/tags/stream/"/>
    
      <category term="collector" scheme="http://linyishui.top/tags/collector/"/>
    
  </entry>
  
  <entry>
    <title>流（二）使用和构建</title>
    <link href="http://linyishui.top/2019092301.html"/>
    <id>http://linyishui.top/2019092301.html</id>
    <published>2019-09-23T10:38:01.000Z</published>
    <updated>2019-12-05T03:41:44.407Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="流（二）使用和构建"><a href="#流（二）使用和构建" class="headerlink" title="流（二）使用和构建"></a><strong>流（二）使用和构建</strong></h1><h2 id="第五节-流的使用"><a href="#第五节-流的使用" class="headerlink" title="第五节 流的使用"></a><strong>第五节 流的使用</strong></h2><h3 id="5-1-筛选和切片"><a href="#5-1-筛选和切片" class="headerlink" title="5.1 筛选和切片"></a><strong>5.1 筛选和切片</strong></h3><p>&emsp;&emsp;流怎样选择元素：用谓词筛选，筛选出各不相同的元素，忽略流中的头几个元素，或将流截短至指定长度。</p><h4 id="5-1-1-用谓词筛选"><a href="#5-1-1-用谓词筛选" class="headerlink" title="5.1.1 用谓词筛选"></a><strong>5.1.1 用谓词筛选</strong></h4><p>&emsp;&emsp;Stream接口支持filter方法，接受一个Predicate参数，并返回符合谓词元素T的流。</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Stream<span class="tag">&lt;<span class="name">T</span>&gt;</span> filter(Predicate<span class="php"><span class="meta">&lt;?</span> super T&gt; predicate);</span></span><br></pre></td></tr></table></figure><p><img src="https://pic-1258215793.cos.ap-shanghai.myqcloud.com/content/20190901/201909010115.png" alt="用谓词筛选一个流"></p><h4 id="5-1-2-筛选出各不相同的元素"><a href="#5-1-2-筛选出各不相同的元素" class="headerlink" title="5.1.2 筛选出各不相同的元素"></a><strong>5.1.2 筛选出各不相同的元素</strong></h4><p>&emsp;&emsp;Stream接口支持distinct方法，返回一个元素各异的流（根据流所生成元素的hashcode和equals方法实现），避免重复元素。</p><figure class="highlight abnf"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Stream&lt;T&gt; distinct()<span class="comment">;</span></span><br></pre></td></tr></table></figure><p><img src="https://pic-1258215793.cos.ap-shanghai.myqcloud.com/content/20190901/201909010116.png" alt="筛选流中各异的元素代码"></p><p><img src="https://pic-1258215793.cos.ap-shanghai.myqcloud.com/content/20190901/201909010117.png" alt="筛选流中各异的元素"></p><h4 id="5-1-3-截短流"><a href="#5-1-3-截短流" class="headerlink" title="5.1.3 截短流"></a><strong>5.1.3 截短流</strong></h4><p>&emsp;&emsp;Stream接口支持limit方法，返回一个不超过给定长度的流。</p><figure class="highlight pf"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Stream<span class="variable">&lt;T&gt;</span> <span class="keyword">limit</span>(long <span class="keyword">max</span>Size);</span><br></pre></td></tr></table></figure><p><img src="https://pic-1258215793.cos.ap-shanghai.myqcloud.com/content/20190901/201909010118.png" alt="截短流代码"></p><p><img src="https://pic-1258215793.cos.ap-shanghai.myqcloud.com/content/20190901/201909010119.png" alt="截短流"></p><h4 id="5-1-4-跳过元素"><a href="#5-1-4-跳过元素" class="headerlink" title="5.1.4 跳过元素"></a><strong>5.1.4 跳过元素</strong></h4><p>&emsp;&emsp;Stream接口支持skip方法，返回一个扔掉了前n个元素的流，如果流中元素不足n个，会返回一个空流。</p><figure class="highlight arduino"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">Stream</span>&lt;T&gt; skip(<span class="keyword">long</span> n);</span><br></pre></td></tr></table></figure><p><img src="https://pic-1258215793.cos.ap-shanghai.myqcloud.com/content/20190901/201909010120.png" alt="在流中跳过元素"></p><h3 id="5-2-映射"><a href="#5-2-映射" class="headerlink" title="5.2 映射"></a><strong>5.2 映射</strong></h3><p>&emsp;&emsp;类似于数据库查询表中指定属性列，流也可以从对象中选择信息。</p><h4 id="5-2-1-对流中每一个元素应用函数"><a href="#5-2-1-对流中每一个元素应用函数" class="headerlink" title="5.2.1 对流中每一个元素应用函数"></a><strong>5.2.1 对流中每一个元素应用函数</strong></h4><p>&emsp;&emsp;Stream接口支持map方法，接受一个Function参数，会应用到每个元素上，并将元素映射为一个新的元素，最后返回流。</p><figure class="highlight armasm"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;R&gt; <span class="keyword">Stream&lt;R&gt; </span><span class="meta">map</span>(<span class="meta">Function</span>&lt;? super T, ? extends R&gt; mapper)<span class="comment">;</span></span><br></pre></td></tr></table></figure><figure class="highlight lasso"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">List</span>&lt;<span class="built_in">String</span>&gt; words = Arrays.asList(<span class="string">"Java 8"</span>,<span class="string">"Lambdas"</span>,<span class="string">"In"</span>,<span class="string">"Action"</span>);</span><br><span class="line"><span class="comment">//对流中每个元素应用函数</span></span><br><span class="line"><span class="built_in">List</span>&lt;<span class="built_in">Integer</span>&gt; wordLengths = words.stream().<span class="built_in">map</span>(<span class="built_in">String</span><span class="type">::length</span>).collect(Collectors.toList());</span><br><span class="line">System.out.println(wordLengths);<span class="comment">//[6, 7, 2, 6]</span></span><br></pre></td></tr></table></figure><h4 id="5-2-2-流的扁平化"><a href="#5-2-2-流的扁平化" class="headerlink" title="5.2.2 流的扁平化"></a><strong>5.2.2 流的扁平化</strong></h4><p>&emsp;&emsp;如果我们对于一个字符串集合，需要返回一张列表，列出所有不同的字符。我们可能会先通过map实现如下。</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-tag">words</span><span class="selector-class">.stream</span>()<span class="selector-class">.map</span>(<span class="selector-tag">word</span> <span class="selector-tag">-</span>&gt; <span class="selector-tag">word</span><span class="selector-class">.split</span>(""))<span class="selector-class">.dintinct</span>()<span class="selector-class">.collect</span>(<span class="selector-tag">Collectors</span><span class="selector-class">.toList</span>());</span><br></pre></td></tr></table></figure><p>&emsp;&emsp;传递给map方法的Lambda为每个单词返回了String[]，所以map返回的流应该是Stream&lt;String[]&gt;格式的，而我们想要的是Stream<string>。</string></p><p><img src="https://pic-1258215793.cos.ap-shanghai.myqcloud.com/content/20190901/201909010121.png" alt="不正确的使用map找出单词列表中不同的字符"></p><figure class="highlight arduino"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//流的扁平化</span></span><br><span class="line"><span class="comment">//首先通过map把单词映射为字符列表，再distinct去重，但返回是Stream&lt;String[]&gt;</span></span><br><span class="line">List&lt;<span class="keyword">String</span>[]&gt; wordCharsArray = words.stream().<span class="built_in">map</span>(<span class="keyword">word</span> -&gt; <span class="keyword">word</span>.split(<span class="string">""</span>)).distinct().collect(Collectors.toList());</span><br><span class="line">wordCharsArray.forEach(wordChar -&gt; System.out.<span class="built_in">println</span>(Arrays.toString(wordChar)));</span><br><span class="line"></span><br><span class="line"><span class="comment">//我们想要的是Stream&lt;String&gt;而不是Stream&lt;String[]&gt;，Arrays::stream这个方法好像可以把数组转为流，但只是把字符数组变为了流</span></span><br><span class="line">words.stream().<span class="built_in">map</span>(<span class="keyword">word</span> -&gt; <span class="keyword">word</span>.split(<span class="string">""</span>)).<span class="built_in">map</span>(Arrays::stream).distinct().collect(Collectors.toList());</span><br><span class="line"></span><br><span class="line"><span class="comment">//再通过flatMap</span></span><br><span class="line">List&lt;<span class="keyword">String</span>&gt; wordChars = words.stream()</span><br><span class="line">        .<span class="built_in">map</span>(<span class="keyword">word</span> -&gt; <span class="keyword">word</span>.split(<span class="string">""</span>)) <span class="comment">//将每个单词转换为由其字母构成的数组</span></span><br><span class="line">        .flatMap(Arrays::stream) <span class="comment">//将各个生成流扁平化为单个流</span></span><br><span class="line">        .distinct() </span><br><span class="line">        .collect(Collectors.toList());</span><br><span class="line">System.out.<span class="built_in">println</span>(wordChars);</span><br></pre></td></tr></table></figure><p>&emsp;&emsp;执行结果如下。</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">[J, a, v, a,  , <span class="number">8</span>]</span><br><span class="line">[L, a, m, b, d, a, s]</span><br><span class="line">[I, n]</span><br><span class="line">[A, c, t, i, o, n]</span><br><span class="line"></span><br><span class="line">[J, a, v,  , <span class="number">8</span>, L, m, b, d, s, I, n, A, c, t, i, o]</span><br></pre></td></tr></table></figure><p>&emsp;&emsp;flatMap()的作用是：各个数组并不是分别映射为一个流，而是映射为流的内容。所有map(Arrays::stream)生成的流都会被合并起来，扁平化为一个流。简单的说就是flatMap()会把一个流中每个值都换为另一个流，再把所有流连接起来成为一个流。</p><p><img src="https://pic-1258215793.cos.ap-shanghai.myqcloud.com/content/20190901/201909010122.png" alt="使用flatMap找出单词列表中不同的字符"></p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">R</span>&gt;</span> Stream<span class="tag">&lt;<span class="name">R</span>&gt;</span> flatMap(Function<span class="php"><span class="meta">&lt;?</span> super T, ? extends Stream<span class="meta">&lt;?</span> extends R&gt;&gt; mapper);</span></span><br></pre></td></tr></table></figure><h3 id="5-3-查找和匹配"><a href="#5-3-查找和匹配" class="headerlink" title="5.3 查找和匹配"></a><strong>5.3 查找和匹配</strong></h3><p>&emsp;&emsp;还有一个常见的数据处理套路是查询数据集中有某些元素是否匹配一个给定的数据。</p><h4 id="5-3-1-检查谓词是否至少匹配一个元素"><a href="#5-3-1-检查谓词是否至少匹配一个元素" class="headerlink" title="5.3.1 检查谓词是否至少匹配一个元素"></a><strong>5.3.1 检查谓词是否至少匹配一个元素</strong></h4><p>&emsp;&emsp;Stream接口支持anyMatch方法，接受一个Predicate参数，并返回布尔值，判断流中是否有一个元素可以匹配给定谓词。</p><figure class="highlight aspectj"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">boolean</span> <span class="title">anyMatch</span><span class="params">(Predicate&lt;? <span class="keyword">super</span> T&gt; predicate)</span></span>;</span><br></pre></td></tr></table></figure><h4 id="5-3-2-检查谓词是否匹配所有元素"><a href="#5-3-2-检查谓词是否匹配所有元素" class="headerlink" title="5.3.2 检查谓词是否匹配所有元素"></a><strong>5.3.2 检查谓词是否匹配所有元素</strong></h4><p>&emsp;&emsp;Stream接口支持allMatch方法，接受一个Predicate参数，并返回布尔值，判断流中是否所有元素可以匹配给定谓词。</p><figure class="highlight aspectj"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">boolean</span> <span class="title">allMatch</span><span class="params">(Predicate&lt;? <span class="keyword">super</span> T&gt; predicate)</span></span>;</span><br></pre></td></tr></table></figure><p>&emsp;&emsp;和allMatch相反的是noneMatch方法，判断流中是否没有元素可以匹配给定谓词。</p><figure class="highlight aspectj"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">boolean</span> <span class="title">noneMatch</span><span class="params">(Predicate&lt;? <span class="keyword">super</span> T&gt; predicate)</span></span>;</span><br></pre></td></tr></table></figure><blockquote><p>我们大概都学过短路技术，比如在一些逻辑判断时不需要进行所有操作就可以得到最终结果，对于流来说，如anyMatch、allMatch、noneMatch、findFirst、findAny这些操作也是可以应用短路的操作。在遇到无限流时，我们就能够把无限流变为有限流。</p></blockquote><h4 id="5-3-3-查找元素"><a href="#5-3-3-查找元素" class="headerlink" title="5.3.3 查找元素"></a><strong>5.3.3 查找元素</strong></h4><p>&emsp;&emsp;Stream接口支持findAny方法，返回当前流中的任意元素。通过Optional可以避免什么都没找到时返回null。</p><figure class="highlight abnf"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Optional&lt;T&gt; findAny()<span class="comment">;</span></span><br></pre></td></tr></table></figure><h4 id="5-3-4-查找第一个元素"><a href="#5-3-4-查找第一个元素" class="headerlink" title="5.3.4 查找第一个元素"></a><strong>5.3.4 查找第一个元素</strong></h4><p>&emsp;&emsp;对于一些有序的流，你可能想要获取第一个元素。Stream接口支持findFirst方法，返回当前流中的第一个元素。通过Optional可以避免什么都没找到时返回null。</p><figure class="highlight abnf"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Optional&lt;T&gt; findFirst()<span class="comment">;</span></span><br></pre></td></tr></table></figure><p>&emsp;&emsp;findAny()相比findFirst()在并行上限制更小，所以如果只是需要获取一个元素，建议使用findAny()。</p><h3 id="5-4-归约"><a href="#5-4-归约" class="headerlink" title="5.4 归约"></a><strong>5.4 归约</strong></h3><p>&emsp;&emsp;“计算菜单中菜肴的总卡路里”和“菜单中卡路里最高的菜是哪个”，类似这种需要在元素间计算的复杂需求，需要我们把一个流中的元素反复组合起来，得到一个值。这样的查询我们称为归约操作（把流归约为一个值），一般称类似操作为折叠。</p><h4 id="5-4-1-元素求和"><a href="#5-4-1-元素求和" class="headerlink" title="5.4.1 元素求和"></a><strong>5.4.1 元素求和</strong></h4><p>&emsp;&emsp;reduce()方法接受两个参数，identity是初始值，accumulator是函数式接口BinaryOperator，定义了对同类型两个操作数的处理操作，并产生相同类型的结果。</p><figure class="highlight excel"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">T</span> reduce(<span class="built_in">T</span> identity, BinaryOperator&lt;<span class="built_in">T</span>&gt; accumulator);</span><br><span class="line"></span><br><span class="line">Optional&lt;<span class="built_in">T</span>&gt; reduce(BinaryOperator&lt;<span class="built_in">T</span>&gt; accumulator);</span><br></pre></td></tr></table></figure><p>&emsp;&emsp;可以统计一下菜单中菜肴的总卡路里。Lambda会反复结合每个元素，直到流被归约为一个值。</p><figure class="highlight livescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">int sum = menu.stream<span class="function"><span class="params">()</span>.<span class="title">map</span><span class="params">(Dish::getCalories)</span>.<span class="title">reduce</span><span class="params">(<span class="number">0</span>,(a, b) -&gt; a + b)</span>;</span></span><br><span class="line"><span class="function"><span class="title">System</span>.<span class="title">out</span>.<span class="title">println</span><span class="params">(<span class="string">"sum: "</span> + sum)</span>;//<span class="title">sum</span>: 4200</span></span><br></pre></td></tr></table></figure><p><img src="https://pic-1258215793.cos.ap-shanghai.myqcloud.com/content/20190901/201909010123.png" alt="使用reduce来对流中的数字求和"></p><p>&emsp;&emsp;reduce()重载的一个没有初始值的变体，返回值是Optional。因为没有初始值，所以要考虑没有元素的情况。</p><h4 id="5-4-2-最大值和最小值"><a href="#5-4-2-最大值和最小值" class="headerlink" title="5.4.2 最大值和最小值"></a><strong>5.4.2 最大值和最小值</strong></h4><p>&emsp;&emsp;通过传递给reduce()一个求最大值/最小值的Lambda表达式就可以计算流中的最大值/最小值。</p><p><img src="https://pic-1258215793.cos.ap-shanghai.myqcloud.com/content/20190901/201909010124.png" alt="一个归约操作求最大值"></p><figure class="highlight fortran"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">Optional</span>&lt;<span class="keyword">Integer</span>&gt; <span class="built_in">max</span> = menu.stream().map(Dish::getCalories).reduce(<span class="keyword">Integer</span>::<span class="built_in">max</span>);</span><br><span class="line">System.<span class="keyword">out</span>.println(<span class="string">"max: "</span> + <span class="built_in">max</span>);//<span class="built_in">max</span>: <span class="keyword">Optional</span>[<span class="number">800</span>]</span><br><span class="line"><span class="keyword">Optional</span>&lt;<span class="keyword">Integer</span>&gt; <span class="built_in">min</span> = menu.stream().map(Dish::getCalories).reduce(<span class="keyword">Integer</span>::<span class="built_in">min</span>);</span><br><span class="line">System.<span class="keyword">out</span>.println(<span class="string">"min: "</span> + <span class="built_in">min</span>);//<span class="built_in">min</span>: <span class="keyword">Optional</span>[<span class="number">120</span>]</span><br></pre></td></tr></table></figure><p>&emsp;&emsp;map和reduce的连接通常称为map-reduce模式，因为Google用它进行网络搜索而知名，很容易并行化。</p><p>&emsp;&emsp;可变的累加器模式对并行化是死路一条，迭代求和要更新共享变量sum，非常不利于并行化，加入同步后线程竞争又抵消了并行本应带来的性能提升。当然归约方法也会有其限制，比如不能更改状态，操作必须满足结合律才能以任意顺序执行等。</p><p>&emsp;&emsp;如map或filter等操作从输入流获取每个元素，并在输出流中得到0或1个结果，这些操作一般是<strong>无状态</strong>的。而如reduce、sum和max等操作则需要<strong>内部状态</strong>来累积结果，但内部状态一般是有界的。对于sort和distinct等操作，它们和map很像，但却有一个关键区别：从流中排序或删除重复项都需要知道历史，排序需要把所有元素放入缓冲区后才能给输出流加入一个项目，这一操作的存储要求是无界的，如果流比较大甚至无限就会有问题。这些操作叫<strong>有状态操作</strong>。</p><h3 id="5-5-练习"><a href="#5-5-练习" class="headerlink" title="5.5 练习"></a><strong>5.5 练习</strong></h3><p><img src="https://pic-1258215793.cos.ap-shanghai.myqcloud.com/content/20190901/201909010125.png" alt="中间操作和终端操作"></p><p>&emsp;&emsp;有交易员Trader和交易Transction，请解答以下问题。</p><blockquote><ol><li>找出2011年发生的所有交易，并按交易额升序排序</li><li>交易员都在哪些不同的城市工作过</li><li>查找所有来自于剑桥的交易员，并按姓名排序</li><li>返回所有交易员的姓名字符串，按字母顺序排序</li><li>有没有交易员是在米兰工作的</li><li>打印生活在剑桥的交易员的所有交易额</li><li>所有交易中，最高的交易额是多少</li><li>找到交易额最小的交易</li></ol></blockquote><figure class="highlight haxe"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Trader</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> final <span class="keyword">String</span> name;</span><br><span class="line">    <span class="keyword">private</span> final <span class="keyword">String</span> city;</span><br><span class="line">    ......</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Transaction</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> final Trader trader;</span><br><span class="line">    <span class="keyword">private</span> final int year;</span><br><span class="line">    <span class="keyword">private</span> final int value;</span><br><span class="line">    ......</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//测试数据</span></span><br><span class="line">        Trader raoul = <span class="keyword">new</span> <span class="type">Trader</span>(<span class="string">"Raoul"</span>,<span class="string">"Cambridge"</span>);</span><br><span class="line">        Trader mario = <span class="keyword">new</span> <span class="type">Trader</span>(<span class="string">"Mario"</span>,<span class="string">"Milan"</span>);</span><br><span class="line">        Trader alan = <span class="keyword">new</span> <span class="type">Trader</span>(<span class="string">"Alan"</span>,<span class="string">"Cambridge"</span>);</span><br><span class="line">        Trader brian = <span class="keyword">new</span> <span class="type">Trader</span>(<span class="string">"Brian"</span>,<span class="string">"Cambridge"</span>);</span><br><span class="line"></span><br><span class="line">        List&lt;Transaction&gt; transactions = Arrays.asList(</span><br><span class="line">                <span class="keyword">new</span> <span class="type">Transaction</span>(brian,<span class="number">2011</span>,<span class="number">300</span>),</span><br><span class="line">                <span class="keyword">new</span> <span class="type">Transaction</span>(raoul,<span class="number">2012</span>,<span class="number">1000</span>),</span><br><span class="line">                <span class="keyword">new</span> <span class="type">Transaction</span>(raoul,<span class="number">2011</span>,<span class="number">400</span>),</span><br><span class="line">                <span class="keyword">new</span> <span class="type">Transaction</span>(mario,<span class="number">2012</span>,<span class="number">710</span>),</span><br><span class="line">                <span class="keyword">new</span> <span class="type">Transaction</span>(mario,<span class="number">2012</span>,<span class="number">700</span>),</span><br><span class="line">                <span class="keyword">new</span> <span class="type">Transaction</span>(alan,<span class="number">2012</span>,<span class="number">950</span>)</span><br><span class="line">        );</span><br></pre></td></tr></table></figure><h4 id="解答"><a href="#解答" class="headerlink" title="解答"></a><strong>解答</strong></h4><p>&emsp;&emsp;注释掉部分是因为书中有更好的解法。</p><figure class="highlight livescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br></pre></td><td class="code"><pre><span class="line">public <span class="class"><span class="keyword">class</span> <span class="title">Practice</span> &#123;</span></span><br><span class="line">    public static <span class="literal">void</span> main(String[] args) &#123;</span><br><span class="line">        Trader raoul = <span class="keyword">new</span> Trader(<span class="string">"Raoul"</span>,<span class="string">"Cambridge"</span>);</span><br><span class="line">        Trader mario = <span class="keyword">new</span> Trader(<span class="string">"Mario"</span>,<span class="string">"Milan"</span>);</span><br><span class="line">        Trader alan = <span class="keyword">new</span> Trader(<span class="string">"Alan"</span>,<span class="string">"Cambridge"</span>);</span><br><span class="line">        Trader brian = <span class="keyword">new</span> Trader(<span class="string">"Brian"</span>,<span class="string">"Cambridge"</span>);</span><br><span class="line"></span><br><span class="line">        List&lt;Transaction&gt; transactions = Arrays.asList(</span><br><span class="line">                <span class="keyword">new</span> Transaction(brian,<span class="number">2011</span>,<span class="number">300</span>),</span><br><span class="line">                <span class="keyword">new</span> Transaction(raoul,<span class="number">2012</span>,<span class="number">1000</span>),</span><br><span class="line">                <span class="keyword">new</span> Transaction(raoul,<span class="number">2011</span>,<span class="number">400</span>),</span><br><span class="line">                <span class="keyword">new</span> Transaction(mario,<span class="number">2012</span>,<span class="number">710</span>),</span><br><span class="line">                <span class="keyword">new</span> Transaction(mario,<span class="number">2012</span>,<span class="number">700</span>),</span><br><span class="line">                <span class="keyword">new</span> Transaction(alan,<span class="number">2012</span>,<span class="number">950</span>)</span><br><span class="line">        );</span><br><span class="line"></span><br><span class="line">        <span class="regexp">//Question 1 : 找出2011年发生的所有交易，并按交易额升序排序</span></span><br><span class="line"><span class="regexp">        List&lt;Transaction&gt; result1 = transactions.stream()</span></span><br><span class="line"><span class="regexp">                .filter(t -&gt; 2011 == t.getYear())</span></span><br><span class="line"><span class="regexp">                .sorted(Comparator.comparing(Transaction::getValue))</span></span><br><span class="line"><span class="regexp">                .collect(Collectors.toList());</span></span><br><span class="line"><span class="regexp">        System.out.println("------------------------------\nQuestion 1 : ");</span></span><br><span class="line"><span class="regexp">        System.out.println(result1);</span></span><br><span class="line"><span class="regexp"></span></span><br><span class="line"><span class="regexp">        //</span>Question <span class="number">2</span> : 交易员都在哪些不同的城市工作过</span><br><span class="line"><span class="regexp">//        List&lt;String&gt; result2 = transactions.stream()</span></span><br><span class="line"><span class="regexp">//</span>                .map(Transaction::getTrader)</span><br><span class="line"><span class="regexp">//                .map(Trader::getCity)</span></span><br><span class="line"><span class="regexp">//</span>                .distinct()</span><br><span class="line"><span class="regexp">//                .collect(Collectors.toList());</span></span><br><span class="line"><span class="regexp">        Set&lt;String&gt; result2 = transactions.stream()</span></span><br><span class="line"><span class="regexp">                .map(t -&gt; t.getTrader().getCity())</span></span><br><span class="line"><span class="regexp">                .collect(Collectors.toSet());</span></span><br><span class="line"><span class="regexp">        System.out.println("------------------------------\nQuestion 2 : ");</span></span><br><span class="line"><span class="regexp">        System.out.println(result2);</span></span><br><span class="line"><span class="regexp"></span></span><br><span class="line"><span class="regexp">        //</span>Question <span class="number">3</span> : 查找所有来自于剑桥的交易员，并按姓名排序</span><br><span class="line">        List&lt;Trader&gt; result3 = transactions.stream()</span><br><span class="line">                .map(Transaction::getTrader)</span><br><span class="line">                .filter(t<span class="function"> -&gt;</span> <span class="string">"Cambridge"</span>.equals(t.getCity()))</span><br><span class="line">                .distinct()</span><br><span class="line">                .sorted(Comparator.comparing(Trader::getName))</span><br><span class="line">                .collect(Collectors.toList());</span><br><span class="line">        System.out.println(<span class="string">"------------------------------\nQuestion 3 : "</span>);</span><br><span class="line">        System.out.println(result3);</span><br><span class="line"></span><br><span class="line">        <span class="regexp">//Question 4 : 返回所有交易员的姓名字符串，按字母顺序排序</span></span><br><span class="line"><span class="regexp">//</span>        String result4 = transactions.stream()</span><br><span class="line"><span class="regexp">//                .map(t -&gt; t.getTrader().getName())</span></span><br><span class="line"><span class="regexp">//</span>                .distinct()</span><br><span class="line"><span class="regexp">//                .sorted()</span></span><br><span class="line"><span class="regexp">//</span>                .reduce<span class="function"><span class="params">(<span class="string">""</span>,(s1,s2) -&gt; s1 + s2)</span>;</span></span><br><span class="line"><span class="function">        <span class="title">String</span> <span class="title">result4</span> = <span class="title">transactions</span>.<span class="title">stream</span><span class="params">()</span></span></span><br><span class="line"><span class="function">                .<span class="title">map</span><span class="params">(t -&gt; t.getTrader().getName())</span></span></span><br><span class="line"><span class="function">                .<span class="title">distinct</span><span class="params">()</span></span></span><br><span class="line"><span class="function">                .<span class="title">sorted</span><span class="params">()</span></span></span><br><span class="line"><span class="function">                .<span class="title">collect</span><span class="params">(Collectors.joining())</span>;</span></span><br><span class="line"><span class="function">        <span class="title">System</span>.<span class="title">out</span>.<span class="title">println</span><span class="params">(<span class="string">"------------------------------\nQuestion 4 : "</span>)</span>;</span></span><br><span class="line"><span class="function">        <span class="title">System</span>.<span class="title">out</span>.<span class="title">println</span><span class="params">(result4)</span>;</span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function">        //<span class="title">Question</span> 5 : 有没有交易员是在米兰工作的</span></span><br><span class="line"><span class="function">        <span class="title">boolean</span> <span class="title">result5</span> = <span class="title">transactions</span>.<span class="title">stream</span><span class="params">()</span></span></span><br><span class="line"><span class="function">                .<span class="title">map</span><span class="params">(Transaction::getTrader)</span></span></span><br><span class="line"><span class="function">                .<span class="title">anyMatch</span><span class="params">(t-&gt;<span class="string">"Milan"</span>.equals(t.getCity()))</span>;</span></span><br><span class="line"><span class="function">        <span class="title">System</span>.<span class="title">out</span>.<span class="title">println</span><span class="params">(<span class="string">"------------------------------\nQuestion 5 : "</span>)</span>;</span></span><br><span class="line"><span class="function">        <span class="title">System</span>.<span class="title">out</span>.<span class="title">println</span><span class="params">(result5)</span>;</span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function">        //<span class="title">Question</span> 6 : 打印生活在剑桥的交易员的所有交易额</span></span><br><span class="line"><span class="function">        <span class="title">System</span>.<span class="title">out</span>.<span class="title">println</span><span class="params">(<span class="string">"------------------------------\nQuestion 6 : "</span>)</span>;</span></span><br><span class="line"><span class="function">        <span class="title">transactions</span>.<span class="title">stream</span><span class="params">()</span></span></span><br><span class="line"><span class="function">                .<span class="title">filter</span><span class="params">(t -&gt; <span class="string">"Cambridge"</span>.equals(t.getTrader().getCity()))</span></span></span><br><span class="line"><span class="function">                .<span class="title">map</span><span class="params">(Transaction::getValue)</span></span></span><br><span class="line"><span class="function">                .<span class="title">forEach</span><span class="params">(System.out::println)</span>;</span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function">        //<span class="title">Question</span> 7 : 所有交易中，最高的交易额是多少</span></span><br><span class="line"><span class="function">        <span class="title">Optional</span>&lt;<span class="title">Integer</span>&gt; <span class="title">result7</span> = <span class="title">transactions</span>.<span class="title">stream</span><span class="params">()</span></span></span><br><span class="line"><span class="function">                .<span class="title">map</span><span class="params">(Transaction::getValue)</span></span></span><br><span class="line"><span class="function">                .<span class="title">reduce</span><span class="params">(Integer::max)</span>;</span></span><br><span class="line"><span class="function">        <span class="title">System</span>.<span class="title">out</span>.<span class="title">println</span><span class="params">(<span class="string">"------------------------------\nQuestion 7 : "</span>)</span>;</span></span><br><span class="line"><span class="function">        <span class="title">System</span>.<span class="title">out</span>.<span class="title">println</span><span class="params">(result7)</span>;</span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function">        //<span class="title">Question</span> 8 : 找到交易额最小的交易</span></span><br><span class="line"><span class="function">        <span class="title">Optional</span>&lt;<span class="title">Transaction</span>&gt; <span class="title">result8</span> = <span class="title">transactions</span>.<span class="title">stream</span><span class="params">()</span></span></span><br><span class="line"><span class="function">                .<span class="title">min</span><span class="params">(Comparator.comparing(Transaction::getValue))</span>;</span></span><br><span class="line"><span class="function">        <span class="title">System</span>.<span class="title">out</span>.<span class="title">println</span><span class="params">(<span class="string">"------------------------------\nQuestion 8 : "</span>)</span>;</span></span><br><span class="line"><span class="function">        <span class="title">System</span>.<span class="title">out</span>.<span class="title">println</span><span class="params">(result8)</span>;</span></span><br><span class="line"><span class="function">    &#125;</span></span><br><span class="line"><span class="function">&#125;</span></span><br></pre></td></tr></table></figure><p>&emsp;&emsp;打印结果如下。</p><figure class="highlight asciidoc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">------------------------------</span><br><span class="line">Question 1 : </span><br><span class="line"><span class="meta">[&#123;Brian,2011,300&#125;, &#123;Raoul,2011,400&#125;]</span></span><br><span class="line">------------------------------</span><br><span class="line">Question 2 : </span><br><span class="line"><span class="meta">[Milan, Cambridge]</span></span><br><span class="line">------------------------------</span><br><span class="line">Question 3 : </span><br><span class="line"><span class="meta">[&#123;Alan,Cambridge&#125;, &#123;Brian,Cambridge&#125;, &#123;Raoul,Cambridge&#125;]</span></span><br><span class="line">------------------------------</span><br><span class="line">Question 4 : </span><br><span class="line">AlanBrianMarioRaoul</span><br><span class="line">------------------------------</span><br><span class="line">Question 5 : </span><br><span class="line">true</span><br><span class="line">------------------------------</span><br><span class="line">Question 6 : </span><br><span class="line">300</span><br><span class="line">1000</span><br><span class="line">400</span><br><span class="line">950</span><br><span class="line">------------------------------</span><br><span class="line">Question 7 : </span><br><span class="line">Optional[1000]</span><br><span class="line">------------------------------</span><br><span class="line">Question 8 : </span><br><span class="line">Optional[&#123;Brian,2011,300&#125;]</span><br></pre></td></tr></table></figure><hr><h2 id="第六节-数值流"><a href="#第六节-数值流" class="headerlink" title="第六节 数值流"></a><strong>第六节 数值流</strong></h2><h3 id="6-1-原始类型流特化"><a href="#6-1-原始类型流特化" class="headerlink" title="6.1 原始类型流特化"></a><strong>6.1 原始类型流特化</strong></h3><p>&emsp;&emsp;有时我们需要统计对象的某个数值属性列，根据归约我们可以如此实现。</p><figure class="highlight livescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">int sum = menu.stream<span class="function"><span class="params">()</span>.<span class="title">map</span><span class="params">(Dish::getCalories)</span>.<span class="title">reduce</span><span class="params">(<span class="number">0</span>,(a, b) -&gt; a + b)</span>;</span></span><br></pre></td></tr></table></figure><p>&emsp;&emsp;这种实现存在一个装箱成本，Integer类型的属性需要转为int进行求和，你或许会想会什么不能直接调用sum()来进行求和。因为对于流接口来说，它对于对象求和是没有意义的，但Stream API提供了<strong>原始类型流特化</strong>，专门用来支持处理数值流的方法。</p><table><thead><tr><th style="text-align:left">操作</th><th style="text-align:left">类型</th><th style="text-align:left">返回类型</th><th style="text-align:left">操作参数</th><th style="text-align:left">函数描述符</th></tr></thead><tbody><tr><td style="text-align:left">mapToInt</td><td style="text-align:left">中间</td><td style="text-align:left">IntStream</td><td style="text-align:left">ToIntFunction<t></t></td><td style="text-align:left">T -&gt; int</td></tr><tr><td style="text-align:left">mapToLong</td><td style="text-align:left">中间</td><td style="text-align:left">LongStream</td><td style="text-align:left">ToLongFunction<t></t></td><td style="text-align:left">T -&gt; long</td></tr><tr><td style="text-align:left">mapToDouble</td><td style="text-align:left">中间</td><td style="text-align:left">DoubleStream</td><td style="text-align:left">ToDoubleFunction<t></t></td><td style="text-align:left">T -&gt; double</td></tr></tbody></table><p>&emsp;&emsp;所以我们可以改写代码如下。</p><figure class="highlight axapta"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> sumSpec = menu.stream()</span><br><span class="line">        .mapToInt(Dish::getCalories) <span class="comment">//先映射为IntStream</span></span><br><span class="line">        .<span class="keyword">sum</span>(); <span class="comment">//再调用IntStream提供的sum()求和</span></span><br></pre></td></tr></table></figure><p>&emsp;&emsp;<strong>数值流也可以再转为对象流</strong>，通过boxed()进行装箱。</p><p>&emsp;&emsp;sum()有默认值0，但如求最大值等则需要Optional的特定版本：OptionalInt、OptionalDouble、OptionalLong来作为返回值。</p><h3 id="6-2-数值范围"><a href="#6-2-数值范围" class="headerlink" title="6.2 数值范围"></a><strong>6.2 数值范围</strong></h3><p>&emsp;&emsp;range()和rangeClosed()可以生成数值范围，两个参数分别是起始和结束值，range()不包括结束值。</p><figure class="highlight aspectj"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="function">IntStream <span class="title">range</span><span class="params">(<span class="keyword">int</span> startInclusive, <span class="keyword">int</span> endExclusive)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (startInclusive &gt;= endExclusive) &#123;</span><br><span class="line">        <span class="function"><span class="keyword">return</span> <span class="title">empty</span><span class="params">()</span></span>;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> StreamSupport.intStream(</span><br><span class="line">                <span class="keyword">new</span> Streams.RangeIntSpliterator(startInclusive, endExclusive, <span class="keyword">false</span>), <span class="keyword">false</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="function">IntStream <span class="title">rangeClosed</span><span class="params">(<span class="keyword">int</span> startInclusive, <span class="keyword">int</span> endInclusive)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (startInclusive &gt; endInclusive) &#123;</span><br><span class="line">        <span class="function"><span class="keyword">return</span> <span class="title">empty</span><span class="params">()</span></span>;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> StreamSupport.intStream(</span><br><span class="line">                <span class="keyword">new</span> Streams.RangeIntSpliterator(startInclusive, endInclusive, <span class="keyword">true</span>), <span class="keyword">false</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="6-3-应用"><a href="#6-3-应用" class="headerlink" title="6.3 应用"></a><strong>6.3 应用</strong></h3><p>&emsp;&emsp;创建一个勾股数（若a^2 + b^2 = c^2，三个都是整数，则a、b、c是一组勾股数）。</p><p>&emsp;&emsp;我们需要能表示三元组(a, b, c)，可以采用数组int[]。</p><figure class="highlight xl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//勾股数</span></span><br><span class="line">Stream&lt;int[]&gt; pythagoreanTriples = IntStream.rangeClosed(<span class="number">1</span>,<span class="number">100</span>) <span class="comment">//从1至100取值</span></span><br><span class="line">        .boxed() <span class="comment">//数值流装箱转换为Stream&lt;Integer&gt;</span></span><br><span class="line">        .<span class="function"><span class="title">flatMap</span>(a -&gt;</span> <span class="comment">//把生成的三元流扁平为一个三元数流</span></span><br><span class="line">                IntStream.rangeClosed(a,<span class="number">100</span>) <span class="comment">//从a至100取值，避免重复</span></span><br><span class="line">                        .<span class="function"><span class="title">filter</span>(b -&gt;</span> <span class="comment">//过滤不合法的(a, b)取值</span></span><br><span class="line">                                Math.<span class="built_in">sqrt</span>(a * a + b * b) % <span class="number">1</span> == <span class="number">0</span>) <span class="comment">//Math.sqrt(a * a + b * b) % 1 == 0判断c是否为整数</span></span><br><span class="line">                        .<span class="function"><span class="title">mapToObj</span>(b -&gt;</span> <span class="comment">//映射出三元组</span></span><br><span class="line">                                new int[]&#123;a, b, (int) Math.<span class="built_in">sqrt</span>(a * a + b * b)&#125;));</span><br><span class="line">System.out.println(<span class="string">"++++++++++++++++++++"</span>);</span><br><span class="line"><span class="function"><span class="title">pythagoreanTriples</span>.limit(5).forEach(t -&gt;</span> System.out.println(t[<span class="number">0</span>] + <span class="string">", "</span> + t[<span class="number">1</span>] + <span class="string">", "</span> + t[<span class="number">2</span>]));</span><br><span class="line"></span><br><span class="line"><span class="comment">//优化</span></span><br><span class="line">Stream&lt;double[]&gt; pythagoreanTriples2 = IntStream.rangeClosed(<span class="number">1</span>,<span class="number">100</span>)</span><br><span class="line">        .boxed()</span><br><span class="line">        .<span class="function"><span class="title">flatMap</span>(a -&gt;</span></span><br><span class="line">                IntStream.rangeClosed(a, <span class="number">100</span>)</span><br><span class="line">                        .<span class="function"><span class="title">mapToObj</span>(b -&gt;</span> new double[]&#123;a, b, Math.<span class="built_in">sqrt</span>(a * a + b * b)&#125;) <span class="comment">//先生成所有三元组</span></span><br><span class="line">                        .<span class="function"><span class="title">filter</span>(t -&gt;</span> t[<span class="number">2</span>] % <span class="number">1</span> == <span class="number">0</span>)); <span class="comment">//再筛选掉不合法的</span></span><br></pre></td></tr></table></figure><hr><h2 id="第七节-构建流"><a href="#第七节-构建流" class="headerlink" title="第七节 构建流"></a><strong>第七节 构建流</strong></h2><h3 id="7-1-由值创建流"><a href="#7-1-由值创建流" class="headerlink" title="7.1 由值创建流"></a><strong>7.1 由值创建流</strong></h3><p>&emsp;&emsp;Stream.of()方法可以用来由值创建流。</p><figure class="highlight arduino"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span>&lt;T&gt; <span class="built_in">Stream</span>&lt;T&gt; of(T... values) &#123;</span><br><span class="line">    <span class="built_in">return</span> Arrays.stream(values);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight arduino"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//由值创建流</span></span><br><span class="line"><span class="built_in">Stream</span>&lt;<span class="keyword">String</span>&gt; stringStream = <span class="built_in">Stream</span>.of(<span class="string">"a"</span>,<span class="string">"b"</span>);</span><br></pre></td></tr></table></figure><h3 id="7-2-由数组创建流"><a href="#7-2-由数组创建流" class="headerlink" title="7.2 由数组创建流"></a><strong>7.2 由数组创建流</strong></h3><p>&emsp;&emsp;Arrays.stream()方法可以用来由数组创建流</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> IntStream <span class="title">stream</span><span class="params">(<span class="keyword">int</span>[] <span class="built_in">array</span>)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> stream(<span class="built_in">array</span>, <span class="number">0</span>, <span class="built_in">array</span>.length);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight lsl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//由数组创建流</span></span><br><span class="line">int[] a = &#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>&#125;;</span><br><span class="line">Stream&lt;Integer&gt; integerStream = Arrays.stream(a).boxed();</span><br></pre></td></tr></table></figure><h3 id="7-3-由文件生成流"><a href="#7-3-由文件生成流" class="headerlink" title="7.3 由文件生成流"></a><strong>7.3 由文件生成流</strong></h3><figure class="highlight arduino"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//由文件生成流</span></span><br><span class="line"><span class="keyword">long</span> uniqueWords = <span class="number">0</span>;</span><br><span class="line"><span class="built_in">try</span>(<span class="built_in">Stream</span>&lt;<span class="keyword">String</span>&gt; lines = Files.lines(Paths.<span class="built_in">get</span>(<span class="string">"d:/data.txt"</span>), Charset.defaultCharset()))&#123;</span><br><span class="line">    uniqueWords = lines.flatMap(<span class="built_in">line</span> -&gt; Arrays.stream(<span class="built_in">line</span>.split(<span class="string">" "</span>)))</span><br><span class="line">            .distinct()</span><br><span class="line">            .count();</span><br><span class="line">&#125;<span class="built_in">catch</span> (IOException ex)&#123;</span><br><span class="line">    ex.printStackTrace();</span><br><span class="line">&#125;</span><br><span class="line">System.out.<span class="built_in">println</span>(<span class="string">"文件中不重复单词有："</span> + uniqueWords + <span class="string">"个"</span>);</span><br></pre></td></tr></table></figure><h3 id="7-4-由函数生成流：创建无限流"><a href="#7-4-由函数生成流：创建无限流" class="headerlink" title="7.4 由函数生成流：创建无限流"></a><strong>7.4 由函数生成流：创建无限流</strong></h3><p>&emsp;&emsp;Stream.iterate()和Stream.generate()方法用来从函数生成流，可以创建所谓的<strong>无限流</strong>：没有固定大小的流。注意加limit限制，防止无限的打印。</p><h4 id="迭代"><a href="#迭代" class="headerlink" title="迭代"></a><strong>迭代</strong></h4><figure class="highlight less"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//迭代</span></span><br><span class="line"><span class="selector-tag">Stream</span><span class="selector-class">.iterate</span>(<span class="number">0</span>, n -&gt; n + <span class="number">2</span>)</span><br><span class="line">        <span class="selector-class">.limit</span>(<span class="number">10</span>)</span><br><span class="line">        <span class="selector-class">.forEach</span>(System.<span class="attribute">out</span>::println);</span><br></pre></td></tr></table></figure><p>&emsp;&emsp;顺序的不断迭代+2，如果没有限制会无限的运行下去，这种流是无界的。</p><h4 id="生成"><a href="#生成" class="headerlink" title="生成"></a><strong>生成</strong></h4><figure class="highlight less"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//生成</span></span><br><span class="line"><span class="selector-tag">Stream</span><span class="selector-class">.generate</span>(<span class="attribute">Math</span>::random)</span><br><span class="line">        <span class="selector-class">.limit</span>(<span class="number">5</span>)</span><br><span class="line">        <span class="selector-class">.forEach</span>(System.<span class="attribute">out</span>::println);</span><br></pre></td></tr></table></figure><p>&emsp;&emsp;我们使用的源（指向random的方法引用）是无状态的：它不会在任何地方记录任何值来以便备用。但也可以使用有存储状态的源，修改其状态，留给流生成下一个值时使用。</p><h4 id="实现斐波那契数列"><a href="#实现斐波那契数列" class="headerlink" title="实现斐波那契数列"></a><strong>实现斐波那契数列</strong></h4><figure class="highlight arduino"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//斐波那契数列，每个数字都是前两个数字之和</span></span><br><span class="line"><span class="comment">//打印二元组</span></span><br><span class="line"><span class="built_in">Stream</span>.iterate(<span class="keyword">new</span> <span class="keyword">int</span>[]&#123;<span class="number">0</span>, <span class="number">1</span>&#125;, temp -&gt; <span class="keyword">new</span> <span class="keyword">int</span>[]&#123;temp[<span class="number">1</span>], temp[<span class="number">0</span>] + temp[<span class="number">1</span>]&#125;)</span><br><span class="line">        .limit(<span class="number">20</span>)</span><br><span class="line">        .forEach(t -&gt; System.out.<span class="built_in">println</span>(<span class="string">"("</span> + t[<span class="number">0</span>] + <span class="string">", "</span> + t[<span class="number">1</span>] + <span class="string">")"</span>));</span><br><span class="line"></span><br><span class="line"><span class="comment">//打印斐波那契数列</span></span><br><span class="line"><span class="built_in">Stream</span>.iterate(<span class="keyword">new</span> <span class="keyword">int</span>[]&#123;<span class="number">0</span>, <span class="number">1</span>&#125;, temp -&gt; <span class="keyword">new</span> <span class="keyword">int</span>[]&#123;temp[<span class="number">1</span>], temp[<span class="number">0</span>] + temp[<span class="number">1</span>]&#125;)</span><br><span class="line">        .limit(<span class="number">20</span>)</span><br><span class="line">        .<span class="built_in">map</span>(t -&gt; t[<span class="number">0</span>])</span><br><span class="line">        .forEach(System.out::<span class="built_in">println</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">//实例化IntSupplier，修改状态，实现斐波那契数列</span></span><br><span class="line">IntSupplier fib = <span class="keyword">new</span> IntSupplier() &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> pre = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> current = <span class="number">1</span>;</span><br><span class="line">    @Override</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">int</span> getAsInt() &#123;</span><br><span class="line">        <span class="keyword">int</span> old = <span class="keyword">this</span>.pre;</span><br><span class="line">        <span class="keyword">int</span> next = <span class="keyword">this</span>.pre + <span class="keyword">this</span>.current;</span><br><span class="line">        <span class="keyword">this</span>.pre = <span class="keyword">this</span>.current;</span><br><span class="line">        <span class="keyword">this</span>.current = next;</span><br><span class="line">        <span class="built_in">return</span> old;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line">IntStream.generate(fib).limit(<span class="number">10</span>).forEach(System.out::<span class="built_in">println</span>);</span><br></pre></td></tr></table></figure><p>&emsp;&emsp;两种实现：使用iterate方法不会出现修改状态操作，但每次迭代都会创建新的元组。generate方法则实例化了IntSupplier接口，并在每次调用getAsInt方法时改变了对象的状态。不变的方法会有利于并行处理哦。</p><hr><p><em>参考博客和文章书籍等：</em></p><blockquote><p>《Java8实战》</p></blockquote><p><em>因博客主等未标明不可引用，若部分内容涉及侵权请及时告知，我会尽快修改和删除相关内容</em></p>]]></content>
    
    <summary type="html">
    
      介绍Java 8中加入的流——第二节，内容包括：流的使用(筛选和切片、映射、查找和匹配、归约、练习)，数值流(原始类型流特化、数值范围、应用)，构建流(由值创建流、由数组创建流、由文件生成流、由函数生成流：创建无限流)。
    
    </summary>
    
      <category term="技术文档" scheme="http://linyishui.top/categories/%E6%8A%80%E6%9C%AF%E6%96%87%E6%A1%A3/"/>
    
    
      <category term="java" scheme="http://linyishui.top/tags/java/"/>
    
      <category term="stream" scheme="http://linyishui.top/tags/stream/"/>
    
  </entry>
  
  <entry>
    <title>流（一）入门介绍</title>
    <link href="http://linyishui.top/2019092201.html"/>
    <id>http://linyishui.top/2019092201.html</id>
    <published>2019-09-22T02:15:53.000Z</published>
    <updated>2019-12-05T03:23:24.105Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="流（一）入门介绍"><a href="#流（一）入门介绍" class="headerlink" title="流（一）入门介绍"></a><strong>流（一）入门介绍</strong></h1><h2 id="第一节-引文"><a href="#第一节-引文" class="headerlink" title="第一节 引文"></a><strong>第一节 引文</strong></h2><h3 id="为什么有了集合还需要流？"><a href="#为什么有了集合还需要流？" class="headerlink" title="为什么有了集合还需要流？"></a><strong>为什么有了集合还需要流？</strong></h3><p>&emsp;&emsp;流的出现是为了在某些场景下能够代替集合，集合的业务中常常涉及到类似数据库的操作，当有一些复杂需求需要嵌套遍历运算时，集合就需要公式似的写一串代码，很难让人一眼看明白代码代表的意思。如下案例实现在集合中筛选金额较高的交易，并按货币分组。</p><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//创建累积交易分组的Map</span></span><br><span class="line"><span class="built_in">Map</span>&lt;Currency, <span class="built_in">List</span>&lt;Transaction&gt;&gt; transactionsByCurrencies = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line"><span class="comment">//遍历交易List</span></span><br><span class="line"><span class="keyword">for</span>(Transaction transaction : transactions)&#123;</span><br><span class="line">    <span class="comment">//筛选金额较高的交易</span></span><br><span class="line">    <span class="keyword">if</span>(transaction.getPrice() &gt; <span class="number">1000</span>)&#123;</span><br><span class="line">        <span class="comment">//提取交易货币</span></span><br><span class="line">        Currency currency = transaction.getCurrency();</span><br><span class="line">        <span class="built_in">List</span>&lt;Transaction&gt; transactionForCurrency = transactionsByCurrencies.<span class="keyword">get</span>(currency);</span><br><span class="line">        <span class="comment">//如果此货币分组为空，就新建一个</span></span><br><span class="line">        <span class="keyword">if</span>(transactionForCurrency == <span class="keyword">null</span>)&#123;</span><br><span class="line">            transactionForCurrency = <span class="keyword">new</span> ArratList();</span><br><span class="line">            transactionsByCurrencies.put(currency,transactionForCurrency);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//将当前遍历的交易添加到具有同一货币的交易List中</span></span><br><span class="line">        transactionForCurrency.add(transaction);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>&emsp;&emsp;如果通过Stream API，可以改写上述代码如下。</p><figure class="highlight livescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> static java.util.stream.Collectors.toList;</span><br><span class="line">Map&lt;Currency, List&lt;Transaction&gt;&gt; transactionsByCurrencies = transactions.stream<span class="function"><span class="params">()</span>.<span class="title">filter</span><span class="params">((Transaction t) -&gt; t.getPrice() &gt; <span class="number">1000</span>)</span>.<span class="title">collect</span><span class="params">(groupingBy(Transaction::getCurrency))</span>;</span></span><br></pre></td></tr></table></figure><p>&emsp;&emsp;流允许我们以声明性方式处理数据几个（通过查询语句实现，而不是临时编写一个实现）。</p><h3 id="流解决了集合的两个问题"><a href="#流解决了集合的两个问题" class="headerlink" title="流解决了集合的两个问题"></a><strong>流解决了集合的两个问题</strong></h3><p>&emsp;&emsp;两个问题是：集合处理时的固定套路和晦涩，以及难以有效利用多核性能。</p><p>&emsp;&emsp;<strong>集合的主要目的是为了存储和访问数据，而Stream则主要用于描述对数据的计算。</strong></p><p>&emsp;&emsp;集合需要手动实现迭代和运算处理，这种数据迭代叫<strong>外部迭代</strong>，而流式的迭代完全在库内部实现，叫做<strong>内部迭代</strong>。流则和SQL的思路一样，采用了更高级的语言表达，由<strong>实现</strong>（Streams库）来选择最佳的低级执行机制。这样就可以避免用synchronized编写代码，它不仅容易出错，且在多核环境下需要很大的成本。筛选一个集合的最快方案就是先转为Stream，再进行并行处理，最后再转换为List。编程中往往会有一些反复出现的数据处理模式，可以根据标准进行<strong>筛选数据</strong>、<strong>提取数据</strong>、<strong>给数据分组</strong>等会很方便。</p><p>&emsp;&emsp;<strong>这些操作往往可以并行化</strong>。比如在两个CPU上筛选集合，可以一个处理列表前半部，一个处理后半部，这叫做分支步骤(1)；然后CPU对各自半个集合进行筛选(2)；最后(3)，一个CPU将两个结果合并。</p><h3 id="流的优点"><a href="#流的优点" class="headerlink" title="流的优点"></a><strong>流的优点</strong></h3><blockquote><p>流相较集合的优点：</p><ul><li><strong>声明性</strong>：如果使用SQL这种数据库语言会发现一些查询语句转化为Java要变得很长，Java8的流支持这种简明的数据库查询式编程且用的是Java语法，我们的目标是说明要做什么，而不是要如何来实现这个操作。</li><li><strong>可复合</strong>：可以对流做一些集合不能做的优化操作，如可以将对同一个流的若干操作组合起来，从而只遍历一次数据，而不是花大代价的去多次遍历。</li><li><strong>可并行</strong>：Java可以自动的将流操作并行化，而集合则不行。</li><li>流被设计为无需同时将数据调入内存，这样就可以处理无法装入内存的流数据了。</li></ul></blockquote><hr><h2 id="第二节-流简介"><a href="#第二节-流简介" class="headerlink" title="第二节 流简介"></a><strong>第二节 流简介</strong></h2><h3 id="stream和parallelStream"><a href="#stream和parallelStream" class="headerlink" title="stream和parallelStream"></a><strong>stream和parallelStream</strong></h3><p>&emsp;&emsp;集合接口Collection在Java 8中增加了默认方法stream()和parallelStream()，分别代表着<strong>流的顺序和并行处理</strong>。</p><figure class="highlight livescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">default</span> Stream&lt;E&gt; stream() &#123;</span><br><span class="line">    <span class="keyword">return</span> StreamSupport.stream(spliterator(), <span class="literal">false</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">default</span> Stream&lt;E&gt; parallelStream() &#123;</span><br><span class="line">    <span class="keyword">return</span> StreamSupport.stream(spliterator(), <span class="literal">true</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="regexp">//顺序处理</span></span><br><span class="line"><span class="regexp">List&lt;Student&gt; result = students.stream().filter((Student s) -&gt; s.getAge() &gt; 18).collect(Collectors.toList());</span></span><br><span class="line"><span class="regexp">//</span>并行处理</span><br><span class="line">List&lt;Student&gt; result = students.parallelStream<span class="function"><span class="params">()</span>.<span class="title">filter</span><span class="params">((Student s) -&gt; s.getAge() &gt; <span class="number">18</span>)</span>.<span class="title">collect</span><span class="params">(Collectors.toList())</span>;</span></span><br></pre></td></tr></table></figure><h3 id="流是什么"><a href="#流是什么" class="headerlink" title="流是什么"></a><strong>流是什么</strong></h3><p>&emsp;&emsp;简单的定义，<strong>流是从支持数据处理操作的源生成的元素序列</strong>。</p><blockquote><ul><li><strong>元素序列</strong>：和集合一样，流也提供了接口Stream，可以访问特定元素类型的一组有序值。集合是数据结构，其目的是以特定的时间/空间复杂度存储和访问元素。流的目的是表达计算。集合表述数据，流表述计算。</li><li><strong>源</strong>：流会使用一个提供数据的源，如集合、数组或输入/输出资源。从有序集合生成流时会保留顺序。</li><li><strong>数据处理操作</strong>：流的数据处理功能支持类似于数据库的操作，以及函数式编程语言中的常用操作，如filter、map、reduce、find、match、sort等。流操作可以顺序执行也可以并行执行。</li><li><strong>流水线</strong>：很多流操作本身会返回一个流，所以这些操作就可以链接起来，形成一个大的流水线。也为我们做如延迟和短路这些优化提供了可能。</li><li><strong>内部迭代</strong>：与使用迭代器进行显示迭代的集合不同，流的迭代操作是在背后进行的。</li></ul></blockquote><p><img src="https://pic-1258215793.cos.ap-shanghai.myqcloud.com/content/20190901/201909010110.png" alt="将流操作链接起来构成流的流水线"></p><p>&emsp;&emsp;如下代码中，<strong>数据源</strong>是菜肴列表，它提供给流一个<strong>元素序列</strong>。一系列<strong>数据处理操作</strong>构成了<strong>流水线</strong>，最后的collect操作并没有返回流，而是返回List结果。在collect操作被调用前，流水线上其他操作都在排队等待。</p><figure class="highlight jboss-cli"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">List&lt;String&gt; threeHighCaloricDishNames = menu.stream<span class="params">()</span> <span class="string">//</span>从集合获得流，准备创建流水线</span><br><span class="line">        <span class="string">.filter</span><span class="params">(d -&gt; d.getCalories()</span> &gt; 300) <span class="string">//</span>筛选高热量的菜肴</span><br><span class="line">        <span class="string">.map</span><span class="params">(Dish::getName)</span> <span class="string">//</span>获取菜名</span><br><span class="line">        <span class="string">.limit</span><span class="params">(3)</span> <span class="string">//</span>只选择头三个</span><br><span class="line">        <span class="string">.collect</span><span class="params">(Collectors.toList()</span>); <span class="string">//</span>将结果存在另一个List中</span><br><span class="line">System.out.println<span class="params">(threeHighCaloricDishNames)</span>;</span><br></pre></td></tr></table></figure><p><img src="https://pic-1258215793.cos.ap-shanghai.myqcloud.com/content/20190901/201909010111.png" alt="使用流来筛选菜单找出三个热量最高的菜肴名字"></p><p>&emsp;&emsp;流水线类似于<strong>构建器模式</strong>，一个调用链来设置一套配置，再调用build()方法。</p><hr><h2 id="第三节-流和集合"><a href="#第三节-流和集合" class="headerlink" title="第三节 流和集合"></a><strong>第三节 流和集合</strong></h2><p>&emsp;&emsp;我们可以把DVD中存储的电影（基于字节或帧无所谓）看作是一个集合，而网络中通过视频流看同一部电影看作是流。视频流不需要用户等待加载完整个视频，而是只要下载当前观看位置的那几帧就可以了。</p><p><img src="https://pic-1258215793.cos.ap-shanghai.myqcloud.com/content/20190901/201909010112.png" alt="流与集合"></p><p>&emsp;&emsp;这样看，<strong>流和集合的差异就在于何时进行计算</strong>，集合是一个内存中的数据结构，它包含了数据结构中目前的所有值，集合中的所有元素都要先计算出来才能添加到集合中，你可以对集合元素做增删操作，但每个元素都必须算出后存放在内存里。</p><p>&emsp;&emsp;流则只是概念上的固定数据结构，你不能增删元素，它的元素是按需计算的。这是一种生产者——消费者关系，流也可以看作是一个延迟创建的集合：只有消费者要求时才会计算值（需求驱动，实时制造）。集合则是急切创建的（供应商驱动）。比如我们需要创建一个所有质数的集合，质数是无穷无尽的，所以这个质数集合我们永远也拿不到。另一个例子是查询分页，集合就是我把所有元素都返回给用户，流则是根据需求返回优先级最高的一页数据。</p><h3 id="只能遍历一次"><a href="#只能遍历一次" class="headerlink" title="只能遍历一次"></a><strong>只能遍历一次</strong></h3><p>&emsp;&emsp;流和迭代器一样，只能遍历一次。如果还需要重新遍历就需要从数据源再重新获取一个新流，当然这里指的是集合之类可以重复的源，而不是I/O通道。</p><figure class="highlight pf"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Stream s = menu.stream();</span><br><span class="line">s.<span class="keyword">for</span>Each(System.<span class="keyword">out</span>::println);</span><br><span class="line">s.<span class="keyword">for</span>Each(System.<span class="keyword">out</span>::println);</span><br></pre></td></tr></table></figure><p>&emsp;&emsp;执行后抛出异常: stream has already been operated upon or closed</p><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Exception <span class="keyword">in</span> thread <span class="string">"main"</span> java<span class="selector-class">.lang</span><span class="selector-class">.IllegalStateException</span>: stream has already been operated upon or closed</span><br><span class="line">at java<span class="selector-class">.util</span><span class="selector-class">.stream</span><span class="selector-class">.AbstractPipeline</span><span class="selector-class">.sourceStageSpliterator</span>(AbstractPipeline<span class="selector-class">.java</span>:<span class="number">279</span>)</span><br><span class="line">at java<span class="selector-class">.util</span><span class="selector-class">.stream</span><span class="selector-class">.ReferencePipeline</span><span class="variable">$Head</span>.forEach(ReferencePipeline<span class="selector-class">.java</span>:<span class="number">580</span>)</span><br><span class="line">at categories<span class="selector-class">.java</span><span class="selector-class">.a7stream</span><span class="selector-class">.Test</span><span class="selector-class">.main</span>(Test<span class="selector-class">.java</span>:<span class="number">31</span>)</span><br></pre></td></tr></table></figure><h3 id="外部迭代和内部迭代"><a href="#外部迭代和内部迭代" class="headerlink" title="外部迭代和内部迭代"></a><strong>外部迭代和内部迭代</strong></h3><p>&emsp;&emsp;集合Collection需要开发者自行去做迭代，叫外部迭代。流则是内部迭代，Stream库帮你做了迭代，并把得到的流值存放起来，你只要声明要做什么即可。</p><figure class="highlight pony"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">List</span>&lt;<span class="type">String</span>&gt; names = <span class="function"><span class="keyword">new</span> <span class="title">ArrayList</span>&lt;&gt;();</span></span><br><span class="line"><span class="function"><span class="comment">//集合通过for-each循环外部迭代</span></span></span><br><span class="line"><span class="function"><span class="title">for</span>(<span class="type">Dish</span> dish : menu)&#123;</span></span><br><span class="line"><span class="function">    <span class="title">names</span>.<span class="title">add</span>(dish.getName());</span></span><br><span class="line"><span class="function">&#125;</span></span><br><span class="line"><span class="function"><span class="comment">//集合通过迭代器做外部迭代</span></span></span><br><span class="line"><span class="function"><span class="title">Iterator</span>&lt;<span class="title">Dish</span>&gt; <span class="title">iterator</span> = <span class="title">menu</span>.<span class="title">iterator</span>();</span></span><br><span class="line"><span class="function"><span class="title">while</span> (iterator.hasNext())&#123;</span></span><br><span class="line"><span class="function">    <span class="title">Dish</span> <span class="title">d</span> = <span class="title">iterator</span>.<span class="title">next</span>();</span></span><br><span class="line"><span class="function">    <span class="title">names</span>.<span class="title">add</span>(d.getName());</span></span><br><span class="line"><span class="function">&#125;</span></span><br><span class="line"><span class="function"><span class="comment">//流内部迭代</span></span></span><br><span class="line"><span class="function"><span class="title">names</span> = <span class="title">menu</span>.<span class="title">stream</span>().<span class="title">map</span>(<span class="type">Dish</span>::getName).<span class="title">collect</span>(<span class="type">Collectors</span>.toList());</span></span><br></pre></td></tr></table></figure><p>&emsp;&emsp;我们设想一个应用场景，你需要女儿把地上的玩具收回箱子。如果是外部迭代，你需要一个个的指示她去整理所有玩具，需要显式的取出每个项目进行处理。如果是内部迭代，她可以选择一手拿一个，也可以自己决定先拿离盒子较近的玩具，而你只需要告诉她把所有的玩具收回箱子即可。流的内部迭代可以自动选择一种适合你硬件的数据表示和并行实现，而集合就需要你自己手动来处理所有的并行问题。</p><p><img src="https://pic-1258215793.cos.ap-shanghai.myqcloud.com/content/20190901/201909010113.png" alt="内部迭代与外部迭代"></p><hr><h2 id="第四节-流的操作"><a href="#第四节-流的操作" class="headerlink" title="第四节 流的操作"></a><strong>第四节 流的操作</strong></h2><p>&emsp;&emsp;可以连接起来的流操作称为<strong>中间操作</strong>，关闭流的操作叫<strong>终端操作</strong>。</p><blockquote><ul><li>一个数据源来执行一个查询</li><li>一个中间操作链，形成一条流水线</li><li>一个终端操作，执行流水线，并能生成结果</li></ul></blockquote><h3 id="中间操作"><a href="#中间操作" class="headerlink" title="中间操作"></a><strong>中间操作</strong></h3><p>&emsp;&emsp;除非流水线触发一个终端操作，否则中间操作不会执行任何处理，中间操作可以合并起来，在终端操作时一次性处理。</p><p><img src="https://pic-1258215793.cos.ap-shanghai.myqcloud.com/content/20190901/201909010114.png" alt="中间操作与终端操作"></p><p>&emsp;&emsp;可以尝试在中间操作中添加打印，观察执行顺序。</p><figure class="highlight gauss"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//打印每个操作</span></span><br><span class="line">List&lt;<span class="keyword">String</span>&gt; delayNames = menu.stream() <span class="comment">//从集合获得流，准备创建流水线</span></span><br><span class="line">        .filter(d -&gt; &#123;</span><br><span class="line">            <span class="keyword">System</span>.out.println(<span class="string">"filtering"</span> + d.<span class="built_in">getName</span>());</span><br><span class="line">            <span class="keyword">return</span> d.getCalories() &gt; <span class="number">300</span>;</span><br><span class="line">        &#125;) <span class="comment">//筛选高热量的菜肴</span></span><br><span class="line">        .map(d -&gt; &#123;</span><br><span class="line">            <span class="keyword">System</span>.out.println(<span class="string">"maping"</span> + d.<span class="built_in">getName</span>());</span><br><span class="line">            <span class="keyword">return</span> d.<span class="built_in">getName</span>();</span><br><span class="line">        &#125;) <span class="comment">//获取菜名</span></span><br><span class="line">        .limit(<span class="number">3</span>) <span class="comment">//只选择头三个</span></span><br><span class="line">        .collect(Collectors.toList()); <span class="comment">//将结果存在另一个List中</span></span><br><span class="line"><span class="keyword">System</span>.out.println(threeHighCaloricDishNames);</span><br></pre></td></tr></table></figure><p>&emsp;&emsp;打印结果如下，可以发现Java通过流的延迟性质进行了多个优化：(1)通过limit操作和短路技巧可以只取前3个元素。(2)循环合并技术把filter和map操作合并到同一次遍历中了。</p><figure class="highlight armasm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="symbol">filtering</span> pork</span><br><span class="line"><span class="symbol">maping</span> pork</span><br><span class="line"><span class="symbol">filtering</span> <span class="keyword">beef</span></span><br><span class="line"><span class="keyword">maping </span><span class="keyword">beef</span></span><br><span class="line"><span class="keyword">filtering </span>chicken</span><br><span class="line"><span class="symbol">maping</span> chicken</span><br><span class="line">[pork, <span class="keyword">beef, </span>chicken]</span><br></pre></td></tr></table></figure><table><thead><tr><th style="text-align:left">操作</th><th style="text-align:left">类型</th><th style="text-align:left">返回类型</th><th style="text-align:left">操作参数</th><th style="text-align:left">函数描述符</th></tr></thead><tbody><tr><td style="text-align:left">filter</td><td style="text-align:left">中间</td><td style="text-align:left">Stream<t></t></td><td style="text-align:left">Predicate<t></t></td><td style="text-align:left">T -&gt; boolean</td></tr><tr><td style="text-align:left">map</td><td style="text-align:left">中间</td><td style="text-align:left">Stream<r></r></td><td style="text-align:left">Function&lt;T, R&gt;</td><td style="text-align:left">T -&gt; R</td></tr><tr><td style="text-align:left">limit</td><td style="text-align:left">中间</td><td style="text-align:left">Stream<t></t></td><td style="text-align:left">long maxSize</td><td style="text-align:left"></td></tr><tr><td style="text-align:left">sorted</td><td style="text-align:left">中间</td><td style="text-align:left">Stream<t></t></td><td style="text-align:left">Comparator<t></t></td><td style="text-align:left">(T, T) -&gt; int</td></tr><tr><td style="text-align:left">peek</td><td style="text-align:left">中间</td><td style="text-align:left">Stream<t></t></td><td style="text-align:left">Consumer<t></t></td><td style="text-align:left">T -&gt; void</td></tr><tr><td style="text-align:left">distinct</td><td style="text-align:left">中间</td><td style="text-align:left">Stream<t></t></td><td style="text-align:left"></td><td style="text-align:left"></td></tr><tr><td style="text-align:left">skip</td><td style="text-align:left">中间</td><td style="text-align:left">Stream<t></t></td><td style="text-align:left">long n</td><td style="text-align:left"></td></tr><tr><td style="text-align:left">mapToInt</td><td style="text-align:left">中间</td><td style="text-align:left">IntStream</td><td style="text-align:left">ToIntFunction<t></t></td><td style="text-align:left">T -&gt; int</td></tr><tr><td style="text-align:left">mapToLong</td><td style="text-align:left">中间</td><td style="text-align:left">LongStream</td><td style="text-align:left">ToLongFunction<t></t></td><td style="text-align:left">T -&gt; long</td></tr><tr><td style="text-align:left">mapToDouble</td><td style="text-align:left">中间</td><td style="text-align:left">DoubleStream</td><td style="text-align:left">ToDoubleFunction<t></t></td><td style="text-align:left">T -&gt; double</td></tr><tr><td style="text-align:left">flatMap</td><td style="text-align:left">中间</td><td style="text-align:left">Stream<r></r></td><td style="text-align:left">Function&lt;T, Stream<r>&gt;</r></td><td style="text-align:left">T -&gt; R</td></tr><tr><td style="text-align:left">flatMapToInt</td><td style="text-align:left">中间</td><td style="text-align:left">IntStream</td><td style="text-align:left">Function&lt;T, IntStream&gt;</td><td style="text-align:left">T -&gt; int</td></tr><tr><td style="text-align:left">flatMapToLong</td><td style="text-align:left">中间</td><td style="text-align:left">LongStream</td><td style="text-align:left">Function&lt;T, LongStream&gt;</td><td style="text-align:left">T -&gt; long</td></tr><tr><td style="text-align:left">flatMapToDouble</td><td style="text-align:left">中间</td><td style="text-align:left">DoubleStream</td><td style="text-align:left">Function&lt;T, DoubleStream&gt;</td><td style="text-align:left">T -&gt; double</td></tr></tbody></table><h3 id="终端操作"><a href="#终端操作" class="headerlink" title="终端操作"></a><strong>终端操作</strong></h3><p>&emsp;&emsp;终端操作会从流水线生成非流的结果，如List、Integer、void等。</p><table><thead><tr><th style="text-align:left">操作</th><th style="text-align:left">类型</th><th style="text-align:left">目的</th></tr></thead><tbody><tr><td style="text-align:left">forEach</td><td style="text-align:left">终端</td><td style="text-align:left">消费流中的每个元素并对其应用Lambda，返回void</td></tr><tr><td style="text-align:left">count</td><td style="text-align:left">终端</td><td style="text-align:left">返回流中元素的个数，返回long</td></tr><tr><td style="text-align:left">collect</td><td style="text-align:left">终端</td><td style="text-align:left">把流归约为集合，如List、Map甚至Integer</td></tr></tbody></table><hr><p><em>参考博客和文章书籍等：</em></p><blockquote><p>《Java8实战》</p></blockquote><p><em>因博客主等未标明不可引用，若部分内容涉及侵权请及时告知，我会尽快修改和删除相关内容</em></p>]]></content>
    
    <summary type="html">
    
      介绍Java 8中加入的流——第一节，内容包括：引文(为什么有了集合还需要流、流解决了集合的两个问题、流的优点)，流简介(stream和parallelStream、流是什么)，流和集合(只能遍历一次、外部迭代和内部迭代)，流的操作(中间操作、终端操作)
    
    </summary>
    
      <category term="技术文档" scheme="http://linyishui.top/categories/%E6%8A%80%E6%9C%AF%E6%96%87%E6%A1%A3/"/>
    
    
      <category term="java" scheme="http://linyishui.top/tags/java/"/>
    
      <category term="stream" scheme="http://linyishui.top/tags/stream/"/>
    
  </entry>
  
  <entry>
    <title>默认方法</title>
    <link href="http://linyishui.top/2019092101.html"/>
    <id>http://linyishui.top/2019092101.html</id>
    <published>2019-09-21T03:13:17.000Z</published>
    <updated>2019-12-05T06:39:04.400Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="默认方法"><a href="#默认方法" class="headerlink" title="默认方法"></a><strong>默认方法</strong></h1><h2 id="第一节-引文"><a href="#第一节-引文" class="headerlink" title="第一节 引文"></a><strong>第一节 引文</strong></h2><p>&emsp;&emsp;Java程序的接口是将相关方法按照约定组合到一起的方式，实现接口的类必须为接口中定义的每一个方法提供实现，或者从父类继承实现。这样如果设计者需要更新接口，向其中加入新的方法，就会引起一些问题，因为大部分实现类并不由设计者所管控，但实现类必须为了适配接口的更新而修改。</p><p>&emsp;&emsp;你可以选择为API创建不同的发布版本，同时维护老版本和新版本。但这种做法增加了作为类库设计者维护类库的复杂度，类库的用户也不得不同时使用一套代码的两个版本，且这会增加内存的消耗，延长程序的载入时间，因为这种方式下项目使用的类文件数量更多了。</p><p>&emsp;&emsp;为了解决上述问题，Java 8支持<strong>在接口声明方法的同时提供实现</strong>。第一，接口内可以声明静态方法；第二，引入新功能——默认方法，可以指定接口方法的默认实现。默认方法的设计初衷是为了支持库设计师，为了以更兼容的方式解决像Java API这样的类库的演进问题，辅助他们写出更容易改进的接口。</p><p><img src="https://pic-1258215793.cos.ap-shanghai.myqcloud.com/content/20190901/201909010141.png" alt="向接口添加方法"></p><p>&emsp;&emsp;比如在Java 8之前，List是没有stream()或parallelStream()方法的，List所继承的Collection<t>接口也没有。那么对于设计者而言，最简单的做法就是把stream()方法加入Collection接口，并加入ArrayList类的实现。但这样的更新使Collection接口多出一个方法，以前版本中会有大量依照Collection接口而扩展的实体类，他们就必须都实现stream()方法，那么<strong>怎样才能改变已发布的接口而不用破坏已有的实现呢</strong>？</t></p><figure class="highlight livescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">List&lt;Student&gt; students1 = inventory.stream<span class="function"><span class="params">()</span>.<span class="title">filter</span><span class="params">((Student s) -&gt; s.getAge() &gt; <span class="number">18</span>)</span></span></span><br><span class="line"><span class="function">                                   .<span class="title">collect</span><span class="params">(toList())</span>;</span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function"><span class="title">List</span>&lt;<span class="title">Student</span>&gt; <span class="title">students2</span> = <span class="title">inventory</span>.<span class="title">parallelStream</span><span class="params">()</span>.<span class="title">filter</span><span class="params">((Student s) -&gt; s.getAge() &gt; <span class="number">18</span>)</span></span></span><br><span class="line"><span class="function">                                   .<span class="title">collect</span><span class="params">(toList())</span>;</span></span><br></pre></td></tr></table></figure><p>&emsp;&emsp;Java 8采用的做法就是<strong>允许接口包含实现类没有提供实现的方法签名，缺失的这些方法由接口来完成实现</strong>。所以<strong>Java 8提供了default关键字来在接口中实现默认方法</strong>。</p><figure class="highlight processing"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//List源码中sort方法的默认实现</span></span><br><span class="line"><span class="keyword">default</span> <span class="keyword">void</span> <span class="built_in">sort</span>(Comparator&lt;? <span class="keyword">super</span> E&gt; c) &#123;</span><br><span class="line">    <span class="keyword">Object</span>[] a = <span class="keyword">this</span>.toArray();</span><br><span class="line">    Arrays.<span class="built_in">sort</span>(a, (Comparator) c);</span><br><span class="line">    ListIterator&lt;E&gt; i = <span class="keyword">this</span>.listIterator();</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">Object</span> e : a) &#123;</span><br><span class="line">        i.next();</span><br><span class="line">        i.<span class="built_in">set</span>((E) e);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>&emsp;&emsp;类可以实现多个接口，当默认实现冲突时，Java有一套处理和限制来避免类似C++的菱形继承问题。</p><blockquote><p>抽象类和抽象接口的区别？</p><ul><li>一个类只能继承一个抽象类，但一个类可以实现多个接口</li><li>一个抽象类可以通过实例变量保存一个通用状态，而接口不能有实例变量</li></ul></blockquote><hr><h2 id="第二节-使用默认方法"><a href="#第二节-使用默认方法" class="headerlink" title="第二节 使用默认方法"></a><strong>第二节 使用默认方法</strong></h2><h3 id="可选方法"><a href="#可选方法" class="headerlink" title="可选方法"></a><strong>可选方法</strong></h3><p>&emsp;&emsp;类实现了接口，但会刻意的将一些方法的实现留白，如Iterator接口的remove方法，Java 8以前因为用户很少使用，所以remove常被忽略，实现Iterator接口的类通常会为此方法放置一个空的实现。</p><p>&emsp;&emsp;采用默认方法后，刻意为这种类型的方法提供一个默认实现，实体类就无需再重复的提供一个空方法。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">default</span> <span class="keyword">void</span> <span class="title">remove</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> UnsupportedOperationException(<span class="string">"remove"</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="行为的多继承"><a href="#行为的多继承" class="headerlink" title="行为的多继承"></a><strong>行为的多继承</strong></h3><p>&emsp;&emsp;行为的多继承，一种让类从多个来源重用代码的能力。Java的类只能单继承，但却可以多实现。而因为接口方法允许提供默认实现，所以类也可以从类型继承中继承接口行为。</p><p><img src="https://pic-1258215793.cos.ap-shanghai.myqcloud.com/content/20190901/201909010142.png" alt="单继承和多继承的比较"></p><p>&emsp;&emsp;假设有需求需要为游戏定义多个具有不同特性的形状，有的形状需要调整大小，有的需要旋转，有的需要旋转和移动等等，实现代码如下。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 可旋转</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Rotatable</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">setRotationAngle</span><span class="params">(<span class="keyword">int</span> angleInDegress)</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">getRotationAngle</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">default</span> <span class="keyword">void</span> <span class="title">rotateBy</span><span class="params">(<span class="keyword">int</span> angleInDegress)</span></span>&#123;</span><br><span class="line">        setRotationAngle((getRotationAngle() + angleInDegress) % <span class="number">360</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 可移动</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Moveable</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">getX</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">getY</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">setX</span><span class="params">(<span class="keyword">int</span> x)</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">setY</span><span class="params">(<span class="keyword">int</span> y)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">default</span> <span class="keyword">void</span> <span class="title">moveHorizontally</span><span class="params">(<span class="keyword">int</span> distance)</span></span>&#123;</span><br><span class="line">        setX(getX() + distance);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">default</span> <span class="keyword">void</span> <span class="title">moveVertically</span><span class="params">(<span class="keyword">int</span> distance)</span></span>&#123;</span><br><span class="line">        setY(getY() + distance);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 可调整大小</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Resizeable</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">getWidth</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">getHeight</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">setWidth</span><span class="params">(<span class="keyword">int</span> width)</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">setHeight</span><span class="params">(<span class="keyword">int</span> height)</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">setAbsoluteSize</span><span class="params">(<span class="keyword">int</span> width, <span class="keyword">int</span> height)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">default</span> <span class="keyword">void</span> <span class="title">setRelativeSize</span><span class="params">(<span class="keyword">int</span> wFactor, <span class="keyword">int</span> hFactor)</span></span>&#123;</span><br><span class="line">        setAbsoluteSize(getWidth() / wFactor, getHeight() / hFactor);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 可移动、旋转和缩放</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Monster</span> <span class="keyword">implements</span> <span class="title">Rotatable</span>,<span class="title">Moveable</span>,<span class="title">Resizeable</span></span>&#123;</span><br><span class="line">    ......</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 可移动和旋转</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Sun</span> <span class="keyword">implements</span> <span class="title">Moveable</span>,<span class="title">Rotatable</span> </span>&#123;</span><br><span class="line">    ......</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Monster m = <span class="keyword">new</span> Monster();</span><br><span class="line">        m.rotateBy(<span class="number">180</span>);</span><br><span class="line">        m.moveVertically(<span class="number">10</span>);</span><br><span class="line">        Sun sun = <span class="keyword">new</span> Sun();</span><br><span class="line">        sun.moveHorizontally(<span class="number">100</span>);</span><br><span class="line">        sun.rotateBy(<span class="number">6</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="https://pic-1258215793.cos.ap-shanghai.myqcloud.com/content/20190901/201909010143.png" alt="多种行为的组合"></p><p>&emsp;&emsp;通过组合接口Rotatable、Moveable、Resizeable可以创建不同的实现类，需要实现定义的抽象方法，无需重复实现默认方法。</p><p>&emsp;&emsp;继承不是适合所有代码复用场景的万能钥匙，比如一个复杂类的继承就不是好的选择，而是应该通过代理，即创建一个方法通过该类的成员变量直接调用该类的方法。这也是为什么有时我们会声明一个类的类型为final：声明为final的类无法被其他类继承，避免发生这样的反模式，防止核心代码的功能被污染。这样的思想也适用于使用默认方法的接口，我们只需选择需要的实现即可。</p><hr><h2 id="第三节-解决冲突的规则"><a href="#第三节-解决冲突的规则" class="headerlink" title="第三节 解决冲突的规则"></a><strong>第三节 解决冲突的规则</strong></h2><p>&emsp;&emsp;一个类继承了多个使用同样函数签名的方法，如何选择使用的函数？</p><p>&emsp;&emsp;如下列代码，类C继承了接口A和B的同名方法，最终会选择哪个？</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">A</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">default</span> <span class="keyword">void</span> <span class="title">hello</span><span class="params">()</span></span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"Hello from A"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">B</span> <span class="keyword">extends</span> <span class="title">A</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">default</span> <span class="keyword">void</span> <span class="title">hello</span><span class="params">()</span></span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"Hello from B"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">C</span> <span class="keyword">implements</span> <span class="title">A</span>,<span class="title">B</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">new</span> C().hello();<span class="comment">//Hello from B</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="解决冲突的三个规则"><a href="#解决冲突的三个规则" class="headerlink" title="解决冲突的三个规则"></a><strong>解决冲突的三个规则</strong></h3><p>&emsp;&emsp;如果一个类使用相同的函数签名从多个地方继承了方法，通过三条规则可以进行判断。</p><blockquote><p>如何判断相同签名方法选择优先级？</p><ol><li>类中的方法优先级最高。类或父类中声明的方法优先级高于任何声明为默认方法的优先级。</li><li>如果无法依据第一条进行判断，则子接口的优先级更高：函数签名相同时，优先选择拥有最具体实现的默认方法的接口，即如果B继承了A，则B比A更具体。</li><li>最后还是无法判断，则继承了多个接口的类必须通过显式覆盖和调用期望的方法，显式的选择使用哪一个默认方法的实现。</li></ol></blockquote><p>&emsp;&emsp;所以对于上述代码案例，同样是默认方法，会优先选择接口B中的方法。</p><h3 id="冲突及如何显式的消除歧义"><a href="#冲突及如何显式的消除歧义" class="headerlink" title="冲突及如何显式的消除歧义"></a><strong>冲突及如何显式的消除歧义</strong></h3><p>&emsp;&emsp;如果前两条规则都无法判断优先级时，Java编译器会抛出一个编译错误，因为编译器无法判断应该选择哪个方法。解决这种冲突没有太多的方案，只能显式的决定希望使用哪一种方法，所以可以在类C中覆盖hello方法，在它的方法体内显式的调用希望调用的方法。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">A</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">default</span> <span class="keyword">void</span> <span class="title">hello</span><span class="params">()</span></span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"Hello from A"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">BB</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">default</span> <span class="keyword">void</span> <span class="title">hello</span><span class="params">()</span></span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"Hello from BB"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">E</span> <span class="keyword">implements</span> <span class="title">A</span>,<span class="title">BB</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">hello</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        BB.<span class="keyword">super</span>.hello();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">       <span class="keyword">new</span> E().hello();<span class="comment">//Hello from BB</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>&emsp;&emsp;Java 8引入了一种新的语法：X.super.m(…)，X是希望调用的m方法所在的父接口。</p><h3 id="菱形继承问题"><a href="#菱形继承问题" class="headerlink" title="菱形继承问题"></a><strong>菱形继承问题</strong></h3><p>&emsp;&emsp;如下述代码所描绘情况，因为类的继承关系图形像菱形所以被称作菱形问题。下列情况最终选择的必然是接口A的hello方法，如果B接口也实现了hello方法，则因为B更具体所以会选择B的hello方法。如果C也实现了hello方法，就出现了冲突，需要显式的指定要使用的方法。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">A</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">default</span> <span class="keyword">void</span> <span class="title">hello</span><span class="params">()</span></span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"Hello from A"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">B</span> <span class="keyword">extends</span> <span class="title">A</span> </span>&#123;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">C</span> <span class="keyword">extends</span> <span class="title">A</span> </span>&#123;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">D</span> <span class="keyword">implements</span> <span class="title">B</span>, <span class="title">C</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">new</span> D().hello();<span class="comment">//Hello from A</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="https://pic-1258215793.cos.ap-shanghai.myqcloud.com/content/20190901/201909010144.png" alt="菱形问题"></p><hr><p><em>参考博客和文章书籍等：</em></p><blockquote><p>《Java8实战》</p></blockquote><p><em>因博客主等未标明不可引用，若部分内容涉及侵权请及时告知，我会尽快修改和删除相关内容</em></p>]]></content>
    
    <summary type="html">
    
      介绍Java 8引入的默认方法，内容包括：引文，使用默认方法（可选方法、行为的多继承），解决冲突的规则（解决冲突的三个规则、冲突及如何显式的消除歧义、菱形继承问题）等内容。
    
    </summary>
    
      <category term="技术文档" scheme="http://linyishui.top/categories/%E6%8A%80%E6%9C%AF%E6%96%87%E6%A1%A3/"/>
    
    
      <category term="java" scheme="http://linyishui.top/tags/java/"/>
    
      <category term="stream" scheme="http://linyishui.top/tags/stream/"/>
    
  </entry>
  
  <entry>
    <title>行为参数化</title>
    <link href="http://linyishui.top/2019092001.html"/>
    <id>http://linyishui.top/2019092001.html</id>
    <published>2019-09-20T06:52:26.000Z</published>
    <updated>2019-12-05T03:08:08.807Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="行为参数化"><a href="#行为参数化" class="headerlink" title="行为参数化"></a><strong>行为参数化</strong></h1><p>&emsp;&emsp;行为参数化是一种开发模式，Lambda只是提供了更简洁的实现方式，让旧版本通过类和接口的实现方式变得更方便罢了。</p><h2 id="意义"><a href="#意义" class="headerlink" title="意义"></a><strong>意义</strong></h2><p>&emsp;&emsp;应对频繁变更的需求：行为参数化意味着可以准备一段代码，并推迟它的执行，比如可以当作参数传递给另一个方法，等到需要时再执行。</p><hr><h2 id="旧版本实现行为参数化"><a href="#旧版本实现行为参数化" class="headerlink" title="旧版本实现行为参数化"></a><strong>旧版本实现行为参数化</strong></h2><p>&emsp;&emsp;如书中苹果集合筛选实例，客户从颜色开始提出需求，再到重量等，每个需求我们都需要实现一个filter。你可能会想，还是有办法只用一个filter的，于是你实现了filter(List<apple> inventory, String color, int weight, …)，但这并不能根本解决问题，比如需求变更为根据不同场景筛选对应的属性，或是组合多个属性进行复杂查询，又该如何减少重复代码呢？</apple></p><p>&emsp;&emsp;我们可以对苹果的筛选标准建模，定义一个<strong>谓词</strong>，返回一个boolean值。</p><figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">public<span class="built_in"> interface </span>ApplePredicate&#123;</span><br><span class="line">    boolean test(Apple apple);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>&emsp;&emsp;所以我们可以根据需求去扩展ApplePredicate的实现，不同的筛选策略就实现对应的代码。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">AppleHeavyWeightPredicate</span> <span class="keyword">implements</span> <span class="title">ApplePredicate</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">test</span><span class="params">(Apple apple)</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> apple.getWeight() &gt; <span class="number">150</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">......</span><br></pre></td></tr></table></figure><p>&emsp;&emsp;我们把这些不同的策略看作是filter方法的不同行为，这类似于<strong>策略设计模式</strong>，我们可以封装一些算法，在运行时再去选择一个执行。ApplePredicate就是算法族，AppleHeavyWeightPredicate等就是不同策略。</p><p>&emsp;&emsp;下一步我们需要filterApples()方法能接收ApplePredicate对象，这就是行为参数化：<strong>让方法接受多种行为（策略）作为参数，并在内部使用，来完成不同的行为</strong>。</p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">List</span>&lt;Apple&gt; filterApples(<span class="keyword">List</span>&lt;Apple&gt; inventory, ApplePredicate p)&#123;</span><br><span class="line">    <span class="keyword">List</span>&lt;Student&gt; result = <span class="keyword">new</span> ArrayList();</span><br><span class="line">    <span class="keyword">for</span>(Apple apple : inventory)&#123;</span><br><span class="line">        <span class="keyword">if</span>(p.test(apple))&#123;</span><br><span class="line">            result.add(apple);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>&emsp;&emsp;上述过程中我们已经做到了让filterApples()方法根据我们定义ApplePredicate对象传递的代码来选择行为，实际上就已经做到了行为参数化。</p><p>&emsp;&emsp;我们发现<strong>解决不断变更的需求这一问题时，通过把迭代集合这一行为和筛选逻辑判断行为进行了分离，随着需求而变的行为作为参数传递选择，从而通过重复使用一个方法来应对变化的需求</strong>。</p><hr><h2 id="对行为参数化进行优化"><a href="#对行为参数化进行优化" class="headerlink" title="对行为参数化进行优化"></a><strong>对行为参数化进行优化</strong></h2><p>&emsp;&emsp;因为filterApples()方法只能接受对象，所以我们传递的代码只能包装在对象中，但Java 8后就可以通过Lambda，直接把apple.getWeight() &gt; 150;这种表达式直接传递给filterApples()方法，而不用构建多个ApplePredicate对象。</p><h3 id="匿名类"><a href="#匿名类" class="headerlink" title="匿名类"></a><strong>匿名类</strong></h3><p>&emsp;&emsp;熟悉Java的人可能会想到匿名类好像就可以解决重复创建ApplePredicate对象的问题，因为它可以随用随建。</p><figure class="highlight lisp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">List&lt;Student&gt; result = filterApples(<span class="name">inventory</span>, new ApplePredicate()&#123;</span><br><span class="line">    public boolean test(<span class="name">Apple</span> apple)&#123;</span><br><span class="line">        return apple.getWeight() &gt; <span class="number">150</span><span class="comment">;</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;)<span class="comment">;</span></span><br></pre></td></tr></table></figure><p>&emsp;&emsp;但匿名类仍存在一些缺点：1.它不太简洁。2.它让用户觉得难以理解。匿名类虽然解决了为ApplePredicate接口构建实体类的问题，但实际上仍需要创建这些对象，实际上并没有彻底的解决啰嗦的问题。</p><h3 id="Lambda表达式"><a href="#Lambda表达式" class="headerlink" title="Lambda表达式"></a><strong>Lambda表达式</strong></h3><p>&emsp;&emsp;Lambda表达式的实现如下，彻底解决了啰嗦问题。</p><figure class="highlight lisp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">List&lt;Student&gt; result = filterApples(<span class="name">inventory</span>, (<span class="name">Apple</span> a) -&gt; apple.getWeight() &gt; <span class="number">150</span>)<span class="comment">;</span></span><br></pre></td></tr></table></figure><p><img src="https://pic-1258215793.cos.ap-shanghai.myqcloud.com/content/20190901/201909010106.png" alt="行为参数化与值参数化"></p><h3 id="泛型"><a href="#泛型" class="headerlink" title="泛型"></a><strong>泛型</strong></h3><p>&emsp;&emsp;通过泛型进一步抽象，让filterApples()能够适用更多的对象。</p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> &lt;T&gt; <span class="keyword">List</span>&lt;T&gt; filter(<span class="keyword">List</span>&lt;T&gt; <span class="keyword">list</span>, Predicate&lt;T&gt; p)&#123;</span><br><span class="line">    <span class="keyword">List</span>&lt;Student&gt; result = <span class="keyword">new</span> ArrayList();</span><br><span class="line">    <span class="keyword">for</span>(T e : <span class="keyword">list</span>)&#123;</span><br><span class="line">        <span class="keyword">if</span>(p.test(e))&#123;</span><br><span class="line">            result.add(e);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><p><em>参考博客和文章书籍等：</em></p><blockquote><p>《Java8实战》</p></blockquote><p><em>因博客主等未标明不可引用，若部分内容涉及侵权请及时告知，我会尽快修改和删除相关内容</em></p>]]></content>
    
    <summary type="html">
    
      简单介绍了行为参数化这一概念，行为参数化的意义，在Java 8版本前如何实现行为参数化，Java 8又对行为参数化提供了哪些支持等。
    
    </summary>
    
      <category term="技术文档" scheme="http://linyishui.top/categories/%E6%8A%80%E6%9C%AF%E6%96%87%E6%A1%A3/"/>
    
    
      <category term="java" scheme="http://linyishui.top/tags/java/"/>
    
  </entry>
  
  <entry>
    <title>Java8的新特性</title>
    <link href="http://linyishui.top/2019091901.html"/>
    <id>http://linyishui.top/2019091901.html</id>
    <published>2019-09-19T01:35:44.000Z</published>
    <updated>2019-12-06T07:20:03.185Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="Java8的新特性"><a href="#Java8的新特性" class="headerlink" title="Java8的新特性"></a><strong>Java8的新特性</strong></h1><h2 id="第一节-引文"><a href="#第一节-引文" class="headerlink" title="第一节 引文"></a><strong>第一节 引文</strong></h2><p>&emsp;&emsp;Java 8是改动较大的一个版本，新增了Lambda表达式、函数式编程、流等，当然也有一些其他扩充功能的更新。这些变化主要反映了Java从注重改变现有值得经典面向对象思想转变为向函数式编程领域转变。这些改动会很大程度上对开发人员起到帮助，让编程更容易更轻松。</p><p>&emsp;&emsp;对于并发编程来说，Java 1.0时有线程和锁，甚至提供了内存模型，但没有相关专业知识的团队很难可靠的使用这些工具。Java 5时添加了工业级的构建模块，如线程池和并发集合。Java 7时添加了分支/合并（fork/join）框架，使得并行变得更加实用，但依旧会有些困难。Java 8则对并行提供了一个更简单的新思路。</p><hr><h2 id="第二节-三个新的编程概念"><a href="#第二节-三个新的编程概念" class="headerlink" title="第二节 三个新的编程概念"></a><strong>第二节 三个新的编程概念</strong></h2><h3 id="流处理"><a href="#流处理" class="headerlink" title="流处理"></a><strong>流处理</strong></h3><p>&emsp;&emsp;流是一系列数据项，一次只生成一项。程序可以从输入流中一个一个读取数据项，以相同方式将数据项写入输出流。</p><p>&emsp;&emsp;比如在Unix或Linux中，很多程序从标准输入中读取数据（Unix和C中的stdin，Java中的System.in），然后把结果写入标准输出（Unix和C中的stdout，Java中的System.out）。如下命令，cat会把两个文件连接起来创建一个流，tr会转换流中的字符，sort会对流中的行进行排序，trail -3则会给出流的最后三行。Unix允许这些程序通过<strong>管道</strong>（|）连接起来。</p><figure class="highlight coq"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cat file1 file2 | <span class="type">tr</span> <span class="string">"[A-Z]"</span> <span class="string">"[a-z]"</span> | <span class="type">sort</span> | <span class="type">trail</span> <span class="number">-3</span></span><br></pre></td></tr></table></figure><p>&emsp;&emsp;上述语句会先把字母转为小写，然后打印出排序后的最后三个单词。sort会把一个行流作为输入，产生了另一个行流，进行排序并输出。在Unix中，这些命令是同时执行的，就像工厂式的流水线，虽然整个命令序列像是是一步一步完成的，但各个命令的运行是并行的。</p><p>&emsp;&emsp;基于此思想，Java 8在java.util.stream中添加了一个Stream API；可以把Stream<t>看作是一个迭代器，它可以链接起来形成一个流水线。它带来的好处就是我们可以像SQL那样写查询语句的思路，把这样的流转为那样的流，而不是一次只能处理一个项目，而且Java可以很透明的把输入中不相关的部分分开放到几个CPU内核上分别执行，这样自动的并行就省去我们去开辟线程的功夫了。</t></p><h3 id="用行为参数化把代码传递给方法"><a href="#用行为参数化把代码传递给方法" class="headerlink" title="用行为参数化把代码传递给方法"></a><strong>用行为参数化把代码传递给方法</strong></h3><p>&emsp;&emsp;比如我们有一组学生数据，包括其年龄，学期成绩，班级，学号等信息，我们可能有各种排序需求，真正想要的就是通过给sort一个参数让其定义顺序。我们可以写一个函数compareUsingAge来比较学生的年龄，但Java 8之前我们没法把这个方法传递给另一个方法，所以只能创建一个Comparator对象，然后把对象传递给sort方法。而有了行为参数化后，这样的需求就可以简单的实现了，我们可以把compareUsingAge方法作为参数传递给sort。</p><p>&emsp;&emsp;<strong>把代码传递给方法</strong>这种方式简洁的表达了<strong>行为参数化</strong>，也许你会想可以通过<strong>匿名类</strong>实现行为参数化，但Lambda和方法引用可以更清晰和简单的来实现这一需求。</p><h3 id="并行与共享的可变数据"><a href="#并行与共享的可变数据" class="headerlink" title="并行与共享的可变数据"></a><strong>并行与共享的可变数据</strong></h3><p>&emsp;&emsp;如果我们的代码可以拆分为多个副本并独立工作时，并行是可以确保的，但如果要写入一个共享变量或对象，如果两个线程都要同时修改这个变量，就是不能允许的了。当然你可以通过synchronized来打破<strong>不能有共享的可变数据</strong>这一原则，但打破的同时也就意味着放弃了所有相关的优化，同步就意味着要按照顺序执行，这与并行的宗旨相悖。</p><p>&emsp;&emsp;<strong>没有共享的可变数据</strong>，<strong>将代码传递给方法的能力</strong>这两个概念是<strong>函数式编程范式</strong>的基石。而相反的<strong>命令式编程范式</strong>中，程序是一系列改变状态的指令。</p><blockquote><p>Java 8为并行做的优化：</p><ul><li>库会负责分块，把大的流分成几个小的流，以便于并行处理。</li><li>流所提供的这个免费并行，只有在传递给filter之类的库方法的函数不会互动时才能工作。函数式编程中函数的主要意思是函数可以作为一等值，但也隐含着执行时元素间无互动的意思。</li></ul></blockquote><blockquote><p><strong>把代码传递给方法（方法引用、Lambda）和接口中的默认方法这两种特性的补充可以看作是为Stream而设计的</strong>。</p></blockquote><hr><h2 id="第三节-行为参数化"><a href="#第三节-行为参数化" class="headerlink" title="第三节 行为参数化"></a><strong>第三节 行为参数化</strong></h2><p>&emsp;&emsp;<a href="../2019092001.html" title="Title">行为参数化</a></p><hr><h2 id="第四节-默认方法"><a href="#第四节-默认方法" class="headerlink" title="第四节 默认方法"></a><strong>第四节 默认方法</strong></h2><p>&emsp;&emsp;<a href="../2019092101.html" title="Title">默认方法</a></p><hr><h2 id="第五节-Lambda表达式"><a href="#第五节-Lambda表达式" class="headerlink" title="第五节 Lambda表达式"></a><strong>第五节 Lambda表达式</strong></h2><p>&emsp;&emsp;<a href="../2019031802.html" title="Title">Lambda表达式</a></p><hr><h2 id="第六节-流"><a href="#第六节-流" class="headerlink" title="第六节 流"></a><strong>第六节 流</strong></h2><p>&emsp;&emsp;<a href="../2019092201.html" title="Title">流（一）入门介绍</a></p><p>&emsp;&emsp;<a href="../2019092301.html" title="Title">流（二）使用和构建</a></p><p>&emsp;&emsp;<a href="../2019092401.html" title="Title">流（三）收集器</a></p><p>&emsp;&emsp;<a href="../2019092501.html" title="Title">流（四）并行化处理</a></p><hr><h2 id="第七节-重构、测试和调试"><a href="#第七节-重构、测试和调试" class="headerlink" title="第七节 重构、测试和调试"></a><strong>第七节 重构、测试和调试</strong></h2><p>&emsp;&emsp;<a href="../2019092601.html" title="Title">重构、测试和调试</a></p><hr><h2 id="第八节-Optional"><a href="#第八节-Optional" class="headerlink" title="第八节 Optional"></a><strong>第八节 Optional</strong></h2><p>&emsp;&emsp;<a href="../2019092701.html" title="Title">Optional</a></p><hr><h2 id="第九节-CompletableFuture组合式异步编程"><a href="#第九节-CompletableFuture组合式异步编程" class="headerlink" title="第九节 CompletableFuture组合式异步编程"></a><strong>第九节 CompletableFuture组合式异步编程</strong></h2><p>&emsp;&emsp;<a href="../2019092801.html" title="Title">CompletableFuture组合式异步编程</a></p><hr><h2 id="第十节-新的日期和时间API"><a href="#第十节-新的日期和时间API" class="headerlink" title="第十节 新的日期和时间API"></a><strong>第十节 新的日期和时间API</strong></h2><p>&emsp;&emsp;<a href="../2019100101.html" title="Title">新的日期和时间API</a></p><hr><h2 id="第十一节-函数式的思考"><a href="#第十一节-函数式的思考" class="headerlink" title="第十一节 函数式的思考"></a><strong>第十一节 函数式的思考</strong></h2><p>&emsp;&emsp;<a href="../2019100301.html" title="Title">函数式的思考</a></p><hr><h2 id="第十二节-函数式编程的技巧"><a href="#第十二节-函数式编程的技巧" class="headerlink" title="第十二节 函数式编程的技巧"></a><strong>第十二节 函数式编程的技巧</strong></h2><p>&emsp;&emsp;<a href="../2019100401.html" title="Title">函数式编程的技巧</a></p><hr><p><em>参考博客和文章书籍等：</em></p><blockquote><p>《Java8实战》</p></blockquote><p><em>因博客主等未标明不可引用，若部分内容涉及侵权请及时告知，我会尽快修改和删除相关内容</em></p>]]></content>
    
    <summary type="html">
    
      介绍一些Java8的新特性，本篇博客作为系列的目录和引文，内容包括：引文，三个新的编程概念（流处理、用行为参数化把代码传递给方法、并行与共享的可变数据），行为参数化，默认方法，Lambda表达式，流，重构、测试和调试，Optional，CompletableFuture组合式异步编程，新的日期和时间API，函数式的思考，函数式编程的技巧等内容。
    
    </summary>
    
      <category term="技术文档" scheme="http://linyishui.top/categories/%E6%8A%80%E6%9C%AF%E6%96%87%E6%A1%A3/"/>
    
    
      <category term="java" scheme="http://linyishui.top/tags/java/"/>
    
  </entry>
  
  <entry>
    <title>《鸟哥的linux私房菜》读书笔记（三）主机规划与磁盘分区（未完成）</title>
    <link href="http://linyishui.top/2019091801.html"/>
    <id>http://linyishui.top/2019091801.html</id>
    <published>2019-09-18T09:20:59.000Z</published>
    <updated>2019-11-17T13:52:14.001Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="第二章-Linux"><a href="#第二章-Linux" class="headerlink" title="第二章 Linux"></a><strong>第二章 Linux</strong></h1><h2 id="第一节-硬件搭配"><a href="#第一节-硬件搭配" class="headerlink" title="第一节 硬件搭配"></a><strong>第一节 硬件搭配</strong></h2><p>&emsp;&emsp;Linux系统中，每个装置都会当作一个文件来看待。如IDE接口的硬盘文件名为/dev/sd[a-d]，a-d可选任意一个。几乎所有硬件装置文件都在/dev目录中。</p><p><img src="https://pic-1258215793.cos.ap-shanghai.myqcloud.com/content/20190901/201909010104.png" alt="常见装置在Linux中的文件名"></p><p><img src="https://pic-1258215793.cos.ap-shanghai.myqcloud.com/content/20190901/201909010105.png" alt="常见装置在Linux中的文件名"></p><p>&emsp;&emsp;如果Linux所在机器是云端，可能得到的是虚拟机，为了加速，虚拟机中磁盘通过仿真器生成，对应的磁盘文件名为/dev/vd[a-p]系列文件名。</p><hr><h2 id="第二节-磁盘分区"><a href="#第二节-磁盘分区" class="headerlink" title="第二节 磁盘分区"></a><strong>第二节 磁盘分区</strong></h2><p>&emsp;&emsp;Linux系统作为一组程序，自然是要安装在磁盘中的。我们知道常见的磁盘接口有：SATA和SAS接口。近些年大部分的Linux distribution将IDE界面的磁盘文件名仿真成SATA了。虚拟机使用的<strong>虚拟磁盘</strong>并非是正规的磁盘界面，<strong>正常的实体机器基本都使用/dev/sd[a-]的磁盘文件名，而虚拟机环境下，为了加速，可能就会使用/dev/vd[a-p]这种装置文件名</strong>。</p><p>&emsp;&emsp;</p><hr><p><em>参考博客和文章书籍等：</em></p><blockquote><p>《鸟哥的Linux私房菜》</p></blockquote><p><em>因博客主等未标明不可引用，若部分内容涉及侵权请及时告知，我会尽快修改和删除相关内容</em></p>]]></content>
    
    <summary type="html">
    
      整理《鸟哥的linux私房菜》读书笔记（三）主机规划与磁盘分区，内容包括：等内容。
    
    </summary>
    
      <category term="技术文档" scheme="http://linyishui.top/categories/%E6%8A%80%E6%9C%AF%E6%96%87%E6%A1%A3/"/>
    
    
      <category term="unfinished" scheme="http://linyishui.top/tags/unfinished/"/>
    
      <category term="os" scheme="http://linyishui.top/tags/os/"/>
    
      <category term="linux" scheme="http://linyishui.top/tags/linux/"/>
    
  </entry>
  
  <entry>
    <title>《鸟哥的linux私房菜》读书笔记（二）Linux简介</title>
    <link href="http://linyishui.top/2019091701.html"/>
    <id>http://linyishui.top/2019091701.html</id>
    <published>2019-09-17T03:20:42.000Z</published>
    <updated>2019-11-15T09:07:21.934Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="第二章-Linux"><a href="#第二章-Linux" class="headerlink" title="第二章 Linux"></a><strong>第二章 Linux</strong></h1><h2 id="第一节-引文"><a href="#第一节-引文" class="headerlink" title="第一节 引文"></a><strong>第一节 引文</strong></h2><p>&emsp;&emsp;Linux就是一套操作系统，也就是核心和系统呼叫接口两层。操作系统是针对特定的硬件平台开发，所以不同的硬件平台自然无法运行一套操作系统，跨平台需要移植，Linux具有可移植性，是开源的操作系统。</p><p><img src="https://pic-1258215793.cos.ap-shanghai.myqcloud.com/content/20190901/201909010101.png" alt="操作系统的角色"></p><p>&emsp;&emsp;Linux从Unix沿袭了一个完整的操作系统中最底层的硬件控制与资源管理的完整架构，非常稳定和强大。</p><hr><h2 id="第二节-历史"><a href="#第二节-历史" class="headerlink" title="第二节 历史"></a><strong>第二节 历史</strong></h2><p>&emsp;&emsp;1969年，贝尔实验室的员工Ken Thompson以汇编语言写出了一组<strong>核心程序</strong>，以及一个小的<strong>文件系统</strong>。这个文件系统有两个重要的概念：<strong>（1）所有的程序或系统装置都是文件。（2）不管建构编辑器还是附属文件，所写的程序只有一个目的，且要有效的完成目标</strong>。这些概念对后续Linux的发展有很重要的影响。</p><p>&emsp;&emsp;1973年，Unix正式诞生，最开始Tompson和Ritchie合作用高阶语言：B语言来撰写，但实现出的核心效能并不好，后来Ritchie用C语言重新改写和编译Unics的核心，最后发行Unix的正式版本。</p><p>&emsp;&emsp;1977年，Unix分支–<strong>BSD</strong>诞生。1973年后Unix便和学术界进行了合作，加州伯克利大学的Bill Joy对Unix进行了移植，修改为实验室机器适合的版本，并增加了许多工具软件和编译程序，最终命名为Berkeley Software Distribution(BSD)。Bill Joy也是Sun公司的创办者。Unix具有高度可移植性和强大的效能，再加上当时并没有太多版权的纠纷，所以市场上出现了很多商业公司自家的Unix系统。在这个阶段各个公司还没有制定协议的概念，硬件各不相同所以开发出的Unix系统以及相关软件也无法在其他平台使用。</p><p>&emsp;&emsp;1979年，AT&amp;T推出System V第七版Unix，终于有了可以支持x86架构的个人计算机系统。但AT&amp;T在这一代尝试收回Unix版权，特别是限制了不可对学生提供源代码。</p><p>&emsp;&emsp;1984年，Andrew Tanenbaum教授自己手写了Minix这个Unix Like核心程序，为了避免版权纠纷，在开发时他完全脱离了Unix核心源代码，终于在1986年完成。但Minix并不是免费的，它的诞生就是作者为了教学，所以也没有后续的发展和更新。</p><p>&emsp;&emsp;1984年，Richard Mathew Stallman发起了<strong>GNU计划</strong>，对后来的自由和开源软件开启了大门。GNU计划的目的是：<strong>建立一个自由、开放的Unix操作系统</strong>。Stallman从开发免费的Unix程序开始慢慢打响了知名度，然后又撰写了C语言的编译程序：GNU C Compiler(gcc)，在这个过程中他还把写过的Emacs编辑器（可以在编辑时就指出语法的错误）移植到了Unix上，并公布了源代码。Stallman通过Emacs赚到了一定的资金并成立了<strong>自由软件基金会</strong>（FSF，Free Software Foundation），基金会请到了更多的开发者参与终于完成了GCC，之后Stallman还撰写了可以被呼叫的C函式库(GNU C library)，以及可以被使用来操作OS的基本接口BASH shell。</p><p>&emsp;&emsp;1985年，为了避免GNU开发的自由软件被他人注册为专利软件，Stallman和律师草拟了<strong>通用公共许可证</strong>（General Public License，GPL），并称呼为copyleft相比于专利软件的copyright。FSF的核心观念是【<strong>版权只读是促进社会进步的手段，但版权本身不是自然权利</strong>】，自由软件的重点不是指免费，而是指具有自由度的软件，<strong>使用者可以自由的执行、复制、再发行、学习、修改和强化自由软件</strong>。</p><p>&emsp;&emsp;GNU在开发的核心叫hurd，是一款架构非常先进的核心，但开发者对其要求太高，导致一直推迟了发布，也影响了后来Linux的开发。</p><p>&emsp;&emsp;1991年，芬兰的赫尔辛基大学的Linus Torvalds在BBS上贴了一则消息，说他以bash，gcc等GNU工具写了一个小的核心程序，不是GNU那样的专业程序，比较像玩具。但此核心程序可以在Intel的386个人计算机上运作，引起了很多人的兴趣。Torvalds通过学习Minix操作系统学习了核心程序设计的设计概念，但他对个人计算机缺少服务器的<strong>多任务处理能力</strong>不是很满意，所以他测试了很久386的硬件性能。在拿到Minix后，他也发现Minix虽然很棒，但创始人Tanenbaum教授不愿意加强其功能，所以Torvalds就动手开始改写自己的核心程序。</p><p>&emsp;&emsp;撰写程序首先需要的是能够工作的环境，再来则是可以将原始码编译为可执行文件的编译程序。<strong>还好GNU计划提供了bash工作环境和gcc编译程序等自由软件</strong>，Torvalds参考了Minix的设计理念和书籍上的程序代码，开始研究386个人计算机的效能优化，通过GNU自由软件将核心程序代码和386结合起来，最终写出了他需要的核心程序。最终这个玩具可以在386上运行，并且可以读取Minix的文件系统。之后他便将这个程序放到了网上供别人下载，并在BBS上贴了一则消息，而他放置这个程序的FTP目录为Linux，也就成为了它的名字。</p><p><img src="https://pic-1258215793.cos.ap-shanghai.myqcloud.com/content/20190901/201909010102.png" alt="Linus Torvalds在BBS上发布Linux"></p><p>&emsp;&emsp;之后Torvalds尝试在Linux上运行一些Unix的程序，但大部分都无法启动。所以他现在有两种选择：第一是修改软件，让其可以运行在Linux上；第二是修改Linux，让Linux符合软件运行的规范。Torvalds选择了后者，他希望Linux可以兼容Unix，于是他参考了标准的POSIX规范（可携式操作系统接口，由IEEE发布，主要针对Unix与一些软件运行时的标准），这个决定也是后来Linux发展状大的一个重要原因。</p><p>&emsp;&emsp;Linux的发展离不开社群的贡献，Torvalds在一开始便将Linux发布在网络中，有人使用后出现各种问题和需求，Torvalds就会及时的进行处理和更新。但一个人力量是有限的，因为Linux核心是Open Source的，所以网络和社群上的人很容易就可以跟随Linux的设计架构，并为一些硬件开发出兼容的驱动程序或软件等。Torvalds总是以【<strong>先求有且能运行，再求进一步改良</strong>】为准则，这鼓励到了很多志愿者加入了这个团队。同时<strong>为了适应这种随时都有程序代码加入的状况，Linux发展为具有模块的功能</strong>。将一些功能独立出核心，在需要时再加载进核心中，这样模块化的设计大大的提升了Linux核心的可维护能力。</p><p>&emsp;&emsp;1994年，Linux核心正式版上线。1996年完成了2.0版，2011年更新了3.0版，2015年更新了4.0版。</p><h3 id="自由软件和开源软件"><a href="#自由软件和开源软件" class="headerlink" title="自由软件和开源软件"></a><strong>自由软件和开源软件</strong></h3><blockquote><p>自由软件的特色：</p><ul><li>取得软件与原始码：你可以根据自己的需求来执行这个自由软件。</li><li>复制：你可以自由的复制该软件。</li><li>修改：你可以将取得的原始码进行修改，使其适应你的工作。</li><li>再发行：你可以将你修改过的程序，再度的自由发行，不会和原撰写者发生冲突。</li><li>回馈：你可以将你修改过的程序代码回馈给社群。</li></ul></blockquote><blockquote><p>自由软件禁止：</p><ul><li>修改授权：你不能把一个GPL授权的自由软件，在修改后取消GPL授权。</li><li>单纯贩卖：你不能单纯的贩卖自由软件。</li></ul></blockquote><p>&emsp;&emsp;<em>自由软件也是可以贩卖的，但不能单售卖自由软件，而是厂商自己开发和制作的部分，特别是服务</em></p><blockquote><p>开源软件规则：</p><ul><li>公布原始码且用户具有修改权：用户可以任意的修改和编译程序代码，与自由软件相同。</li><li>任意的再散布：此程序代码全部或部分可以被贩卖，且程序代码可以成为其他软件的组件之一，作者不应该称自己具有所有权，或收取额外的费用。</li><li>必须允许修改或衍生的作品，且可让再发布的软件使用相似的授权来发表即可。</li><li>承上，用户可使用与原本软件不同的名称或编号来散布。</li><li>不可限制某些个体或团体的使用权。</li><li>不可限制某些领域的应用：如不可限制其不能用于商业行为或学术行为等领域</li><li>不可限制在某些产品中，亦即程序代码可以应用于多种不同产品中。</li><li>不可具有排他条款，如不可限制此程序代码不能用于教育类研究中等。</li></ul></blockquote><p>&emsp;&emsp;GPL自由软件在商业上相比开源软件要有更多限制，所以许多商业公司选择拥抱其他open source开源软件授权，因为可以用于商业行为。<em>ps：有些专利软件也会通过Freeware和Shareware的模式来开放免费版本给大众使用噢</em>。</p><hr><h2 id="第三节-版本"><a href="#第三节-版本" class="headerlink" title="第三节 版本"></a><strong>第三节 版本</strong></h2><p>&emsp;&emsp;Linux的核心版本编号如下格式：</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">3<span class="selector-class">.10</span><span class="selector-class">.0-123</span><span class="selector-class">.e17</span><span class="selector-class">.x86_64</span></span><br><span class="line">主版本.次版本.释出版本<span class="selector-tag">-</span>修改版本</span><br></pre></td></tr></table></figure><h3 id="奇数偶数版本分类"><a href="#奇数偶数版本分类" class="headerlink" title="奇数偶数版本分类"></a><strong>奇数偶数版本分类</strong></h3><p>&emsp;&emsp;当主次版本为奇数，表示是<strong>发展中版本</strong>（development），如2.5.XX；当主次版本为偶数，则表示为<strong>稳定版本</strong>（stable）。<strong>释出版本</strong>是主次版本的架构不变时，新增功能累积到一定程度后释放的核心版本。修改版本就是使用者各自针对某个进行核心程序代码修改后的版本。</p><h3 id="主线版本和长期维护版本"><a href="#主线版本和长期维护版本" class="headerlink" title="主线版本和长期维护版本"></a><strong>主线版本和长期维护版本</strong></h3><p>&emsp;&emsp;3.0后奇数偶数编号格式就不再使用了，而是依据主线版本（MainLine）来开发，如3.10基于3.9架构继续开发。</p><p>&emsp;&emsp;旧版本在出现新的版本之前会有两种机制来处理，一是结束开发，表示此程序代码已结束不会再维护；二是保持该版本的持续维护，即长期维护版本，如3.10即为一个长期维护版本，如果出现BUG等问题，维护人员会进行更新维护。</p><h3 id="核心版本和发布商版本"><a href="#核心版本和发布商版本" class="headerlink" title="核心版本和发布商版本"></a><strong>核心版本和发布商版本</strong></h3><p>&emsp;&emsp;Linux核心版本和一些distribution的版本不相同，如Linux 7.x 应该是指CentOS这个distribution的版本。</p><p>&emsp;&emsp;为了让更多使用者能够使用Linux，许多商业公司和非盈利团体，将Linux Kernel（包括tools）与一些可运行软件整合起来，再加上了自己一些有创意的工具程序，可以让用户通过存储设备或网络来安装和管理Linux系统。这个【Kernel + Softwares + Tools + 可完全安装程序】就被叫作Linux distribution，Linux发布商套件。</p><p>&emsp;&emsp;比较知名的有Red Hat，SuSE，Ubuntu，Fedora，Debian等，这些系统重复性很高，并都基于<strong>Linux Standard Base</strong>（LSB）标准以及目录架构的<strong>File system Hierarchy Standard</strong>（FHS）来开发，所以不会有太大差异，区别可能就是平台自家开发的管理工具以及套件管理的模式吧。</p><p><img src="https://pic-1258215793.cos.ap-shanghai.myqcloud.com/content/20190901/201909010103.png" alt="Linux distribution分类"></p><p><em>商业版会稳定些，而社群版可能会有一些潜在的BUG</em></p><hr><h2 id="第四节-应用场景"><a href="#第四节-应用场景" class="headerlink" title="第四节 应用场景"></a><strong>第四节 应用场景</strong></h2><h3 id="网络服务器"><a href="#网络服务器" class="headerlink" title="网络服务器"></a><strong>网络服务器</strong></h3><p>&emsp;&emsp;Linux最热门的应用场景。Linux系统网络功能非常稳定和强大，特别适合用作网络服务器，如WWW，Mail Server，File Server等。</p><h3 id="关键任务的应用-金融数据库、大型企业网管环境"><a href="#关键任务的应用-金融数据库、大型企业网管环境" class="headerlink" title="关键任务的应用(金融数据库、大型企业网管环境)"></a><strong>关键任务的应用(金融数据库、大型企业网管环境)</strong></h3><p>&emsp;&emsp;关键任务就是企业最重要的业务，比如金融行业最重要的投资者和账户的数据，这些数据大部分是由数据库系统来作为存取接口，往往都采用Linux。</p><h3 id="学术机构的高效能运算任务"><a href="#学术机构的高效能运算任务" class="headerlink" title="学术机构的高效能运算任务"></a><strong>学术机构的高效能运算任务</strong></h3><p>&emsp;&emsp;Linux具有强大的运算能力，也具有支持度相当广泛的GCC编译软件，很适合一些学术机构的研究软件。</p><h3 id="个人计算机"><a href="#个人计算机" class="headerlink" title="个人计算机"></a><strong>个人计算机</strong></h3><p>&emsp;&emsp;桌面计算机（Desktop）的绝大部分功能需求Linux都已经可以满足了，旧版本缺少的窗口接口在Linux和X Window System结合后也得到了解决，Linux经过多年的发展已经兼容了绝大部分常用的办公和生活软件。</p><h3 id="移动设备"><a href="#移动设备" class="headerlink" title="移动设备"></a><strong>移动设备</strong></h3><p>&emsp;&emsp;Android就是Linux的一个分支。</p><h3 id="嵌入式设备"><a href="#嵌入式设备" class="headerlink" title="嵌入式设备"></a><strong>嵌入式设备</strong></h3><p>&emsp;&emsp;嵌入式系统基本不会有太大的更新，比如路由器、防火墙、收集、IP分享器、交换机、机器人芯片、家电产品等都可以使用Linux系统。</p><h3 id="云端应用"><a href="#云端应用" class="headerlink" title="云端应用"></a><strong>云端应用</strong></h3><p>&emsp;&emsp;随着个人计算机的CPU核心数越来越多，主机的性能有些过于强大，一些硬件资源经常会闲置，促进了虚拟化技术的发展，让数据集中在云程序中，用户通过端点设备联机到云中取到运算资源。<strong>云程序</strong>的底层就是Linux，而云程序搭建出的虚拟机，内容也是Linux操作系统。（通过虚拟化技术可以在一部主机上安装多个同时运作的操作系统，从而充分利用硬件资源）</p><hr><p><em>参考博客和文章书籍等：</em></p><blockquote><p>《鸟哥的Linux私房菜》</p></blockquote><p><em>因博客主等未标明不可引用，若部分内容涉及侵权请及时告知，我会尽快修改和删除相关内容</em></p>]]></content>
    
    <summary type="html">
    
      整理《鸟哥的linux私房菜》读书笔记（二）Linux简介，内容包括：引文，历史，版本，应用场景等内容。
    
    </summary>
    
      <category term="技术文档" scheme="http://linyishui.top/categories/%E6%8A%80%E6%9C%AF%E6%96%87%E6%A1%A3/"/>
    
    
      <category term="os" scheme="http://linyishui.top/tags/os/"/>
    
      <category term="linux" scheme="http://linyishui.top/tags/linux/"/>
    
  </entry>
  
  <entry>
    <title>《鸟哥的linux私房菜》读书笔记（一）计算机概论</title>
    <link href="http://linyishui.top/2019091601.html"/>
    <id>http://linyishui.top/2019091601.html</id>
    <published>2019-09-16T07:24:33.000Z</published>
    <updated>2019-11-15T03:32:15.678Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="第一章-计算机概论"><a href="#第一章-计算机概论" class="headerlink" title="第一章 计算机概论"></a><strong>第一章 计算机概论</strong></h1><h2 id="第一节-五大单元"><a href="#第一节-五大单元" class="headerlink" title="第一节 五大单元"></a><strong>第一节 五大单元</strong></h2><p>&emsp;&emsp;计算机由以下几个单元组成：输入单元、输出单元、CPU内部的控制单元和算数逻辑单元、主存储器。</p><p>&emsp;&emsp;计算机的重点是中央处理器（Central Processing Unit, CPU），CPU是一个具有特定功能的芯片，里面含有微指令集，主要工作是管理和运算，所以CPU又分为两个单元：算数逻辑单元与控制单元。<strong>算数逻辑单元主要负责程序运算与逻辑判断，控制单元主要协调周边组件和各单元间的工作</strong>。</p><p>&emsp;&emsp;所以数据从输入单元传输到主存储器，经过CPU处理后写回主存储器，最后再传输到输出单元。<em>（因为所有数据都要经过主存储器传输，如果内存容量不足，会对性能造成很大影响，所以提升内存被认为是提高机器性能的简单做法）</em></p><hr><h2 id="第二节-指令集"><a href="#第二节-指令集" class="headerlink" title="第二节 指令集"></a><strong>第二节 指令集</strong></h2><p>&emsp;&emsp;CPU的微指令集主要有两种设计理念：精简指令集（RISC）与复杂指令集（CISC）系统。</p><h3 id="精简指令集"><a href="#精简指令集" class="headerlink" title="精简指令集"></a><strong>精简指令集</strong></h3><p>&emsp;&emsp;如字面意思，此微指令集较为精简，每个指令的运行时间都很短，完成的动作也很单纯，指令执行效能较佳。但对于复杂的任务，就需要多个指令来完成。</p><p>&emsp;&emsp;常见的RISC微指令集CPU主要为：Oracle公司的SPARC系列、IBM公司的PowerPC系列、ARM公司的ARM CPU系列等。SPARC CPU主要用于学术领域的大型工作站，或者金融体系的主服务器。Power PC则有索尼的PS3等。ARM则是绝大部分主流手机、导航设备、网络设备等所采用的CPU。</p><h3 id="复杂指令集"><a href="#复杂指令集" class="headerlink" title="复杂指令集"></a><strong>复杂指令集</strong></h3><p>&emsp;&emsp;CISC每个小指令都可以执行一些较低阶的硬件操作，指令数目多而且复杂，每条指令的长度并不相同，消耗的时间较长，但可以处理较丰富的任务。</p><p>&emsp;&emsp;常见的CISC微指令集CPU主要有AMD、Intel、VIA等x86架构CPU。大量的PC都是采用x86架构CPU。</p><hr><h2 id="第三节-其他单元"><a href="#第三节-其他单元" class="headerlink" title="第三节 其他单元"></a><strong>第三节 其他单元</strong></h2><p>&emsp;&emsp;设备主要通过主板在硬件上连接起来，主板上有个连接沟通所有设备的芯片组，使CPU可以对各个设备下达命令。</p><blockquote><ul><li>系统单元：CPU、内存和主板等相关组件。主板上有很多连接界面和适配卡。</li><li>记忆单元：包括主存储器（RAM）与辅助内存。辅助内存就是硬盘、光盘等存储设备。</li><li>输入、输出单元：触摸屏、键盘、鼠标、打印机、HDMI、投影机、蓝牙等等。</li></ul></blockquote><hr><h2 id="第四节-常见单位"><a href="#第四节-常见单位" class="headerlink" title="第四节 常见单位"></a><strong>第四节 常见单位</strong></h2><h3 id="容量单位"><a href="#容量单位" class="headerlink" title="容量单位"></a><strong>容量单位</strong></h3><p>&emsp;&emsp;最基础的单位就是bit，代表二进制0或1。</p><p>&emsp;&emsp;字节 Byte 是很多简单数据都是8比特大小而定义的单位，所以 1 Byte = 8 bit。</p><p>&emsp;&emsp;在字节之上就通过一系列简化单位来表示所代表的位数（K,M,G,T,P,E,Z等），二进制换算是每隔一代代表1024倍，十进制换算是每隔一代代表1000倍。</p><h3 id="速度单位"><a href="#速度单位" class="headerlink" title="速度单位"></a><strong>速度单位</strong></h3><p>&emsp;&emsp;CPU的指令周期常用MHz或GHz等单位，Hz表示秒分之一。对于网络传输，因为网络使用bit作为单位，所以为Mbps（Mbits per second）也就是每秒多少Mbit。比如常见的100M宽带，如果转换为字节时，理论最大传输值为：每秒12.5Mbyte。</p><hr><h2 id="第五节-CPU"><a href="#第五节-CPU" class="headerlink" title="第五节 CPU"></a><strong>第五节 CPU</strong></h2><p>&emsp;&emsp;早期主板上的芯片组使用两个网桥来控制各个组件的沟通：(1)<strong>北桥</strong>：负责链接速度较快的CPU、主存储器与显式适配器界面等组件。(2)<strong>南桥</strong>：负责链接速度较慢的装置接口，如硬盘、USB、网卡等。因为北桥最主要的用处是桥接CPU和主存储器，所以后来的架构将北桥内存控制器封装到CPU中了，这样CPU和主存储器不再需要一层北桥，而是直接联系，可以释放浪费的带宽，提高速度。</p><p>&emsp;&emsp;多核CPU可以理解为CPU中有多个CPU处理单元，不同的微指令集也会影响到CPU的性能。CPU的频率就是CPU每秒钟可以进行的工作次数，如3.6GHz表示CPU可以一秒钟进行3.6*10^9次工作，只用频率来判定CPU性能是比较片面的，除了不同微指令集外，架构也不同，可用的第二层快取及其计算器制也可能不同，每次频率能进行的工作指令数也不同。</p><p>&emsp;&emsp;早期因为需要通过北桥来进行连接，所有设备工作频率需要相同，所以就有了<strong>前端总线</strong>（Front Side Bus, FSB）。因为CPU指令周期最快，所以有了外频和倍频的定义，<strong>外频</strong>就是CPU和外部组件进行传输的速度，<strong>倍频</strong>则是CPU内部用来加速工作效能的一个倍数，二者的积才是CPU的频率速度。比如一个CPU内频为3.0GHz，外频是333MHz，所以倍频就是9倍（3G = 3000M = 333M * 9）。</p><p>&emsp;&emsp;<strong>超频</strong>就是将CPU的倍频或外频通过主板设定为较高的频率，倍频通常不允许修改，一般修改的是外频。如333MHz提到400MHz，但超频之后CPU被提速，主板的各个组件都要相应的提速，变为原来的1.333倍（4/3），虽然CPU可能会达到3.6GHz，但可能会导致当机等问题。</p><p>&emsp;&emsp;北桥要慢于CPU，就会变成性能的瓶颈，所以后来就将内存控制器整合到了CPU内部。这时就不需要考虑同步的外频，只要考虑整体频率即可。</p><p>&emsp;&emsp;CPU每次能够处理的数据量称为<strong>字组大小</strong>，根据CPU设计有32位和64位，32位CPU因为能解析数据量有限，最多只能支持最大4GBytes的内存。</p><p>&emsp;&emsp;CPU的<strong>超线程</strong>（Hyper-Threading），CPU指令周期太快了，所以运算核心经常得以闲置，如今的系统基本都是多任务系统，同时会有很多任务让CPU执行，所以就可以让CPU“同时”执行多个程序，来充分利用其性能。多线程的原理在其他博文中已有整理，简单的说就是CPU将缓存器分为两块，多个程序同时竞争CPU的运算单元，这样4核的CPU可以有8核的效果。</p><hr><h2 id="第六节-内存"><a href="#第六节-内存" class="headerlink" title="第六节 内存"></a><strong>第六节 内存</strong></h2><p>&emsp;&emsp;主存储器的主要组件为<strong>动态随机存取内存</strong>（Dynamic Random Access Memory, DRAM），断电后数据即丢失。</p><p>&emsp;&emsp;DDR是所谓的<strong>双倍数据传送速度</strong>（Double Data Rate），可以在一次工作周期进行两次数据传送。</p><p>&emsp;&emsp;内存除了频率/带宽和型号外，其容量是非常重要的，所有数据都要加载到内存后才能被CPU读取，内存不够大会使大容量数据无法完整加载，内存需要释放未被使用的数据，现实使用中这些释放会和影响内存性能。</p><p>&emsp;&emsp;CPU内有<strong>第二层高速缓存</strong>（L2 cache），用来存放常用的程序或数据，避免再从主存储器中读取。L2内存的速度和CPU频率相同，但DRAM无法达到这个频率，所以需要<strong>静态随机存取内存</strong>（Static Random Access Memory, SRAM）。SRAM成本较高，很难做成大容量，所以利用其速度快的优势来作缓存是很好的方案。</p><p>&emsp;&emsp;CMOS主要用来记录主板上重要的参数，包括系统时间、CPU电压和评率、各项设备的I/O地址与IRQ等，记录这些需要通电，所以主板上也会有电池。</p><p>&emsp;&emsp;BIOS（Basic Input Output System）是写死在主板上内存芯片中的一套程序，这个芯片是<strong>只读存储器</strong>（ROM）即使没有通电也可以记录数据。BIOS随着计算机发展，需要不断地进行更新，所以只能放弃ROM，转为写入如闪存（flash）或EEPRO中。BIOS开机时执行，加载CMOS中的参数，并尝试呼叫存储设备中的开机程序从而进入操作系统。</p><p>&emsp;&emsp;显式适配器又叫VGA（Vifeo Graphics Array），图像的显式颜色需要占用内存，一些3D需要一定的运算，而CPU并非针对3D而设计的，所以就在VGA中嵌入了3D加速的芯片，也就是GPU。PCI是VGA的规格，经过了AGP后又发展为PCI-Express。</p><p>&emsp;&emsp;VGA和显示器连接的接口有：D-Sub(VGA端子)，DVI，HDMI，Display port(DP)。</p><hr><h2 id="第七节-机器语言到高级语言"><a href="#第七节-机器语言到高级语言" class="headerlink" title="第七节 机器语言到高级语言"></a><strong>第七节 机器语言到高级语言</strong></h2><p>&emsp;&emsp;<strong>机器语言</strong>就是一种指令集，也叫机器码，可以让CPU直接解读的语言，通过二进制代码来表示一些机器可以直接执行的指令集合。</p><p>&emsp;&emsp;因为机器只能识别0和1这种二进制语言，为了让机器执行特定的程序，需要参考机器自身的功能，程序最重要的运算和逻辑判断是通过CPU进行处理，所以为了让CPU执行程序需要参考CPU特有的微指令集，所以不同CPU微指令集不同时，移植就是一件麻烦事，程序需要和硬件结合才能开发时，程序就无法有效的复用，每次都要重新和硬件打交道。</p><p>&emsp;&emsp;为了解决这些麻烦，经过不断地发展，从机器语言到汇编语言，最后发展到一些现在的高级语言。</p><p>&emsp;&emsp;<strong>汇编语言</strong>通过助记符来代替机器指令的操作码，从而不用面对大量的二进制串，但汇编语言基本是和机器语言指令集一一对应的，所以不能解决不同平台不能移植的问题，不同指令集也就意味着不同的汇编语言，也没有降低编程的复杂度，但其性能和机器语言相当，要高于其他语言，所以到现在也会在一些场景继续发挥作用。</p><p>&emsp;&emsp;<strong>高级语言</strong>是高度封装后的编程语言，相比面向机器的汇编和机器语言，高级语言是面向用户的。高级语言不能直接被机器理解，所以需要一个翻译的过程，变为可以执行的机器语言。翻译方式有：编译和解释，编译就是先翻译程序后再执行，解释则是一边翻译一边执行。翻译的过程由<strong>编译程序</strong>来执行，开发人员只要专注于创造性的内容即可。</p><p>&emsp;&emsp;高级语言接近算法语言，简单易理解，更有结构化，使其开发的程序更具有可读性、可维护性、可靠性等，因为脱离了和硬件的对应，所以也实现了好的可移植性，提高了复用率。</p><hr><h2 id="第八节-操作系统"><a href="#第八节-操作系统" class="headerlink" title="第八节 操作系统"></a><strong>第八节 操作系统</strong></h2><p>&emsp;&emsp;如果程序想要把数据写入内存，必然需要分配一块内存区域用来放置数据，也就意味着要了解内存地址是如何定位的，而操作系统可以完成这种和硬件打交道重复撰写句柄的任务。</p><p>&emsp;&emsp;<strong>操作系统</strong>也是一组程序，其工作重点是管理计算机所由活动以及驱动系统中所有硬件。操作系统可以实现的这些功能就是其<strong>核心</strong>（Kernel），核心主要管控硬件与提供相关的能力，这些功能十分重要，所以核心程序会被放置到内存当中的区块中进行保护，开机后就会驻留在内存当中。</p><p>&emsp;&emsp;程序通过<strong>系统呼叫</strong>（System Call）来和核心交互，只要遵守操作系统提供的开发接口，核心的系统呼叫接口会主动的把程序语言的相关语法转为可以识别的任务函数，而开发人员不需要去了解核心或硬件了。</p><p><img src="https://pic-1258215793.cos.ap-shanghai.myqcloud.com/content/20190901/201909010101.png" alt="操作系统的角色"></p><p>&emsp;&emsp;核心程序提供的这一整组开发接口叫<strong>系统呼叫层</strong>，操作系统的核心层参考硬件信息来实现，没有其他程序的帮助操作系统只是在管理整个硬件资源，只是让计算机处于准备状态，应用程序开发时参考操作系统的开发接口，也只能运行在这个操作系统上。</p><blockquote><p>核心至少要具有以下功能：</p><ul><li>系统呼叫接口</li><li>程序管理</li><li>内存管理</li><li>文件系统管理</li><li>装置的驱动</li></ul></blockquote><p>&emsp;&emsp;驱动一般由硬件厂商提供，操作系统会提供给硬件厂商一组开发接口，让他们按照接口设计驱动程序，从而使操作系统可以识别任意版本的驱动。</p><hr><p><em>参考博客和文章书籍等：</em></p><blockquote><p>《鸟哥的Linux私房菜》</p></blockquote><p><em>因博客主等未标明不可引用，若部分内容涉及侵权请及时告知，我会尽快修改和删除相关内容</em></p>]]></content>
    
    <summary type="html">
    
      整理《鸟哥的linux私房菜》读书笔记（一）计算机概论，内容包括：计算机五大组成单元，指令集，其他单元，常见单位，CPU，内存，机器语言到高级语言，操作系统等内容。
    
    </summary>
    
      <category term="技术文档" scheme="http://linyishui.top/categories/%E6%8A%80%E6%9C%AF%E6%96%87%E6%A1%A3/"/>
    
    
      <category term="os" scheme="http://linyishui.top/tags/os/"/>
    
      <category term="linux" scheme="http://linyishui.top/tags/linux/"/>
    
  </entry>
  
  <entry>
    <title>正则表达式 &lt;整&gt;</title>
    <link href="http://linyishui.top/2019091501.html"/>
    <id>http://linyishui.top/2019091501.html</id>
    <published>2019-09-15T03:10:59.000Z</published>
    <updated>2019-11-13T07:48:14.734Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="正则表达式"><a href="#正则表达式" class="headerlink" title="正则表达式"></a><strong>正则表达式</strong></h1><h2 id="第一节-介绍"><a href="#第一节-介绍" class="headerlink" title="第一节 介绍"></a><strong>第一节 介绍</strong></h2><p>&emsp;&emsp;正则表达式（Regular expression）是一组由字母和符号组成的特殊文本, 用来从文本中找出满足条件格式的句子。</p><p>&emsp;&emsp;一个正则表达式是一种从左到右匹配主体字符串的模式。“Regular expression”可以用缩写的术语“regex”或“regexp”代替。正则表达式可以从一个基础字符串中根据一定的匹配模式替换文本中的字符串、验证表单、提取字符串等等。</p><p>&emsp;&emsp;假设有如下限制：用户名只能包含小写字母、数字、下划线和连字符，并且限制用户名长度在3~15个字符之间</p><blockquote><p>^[a-z0-9_-]{3,15}&amp;</p></blockquote><p>&emsp;&emsp;^是开始标记，a-z0-9_-表示字母(a-z)、数字(0-9)、下划线和连字符，3-15表示允许3~15个字符长度，$是结束标记。</p><hr><h2 id="第二节-匹配模式"><a href="#第二节-匹配模式" class="headerlink" title="第二节 匹配模式"></a><strong>第二节 匹配模式</strong></h2><h3 id="1-基本匹配"><a href="#1-基本匹配" class="headerlink" title="1 基本匹配"></a><strong>1 基本匹配</strong></h3><p>&emsp;&emsp;正则表达式是<strong>大小写敏感</strong>的，简单的“the”就表示规则：t紧接h再紧接e。</p><blockquote><p>“the” =&gt; The fat cat sat on <strong>the</strong> mat.</p></blockquote><h3 id="2-元字符"><a href="#2-元字符" class="headerlink" title="2 元字符"></a><strong>2 元字符</strong></h3><p>&emsp;&emsp;正则表达式主要依赖于<strong>元字符</strong>。 元字符不代表他们本身的字面意思，他们都有特殊的含义。</p><table><thead><tr><th style="text-align:center">元字符</th><th style="text-align:left">描述</th></tr></thead><tbody><tr><td style="text-align:center">.</td><td style="text-align:left">句号匹配任意单个字符除了换行符。</td></tr><tr><td style="text-align:center">[ ]</td><td style="text-align:left">字符种类。匹配方括号内的任意字符。</td></tr><tr><td style="text-align:center">[^ ]</td><td style="text-align:left">否定的字符种类。匹配除了方括号里的任意字符</td></tr><tr><td style="text-align:center">*</td><td style="text-align:left">匹配&gt;=0个重复的在*号之前的字符。</td></tr><tr><td style="text-align:center">+</td><td style="text-align:left">匹配&gt;=1个重复的+号前的字符。</td></tr><tr><td style="text-align:center">?</td><td style="text-align:left">标记?之前的字符为可选.</td></tr><tr><td style="text-align:center">{n,m}</td><td style="text-align:left">匹配num个大括号之间的字符 (n &lt;= num &lt;= m).</td></tr><tr><td style="text-align:center">(xyz)</td><td style="text-align:left">字符集，匹配与 xyz 完全相等的字符串.</td></tr><tr><td style="text-align:center">\</td><td style="text-align:left"></td><td>或运算符，匹配符号前或后的字符.</td></tr><tr><td style="text-align:center">\</td><td style="text-align:left">转义字符,用于匹配一些保留的字符: [ ] ( ) { } . * + ? ^ $ \ \</td><td></td></tr><tr><td style="text-align:center">^</td><td style="text-align:left">从开始行开始匹配.</td></tr><tr><td style="text-align:center">$</td><td style="text-align:left">从末端开始匹配.</td></tr></tbody></table><h4 id="2-1-点运算符"><a href="#2-1-点运算符" class="headerlink" title="2.1 点运算符 ."></a><strong>2.1 点运算符 .</strong></h4><p>&emsp;&emsp;.是元字符中最简单的例子。 .匹配任意单个字符，但不匹配换行符。 </p><blockquote><p>“.ar” =&gt; The <strong>car</strong> <strong>par</strong>ked in the <strong>gar</strong>age.</p></blockquote><h4 id="2-2-字符集"><a href="#2-2-字符集" class="headerlink" title="2.2 字符集"></a><strong>2.2 字符集</strong></h4><p>&emsp;&emsp;<strong>字符集</strong>也叫做字符类。方括号用来指定一个字符集。在方括号中使用连字符来指定字符集的范围。在方括号中的字符集不关心顺序。 例如，表达式[Tt]he 匹配 the 和 The。</p><blockquote><p>“[Tt]he” =&gt; <strong>The</strong> car parked in <strong>the</strong> garage.</p></blockquote><p>&emsp;&emsp;方括号的句号就表示句号。</p><blockquote><p>“ar[.]” =&gt; A garage is a good place to park a c<strong>ar.</strong></p></blockquote><h5 id="2-2-1-否定字符集"><a href="#2-2-1-否定字符集" class="headerlink" title="2.2.1 否定字符集"></a><strong>2.2.1 否定字符集</strong></h5><p>&emsp;&emsp;一般来说 ^ 表示一个字符串的开头，但它用在一个方括号的开头的时候，它表示这个字符集是否定的。 =</p><blockquote><p>“[^c]ar” =&gt; The car <strong>par</strong>ked in the <strong>gar</strong>age.</p></blockquote><h4 id="2-3-重复次数"><a href="#2-3-重复次数" class="headerlink" title="2.3 重复次数"></a><strong>2.3 重复次数</strong></h4><p>&emsp;&emsp;后面跟着元字符 +，* or ? 的，用来指定匹配子模式的次数。</p><h5 id="2-3-1-号"><a href="#2-3-1-号" class="headerlink" title="2.3.1 * 号"></a><strong>2.3.1 * 号</strong></h5><p>&emsp;&emsp;* 号匹配在 * 之前的字符出现大于等于0次。 例如，表达式 a<em> 匹配0或更多个以a开头的字符。表达式[a-z]</em> 匹配一个行中所有以小写字母开头的字符串。</p><blockquote><p>“[a-z]*” =&gt; Th<strong>e car parked in the garage</strong> #21.</p></blockquote><p>&emsp;&emsp;* 字符和 . 字符搭配可以匹配所有的字符 .* 。 * 和表示匹配空格的符号 \s 连起来用，如表达式\s*cat\s* 匹配0或更多个空格开头和0或更多个空格结尾的cat字符串。</p><blockquote><p>“\s<em>cat\s</em>“ =&gt; The fat <strong>cat</strong> sat on the con<strong>cat</strong>enation.</p></blockquote><h5 id="2-3-2-号"><a href="#2-3-2-号" class="headerlink" title="2.3.2 + 号"></a><strong>2.3.2 + 号</strong></h5><p>&emsp;&emsp;+号匹配+号之前的字符出现 &gt;=1 次。 例如表达式c.+t 匹配以首字母c开头以t结尾，中间跟着至少一个字符的字符串。</p><blockquote><p>“c.+t” =&gt; The fat <strong>cat sat on the mat</strong>.</p></blockquote><h5 id="2-3-3-号"><a href="#2-3-3-号" class="headerlink" title="2.3.3 ? 号"></a><strong>2.3.3 ? 号</strong></h5><p>&emsp;&emsp;在正则表达式中元字符 ? 标记在符号前面的字符为可选，即出现 0 或 1 次。 例如，表达式 [T]?he 匹配字符串 he 和 The。</p><blockquote><p>“[T]he” =&gt; <strong>The</strong> car is parked in the garage.</p></blockquote><blockquote><p>“[T]?he” =&gt; <strong>The</strong> car is parked in t<strong>he</strong> garage.</p></blockquote><h4 id="2-4-符号"><a href="#2-4-符号" class="headerlink" title="2.4 符号 {}"></a><strong>2.4 符号 {}</strong></h4><p>&emsp;&emsp;在正则表达式中 {} 是一个量词，常用来一个或一组字符可以重复出现的次数。 例如， 表达式 [0-9]{2,3} 匹配最少 2 位最多 3 位 0~9 的数字。</p><blockquote><p>“[0-9]{2,3}” =&gt; The number was 9.<strong>999</strong>7 but we rounded it off to <strong>10</strong>.0.</p></blockquote><p>&emsp;&emsp;我们可以省略第二个参数。 例如，[0-9]{2,} 匹配至少两位 0~9 的数字。</p><blockquote><p>“[0-9]{2,}” =&gt; The number was 9.<strong>9997</strong> but we rounded it off to <strong>10</strong>.0.</p></blockquote><p>&emsp;&emsp;如果逗号也省略掉则表示重复固定的次数。 例如，[0-9]{3} 匹配3位数字</p><blockquote><p>“[0-9]{3}” =&gt; The number was 9.<strong>999</strong>7 but we rounded it off to 10.0.</p></blockquote><h4 id="2-5-…-特征标群"><a href="#2-5-…-特征标群" class="headerlink" title="2.5 (…) 特征标群"></a><strong>2.5 (…) 特征标群</strong></h4><p>&emsp;&emsp;特征标群是一组写在 (…) 中的子模式。例如之前说的 {} 是用来表示前面一个字符出现指定次数。但如果在 {} 前加入特征标群则表示整个标群内的字符重复 N 次。例如，表达式 (ab)* 匹配连续出现 0 或更多个 ab。</p><p>&emsp;&emsp;我们还可以在 () 中用或字符 | 表示或。例如，(c|g|p)ar 匹配 car 或 gar 或 par.</p><blockquote><p>“(c|g|p)ar” =&gt; The <strong>car</strong> is <strong>par</strong>ked in the <strong>gar</strong>age.</p></blockquote><h4 id="2-6-或运算符"><a href="#2-6-或运算符" class="headerlink" title="2.6 | 或运算符"></a><strong>2.6 | 或运算符</strong></h4><p>&emsp;&emsp;或运算符就表示或，用作判断条件。例如 (T|t)he|car 匹配 (T|t)he 或 car。</p><blockquote><p>“(T|t)he|car” =&gt; <strong>The car</strong> is parked in <strong>the</strong> garage.</p></blockquote><h4 id="2-7-转码特殊字符"><a href="#2-7-转码特殊字符" class="headerlink" title="2.7 转码特殊字符"></a><strong>2.7 转码特殊字符</strong></h4><p>&emsp;&emsp;反斜线 \ 在表达式中用于转码紧跟其后的字符。用于指定 { } [ ] / \ + * . $ ^ | ? 这些特殊字符。如果想要匹配这些特殊字符则要在其前面加上反斜线 \。</p><p>&emsp;&emsp;例如 . 是用来匹配除换行符外的所有字符的。如果想要匹配句子中的 . 则要写成 \. 以下这个例子 \.?是选择性匹配.</p><blockquote><p>“(f|c|m)at.?” =&gt; The <strong>fat cat</strong> sat on the <strong>mat.</strong></p></blockquote><h4 id="2-8-锚点"><a href="#2-8-锚点" class="headerlink" title="2.8 锚点"></a><strong>2.8 锚点</strong></h4><p>&emsp;&emsp;在正则表达式中，想要匹配指定开头或结尾的字符串就要使用到锚点。^ 指定开头，$ 指定结尾。</p><h5 id="2-8-1-号"><a href="#2-8-1-号" class="headerlink" title="2.8.1 ^ 号"></a><strong>2.8.1 ^ 号</strong></h5><p>&emsp;&emsp;^ 用来检查匹配的字符串是否在所匹配字符串的开头。</p><p>&emsp;&emsp;例如，在 abc 中使用表达式 ^a 会得到结果 a。但如果使用 ^b 将匹配不到任何结果。因为在字符串 abc 中并不是以 b 开头。</p><p>&emsp;&emsp;例如，^(T|t)he 匹配以 The 或 the 开头的字符串。</p><blockquote><p>“(T|t)he” =&gt; <strong>The</strong> car is parked in <strong>the</strong> garage.</p></blockquote><blockquote><p>“^(T|t)he” =&gt; <strong>The</strong> car is parked in the garage.</p></blockquote><h5 id="2-8-2-号"><a href="#2-8-2-号" class="headerlink" title="2.8.2 $ 号"></a><strong>2.8.2 $ 号</strong></h5><p>&emsp;&emsp;同理于 ^ 号，$ 号用来匹配字符是否是最后一个。</p><p>&emsp;&emsp;例如，(at.)$ 匹配以 at. 结尾的字符串。</p><blockquote><p>“(at.)” =&gt; The fat c<strong>at.</strong> s<strong>at.</strong> on the m<strong>at.</strong></p></blockquote><blockquote><p>“(at.)$” =&gt; The fat cat. sat. on the m<strong>at.</strong></p></blockquote><h3 id="3-简写字符集"><a href="#3-简写字符集" class="headerlink" title="3 简写字符集"></a><strong>3 简写字符集</strong></h3><p>&emsp;&emsp;正则表达式提供一些常用的字符集简写。如下:</p><table><thead><tr><th style="text-align:center">简写</th><th style="text-align:left">描述</th></tr></thead><tbody><tr><td style="text-align:center">.</td><td style="text-align:left">除换行符外的所有字符</td></tr><tr><td style="text-align:center">\w</td><td style="text-align:left">匹配所有字母数字，等同于 [a-zA-Z0-9_]</td></tr><tr><td style="text-align:center">\W</td><td style="text-align:left">匹配所有非字母数字，即符号，等同于： [^\w]</td></tr><tr><td style="text-align:center">\d</td><td style="text-align:left">匹配数字： [0-9]</td></tr><tr><td style="text-align:center">\D</td><td style="text-align:left">匹配非数字： [^\d]</td></tr><tr><td style="text-align:center">\s</td><td style="text-align:left">匹配所有空格字符，等同于： [\t\n\f\r\p{Z}]</td></tr><tr><td style="text-align:center">\S</td><td style="text-align:left">匹配所有非空格字符： [^\s]</td></tr><tr><td style="text-align:center">\f</td><td style="text-align:left">匹配一个换页符</td></tr><tr><td style="text-align:center">\n</td><td style="text-align:left">匹配一个换行符</td></tr><tr><td style="text-align:center">\r</td><td style="text-align:left">匹配一个回车符</td></tr><tr><td style="text-align:center">\t</td><td style="text-align:left">匹配一个制表符</td></tr><tr><td style="text-align:center">\v</td><td style="text-align:left">匹配一个垂直制表符</td></tr><tr><td style="text-align:center">\p</td><td style="text-align:left">匹配 CR/LF（等同于 \r\n），用来匹配 DOS 行终止符</td></tr></tbody></table><h3 id="4-零宽度断言（前后预查）"><a href="#4-零宽度断言（前后预查）" class="headerlink" title="4 零宽度断言（前后预查）"></a><strong>4 零宽度断言（前后预查）</strong></h3><p>&emsp;&emsp;先行断言和后发断言都属于非捕获簇（不捕获文本 ，也不针对组合计进行计数）。 先行断言用于判断所匹配的格式是否在另一个确定的格式之前，匹配结果不包含该确定格式（仅作为约束）。</p><p>&emsp;&emsp;例如，我们想要获得所有跟在 $ 符号后的数字，我们可以使用正后发断言 (?&lt;=\$)[0-9.]*。 这个表达式匹配 $ 开头，之后跟着 0,1,2,3,4,5,6,7,8,9,. 这些字符可以出现大于等于 0 次。</p><p>&emsp;&emsp;零宽度断言如下：</p><table><thead><tr><th style="text-align:center">符号</th><th style="text-align:left">描述</th></tr></thead><tbody><tr><td style="text-align:center">?=</td><td style="text-align:left">正先行断言-存在</td></tr><tr><td style="text-align:center">?!</td><td style="text-align:left">负先行断言-排除</td></tr><tr><td style="text-align:center">?&lt;=</td><td style="text-align:left">正后发断言-存在</td></tr><tr><td style="text-align:center">?&lt;!</td><td style="text-align:left">负后发断言-排除</td></tr></tbody></table><h4 id="4-1-…-正先行断言"><a href="#4-1-…-正先行断言" class="headerlink" title="4.1 ?=… 正先行断言"></a><strong>4.1 ?=… 正先行断言</strong></h4><p>&emsp;&emsp;?=… 正先行断言，表示第一部分表达式之后必须跟着 ?=…定义的表达式。</p><p>&emsp;&emsp;返回结果只包含满足匹配条件的第一部分表达式。 定义一个正先行断言要使用 ()。在括号内部使用一个问号和等号： (?=…)。</p><p>&emsp;&emsp;正先行断言的内容写在括号中的等号后面。 例如，表达式 (T|t)he(?=\sfat) 匹配 The 和 the，在括号中我们又定义了正先行断言 (?=\sfat) ，即 The 和 the 后面紧跟着 (空格)fat。</p><blockquote><p>“(T|t)he(?=\sfat)” =&gt; <strong>The</strong> fat cat sat on the mat.</p></blockquote><h4 id="4-2-…-负先行断言"><a href="#4-2-…-负先行断言" class="headerlink" title="4.2 ?!… 负先行断言"></a><strong>4.2 ?!… 负先行断言</strong></h4><p>&emsp;&emsp;负先行断言 ?! 用于筛选所有匹配结果，筛选条件为 其后不跟随着断言中定义的格式。 正先行断言 定义和 负先行断言 一样，区别就是 = 替换成 ! 也就是 (?!…)。</p><p>&emsp;&emsp;表达式 (T|t)he(?!\sfat) 匹配 The 和 the，且其后不跟着 (空格)fat。</p><blockquote><p>“(T|t)he(?!\sfat)” =&gt; The fat cat sat on <strong>the</strong> mat.</p></blockquote><h4 id="4-3-lt-…-正后发断言"><a href="#4-3-lt-…-正后发断言" class="headerlink" title="4.3 ?&lt;= … 正后发断言"></a><strong>4.3 ?&lt;= … 正后发断言</strong></h4><p>&emsp;&emsp;正后发断言 记作(?&lt;=…) 用于筛选所有匹配结果，筛选条件为 其前跟随着断言中定义的格式。 例如，表达式 (?&lt;=(T|t)he\s)(fat|mat) 匹配 fat 和 mat，且其前跟着 The 或 the。</p><blockquote><p>“(?&lt;=(T|t)he\s)(fat|mat)” =&gt; The <strong>fat</strong> cat sat on the <strong>mat</strong>.</p></blockquote><h4 id="4-4-lt-…-负后发断言"><a href="#4-4-lt-…-负后发断言" class="headerlink" title="4.4 ?&lt;!… 负后发断言"></a><strong>4.4 ?&lt;!… 负后发断言</strong></h4><p>&emsp;&emsp;负后发断言 记作 (?&lt;!…) 用于筛选所有匹配结果，筛选条件为 其前不跟随着断言中定义的格式。 例如，表达式 (?&lt;!(T|t)he\s)(cat) 匹配 cat，且其前不跟着 The 或 the。</p><blockquote><p>“(?&lt;!(T|t)he\s)(cat)” =&gt; The cat sat on <strong>cat</strong>.</p></blockquote><h3 id="5-标志"><a href="#5-标志" class="headerlink" title="5 标志"></a><strong>5 标志</strong></h3><p>&emsp;&emsp;标志也叫模式修正符，因为它可以用来修改表达式的搜索结果。 这些标志可以任意的组合使用，它也是整个正则表达式的一部分。</p><table><thead><tr><th style="text-align:center">标志</th><th style="text-align:left">描述</th></tr></thead><tbody><tr><td style="text-align:center">i</td><td style="text-align:left">忽略大小写。</td></tr><tr><td style="text-align:center">g</td><td style="text-align:left">全局搜索。</td></tr><tr><td style="text-align:center">m</td><td style="text-align:left">多行修饰符：锚点元字符 ^ $ 工作范围在每行的起始。</td></tr></tbody></table><h4 id="5-1-忽略大小写（Case-Insensitive）"><a href="#5-1-忽略大小写（Case-Insensitive）" class="headerlink" title="5.1 忽略大小写（Case Insensitive）"></a><strong>5.1 忽略大小写（Case Insensitive）</strong></h4><p>&emsp;&emsp;修饰语 i 用于忽略大小写。 例如，表达式 /The/gi 表示在全局搜索 The，在后面的 i 将其条件修改为忽略大小写，则变成搜索 the 和 The，g 表示全局搜索。</p><blockquote><p>“The” =&gt; <strong>The</strong> fat cat sat on the mat.</p></blockquote><blockquote><p>“/The/gi” =&gt; <strong>The</strong> fat cat sat on <strong>the</strong> mat.</p></blockquote><h4 id="5-2-全局搜索（Global-search）"><a href="#5-2-全局搜索（Global-search）" class="headerlink" title="5.2 全局搜索（Global search）"></a><strong>5.2 全局搜索（Global search）</strong></h4><p>&emsp;&emsp;修饰符 g 常用于执行一个全局搜索匹配，即（不仅仅返回第一个匹配的，而是返回全部）。 例如，表达式 /.(at)/g 表示搜索 任意字符（除了换行）+ at，并返回全部结果。</p><blockquote><p>“/.(at)/“ =&gt; The <strong>fat</strong> cat sat on the mat.</p></blockquote><blockquote><p>“/.(at)/g” =&gt; The <strong>fat cat sat</strong> on the <strong>mat</strong>.</p></blockquote><h4 id="5-3-多行修饰符（Multiline）"><a href="#5-3-多行修饰符（Multiline）" class="headerlink" title="5.3 多行修饰符（Multiline）"></a><strong>5.3 多行修饰符（Multiline）</strong></h4><p>&emsp;&emsp;多行修饰符 m 常用于执行一个多行匹配。</p><p>&emsp;&emsp;像之前介绍的 (^,$) 用于检查格式是否是在待检测字符串的开头或结尾。但我们如果想要它在每行的开头和结尾生效，我们需要用到多行修饰符 m。</p><p>&emsp;&emsp;例如，表达式 /at(.)?$/gm 表示小写字符 a 后跟小写字符 t ，末尾可选除换行符外任意字符。根据 m 修饰符，现在表达式匹配每行的结尾。</p><blockquote><p>“/.at(.)?$/“ =&gt; The fat<br>                cat sat<br>                on the <strong>mat</strong>.</p></blockquote><blockquote><p>“/.at(.)?$/gm” =&gt; The <strong>fat</strong><br>                  cat <strong>sat</strong><br>                  on the <strong>mat</strong>.</p></blockquote><h3 id="6-贪婪匹配与惰性匹配（Greedy-vs-lazy-matching）"><a href="#6-贪婪匹配与惰性匹配（Greedy-vs-lazy-matching）" class="headerlink" title="6 贪婪匹配与惰性匹配（Greedy vs lazy matching）"></a><strong>6 贪婪匹配与惰性匹配（Greedy vs lazy matching）</strong></h3><p>&emsp;&emsp;正则表达式默认采用贪婪匹配模式，在该模式下意味着会匹配尽可能长的子串。我们可以使用 ? 将贪婪匹配模式转化为惰性匹配模式。</p><blockquote><p>“/(.*at)/“ =&gt; <strong>The fat cat sat on the mat</strong>. </p></blockquote><blockquote><p>“/(.*?at)/“ =&gt; <strong>The fat</strong> cat sat on the mat. </p></blockquote><hr><h2 id="第三节-捕获组和非捕获组"><a href="#第三节-捕获组和非捕获组" class="headerlink" title="第三节 捕获组和非捕获组"></a><strong>第三节 捕获组和非捕获组</strong></h2><p>&emsp;&emsp;捕获组就是把正则表达式中子表达式匹配的内容，保存到内存中以数字编号或显式命名的组里，方便后面引用。当然，这种引用既可以是在正则表达式内部，也可以是在正则表达式外部。一般一个小括号括起来就是一个捕获组。捕获组可以进行嵌套。以深度优先进行编号，在js中编号从1开始。</p><p>&emsp;&emsp;参与匹配却不进行分组编号的捕获组，其形式为（?:exp）组成，还有其他的形式</p><hr><h2 id="第四节-贪婪、勉强和独占模式"><a href="#第四节-贪婪、勉强和独占模式" class="headerlink" title="第四节 贪婪、勉强和独占模式"></a><strong>第四节 贪婪、勉强和独占模式</strong></h2><h3 id="1-贪婪模式"><a href="#1-贪婪模式" class="headerlink" title="1 贪婪模式"></a><strong>1 贪婪模式</strong></h3><p>&emsp;&emsp;匹配最长。在贪婪量词模式下，正则表达式会尽可能长地去匹配符合规则的字符串，且会回溯。</p><figure class="highlight gradle"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">String <span class="keyword">source</span> = <span class="string">"&lt;ol&gt;&lt;li&gt;Ggicci's Blog&lt;/li&gt;&lt;li&gt;Ggicci's Facebook&lt;/li&gt;&lt;/ol&gt;"</span>;</span><br><span class="line">Pattern pattern = Pattern.<span class="keyword">compile</span>(<span class="string">"&lt;li&gt;.*&lt;/li&gt;"</span>);</span><br><span class="line">Matcher matcher = pattern.matcher(<span class="keyword">source</span>);</span><br><span class="line"><span class="keyword">while</span> (matcher.<span class="keyword">find</span>()) &#123;</span><br><span class="line">    System.out.<span class="keyword">println</span>(matcher.<span class="keyword">group</span>());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>&emsp;&emsp;输出：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">li</span>&gt;</span>Ggicci's Blog<span class="tag">&lt;/<span class="name">li</span>&gt;</span><span class="tag">&lt;<span class="name">li</span>&gt;</span>Ggicci's Facebook<span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br></pre></td></tr></table></figure><p>&emsp;&emsp;解释：首先 .<em> 匹配任何字符（在非 DOTALL 模式下不匹配 \n,\r,\a 一类字符），在 source 中第一个被匹配的 &lt; li &gt; 后面直至最后一个字符（也就是&lt; /ol &gt;的 &gt;）都符合 .</em> 的匹配规则，但是显然如果 .* 匹配到最后一个字符，那么没有剩余的字符去匹配正则表达式中还未匹配的 &lt; /li &gt; 的，那么会引起匹配失败。但是失败后会回溯（这一点与独占量词不同，下面会讲到）。回溯后这段正则表达式将匹配到 source 中第一个 &lt; li &gt; 和第二个 &lt; /li &gt; 以及之间的内容，如上面的输出所示。</p><h3 id="2-勉强模式"><a href="#2-勉强模式" class="headerlink" title="2 勉强模式"></a><strong>2 勉强模式</strong></h3><p>&emsp;&emsp;匹配最短。在勉强量词模式下，正则表达式会匹配尽可能短的字符串。</p><figure class="highlight gradle"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">String <span class="keyword">source</span> = <span class="string">"&lt;ol&gt;&lt;li&gt;Ggicci's Blog&lt;/li&gt;&lt;li&gt;Ggicci's Facebook&lt;/li&gt;&lt;/ol&gt;"</span>;</span><br><span class="line">Pattern pattern = Pattern.<span class="keyword">compile</span>(<span class="string">"&lt;li&gt;.*?&lt;/li&gt;"</span>);</span><br><span class="line">Matcher matcher = pattern.matcher(<span class="keyword">source</span>);</span><br><span class="line"><span class="keyword">while</span> (matcher.<span class="keyword">find</span>()) &#123;</span><br><span class="line">    System.out.<span class="keyword">println</span>(matcher.<span class="keyword">group</span>());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>&emsp;&emsp;输出：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">li</span>&gt;</span>Ggicci's Blog<span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">li</span>&gt;</span>Ggicci's Facebook<span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br></pre></td></tr></table></figure><p>&emsp;&emsp;解释：source 中第一个&lt; li &gt;匹配到之后到第一个&lt; /li &gt;之间的字符都符合 .* 的匹配规则，同时如果继续匹配 &lt; /li &gt; 也符合这个规则，但是勉强模式下，它会尽可能短地匹配字符串，故第一个找到的字符串应该是 &lt; li &gt;Ggicci’s Blog&lt; /li &gt;，如上面输出所示。然后它会继续匹配剩余的字符串，找到第二个。</p><h3 id="3-独占模式"><a href="#3-独占模式" class="headerlink" title="3 独占模式"></a><strong>3 独占模式</strong></h3><p>&emsp;&emsp;同贪婪一样匹配最长。不过在独占量词模式下，正则表达式尽可能长地去匹配字符串，一旦匹配不成功就会结束匹配而不会回溯。</p><figure class="highlight gradle"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">String <span class="keyword">source</span> = <span class="string">"&lt;ol&gt;&lt;li&gt;Ggicci's Blog&lt;/li&gt;&lt;li&gt;Ggicci's Facebook&lt;/li&gt;&lt;/ol&gt;"</span>;</span><br><span class="line">Pattern pattern = Pattern.<span class="keyword">compile</span>(<span class="string">"&lt;li&gt;.*+&lt;/li&gt;"</span>);</span><br><span class="line">Matcher matcher = pattern.matcher(<span class="keyword">source</span>);</span><br><span class="line"><span class="keyword">while</span> (matcher.<span class="keyword">find</span>()) &#123;</span><br><span class="line">    System.out.<span class="keyword">println</span>(matcher.<span class="keyword">group</span>());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>&emsp;&emsp;解释：这段正则表达式将不会在 source 找到任何匹配的内容，因为 &lt; li &gt; 匹配到后， .*+ 所能匹配的字符尽可能长地匹配下去，直到 source 的最后一个字符，这必将引起匹配失败，但是在独占模式下一旦匹配失败就不会回溯，故不存在像贪婪模式一样回溯之后找到 &lt; /ol &gt;之前的&lt; /li &gt; 的情况。</p><hr><p><em>参考博客和文章书籍等：</em></p><blockquote><p><a href="https://github.com/ziishaned/learn-regex/blob/master/translations/README-cn.md" title="Title" target="_blank" rel="noopener">learn-regex</a></p></blockquote><p><em>因博客主等未标明不可引用，若部分内容涉及侵权请及时告知，我会尽快修改和删除相关内容</em></p>]]></content>
    
    <summary type="html">
    
      简单介绍正则表达式，包括：简单介绍，元字符，用法，捕获组和非捕获组，贪婪、勉强和独占模式等。
    
    </summary>
    
      <category term="技术文档" scheme="http://linyishui.top/categories/%E6%8A%80%E6%9C%AF%E6%96%87%E6%A1%A3/"/>
    
    
      <category term="regex" scheme="http://linyishui.top/tags/regex/"/>
    
  </entry>
  
  <entry>
    <title>CentOS（未完成）</title>
    <link href="http://linyishui.top/2019091401.html"/>
    <id>http://linyishui.top/2019091401.html</id>
    <published>2019-09-14T06:40:30.000Z</published>
    <updated>2019-12-09T09:59:55.223Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>&emsp;&emsp;远程连接密码和实例用户密码（root）</p><p>&emsp;&emsp;进入/usr/local目录</p><blockquote><p>cd /usr/local</p></blockquote><p>&emsp;&emsp;创建/usr/local/java目录</p><blockquote><p>mkdir java</p><p>cd java</p></blockquote><p>&emsp;&emsp;通过openjdk安装JDK8</p><blockquote><p>yum -y install java-1.8.0-openjdk</p><p>java -version</p></blockquote><p>&emsp;&emsp;重命名</p><blockquote><p>mv jdk1.8.0_171 jdk1.8</p></blockquote><p>&emsp;&emsp;解压</p><blockquote><p>tar -xzvf jdk-8u171-linux-x64.tar.gz</p></blockquote><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">① cd + 目录名</span><br><span class="line"></span><br><span class="line">② cd + 空格（退回上级目录）</span><br><span class="line"></span><br><span class="line">③ cd + 空格 + /（退回最高级目录）</span><br><span class="line"></span><br><span class="line">vi + 文件名命令，打开文件，然后输入命令：/ + 要修改的关键词，查找到要修改的内容，然后使用命令进入【文本输入模式】，常用的命令如下：</span><br><span class="line"></span><br><span class="line">① <span class="selector-tag">a</span> 在光标之后开始输入文本</span><br><span class="line">② A 在行尾开始输入文本</span><br><span class="line">③ <span class="selector-tag">i</span> 在光标之前开始输入文本</span><br><span class="line">④ I 在行首第一个非空白字符前输入文本</span><br><span class="line">⑤ o 在光标所在行后插入一空行</span><br><span class="line">⑥ O 在光标所在行前插入一空行</span><br><span class="line">【二】保存退出</span><br><span class="line"></span><br><span class="line">修改好文件后，如果在【文本输入模式】下，首先按“ESC” 键进入【命令模式】，然后输入“:”，进入【末行模式】，在末行模式下，可使用如下退出命令：</span><br><span class="line"></span><br><span class="line">① <span class="selector-tag">q</span> 是直接退出；</span><br><span class="line"></span><br><span class="line">② wq 保存后退出；</span><br><span class="line"></span><br><span class="line">③ q! 强制退出；</span><br><span class="line"></span><br><span class="line">④ wq! 强制保存退出；</span><br></pre></td></tr></table></figure><h2 id="创建用户"><a href="#创建用户" class="headerlink" title="创建用户"></a><strong>创建用户</strong></h2><p>&emsp;&emsp;</p><figure class="highlight ebnf"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="attribute">useradd xx</span></span><br><span class="line"><span class="attribute">passwd xx</span></span><br></pre></td></tr></table></figure><p>&emsp;&emsp;未完待续</p>]]></content>
    
    <summary type="html">
    
      简单介绍CentOS系统。
    
    </summary>
    
      <category term="技术文档" scheme="http://linyishui.top/categories/%E6%8A%80%E6%9C%AF%E6%96%87%E6%A1%A3/"/>
    
    
      <category term="unfinished" scheme="http://linyishui.top/tags/unfinished/"/>
    
      <category term="os" scheme="http://linyishui.top/tags/os/"/>
    
  </entry>
  
</feed>
