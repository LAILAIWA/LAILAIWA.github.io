<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>俺的部落格</title>
  
  <subtitle>俺寻思俺需要记点东西</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://linyishui.top/"/>
  <updated>2020-04-17T11:02:16.959Z</updated>
  <id>http://linyishui.top/</id>
  
  <author>
    <name>Speciosity</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>WebSocket</title>
    <link href="http://linyishui.top/2020041701.html"/>
    <id>http://linyishui.top/2020041701.html</id>
    <published>2020-04-17T01:31:16.000Z</published>
    <updated>2020-04-17T11:02:16.959Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="WebSocket"><a href="#WebSocket" class="headerlink" title="WebSocket"></a><strong>WebSocket</strong></h1><h2 id="第一节-简介"><a href="#第一节-简介" class="headerlink" title="第一节 简介"></a><strong>第一节 简介</strong></h2><h3 id="1-1-为什么需要WebSocket"><a href="#1-1-为什么需要WebSocket" class="headerlink" title="1.1 为什么需要WebSocket"></a><strong>1.1 为什么需要WebSocket</strong></h3><p>​        我们已经有了HTTP协议，为什么还需要使用WebSocket呢？答案就是解决HTTP的缺陷-<strong>通信只能由客户端发起</strong>。</p><p>​        很多场景下我们需要由服务端主动向客户端推送消息，而HTTP协议这种单向请求的设计注定了服务器端有连续的状态变化时，客户端很难去获知。</p><p>​        早期，很多网站为了实现<a href="https://zh.wikipedia.org/wiki/推送技术" target="_blank" rel="noopener">推送技术</a>，所用的技术都是<a href="https://zh.wikipedia.org/wiki/輪詢" target="_blank" rel="noopener">轮询</a>。轮询是指由浏览器每隔一段时间（如每秒）向服务器发出HTTP请求，然后服务器返回最新的数据给客户端。这种传统的模式带来很明显的缺点，即浏览器需要不断的向服务器发出请求，然而HTTP请求与回复可能会包含较长的<a href="https://zh.wikipedia.org/wiki/HTTP头字段" target="_blank" rel="noopener">头部</a>，其中真正有效的数据可能只是很小的一部分，所以这样会消耗很多带宽资源，最常见的场景就是聊天室。</p><p><img src="https://pic-1258215793.cos.ap-shanghai.myqcloud.com/content/20200401/202004010102.png" alt=""></p><p>​        比较新的轮询技术是<a href="https://zh.wikipedia.org/wiki/Comet_(web技术" target="_blank" rel="noopener">Comet</a>)。这种技术虽然可以实现双向通信，但仍然需要反复发出请求。而且在Comet中普遍采用的<a href="https://zh.wikipedia.org/wiki/HTTP持久链接" target="_blank" rel="noopener">HTTP长连接</a>也会消耗服务器资源。</p><p>​        由此契机催生了WebSocket协议，<a href="https://zh.wikipedia.org/wiki/HTML5" target="_blank" rel="noopener">HTML5</a>定义了WebSocket协议，能更好的节省服务器资源和带宽，并且能够更实时地进行通讯。</p><h3 id="1-2-什么是WebSocket"><a href="#1-2-什么是WebSocket" class="headerlink" title="1.2 什么是WebSocket"></a><strong>1.2 什么是WebSocket</strong></h3><p>​        <strong>WebSocket</strong>是一种<a href="https://zh.wikipedia.org/wiki/网络传输协议" target="_blank" rel="noopener">网络传输协议</a>，可在单个<a href="https://zh.wikipedia.org/wiki/传输控制协议" target="_blank" rel="noopener">TCP</a>连接上进行<a href="https://zh.wikipedia.org/wiki/全雙工" target="_blank" rel="noopener">全双工</a>通信，位于<a href="https://zh.wikipedia.org/wiki/OSI模型" target="_blank" rel="noopener">OSI模型</a>的<a href="https://zh.wikipedia.org/wiki/应用层" target="_blank" rel="noopener">应用层</a>。</p><p>​        WebSocket协议诞生于2008年，最初在<a href="https://zh.wikipedia.org/wiki/HTML5" target="_blank" rel="noopener">HTML5</a>规范中被引用为TCPConnection，作为基于TCP的套接字API的占位符。2008年6月，<a href="https://zh.wikipedia.org/w/index.php?title=Michael_Carter&amp;action=edit&amp;redlink=1" target="_blank" rel="noopener">Michael Carter</a>进行了一系列讨论，最终形成了称为WebSocket的协议。</p><p>​        WebSocket使得客户端和服务器之间的数据交换变得更加简单，允许服务端主动向客户端推送数据。在WebSocket API中，浏览器和服务器只需要完成一次握手，两者之间就可以创建持久性的连接，并进行双向数据传输。</p><p>​        WebSocket是一种与<a href="https://zh.wikipedia.org/wiki/超文本传输协议" target="_blank" rel="noopener">HTTP</a>不同的协议。两者都位于<a href="https://zh.wikipedia.org/wiki/OSI模型" target="_blank" rel="noopener">OSI模型</a>的<a href="https://zh.wikipedia.org/wiki/应用层" target="_blank" rel="noopener">应用层</a>，并且都依赖于<a href="https://zh.wikipedia.org/wiki/传输层" target="_blank" rel="noopener">传输层</a>的TCP协议。 虽然它们不同，但是RFC 6455中规定：<code>it is designed to work over HTTP ports 80 and 443 as well as to support HTTP proxies and intermediaries</code>（WebSocket通过HTTP端口80和443进行工作，并支持HTTP代理和中介），从而使其与HTTP协议兼容。 为了实现兼容性，WebSocket握手使用HTTP Upgrade头<a href="https://zh.wikipedia.org/wiki/WebSocket#cite_note-1" target="_blank" rel="noopener">[1]</a>从HTTP协议更改为WebSocket协议。</p><p>​        WebSocket协议支持Web<a href="https://zh.wikipedia.org/wiki/浏览器" target="_blank" rel="noopener">浏览器</a>（或其他客户端应用程序）与Web<a href="https://zh.wikipedia.org/wiki/服务器" target="_blank" rel="noopener">服务器</a>之间的交互，具有较低的开销，便于实现客户端与服务器的实时数据传输。 服务器可以通过标准化的方式来实现，而无需客户端首先请求内容，并允许消息在保持连接打开的同时来回传递。通过这种方式，可以在客户端和服务器之间进行双向持续对话。 通信通过TCP端口80或443完成，这在防火墙阻止非Web网络连接的环境下是有益的。另外，<a href="https://zh.wikipedia.org/wiki/Comet_(web技术" target="_blank" rel="noopener">Comet</a>)之类的技术以非标准化的方式实现了类似的双向通信。</p><p>​        <strong>与HTTP不同，WebSocket提供全双工通信</strong>。<a href="https://zh.wikipedia.org/wiki/WebSocket#cite_note-2" target="_blank" rel="noopener">[2]</a><a href="https://zh.wikipedia.org/wiki/WebSocket#cite_note-quantum-3" target="_blank" rel="noopener">[3]</a>此外，<strong>WebSocket还可以在TCP之上实现消息流</strong>。TCP单独处理字节流，没有固有的消息概念。 在WebSocket之前，使用Comet可以实现全双工通信。但是Comet存在TCP握手和HTTP头的开销，因此对于小消息来说效率很低。WebSocket协议旨在解决这些问题。</p><blockquote><ul><li>单工通信：即只能A到B（广播），同一时间只允许一方向另一方传送消息，另一方则不允许反过来传送。</li><li>全双工：指在发送数据的同时也能接收数据，二者同步进行。</li><li>半双工：指在一个时间段内只有一个动作发生，数据信息可以沿两个方向传送，但同一时刻一个信道只允许单方向传送，因此也称为双向交替通信。如果要改变传输方向，需由开关进行切换。半双工方式要求收发两端都有发送装置和接收装置。由于这种方式要频繁变换信道方向，故效率低，但可以节约传输线路。半双工方式适用于终端与终端之间的会话式通信。</li></ul></blockquote><p>​        WebSocket协议规范将<code>ws</code>（WebSocket）和<code>wss</code>（WebSocket Secure）定义为两个新的<a href="https://zh.wikipedia.org/wiki/統一資源標識符" target="_blank" rel="noopener">统一资源标识符</a>（URI）方案<a href="https://zh.wikipedia.org/wiki/WebSocket#cite_note-4" target="_blank" rel="noopener">[4]</a>，分别对应明文和加密连接，其中<code>wss</code>表示使用了<a href="https://zh.wikipedia.org/wiki/TLS" target="_blank" rel="noopener">TLS</a>的Websocket。除了方案名称和片段ID（不支持<code>#</code>）之外，其余的URI组件都被定义为此URI的通用语法。<a href="https://zh.wikipedia.org/wiki/WebSocket#cite_note-5" target="_blank" rel="noopener">[5]</a></p><figure class="highlight vim"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">w</span><span class="variable">s:</span>//example.<span class="keyword">com</span>/wsapi</span><br><span class="line"><span class="keyword">ws</span><span class="variable">s:</span>//secure.example.<span class="keyword">com</span>/wsapi</span><br></pre></td></tr></table></figure><p>​        默认情况下，Websocket协议使用80端口；运行在TLS之上时，默认使用443端口。        </p><p>​        使用浏览器开发人员工具，开发人员可以检查WebSocket握手以及WebSocket框架。</p><h3 id="1-3-优点"><a href="#1-3-优点" class="headerlink" title="1.3 优点"></a><strong>1.3 优点</strong></h3><ul><li><p><strong>较少的控制开销</strong>。在连接创建后，服务器和客户端之间交换数据时，用于协议控制的数据包头部相对较小。在不包含扩展的情况下，对于服务器到客户端的内容，此头部大小只有2至10<a href="https://zh.wikipedia.org/wiki/字节" target="_blank" rel="noopener">字节</a>（和数据包长度有关）；对于客户端到服务器的内容，此头部还需要加上额外的4字节的<a href="https://zh.wikipedia.org/wiki/掩码" target="_blank" rel="noopener">掩码</a>。相对于HTTP请求每次都要携带完整的头部，此项开销显著减少了。</p></li><li><p><strong>更强的实时性</strong>。由于协议是全双工的，所以服务器可以随时主动给客户端下发数据。相对于HTTP请求需要等待客户端发起请求服务端才能响应，延迟明显更少；即使是和Comet等类似的<a href="https://zh.wikipedia.org/w/index.php?title=长轮询&amp;action=edit&amp;redlink=1" target="_blank" rel="noopener">长轮询</a>比较，其也能在短时间内更多次地传递数据。</p></li><li><p><strong>保持连接状态</strong>。与HTTP不同的是，Websocket需要先创建连接，这就使得其成为一种有状态的协议，之后通信时可以省略部分状态信息。而HTTP请求可能需要在每个请求都携带状态信息（如身份认证等）。</p></li><li><p><strong>更好的二进制支持</strong>。Websocket定义了<a href="https://zh.wikipedia.org/wiki/二进制" target="_blank" rel="noopener">二进制</a>帧，相对HTTP，可以更轻松地处理二进制内容。</p></li><li><p><strong>可以支持扩展</strong>。Websocket定义了扩展，用户可以扩展协议、实现部分自定义的子协议。如部分浏览器支持<a href="https://zh.wikipedia.org/wiki/数据压缩" target="_blank" rel="noopener">压缩</a>等。</p></li><li><p><strong>更好的压缩效果</strong>。相对于<a href="https://zh.wikipedia.org/wiki/HTTP压缩" target="_blank" rel="noopener">HTTP压缩</a>，Websocket在适当的扩展支持下，可以沿用之前内容的<a href="https://zh.wikipedia.org/wiki/上下文" target="_blank" rel="noopener">上下文</a>，在传递类似的数据时，可以显著地提高压缩率。<a href="https://zh.wikipedia.org/wiki/WebSocket#cite_note-14" target="_blank" rel="noopener">[14]</a></p></li></ul><hr><h2 id="第二节-HTML5-WebSocket"><a href="#第二节-HTML5-WebSocket" class="headerlink" title="第二节 HTML5 WebSocket"></a><strong>第二节 HTML5 WebSocket</strong></h2><p>​        浏览器通过 JavaScript 向服务器发出建立 WebSocket 连接的请求，连接建立以后，客户端和服务器端就可以通过 TCP 连接直接交换数据。</p><p>​        当你获取 Web Socket 连接后，你可以通过 <strong>send()</strong> 方法来向服务器发送数据，并通过 <strong>onmessage</strong> 事件来接收服务器返回的数据。</p><p>以下 API 用于创建 WebSocket 对象。</p><figure class="highlight haxe"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> Socket = <span class="keyword">new</span> <span class="type">WebSocket</span>(url, [protocol] );</span><br></pre></td></tr></table></figure><p>以上代码中的第一个参数 url, 指定连接的 URL。第二个参数 protocol 是可选的，指定了可接受的子协议。</p><hr><h2 id="第三节-实现"><a href="#第三节-实现" class="headerlink" title="第三节 实现"></a><strong>第三节 实现</strong></h2><hr><p><em>参考博客和文章书籍等：</em></p><blockquote><p><a href="https://zh.wikipedia.org/zh-hans/WebSocket" target="_blank" rel="noopener">WebSocket-维基百科</a></p><p><a href="https://www.runoob.com/html/html5-websocket.html" target="_blank" rel="noopener">html5-websocket-菜鸟教程</a></p><p><a href="http://www.ruanyifeng.com/blog/2017/05/websocket.html" target="_blank" rel="noopener">WebSocket 教程</a></p></blockquote><p><em>因博客主等未标明不可引用，若部分内容涉及侵权请及时告知，我会尽快修改和删除相关内容</em></p>]]></content>
    
    <summary type="html">
    
      简单介绍WebSocket相关知识，内容包括：。
    
    </summary>
    
      <category term="个人记录" scheme="http://linyishui.top/categories/%E4%B8%AA%E4%BA%BA%E8%AE%B0%E5%BD%95/"/>
    
    
      <category term="websocket" scheme="http://linyishui.top/tags/websocket/"/>
    
  </entry>
  
  <entry>
    <title>Nginx简单处理一次灰度发布问题</title>
    <link href="http://linyishui.top/2020041501.html"/>
    <id>http://linyishui.top/2020041501.html</id>
    <published>2020-04-15T06:28:48.000Z</published>
    <updated>2020-04-16T09:41:22.099Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="Nginx简单处理一次灰度发布问题"><a href="#Nginx简单处理一次灰度发布问题" class="headerlink" title="Nginx简单处理一次灰度发布问题"></a><strong>Nginx简单处理一次灰度发布问题</strong></h1><h2 id="1-需求"><a href="#1-需求" class="headerlink" title="1.需求"></a><strong>1.需求</strong></h2><p>&emsp;&emsp;公司接手的一个半成品项目，客户要求更新版本时不要停掉网站（灰度发布）。</p><p>&emsp;&emsp;马上想到的方案是：主从热备和负载均衡，nginx+keepalived，然后又想到了自动部署-CI/CD，及时打住避免越想越远。这个项目本身比较粗糙，简单的解决当前的问题即可。</p><p>&emsp;&emsp;原系统使用session存储会话信息，所以还要解决session如何共享的问题，google了一下，决定nginx配置两台服务器负载均衡，发布新版本时，一次更新一个，然后使用Redis来共享session。</p><h2 id="2-实现"><a href="#2-实现" class="headerlink" title="2.实现"></a><strong>2.实现</strong></h2><p>&emsp;&emsp;时间和精力有限，先在本地和测试服务器跑通一个demo。</p><p>&emsp;&emsp;两台机器：本机，服务器A</p><table><thead><tr><th style="text-align:center">工具</th><th style="text-align:center">本机</th><th style="text-align:center">服务器A</th></tr></thead><tbody><tr><td style="text-align:center">JDK 1.8</td><td style="text-align:center">√</td><td style="text-align:center">√</td></tr><tr><td style="text-align:center">Nginx</td><td style="text-align:center">√</td><td style="text-align:center">×</td></tr><tr><td style="text-align:center">Redis</td><td style="text-align:center">×</td><td style="text-align:center">√</td></tr></tbody></table><h3 id="2-1-代码"><a href="#2-1-代码" class="headerlink" title="2.1 代码"></a><strong>2.1 代码</strong></h3><p>&emsp;&emsp;首先新建spring-boot项目，代码如下。</p><h4 id="1-pom-xml"><a href="#1-pom-xml" class="headerlink" title="(1) pom.xml"></a><strong>(1) pom.xml</strong></h4><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-web<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.session<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-session-core<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-data-redis<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.session<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-session-data-redis<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.projectlombok<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>lombok<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">optional</span>&gt;</span>true<span class="tag">&lt;/<span class="name">optional</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure><h4 id="2-application-properties"><a href="#2-application-properties" class="headerlink" title="(2) application.properties"></a><strong>(2) application.properties</strong></h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">server.port=8022</span><br><span class="line"></span><br><span class="line">spring.redis.host=&#123;服务器A&#125;</span><br><span class="line">spring.redis.port=6379</span><br><span class="line">spring.redis.password=</span><br><span class="line">spring.redis.timeout=5000</span><br></pre></td></tr></table></figure><h4 id="3-Application"><a href="#3-Application" class="headerlink" title="(3) Application"></a><strong>(3) Application</strong></h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@SpringBootApplication</span></span><br><span class="line"><span class="meta">@EnableRedisHttpSession</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">NginxKeepalivedRedisDemoApplication</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        SpringApplication.run(NginxKeepalivedRedisDemoApplication.class, args);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="4-控制器和实体类"><a href="#4-控制器和实体类" class="headerlink" title="(4) 控制器和实体类"></a><strong>(4) 控制器和实体类</strong></h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@RestController</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">LoginController</span> </span>&#123;</span><br><span class="line">    <span class="meta">@GetMapping</span>(value = <span class="string">"/login"</span>)</span><br><span class="line">    <span class="function"><span class="keyword">public</span> Map&lt;String, Object&gt; <span class="title">login</span><span class="params">(HttpSession session)</span> <span class="keyword">throws</span> UnknownHostException </span>&#123;</span><br><span class="line">        Map&lt;String, Object&gt; content = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line">        content.put(<span class="string">"sessionId"</span>,session.getId());</span><br><span class="line">        UserInfo userInfo = <span class="keyword">new</span> UserInfo(<span class="string">"01"</span>,<span class="string">"张三"</span>);</span><br><span class="line">        session.setAttribute(<span class="string">"userInfo"</span>, userInfo);</span><br><span class="line">        content.put(<span class="string">"hostAddress"</span>,InetAddress.getLocalHost().getHostAddress());</span><br><span class="line">        content.put(<span class="string">"hostName"</span>,InetAddress.getLocalHost().getHostName());</span><br><span class="line">        <span class="keyword">return</span> content;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Data</span></span><br><span class="line"><span class="meta">@AllArgsConstructor</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">UserInfo</span> <span class="keyword">implements</span> <span class="title">Serializable</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">long</span> serialVersionUID = <span class="number">5392373940126446170L</span>;</span><br><span class="line">    <span class="keyword">private</span> String id;</span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="2-2-调试"><a href="#2-2-调试" class="headerlink" title="2.2 调试"></a><strong>2.2 调试</strong></h3><p>&emsp;&emsp;尝试启动，发现报错：Connection refused: no further information。很明显Redis无法连接。</p><p>&emsp;&emsp;先开了下命令行，尝试 telnet 服务器A 6379 ，无法连通。</p><p>&emsp;&emsp;检查了一下防火墙，确认端口已经开放了，然后又检查了一下阿里云控制平台上是否在安全组中开放端口，发现也是正确的。</p><p>&emsp;&emsp;google了一下，尝试修改redis.conf，将bind 127.0.0.1 修改为0.0.0.0。</p><p>&emsp;&emsp;再次telnet，可以连通，分别在本地和服务器A发布服务（服务器端口8022被占用，启动时指定了端口8023），并分别访问：http://{服务器A}:8023/login</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"># 服务器A返回如下：</span><br><span class="line">&#123;</span><br><span class="line">    <span class="attr">"hostName"</span>:<span class="string">"xxxx"</span>,</span><br><span class="line">    <span class="attr">"sessionId"</span>:<span class="string">"6a5e81a6-04f4-4ca8-afd4-1559695c1446"</span>,</span><br><span class="line">    <span class="attr">"hostAddress"</span>:<span class="string">"xxx.xxx.xxx.xxx"</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"># 本地返回如下：</span><br><span class="line">&#123;</span><br><span class="line">    <span class="attr">"hostName"</span>:<span class="string">"DESKTOP-xx"</span>,</span><br><span class="line">    <span class="attr">"sessionId"</span>:<span class="string">"2a7c4873-1f9b-414a-85fc-6298562de64b"</span>,</span><br><span class="line">    <span class="attr">"hostAddress"</span>:<span class="string">"192.168.31.197"</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>&emsp;&emsp;访问：<a href="http://qxamoy.com:8023/login" target="_blank" rel="noopener">http://qxamoy.com:8023/login</a></p><p>&emsp;&emsp;修改配置文件nginx.conf（我新建了一个demo.conf并在nginx.conf中引用）。</p><figure class="highlight axapta"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta"># 负载均衡配置</span></span><br><span class="line">upstream demo_upstream&#123;</span><br><span class="line">  <span class="keyword">server</span> <span class="number">127.0</span><span class="number">.0</span><span class="number">.1</span>:<span class="number">8022</span> weight=<span class="number">10</span>;</span><br><span class="line">  <span class="keyword">server</span> xxx:<span class="number">8023</span> weight=<span class="number">20</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">#虚拟主机的配置</span></span><br><span class="line"><span class="keyword">server</span> &#123;</span><br><span class="line">    <span class="meta">#监听端口</span></span><br><span class="line">    listen <span class="number">7051</span>;</span><br><span class="line">    <span class="meta"># 指定ip地址或者域名，多个配置之间用空格分隔</span></span><br><span class="line">    server_name localhost;</span><br><span class="line">    </span><br><span class="line">    <span class="meta">#对 "/" 启用反向代理</span></span><br><span class="line">    location / &#123;</span><br><span class="line">            proxy_pass http:<span class="comment">//demo_upstream;</span></span><br><span class="line">            ...</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>&emsp;&emsp;启动nginx。</p><figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">start nginx.exe</span><br></pre></td></tr></table></figure><p>&emsp;&emsp;访问<a href="http://localhost:7051/login" target="_blank" rel="noopener">http://localhost:7051/login</a></p><p>&emsp;&emsp;可以观察每次请求后返回结果的变化（ip和session），顺利的话会看到根据权重来切换接收的服务端，所以日常更新版本时可以依次对单个服务器进行更新来完成“灰度发布”。</p><hr><p><em>参考博客和文章书籍等：</em></p><blockquote><p><a href="https://www.v2ex.com/t/477509" target="_blank" rel="noopener">大家是怎么做到服务器热更新的?</a></p><p><a href="https://blog.csdn.net/IT_10/article/details/89365436" target="_blank" rel="noopener">超详细的Nginx负载均衡+高可用配置</a></p><p><a href="https://www.cnblogs.com/54chensongxia/p/12096493.html" target="_blank" rel="noopener">Spring系列.@EnableRedisHttpSession原理简析</a></p></blockquote><p><em>因博客主等未标明不可引用，若部分内容涉及侵权请及时告知，我会尽快修改和删除相关内容</em></p>]]></content>
    
    <summary type="html">
    
      使用Nginx来简单处理一次灰度发布的问题，更新网站后台同时“不停掉服务”。
    
    </summary>
    
      <category term="个人记录" scheme="http://linyishui.top/categories/%E4%B8%AA%E4%BA%BA%E8%AE%B0%E5%BD%95/"/>
    
    
      <category term="nginx" scheme="http://linyishui.top/tags/nginx/"/>
    
  </entry>
  
  <entry>
    <title>Postman笔记（持续更新）</title>
    <link href="http://linyishui.top/2020041001.html"/>
    <id>http://linyishui.top/2020041001.html</id>
    <published>2020-04-10T07:41:30.000Z</published>
    <updated>2020-04-10T07:50:25.676Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="Postman笔记"><a href="#Postman笔记" class="headerlink" title="Postman笔记"></a><strong>Postman笔记</strong></h1><h2 id="1-自动获取Token"><a href="#1-自动获取Token" class="headerlink" title="1. 自动获取Token"></a><strong>1. 自动获取Token</strong></h2><p>&emsp;&emsp;首先根据login-api返回body确定token的位置。</p><p>&emsp;&emsp;然后在login-api中设置Tests，增加如下代码。</p><figure class="highlight haskell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="title">pm</span>.test(<span class="string">"Status code is 200"</span>, function () &#123;</span><br><span class="line">    pm.response.to.have.status(<span class="number">200</span>);</span><br><span class="line">&#125;);</span><br><span class="line"> </span><br><span class="line"><span class="title">var</span> <span class="class"><span class="keyword">data</span> = <span class="type">JSON</span>.parse(<span class="title">responseBody</span>);</span></span><br><span class="line"><span class="meta"># 项目多了一个Bearer，postman会自动生成，所以导致出现两个Bearer</span></span><br><span class="line"><span class="title">var</span> temp = <span class="class"><span class="keyword">data</span>.token.substring(7);</span></span><br><span class="line"><span class="title">pm</span>.environment.set(<span class="string">"token"</span>, temp);</span><br></pre></td></tr></table></figure><p>&emsp;&emsp;添加自定义environment。</p><p>&emsp;&emsp;重新发送登录请求，观察是否自动生成环境变量。</p><p>&emsp;&emsp;接下来在使用token的api中通过的方式来获取变量，【Authorization】-&gt;【TYPE-Bearer Token】</p><hr><p><em>参考博客和文章书籍等：</em></p><blockquote><p><a href="https://www.postman.com/api-documentation-generator" title="Title" target="_blank" rel="noopener">postman-doc</a></p></blockquote><p><em>因博客主等未标明不可引用，若部分内容涉及侵权请及时告知，我会尽快修改和删除相关内容</em></p>]]></content>
    
    <summary type="html">
    
      Postman笔记
    
    </summary>
    
      <category term="个人记录" scheme="http://linyishui.top/categories/%E4%B8%AA%E4%BA%BA%E8%AE%B0%E5%BD%95/"/>
    
    
      <category term="updating" scheme="http://linyishui.top/tags/updating/"/>
    
      <category term="postman" scheme="http://linyishui.top/tags/postman/"/>
    
  </entry>
  
  <entry>
    <title>Hexo+GitHub搭建个人博客 (六) 异常解决记录</title>
    <link href="http://linyishui.top/2020040301.html"/>
    <id>http://linyishui.top/2020040301.html</id>
    <published>2020-04-03T02:31:00.000Z</published>
    <updated>2020-04-03T10:24:51.466Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="Hexo异常解决记录"><a href="#Hexo异常解决记录" class="headerlink" title="Hexo异常解决记录"></a><strong>Hexo异常解决记录</strong></h1><h2 id="unknown-block-tag-endif"><a href="#unknown-block-tag-endif" class="headerlink" title="unknown block tag: endif"></a><strong>unknown block tag: endif</strong></h2><p>&emsp;&emsp;一次更新博客（hexo g）时，出现以下异常。</p><p><img src="https://pic-1258215793.cos.ap-shanghai.myqcloud.com/content/20200401/202004010101.png" alt=""></p><p>&emsp;&emsp;google了一下，看到有类似问题的是因为在’{‘和’%’之间多写了空格这种语法错误，所以花了一些时间去找项目中的swig文件，因为刚好这次更新也有增加一些博客功能，怀疑是不是修改swig文件时也写错了。(<a href="https://52heartz.top/articles/hexo-template-render-error/" title="title" target="_blank" rel="noopener">Hexo 的 Template render error 错误</a> 和 <a href="https://github.com/hexojs/hexo/issues/3346" title="title" target="_blank" rel="noopener">hexo 在markdown文档中出现<code>{-% %-}</code>语法会报错，提示“Template render error: (unknown path) </a>)</p><p>&emsp;&emsp;但很快便发现没有找到异常，所以思考了一下，既然代码文件中的endif没有问题，会不会是其他地方也写了endif，突然想到这次提交也更新了MD文件，记录我这次更新，其中也直接记录了{\% endif \%}，所以就修改了相关描述。</p><p>&emsp;&emsp;重试了一下，问题解决。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;link rel=&quot;stylesheet&quot; class=&quot;aplayer-secondary-style-marker&quot; href=&quot;\assets\css\APlayer.min.css&quot;&gt;&lt;script src=&quot;\assets\js\APlayer.min.js&quot; cla
      
    
    </summary>
    
      <category term="搭建博客" scheme="http://linyishui.top/categories/%E6%90%AD%E5%BB%BA%E5%8D%9A%E5%AE%A2/"/>
    
    
      <category term="hexo" scheme="http://linyishui.top/tags/hexo/"/>
    
  </entry>
  
  <entry>
    <title>《Redis开发与运维》读书笔记（一）Redis简介</title>
    <link href="http://linyishui.top/2020030102.html"/>
    <id>http://linyishui.top/2020030102.html</id>
    <published>2020-03-01T07:24:19.000Z</published>
    <updated>2020-04-08T03:57:23.093Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="第一章-Redis简介"><a href="#第一章-Redis简介" class="headerlink" title="第一章 Redis简介"></a><strong>第一章 Redis简介</strong></h1><h2 id="1-1-什么是Redis"><a href="#1-1-什么是Redis" class="headerlink" title="1.1 什么是Redis?"></a><strong>1.1 什么是Redis?</strong></h2><p>&emsp;&emsp;Redis是一种基于<strong>键值对</strong>的NoSQL（非关系型）数据库。与另外一些键值对数据库不同的是，Redis的值可以是：string、hash、list、set、zset（有序集合）、Bitmaps（位图）、HyperLogLog（做基数统计）、GEO（地理信息定位）等多种数据结构和算法。</p><blockquote><p>Redis主要有哪些优势？</p><ul><li>值可以存放多种数据结构和算法，所以可以满足大量的应用场景。</li><li>将数据存放在内存，所以有高效的读写性能。</li><li>内存中的数据通过快照和日志的方式保存在硬盘上，防止丢失。</li></ul></blockquote><p>&emsp;&emsp;Redis的作者本身想通过MySql来实现一个高性能的队列功能，但优化SQL无法提高性能，所以他决定自己开发一款数据库，即Redis。目前大部分国内外知名的互联网企业都在使用Redis，还有一些开源技术如ELK（即Elasticsearch，Logstash 和Kibana，实现集中式日志系统）也把Redis当作组件中的重要一环。</p><hr><h2 id="1-2-Redis特性"><a href="#1-2-Redis特性" class="headerlink" title="1.2 Redis特性"></a><strong>1.2 Redis特性</strong></h2><h3 id="1-2-1-速度快"><a href="#1-2-1-速度快" class="headerlink" title="1.2.1 速度快"></a><strong>1.2.1 速度快</strong></h3><blockquote><p>Redis速度非常快，其高效性能的原因有：</p><ul><li>所有数据都存放在内存。</li><li>使用C语言实现。</li><li>使用单线程架构，避免了多线程竞争问题。</li><li>作者对源码进行了精打细磨，曾被人评价是少有的集性能与优雅于一身的开源代码。</li></ul></blockquote><h3 id="1-2-2-基于键值对的数据结构服务器"><a href="#1-2-2-基于键值对的数据结构服务器" class="headerlink" title="1.2.2 基于键值对的数据结构服务器"></a><strong>1.2.2 基于键值对的数据结构服务器</strong></h3><p>&emsp;&emsp;大部分语言都会提供类似字典的功能，映射这种组织数据的方式叫做<strong>基于键值的方式</strong>，但Redis中的值不仅可以是字符串，还可以是字符串、哈希、列表、集合、有序集合。同时又在字符串的基础上演变出了Bitmaps（位图）、HyperLogLog（做基数统计）两种高级数据结构，并且随着LBS（Location Based Service，基于位置服务）的发展加入了GEO（地理信息定位）功能。</p><h3 id="1-2-3-丰富的功能"><a href="#1-2-3-丰富的功能" class="headerlink" title="1.2.3 丰富的功能"></a><strong>1.2.3 丰富的功能</strong></h3><blockquote><p>Redis还提供许多额外功能：</p><ul><li>提供了键过期功能，可以用来实现缓存。</li><li>提供了发布订阅功能，可以用来实现消息系统。</li><li>支持Lua脚本功能，可以利用Lua创造出新的Redis命令。</li><li>提供了简单的事务功能，能在一定程度上保证事务特性。</li><li>提供了流水线（Pipeline）功能，使客户端能将一批命令一次性传到Redis，减少了网络的开销。</li></ul></blockquote><h3 id="1-2-4-简单稳定"><a href="#1-2-4-简单稳定" class="headerlink" title="1.2.4 简单稳定"></a><strong>1.2.4 简单稳定</strong></h3><p>&emsp;&emsp;Redis的简单主要体现在三个方面：首先是源码很精简，几万行代码，对于大部分使用者来说都是可以去快速阅读一遍的。其次Redis使用单线程模型，不仅使得Redis服务端处理模型变得简单，也使客户端开发变得简单。最后Redis不需要依赖操作系统的类库（如Memcache需要依赖libevent），Redis自己实现了事件处理的相关功能。</p><p>&emsp;&emsp;Redis虽然精简，但非常稳定。</p><h3 id="1-2-5-客户端语言多"><a href="#1-2-5-客户端语言多" class="headerlink" title="1.2.5 客户端语言多"></a><strong>1.2.5 客户端语言多</strong></h3><p>&emsp;&emsp;Redis提供了简单的TCP通信协议，方便编程语言接入Redis，因为主流公司的认可，所以大部分客户端编程语言都支持Redis。</p><h3 id="1-2-6-持久化"><a href="#1-2-6-持久化" class="headerlink" title="1.2.6 持久化"></a><strong>1.2.6 持久化</strong></h3><p>&emsp;&emsp;数据存放在内存一般被认为是不安全的（断电或机器故障导致数据丢失），Redis提供了两种持久化方式：<strong>RDB</strong>和<strong>AOF</strong>。</p><h3 id="1-2-7-主从复制"><a href="#1-2-7-主从复制" class="headerlink" title="1.2.7 主从复制"></a><strong>1.2.7 主从复制</strong></h3><p>&emsp;&emsp;Redis提供了复制功能，实现了多个相同数据的Redis副本，复制功能是分布式的基础。</p><h3 id="1-2-8-高可用和分布式"><a href="#1-2-8-高可用和分布式" class="headerlink" title="1.2.8 高可用和分布式"></a><strong>1.2.8 高可用和分布式</strong></h3><p>&emsp;&emsp;Redis从2.8版本后提供了高可用实现：Redis Sentinel，能保证Redis节点的故障发现和故障自动转移。</p><p>&emsp;&emsp;3.0版本正式提供了分布式实现：Redis Cluster，提供了高可用、读写和容量的扩展性。</p><hr><h2 id="1-3-Redis使用场景"><a href="#1-3-Redis使用场景" class="headerlink" title="1.3 Redis使用场景"></a><strong>1.3 Redis使用场景</strong></h2><h3 id="1-3-1-Redis可以做什么？"><a href="#1-3-1-Redis可以做什么？" class="headerlink" title="1.3.1 Redis可以做什么？"></a><strong>1.3.1 Redis可以做什么？</strong></h3><blockquote><ol><li><strong>缓存</strong>，常用于大型网站来加速数据访问和缓解后端数据库压力。Redis提供了键值过期时间设置，也提供了灵活控制最大内存和内存溢出后的淘汰策略。</li><li><strong>排行榜系统</strong>，几乎所有网站都需要各种规则的排行榜，或是依据热度排行，或是发布时间，或是结合各种复杂维度计算。Redis提供了列表和有序集合数据结构，合理的使用这些结构可以很方便的构建各种排行榜系统。</li><li><strong>计数器应用</strong>，如一些视频网站的播放数，电商网站的浏览数，对于数据的实时性有较高的要求，如果并发量很大时，传统关系型数据库很难做好这一工作。Redis天然支持计数功能，且性能优越。</li><li><strong>社交网络</strong>，比如赞/踩、粉丝、共同好友/喜好、推送、下拉刷新等常见功能，由于社交网站访问量通常较大，且传统关系型数据库不太适合存储这种类型的数据，而Redis提供的数据结构比较容易实现这些功能。</li><li><strong>消息队列系统</strong>，大型网站的必备基础组件，因为其具有业务解耦、非实时业务削峰等特性。Redis提供了发布订阅功能和阻塞队列功能，虽然相比专业的消息队列还有所欠缺，但可以满足大部分基础需求。</li></ol></blockquote><h3 id="1-3-2-Redis不可以做什么？"><a href="#1-3-2-Redis不可以做什么？" class="headerlink" title="1.3.2 Redis不可以做什么？"></a><strong>1.3.2 Redis不可以做什么？</strong></h3><p>&emsp;&emsp;正像大部分技术一样，Redis也有其边界。</p><p>&emsp;&emsp;首先站在<strong>数据规模</strong>的角度来看，我们把数据分为大规模数据和小规模数据。因为其存放数据于内存这一设定，在面对海量数据时就是一个性价比极低的选择。</p><p>&emsp;&emsp;然后站在<strong>数据冷热</strong>的角度来看，我们把数据分为热数据和冷数据，热数据指需要频繁操作的数据，冷数据则相反。例如对于视频网站，视频基本信息需要在各个业务线频繁操作，而用户观看记录（不要和观看数混为一谈，此处应该指行为数据）相比就不会那么繁忙，先不讨论两者的规模差异，视频信息属于热数据，用户观看记录属于冷数据。冷数据存放于内存是一种浪费，而热数据可以放在内存中加速读写，也减轻了后端存储的负载压力。</p><hr><h2 id="1-4-如何用好Redis？"><a href="#1-4-如何用好Redis？" class="headerlink" title="1.4 如何用好Redis？"></a><strong>1.4 如何用好Redis？</strong></h2><blockquote><ul><li><strong>不要把Redis当作黑盒使用，开发和运维一样重要</strong>。很多线上故障都是因为开发者把Redis当作黑盒使用而造成的：如果不了解Redis的单线程模型，可能会在有上千万个键的Redis上执行keys *操作；如果不了解持久化相关原理，可能会在一个写操作量很大的Redis上配置自动保存RDB。相比专职的关系型数据库DBA，大部分公司并没有人来专职运维Redis，所以往往需要开发人员来担当这一角色。这一经验对于我们学好Redis也大有帮助。</li><li><strong>阅读源码</strong>。Redis源码量很小，所以请多读Redis源码，不仅可以加深理解，也可以提高自身编程水平，甚至定制化Redis，需要大公司会对Redis进行定制来满足其业务需求。</li></ul></blockquote><hr><h2 id="1-5-安装Redis"><a href="#1-5-安装Redis" class="headerlink" title="1.5 安装Redis"></a><strong>1.5 安装Redis</strong></h2><h3 id="1-5-1-Linux上安装Redis"><a href="#1-5-1-Linux上安装Redis" class="headerlink" title="1.5.1 Linux上安装Redis"></a><strong>1.5.1 Linux上安装Redis</strong></h3><p>&emsp;&emsp;Linux上安装Redis的方式有两种：第一种是通过各个操作系统的软件管理软件进行安装，如CentOS的yum管理工具，Ubuntu的apt（Docker应该也属于第一种吧）。第二种是通过源码的方式安装。</p><p>&emsp;&emsp;Redis更新较快，所以一般推荐第二种安装方式。</p><p>&emsp;&emsp;安装步骤只需要六步即可，如下案例安装3.0.7版本。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> wget http://download.redis.io/releases/redis-3.0.7.tar.gz</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> tar xzf redis-3.0.7.tar.gz</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> ln -s redis-3.0.7 redis</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> <span class="built_in">cd</span> redis</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> make</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> make install</span></span><br></pre></td></tr></table></figure><blockquote><ol><li>下载指定版本的Redis源码压缩包到当前目录。</li><li>解压缩Redis源码压缩包。</li><li>建立一个redis目录的软连接，指向redis-3.0.7（为了不把redis目录固定在指定版本，有利于未来版本升级，算是一种安装软件的好习惯）。</li><li>进入redis目录。</li><li>编译（编译前确保操作系统已安装gcc）。</li><li>安装（将Redis的相关运行软件放在/usr/local/bin/下，从而可以在任意目录下执行Redis的命令）。</li></ol></blockquote><p>&emsp;&emsp;如下图安装5.0.8版本。</p><p><img src="https://pic-1258215793.cos.ap-shanghai.myqcloud.com/content/20200301/202003010101.png" alt=""></p><h3 id="1-5-2-Windows上安装Redis"><a href="#1-5-2-Windows上安装Redis" class="headerlink" title="1.5.2 Windows上安装Redis"></a><strong>1.5.2 Windows上安装Redis</strong></h3><p>&emsp;&emsp;Redis官方并不支持Windows操作系统，但微软的开源技术组在GitHub上维护了一个Redis的分支：<a href="https://github.com/microsoftarchive/redis" target="_blank" rel="noopener">microsoftarchive/redis</a>。</p><p>&emsp;&emsp;首先在上述开源项目中找到想要安装的版本并下载：<a href="https://github.com/MSOpenTech/redis/releases" target="_blank" rel="noopener">https://github.com/MSOpenTech/redis/releases</a></p><p>&emsp;&emsp;解压并在根目录打开命令行，可以把redis路径添加到环境变量，方便以后使用。</p><h3 id="1-5-3-配置、启动、操作、关闭Redis"><a href="#1-5-3-配置、启动、操作、关闭Redis" class="headerlink" title="1.5.3 配置、启动、操作、关闭Redis"></a><strong>1.5.3 配置、启动、操作、关闭Redis</strong></h3><p>&emsp;&emsp;Redis安装后，src和/usr/local/bin/下会多出几个redis开头的文件，被称作Redis Shell。类似于JDK中的可执行文件，这些文件可以帮助我们做很多事情。</p><table><thead><tr><th style="text-align:left">可执行文件</th><th style="text-align:left">作用</th></tr></thead><tbody><tr><td style="text-align:left">redis-server</td><td style="text-align:left">启动Redis</td></tr><tr><td style="text-align:left">redis-cli</td><td style="text-align:left">Redis命令行客户端</td></tr><tr><td style="text-align:left">redis-benchmark</td><td style="text-align:left">Redis基准测试工具</td></tr><tr><td style="text-align:left">redis-check-aof</td><td style="text-align:left">Redis  AOF持久化文件检查和修复工具</td></tr><tr><td style="text-align:left">redis-check-dump</td><td style="text-align:left">Redis  RDB持久化文件检查和修复工具</td></tr><tr><td style="text-align:left">redis-sentinel</td><td style="text-align:left">启动Redis Sentinel</td></tr></tbody></table><h4 id="1-启动Redis"><a href="#1-启动Redis" class="headerlink" title="1.  启动Redis"></a><strong>1.  启动Redis</strong></h4><p>&emsp;&emsp;首先启动Redis，有三种方式：默认配置、运行配置、配置文件启动。</p><h5 id="（1）默认配置"><a href="#（1）默认配置" class="headerlink" title="（1）默认配置"></a><strong>（1）默认配置</strong></h5><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> redis-server</span></span><br></pre></td></tr></table></figure><p><img src="https://pic-1258215793.cos.ap-shanghai.myqcloud.com/content/20200301/202003010102.png" alt=""></p><p>&emsp;&emsp;由上述信息可以得知，我们当前版本是5.0.8，默认端口6379，线程ID-30710，Redis建议使用配置文件启动。</p><p>&emsp;&emsp;因为直接启动无法自定义配置，所以生产环境不会采用这种方式。</p><h5 id="（2）运行配置"><a href="#（2）运行配置" class="headerlink" title="（2）运行配置"></a><strong>（2）运行配置</strong></h5><p>&emsp;&emsp;redis-server要加上修改配置名和值（可以多对），没有配置的将使用默认配置。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> redis-server --configkey1 configValue1 --configkey2 configValue2</span></span><br></pre></td></tr></table></figure><p>&emsp;&emsp;比如我们想修改端口号。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> redis-server --port 6380</span></span><br></pre></td></tr></table></figure><p>&emsp;&emsp;当配置较多或是想保存配置到文件中时，不建议使用这种方式。</p><h5 id="（3）配置文件启动"><a href="#（3）配置文件启动" class="headerlink" title="（3）配置文件启动"></a><strong>（3）配置文件启动</strong></h5><p>&emsp;&emsp;将配置写到文件中，比如写到/opt/redis/redis.conf，然后只须执行下列命令即可启动Redis。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> redis-server /opt/redis/redis.conf</span></span><br></pre></td></tr></table></figure><p>&emsp;&emsp;Redis有60多个配置，此处只给出比较重要的四个，后续会专门做整理介绍。</p><table><thead><tr><th style="text-align:left">配置名</th><th style="text-align:left">配置说明</th></tr></thead><tbody><tr><td style="text-align:left">port</td><td style="text-align:left">端口</td></tr><tr><td style="text-align:left">logfile</td><td style="text-align:left">日志文件</td></tr><tr><td style="text-align:left">dir</td><td style="text-align:left">Redis工作目录（存放持久化文件和日志文件）</td></tr><tr><td style="text-align:left">daemonize</td><td style="text-align:left">是否以守护线程的方式启动Redis</td></tr></tbody></table><p>&emsp;&emsp;配置文件启动的方式具有灵活性，所以大部分生产环境会使用这种方式。</p><h4 id="2-Redis命令行客户端"><a href="#2-Redis命令行客户端" class="headerlink" title="2.  Redis命令行客户端"></a><strong>2.  Redis命令行客户端</strong></h4><p>&emsp;&emsp;我们已经启动了Redis服务，接下来是使用redis-cli连接和操作Redis服务。redis-cli有两种方式来连接Redis服务器。</p><h5 id="（1）交互式方式"><a href="#（1）交互式方式" class="headerlink" title="（1）交互式方式"></a><strong>（1）交互式方式</strong></h5><p>&emsp;&emsp;通过 redis-cli -h {host} -p {port} 的方式连接到Redis服务，之后所有的操作都通过交互的方式实现，不需要再执行 redis-cli 。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> redis-cli -h 127.0.0.1 -p &#123;port&#125;</span></span><br></pre></td></tr></table></figure><p><img src="https://pic-1258215793.cos.ap-shanghai.myqcloud.com/content/20200301/202003010103.png" alt=""></p><h5 id="（2）命令方式"><a href="#（2）命令方式" class="headerlink" title="（2）命令方式"></a><strong>（2）命令方式</strong></h5><p>&emsp;&emsp;通过 redis-cli -h {host} -p {port}  {command}直接得到命令结果。</p><p><img src="https://pic-1258215793.cos.ap-shanghai.myqcloud.com/content/20200301/202003010104.png" alt=""></p><p>&emsp;&emsp;没有 -h 参数则默认连接127.0.0.1；没有 -p 参数则默认6379端口。</p><h4 id="3-停止Redis服务"><a href="#3-停止Redis服务" class="headerlink" title="3.  停止Redis服务"></a><strong>3.  停止Redis服务</strong></h4><p>&emsp;&emsp;Redis提供了shutdown命令来停止Redis服务。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> redis-cli shutdown</span></span><br></pre></td></tr></table></figure><blockquote><p>需要注意：</p><ol><li><p>Redis关闭的过程：断开与客户端的连接、持久化文件生成，是一种相对优雅的关闭方式。</p></li><li><p>除了shutdown命令外，也可以通过kill进程号的方式关闭Redis，但请不要粗暴的使用kill -9 强制杀死Redis服务，这样不但不会做持久化操作，还会造成缓冲区不能正常关闭，极端情况下会造成AOF和复制丢失数据的情况。</p></li><li><p>shutdown还有一个参数，表示是否在关闭Redis前生成持久化文件。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;</span><span class="bash">    $ redis-cli shutdown nosave|save</span></span><br><span class="line"><span class="meta">&gt;</span><span class="bash"></span></span><br></pre></td></tr></table></figure></li></ol></blockquote><hr><h2 id="1-6-版本命名"><a href="#1-6-版本命名" class="headerlink" title="1.6 版本命名"></a><strong>1.6 版本命名</strong></h2><p>&emsp;&emsp;Redis借鉴了Linux对于版本号的命名规则：版本号第二位如果是奇数，表示非稳定版本（unstable），如果是偶数，表示稳定版本（stable），当然还有Beta版本。</p><hr><p><em>参考博客和文章书籍等：</em></p><blockquote><p>《Redis开发与运维》</p></blockquote><p><em>因博客主等未标明不可引用，若部分内容涉及侵权请及时告知，我会尽快修改和删除相关内容</em></p>]]></content>
    
    <summary type="html">
    
      《Redis开发与运维》读书笔记（一）Redis简介，内容包括：简介，特性，使用场景，如何使用，安装，版本命名。
    
    </summary>
    
      <category term="技术文档" scheme="http://linyishui.top/categories/%E6%8A%80%E6%9C%AF%E6%96%87%E6%A1%A3/"/>
    
    
      <category term="redis" scheme="http://linyishui.top/tags/redis/"/>
    
  </entry>
  
  <entry>
    <title>《Redis开发与运维》读书笔记-目录（未完待续）</title>
    <link href="http://linyishui.top/2020030101.html"/>
    <id>http://linyishui.top/2020030101.html</id>
    <published>2020-03-01T07:16:50.000Z</published>
    <updated>2020-04-08T01:36:49.215Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h2 id="第一章-Redis简介"><a href="#第一章-Redis简介" class="headerlink" title="第一章 Redis简介"></a><strong>第一章 Redis简介</strong></h2><p>&emsp;&emsp;<a href="../2020030102.html" title="Title">《Redis开发与运维》读书笔记（一）Redis简介</a></p><h2 id="第二章-API介绍"><a href="#第二章-API介绍" class="headerlink" title="第二章 API介绍"></a><strong>第二章 API介绍</strong></h2><p>&emsp;&emsp;<a href="../2020030201.html" title="Title">《Redis开发与运维》读书笔记（二）API介绍</a></p><h2 id="第三章-常用功能"><a href="#第三章-常用功能" class="headerlink" title="第三章 常用功能"></a><strong>第三章 常用功能</strong></h2><p>&emsp;&emsp;《Redis开发与运维》读书笔记（三）常用功能</p><h2 id="第四章-客户端"><a href="#第四章-客户端" class="headerlink" title="第四章 客户端"></a><strong>第四章 客户端</strong></h2><p>&emsp;&emsp;《Redis开发与运维》读书笔记（四）客户端</p><h2 id="第五章-持久化"><a href="#第五章-持久化" class="headerlink" title="第五章 持久化"></a><strong>第五章 持久化</strong></h2><p>&emsp;&emsp;《Redis开发与运维》读书笔记（五）持久化</p><h2 id="第六章-复制"><a href="#第六章-复制" class="headerlink" title="第六章 复制"></a><strong>第六章 复制</strong></h2><p>&emsp;&emsp;《Redis开发与运维》读书笔记（六）复制</p><h2 id="第七章-常见问题：阻塞"><a href="#第七章-常见问题：阻塞" class="headerlink" title="第七章 常见问题：阻塞"></a><strong>第七章 常见问题：阻塞</strong></h2><p>&emsp;&emsp;《Redis开发与运维》读书笔记（七）常见问题：阻塞</p><h2 id="第八章-理解内存"><a href="#第八章-理解内存" class="headerlink" title="第八章 理解内存"></a><strong>第八章 理解内存</strong></h2><p>&emsp;&emsp;《Redis开发与运维》读书笔记（八）理解内存</p><h2 id="第九章-哨兵"><a href="#第九章-哨兵" class="headerlink" title="第九章 哨兵"></a><strong>第九章 哨兵</strong></h2><p>&emsp;&emsp;《Redis开发与运维》读书笔记（九）哨兵</p><h2 id="第十章-集群"><a href="#第十章-集群" class="headerlink" title="第十章 集群"></a><strong>第十章 集群</strong></h2><p>&emsp;&emsp;《Redis开发与运维》读书笔记（十）集群</p><h2 id="第十一章-缓存设计"><a href="#第十一章-缓存设计" class="headerlink" title="第十一章 缓存设计"></a><strong>第十一章 缓存设计</strong></h2><p>&emsp;&emsp;《Redis开发与运维》读书笔记（十一）缓存设计</p><h2 id="第十二章-开发运维中常见的陷阱"><a href="#第十二章-开发运维中常见的陷阱" class="headerlink" title="第十二章 开发运维中常见的陷阱"></a><strong>第十二章 开发运维中常见的陷阱</strong></h2><p>&emsp;&emsp;《Redis开发与运维》读书笔记（十二）开发运维中常见的陷阱</p><h2 id="第十三章-Redis监控运维云平台-CacheCloud"><a href="#第十三章-Redis监控运维云平台-CacheCloud" class="headerlink" title="第十三章 Redis监控运维云平台-CacheCloud"></a><strong>第十三章 Redis监控运维云平台-CacheCloud</strong></h2><p>&emsp;&emsp;《Redis开发与运维》读书笔记（十三）Redis监控运维云平台-CacheCloud</p><h2 id="第十四章-Redis配置统计字典"><a href="#第十四章-Redis配置统计字典" class="headerlink" title="第十四章 Redis配置统计字典"></a><strong>第十四章 Redis配置统计字典</strong></h2><p>&emsp;&emsp;《Redis开发与运维》读书笔记（十四）Redis配置统计字典</p><hr><p><em>参考博客和文章书籍等：</em></p><blockquote><p>《Redis开发与运维》</p></blockquote><p><em>因博客主等未标明不可引用，若部分内容涉及侵权请及时告知，我会尽快修改和删除相关内容</em></p>]]></content>
    
    <summary type="html">
    
      《Redis开发与运维》读书笔记，内容包括：Redis简介，API介绍，常用功能，客户端，持久化，复制，常见问题：阻塞，理解内存，哨兵，集群，缓存设计，开发运维中常见的陷阱，Redis监控运维云平台-CacheCloud，Redis配置统计字典。
    
    </summary>
    
      <category term="技术文档" scheme="http://linyishui.top/categories/%E6%8A%80%E6%9C%AF%E6%96%87%E6%A1%A3/"/>
    
    
      <category term="unfinished" scheme="http://linyishui.top/tags/unfinished/"/>
    
      <category term="redis" scheme="http://linyishui.top/tags/redis/"/>
    
  </entry>
  
  <entry>
    <title>开发常见英文缩写合集（持续更新）</title>
    <link href="http://linyishui.top/2020022101.html"/>
    <id>http://linyishui.top/2020022101.html</id>
    <published>2020-02-21T10:21:41.000Z</published>
    <updated>2020-03-25T10:32:39.705Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="开发常见英文缩写合集"><a href="#开发常见英文缩写合集" class="headerlink" title="开发常见英文缩写合集"></a><strong>开发常见英文缩写合集</strong></h1><h2 id="Java"><a href="#Java" class="headerlink" title="Java"></a><strong>Java</strong></h2><h3 id="IOC"><a href="#IOC" class="headerlink" title="IOC"></a><strong>IOC</strong></h3><p>控制反转(Inversion of Control，缩写为IoC)，是面向对象编程中的一种设计原则，可以用来减低计算机代码之间的耦合度。其中最常见的方式叫做依赖注入(Dependency Injection，简称DI)，还有一种方式叫“依赖查找”(Dependency Lookup)。通过控制反转，对象在被创建的时候，由一个调控系统内所有对象的外界实体将其所依赖的对象的引用传递给它。也可以说，依赖被注入到对象中。</p><h3 id="AOP"><a href="#AOP" class="headerlink" title="AOP"></a><strong>AOP</strong></h3><p>在软件业，AOP为Aspect Oriented Programming的缩写，意为：面向切面编程，通过预编译方式和运行期动态代理实现程序功能的统一维护的一种技术。AOP是OOP的延续，是软件开发中的一个热点，也是Spring框架中的一个重要内容，是函数式编程的一种衍生范型。利用AOP可以对业务逻辑的各个部分进行隔离，从而使得业务逻辑各部分之间的耦合度降低，提高程序的可重用性，同时提高了开发的效率。</p><h3 id="CAS"><a href="#CAS" class="headerlink" title="CAS"></a><strong>CAS</strong></h3><p>是一种乐观锁机制。CAS是英文单词Compare And Swap的缩写，翻译过来就是比较并替换。CAS机制当中使用了3个基本操作数：内存地址V，旧的预期值A，要修改的新值B。更新一个变量的时候，只有当变量的预期值A和内存地址V当中的实际值相同时，才会将内存地址V对应的值修改为B。</p><h3 id="BIO"><a href="#BIO" class="headerlink" title="BIO"></a><strong>BIO</strong></h3><p>Blocking Input Output，同步阻塞I/O模式，数据的读取写入必须阻塞在一个线程内等待其完成。服务器实现模式为一个连接一个线程，即客户端有连接请求时服务器端就需要启动一个线程进行处理，如果这个连接不做任何事情会造成不必要的线程开销，当然可以通过线程池机制改善。</p><h3 id="NIO"><a href="#NIO" class="headerlink" title="NIO"></a><strong>NIO</strong></h3><p>NIO是指将IO模式设为“Non-Blocking”模式。NIO是一种同步非阻塞的I/O模型，在Java 1.4 中引入了NIO框架，对应 java.nio 包，提供了 Channel , Selector，Buffer等抽象。NIO中的N可以理解为Non-blocking，不单纯是New。它支持面向缓冲的，基于通道的I/O操作方法。</p><h2 id="数据库"><a href="#数据库" class="headerlink" title="数据库"></a><strong>数据库</strong></h2><h3 id="AICD"><a href="#AICD" class="headerlink" title="AICD"></a><strong>AICD</strong></h3><p>事务属性AICD：</p><p>原子性(Atomicity)：整体不可分割性，要么全做要不全不做。</p><p>一致性(Consistency) ：事务执行前、后数据库状态均一致。</p><p>隔离性(Isolation) ：在事务未提交前，它操作的数据，对其它用户不可见(从其他session读取的数据还是commit之前的数据状态)。</p><p>持久性(Durability)：一旦事务成功，将进行永久的变更，记录与redo日志。</p><h3 id="RC"><a href="#RC" class="headerlink" title="RC"></a><strong>RC</strong></h3><p>数据库隔离级别，Read Committed(读取提交内容)。</p><p>(1) 这是大多数数据库系统的默认隔离级别(但不是MySQL默认的)</p><p>(2)它满足了隔离的简单定义：一个事务只能看见已经提交事务所做的改变</p><p>(3)这种隔离级别出现的问题是——不可重复读(Nonrepeatable Read)：不可重复读意味着我们在同一个事务中执行完全相同的select语句时可能看到不一样的结果。</p><h3 id="RR"><a href="#RR" class="headerlink" title="RR"></a><strong>RR</strong></h3><p>数据库隔离级别，Repeatable Read(可重读)。</p><p>(1)这是MySQL的默认事务隔离级别。</p><p>(2)它确保同一事务的多个实例在并发读取数据时，会看到同样的数据行。</p><p>(3)此级别可能出现的问题——幻读(Phantom Read)：当用户读取某一范围的数据行时，另一个事务又在该范围内插入了新行，当用户再读取该范围的数据行时，会发现有新的“幻影” 行。</p><p>(4)InnoDB和Falcon存储引擎通过多版本并发控制(MVCC，Multiversion Concurrency Control)机制解决了该问题。</p><h3 id="Binlog"><a href="#Binlog" class="headerlink" title="Binlog"></a><strong>Binlog</strong></h3><p>是The Binary Log的简称，意思就是二进制的日志文件。binlog是一个二进制格式的文件，用于记录用户对数据库更新的SQL语句信息，例如更改数据库表和更改内容的SQL语句都会记录到binlog里，但是对库表等内容的查询不会记录。默认情况下，binlog日志是二进制格式的，不能使用查看文本工具的命令(比如，cat，vi等)查看，而使用mysqlbinlog解析查看。当有数据写入到数据库时，还会同时把更新的SQL语句写入到对应的binlog文件里，这个文件就是上文说的binlog文件。使用mysqldump备份时，只是对一段时间的数据进行全备，但是如果备份后突然发现数据库服务器故障，这个时候就要用到binlog的日志了。主要作用是用于数据库的主从复制及数据的增量恢复。</p><h3 id="RESP"><a href="#RESP" class="headerlink" title="RESP"></a><strong>RESP</strong></h3><p>Redis Serialization Protocol，RESP 是 Redis 序列化协议的简写。它是一种直观的文本协议，优势在于实现异常简 单，解析性能极好。</p><h3 id="COW"><a href="#COW" class="headerlink" title="COW"></a><strong>COW</strong></h3><p>写入时复制(英语：Copy-on-write，简称COW)是一种计算机程序设计领域的优化策略。其核心思想是，如果有多个调用者(callers)同时请求相同资源(如内存或磁盘上的数据存储)，他们会共同获取相同的指针指向相同的资源，直到某个调用者试图修改资源的内容时，系统才会真正复制一份专用副本(private copy)给该调用者，而其他调用者所见到的最初的资源仍然保持不变。这过程对其他的调用者都是透明的(transparently)。 优点是如果调用者没有修改该资源，就不会有副本(private copy)被建立，因此多个调用者只是读取操作时可以共享同一份资源。</p><h3 id="MVCC"><a href="#MVCC" class="headerlink" title="MVCC"></a><strong>MVCC</strong></h3><p>Multi-Version Concurrency Control 多版本并发控制，MVCC 是一种并发控制的方法，一般在数据库管理系统中，实现对数据库的并发访问;在编程语言中实现事务内存。MVCC是通过保存数据在某个时间点的快照来实现的. 不同存储引擎的MVCC. 不同存储引擎的MVCC实现是不同的,典型的有乐观并发控制和悲观并发控制。</p><h3 id="SDS"><a href="#SDS" class="headerlink" title="SDS"></a><strong>SDS</strong></h3><p>简单动态字符串(simple dynamic string，SDS)的抽象类型。字符串是Redis中最为常见的数据存储类型，其底层实现是简单动态字符串sds(simple dynamic string)，是可以修改的字符串。它类似于Java中的ArrayList，它采用预分配冗余空间的方式来减少内存的频繁分配。C语言字符串使用长度为n+1的字符数组来表示长度为n的字符串，并且字符数组的最后一个元素总是空字符’\0’，因为这种字符串表示方式不能满足Redis对字符串在安全性、效率以及功能方面的要求，所以Redis自己构建了SDS，用于满足其需求。在Redis里，C语言字符串只用于一些无须对字符串值进行修改的地方，比如：日志。在Redis中，包含字符串值的键值对都是使用SDS实现的，除此之外，SDS还被用于AOF缓冲区、客户端状态的输入缓冲区。</p><h3 id="RDB"><a href="#RDB" class="headerlink" title="RDB"></a><strong>RDB</strong></h3><p>Redis支持RDB和AOF两种持久化机制，持久化功能有效地避免因进程退出造成的数据丢失问题，当下次重启时利用之前持久化文件即可实现数据恢复。RDB (Redis DataBase)。RDB 是 Redis 默认的持久化方案。在指定的时间间隔内，执行指定次数的写操作，则会将内存中的数据写入到磁盘中。即在指定目录下生成一个dump.rdb文件。Redis 重启会通过加载dump.rdb文件恢复数据。RDB持久化是把当前进程数据生成快照保存到硬盘的过程，触发RDB持久化过程分为手动触发和自动触发。</p><h3 id="AOF"><a href="#AOF" class="headerlink" title="AOF"></a><strong>AOF</strong></h3><p>Redis支持RDB和AOF两种持久化机制，持久化功能有效地避免因进程退出造成的数据丢失问题，当下次重启时利用之前持久化文件即可实现数据恢复。AOF(append only file)持久化：以独立日志的方式记录每次写命令，重启时再重新执行AOF文件中命令达到恢复数据的目的。AOF的主要作用是解决了数据持久化的实时性，目前已经是Redis持久化的主流方式。</p><h2 id="网络"><a href="#网络" class="headerlink" title="网络"></a><strong>网络</strong></h2><h3 id="ZAB"><a href="#ZAB" class="headerlink" title="ZAB"></a><strong>ZAB</strong></h3><p>ZAB 协议全称：Zookeeper Atomic Broadcast(Zookeeper 原子广播协议)。ZAB 协议的消息广播过程使用的是一个原子广播协议，类似一个 二阶段提交过程。对于客户端发送的写请求，全部由 Leader 接收，Leader 将请求封装成一个事务 Proposal，将其发送给所有 Follwer ，然后，根据所有 Follwer 的反馈，如果超过半数成功响应，则执行 commit 操作(先提交自己，再发送 commit 给所有 Follwer)。</p><h3 id="ACK"><a href="#ACK" class="headerlink" title="ACK"></a><strong>ACK</strong></h3><p>ACK消息，Acknowledgement 。是在计算机网上中通信协议的一部分，是设备或是进程发出的消息，回复已收到数据。例如在传输控制协议(TCP，Transmission Control Protocol)中就有用ACK来告知创建链接时有收到SYN数据包、使用链接时有收到数据包，或是在中止链接有收到FIN数据包。</p><h2 id="分布式"><a href="#分布式" class="headerlink" title="分布式"></a><strong>分布式</strong></h2><h3 id="CAP"><a href="#CAP" class="headerlink" title="CAP"></a><strong>CAP</strong></h3><p>CAP原则又称CAP定理，指的是在一个分布式系统中，一致性(Consistency)、可用性(Availability)、分区容忍性(Partition tolerance)。CAP 原则指的是，这三个要素最多只能同时实现两点，不可能三者兼顾。</p><p>一致性(C)：在分布式系统中的所有数据备份，在同一时刻是否同样的值。(等同于所有节点访问同一份最新的数据副本)</p><p>可用性(A)：在集群中一部分节点故障后，集群整体是否还能响应客户端的读写请求。(对数据更新具备高可用性)</p><p>分区容忍性(P)：以实际效果而言，分区相当于对通信的时限要求。系统如果不能在时限内达成数据一致性，就意味着发生了分区的情况，必须就当前操作在C和A之间做出选择。</p><h3 id="AMQP"><a href="#AMQP" class="headerlink" title="AMQP"></a><strong>AMQP</strong></h3><p>即Advanced Message Queuing Protocol,一个提供统一消息服务的应用层标准高级消息队列协议,是应用层协议的一个开放标准,为面向消息的中间件设计。基于此协议的客户端与消息中间件可传递消息，并不受客户端/中间件不同产品，不同的开发语言等条件的限制。Erlang中的实现有 RabbitMQ等。</p><h2 id="架构"><a href="#架构" class="headerlink" title="架构"></a><strong>架构</strong></h2><h3 id="DDD"><a href="#DDD" class="headerlink" title="DDD"></a><strong>DDD</strong></h3><p>DDD(Domain-Driven Design 领域驱动设计)是由Eric Evans最先提出，目的是对软件所涉及到的领域进行建模，以应对系统规模过大时引起的软件复杂性的问题。整个过程大概是这样的，开发团队和领域专家一起通过 通用语言(Ubiquitous Language)去理解和消化领域知识，从领域知识中提取和划分为一个一个的子领域(核心子域，通用子域，支撑子域)，并在子领域上建立模型，再重复以上步骤，这样周而复始，构建出一套符合当前领域的模型。</p>]]></content>
    
    <summary type="html">
    
      开发中常见英文缩写合集，主要针对Java后端，可能会扩展到前端、算法、网络等。
    
    </summary>
    
      <category term="个人记录" scheme="http://linyishui.top/categories/%E4%B8%AA%E4%BA%BA%E8%AE%B0%E5%BD%95/"/>
    
    
      <category term="updating" scheme="http://linyishui.top/tags/updating/"/>
    
  </entry>
  
  <entry>
    <title>Git常用指令（持续更新）</title>
    <link href="http://linyishui.top/2020022001.html"/>
    <id>http://linyishui.top/2020022001.html</id>
    <published>2020-02-20T09:32:27.000Z</published>
    <updated>2020-04-07T10:22:59.063Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="Git常用指令笔记"><a href="#Git常用指令笔记" class="headerlink" title="Git常用指令笔记"></a><strong>Git常用指令笔记</strong></h1><h2 id="1-用户"><a href="#1-用户" class="headerlink" title="1. 用户"></a><strong>1. 用户</strong></h2><p>&emsp;&emsp;更新名字和邮箱。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> git config --global user.name <span class="string">"**"</span></span></span><br><span class="line"><span class="meta">$</span><span class="bash"> git config --global user.email <span class="string">"**@**.com"</span></span></span><br></pre></td></tr></table></figure><h2 id="2-本地"><a href="#2-本地" class="headerlink" title="2. 本地"></a><strong>2. 本地</strong></h2><p>&emsp;&emsp;创建空仓库或进行初始化（不会覆盖已有配置）。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> git init</span></span><br></pre></td></tr></table></figure><p>&emsp;&emsp;此命令将要提交的文件的信息添加到索引库中(将修改添加到暂存区)，以准备为下一次提交分段的内容。 默认情况下，git add命令不会添加忽略的文件。 如果在命令行上显式指定了任何忽略的文件，git add命令都将失败，并显示一个忽略的文件列表。由Git执行的目录递归或文件名遍历所导致的忽略文件将被默认忽略。 git add命令可以用-f(force)选项添加被忽略的文件。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> git add &lt;path&gt;</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> 将所有修改添加到暂存区</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> git add .</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> Ant风格添加修改</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> git add *  </span></span><br><span class="line"><span class="meta">#</span><span class="bash"> 将以Controller结尾的文件的所有修改添加到暂存区</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> git add *Controller   </span></span><br><span class="line"><span class="meta">#</span><span class="bash"> 将所有以Hello开头的文件的修改添加到暂存区</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> git add Hello*    </span></span><br><span class="line"><span class="meta">#</span><span class="bash"> 将以Hello开头后面只有一位的文件的修改提交到暂存区</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> git add Hello?   </span></span><br><span class="line"><span class="meta">#</span><span class="bash"> 添加doc目录及其子目录下所有*.txt文件的内容</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> git add doc/*.txt</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> 添加所有git-*.sh脚本内容(不会考虑子目录文件)</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> git add git-*.sh</span></span><br></pre></td></tr></table></figure><p>&emsp;&emsp;提交更改。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> git commit -m <span class="string">"First Commit"</span></span></span><br></pre></td></tr></table></figure><p>&emsp;&emsp;推送到远程仓库。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> git push -u origin master</span></span><br></pre></td></tr></table></figure><p>&emsp;&emsp;查看日志。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> git status</span></span><br></pre></td></tr></table></figure><p>&emsp;&emsp;查看日志详细信息。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 尚未缓存的改动</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> git diff</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> 查看已缓存的改动</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> git diff --cached</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> 查看已缓存的与未缓存的所有改动</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> git diff HEAD</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> 显示摘要而非整个diff</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> git diff --<span class="built_in">stat</span></span></span><br></pre></td></tr></table></figure><p>&emsp;&emsp;取消文件的缓存，之后首次执行git commit不会提交前者，再次执行git commit则会提交，用来在文件还未修改成功但需要提交其他内容时跳过此次提交。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> git reset HEAD &lt;file&gt;</span></span><br></pre></td></tr></table></figure><p>&emsp;&emsp;从工作区移除文件。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 要从 Git 中移除某个文件，就必须要从已跟踪文件清单中移除，然后提交</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> git rm &lt;file&gt;</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> 如果删除之前修改过并且已经放到暂存区域的话，则必须要用强制删除选项 -f</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> git rm -f &lt;file&gt;</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> 如果把文件从暂存区域移除，但仍然希望保留在当前工作目录中</span></span><br><span class="line">git rm --cached &lt;file&gt;</span><br><span class="line"><span class="meta">#</span><span class="bash"> 递归删除，删掉当前目录所有文件</span></span><br><span class="line">git rm –r *</span><br></pre></td></tr></table></figure><p>&emsp;&emsp;移动和重命名文件。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> git mv</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> git mv README README.md</span></span><br></pre></td></tr></table></figure><h2 id="3-远程"><a href="#3-远程" class="headerlink" title="3. 远程"></a><strong>3. 远程</strong></h2><p>&emsp;&emsp;克隆项目。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> git <span class="built_in">clone</span> git@gitlab.**.**</span></span><br></pre></td></tr></table></figure><p>&emsp;&emsp;远程仓库。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 查看当前远程仓库</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> git remote</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> 查看当前远程仓库，列出详细信息</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> git remote -v | --verbose</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> 添加一个新的远程仓库</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> git remote add &lt;shortname&gt; &lt;url&gt;</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> git remote add origin git@XXX.XXX.XXX.XXX:XXX</span></span><br></pre></td></tr></table></figure><p>&emsp;&emsp;更新分支。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 相当于是从远程获取最新版本到本地，不会自动合并</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> git fetch &lt;远程主机名&gt; &lt;远程分支名&gt;:&lt;本地分支名&gt;</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> git pull则相当于是从远程获取最新版本并merge到本地</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> git pull &lt;远程主机名&gt; &lt;远程分支名&gt;:&lt;本地分支名&gt;</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> 手动建立追踪关系，指定本地master分支追踪origin/next分支</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> git branch --<span class="built_in">set</span>-upstream master origin/next</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> 已有追踪关系，可以忽略远程分支名</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> git pull origin</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> 如果当前分支只有一个追踪分支，连远程主机名都可以省略</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> git pull</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> 如果合并需要采用rebase模式</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> git pull --rebase &lt;远程主机名&gt; &lt;远程分支名&gt;:&lt;本地分支名&gt;</span></span><br></pre></td></tr></table></figure><hr><p><em>参考博客和文章书籍等：</em></p><blockquote><p><a href="https://www.yiibai.com/git" title="Title" target="_blank" rel="noopener">Git教程-易百教程</a></p></blockquote><blockquote><p><a href="https://www.runoob.com/git/git-tutorial.html" title="Title" target="_blank" rel="noopener">Git教程-菜鸟教程</a></p></blockquote><p><em>因博客主等未标明不可引用，若部分内容涉及侵权请及时告知，我会尽快修改和删除相关内容</em></p>]]></content>
    
    <summary type="html">
    
      Git常用指令笔记
    
    </summary>
    
      <category term="个人记录" scheme="http://linyishui.top/categories/%E4%B8%AA%E4%BA%BA%E8%AE%B0%E5%BD%95/"/>
    
    
      <category term="updating" scheme="http://linyishui.top/tags/updating/"/>
    
      <category term="mysql" scheme="http://linyishui.top/tags/mysql/"/>
    
  </entry>
  
  <entry>
    <title>Linux常用指令（持续更新）</title>
    <link href="http://linyishui.top/2020021901.html"/>
    <id>http://linyishui.top/2020021901.html</id>
    <published>2020-02-19T09:30:05.000Z</published>
    <updated>2020-04-07T10:22:49.916Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="Linux常用指令笔记"><a href="#Linux常用指令笔记" class="headerlink" title="Linux常用指令笔记"></a><strong>Linux常用指令笔记</strong></h1><h2 id="1-文件"><a href="#1-文件" class="headerlink" title="1. 文件"></a><strong>1. 文件</strong></h2><p>&emsp;&emsp;ls</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 列出所有目录</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> ls /</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> 列出目录下所有s开头文件</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> ls -ltr s*</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> 将/bin目录以下所有目录及文件详细信息列出</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> ls -lR /bin</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> 列出目录下所有文件及目录；目录于名称后加 <span class="string">"/"</span>, 可执行档于名称后加<span class="string">"*"</span></span></span><br><span class="line"><span class="meta">$</span><span class="bash"> ls -AF</span></span><br></pre></td></tr></table></figure><p>&emsp;&emsp;目录。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash">使用 mkdir 命令创建 runoob 目录</span></span><br><span class="line">[root@www ~]# mkdir runoob</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash">使用绝对路径切换到 runoob 目录</span></span><br><span class="line">[root@www ~]# cd /root/runoob/</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash">使用相对路径切换到 runoob 目录</span></span><br><span class="line">[root@www ~]# cd ./runoob/</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 表示回到自己的家目录，亦即是 /root 这个目录</span></span><br><span class="line">[root@www runoob]# cd ~</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 表示去到目前的上一级目录，亦即是 /root 的上一级目录的意思；</span></span><br><span class="line">[root@www ~]# cd ..</span><br></pre></td></tr></table></figure><p>&emsp;&emsp;CTRL+D退出当前shell命令。</p><hr><p><em>参考博客和文章书籍等：</em></p><blockquote><p><a href="https://www.runoob.com/linux/linux-tutorial.html" title="Title" target="_blank" rel="noopener">Linux教程</a></p></blockquote><p><em>因博客主等未标明不可引用，若部分内容涉及侵权请及时告知，我会尽快修改和删除相关内容</em></p>]]></content>
    
    <summary type="html">
    
      Linux常用指令笔记
    
    </summary>
    
      <category term="个人记录" scheme="http://linyishui.top/categories/%E4%B8%AA%E4%BA%BA%E8%AE%B0%E5%BD%95/"/>
    
    
      <category term="updating" scheme="http://linyishui.top/tags/updating/"/>
    
      <category term="mysql" scheme="http://linyishui.top/tags/mysql/"/>
    
  </entry>
  
  <entry>
    <title>MySql笔记（持续更新）</title>
    <link href="http://linyishui.top/2020021801.html"/>
    <id>http://linyishui.top/2020021801.html</id>
    <published>2020-02-18T03:15:41.000Z</published>
    <updated>2020-03-24T07:19:41.548Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="MySql笔记"><a href="#MySql笔记" class="headerlink" title="MySql笔记"></a><strong>MySql笔记</strong></h1><h2 id="1-数据库定时备份"><a href="#1-数据库定时备份" class="headerlink" title="1 数据库定时备份"></a><strong>1 数据库定时备份</strong></h2><h3 id="1-1-Linux"><a href="#1-1-Linux" class="headerlink" title="1.1 Linux"></a><strong>1.1 Linux</strong></h3><p>&emsp;&emsp;暂无</p><h3 id="1-2-Windows"><a href="#1-2-Windows" class="headerlink" title="1.2 Windows"></a><strong>1.2 Windows</strong></h3><p>&emsp;&emsp;新建一个.bat文件，</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">@<span class="built_in">echo</span> off</span><br><span class="line"><span class="built_in">set</span> <span class="string">"Ymd=%date:~,4%%date:~5,2%%date:~8,2%"</span></span><br><span class="line"><span class="string">"C:\Program Files\MySQL\MySQL Server 5.7\bin\mysqldump"</span> --opt -u root --password=&lt;密码&gt; &lt;数据库名&gt; &gt; E:\db_backup\scwl_%Ymd%.sql</span><br><span class="line">@<span class="built_in">echo</span> on</span><br></pre></td></tr></table></figure><p>&emsp;&emsp;Windows开启定时任务：【任务管理器】-&gt;【管理工具】-&gt;【任务计划程序中】</p><h3 id="1-3-Navicat-for-MySQL"><a href="#1-3-Navicat-for-MySQL" class="headerlink" title="1.3 Navicat for MySQL"></a><strong>1.3 Navicat for MySQL</strong></h3><p>&emsp;&emsp;<a href="https://www.formysql.com/wenti/dingshi-beifen.html" title="Title" target="_blank" rel="noopener">Navicat for MySQL 如何创建定时备份</a></p><hr><p><em>参考博客和文章书籍等：</em></p><blockquote><p><a href="https://www.formysql.com/wenti/dingshi-beifen.html" title="Title" target="_blank" rel="noopener">Navicat for MySQL 如何创建定时备份</a></p></blockquote><p><em>因博客主等未标明不可引用，若部分内容涉及侵权请及时告知，我会尽快修改和删除相关内容</em></p>]]></content>
    
    <summary type="html">
    
      MySql常用功能和指令笔记
    
    </summary>
    
      <category term="个人记录" scheme="http://linyishui.top/categories/%E4%B8%AA%E4%BA%BA%E8%AE%B0%E5%BD%95/"/>
    
    
      <category term="updating" scheme="http://linyishui.top/tags/updating/"/>
    
      <category term="mysql" scheme="http://linyishui.top/tags/mysql/"/>
    
  </entry>
  
  <entry>
    <title>LoadBalanced注解原理（未完成）</title>
    <link href="http://linyishui.top/2020021501.html"/>
    <id>http://linyishui.top/2020021501.html</id>
    <published>2020-02-15T10:22:31.000Z</published>
    <updated>2020-03-25T02:58:13.153Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="Spring-Cloud-LoadBalanced注解原理"><a href="#Spring-Cloud-LoadBalanced注解原理" class="headerlink" title="Spring Cloud-LoadBalanced注解原理"></a><strong>Spring Cloud-LoadBalanced注解原理</strong></h1><p>​        Spring Cloud提供Ribbon来进行服务端负载均衡，和Eureka配合使用不需要再在服务集群架设负载均衡服务。</p><blockquote><ol><li>RibbonAutoConfiguration配置生成RibbonLoadBalancerClient实例</li><li>LoadBalancerInterceptorConfig配置生成LoadBalancerInterceptor实例（RibbonLoadBalancerClient实例和LoadBalancerRequestFactory实例）和RestTemplate自定义的RestTemplateCustomizer实例</li><li>通过RestTemplateCustomizer实例配置所有RestTemplate实例，即将负载均衡拦截器设置给所有RestTemplate</li><li>RibbonClientConfiguration配置生成ZoneAwareLoadBalancer实例</li></ol></blockquote><h2 id="第二节-源码解析"><a href="#第二节-源码解析" class="headerlink" title="第二节 源码解析"></a><strong>第二节 源码解析</strong></h2><h3 id="2-1-RibbonAutoConfiguration"><a href="#2-1-RibbonAutoConfiguration" class="headerlink" title="2.1 RibbonAutoConfiguration"></a><strong>2.1 RibbonAutoConfiguration</strong></h3><p>&emsp;&emsp;Ribbon基础配置类，用来生成RibbonLoadBalancerClient实例。此配置类要早于LoadBalancerAutoConfiguration前执行，因为在后者中要使用RibbonLoadBalancerClient实例。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="comment">// 只有在classpath下能找到这些类才会构建这个Bean</span></span><br><span class="line"><span class="meta">@ConditionalOnClass</span>(&#123;IClient.class, RestTemplate.class, AsyncRestTemplate.class, Ribbon.class&#125;)</span><br><span class="line"><span class="comment">// 允许在单个类中使用多个@RibbonClient</span></span><br><span class="line"><span class="meta">@RibbonClients</span></span><br><span class="line"><span class="comment">// 控制配置类启动顺序，若有Eureka，那就在Eureka配置好后再配置它</span></span><br><span class="line"><span class="meta">@AutoConfigureAfter</span>(</span><br><span class="line">    name = &#123;<span class="string">"org.springframework.cloud.netflix.eureka.EurekaClientAutoConfiguration"</span>&#125;</span><br><span class="line">)</span><br><span class="line"><span class="meta">@AutoConfigureBefore</span>(&#123;LoadBalancerAutoConfiguration.class, AsyncLoadBalancerAutoConfiguration.class&#125;)</span><br><span class="line"><span class="comment">// 加载配置：ribbon.eager-load --&gt; true的话，那么项目启动的时候就会把Client初始化好，避免第一次惩罚</span></span><br><span class="line"><span class="meta">@EnableConfigurationProperties</span>(&#123;RibbonEagerLoadProperties.class, ServerIntrospectorProperties.class&#125;)</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">RibbonAutoConfiguration</span> </span>&#123;</span><br><span class="line">    <span class="comment">// Ribbon的配置文件</span></span><br><span class="line">    <span class="meta">@Autowired</span>(</span><br><span class="line">        required = <span class="keyword">false</span></span><br><span class="line">    )</span><br><span class="line">    <span class="keyword">private</span> List&lt;RibbonClientSpecification&gt; configurations = <span class="keyword">new</span> ArrayList();</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> RibbonEagerLoadProperties ribbonEagerLoadProperties;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">RibbonAutoConfiguration</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 特征，FeaturesEndpoint这个端点('/actuator/features')会使用它</span></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> HasFeatures <span class="title">ribbonFeature</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> HasFeatures.namedFeature(<span class="string">"Ribbon"</span>, Ribbon.class);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 它是最为重要的，是一个org.springframework.cloud.context.named.NamedContextFactory 此工厂用于创建命名的Spring容器</span></span><br><span class="line">    <span class="comment">// 这里传入配置文件，每个不同命名空间就会创建一个新的容器（和Feign特别像）设置当前容器为父容器</span></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> SpringClientFactory <span class="title">springClientFactory</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        SpringClientFactory factory = <span class="keyword">new</span> SpringClientFactory();</span><br><span class="line">        factory.setConfigurations(<span class="keyword">this</span>.configurations);</span><br><span class="line">        <span class="keyword">return</span> factory;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 这个Bean是关键，若你没定义，就用系统默认提供的Client了</span></span><br><span class="line">    <span class="comment">// RibbonLoadBalancerClient继承自LoadBalancerClient接口，是负载均衡客户端，也是负载均衡策略的调用方，内部使用和持有了SpringClientFactory</span></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="meta">@ConditionalOnMissingBean</span>(&#123;LoadBalancerClient.class&#125;)</span><br><span class="line">    <span class="function"><span class="keyword">public</span> LoadBalancerClient <span class="title">loadBalancerClient</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> RibbonLoadBalancerClient(<span class="keyword">this</span>.springClientFactory());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="meta">@ConditionalOnClass</span>(</span><br><span class="line">        name = &#123;<span class="string">"org.springframework.retry.support.RetryTemplate"</span>&#125;</span><br><span class="line">    )</span><br><span class="line">    <span class="meta">@ConditionalOnMissingBean</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> LoadBalancedRetryFactory <span class="title">loadBalancedRetryPolicyFactory</span><span class="params">(<span class="keyword">final</span> SpringClientFactory clientFactory)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> RibbonLoadBalancedRetryFactory(clientFactory);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="meta">@ConditionalOnMissingBean</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> PropertiesFactory <span class="title">propertiesFactory</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> PropertiesFactory();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="meta">@ConditionalOnProperty</span>(&#123;<span class="string">"ribbon.eager-load.enabled"</span>&#125;)</span><br><span class="line">    <span class="function"><span class="keyword">public</span> RibbonApplicationContextInitializer <span class="title">ribbonApplicationContextInitializer</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> RibbonApplicationContextInitializer(<span class="keyword">this</span>.springClientFactory(), <span class="keyword">this</span>.ribbonEagerLoadProperties.getClients());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">OnRibbonRestClientCondition</span> <span class="keyword">extends</span> <span class="title">AnyNestedCondition</span> </span>&#123;</span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="title">OnRibbonRestClientCondition</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            <span class="keyword">super</span>(ConfigurationPhase.REGISTER_BEAN);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="meta">@ConditionalOnProperty</span>(&#123;<span class="string">"ribbon.restclient.enabled"</span>&#125;)</span><br><span class="line">        <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">RibbonProperty</span> </span>&#123;</span><br><span class="line">            RibbonProperty() &#123;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">/** <span class="doctag">@deprecated</span> */</span></span><br><span class="line">        <span class="meta">@Deprecated</span></span><br><span class="line">        <span class="meta">@ConditionalOnProperty</span>(&#123;<span class="string">"ribbon.http.client.enabled"</span>&#125;)</span><br><span class="line">        <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">ZuulProperty</span> </span>&#123;</span><br><span class="line">            ZuulProperty() &#123;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Target</span>(&#123;ElementType.TYPE, ElementType.METHOD&#125;)</span><br><span class="line">    <span class="meta">@Retention</span>(RetentionPolicy.RUNTIME)</span><br><span class="line">    <span class="meta">@Documented</span></span><br><span class="line">    <span class="meta">@Conditional</span>(&#123;RibbonAutoConfiguration.OnRibbonRestClientCondition.class&#125;)</span><br><span class="line">    <span class="meta">@interface</span> ConditionalOnRibbonRestClient &#123;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Configuration</span></span><br><span class="line">    <span class="meta">@ConditionalOnClass</span>(&#123;HttpRequest.class&#125;)</span><br><span class="line">    <span class="meta">@RibbonAutoConfiguration</span>.ConditionalOnRibbonRestClient</span><br><span class="line">    <span class="keyword">protected</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">RibbonClientHttpRequestFactoryConfiguration</span> </span>&#123;</span><br><span class="line">        <span class="meta">@Autowired</span></span><br><span class="line">        <span class="keyword">private</span> SpringClientFactory springClientFactory;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">protected</span> <span class="title">RibbonClientHttpRequestFactoryConfiguration</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="meta">@Bean</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> RestTemplateCustomizer <span class="title">restTemplateCustomizer</span><span class="params">(<span class="keyword">final</span> RibbonClientHttpRequestFactory ribbonClientHttpRequestFactory)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">return</span> (restTemplate) -&gt; &#123;</span><br><span class="line">                restTemplate.setRequestFactory(ribbonClientHttpRequestFactory);</span><br><span class="line">            &#125;;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="meta">@Bean</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> RibbonClientHttpRequestFactory <span class="title">ribbonClientHttpRequestFactory</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">new</span> RibbonClientHttpRequestFactory(<span class="keyword">this</span>.springClientFactory);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="2-2-LoadBalancerAutoConfiguration"><a href="#2-2-LoadBalancerAutoConfiguration" class="headerlink" title="2.2 LoadBalancerAutoConfiguration"></a><strong>2.2 LoadBalancerAutoConfiguration</strong></h3><p>&emsp;&emsp;源码配置类，为RestTemplate配置拦截器，维护一个restTemplates数组，即所有标注@LoadBalanced的RestTemplate。通过LoadBalancerRequestTransformer</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="comment">// 可见它只对RestTemplate生效</span></span><br><span class="line"><span class="meta">@ConditionalOnClass</span>(&#123;RestTemplate.class&#125;)</span><br><span class="line"><span class="comment">// Spring容器内必须存在这个接口的Bean才会生效（参见：RibbonAutoConfiguration），即RibbonAutoConfiguration生成的RibbonLoadBalancerClient实例。</span></span><br><span class="line"><span class="meta">@ConditionalOnBean</span>(&#123;LoadBalancerClient.class&#125;)</span><br><span class="line"><span class="comment">// retry的配置文件</span></span><br><span class="line"><span class="meta">@EnableConfigurationProperties</span>(&#123;LoadBalancerRetryProperties.class&#125;)</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">LoadBalancerAutoConfiguration</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 维护容器内所有的标注有@LoadBalanced注解的Bean，必须标注有@LoadBalanced注解</span></span><br><span class="line">    <span class="meta">@LoadBalanced</span></span><br><span class="line">    <span class="meta">@Autowired</span>(</span><br><span class="line">        required = <span class="keyword">false</span></span><br><span class="line">    )</span><br><span class="line">    <span class="keyword">private</span> List&lt;RestTemplate&gt; restTemplates = Collections.emptyList();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// LoadBalancerRequestTransformer接口：函数transformRequest(HttpRequest, ServiceInstance)</span></span><br><span class="line">    <span class="comment">// Spring内部默认是没有提供任何实现类的</span></span><br><span class="line">    <span class="meta">@Autowired</span>(</span><br><span class="line">        required = <span class="keyword">false</span></span><br><span class="line">    )</span><br><span class="line">    <span class="keyword">private</span> List&lt;LoadBalancerRequestTransformer&gt; transformers = Collections.emptyList();</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">LoadBalancerAutoConfiguration</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 配置一个匿名的SmartInitializingSingleton，它的afterSingletonsInstantiated()方法会在所有的单例Bean初始化完成之后，再调用一个一个的处理BeanName</span></span><br><span class="line">    <span class="comment">// 使用LoadBalancerInterceptorConfig配置好的RestTemplateCustomizer定制器，对所有的RestTemplate进行定制处理，就是将负载均衡拦截器设置给RestTemplate实例</span></span><br><span class="line">    <span class="comment">// 函数式接口RestTemplateCustomizer下面有个lambda的实现，若调用者有需要可以书写然后扔进容器里既生效</span></span><br><span class="line">    <span class="comment">// 若你项目中有多个RestTempalte，需要统一处理的话，写一个定制器是个不错的选择（比如统一要放置一个请求拦截器：输出日志之类的）</span></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> SmartInitializingSingleton <span class="title">loadBalancedRestTemplateInitializerDeprecated</span><span class="params">(<span class="keyword">final</span> ObjectProvider&lt;List&lt;RestTemplateCustomizer&gt;&gt; restTemplateCustomizers)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> () -&gt; &#123;</span><br><span class="line">            restTemplateCustomizers.ifAvailable((customizers) -&gt; &#123;</span><br><span class="line">                Iterator var2 = <span class="keyword">this</span>.restTemplates.iterator();</span><br><span class="line"></span><br><span class="line">                <span class="keyword">while</span>(var2.hasNext()) &#123;</span><br><span class="line">                    RestTemplate restTemplate = (RestTemplate)var2.next();</span><br><span class="line">                    Iterator var4 = customizers.iterator();</span><br><span class="line"></span><br><span class="line">                    <span class="keyword">while</span>(var4.hasNext()) &#123;</span><br><span class="line">                        RestTemplateCustomizer customizer = (RestTemplateCustomizer)var4.next();</span><br><span class="line">                        customizer.customize(restTemplate);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">            &#125;);</span><br><span class="line">        &#125;;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 这个工厂用于createRequest()生成一个LoadBalancerRequest</span></span><br><span class="line">    <span class="comment">// 这个请求里面是包含LoadBalancerClient以及HttpRequest的</span></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="meta">@ConditionalOnMissingBean</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> LoadBalancerRequestFactory <span class="title">loadBalancerRequestFactory</span><span class="params">(LoadBalancerClient loadBalancerClient)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> LoadBalancerRequestFactory(loadBalancerClient, <span class="keyword">this</span>.transformers);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Configuration</span></span><br><span class="line">    <span class="meta">@ConditionalOnClass</span>(&#123;RetryTemplate.class&#125;)</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">RetryInterceptorAutoConfiguration</span> </span>&#123;</span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="title">RetryInterceptorAutoConfiguration</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="meta">@Bean</span></span><br><span class="line">        <span class="meta">@ConditionalOnMissingBean</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> RetryLoadBalancerInterceptor <span class="title">ribbonInterceptor</span><span class="params">(LoadBalancerClient loadBalancerClient, LoadBalancerRetryProperties properties, LoadBalancerRequestFactory requestFactory, LoadBalancedRetryFactory loadBalancedRetryFactory)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">new</span> RetryLoadBalancerInterceptor(loadBalancerClient, properties, requestFactory, loadBalancedRetryFactory);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="meta">@Bean</span></span><br><span class="line">        <span class="meta">@ConditionalOnMissingBean</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> RestTemplateCustomizer <span class="title">restTemplateCustomizer</span><span class="params">(<span class="keyword">final</span> RetryLoadBalancerInterceptor loadBalancerInterceptor)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">return</span> (restTemplate) -&gt; &#123;</span><br><span class="line">                List&lt;ClientHttpRequestInterceptor&gt; list = <span class="keyword">new</span> ArrayList(restTemplate.getInterceptors());</span><br><span class="line">                list.add(loadBalancerInterceptor);</span><br><span class="line">                restTemplate.setInterceptors(list);</span><br><span class="line">            &#125;;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Configuration</span></span><br><span class="line">    <span class="meta">@ConditionalOnClass</span>(&#123;RetryTemplate.class&#125;)</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">RetryAutoConfiguration</span> </span>&#123;</span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="title">RetryAutoConfiguration</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="meta">@Bean</span></span><br><span class="line">        <span class="meta">@ConditionalOnMissingBean</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> LoadBalancedRetryFactory <span class="title">loadBalancedRetryFactory</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">new</span> LoadBalancedRetryFactory() &#123;</span><br><span class="line">            &#125;;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 通过LoadBalancerInterceptor和RestTemplateCustomizer来添加拦截器</span></span><br><span class="line">    <span class="meta">@Configuration</span></span><br><span class="line">    <span class="meta">@ConditionalOnMissingClass</span>(&#123;<span class="string">"org.springframework.retry.support.RetryTemplate"</span>&#125;)</span><br><span class="line">    <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">LoadBalancerInterceptorConfig</span> </span>&#123;</span><br><span class="line">        LoadBalancerInterceptorConfig() &#123;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 这里直接使用的是requestFactory和Client构建一个拦截器对象</span></span><br><span class="line">        <span class="comment">// LoadBalancerInterceptor实现ClientHttpRequestInterceptor接口，也是实现负载均衡的入口</span></span><br><span class="line">        <span class="meta">@Bean</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> LoadBalancerInterceptor <span class="title">ribbonInterceptor</span><span class="params">(LoadBalancerClient loadBalancerClient, LoadBalancerRequestFactory requestFactory)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">new</span> LoadBalancerInterceptor(loadBalancerClient, requestFactory);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 向容器内放入一个RestTemplateCustomizer定制器，在RestTemplate初始化完成后，应用此定制化器在所有的实例上。</span></span><br><span class="line">        <span class="comment">// 这个匿名实现的逻辑很简单，向所有的RestTemplate都塞入一个loadBalancerInterceptor让其具备有负载均衡的能力</span></span><br><span class="line">        <span class="comment">// 此处有注解@ConditionalOnMissingBean。也就是说如果调用者自己定义过RestTemplateCustomizer类型的Bean，此处是不会执行的</span></span><br><span class="line">        <span class="meta">@Bean</span></span><br><span class="line">        <span class="meta">@ConditionalOnMissingBean</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> RestTemplateCustomizer <span class="title">restTemplateCustomizer</span><span class="params">(<span class="keyword">final</span> LoadBalancerInterceptor loadBalancerInterceptor)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">return</span> (restTemplate) -&gt; &#123;</span><br><span class="line">                List&lt;ClientHttpRequestInterceptor&gt; list = <span class="keyword">new</span> ArrayList(restTemplate.getInterceptors());</span><br><span class="line">                list.add(loadBalancerInterceptor);</span><br><span class="line">                restTemplate.setInterceptors(list);</span><br><span class="line">            &#125;;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><ol><li>LoadBalancerAutoConfiguration要想生效类路径必须有RestTemplate，以及Spring容器内必须有LoadBalancerClient的实现Bean</li><li>LoadBalancerClient的唯一实现类是：org.springframework.cloud.netflix.ribbon.RibbonLoadBalancerClient</li><li>LoadBalancerInterceptor是个ClientHttpRequestInterceptor客户端请求拦截器。它的作用是在客户端发起请求之前拦截，进而实现客户端的负载均衡</li><li>restTemplateCustomizer()返回的匿名定制器RestTemplateCustomizer它用来给所有的RestTemplate加上负载均衡拦截器（需要注意它的@ConditionalOnMissingBean注解~）</li></ol></blockquote><p>​        不难发现，负载均衡实现的核心就是一个拦截器，就是这个拦截器让一个普通的RestTemplate逆袭成为了一个具有负载均衡功能的请求器LoadBalancerInterceptor。</p><h3 id="2-3-LoadBalancerRequestFactory"><a href="#2-3-LoadBalancerRequestFactory" class="headerlink" title="2.3 LoadBalancerRequestFactory"></a><strong>2.3 LoadBalancerRequestFactory</strong></h3><p>&emsp;&emsp;工厂类，根据LoadBalancerRequestTransformer数组批量对HttpRequest进行处理，创建LoadBalancerRequest。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">LoadBalancerRequestFactory</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> LoadBalancerClient loadBalancer;</span><br><span class="line">    <span class="keyword">private</span> List&lt;LoadBalancerRequestTransformer&gt; transformers;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">LoadBalancerRequestFactory</span><span class="params">(LoadBalancerClient loadBalancer, List&lt;LoadBalancerRequestTransformer&gt; transformers)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.loadBalancer = loadBalancer;</span><br><span class="line">        <span class="keyword">this</span>.transformers = transformers;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">LoadBalancerRequestFactory</span><span class="params">(LoadBalancerClient loadBalancer)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.loadBalancer = loadBalancer;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> LoadBalancerRequest&lt;ClientHttpResponse&gt; <span class="title">createRequest</span><span class="params">(<span class="keyword">final</span> HttpRequest request, <span class="keyword">final</span> <span class="keyword">byte</span>[] body, <span class="keyword">final</span> ClientHttpRequestExecution execution)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// Lambda表达式，LoadBalancerRequest是一个函数式接口，T apply(ServiceInstance instance) </span></span><br><span class="line">        <span class="keyword">return</span> (instance) -&gt; &#123;</span><br><span class="line">            HttpRequest serviceRequest = <span class="keyword">new</span> ServiceRequestWrapper(request, instance, <span class="keyword">this</span>.loadBalancer);</span><br><span class="line">            LoadBalancerRequestTransformer transformer;</span><br><span class="line">            <span class="comment">//遍历并执行transformer.transformRequest</span></span><br><span class="line">            <span class="keyword">if</span> (<span class="keyword">this</span>.transformers != <span class="keyword">null</span>) &#123;</span><br><span class="line">                <span class="keyword">for</span>(Iterator var6 = <span class="keyword">this</span>.transformers.iterator(); var6.hasNext(); serviceRequest = transformer.transformRequest((HttpRequest)serviceRequest, instance)) &#123;</span><br><span class="line">                    transformer = (LoadBalancerRequestTransformer)var6.next();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="comment">//执行serviceRequest并返回ClientHttpResponse</span></span><br><span class="line">            <span class="keyword">return</span> execution.execute((HttpRequest)serviceRequest, body);</span><br><span class="line">        &#125;;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="2-4-LoadBalancerInterceptor"><a href="#2-4-LoadBalancerInterceptor" class="headerlink" title="2.4  LoadBalancerInterceptor"></a><strong>2.4  LoadBalancerInterceptor</strong></h3><p>&emsp;&emsp;拦截器代码，主要逻辑在intercept函数，执行交给了LoadBalancerClient来处理，通过LoadBalancerRequestFactory来构建一个LoadBalancerRequest对象。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">LoadBalancerInterceptor</span> <span class="keyword">implements</span> <span class="title">ClientHttpRequestInterceptor</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 这个命名都不叫Client了，而叫loadBalancer</span></span><br><span class="line">    <span class="keyword">private</span> LoadBalancerClient loadBalancer;</span><br><span class="line">    <span class="comment">// 用于构建出一个Request</span></span><br><span class="line">    <span class="keyword">private</span> LoadBalancerRequestFactory requestFactory;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">LoadBalancerInterceptor</span><span class="params">(LoadBalancerClient loadBalancer, LoadBalancerRequestFactory requestFactory)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.loadBalancer = loadBalancer;</span><br><span class="line">        <span class="keyword">this</span>.requestFactory = requestFactory;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">LoadBalancerInterceptor</span><span class="params">(LoadBalancerClient loadBalancer)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>(loadBalancer, <span class="keyword">new</span> LoadBalancerRequestFactory(loadBalancer));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> ClientHttpResponse <span class="title">intercept</span><span class="params">(<span class="keyword">final</span> HttpRequest request, <span class="keyword">final</span> <span class="keyword">byte</span>[] body, <span class="keyword">final</span> ClientHttpRequestExecution execution)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">        URI originalUri = request.getURI();</span><br><span class="line">        String serviceName = originalUri.getHost();</span><br><span class="line">        Assert.state(serviceName != <span class="keyword">null</span>, <span class="string">"Request URI does not contain a valid hostname: "</span> + originalUri);</span><br><span class="line">        <span class="keyword">return</span> (ClientHttpResponse)<span class="keyword">this</span>.loadBalancer.execute(serviceName, <span class="keyword">this</span>.requestFactory.createRequest(request, body, execution));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>&emsp;&emsp;createRequest中通过ServiceRequestWrapper来执行替换URI的逻辑，ServiceRequestWrapper中将URI的获取交给了LoadBalancerClient#reconstructURI方法。</p><p>&emsp;&emsp;此拦截器拦截请求后把它的serviceName委托给了LoadBalancerClient去执行，根据ServiceName可能对应N多个实际的Server，因此就可以从众多的Server中运用均衡算法，挑选出一个最为合适的Server做最终的请求（它持有真正的请求执行器ClientHttpRequestExecution）。</p><h3 id="2-5-LoadBalancerClient"><a href="#2-5-LoadBalancerClient" class="headerlink" title="2.5  LoadBalancerClient"></a><strong>2.5  LoadBalancerClient</strong></h3><p>请求被拦截后，最终都是委托给了LoadBalancerClient处理。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 由使用负载平衡器选择要向其发送请求的服务器的类实现</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">ServiceInstanceChooser</span> </span>&#123;</span><br><span class="line"><span class="comment">// 从负载平衡器中为指定的服务选择Service服务实例。</span></span><br><span class="line">    <span class="comment">// 也就是根据调用者传入的serviceId，负载均衡的选择出一个具体的实例出来</span></span><br><span class="line">    <span class="function">ServiceInstance <span class="title">choose</span><span class="params">(String serviceId)</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 它自己定义了三个方法</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">LoadBalancerClient</span> <span class="keyword">extends</span> <span class="title">ServiceInstanceChooser</span> </span>&#123;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 执行请求</span></span><br><span class="line">    &lt;T&gt; <span class="function">T <span class="title">execute</span><span class="params">(String serviceId, LoadBalancerRequest&lt;T&gt; request)</span> <span class="keyword">throws</span> IOException</span>;</span><br><span class="line">    &lt;T&gt; <span class="function">T <span class="title">execute</span><span class="params">(String serviceId, ServiceInstance serviceInstance, LoadBalancerRequest&lt;T&gt; request)</span> <span class="keyword">throws</span> IOException</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 重新构造url：把url中原来写的服务名 换掉 换成实际的</span></span><br><span class="line">    <span class="function">URI <span class="title">reconstructURI</span><span class="params">(ServiceInstance instance, URI original)</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>​    它只有一个实现类RibbonLoadBalancerClient （ServiceInstanceChooser是有多个实现类的~）。<br>RibbonLoadBalancerClient。<br>​    首先我们应当关注它的choose()方法：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">RibbonLoadBalancerClient</span> <span class="keyword">implements</span> <span class="title">LoadBalancerClient</span> </span>&#123;</span><br><span class="line">    </span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> ServiceInstance <span class="title">choose</span><span class="params">(String serviceId)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> choose(serviceId, <span class="keyword">null</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// hint：你可以理解成分组。若指定了，只会在这个偏好的分组里面去均衡选择</span></span><br><span class="line">    <span class="comment">// 得到一个Server后，使用RibbonServer把server适配起来~~~</span></span><br><span class="line">    <span class="comment">// 这样一个实例就选好了~~~真正请求会落在这个实例上~</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> ServiceInstance <span class="title">choose</span><span class="params">(String serviceId, Object hint)</span> </span>&#123;</span><br><span class="line">        Server server = getServer(getLoadBalancer(serviceId), hint);</span><br><span class="line">        <span class="keyword">if</span> (server == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> RibbonServer(serviceId, server, isSecure(server, serviceId),</span><br><span class="line">                serverIntrospector(serviceId).getMetadata(server));</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 根据ServiceId去找到一个属于它的负载均衡器</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> ILoadBalancer <span class="title">getLoadBalancer</span><span class="params">(String serviceId)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">this</span>.clientFactory.getLoadBalancer(serviceId);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>​        choose方法：传入serviceId，然后通过SpringClientFactory获取负载均衡器com.netflix.loadbalancer.ILoadBalancer，最终委托给它的chooseServer()方法选取到一个com.netflix.loadbalancer.Server实例，也就是说真正完成Server选取的是ILoadBalancer。ILoadBalancer以及它相关的类是一个较为庞大的体系，此处不做更多的展开。</p><p>​        LoadBalancerInterceptor执行的时候是直接委托执行的loadBalancer.execute()这个方法：<br>RibbonLoadBalancerClient：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// hint此处传值为null：一视同仁</span></span><br><span class="line"><span class="comment">// 说明：LoadBalancerRequest是通过LoadBalancerRequestFactory.createRequest(request, body, execution)创建出来的</span></span><br><span class="line"><span class="comment">// 它实现LoadBalancerRequest接口是用的一个匿名内部类，泛型类型是ClientHttpResponse</span></span><br><span class="line"><span class="comment">// 因为最终执行的显然还是执行器：ClientHttpRequestExecution.execute()</span></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">public</span> &lt;T&gt; <span class="function">T <span class="title">execute</span><span class="params">(String serviceId, LoadBalancerRequest&lt;T&gt; request)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> execute(serviceId, request, <span class="keyword">null</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// public方法（非接口方法）</span></span><br><span class="line"><span class="keyword">public</span> &lt;T&gt; <span class="function">T <span class="title">execute</span><span class="params">(String serviceId, LoadBalancerRequest&lt;T&gt; request, Object hint)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">    <span class="comment">// 同上：拿到负载均衡器，然后拿到一个serverInstance实例</span></span><br><span class="line">    ILoadBalancer loadBalancer = getLoadBalancer(serviceId);</span><br><span class="line">    Server server = getServer(loadBalancer, hint);</span><br><span class="line">    <span class="keyword">if</span> (server == <span class="keyword">null</span>) &#123; <span class="comment">// 若没找到就直接抛出异常。这里使用的是IllegalStateException这个异常</span></span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> IllegalStateException(<span class="string">"No instances available for "</span> + serviceId);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 把Server适配为RibbonServer  isSecure：客户端是否安全</span></span><br><span class="line">    <span class="comment">// serverIntrospector内省  参考配置文件：ServerIntrospectorProperties</span></span><br><span class="line">    RibbonServer ribbonServer = <span class="keyword">new</span> RibbonServer(serviceId, server,</span><br><span class="line">            isSecure(server, serviceId), serverIntrospector(serviceId).getMetadata(server));</span><br><span class="line"></span><br><span class="line">    <span class="comment">//调用本类的重载接口方法~~~~~</span></span><br><span class="line">    <span class="keyword">return</span> execute(serviceId, ribbonServer, request);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 接口方法：它的参数是ServiceInstance --&gt; 已经确定了唯一的Server实例~~~</span></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">public</span> &lt;T&gt; <span class="function">T <span class="title">execute</span><span class="params">(String serviceId, ServiceInstance serviceInstance, LoadBalancerRequest&lt;T&gt; request)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 拿到Server）（说白了，RibbonServer是execute时的唯一实现）</span></span><br><span class="line">    Server server = <span class="keyword">null</span>;</span><br><span class="line">    <span class="keyword">if</span> (serviceInstance <span class="keyword">instanceof</span> RibbonServer) &#123;</span><br><span class="line">        server = ((RibbonServer) serviceInstance).getServer();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (server == <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> IllegalStateException(<span class="string">"No instances available for "</span> + serviceId);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 说明：执行的上下文是和serviceId绑定的</span></span><br><span class="line">    RibbonLoadBalancerContext context = <span class="keyword">this</span>.clientFactory.getLoadBalancerContext(serviceId);</span><br><span class="line">    ... </span><br><span class="line">    <span class="comment">// 真正的向server发送请求，得到返回值</span></span><br><span class="line">    <span class="comment">// 因为有拦截器，所以这里肯定说执行的是InterceptingRequestExecution.execute()方法</span></span><br><span class="line">    <span class="comment">// so会调用ServiceRequestWrapper.getURI()，从而就会调用reconstructURI()方法</span></span><br><span class="line">        T returnVal = request.apply(serviceInstance);</span><br><span class="line">        <span class="keyword">return</span> returnVal;</span><br><span class="line">    ... <span class="comment">// 异常处理</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>​        returnVal是一个ClientHttpResponse，最后交给handleResponse()方法来处理异常情况（若存在的话），若无异常就交给提取器提值：responseExtractor.extractData(response)，这样整个请求就算全部完成了。<br>使用细节针对@LoadBalanced下的RestTemplate的使用，总结如下细节供以参考：</p><p>​        传入的String类型的url必须是绝对路径（http://…），否则抛出异常：java.lang.IllegalArgumentException: URI is not absolute<br>​        serviceId不区分大小写（<a href="http://user/...效果同http://USER/...），serviceId后不要跟port端口号" target="_blank" rel="noopener">http://user/...效果同http://USER/...），serviceId后不要跟port端口号</a></p><p>​        最后，需要特别指出的是：标注有@LoadBalanced的RestTemplate只能书写serviceId而不能再写IP地址/域名去发送请求了。若你的项目中两种case都有需要，请定义多个RestTemplate分别应对不同的使用场景~</p><h2 id="第三节-测试"><a href="#第三节-测试" class="headerlink" title="第三节 测试"></a><strong>第三节 测试</strong></h2><pre><code>了解了它的执行流程后，若需要本地测试（不依赖于注册中心），可以这么来做：</code></pre><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 因为自动配置头上有@ConditionalOnMissingBean注解，所以自定义一个覆盖它的行为即可</span></span><br><span class="line"><span class="comment">// 此处复写它的getServer()方法，返回一个固定的（访问百度首页）即可，方便测试</span></span><br><span class="line"><span class="meta">@Bean</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> LoadBalancerClient <span class="title">loadBalancerClient</span><span class="params">(SpringClientFactory factory)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> RibbonLoadBalancerClient(factory) &#123;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">protected</span> Server <span class="title">getServer</span><span class="params">(ILoadBalancer loadBalancer, Object hint)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">new</span> Server(<span class="string">"www.baidu.com"</span>, <span class="number">80</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>​        这么一来，下面这个访问结果就是百度首页的html内容喽。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">contextLoads</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    String obj = restTemplate.getForObject(<span class="string">"http://my-serviceId"</span>, String.class);</span><br><span class="line">    System.out.println(obj);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>​        此处my-serviceId肯定是不存在的，但得益于我上面自定义配置的LoadBalancerClient</p><p>​        什么，写死return一个Server实例不优雅？确实，总不能每次上线前还把这部分代码给注释掉吧，若有多个实例呢？还得自己写负载均衡算法吗？很显然Spring Cloud早早就为我们考虑到了这一点：脱离Eureka使用配置listOfServers进行客户端负载均衡调度（..listOfServers=）</p><p>​        对于上例我只需要在主配置文件里这么配置一下：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> ribbon.eureka.enabled=<span class="literal">false</span> <span class="comment"># 若没用euraka，此配置可省略。否则不可以</span></span></span><br><span class="line">my-serviceId.ribbon.listOfServers=www.baidu.com # 若有多个实例请用逗号分隔复制代码</span><br></pre></td></tr></table></figure><p>​        效果完全同上。Tips：这种配置法不需要是完整的绝对路径，http://是可以省略的（new Server()方式亦可）</p><p>​        自己添加一个记录请求日志的拦截器可行吗？显然是可行的，示例如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@LoadBalanced</span></span><br><span class="line"><span class="meta">@Bean</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> RestTemplate <span class="title">restTemplate</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    RestTemplate restTemplate = <span class="keyword">new</span> RestTemplate();</span><br><span class="line">    List&lt;ClientHttpRequestInterceptor&gt; list = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">    list.add((request, body, execution) -&gt; &#123;</span><br><span class="line">        System.out.println(<span class="string">"当前请求的URL是："</span> + request.getURI().toString());</span><br><span class="line">        <span class="keyword">return</span> execution.execute(request, body);</span><br><span class="line">    &#125;);</span><br><span class="line">    restTemplate.setInterceptors(list);</span><br><span class="line">    <span class="keyword">return</span> restTemplate;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>​        这样每次客户端的请求都会打印这句话：当前请求的URI是：<a href="http://my-serviceId，一般情况（缺省情况）自定义的拦截器都会在负载均衡拦截器前面执行（因为它要执行最终的请求）。若你有必要定义多个拦截器且要控制顺序，可通过Ordered系列接口来实现" target="_blank" rel="noopener">http://my-serviceId，一般情况（缺省情况）自定义的拦截器都会在负载均衡拦截器前面执行（因为它要执行最终的请求）。若你有必要定义多个拦截器且要控制顺序，可通过Ordered系列接口来实现</a>~</p><p>​        最后的最后，一个非常非常重要的问题：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@LoadBalanced</span></span><br><span class="line"><span class="meta">@Autowired</span>(required = <span class="keyword">false</span>)</span><br><span class="line"><span class="keyword">private</span> List&lt;RestTemplate&gt; restTemplates = Collections.emptyList();</span><br></pre></td></tr></table></figure></p><p>​        @Autowired + @LoadBalanced能把你配置的RestTemplate自动注入进来拿来定制呢？？？核心原理是什么？</p><hr><p><em>参考博客和文章书籍等：</em></p><blockquote><p><a href="https://juejin.im/post/5d80576de51d4561b416d51f" title="Title" target="_blank" rel="noopener">为何一个@LoadBalanced注解就能让RestTemplate拥有负载均衡的能力？</a></p></blockquote><p><em>因博客主等未标明不可引用，若部分内容涉及侵权请及时告知，我会尽快修改和删除相关内容</em></p>]]></content>
    
    <summary type="html">
    
      Spring Cloud LoadBalanced注解原理
    
    </summary>
    
      <category term="技术文档" scheme="http://linyishui.top/categories/%E6%8A%80%E6%9C%AF%E6%96%87%E6%A1%A3/"/>
    
    
      <category term="unfinished" scheme="http://linyishui.top/tags/unfinished/"/>
    
      <category term="spring cloud" scheme="http://linyishui.top/tags/spring-cloud/"/>
    
      <category term="ribbon" scheme="http://linyishui.top/tags/ribbon/"/>
    
  </entry>
  
  <entry>
    <title>Idea一些常用设置和快捷操作（持续更新）</title>
    <link href="http://linyishui.top/2020021401.html"/>
    <id>http://linyishui.top/2020021401.html</id>
    <published>2020-02-14T06:33:42.000Z</published>
    <updated>2020-03-24T07:25:25.961Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="Idea一些常用设置和快捷操作"><a href="#Idea一些常用设置和快捷操作" class="headerlink" title="Idea一些常用设置和快捷操作"></a><strong>Idea一些常用设置和快捷操作</strong></h1><h2 id="前文"><a href="#前文" class="headerlink" title="前文"></a>前文</h2><p>​        博主所用Idea为2019.3.3(Ultimate Edition)版本</p><h2 id="第一节-插件"><a href="#第一节-插件" class="headerlink" title="第一节 插件"></a><strong>第一节 插件</strong></h2><h3 id="1-1-背景替换"><a href="#1-1-背景替换" class="headerlink" title="1.1 背景替换"></a><strong>1.1 背景替换</strong></h3><p>&emsp;&emsp;Idea可以设置修改背景图片，【Settings】-&gt;【Appearance】-&gt;【Background Image】</p><p><img src="https://pic-1258215793.cos.ap-shanghai.myqcloud.com/content/20200201/202002010133.png" alt="背景替换"></p><h3 id="1-2-代码迷你缩放图-CodeGlance"><a href="#1-2-代码迷你缩放图-CodeGlance" class="headerlink" title="1.2 代码迷你缩放图-CodeGlance"></a><strong>1.2 代码迷你缩放图-CodeGlance</strong></h3><p>&emsp;&emsp;插件可以在Idea中联网下载（或者自行下载后安装），【Settings】-&gt;【Plugins】-&gt;【CodeGlance】</p><p><img src="https://pic-1258215793.cos.ap-shanghai.myqcloud.com/content/20200201/202002010134.png" alt="代码迷你缩放图"></p><p>&emsp;&emsp;安装完毕重启，效果如下。</p><p><img src="https://pic-1258215793.cos.ap-shanghai.myqcloud.com/content/20200201/202002010135.png" alt="代码迷你缩放图-效果"></p><h3 id="1-3-翻译-Translation"><a href="#1-3-翻译-Translation" class="headerlink" title="1.3 翻译-Translation"></a><strong>1.3 翻译-Translation</strong></h3><p>&emsp;&emsp;【Settings】-&gt;【Plugins】-&gt;【Translation】</p><p><img src="https://pic-1258215793.cos.ap-shanghai.myqcloud.com/content/20200201/202002010136.png" alt="代码迷你缩放图-效果"></p><p>&emsp;&emsp;重启后，可勾选一段文字，右击后选择Translate进行翻译。</p><p><img src="https://pic-1258215793.cos.ap-shanghai.myqcloud.com/content/20200201/202002010137.png" alt="代码迷你缩放图-效果"></p><p>​        效果如下。</p><p><img src="https://pic-1258215793.cos.ap-shanghai.myqcloud.com/content/20200201/202002010138.png" alt="代码迷你缩放图-效果"></p><h3 id="1-4-彩虹括号-Rainbow-Brackets"><a href="#1-4-彩虹括号-Rainbow-Brackets" class="headerlink" title="1.4 彩虹括号-Rainbow Brackets"></a><strong>1.4 彩虹括号-Rainbow Brackets</strong></h3><p>&emsp;&emsp;【Settings】-&gt;【Plugins】-&gt;【Rainbow Brackets】</p><p><img src="https://pic-1258215793.cos.ap-shanghai.myqcloud.com/content/20200201/202002010139.png" alt="代码迷你缩放图-效果"></p><p>​        重启后，观察效果。</p><p><img src="https://pic-1258215793.cos.ap-shanghai.myqcloud.com/content/20200201/202002010140.png" alt="代码迷你缩放图-效果"></p><h3 id="1-5-代码统计-Statistic"><a href="#1-5-代码统计-Statistic" class="headerlink" title="1.5 代码统计-Statistic"></a><strong>1.5 代码统计-Statistic</strong></h3><p>&emsp;&emsp;【Settings】-&gt;【Plugins】-&gt;【Statistic】</p><p><img src="https://pic-1258215793.cos.ap-shanghai.myqcloud.com/content/20200201/202002010141.png" alt="代码迷你缩放图-效果"></p><p>​        重启后，将统计工具添加到显示栏，【View】-&gt;【Tool Windows】-&gt;【Statistic】</p><p><img src="https://pic-1258215793.cos.ap-shanghai.myqcloud.com/content/20200201/202002010142.png" alt="代码迷你缩放图-效果"></p><p>​        效果如下。</p><p><img src="https://pic-1258215793.cos.ap-shanghai.myqcloud.com/content/20200201/202002010143.png" alt="代码迷你缩放图-效果"></p><h3 id="1-6-接口工具-RestfulToolkit"><a href="#1-6-接口工具-RestfulToolkit" class="headerlink" title="1.6 接口工具-RestfulToolkit"></a><strong>1.6 接口工具-RestfulToolkit</strong></h3><p>&emsp;&emsp;Idea 新版本自带Web，这里使用插件RestfulToolkit，【Settings】-&gt;【Plugins】-&gt;【RestfulToolkit】</p><p><img src="https://pic-1258215793.cos.ap-shanghai.myqcloud.com/content/20200201/202002010144.png" alt="代码迷你缩放图-效果"></p><p>​        重启后，可在侧栏的RestServices查看项目所有接口API，也可以直接进行接口测试。</p><p><img src="https://pic-1258215793.cos.ap-shanghai.myqcloud.com/content/20200201/202002010145.png" alt="代码迷你缩放图-效果"></p><h3 id="1-7-Json代码生成-GsonFormat"><a href="#1-7-Json代码生成-GsonFormat" class="headerlink" title="1.7 Json代码生成-GsonFormat"></a><strong>1.7 Json代码生成-GsonFormat</strong></h3><p>​        【Settings】-&gt;【Plugins】-&gt;【GsonFormat】</p><p><img src="https://pic-1258215793.cos.ap-shanghai.myqcloud.com/content/20200201/202002010146.png" alt="代码迷你缩放图-效果"></p><p>​        重启后，新建一个类Test，类中鼠标右键，选择Generate。</p><p><img src="https://pic-1258215793.cos.ap-shanghai.myqcloud.com/content/20200201/202002010147.png" alt="代码迷你缩放图-效果"></p><p>​        然后点选GsonFormat。</p><p><img src="https://pic-1258215793.cos.ap-shanghai.myqcloud.com/content/20200201/202002010148.png" alt="代码迷你缩放图-效果"></p><p>​        在弹出的输入框中键入要转换的Json串。</p><p><img src="https://pic-1258215793.cos.ap-shanghai.myqcloud.com/content/20200201/202002010149.png" alt="代码迷你缩放图-效果"></p><p>​        插件会自动识别数据类型。</p><p><img src="https://pic-1258215793.cos.ap-shanghai.myqcloud.com/content/20200201/202002010150.png" alt="代码迷你缩放图-效果"></p><p>​        最终会生成如下代码。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * id : 1</span></span><br><span class="line"><span class="comment">     * name : demoData</span></span><br><span class="line"><span class="comment">     * sort : 1</span></span><br><span class="line"><span class="comment">     * enabled : true</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> id;</span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> sort;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">boolean</span> enabled;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getId</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> id;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setId</span><span class="params">(<span class="keyword">int</span> id)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.id = id;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getName</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setName</span><span class="params">(String name)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.name = name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getSort</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> sort;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setSort</span><span class="params">(<span class="keyword">int</span> sort)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.sort = sort;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isEnabled</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> enabled;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setEnabled</span><span class="params">(<span class="keyword">boolean</span> enabled)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.enabled = enabled;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="第二节-Idea设置"><a href="#第二节-Idea设置" class="headerlink" title="第二节 Idea设置"></a><strong>第二节 Idea设置</strong></h2><h3 id="2-1-生成serialVersionUID"><a href="#2-1-生成serialVersionUID" class="headerlink" title="2.1 生成serialVersionUID"></a><strong>2.1 生成serialVersionUID</strong></h3><p>&emsp;&emsp;设置：【File】-&gt;【Settings】-&gt;【Editor】-&gt;【Inspections】-&gt;【Java】-&gt;【Serialization issues】-&gt;【Serializable class without ‘serialVersionUID’】</p><p><img src="https://pic-1258215793.cos.ap-shanghai.myqcloud.com/content/20200201/202002010126.png" alt="设置生成serialVersionUID"></p><p>&emsp;&emsp;鼠标移动到类名处，【Alt】+【Enter】，即可生成serialVersionUID。</p><p><img src="https://pic-1258215793.cos.ap-shanghai.myqcloud.com/content/20200201/202002010127.png" alt="生成serialVersionUID"></p>]]></content>
    
    <summary type="html">
    
      Idea一些常用设置和快捷操作
    
    </summary>
    
      <category term="个人记录" scheme="http://linyishui.top/categories/%E4%B8%AA%E4%BA%BA%E8%AE%B0%E5%BD%95/"/>
    
    
      <category term="updating" scheme="http://linyishui.top/tags/updating/"/>
    
      <category term="idea" scheme="http://linyishui.top/tags/idea/"/>
    
  </entry>
  
  <entry>
    <title>面向对象-多态</title>
    <link href="http://linyishui.top/2020021301.html"/>
    <id>http://linyishui.top/2020021301.html</id>
    <published>2020-02-13T06:47:11.000Z</published>
    <updated>2020-03-13T10:01:13.472Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="多态"><a href="#多态" class="headerlink" title="多态"></a><strong>多态</strong></h1><h2 id="第一节-简介"><a href="#第一节-简介" class="headerlink" title="第一节 简介"></a><strong>第一节 简介</strong></h2><h3 id="1-1-什么是多态"><a href="#1-1-什么是多态" class="headerlink" title="1.1 什么是多态"></a><strong>1.1 什么是多态</strong></h3><p>&emsp;&emsp;多态，按照字面意思就是具有多种形态，用来描述同一个行为具有多种表现形式或形态能力，作为面向对象的三个特性（继承、封装和多态）之一。</p><p>&emsp;&emsp;多态就是同一个接口，使用不同的实例而执行不同操作，多态性是对象多种表现形式的体现，同一个事件发生在不同的对象上会产生不同的结果。</p><h3 id="1-2-优点"><a href="#1-2-优点" class="headerlink" title="1.2 优点"></a><strong>1.2 优点</strong></h3><blockquote><ul><li>消除类型之间的耦合关系</li><li>可替换性</li><li>可扩充性</li><li>接口性</li><li>灵活性</li><li>简化性</li></ul></blockquote><h3 id="1-3-在Java中的实现方式"><a href="#1-3-在Java中的实现方式" class="headerlink" title="1.3 在Java中的实现方式"></a><strong>1.3 在Java中的实现方式</strong></h3><blockquote><p>多态存在的三个必要条件：</p><ul><li>继承</li><li>重写</li><li>父类引用指向子类对象</li></ul></blockquote><p>&emsp;&emsp;多态又可以分为<strong>编译时多态</strong>和<strong>运行时多态</strong>。</p><blockquote><p>Java中使用多态特性的主要有:</p><ul><li><strong>方法重载</strong>(overload)：同一个类中可以创建多个具有相同名字的方法，但可具有不同的参数列表、返回值类型，调用方法时通过传递的参数类型来决定具体使用哪个方法，体现了多态性。是一种<strong>编译时多态</strong>，运行时调用的是确定的方法。</li><li><strong>方法重写</strong>(overrite)：子类可继承父类中的方法，但有时子类并不想原封不动地继承父类的方法，而是想作一定的修改，这就需要采用方法的重写。重写的参数列表和返回类型均不可修改，要想调用父类中被重写的方法，则必须使用关键字super。是一种<strong>运行时多态</strong>，在运行时有不同的执行效果。</li><li><strong>实现接口</strong>：对接口方法的实现，是一种<strong>运行时多态</strong>。</li><li><strong>实现抽象类的一个方法</strong>：是一种<strong>运行时多态</strong>。</li></ul></blockquote><hr><h2 id="第二节-实现原理"><a href="#第二节-实现原理" class="headerlink" title="第二节 实现原理"></a><strong>第二节 实现原理</strong></h2><p>&emsp;&emsp;多态的底层实现是<strong>动态绑定</strong>，即在运行时才把方法调用与方法实现关联起来，通过<strong>方法表</strong>来实现。动态绑定涉及到一些JVM知识，如果对JVM不够了解可以先补充一些相关知识。</p><h3 id="2-1-虚函数"><a href="#2-1-虚函数" class="headerlink" title="2.1 虚函数"></a><strong>2.1 虚函数</strong></h3><p>&emsp;&emsp;虚函数的存在是为了多态。</p><p>&emsp;&emsp;Java 中其实没有虚函数的概念，它的普通函数就相当于 C++ 的虚函数，动态绑定是Java的默认行为。如果 Java 中不希望某个函数具有虚函数特性，可以加上 final 关键字变成非虚函数。</p><h3 id="2-2-静态绑定与动态绑定"><a href="#2-2-静态绑定与动态绑定" class="headerlink" title="2.2 静态绑定与动态绑定"></a><strong>2.2 静态绑定与动态绑定</strong></h3><blockquote><p>JVM 的方法调用指令有五个，分别是：</p><ul><li>invokestatic：调用静态方法</li><li>invokespecial：调用实例构造器&lt; init &gt;方法、私有方法和父类方法</li><li>invokevirtual：调用虚方法</li><li>invokeinterface：调用接口方法，运行时确定具体实现</li><li>invokedynamic：运行时动态解析所引用的方法，然后再执行，用于支持动态类型语言。</li></ul></blockquote><p>&emsp;&emsp;其中，invokestatic 和 invokespecial 用于静态绑定，invokevirtual 和 invokeinterface 用于动态绑定。可以看出，动态绑定主要应用于虚方法和接口方法。</p><p>&emsp;&emsp;<strong>静态绑定</strong>在编译期就已经确定，这是因为静态方法、构造器方法、私有方法和父类方法可以唯一确定。这些方法的符号引用在类加载的解析阶段就会解析成直接引用。因此这些方法也被称为非虚方法，与之相对的便是虚方法。</p><p>&emsp;&emsp;<strong>动态绑定</strong>是指在执行期间（非编译期）判断所引用对象的实际类型，根据其实际的类型调用其相应的方法。</p><p>&emsp;&emsp;虚方法的方法调用与方法实现的关联（也就是分派）有两种，<strong>一种是在编译期确定，被称为静态分派，比如方法的重载</strong>；<strong>一种是在运行时确定，被称为动态分派，比如方法的重写</strong>。对象方法基本上都是虚方法。</p><p>&emsp;&emsp;这里需要特别说明的是，final 方法由于不能被覆盖，可以唯一确定，因此 Java 语言规范规定 final 方法属于非虚方法，但仍然使用 invokevirtual 指令调用。静态绑定、动态绑定的概念和虚方法、非虚方法的概念是两个不同的概念。</p><h3 id="2-3-虚拟机中多态的实现"><a href="#2-3-虚拟机中多态的实现" class="headerlink" title="2.3 虚拟机中多态的实现"></a><strong>2.3 虚拟机中多态的实现</strong></h3><p>&emsp;&emsp;虚拟机栈中会存放当前方法调用的栈帧，在栈帧中，存储着局部变量表、操作栈、动态连接、返回地址和其他附加信息。<strong>多态的实现过程，就是方法调用动态分派的过程</strong>，通过栈帧的信息去找到被调用方法的具体实现，然后使用这个具体实现的直接引用完成方法调用。</p><h4 id="2-3-1-调用虚方法的执行过程"><a href="#2-3-1-调用虚方法的执行过程" class="headerlink" title="2.3.1 调用虚方法的执行过程"></a><strong>2.3.1 调用虚方法的执行过程</strong></h4><p>&emsp;&emsp;以 invokevirtual 指令为例，在执行时，大致可以分为以下几步：</p><blockquote><ol><li>先从操作栈中找到对象的实际类型class；</li><li>找到class中与被调用方法签名相同的方法，如果有访问权限就返回这个方法的直接引用，如果没有访问权限就报错 java.lang.IllegalAccessError；</li><li>如果第 2 步找不到相符的方法，就去搜索 class 的父类，按照继承关系自下而上依次执行第 2 步的操作；</li><li>如果第 3 步找不到相符的方法，就报错java.lang.AbstractMethodError；</li></ol></blockquote><p>&emsp;&emsp;可以看到，如果子类覆盖了父类的方法，则在多态调用中，动态绑定过程会首先确定实际类型是子类，从而先搜索到子类中的方法。这个过程便是方法覆盖的本质。</p><p>&emsp;&emsp;实际上，商用虚拟机为了保证性能，通常会使用<strong>虚方法表</strong>和<strong>接口方法表</strong>，而不是每次都执行一遍上面的步骤。以虚方法表为例，虚方法表在类加载的解析阶段填充完成，其中存储了所有方法的直接引用。也就是说，动态分派在填充虚方法表的时候就已经完成了。</p><p>&emsp;&emsp;在子类的虚方法表中，如果子类覆盖了父类的某个方法，则这个方法的直接引用指向子类的实现；而子类没有覆盖的那些方法，比如 Object 的方法，直接引用指向父类或 Object 的实现。</p><h4 id="2-3-2-调用重写的虚方法"><a href="#2-3-2-调用重写的虚方法" class="headerlink" title="2.3.2 调用重写的虚方法"></a><strong>2.3.2 调用重写的虚方法</strong></h4><p>&emsp;&emsp;假设有类A和类B，B为A的子类，并重写了类A的method()方法，两个方法分别打印不同的输出。根据下列调用猜想一下实际的输出。</p><figure class="highlight mipsasm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">A a = new <span class="keyword">B();</span></span><br><span class="line"><span class="keyword">B </span><span class="keyword">b </span>= new <span class="keyword">B();</span></span><br><span class="line"><span class="keyword">a.method();</span></span><br><span class="line"><span class="keyword">b.method();</span></span><br></pre></td></tr></table></figure><p>&emsp;&emsp;很明显最终都会打印B中method()的输出，编译时通过A类的method()验证，运行时却实际调用的B类的method()。因为不管编译时引用变量是什么数据类型，最终在方法表中存放的仍是运行时要执行的引用。</p><h4 id="2-3-3-方法表在方法调用中的工作"><a href="#2-3-3-方法表在方法调用中的工作" class="headerlink" title="2.3.3 方法表在方法调用中的工作"></a><strong>2.3.3 方法表在方法调用中的工作</strong></h4><p>&emsp;&emsp;在JVM执行Java字节码时，类型信息被存放在方法区中，通常为了优化对象调用方法的速度，方法区的类型信息中增加一个指针，该指针指向一张记录该类方法入口的表（称为<strong>方法表</strong>），表中的每一项都是指向相应方法的指针。</p><p>&emsp;&emsp;由于Java的单继承机制，一个类只能继承一个父类，而所有的类又都继承自Object类。方法表中最先存放的是Object类的方法，接下来是该类的父类的方法，最后是该类本身的方法。这里关键的地方在于，如果子类改写了父类的方法，那么子类和父类的那些同名方法共享一个方法表项，都被认作是父类的方法。</p><blockquote><p><em>注意这里只有非私有的实例方法才会出现，并且静态方法也不会出现在这里，原因很容易理解：静态方法跟对象无关，可以将方法地址直接引用，而不像实例方法需要间接引用。</em></p><p><em>更深入地讲，静态方法是由虚拟机指令invokestatic调用的，私有方法和构造函数则是由invokespecial指令调用，只有被invokevirtual和invokeinterface指令调用的方法才会在方法表中出现。</em></p></blockquote><p>&emsp;&emsp;由于以上方法的排列特性（Object——父类——子类），使得方法表的偏移量总是固定的。例如，对于任何类来说，其方法表中equals方法的偏移量总是一个定值，所有继承某父类的子类的方法表中，其父类所定义的方法的偏移量也总是一个定值。</p><p>&emsp;&emsp;前面说过，方法表中的表项都是指向该类对应方法的指针，这里就开始了多态的实现：在父类A的方法表中，method方法的指针指向的就是A的method方法入口。而对于子类B来说，它的方法表中的method方法则会指向其自身的method方法而非其父类的（这在类加载器载入该类时已经保证，同时JVM会保证总是能从对象引用指向正确的类型信息）。</p><p>&emsp;&emsp;结合方法指针偏移量是固定的以及指针总是指向实际类的方法域，我们不难发现多态的机制就在这里：在调用方法时，实际上必须<strong>首先完成实例方法的符号引用解析</strong>，结果是该<strong>符号引用被解析为方法表的偏移量</strong>。虚拟机通过对象引用得到方法区中类型信息的入口，查询类的方法表，当将子类对象声明为父类类型时，形式上调用的是父类方法，此时虚拟机会从实际类的方法表（虽然声明的是父类，但是实际上这里的类型信息中存放的是子类的信息）中查找该方法名对应的指针（这里用“查找”实际上是不合适的，前面提到过，方法的偏移量是固定的，所以只需根据偏移量就能获得指针），进而就能指向实际类的方法了。</p><h4 id="2-3-4-实现接口的多态"><a href="#2-3-4-实现接口的多态" class="headerlink" title="2.3.4 实现接口的多态"></a><strong>2.3.4 实现接口的多态</strong></h4><p>&emsp;&emsp;上上面的过程仅仅是利用继承实现多态的内部机制，多态的另外一种实现方式：实现接口相比而言就更加复杂，原因在于，Java的单继承保证了类的线性关系，而接口可以同时实现多个，这样光凭偏移量就很难准确获得方法的指针。所以在JVM中，多态的实例方法调用实际上有两种指令：</p><blockquote><ul><li>invokevirtual指令用于调用声明为类引用的方法。</li><li>invokeinterface指令用于调用声明为接口的方法。</li></ul></blockquote><p>&emsp;&emsp;当使用invokeinterface指令调用方法时，就不能采用固定偏移量的办法，只能老老实实挨个找了（当然实际实现并不一定如此，JVM规范并没有规定究竟如何实现这种查找，不同的JVM实现可以有不同的优化算法来提高搜索效率）。我们不难看出，在性能上，调用接口引用的方法通常总是比调用类的引用的方法要慢。这也告诉我们，在类和接口之间优先选择接口作为设计并不总是正确的。</p><hr><p><em>参考博客和文章书籍等：</em></p><blockquote><p><a href="https://www.runoob.com/java/java-polymorphism.html" title="Title" target="_blank" rel="noopener">Java多态</a></p></blockquote><p><em>因博客主等未标明不可引用，若部分内容涉及侵权请及时告知，我会尽快修改和删除相关内容</em></p>]]></content>
    
    <summary type="html">
    
      简单介绍面向对象-多态，内容包括：简介和实现原理等。
    
    </summary>
    
      <category term="技术文档" scheme="http://linyishui.top/categories/%E6%8A%80%E6%9C%AF%E6%96%87%E6%A1%A3/"/>
    
    
      <category term="java" scheme="http://linyishui.top/tags/java/"/>
    
  </entry>
  
  <entry>
    <title>面试整理——Spring Boot（持续更新）</title>
    <link href="http://linyishui.top/2020021201.html"/>
    <id>http://linyishui.top/2020021201.html</id>
    <published>2020-02-12T10:47:45.000Z</published>
    <updated>2020-03-24T07:07:45.384Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h3 id="问：SpringBoot的自动配置流程？"><a href="#问：SpringBoot的自动配置流程？" class="headerlink" title="问：SpringBoot的自动配置流程？"></a><strong>问：SpringBoot的自动配置流程？</strong></h3><details><br><br>&emsp;&emsp;<br><br></details><h3 id="问：假如现在在一个类了要引用到几十个Bean，难道要在类里声明这些bean然后加注解吗，有没有更好的做法？"><a href="#问：假如现在在一个类了要引用到几十个Bean，难道要在类里声明这些bean然后加注解吗，有没有更好的做法？" class="headerlink" title="问：假如现在在一个类了要引用到几十个Bean，难道要在类里声明这些bean然后加注解吗，有没有更好的做法？"></a><strong>问：假如现在在一个类了要引用到几十个Bean，难道要在类里声明这些bean然后加注解吗，有没有更好的做法？</strong></h3><details><br><br>&emsp;&emsp;<br><br></details>]]></content>
    
    <summary type="html">
    
      整理面试中常问的Spring Boot相关问题，持续更新中。
    
    </summary>
    
      <category term="面试整理" scheme="http://linyishui.top/categories/%E9%9D%A2%E8%AF%95%E6%95%B4%E7%90%86/"/>
    
    
      <category term="Q&amp;A" scheme="http://linyishui.top/tags/Q-A/"/>
    
      <category term="updating" scheme="http://linyishui.top/tags/updating/"/>
    
  </entry>
  
  <entry>
    <title>面试整理——其它（持续更新）</title>
    <link href="http://linyishui.top/2020021101.html"/>
    <id>http://linyishui.top/2020021101.html</id>
    <published>2020-02-11T10:46:18.000Z</published>
    <updated>2020-03-24T07:07:56.698Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h3 id="问：讲一下用的服务器是tomcat还是netty？tomcat的配置参数有印象吗？优化方面有了解过吗？"><a href="#问：讲一下用的服务器是tomcat还是netty？tomcat的配置参数有印象吗？优化方面有了解过吗？" class="headerlink" title="问：讲一下用的服务器是tomcat还是netty？tomcat的配置参数有印象吗？优化方面有了解过吗？"></a><strong>问：讲一下用的服务器是tomcat还是netty？tomcat的配置参数有印象吗？优化方面有了解过吗？</strong></h3><details><br><br>&emsp;&emsp;<br><br></details><h3 id="问：讲一下Hibernate如何实现ORM，引入它的jar包你怎么使用Hibernate操作数据库？"><a href="#问：讲一下Hibernate如何实现ORM，引入它的jar包你怎么使用Hibernate操作数据库？" class="headerlink" title="问：讲一下Hibernate如何实现ORM，引入它的jar包你怎么使用Hibernate操作数据库？"></a><strong>问：讲一下Hibernate如何实现ORM，引入它的jar包你怎么使用Hibernate操作数据库？</strong></h3><details><br><br>&emsp;&emsp;<br><br></details><h3 id="问：讲一下Mybatis基于接口完成查询的过程及原理？"><a href="#问：讲一下Mybatis基于接口完成查询的过程及原理？" class="headerlink" title="问：讲一下Mybatis基于接口完成查询的过程及原理？"></a><strong>问：讲一下Mybatis基于接口完成查询的过程及原理？</strong></h3><details><br><br>&emsp;&emsp;<br><br></details><h3 id="问：讲一下Mybatis的一级缓存和二级缓存？"><a href="#问：讲一下Mybatis的一级缓存和二级缓存？" class="headerlink" title="问：讲一下Mybatis的一级缓存和二级缓存？"></a><strong>问：讲一下Mybatis的一级缓存和二级缓存？</strong></h3><details><br><br>&emsp;&emsp;<br><br></details><h3 id="问：讲一下Quartz是如何完成定时任务的；集群同步机制？"><a href="#问：讲一下Quartz是如何完成定时任务的；集群同步机制？" class="headerlink" title="问：讲一下Quartz是如何完成定时任务的；集群同步机制？"></a><strong>问：讲一下Quartz是如何完成定时任务的；集群同步机制？</strong></h3><details><br><br>&emsp;&emsp;<br><br></details>]]></content>
    
    <summary type="html">
    
      整理面试中常问的其它问题，持续更新中。
    
    </summary>
    
      <category term="面试整理" scheme="http://linyishui.top/categories/%E9%9D%A2%E8%AF%95%E6%95%B4%E7%90%86/"/>
    
    
      <category term="Q&amp;A" scheme="http://linyishui.top/tags/Q-A/"/>
    
      <category term="updating" scheme="http://linyishui.top/tags/updating/"/>
    
  </entry>
  
  <entry>
    <title>Spring Bean</title>
    <link href="http://linyishui.top/2020021001.html"/>
    <id>http://linyishui.top/2020021001.html</id>
    <published>2020-02-10T07:41:41.000Z</published>
    <updated>2020-03-24T02:14:52.162Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="Spring-Bean"><a href="#Spring-Bean" class="headerlink" title="Spring Bean"></a><strong>Spring Bean</strong></h1><h2 id="第一节-简介"><a href="#第一节-简介" class="headerlink" title="第一节 简介"></a><strong>第一节 简介</strong></h2><h3 id="1-1-Spring-Bean是什么？"><a href="#1-1-Spring-Bean是什么？" class="headerlink" title="1.1 Spring Bean是什么？"></a><strong>1.1 Spring Bean是什么？</strong></h3><p>&emsp;&emsp;在Spring中，用来构成应用程序主干并由Spring IoC容器管理的对象就是bean，所以Spring Bean是一个由Spring IoC容器实例化、组装和管理的对象。</p><h3 id="1-2-概念"><a href="#1-2-概念" class="headerlink" title="1.2 概念"></a><strong>1.2 概念</strong></h3><blockquote><ul><li><strong>IoC</strong>：IoC(Inversion of Control)即控制反转，通过依赖注入的方式动态生成依赖对象并注入被依赖对象中。</li><li><strong>Bean容器</strong>：即Spring IoC容器，管理对象和依赖，以及依赖的注入。</li><li><strong>Bean</strong>：Java对象，遵循Bean规范，由Bean容器生成。</li><li><strong>Bean规范</strong>：满足几个条件，包括所有属性为private，提供默认构造方法，提供getter和setter，实现serializable接口。</li></ul></blockquote><hr><h2 id="第二节-生命周期"><a href="#第二节-生命周期" class="headerlink" title="第二节 生命周期"></a><strong>第二节 生命周期</strong></h2><p>&emsp;&emsp;Java对象在new时创建，不被引用后被GC回收，而Spring IoC容器托管的对象的生命周期则由容器控制。Spring Bean的生命周期如下。</p><p><img src="https://pic-1258215793.cos.ap-shanghai.myqcloud.com/content/20200201/754a34e03cfaa40008de8e2b9c1b815c_1440w.jpg" alt="Spring Bean的生命周期"></p><hr><h2 id="第三节-解析"><a href="#第三节-解析" class="headerlink" title="第三节 解析"></a><strong>第三节 解析</strong></h2><h3 id="3-1-实例化Bean"><a href="#3-1-实例化Bean" class="headerlink" title="3.1 实例化Bean"></a><strong>3.1 实例化Bean</strong></h3><p>&emsp;&emsp;对于BeanFactory容器，当用户向容器请求一个尚未初始化的Bean时，或者是初始化Bean的时候需要注入另一个尚未初始化的依赖时，容器会调用createBean()进行实例化。</p><p>&emsp;&emsp;对于ApplicationContext容器，容器启动后就实例化所有Bean。</p><p>&emsp;&emsp;容器通过获取BeanDefinition对象中的信息进行实例化。并且这一步仅仅是简单的实例化，并未进行依赖注入。实例化对象被包装在BeanWrapper对象中，BeanWrapper提供了设置对象属性的接口，从而避免了使用反射机制设置属性。</p><h3 id="3-2-依赖注入"><a href="#3-2-依赖注入" class="headerlink" title="3.2 依赖注入"></a><strong>3.2 依赖注入</strong></h3><p>&emsp;&emsp;设置对象属性，按照Spring上下文对实例化的Bean进行配置</p><h3 id="3-3-BeanNameAware"><a href="#3-3-BeanNameAware" class="headerlink" title="3.3 BeanNameAware"></a><strong>3.3 BeanNameAware</strong></h3><p>&emsp;&emsp;紧接着，Spring会检测该Bean对象是否实现了BeanNameAware接口，如果实现了则Spring将Bean的ID传递给setBeanName()方法。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//实现此接口主要是为了通过Bean的引用来获得Bean的ID，一般业务中是很少有用到Bean的ID的</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">BeanNameAware</span> <span class="keyword">extends</span> <span class="title">Aware</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">setBeanName</span><span class="params">(String var1)</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="3-4-BeanFactoryAware"><a href="#3-4-BeanFactoryAware" class="headerlink" title="3.4 BeanFactoryAware"></a><strong>3.4 BeanFactoryAware</strong></h3><p>&emsp;&emsp;继续检测Bean是否实现了BeanFactoryAware接口，如果实现了，则调用setBeanFactory()方法，并传递BeanFactory实例。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//主要目的是为了获取Spring容器，如Bean通过Spring容器发布事件等</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">BeanFactoryAware</span> <span class="keyword">extends</span> <span class="title">Aware</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">setBeanFactory</span><span class="params">(BeanFactory var1)</span> <span class="keyword">throws</span> BeansException</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="3-5-ApplicationContextAware"><a href="#3-5-ApplicationContextAware" class="headerlink" title="3.5 ApplicationContextAware"></a><strong>3.5 ApplicationContextAware</strong></h3><p>&emsp;&emsp;继续检测Bean是否实现了ApplicationContextAware接口，如果实现了，则调用setApplicationContext()方法，并传递应用上下文。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//作用与BeanFactory类似都是为了获取Spring容器，不同的是Spring容器在调用setApplicationContext方法时会把它自己作为setApplicationContext的参数传入，而Spring容器在调用setBeanDactory前需要指定（注入）setBeanDactory里的参数BeanFactory</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">ApplicationContextAware</span> <span class="keyword">extends</span> <span class="title">Aware</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">setApplicationContext</span><span class="params">(ApplicationContext var1)</span> <span class="keyword">throws</span> BeansException</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="3-6-BeanPostProcessor"><a href="#3-6-BeanPostProcessor" class="headerlink" title="3.6 BeanPostProcessor"></a><strong>3.6 BeanPostProcessor</strong></h3><p>&emsp;&emsp;当经过上述几个步骤后，bean对象已经被正确构造，但如果你想要对象被使用前再进行一些自定义的处理，就可以通过BeanPostProcessor接口实现。</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//作用是在Bean实例创建成功后对进行增强处理，如对Bean进行修改，增加某个功能</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> BeanPostProcessor &#123;</span><br><span class="line">    <span class="meta">@Nullable</span></span><br><span class="line">    <span class="keyword">default</span> <span class="built_in">Object</span> postProcessBeforeInitialization(<span class="built_in">Object</span> bean, <span class="built_in">String</span> beanName) throws BeansException &#123;</span><br><span class="line">        <span class="keyword">return</span> bean;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Nullable</span></span><br><span class="line">    <span class="keyword">default</span> <span class="built_in">Object</span> postProcessAfterInitialization(<span class="built_in">Object</span> bean, <span class="built_in">String</span> beanName) throws BeansException &#123;</span><br><span class="line">        <span class="keyword">return</span> bean;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>该接口提供了两个函数：</p><ul><li>postProcessBeforeInitialization(Object bean, String beanName)：当前正在初始化的bean对象会被传递进来，我们就可以对这个bean作任何处理。这个函数会先于InitialzationBean执行，因此称为前置处理。所有Aware接口的注入就是在这一步完成的。</li><li>postProcessAfterInitialization(Object bean, String beanName)：当前正在初始化的bean对象会被传递进来，我们就可以对这个bean作任何处理。这个函数会在InitialzationBean完成后执行，因此称为后置处理。</li></ul></blockquote><h3 id="3-7-InitializingBean与init-method"><a href="#3-7-InitializingBean与init-method" class="headerlink" title="3.7 InitializingBean与init-method"></a><strong>3.7 InitializingBean与init-method</strong></h3><p>&emsp;&emsp;当BeanPostProcessor的前置处理完成后就会进入本阶段，调用afterPropertiesSet()方法。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//作用与在配置文件中对Bean使用init-method声明初始化的作用一样，都是在Bean的全部属性设置成功后执行的初始化方法</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">InitializingBean</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">afterPropertiesSet</span><span class="params">()</span> <span class="keyword">throws</span> Exception</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>&emsp;&emsp;这一阶段也可以在bean正式构造完成前增加我们自定义的逻辑，但它与前置处理不同，由于该函数并不会把当前bean对象传进来，因此在这一步没办法处理对象本身，只能增加一些额外的逻辑。 </p><p>&emsp;&emsp;若要使用它，我们需要让bean实现该接口，并把要增加的逻辑写在该函数中。然后Spring会在前置处理完成后检测当前bean是否实现了该接口，并执行afterPropertiesSet函数。当然，Spring为了降低对客户代码的侵入性，给bean的配置提供了init-method属性，该属性指定了在这一阶段需要执行的函数名。Spring便会在初始化阶段执行我们设置的函数。init-method本质上仍然使用了InitializingBean接口。</p><h3 id="3-8-DisposableBean和destroy-method"><a href="#3-8-DisposableBean和destroy-method" class="headerlink" title="3.8 DisposableBean和destroy-method"></a><strong>3.8 DisposableBean和destroy-method</strong></h3><p>&emsp;&emsp;经过以上的工作后，Bean将一直驻留在应用上下文中给应用使用，直到应用上下文被销毁。</p><p>&emsp;&emsp;Bean可以实现DisposableBean接口，和init-method一样，通过给destroy-method指定函数，就可以在bean销毁前执行指定的逻辑。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//作用与在配置文件中对Bean使用destory-method属性的作用一样，都是在Bean实例销毁前执行的方法</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">DisposableBean</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">destroy</span><span class="params">()</span> <span class="keyword">throws</span> Exception</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><p><em>参考博客、文章或书籍：</em></p><blockquote><p><a href="https://www.awaimai.com/2596.html" title="Title" target="_blank" rel="noopener">spring bean是什么</a></p></blockquote><blockquote><p><a href="https://www.zhihu.com/question/38597960" title="Title" target="_blank" rel="noopener">Spring中Bean的生命周期是怎样的？</a></p></blockquote><p><em>因博客主未标明不可转载或引用，若内容涉及侵权请及时告知，我会尽快修改和删除相关内容</em></p>]]></content>
    
    <summary type="html">
    
      简单整理Spring Bean。
    
    </summary>
    
      <category term="技术文档" scheme="http://linyishui.top/categories/%E6%8A%80%E6%9C%AF%E6%96%87%E6%A1%A3/"/>
    
    
      <category term="spring" scheme="http://linyishui.top/tags/spring/"/>
    
  </entry>
  
  <entry>
    <title>gitlab-ci.yml语法</title>
    <link href="http://linyishui.top/2020020701.html"/>
    <id>http://linyishui.top/2020020701.html</id>
    <published>2020-02-07T06:31:33.000Z</published>
    <updated>2020-03-09T10:48:52.854Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="gitlab-ci"><a href="#gitlab-ci" class="headerlink" title="gitlab-ci"></a><strong>gitlab-ci</strong></h1><h2 id="第一节-简介"><a href="#第一节-简介" class="headerlink" title="第一节 简介"></a><strong>第一节 简介</strong></h2><p>&emsp;&emsp;自7.12版本开始，GitLab CI使用YAML文件来管理项目配置。此文件存放于项目仓库的根目录，定义了项目该如何构建。</p><blockquote><ul><li>Gitlab-CI ：<a href="https://docs.gitlab.com/ce/ci/quick_start/README.html" title="Title" target="_blank" rel="noopener">Gitlab-CI</a>是GitLab Continuous Integration（Gitlab持续集成）的简称。从Gitlab的8.0版本开始，gitlab就全面集成了Gitlab-CI，并且对所有项目默认开启。只要在项目仓库的根目录添加.gitlab-ci.yml文件，并且配置了Runner（运行器），那么每一次合并请求（MR）或者push都会触发CI pipeline。</li><li>Gitlab-runner ：<a href="https://docs.gitlab.com/ce/ci/runners/README.html" title="Title" target="_blank" rel="noopener">Gitlab-runner</a>是.gitlab-ci.yml脚本的运行器，Gitlab-runner是基于Gitlab-CI的API进行构建的相互隔离的机器（或虚拟机）。考虑到GitLab Runner的资源消耗问题和安全问题，GitLab Runner不建议和Gitlab安装在同一台机器上。Gitlab Runner分为两种，Shared runners和Specific runners。Specific runners只能被指定的项目使用，Shared runners则可以运行所有开启 Allow shared runners选项的项目。</li><li>Pipeline ：管道，每次commit或MR都会执行一次pipeline构建任务，包含多个阶段如测试、编译。</li><li>Stage ：阶段，每个Pipeline有多个Stage，从上向下执行，前一个执行成功才能执行下一个。</li><li>Job ：任务，CI/CD的最小运行单位，表示在指定Stage下执行的任务工作，可以有多个Job，并行执行。</li><li>Badges ：徽章，当Pipelines执行完成，会生成徽章，你可以将这些徽章加入到你的README.md文件或者你的网站。</li></ul></blockquote><hr><h2 id="第二节-案例"><a href="#第二节-案例" class="headerlink" title="第二节 案例"></a><strong>第二节 案例</strong></h2><p>&emsp;&emsp;如下面的两个任务由Runners接管，并由服务器中的runner执行，每个任务独立运行，script可以直接执行系统命令或脚本。</p><figure class="highlight dts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="symbol">job1:</span></span><br><span class="line"><span class="symbol">  script:</span> <span class="string">"execute-script-for-job1"</span></span><br><span class="line">  </span><br><span class="line"><span class="symbol">job2:</span></span><br><span class="line"><span class="symbol">  script:</span> <span class="string">"execute-script-for-job2"</span></span><br></pre></td></tr></table></figure><p>&emsp;&emsp;一个复杂任务如下。</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># image和services这两个关键字允许使用一个自定义的Docker镜像和一系列的服务，并且可以用于整个job周期。</span></span><br><span class="line"><span class="attr">image:</span> <span class="attr">ruby:2.1</span></span><br><span class="line"><span class="attr">services:</span></span><br><span class="line"><span class="bullet">  -</span> <span class="string">postgres</span></span><br><span class="line"><span class="string">​</span></span><br><span class="line"><span class="comment"># before_script用来定义所有job之前运行的命令，包括deploy(部署) jobs，但是在修复artifacts之后。它可以是一个数组或者是多行字符串。</span></span><br><span class="line"><span class="attr">before_script:</span></span><br><span class="line"><span class="bullet">  -</span> <span class="string">bundle</span> <span class="string">install</span></span><br><span class="line"><span class="string">​</span></span><br><span class="line"><span class="comment"># after_script用来定义所有job之后运行的命令。它必须是一个数组或者是多行字符串</span></span><br><span class="line"><span class="attr">after_script:</span></span><br><span class="line"><span class="bullet">  -</span> <span class="string">rm</span> <span class="string">secrets</span></span><br><span class="line"><span class="string">​</span></span><br><span class="line"><span class="comment"># stages用来定义可以被job调用的stages。stages的规范允许有灵活的多级pipelines。</span></span><br><span class="line"><span class="comment"># stages中的元素顺序决定了对应job的执行顺序：</span></span><br><span class="line"><span class="comment">#  1. 相同stage的job可以平行执行。</span></span><br><span class="line"><span class="comment">#  2. 下一个stage的job会在前一个stage的job成功后开始执行。</span></span><br><span class="line"><span class="attr">stages:</span></span><br><span class="line"><span class="bullet">  -</span> <span class="string">build</span></span><br><span class="line"><span class="bullet">  -</span> <span class="string">test</span></span><br><span class="line"><span class="bullet">  -</span> <span class="string">deploy</span></span><br><span class="line"><span class="comment"># 如果.gitlab-ci.yml中没有定义stages，那么job's stages 会默认定义为 build，test 和 deploy。</span></span><br><span class="line"><span class="comment"># 如果一个job没有指定stage，那么这个任务会分配到test stage。</span></span><br><span class="line"><span class="string">​</span></span><br><span class="line"><span class="comment"># GItLab CI 允许在.gitlab-ci.yml文件中添加变量，并在job环境中起作用。因为这些配置是存储在git仓库中，所以最好是存储项目的非敏感配置，例如： </span></span><br><span class="line"><span class="attr">variables:</span></span><br><span class="line"><span class="attr">  DATABASE_URL:</span><span class="string">"postgres://postgres@postgres/my_database"</span></span><br><span class="line"></span><br><span class="line"><span class="attr">job1:</span></span><br><span class="line"><span class="attr">  stage:</span> <span class="string">build</span></span><br><span class="line"><span class="attr">  script:</span></span><br><span class="line"><span class="bullet">    -</span> <span class="string">execute-script-for-job1</span></span><br><span class="line"><span class="attr">  only:</span></span><br><span class="line"><span class="bullet">    -</span> <span class="string">master</span></span><br><span class="line"><span class="attr">  tags:</span></span><br><span class="line"><span class="bullet">    -</span> <span class="string">docker</span></span><br></pre></td></tr></table></figure><p>&emsp;&emsp;下面列出保留字段，这些保留字段不能被定义为job名称：</p><table><thead><tr><th style="text-align:left">关键字</th><th style="text-align:center">是否必须</th><th style="text-align:left">描述</th></tr></thead><tbody><tr><td style="text-align:left">image</td><td style="text-align:center">否</td><td style="text-align:left">用于docker镜像，查看docker文档</td></tr><tr><td style="text-align:left">services</td><td style="text-align:center">否</td><td style="text-align:left">用于docker服务，查看docker文档</td></tr><tr><td style="text-align:left">stages</td><td style="text-align:center">否</td><td style="text-align:left">定义构建阶段</td></tr><tr><td style="text-align:left">types</td><td style="text-align:center">否</td><td style="text-align:left">stages 的别名(已废除)</td></tr><tr><td style="text-align:left">before_script</td><td style="text-align:center">否</td><td style="text-align:left">定义在每个job之前运行的命令</td></tr><tr><td style="text-align:left">after_script</td><td style="text-align:center">否</td><td style="text-align:left">定义在每个job之后运行的命令</td></tr><tr><td style="text-align:left">variable</td><td style="text-align:center">否</td><td style="text-align:left">定义构建变量</td></tr><tr><td style="text-align:left">cache</td><td style="text-align:center">否</td><td style="text-align:left">定义一组文件列表，可在后续运行中使用</td></tr></tbody></table><p>&emsp;&emsp;.gitlab-ci.yml的具体写法，以及关键字含义见： <a href="https://docs.gitlab.com/ee/ci/yaml/README.html" title="Title" target="_blank" rel="noopener">GitLab CI/CD Pipeline Configuration Reference</a></p><p>&emsp;&emsp;关于gitlab为什么使用.gitlab-ci.yml,见： <a href="https://about.gitlab.com/blog/2015/05/06/why-were-replacing-gitlab-ci-jobs-with-gitlab-ci-dot-yml/" title="Title" target="_blank" rel="noopener">Why we’re replacing GitLab CI jobs with .gitlab-ci.yml</a></p><hr><p><em>参考博客和文章书籍等：</em></p><blockquote><p><a href="https://fennay.github.io/gitlab-ci-cn/gitlab-ci-yaml.html" title="Title" target="_blank" rel="noopener">通过.gitlab-ci.yml配置任务</a></p></blockquote><blockquote><p><a href="https://docs.gitlab.com/ee/ci/examples/README.html#cicd-examples" title="Title" target="_blank" rel="noopener">CI/CD examples</a></p></blockquote><blockquote><p><a href="https://segmentfault.com/a/1190000011881435" title="Title" target="_blank" rel="noopener">gitlab-ci配置详解(一)</a></p></blockquote><p><em>因博客主等未标明不可引用，若部分内容涉及侵权请及时告知，我会尽快修改和删除相关内容</em></p>]]></content>
    
    <summary type="html">
    
      简单介绍GitLab-CI的配置文件gitlab-ci.yml的语法。
    
    </summary>
    
      <category term="技术文档" scheme="http://linyishui.top/categories/%E6%8A%80%E6%9C%AF%E6%96%87%E6%A1%A3/"/>
    
    
      <category term="git" scheme="http://linyishui.top/tags/git/"/>
    
      <category term="gitlab" scheme="http://linyishui.top/tags/gitlab/"/>
    
  </entry>
  
  <entry>
    <title>GitLab配置CI持续集成（未完成）</title>
    <link href="http://linyishui.top/2020020601.html"/>
    <id>http://linyishui.top/2020020601.html</id>
    <published>2020-02-06T06:09:42.000Z</published>
    <updated>2020-03-24T07:08:32.969Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="GitLab配置CI持续集成"><a href="#GitLab配置CI持续集成" class="headerlink" title="GitLab配置CI持续集成"></a><strong>GitLab配置CI持续集成</strong></h1><h2 id="第一节-简介"><a href="#第一节-简介" class="headerlink" title="第一节 简介"></a><strong>第一节 简介</strong></h2><h3 id="1-1-概念"><a href="#1-1-概念" class="headerlink" title="1.1 概念"></a><strong>1.1 概念</strong></h3><blockquote><ul><li>Gitlab-CI ：<a href="https://docs.gitlab.com/ce/ci/quick_start/README.html" title="Title" target="_blank" rel="noopener">Gitlab-CI</a>是GitLab Continuous Integration（Gitlab持续集成）的简称。从Gitlab的8.0版本开始，gitlab就全面集成了Gitlab-CI，并且对所有项目默认开启。只要在项目仓库的根目录添加.gitlab-ci.yml文件，并且配置了Runner（运行器），那么每一次合并请求（MR）或者push都会触发CI pipeline。</li><li>Gitlab-runner ：<a href="https://docs.gitlab.com/ce/ci/runners/README.html" title="Title" target="_blank" rel="noopener">Gitlab-runner</a>是.gitlab-ci.yml脚本的运行器，Gitlab-runner是基于Gitlab-CI的API进行构建的相互隔离的机器（或虚拟机）。考虑到GitLab Runner的资源消耗问题和安全问题，GitLab Runner不建议和Gitlab安装在同一台机器上。Gitlab Runner分为两种，Shared runners和Specific runners。Specific runners只能被指定的项目使用，Shared runners则可以运行所有开启 Allow shared runners选项的项目。</li><li>Pipeline ：管道，每次commit或MR都会执行一次pipeline构建任务，包含多个阶段如测试、编译。</li><li>Stage ：阶段，每个Pipeline有多个Stage，从上向下执行，前一个执行成功才能执行下一个。</li><li>Job ：任务，CI/CD的最小运行单位，表示在指定Stage下执行的任务工作，可以有多个Job，并行执行。</li><li>Badges ：徽章，当Pipelines执行完成，会生成徽章，你可以将这些徽章加入到你的README.md文件或者你的网站。</li></ul></blockquote><h3 id="1-2-特性"><a href="#1-2-特性" class="headerlink" title="1.2 特性"></a><strong>1.2 特性</strong></h3><blockquote><p>gitlab ci/cd具有以下特性：</p><ul><li>跨平台支持：只要支持go语言的平台均可以在上面进行ci,目前基本涵盖了大部分的操作系统．</li><li>多语言支持：构建时是通过脚本触发，因此基本上支持所有的语言．</li><li>Pipeline：可以通过不同的阶段形成工作流</li><li>支持docker：可以构建docker镜像，同时也支持触发在Kubernetes允许．</li></ul></blockquote><p>&emsp;&emsp;所有特性：<a href="https://about.gitlab.com/stages-devops-lifecycle/continuous-integration/" title="Title" target="_blank" rel="noopener">GitLab Continuous Integration (CI) &amp; Continuous Delivery (CD)</a></p><h3 id="1-3-结构"><a href="#1-3-结构" class="headerlink" title="1.3 结构"></a><strong>1.3 结构</strong></h3><p><img src="https://pic-1258215793.cos.ap-shanghai.myqcloud.com/content/20200201/202002010103.png" alt="CI/CD架构"></p><p>&emsp;&emsp;gitlab ci/cd是由独立的runner程序完成，runner采用go语言编写，因此可以很好的进行跨平台，通常可以将runner部署到任何gitlab server之外的服务器，从而避免对gitlab server的影响．</p><p>&emsp;&emsp;runner项目：<a href="https://gitlab.com/gitlab-org/gitlab-runner" title="Title" target="_blank" rel="noopener">gitlab-runner</a></p><h2 id="第二节-案例"><a href="#第二节-案例" class="headerlink" title="第二节 案例"></a><strong>第二节 案例</strong></h2><h3 id="2-1-新建一个Spring-Boot项目"><a href="#2-1-新建一个Spring-Boot项目" class="headerlink" title="2.1 新建一个Spring Boot项目"></a><strong>2.1 新建一个Spring Boot项目</strong></h3><p>&emsp;&emsp;新建项目，添加一些demo代码，运行测试。</p><h3 id="2-2-新建GitLab项目"><a href="#2-2-新建GitLab项目" class="headerlink" title="2.2 新建GitLab项目"></a><strong>2.2 新建GitLab项目</strong></h3><p>&emsp;&emsp;登陆GitLab创建项目，并复制URL。</p><p>&emsp;&emsp;提交项目代码到对应URL。</p><h3 id="2-3-添加-gitlab-ci文件"><a href="#2-3-添加-gitlab-ci文件" class="headerlink" title="2.3 添加.gitlab-ci文件"></a><strong>2.3 添加.gitlab-ci文件</strong></h3><p>&emsp;&emsp;创建.gitlab-ci.yml，【.gitlab-ci.yml】用来配置 CI 用你的项目中做哪些操作。当有新内容push到仓库后，GitLab会查找是否有.gitlab-ci.yml文件，如果文件存在，Runners将会根据该文件的内容开始 build 本次 commit。</p><p>&emsp;&emsp;gitlab通过在项目的根目录放置.gitlab-ci.yml文件来触发pipline，文件书写遵循yml语法，因此，概括来说gitlab ci/cd只需要两步。</p><blockquote><ul><li>写好.gitlab-ci.yml文件，并放置到项目根目录</li><li>配置好gitlab runner．完成后，提交代码时会自动根据gitlab-ci.yml的触发条件进行执行相应的stage.</li></ul></blockquote><p>&emsp;&emsp;如下简单的.gitlab-ci.yml - maven项目，更多案例可以参考官网<a href="https://docs.gitlab.com/ee/ci/examples/README.html#cicd-examples" title="Title" target="_blank" rel="noopener">CI/CD examples</a>。</p><figure class="highlight less"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="attribute">image</span>: <span class="attribute">docker</span>:latest</span><br><span class="line"><span class="attribute">services</span>:</span><br><span class="line">  - <span class="attribute">docker</span>:dind</span><br><span class="line"></span><br><span class="line"><span class="attribute">stages</span>:</span><br><span class="line">  - build</span><br><span class="line">  - package</span><br><span class="line">  - deploy</span><br><span class="line"></span><br><span class="line"><span class="attribute">maven-build</span>:</span><br><span class="line">  <span class="attribute">image</span>: <span class="attribute">maven</span>:<span class="number">3</span>-jdk-<span class="number">8</span></span><br><span class="line">  <span class="attribute">stage</span>: build</span><br><span class="line">  <span class="attribute">script</span>: <span class="string">"mvn package"</span></span><br></pre></td></tr></table></figure><p>&emsp;&emsp;配置好.gitlab-ci.yml文件之后，只要把它加入git后然后推送到远程仓库，CI就会开始自动化集成</p><h3 id="2-4-配置一个Runner"><a href="#2-4-配置一个Runner" class="headerlink" title="2.4 配置一个Runner"></a><strong>2.4 配置一个Runner</strong></h3><p>&emsp;&emsp;runner配置主要分为三步:</p><blockquote><ul><li>首先安装runner安装脚本，具体见：<a href="https://docs.gitlab.com/runner/#install-gitlab-runner" title="Title" target="_blank" rel="noopener">Install GitLab Runner</a></li><li>然后注册runner到gitlab：<a href="https://docs.gitlab.com/runner/#register-gitlab-runner" title="Title" target="_blank" rel="noopener">Register GitLab Runner</a></li><li>更多配置见：<a href="https://docs.gitlab.com/runner/executors/README.html" title="Title" target="_blank" rel="noopener">Executors</a></li></ul></blockquote><p>&emsp;&emsp;登陆服务器安装gitlab-ci-multi-runner，笔者是一台Centos服务器。</p><blockquote><p>考虑到GitLab Runner的资源消耗问题和安全问题，GitLab Runner不建议和Gitlab安装在同一台机器上，但笔者因为只有一台服务器所以先布置在一起了。</p></blockquote><ol><li>添加repository</li></ol><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">curl -L https:<span class="regexp">//</span>packages.gitlab.com<span class="regexp">/install/</span>repositories<span class="regexp">/runner/gi</span>tlab-ci-multi-runner<span class="regexp">/script.rpm.sh | sudo bash</span></span><br></pre></td></tr></table></figure><ol start="2"><li>安装包</li></ol><figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">yum <span class="keyword">install</span> gitlab-runner</span><br></pre></td></tr></table></figure><ol start="3"><li>注册runner</li></ol><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo gitlab-runner <span class="keyword">register</span></span><br></pre></td></tr></table></figure><blockquote><p>注册共享的Runner需要gitlab的admin权限</p><ol><li>输入Gitlab CI地址</li><li>输入项目CI token</li><li>输入 Runner 描述</li><li>输入 Runner 标签，可以多个，用逗号隔开</li><li>输入 Runner 执行的语言 (e.g. shell)</li></ol></blockquote><p><img src="https://pic-1258215793.cos.ap-shanghai.myqcloud.com/content/20200201/202002010105.png" alt="CI/CD"></p><p>&emsp;&emsp;相关数据值可以在登录gitlab之后，下图所示位置找到，先点击右上方Admin Settings，再找到左侧列表的runners</p><p><img src="https://pic-1258215793.cos.ap-shanghai.myqcloud.com/content/20200201/202002010104.png" alt="CI/CD"></p><p>&emsp;&emsp;注册完成之后，GitLab-CI立刻就会多出一条Runner记录，启动runner，点击为Project启用Runner</p><figure class="highlight mipsasm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">gitlab-ci-<span class="keyword">multi-runner </span><span class="keyword">install</span></span><br><span class="line"><span class="keyword">gitlab-ci-multi-runner </span>start</span><br></pre></td></tr></table></figure><h2 id="2-5-提交代码"><a href="#2-5-提交代码" class="headerlink" title="2.5 提交代码"></a><strong>2.5 提交代码</strong></h2><p>&emsp;&emsp;推送到服务器后，pipeline一直处于struck状态，提示：This job is stuck, because the project doesn’t have any runners online assigned to it. Go to Runners page.</p><p>&emsp;&emsp;检查一下确认Runner处于正常状态。</p><p>&emsp;&emsp;出现这种情况可能是因为我们注册的Runner设置了TAG，但Job并没有。所以要按照以下4个步骤使我们的Runner能够在没有标记的情况下执行：</p><p><img src="https://pic-1258215793.cos.ap-shanghai.myqcloud.com/content/20200201/202002010108.png" alt="CI/CD"></p><p><img src="https://pic-1258215793.cos.ap-shanghai.myqcloud.com/content/20200201/202002010109.png" alt="CI/CD"></p><p>&emsp;&emsp;配置后Job成功运行，但是检查失败了，如下图所示。</p><p><img src="https://pic-1258215793.cos.ap-shanghai.myqcloud.com/content/20200201/202002010107.png" alt="CI/CD"></p><p>&emsp;&emsp;很明显是因为服务器缺失Maven工具，登陆服务器，安装Maven。</p><figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo yum <span class="keyword">install</span> maven</span><br></pre></td></tr></table></figure><p>&emsp;&emsp;再次提交，问题解决，maven开始下载依赖。</p><p><img src="https://pic-1258215793.cos.ap-shanghai.myqcloud.com/content/20200201/202002010110.png" alt="CI/CD"></p><p>&emsp;&emsp;执行成功。</p><p><img src="https://pic-1258215793.cos.ap-shanghai.myqcloud.com/content/20200201/202002010111.png" alt="CI/CD"></p><h2 id="2-6-扩展"><a href="#2-6-扩展" class="headerlink" title="2.6 扩展"></a><strong>2.6 扩展</strong></h2><p>&emsp;&emsp;未完待续</p><hr><p><em>参考博客和文章书籍等：</em></p><blockquote><p><a href="https://www.jianshu.com/p/705428ca1410" title="Title" target="_blank" rel="noopener">基于Gitlab CI搭建持续集成环境</a></p></blockquote><blockquote><p><a href="https://docs.gitlab.com/ee/ci/examples/deploy_spring_boot_to_cloud_foundry/index.html" title="Title" target="_blank" rel="noopener">Deploy a Spring Boot application to Cloud Foundry with GitLab CI/CD</a></p></blockquote><blockquote><p><a href="https://about.gitlab.com/blog/2016/12/14/continuous-delivery-of-a-spring-boot-application-with-gitlab-ci-and-kubernetes/" title="Title" target="_blank" rel="noopener">Continuous delivery of a Spring Boot application with GitLab CI and Kubernetes</a></p></blockquote><blockquote><p><a href="https://medium.com/@deeksha.sharma25/spring-boot-micro-service-with-gitlab-ci-281c6679b3f8" title="Title" target="_blank" rel="noopener">Spring Boot Micro Service with gitlab CI</a></p></blockquote><blockquote><p><a href="https://segmentfault.com/a/1190000007180257" title="Title" target="_blank" rel="noopener">GitLab-CI安装</a></p></blockquote><p><em>因博客主等未标明不可引用，若部分内容涉及侵权请及时告知，我会尽快修改和删除相关内容</em></p>]]></content>
    
    <summary type="html">
    
      简单整理GitLab简单配置CI流程，内容包括：简介，案例等。
    
    </summary>
    
      <category term="技术文档" scheme="http://linyishui.top/categories/%E6%8A%80%E6%9C%AF%E6%96%87%E6%A1%A3/"/>
    
    
      <category term="git" scheme="http://linyishui.top/tags/git/"/>
    
      <category term="unfinished" scheme="http://linyishui.top/tags/unfinished/"/>
    
      <category term="gitlab" scheme="http://linyishui.top/tags/gitlab/"/>
    
  </entry>
  
  <entry>
    <title>CI/CD-持续集成和持续交付 &lt;整&gt;</title>
    <link href="http://linyishui.top/2020020501.html"/>
    <id>http://linyishui.top/2020020501.html</id>
    <published>2020-02-05T09:15:24.000Z</published>
    <updated>2020-03-06T11:02:50.130Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="CI-CD"><a href="#CI-CD" class="headerlink" title="CI/CD"></a><strong>CI/CD</strong></h1><h2 id="第一节-介绍"><a href="#第一节-介绍" class="headerlink" title="第一节 介绍"></a><strong>第一节 介绍</strong></h2><p>&emsp;&emsp;CI/CD 是一种通过在应用开发阶段引入自动化来频繁向客户交付应用的方法。CI/CD 的核心概念是<strong>持续集成</strong>、<strong>持续交付</strong>和<strong>持续部署</strong>。作为一个面向开发和运营团队的解决方案，CI/CD 主要针对在集成新代码时所引发的问题（亦称：“集成地狱”）。</p><p>&emsp;&emsp;具体而言，CI/CD 可让持续自动化和持续监控贯穿于应用的整个生命周期（从集成和测试阶段，到交付和部署）。这些关联的事务通常被统称为“CI/CD 管道”，由开发和运维团队以敏捷方式协同支持。</p><hr><h2 id="第二节-CI-是什么？CI-和-CD-有什么区别？"><a href="#第二节-CI-是什么？CI-和-CD-有什么区别？" class="headerlink" title="第二节 CI 是什么？CI 和 CD 有什么区别？"></a><strong>第二节 CI 是什么？CI 和 CD 有什么区别？</strong></h2><p>&emsp;&emsp;“CI”始终指<strong>持续集成</strong>，它<strong>属于开发人员的自动化流程</strong>。成功的 CI 意味着应用代码的新更改会定期构建、测试并合并到共享存储库中。该解决方案可以解决在一次开发中有太多应用分支，从而导致相互冲突的问题。</p><p>&emsp;&emsp;“CD”指的是<strong>持续交付</strong>和/或<strong>持续部署</strong>，这些相关概念有时会交叉使用。两者都事关管道后续阶段的自动化，但它们有时也会单独使用，用于说明自动化程度。</p><p>&emsp;&emsp;持续交付通常是<strong>指开发人员对应用的更改会自动进行错误测试并上传到存储库</strong>（如 GitHub 或容器注册表），<strong>然后由运维团队将其部署到实时生产环境中</strong>。这旨在解决开发和运维团队之间可见性及沟通较差的问题。因此，持续交付的目的就是<strong>确保尽可能减少部署新代码时所需的工作量</strong>。</p><p>&emsp;&emsp;持续部署（另一种“CD”）指的是<strong>自动将开发人员的更改从存储库发布到生产环境，以供客户使用</strong>。它主要为了<strong>解决因手动流程降低应用交付速度，从而使运维团队超负荷的问题</strong>。持续部署以持续交付的优势为根基，实现了管道后续阶段的自动化。</p><p><img src="https://pic-1258215793.cos.ap-shanghai.myqcloud.com/content/20200201/202002010102.png" alt="CI/CD"></p><p>&emsp;&emsp;CI/CD 既可能仅指持续集成和持续交付构成的关联环节，也可以指持续集成、持续交付和持续部署这三项构成的关联环节。更为复杂的是，有时“持续交付”也包含了持续部署流程。</p><p>&emsp;&emsp;归根结底，我们没必要纠结于这些语义，您只需记得 CI/CD 其实就是一个流程（通常形象地表述为<strong>管道</strong>），用于实现应用开发中的高度持续自动化和持续监控。因案例而异，该术语的具体含义取决于 CI/CD 管道的自动化程度。许多企业最开始先添加 CI，然后逐步实现交付和部署的自动化（例如作为云原生应用的一部分）。</p><hr><h2 id="第三节-CI-持续集成（Continuous-Integration）"><a href="#第三节-CI-持续集成（Continuous-Integration）" class="headerlink" title="第三节 CI 持续集成（Continuous Integration）"></a><strong>第三节 CI 持续集成（Continuous Integration）</strong></h2><p>&emsp;&emsp;现代应用开发的目标是让多位开发人员同时处理同一应用的不同功能。但是，如果企业安排在一天内将所有分支源代码合并在一起（称为“合并日”），最终可能造成工作繁琐、耗时，而且需要手动完成。这是因为当一位独立工作的开发人员对应用进行更改时，有可能会与其他开发人员同时进行的更改发生冲突。如果每个开发人员都自定义自己的本地集成开发环境（IDE），而不是让团队就一个基于云的 IDE 达成一致，那么就会让问题更加雪上加霜。</p><p>&emsp;&emsp;持续集成（CI）可以帮助开发人员更加频繁地（有时甚至每天）将代码更改合并到共享分支或“主干”中。一旦开发人员对应用所做的更改被合并，系统就会通过自动构建应用并运行不同级别的自动化测试（通常是单元测试和集成测试）来验证这些更改，确保这些更改没有对应用造成破坏。这意味着测试内容涵盖了从类和函数到构成整个应用的不同模块。如果自动化测试发现新代码和现有代码之间存在冲突，CI 可以更加轻松地快速修复这些错误。</p><hr><h2 id="第四节-CD-持续交付（Continuous-Delivery）"><a href="#第四节-CD-持续交付（Continuous-Delivery）" class="headerlink" title="第四节 CD 持续交付（Continuous Delivery）"></a><strong>第四节 CD 持续交付（Continuous Delivery）</strong></h2><p>&emsp;&emsp;完成 CI 中构建及单元测试和集成测试的自动化流程后，持续交付可自动将已验证的代码发布到存储库。为了实现高效的持续交付流程，务必要确保 CI 已内置于开发管道。持续交付的目标是拥有一个可随时部署到生产环境的代码库。</p><p>&emsp;&emsp;在持续交付中，每个阶段（从代码更改的合并，到生产就绪型构建版本的交付）都涉及测试自动化和代码发布自动化。在流程结束时，运维团队可以快速、轻松地将应用部署到生产环境中。</p><hr><h2 id="第五节-CD-持续部署（Continuous-Deployment）"><a href="#第五节-CD-持续部署（Continuous-Deployment）" class="headerlink" title="第五节 CD 持续部署（Continuous Deployment）"></a><strong>第五节 CD 持续部署（Continuous Deployment）</strong></h2><p>&emsp;&emsp;对于一个成熟的 CI/CD 管道来说，最后的阶段是持续部署。作为持续交付——自动将生产就绪型构建版本发布到代码存储库——的延伸，持续部署可以自动将应用发布到生产环境。由于在生产之前的管道阶段没有手动门控，因此持续部署在很大程度上都得依赖精心设计的测试自动化。</p><p>&emsp;&emsp;实际上，持续部署意味着开发人员对应用的更改在编写后的几分钟内就能生效（假设它通过了自动化测试）。这更加便于持续接收和整合用户反馈。总而言之，所有这些 CI/CD 的关联步骤都有助于降低应用的部署风险，因此更便于以小件的方式（而非一次性）发布对应用的更改。不过，由于还需要编写自动化测试以适应 CI/CD 管道中的各种测试和发布阶段，因此前期投资还是会很大。</p><hr><p><em>参考博客和文章书籍等：</em></p><blockquote><p><a href="https://www.redhat.com/zh/topics/devops/what-is-ci-cd" title="Title" target="_blank" rel="noopener">CI/CD是什么？如何理解持续集成、持续交付和持续部署</a></p></blockquote><p><em>因博客主等未标明不可引用，若部分内容涉及侵权请及时告知，我会尽快修改和删除相关内容</em></p>]]></content>
    
    <summary type="html">
    
      简单介绍什么是CI/CD？持续集成、持续交付和持续部署的意义
    
    </summary>
    
      <category term="技术文档" scheme="http://linyishui.top/categories/%E6%8A%80%E6%9C%AF%E6%96%87%E6%A1%A3/"/>
    
    
      <category term="git" scheme="http://linyishui.top/tags/git/"/>
    
  </entry>
  
  <entry>
    <title>KeePass</title>
    <link href="http://linyishui.top/2020020401.html"/>
    <id>http://linyishui.top/2020020401.html</id>
    <published>2020-02-04T05:36:11.000Z</published>
    <updated>2020-03-05T08:22:39.641Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="KeePass"><a href="#KeePass" class="headerlink" title="KeePass"></a><strong>KeePass</strong></h1><h2 id="第一节-简介"><a href="#第一节-简介" class="headerlink" title="第一节 简介"></a><strong>第一节 简介</strong></h2><p>&emsp;&emsp;一款免费、开源、轻量级、易用的密码管理器，<a href="https://keepass.info/" title="Title" target="_blank" rel="noopener">KeePass官网</a>。</p><hr><h2 id="第二节-安装"><a href="#第二节-安装" class="headerlink" title="第二节 安装"></a><strong>第二节 安装</strong></h2><p>&emsp;&emsp;从<a href="https://keepass.info/" title="Title" target="_blank" rel="noopener">KeePass官网</a>下载合适版本的软件。</p><p>&emsp;&emsp;或者直接从<a href="https://sourceforge.net/projects/keepass/files/" title="Title" target="_blank" rel="noopener">SourceForge-KeePass</a>，下载对应软件，以及中文语言包。</p><h3 id="2-1-更改语言"><a href="#2-1-更改语言" class="headerlink" title="2.1 更改语言"></a><strong>2.1 更改语言</strong></h3><ol><li>安装并运行keepass（安装时默认英文，无中文可选）；</li><li>点击主界面中的【View】→【Change Language】；</li><li>点击【Open Folder】打开keepass的语言安装文件夹；</li><li>解压下载的中文语言zip包，将解压后的文件复制并粘贴到步骤3打开的文件夹中；</li><li>重复步骤2，选择【Chinese_Simplified】，点击弹出框中的【是】重启keepass。</li></ol><h3 id="2-2-安装插件"><a href="#2-2-安装插件" class="headerlink" title="2.2 安装插件"></a><strong>2.2 安装插件</strong></h3><ol><li>在keepaass主界面中点击【工具】→【插件管理器】→【打开文件夹】；</li><li>将下载的后缀为.plgx的文件复制并粘贴到步骤1打开的的文件夹中（zip包请先解压）；</li><li>关闭然后重新打开keepass。</li><li>（度盘下载的chromeIPass插件安装方法：点击chrome浏览器右上角的三个点→【更多工具】→【扩展程序】，在打开标签页的右上角启用开发者模式→将下载的crx文件拖动到此标签页）</li></ol><h3 id="2-3-数据库同步和加密方式"><a href="#2-3-数据库同步和加密方式" class="headerlink" title="2.3 数据库同步和加密方式"></a><strong>2.3 数据库同步和加密方式</strong></h3><p>&emsp;&emsp;如果你在使用Windows10，建议将keepass数据库直接存储在OneDrive文件夹中。因为OneDrive已经集成到了Windows文件资源管理器中，而且OneDrive网页版可查看文件版本历史记录和回收站，即使操作失误或误删文件也有补救的余地。</p><p>&emsp;&emsp;在创建数据库时keepass提供了3种可任意组合的加密方式：【管理密码】【密钥文件/提供器】和【Windows 用户账户】，也就是说一共可以组合出8种不同的加密方式。追求更高安全性可以了解一下OtpKeyProv：每次打开数据库需要输入至少3个一次性的6位数安全码，但是必须要有一个YubiKey硬件或一台装有Google身份验证器的备用手机，而且这种加密方式的容错率和安全性有所冲突。所以综合安全性，易用性，跨平台等多方面因素，建议使用【管理密码】+【密钥文件/提供器】的加密方式。其中【密钥文件/提供器】可使用任意类型文件（图片，文档，音频，视频等），它的工作原理是使用SHA-256对密钥文件进行哈希处理并将生成的32个字节用作密钥，因此请妥善保存密钥文件，不要随意修改（重命名无影响）。你可以使用一张家人的照片，一首喜欢的歌或一段不可描述的视频作为密钥文件，谁又能猜得到呢？（使用100mb以上的文件作为密钥文件会明显影响解锁速度）</p><p>&emsp;&emsp;为使你的主密码更安全，请在keepass的【选项】→【安全】中勾选【在安全桌面输入管理密码】，因为几乎没有键盘记录软件能在安全桌面工作。</p><h3 id="2-4-移动APP"><a href="#2-4-移动APP" class="headerlink" title="2.4 移动APP"></a><strong>2.4 移动APP</strong></h3><p>&emsp;&emsp;安卓端，在Google Play商店搜索Keepass2Android，可以下载使用。</p><hr><h2 id="第三节-使用"><a href="#第三节-使用" class="headerlink" title="第三节 使用"></a><strong>第三节 使用</strong></h2><p>&emsp;&emsp;省略。</p><hr><p><em>参考博客和文章书籍等：</em></p><blockquote><p><a href="https://zhuanlan.zhihu.com/p/39645975" title="Title" target="_blank" rel="noopener">一劳永逸：KeePass全网最详使用指南</a></p></blockquote><p><em>因博客主等未标明不可引用，若部分内容涉及侵权请及时告知，我会尽快修改和删除相关内容</em></p>]]></content>
    
    <summary type="html">
    
      简单整理密码管理工具KeePass的使用。
    
    </summary>
    
      <category term="实用工具" scheme="http://linyishui.top/categories/%E5%AE%9E%E7%94%A8%E5%B7%A5%E5%85%B7/"/>
    
    
      <category term="KeePass" scheme="http://linyishui.top/tags/KeePass/"/>
    
  </entry>
  
</feed>
