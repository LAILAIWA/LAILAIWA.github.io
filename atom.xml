<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>沂水博客</title>
  
  <subtitle>编程和心历记录</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://linyishui.top/"/>
  <updated>2019-11-05T09:42:50.241Z</updated>
  <id>http://linyishui.top/</id>
  
  <author>
    <name>沂水</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>垃圾收集器（三）内存分配与回收策略</title>
    <link href="http://linyishui.top/2019091301.html"/>
    <id>http://linyishui.top/2019091301.html</id>
    <published>2019-09-13T09:38:40.000Z</published>
    <updated>2019-11-05T09:42:50.241Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h2 id="第五节-内存分配与回收策略"><a href="#第五节-内存分配与回收策略" class="headerlink" title="第五节 内存分配与回收策略"></a><strong>第五节 内存分配与回收策略</strong></h2><h3 id="5-1-对象优先在Eden分配"><a href="#5-1-对象优先在Eden分配" class="headerlink" title="5.1 对象优先在Eden分配"></a><strong>5.1 对象优先在Eden分配</strong></h3><p>&emsp;&emsp;</p><hr><h3 id="5-2-大对象直接进入老年代"><a href="#5-2-大对象直接进入老年代" class="headerlink" title="5.2 大对象直接进入老年代"></a><strong>5.2 大对象直接进入老年代</strong></h3><p>&emsp;&emsp;</p><hr><h3 id="5-3-长期存活的对象将进入老年代"><a href="#5-3-长期存活的对象将进入老年代" class="headerlink" title="5.3 长期存活的对象将进入老年代"></a><strong>5.3 长期存活的对象将进入老年代</strong></h3><p>&emsp;&emsp;</p><hr><h3 id="5-4-动态对象年龄判定"><a href="#5-4-动态对象年龄判定" class="headerlink" title="5.4 动态对象年龄判定"></a><strong>5.4 动态对象年龄判定</strong></h3><p>&emsp;&emsp;</p><hr><h3 id="5-5-空间分配担保"><a href="#5-5-空间分配担保" class="headerlink" title="5.5 空间分配担保"></a><strong>5.5 空间分配担保</strong></h3><p>&emsp;&emsp;</p><hr><p><em>参考博客和文章书籍等：</em></p><blockquote><p>《深入理解Java虚拟机》</p></blockquote><p><em>因博客主等未标明不可引用，若部分内容涉及侵权请及时告知，我会尽快修改和删除相关内容</em></p>]]></content>
    
    <summary type="html">
    
      简单介绍Java虚拟机中的垃圾收集器，包括：对象优先在Eden分配，大对象直接进入老年代，长期存活的对象将进入老年代，动态对象年龄判定，空间分配担保等。
    
    </summary>
    
      <category term="技术文档" scheme="http://linyishui.top/categories/%E6%8A%80%E6%9C%AF%E6%96%87%E6%A1%A3/"/>
    
    
      <category term="java" scheme="http://linyishui.top/tags/java/"/>
    
      <category term="jvm" scheme="http://linyishui.top/tags/jvm/"/>
    
  </entry>
  
  <entry>
    <title>垃圾收集器（二）垃圾收集算法</title>
    <link href="http://linyishui.top/2019091201.html"/>
    <id>http://linyishui.top/2019091201.html</id>
    <published>2019-09-12T09:26:28.000Z</published>
    <updated>2019-11-07T10:37:27.758Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h2 id="第二节-垃圾收集算法"><a href="#第二节-垃圾收集算法" class="headerlink" title="第二节 垃圾收集算法"></a><strong>第二节 垃圾收集算法</strong></h2><h3 id="2-1-标记-清除算法"><a href="#2-1-标记-清除算法" class="headerlink" title="2.1 标记-清除算法"></a><strong>2.1 标记-清除算法</strong></h3><p>&emsp;&emsp;<strong>最基础</strong>的收集算法是“标记-清除”算法(Mark-Sweep)算法，算法分为“标记”和“清除”两个阶段：首先标记出所有需要回收的对象，在标记完成后统一回收所有被标记的对象，它的标记过程其实在前一节讲述对象标记判定时已经介绍过了。最基础是因为后续的收集算法都是基于此思路改进而来。主要有两点不足：一是效率问题，标记和清除过程都不高效；另一个是空间问题，标记和清除之后会产生大量不连续的内存碎片，会导致以后在程序需要分配较大对象时，无法找到足够的连续内存而不得不提前触发另一次垃圾收集动作。</p><p><img src="https://pic-1258215793.cos.ap-shanghai.myqcloud.com/content/20190801/201908010114.png" alt="“标记-清除”算法示意图"></p><hr><h3 id="2-2-复制算法"><a href="#2-2-复制算法" class="headerlink" title="2.2 复制算法"></a><strong>2.2 复制算法</strong></h3><p>&emsp;&emsp;复制算法是为了解决效率问题而设计，将可用内存按容量划分为大小相等的两块，每次只使用其中的一块。当这块的内存用完了，就将还存活的对象复制到另一块上，然后将已使用过的内存空间一次清理掉。这样的做法使每次都是对整个半区进行内存回收，内存分配时就不用考虑到内存碎片等复杂情况，只要移动堆顶指针，按顺序分配内存即可，实现简单，运行高效。但此算法的代价是会将内存空间缩小一半，代价实在太高。</p><p><img src="https://pic-1258215793.cos.ap-shanghai.myqcloud.com/content/20190801/201908010115.png" alt="复制算法示意图"></p><p>&emsp;&emsp;<strong>当前的商业虚拟机都采用此算法来回收新生代</strong>，IBM研究表示新生代中对象98%都是“朝生夕死”，所以不需要对半划分内存空间，而是划分为一块大的Eden空间和两块较小的Survivor空间。每次使用Eden和其中一块Survivor。当回收时，将Eden和Survivor中还存活着的对象一次性的复制到另外一块Survivor空间上，最后清理掉Eden和用过的Survivor空间。(HotSpot默认Eden和Survivor空间大小比例为8:1，即每次新生代可用内存空间为整体的90%)。当Survivor空间不够用时，需要依赖其他内存(老年代)进行<strong>分配担保</strong>(Handle Promotion)。</p><p>&emsp;&emsp;分配担保类似于银行的担保人，如果一块Survivor空间没有足够的空间存放上次新生代收集下的存活对象，可以通过分配担保机制进入老年代，只要新生代有很好的“信誉”。具体实现此处不作详细描述。</p><hr><h3 id="2-3-标记-整理算法"><a href="#2-3-标记-整理算法" class="headerlink" title="2.3 标记-整理算法"></a><strong>2.3 标记-整理算法</strong></h3><p>&emsp;&emsp;复制算法在对象存活率较高时需要进行较多的复制操作，会降低其运行效率。还有就是如果预留空间较小就需要额外的空间进行分配担保，以应对对象存活率极高的情况，所以老年代不会选用复制算法。</p><p>&emsp;&emsp;根据老年代的特点，有了标记-整理算法，标记过程等同于标记-清除算法，但后续步骤不是直接对可回收对象进行清理，而是让所有存活对象都向一端移动，然后直接清理掉端边界以外的内存。</p><p><img src="https://pic-1258215793.cos.ap-shanghai.myqcloud.com/content/20190801/201908010116.png" alt="“标记-整理”算法示意图"></p><hr><h3 id="2-4-分代收集算法"><a href="#2-4-分代收集算法" class="headerlink" title="2.4 分代收集算法"></a><strong>2.4 分代收集算法</strong></h3><p>&emsp;&emsp;<strong>当前的商业虚拟机的垃圾收集都采用分代收集算法</strong>，就是根据对象的存活周期的不同将内存划分为几块。一般把Java堆划分为新生代和老年代，可以根据各个代的特点采用最适合的收集算法。新生代中，每次垃圾收集会有大量对象被清理，仅有少量存活，就采用复制算法；老年代中对象存活率较高，没有额外的内存空间作分配担保，就采用标记-清除算法或标记-整理算法。</p><hr><h2 id="第三节-HotSpot算法实现"><a href="#第三节-HotSpot算法实现" class="headerlink" title="第三节 HotSpot算法实现"></a><strong>第三节 HotSpot算法实现</strong></h2><h3 id="3-1-枚举根节点"><a href="#3-1-枚举根节点" class="headerlink" title="3.1 枚举根节点"></a><strong>3.1 枚举根节点</strong></h3><p>&emsp;&emsp;可达性分析中从GC Roots节点找引用链这个操作为例，可以作为GC Roots的节点主要在<strong>全局性的引用</strong>(如常量或类静态属性)与<strong>执行上下文</strong>(如栈帧中的本地变量表)中，有些应用仅方法区就有数百兆，逐个检查这里面的引用是不现实的。</p><p>&emsp;&emsp;可达性分析中的GC停顿用来确保分析工作在一个保证一致性的“快照”中进行。在整个分析期间整个执行系统看起来就像被冻结在某个时间点上，不能在分析过程中对象关系还在不断地变化，不能满足这一点就无法保证最终分析结果的准确性。这就是GC进行时必须停顿所有Java执行线程的其中一个原因，即使CMS收集器号称不会发生停顿，枚举根节点时也必须停顿。</p><p>&emsp;&emsp;主流的Java虚拟机都是<strong>准确式GC</strong>(虚拟机可以知道内存中某个位置的数据类型具体是什么类型，如内存中有一个32位整数123456，虚拟机可以得知其是一个reference类型指向123456内存地址或者是一个数值为123456的整数，这样虚拟机才能在GC时判断堆上的数据是否还能被使用)。所以当执行系统停顿下来，并不需要一个不漏的检查完所有<strong>执行上下文</strong>和<strong>全局的引用设置</strong>，虚拟机有办法知道哪些地方存放着对象引用。在HotSpot的实现中，是通过一组被称为<strong>OopMap</strong>的数据结构来达到此目的，在<strong>类加载完成</strong>时，HotSpot就把对象内什么偏移量上是什么类型的数据计算出来，在<strong>JIT编译过程</strong>中，也会在特定的位置记录下栈和寄存器中哪些位置是引用。所以GC在扫描时就可以直接得知这些信息了。</p><p>&emsp;&emsp;下列代码是HotSpot Client VM生成的一段String.hashCode()方法的本地代码，可以看到在0x026eb7a9处的call指令有OopMap记录，它指明了EBX寄存器和栈中偏移量为16的内存区域中各有一个<strong>普通对象指针</strong>的引用，有效范围从call指令开始直到0x026eb730（指令流的起始位置）+142（OopMap记录的偏移量）=0x026eb7be，即hlt指令为止。</p><figure class="highlight x86asm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">[Verified Entry Point]</span><br><span class="line"><span class="number">0x026eb730</span>: <span class="keyword">mov</span>    %eax,-<span class="number">0x8000</span>(%esp)</span><br><span class="line">......</span><br><span class="line"><span class="comment">;; ImplicitNullCheckStub slow case</span></span><br><span class="line"><span class="number">0x026eb7a9</span>: <span class="keyword">call</span>   <span class="number">0x026e83e0</span>         <span class="comment">; OopMap&#123;ebx=Oop [16]=Oop off=142&#125;</span></span><br><span class="line">                                        <span class="comment">;*caload</span></span><br><span class="line">                                        <span class="comment">; - java.lang.String::hashCode@48 (line 1489)</span></span><br><span class="line">                                        <span class="comment">;    &#123;runtime_call&#125;</span></span><br><span class="line">  <span class="number">0x026eb7ae</span>: <span class="keyword">push</span>   <span class="number">$0</span>x83c5c18         <span class="comment">;    &#123;external_word&#125;</span></span><br><span class="line">  <span class="number">0x026eb7b3</span>: <span class="keyword">call</span>   <span class="number">0x026eb7b8</span></span><br><span class="line">  <span class="number">0x026eb7b8</span>: <span class="keyword">pusha</span></span><br><span class="line">  <span class="number">0x026eb7b9</span>: <span class="keyword">call</span>   <span class="number">0x0822bec0</span>         <span class="comment">;    &#123;runtime_call&#125;  </span></span><br><span class="line">  <span class="number">0x026eb7be</span>: <span class="keyword">hlt</span></span><br></pre></td></tr></table></figure><hr><h3 id="3-2-安全点"><a href="#3-2-安全点" class="headerlink" title="3.2 安全点"></a><strong>3.2 安全点</strong></h3><p>&emsp;&emsp;在OopMap的帮助下，HotSpot可以快速且准确地完成GC Roots枚举，但随之而来的一个现实的问题：可能导致引用关系变化，或者说OopMap内容变化的指令非常多，如果为每一条指令都生成对应的OopMap，那将会需要大量的额外空间，这样会导致GC的空间成本变得很高。</p><p>&emsp;&emsp;HotSpot实际上并没有为每条指令都生成OopMap，只是在“特定的位置”记录了这些信息，这些位置称为<strong>安全点</strong>（Safepoint），即程序执行时并非在所有地方都能停顿下来开始GC，只会在安全点暂停。Safepoint的选定既不能太少以致于让GC等待时间太长，也不能过于频繁以致于过分增大运行时的负荷。所以安全点的选定基本上是以程序“<strong>是否具有让程序长时间执行的特征</strong>”为标准进行选定的——因为每条指令的执行时间都非常短暂，程序不会因为指令流长度太长这个原因而过长时间运行，“<strong>长时间执行</strong>”的最明显特征就是<strong>指令序列复用</strong>，例如方法调用、循环跳转、异常跳转等，所以具有这些功能的指令才会产生Safepoint。</p><p>&emsp;&emsp;关于Safepoint，另外一个需要考虑的问题是如何在GC发生时让所有线程（不包括执行JNI调用的线程）都“跑”到最近的安全点上再停顿下来。有两种实现方案：<strong>抢先式中断</strong>（Preemptive Suspension）和<strong>主动式中断</strong>（Voluntary Suspension）。</p><p>&emsp;&emsp;抢先式中断不需要线程的执行代码主动去配合，在GC发生时，首先把所有线程全部中断，如果发现有线程中断的地方不在安全点，就恢复线程，让它“跑”到安全点上。但如今几乎没有虚拟机实现采用抢先式中断来暂停线程从而响应GC事件。</p><p>&emsp;&emsp;主动式中断的思想是当GC需要中断线程的时候，不直接对线程操作，而只是简单地设置一个标志，各个线程执行时主动去轮询这个标志，发现中断标志为真时就自己中断挂起。轮询标志的地方和安全点是重合的，另外再加上创建对象需要分配内存的地方。</p><p>&emsp;&emsp;下面代码中的test指令是HotSpot生成的轮询指令，当需要暂停线程时，虚拟机把0x160100的内存页设置为不可读，线程执行到test指令时就会产生一个自陷异常信号，在预先注册的异常处理器中暂停线程实现等待，这样一条汇编指令便完成安全点轮询和触发线程中断。</p><figure class="highlight x86asm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">0x01b6d627</span>: <span class="keyword">call</span>   <span class="number">0x01b2b210</span>         <span class="comment">; OopMap&#123;[60]=Oop off=460&#125;</span></span><br><span class="line">                                        <span class="comment">;*invokeinterface size</span></span><br><span class="line">                                        <span class="comment">; - Client::main@113 (line 23)</span></span><br><span class="line">                                        <span class="comment">;    &#123;virtual_call&#125;</span></span><br><span class="line">  <span class="number">0x01b6d62c</span>: <span class="keyword">nop</span>                       <span class="comment">; OopMap&#123;[60]=Oop off=461&#125;</span></span><br><span class="line">                                        <span class="comment">;*if_icmplt</span></span><br><span class="line">                                        <span class="comment">; - Client::main@118 (line 23)</span></span><br><span class="line">  <span class="number">0x01b6d62d</span>: <span class="keyword">test</span>   %eax,<span class="number">0x160100</span>      <span class="comment">;   &#123;poll&#125;</span></span><br><span class="line">  <span class="number">0x01b6d633</span>: <span class="keyword">mov</span>    <span class="number">0x50</span>(%esp),%esi</span><br><span class="line">  <span class="number">0x01b6d637</span>: <span class="keyword">cmp</span>    %eax,%esi</span><br></pre></td></tr></table></figure><hr><h3 id="3-3-安全区域"><a href="#3-3-安全区域" class="headerlink" title="3.3 安全区域"></a><strong>3.3 安全区域</strong></h3><p>&emsp;&emsp;Safepoint并没有完美地解决了如何进入GC的问题。Safepoint机制保证了程序执行时，在不久的时间内就会遇到可进入GC的Safepoint，但程序“不执行”的时候呢？所谓的程序不执行就是没有分配CPU时间，典型的例子就是线程处于Sleep状态或者Blocked状态，这时候线程无法响应JVM的中断请求，“走”到安全的地方去中断挂起，JVM显然不太可能等待线程重新被分配CPU时间。对于这种情况，就需要<strong>安全区域</strong>（Safe Region）来解决。</p><p>&emsp;&emsp;安全区域是指在一段代码片段之中，引用关系不会发生变化。在这个区域中的任意地方开始GC都是安全的。也可以把Safe Region看做是被扩展了的Safepoint。</p><p>&emsp;&emsp;在线程执行到Safe Region中的代码时，首先标识自己已经进入了Safe Region，那样，当在这段时间里JVM要发起GC时，就不用管标识自己为Safe Region状态的线程了，在线程需要离开Safe Region时，它就要检查系统是否已经完成了根节点枚举（或者是整个GC过程），如果完成了，那线程就继续执行，否则它就必须等待直到收到可以安全离开Safe Region的信号为止。</p><p>&emsp;&emsp;到此，简单介绍了HotSpot虚拟机如何去发起内存回收的问题，但是虚拟机如何具体地进行内存回收动作仍然未涉及，因为内存回收如何进行是由虚拟机所采用的GC收集器决定的，而通常虚拟机中往往不止有一种GC收集器，之后来看HotSpot中有哪些GC收集器。</p><hr><h2 id="第四节-垃圾收集器"><a href="#第四节-垃圾收集器" class="headerlink" title="第四节 垃圾收集器"></a><strong>第四节 垃圾收集器</strong></h2><p>&emsp;&emsp;如何说收集算法是内存回收的方法论，那么垃圾收集器就是内存回收的具体实现。Java虚拟机规范中对垃圾收集器应该如何实现并没有任何规定，因此不同的厂商、不同版本的虚拟机所提供的垃圾收集器都可能会有很大差别，并且一般都会提供参数供用户根据自己的应用特点和要求组合出各个年代所使用的收集器。这里讨论的收集器基于JDK 1.7 Update 14之后的HotSpot虚拟机（在这个版本中正式提供了商用的G1收集器，之前G1仍处于实验状态），虚拟机包含的所有收集器如下图所示。</p><p><img src="https://pic-1258215793.cos.ap-shanghai.myqcloud.com/content/20190801/201908010117.png" alt="HotSpot虚拟机的垃圾收集器"></p><p>&emsp;&emsp;上图展示了7种作用于不同分代的收集器，如果两个收集器之间存在连线，就说明他们可以搭配使用。虚拟机所处的区域，则表示它是属于新生代收集器还是老年代收集器。接下来各节将逐一介绍这些收集器的特性、基本原理和使用场景，并重点分析CMS和G1这两款相对复杂的收集器，了解它们的部分运作细节。</p><h3 id="4-1-Serial收集器"><a href="#4-1-Serial收集器" class="headerlink" title="4.1 Serial收集器"></a><strong>4.1 Serial收集器</strong></h3><p>&emsp;&emsp;Serial收集器是最基本、发展历史最悠久的收集器，曾经（在JDK 1.3.1 之前）是虚拟机新生代收集的唯一选择。此收集器是一个单线程的收集器，但其“单线程”的意义并不仅仅说明它只会使用一个CPU或一条收集线程去完成垃圾收集工作，更重要的是在它进行垃圾收集时，必须暂停其他所有的工作线程，直到它收集结束。“Stop The World” 这个名字也许听起来很酷，但这项工作实际上是由虚拟机在后台自动发起和自动完成的，在用户不可见的情况下把用户正常工作的线程全部停掉，这对很多应用来说都是难以接受的。下图示意了Serial / Serial Old 收集器运行过程。</p><p><img src="https://pic-1258215793.cos.ap-shanghai.myqcloud.com/content/20190801/201908010118.png" alt="Serial / Serial Old 收集器运行示意图"></p><p>&emsp;&emsp;对于“Stop The World”带给用户的不良体验，虚拟机设计者的苦衷是“你妈妈在给你打扫房间的时候，肯定也会让你老老实实地在椅子上或者房间外待着，如果她一边打扫，你一边乱扔纸屑，这房间还能打扫完？”这确实是一个合情合理的矛盾，但垃圾收集是比打扫房间要复杂的多。</p><p>&emsp;&emsp;从JDK 1.3 开始，一直到现在HotSpot开发团队仍在致力于消除或减少工作线程因内存回收而导致停顿的努力一直在进行着，从Serial收集器到Parallel收集器，再到Concurrent Mark Sweep（CMS）乃至GC收集器的最前沿成果Garbage First（G1）收集器，一个个越来越优秀也越来越复杂的收集器的不断出现，用户线程的停顿时间在不断缩短，但是仍无法完全消除。</p><p>&emsp;&emsp;Serial收集器到现在仍是虚拟机运行在Client模式下的默认新生代收集器，它还有相比于其他收集器的优点：<strong>简单而高效</strong>（单线程下）。对于限定单线程环境下，Serial收集器由于没有线程交互的开销，专心做垃圾收集自然可以获得最高的单线程收集效率。在用户的桌面应用场景中，分配给虚拟机管理的内存一般来说不会很大，收集几十兆甚至一两百兆的新生代，停顿时间完全可以控制在几十毫秒最多一百多毫秒以内，只要不是频繁发生，这点停顿是可以接受的。所以对于运行在Client模式下的虚拟机来说Serial收集器是很好的选择。</p><hr><h3 id="4-2-ParNew收集器"><a href="#4-2-ParNew收集器" class="headerlink" title="4.2 ParNew收集器"></a><strong>4.2 ParNew收集器</strong></h3><p>&emsp;&emsp;ParNew收集器其实就是Serial收集器的<strong>多线程版本</strong>，除了使用多条线程进行垃圾收集之外，其余行为包括Serial收集器可用的所有控制参数（例如：-XX:SurvivorRatio、-XX:PretenureSizeThreshold、-XX:HandlePromotionFailure等）、收集算法、Stop The World、对象分配规则、回收策略等都与Serial收集器一样，在实现上，这两种收集器也共用了很多相当多的代码。ParNew收集器的工作过程如下图所示。</p><p><img src="https://pic-1258215793.cos.ap-shanghai.myqcloud.com/content/20190801/201908010119.png" alt="ParNew / Serial Old 收集器运行示意图"></p><p>&emsp;&emsp;ParNew收集器除了多线程收集以外并没有其他创新之处，但它是许多运行在Server模式下的虚拟机中首选的新生代收集器，其中有一个与性能无关但很重要的原因是，除了Serial收集器外，<strong>目前只有它能与CMS收集器配合工作</strong>。在JDK 1.5时期，HotSpot推出了一款在强交互应用中几乎可认为有划时代意义的垃圾收集器——CMS收集器（Concurrent Mark Sweep，稍后详细介绍），这款收集器是HotSpot虚拟机中第一款真正意义上的并发（Concurrent）收集器，它第一次实现了让垃圾收集线程与用户线程基本上同时工作。</p><p>&emsp;&emsp;不幸的是，CMS作为老年代的收集器，却无法与JDK 1.4.0中已经存在的新生代收集器Parallel Scavenge配合工作，所以在JDK 1.5中使用CMS来收集老年代的时候，新生代只能选择ParNew或者Serial收集器中的一个。ParNew收集器也是使用-XX:+UseConcMarkSweepGC选项后的默认新生代收集器，也可以使用-XX:+UseParNewGC选项来强制执行它。</p><p>&emsp;&emsp;ParNew收集器在单CPU的环境中不会比Serial收集器好，甚至因为存在线程交互的开销，此收集器在通过超线程技术实现的两个CPU的环境中都不能百分百的超过Serial收集器。随着可使用CPU的数量增加，其对于GC时系统资源的有效利用还是很有好处的，它默认开启的收集线程数与CPU的数量相同，在CPU非常多的环境下，可以使用-XX:ParallelGCThreads参数来限制垃圾收集的线程数。</p><blockquote><p><strong>并发编程</strong>的两个概念名词在垃圾收集器的上下文语境中的解释：</p><ul><li>并行（Parallel）：指多条垃圾收集线程并行工作，但此时用户线程仍处于等待状态。</li><li>并发（Concurrent）：指用户线程与垃圾收集线程同时执行（但不一定是并行的，可能会交替执行），用户程序在继续运行，而垃圾收集程序运行在另一个CPU上。</li></ul></blockquote><hr><h3 id="4-3-Parallel-Scavenge收集器"><a href="#4-3-Parallel-Scavenge收集器" class="headerlink" title="4.3 Parallel Scavenge收集器"></a><strong>4.3 Parallel Scavenge收集器</strong></h3><p>&emsp;&emsp;Parallel Scavenge收集器是一个新生代收集器，使用复制算法，还是并行的多线程收集器，似乎和ParNew收集器没什么区别。Parallel Scavenge收集器的特点是它的关注点和其他收集器不同，<strong>CMS等收集器的关注点是尽可能的缩短垃圾收集时用户线程的停顿时间，而Parallel Scavenge收集器的目标则是达到一个可控制的吞吐量</strong>（Throughput）。吞吐量就是CPU用于运行用户代码的时间与CPU总消耗时间的比值，即吞吐量 = 运行用户代码时间 / (运行用户代码时间 + 垃圾收集时间)，如果虚拟机运行了100分钟，其中垃圾收集花费了1分钟，吞吐量就是99%。</p><p>&emsp;&emsp;停顿时间短意味着有较快的响应速度可以提升用户体验，适合与用户交互的程序；高吞吐量则可以高效率的利用CPU时间，尽快的完成程序的运算任务，适合在后台运算而不需要太多交互的任务。</p><p>&emsp;&emsp;Parallel Scavenge收集器提供了两个参数用于精确控制吞吐量，-XX:MaxGCPauseMills，-XX:GCTimeRatio。</p><p>&emsp;&emsp;Parallel Scavenge收集器也经常被叫做“吞吐量优先”收集器，除了以上两个参数还有一个-XX:UseAdaptiveSizePolicy值得关注。</p><blockquote><ul><li>-XX:MaxGCPauseMills 此参数控制最大垃圾收集停顿时间。MaxGCPauseMills参数的值是大于0的毫秒数，收集器会尽可能地保证内存回收花费时间不超过设定时间。但并不是设置的小就会使垃圾收集速度变快，GC停顿时间缩短是以牺牲吞吐量和新生代空间来换取的：系统会把新生代调小，也就导致垃圾收集会更频繁，所以吞吐量就会降低。</li><li>-XX:GCTimeRatio 此参数直接设置吞吐量大小。GCTimeRatio参数的值是一个大于0且小于100的整数，也就是垃圾收集时间占总时间的比率，相当于吞吐量的倒数。比如参数值为19，允许的最大GC时间就为1 / (1 + 19) = 5%的最大时间比率，如果为99，结果就为1%。</li><li>-XX:UseAdaptiveSizePolicy 它是一个<strong>开关参数</strong>，开启后就不需要手动指定新生代大小（-Xmn）、Eden与Survivor区的比例（-XX:SurvivorRatio）、晋升老年代对象大小（-XX:PretenureSizeThreshold）等细节参数，虚拟机会根据当前系统运行情况收集性能监控信息，动态调整这些参数以提供最合适的停顿时间或最大的吞吐量。这种调节方式叫GC自适应的调节策略（GC Ergonomics）。</li></ul></blockquote><p>&emsp;&emsp;如果开发者能力不足以进行优化工作，使用Parallel Scavenge收集器搭配自适应调节策略，把优化任务交给虚拟机来完成会是一个不错的选择。只需要把基本的内存数据设置好（-Xmx设置最大堆等），然后MaxGCPauseMills（关注最大停顿时间）或GCTimeRatio（关注最大吞吐量）参数给虚拟机设置一个优化目标，具体调节就由虚拟机去完成了。</p><p>&emsp;&emsp;自适应调节策略是Parallel Scavenge收集器和ParNew收集器的一个重要区别。</p><hr><h3 id="4-4-Serial-Old收集器"><a href="#4-4-Serial-Old收集器" class="headerlink" title="4.4 Serial Old收集器"></a><strong>4.4 Serial Old收集器</strong></h3><p>&emsp;&emsp;Serial Old收集器是Serial收集器的老年代版本，同样是一个单线程收集器，使用“标记-整理”算法。此收集器的主要意义同样是在于给Client模式下的虚拟机使用。但在Server模式下，它还有两大用途：一种用途是在JDK 1.5 以及之前的版本中与Parallel Scavenge收集器搭配使用，另一种用途就是作为CMS收集器的后备预案，在并发收集发生Concurrent Mode Failure时使用。</p><p>&emsp;&emsp;Serial Old收集器工作过程如下图。</p><p><img src="https://pic-1258215793.cos.ap-shanghai.myqcloud.com/content/20190801/201908010118.png" alt="Serial / Serial Old 收集器运行示意图"></p><hr><h3 id="4-5-Parallel-Old收集器"><a href="#4-5-Parallel-Old收集器" class="headerlink" title="4.5 Parallel Old收集器"></a><strong>4.5 Parallel Old收集器</strong></h3><p>&emsp;&emsp;Parallel Old收集器是Parallel Scavenge收集器的老年代版本，使用多线程和“标记-整理”算法。此收集器从JDK 1.6开始提供，在此之前新生代的Parallel Scavenge收集器只能搭配老年代的Serial Old收集器，因为它无法与CMS收集器配合。Serial Old收集器在服务端应用性能上并不可靠，使用了Parallel Scavenge收集器也未必能够在整体应用上获得最大吞吐量的效果，由于单线程的老年代收集中无法充分利用服务器多CPU的处理能力，在老年大很大而且硬件比较高级的环境中，这种组合甚至不一定比ParNew+CMS的组合更好。</p><p>&emsp;&emsp;Parallel Old收集器出现完善了“吞吐量优先”收集器有了合适的组合，在注重吞吐量以及CPU资源敏感的场合，可以优先考虑Parallel Scavenge收集器+Parallel Old收集器的搭配。</p><p><img src="https://pic-1258215793.cos.ap-shanghai.myqcloud.com/content/20190801/201908010120.png" alt="Parallel Scavenge / Parallel Old 收集器运行示意图"></p><hr><h3 id="4-6-CMS收集器"><a href="#4-6-CMS收集器" class="headerlink" title="4.6 CMS收集器"></a><strong>4.6 CMS收集器</strong></h3><p>&emsp;&emsp;CMS（Concurrent Mark Sweep）收集器是一种以获取最短回收停顿时间为目标的收集器。目前很大一部分的Java应用集中在互联网站或B/S系统的服务端上，这类应用尤其重视服务的响应速度，希望系统停顿时间最短，从而给用户带来较好的体验，CMS收集器非常适合这种需求。</p><p>&emsp;&emsp;从名字Mark Sweep便可以得知CMS收集器是基于“标记-清除”算法实现的，其运作过程相比前几个收集器相对复杂。</p><blockquote><p>CMS收集器运作过程：</p><ul><li><strong>初始标记</strong>（CMS initial mark）：仅仅是标记一下GC Roots能直接关联到的对象，速度很快。初始标记和重新标记两个步骤仍需要“Stop The World”。</li><li><strong>并发标记</strong>（CMS concurrent mark）：进行GC Roots Tracing的过程。</li><li><strong>重新标记</strong>（CMS remark）：为了修正并发标记期间因用户程序继续运作而导致标记产生变动的那一部分对象的标记记录，此阶段的停顿时间一般会比初始标记阶段稍长，但比并发标记阶段短。</li><li><strong>并发清除</strong>（CMS concurrent sweep）：并发清除和并发标记是耗时最长的阶段，这两个阶段收集器线程都可以与用户线程一起工作。</li></ul></blockquote><p>&emsp;&emsp;总体来说CMS收集器的内存回收过程是与用户线程一起并发执行的，下图可以看到CMS收集器的运作步骤中并发和需要停顿的时间。</p><p><img src="https://pic-1258215793.cos.ap-shanghai.myqcloud.com/content/20190801/201908010121.png" alt="Concurrent Mark Sweep 收集器运行示意图"></p><p>&emsp;&emsp;CMS是一款优秀的收集器，优点就是<strong>并发收集</strong>、<strong>低停顿</strong>，所以Sun公司文档中称其为<strong>并发低停顿收集器</strong>（Concurrent Low Pause Collector），但CMS也有明显的缺点。</p><h4 id="CMS的三个缺点"><a href="#CMS的三个缺点" class="headerlink" title="CMS的三个缺点"></a><strong>CMS的三个缺点</strong></h4><p>&emsp;&emsp;1. <strong>对CPU资源十分敏感</strong>，这是并发设计程序的通病。在并发阶段，虽然不会导致用户线程停顿，但会因为占用了一部分线程或者说CPU资源而导致应用程序变慢，总吞吐量会降低。</p><p>&emsp;&emsp;CMS默认启动的回收线程数是 (CPU数量 + 3) / 4，也就是当CPU在4个以上时，并发回收时垃圾收集线程不少于25%的CPU资源，并且随着CPU数量的增加而下降。但是当CPU不足4个时，CMS对用户程序的影响就可能变得很大，如果CPU本身负载就比较大，还要分出一半的运算能力去执行收集器线程，就会导致用户程序的执行速度突然下降50%。</p><p>&emsp;&emsp;为了应对这种情况，虚拟机提供了一种称为<strong>增量式并发收集器</strong>（Incremental Concurrent Mark Sweep / i-CMS）的CMS收集器变种，所做的工作和单CPU年代PC机操作系统使用<strong>抢占式</strong>来模拟多任务机制的思路一样，就是在并发标记、清理的时候让GC线程、用户线程交替运行，尽量减少线程独占资源的时间，这样整个垃圾收集的过程会更长，但会降低对用户程序的影响。但实际使用中i-CMS效果非常一般，所以后续版本已经弃用（deprecated）。</p><p>&emsp;&emsp;2. <strong>无法处理浮动垃圾，可能出现“Concurrent Mode Failure”失败而导致另一次Full GC的产生</strong>。因为CMS并发清理阶段用户线程还在运行，所以自然会不断地产生垃圾，这部分垃圾产生在标记过程之后，所以CMS无法在此次收集中处理它们，只能留到下次GC时再进行清理。这部分垃圾就被称为浮动垃圾（Floating Garbage）。因为垃圾收集阶段用户线程还在运行，还意味着需要预留足够的内存空间给用户线程使用，因此CMS收集器不能像其他收集器那样等到老年代几乎被填满了再去收集，而是需要预留一部分空间提供并发收集时的程序运作使用。</p><p>&emsp;&emsp;使用JDK 1.5默认设置时，CMS收集器当老年代使用了68%就会被激活，这个数值比较保守，可以通过提高参数-XX:CMSInitiatingOccupancyFraction的值来提高触发百分比，从而降低内存回收次数获取更好的性能。JDK 1.6时，CMS收集器的启动阈值已经提升至92%。如果CMS运行期间预留的内存无法满足程序需要，会出现一次“Concurrent Mode Failure”失败，此时虚拟机将启动后背预案：临时启动Serial Old收集器来重新进行老年代的垃圾收集，这样停顿时间就很长了。所以CMSInitiatingOccupancyFraction参数谨慎处理，设置太高反而可能导致性能降低。</p><p>&emsp;&emsp;3. <strong>生成大量的空间碎片</strong>。因为CMS收集器基于“标记-清除”算法，所以自然会在收集结束后产生大量的空间碎片，给大对象的分配造成困难，经常老年代仍有大量空间未使用，却无法找到足够大的连续空间来分配当前对象，不得不提前触发一次Full GC。</p><p>&emsp;&emsp;为了解决这个问题，CMS收集器提供了一个-XX:+UseCMSCompactAtFullCollection开关参数（默认开启），用于在CMS收集器顶不住要进行Full GC时开启内存碎片的合并整理过程，此过程无法并发，解决了空间碎片问题，但代价是延长了停顿时间。</p><p>&emsp;&emsp;虚拟机还提供了另外一个参数-XX:CMSFullGCsBeforeCompaction，此参数用来设置执行多少次不压缩Full GC后，跟着来一次带压缩的（默认为0，表示每次进入Full GC时都进行碎片整理）</p><hr><h3 id="4-7-G1收集器"><a href="#4-7-G1收集器" class="headerlink" title="4.7 G1收集器"></a><strong>4.7 G1收集器</strong></h3><p>&emsp;&emsp;G1（Garbage-First）收集器是当今收集器技术发展的最前沿成果之一，早在JDK 1.7时就有了进化特征，在JDK 6u14时有了Early Access版本提供实验、使用。直到JDK 7u4时达到成熟阶段。G1是一款面向服务端应用的垃圾收集器，其使命是替换掉JDK 1.5发布的CMS收集器。</p><blockquote><p>G1相比其它收集器的特点：</p><ul><li><strong>并行与并发</strong> ：G1能充分利用多CPU、多核环境下的硬件优势，使用多个CPU来缩短“Stop The World”停顿的时间，部分其他收集器原本需要停顿Java线程执行的GC动作，G1收集器仍然可以通过并发的方式让Java线程继续执行。</li><li><strong>分代收集</strong> ：和其他收集器一样，G1仍然保留了分代概念。虽然G1能独立管理整个GC堆，不需要其他收集器配合，但它能够采用不同的方式去处理新创建的对象和已经存活了一段时间、熬过多次GC的旧对象以获取更好的收集效果。</li><li><strong>空间整合</strong> ：与CMS的“标记-清除”算法不同，G1从整体来看是基于“标记-整理”算法实现的收集器。从局部（两个Region之间）上来看是基于“复制”算法实现的，但无论如何，这两种算法都意味着G1运行期间不会产生内存空间碎片，收集后能提供规整的可用内存。这个特性有利于程序长时间运行，分配大对象不会因为找不到连续空间而提前触发下次GC。</li><li><strong>可预测的停顿</strong> ：这个特点是G1相对于CMS的另一大优势，G1除了追求低停顿外，还能建立可预测的停顿时间模型，能让使用者明确指定在一个长度为M毫秒的时间片段内，消耗在垃圾收集上的时间不得超过N毫秒，这几乎已经是实时Java（RTSJ）的垃圾收集器的特征了。</li></ul></blockquote><p>&emsp;&emsp;在G1之前的其他收集器进行收集的范围都是整个新生代或者老年代，而G1收集器的Java堆内存布局会有很大变化，它将整个Java堆分为对个大小相等的独立区域（Region），虽然还保留了新生代和老年代的概念，但两者之间不再物理隔离，都是一部分Region（不需要连续）的集合。</p><p>&emsp;&emsp;G1收集器之所以能建立可预测的停顿时间模型，是因为它可以有计划的避免在整个Java堆中进行全区域的垃圾收集。G1跟踪各个Region里面的垃圾堆积的价值大小（回收所获得的空间大小以及回收所需时间的经验值），在后台维护一个优先列表，每次根据允许的收集时间，优先回收价值最大的Region（G1由来）。这种使用Region划分内存空间以及有优先级的区域回收方式，保证了G1收集器在有限的时间内可以获取尽可能高的收集效率。</p><p>&emsp;&emsp;G1把内存“化整为零”的思路，实际实现并不简单。一个细节为例：把Java堆分为多个Region后，垃圾收集是否就真的能以Region为单位进行了？似乎顺理成章，但仔细想想会发现问题所在：Region不可能是孤立的。一个对象分配在某个Region中，它并非只能被此Region中的对象引用，而是可以和整个Java堆中任意的对象发生引用关系。那么在做可达性分析判定确定对象是否存活时，岂不是还要扫描整个Java堆才能保证准确性？这个问题并非G1独有，但G1尤其明显突出。在以前的分代收集中，新生代一般都比老年代要小许多，收集也要频繁许多，那么回收新生代对象时也面临着同样的问题，如果回收新生代对象时不能不同时扫描老年代的话，Minor GC的效率要下降不少。</p><p>&emsp;&emsp;G1收集器中Region间的对象引用，其他收集器中新生代和老年代之间的对象引用，都是通过 Remembered Set 来避免全堆扫描。在G1中每个 Region 都有一个对应的 Remembered Set ，当虚拟机发现程序在对 Reference 类型的数据进行写操作时，会产生一个 Write Barrier 暂时中断写操作，检查 Reference 引用的对象是否处于不同的 Region 之中（在分代的例子中就是检查是否老年代的对象引用了新生代的对象），如果是，便通过 CardTable 把相关引用信息记录到被引用对象所属的 Region 的 Remembered Set 之中。当进行内存回收时，在GC根节点的枚举范围中加入 Remembered Set 即可保证不对全堆扫描也不会有遗漏。 </p><blockquote><p>不考虑维护 Remembered Set 的操作，G1收集器的运作步骤：</p><ul><li><strong>初始标记</strong>（Initial Marking）：仅仅是标记一下GC Roots能直接关联到的对象，并修改TAMS（Next To at Mark Start）的值，使下一阶段用户程序并发运行时，能在正确可用的Region中创建对象，这阶段需要停顿线程，但耗时很短。</li><li><strong>并发标记</strong>（Concurrent Marking）：从GC Roots开始对堆中对象进行可达性分析，找出存活的对象，此阶段耗时较长，但可与用户程序并发执行。</li><li><strong>最终标记</strong>（Final Marking）：此阶段是为了修正在并发标记期间因用户程序继续运作而导致标记产生变动的那一部分标记记录，虚拟机将这段时间对象变化记录在线程 Remembered Set Logs里面，最终标记阶段。</li><li><strong>筛选回收</strong>（Live Data Counting and Evacuation）：并发清除和并发标记是耗时最长的阶段，这两个阶段收集器线程都可以与用户线程一起工作。</li></ul></blockquote><p>&emsp;&emsp;G1收集器的前几个步骤和CMS收集器类似。</p><hr><h3 id="4-8-理解GC日志"><a href="#4-8-理解GC日志" class="headerlink" title="4.8 理解GC日志"></a><strong>4.8 理解GC日志</strong></h3><p>&emsp;&emsp;</p><hr><h3 id="4-9-垃圾收集器参数总结"><a href="#4-9-垃圾收集器参数总结" class="headerlink" title="4.9 垃圾收集器参数总结"></a><strong>4.9 垃圾收集器参数总结</strong></h3><p>&emsp;&emsp;</p><hr><p><em>参考博客和文章书籍等：</em></p><blockquote><p>《深入理解Java虚拟机》</p></blockquote><p><em>因博客主等未标明不可引用，若部分内容涉及侵权请及时告知，我会尽快修改和删除相关内容</em></p>]]></content>
    
    <summary type="html">
    
      简单介绍Java虚拟机中的垃圾收集器，包括：垃圾收集算法(标记-清除算法，复制算法，标记-整理算法，分代收集算法)，枚举根节点，安全点，安全区域，垃圾收集器(Serial收集器，ParNew收集器，Parallel Scavenge收集器，Serial Old收集器，Parallel Old收集器，CMS收集器，G1收集器)，理解GC日志，垃圾收集器参数总结等。
    
    </summary>
    
      <category term="技术文档" scheme="http://linyishui.top/categories/%E6%8A%80%E6%9C%AF%E6%96%87%E6%A1%A3/"/>
    
    
      <category term="java" scheme="http://linyishui.top/tags/java/"/>
    
      <category term="jvm" scheme="http://linyishui.top/tags/jvm/"/>
    
  </entry>
  
  <entry>
    <title>GitLab</title>
    <link href="http://linyishui.top/2019091101.html"/>
    <id>http://linyishui.top/2019091101.html</id>
    <published>2019-09-11T01:30:56.000Z</published>
    <updated>2019-11-05T03:56:22.356Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="GitLab"><a href="#GitLab" class="headerlink" title="GitLab"></a><strong>GitLab</strong></h1><h2 id="第一节-介绍"><a href="#第一节-介绍" class="headerlink" title="第一节 介绍"></a><strong>第一节 介绍</strong></h2><p>&emsp;&emsp;GitLab是由GitLab Inc.开发，使用MIT许可证的基于网络的Git仓库管理工具。它由 Ruby 写成。后来一些部分用 Go 语言重写。</p><h3 id="github和github区别"><a href="#github和github区别" class="headerlink" title="github和github区别"></a><strong>github和github区别</strong></h3><p>&emsp;&emsp;github和github都是基于git的web代码仓库管理软件。区别主要在于github上的仓库基本上都是开源的，当然也可以创建私有的代码仓库，但是费用比较昂贵。而gitlab是可以在企业内部搭建，可以创建私有的代码仓库，除此之外，gitlab还有一些其他的高级特性。相同之处是他们都是基于版本管理系统git，都使用git的命令进行操作。</p><hr><h2 id="第二节-安装"><a href="#第二节-安装" class="headerlink" title="第二节 安装"></a><strong>第二节 安装</strong></h2><h3 id="选择版本"><a href="#选择版本" class="headerlink" title="选择版本"></a><strong>选择版本</strong></h3><p>&emsp;&emsp;GitLab是建立在开放核心模型之上的。这意味着GitLab有两个版本: <strong>社区版</strong>和<strong>企业版</strong>。</p><p>&emsp;&emsp;社区版是开放源码的，拥有MIT的外籍许可证。企业版构建在社区版之上，使用相同的核心，但在此基础上添加了其他特性和功能，这是在专有许可下进行的。</p><p>&emsp;&emsp;对于这两个版本: GitLab中的所有javascript代码都是开源的。所有由GitLab编写的javascript代码都在同一个MIT许可下。</p><p>&emsp;&emsp;社区版升级到企业版的过程中需要停机，如果没有许可证企业版不会和社区版有明显差异。</p><p><a href="https://about.gitlab.com/installation" title="Title" target="_blank" rel="noopener">Install GitLab Enterprise Edition.</a></p><p><a href="https://about.gitlab.com/install/?version=ce" title="Title" target="_blank" rel="noopener">Install GitLab Community Edition.</a></p><h3 id="过程"><a href="#过程" class="headerlink" title="过程"></a><strong>过程</strong></h3><p>&emsp;&emsp;安装环境是Ubuntu + Docker</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 不加 tag 则默认为最新版本 latest (一般使用这种)</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> sudo docker pull gitlab/gitlab-ce</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 如果需要下载其他版本，加上对应的 tag 即可，如：</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> sudo docker pull gitlab/gitlab-ce:rc</span></span><br></pre></td></tr></table></figure><p>&emsp;&emsp;未完待续…</p><hr><p><em>参考博客和文章书籍等：</em></p><blockquote><p><a href="https://about.gitlab.com/install/ce-or-ee/" title="Title" target="_blank" rel="noopener">gitlab社区版和企业版</a></p></blockquote><blockquote><p><a href="http://jemgeek.com/archives/2019/docker-base-install.html" title="Title" target="_blank" rel="noopener">安装 Docker 和 Docker Compose (Ubuntu)</a></p></blockquote><blockquote><p><a href="https://zhuanlan.zhihu.com/p/63786567" title="Title" target="_blank" rel="noopener">使用 Docker 搭建 GitLab</a></p></blockquote><blockquote><p><a href="https://www.jianshu.com/p/ade38a53b1ac" title="Title" target="_blank" rel="noopener">搭建gitlab仓库</a></p></blockquote><blockquote><p><a href="https://git-scm.com/book/zh/v2/%E6%9C%8D%E5%8A%A1%E5%99%A8%E4%B8%8A%E7%9A%84-Git-GitLab" title="Title" target="_blank" rel="noopener">服务器上的 Git - GitLab</a></p></blockquote><blockquote><p><a href="https://www.jianshu.com/p/fb61299086b6" title="Title" target="_blank" rel="noopener">Gitlab详细操作</a></p></blockquote><p><em>因博客主等未标明不可引用，若部分内容涉及侵权请及时告知，我会尽快修改和删除相关内容</em></p>]]></content>
    
    <summary type="html">
    
      GitLab。
    
    </summary>
    
      <category term="技术文档" scheme="http://linyishui.top/categories/%E6%8A%80%E6%9C%AF%E6%96%87%E6%A1%A3/"/>
    
    
      <category term="git" scheme="http://linyishui.top/tags/git/"/>
    
  </entry>
  
  <entry>
    <title>垃圾收集器（一）确认对象生死</title>
    <link href="http://linyishui.top/2019091001.html"/>
    <id>http://linyishui.top/2019091001.html</id>
    <published>2019-09-10T10:56:40.000Z</published>
    <updated>2019-11-06T02:01:38.937Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="垃圾收集器"><a href="#垃圾收集器" class="headerlink" title="垃圾收集器"></a><strong>垃圾收集器</strong></h1><h2 id="引言"><a href="#引言" class="headerlink" title="引言"></a><strong>引言</strong></h2><p>&emsp;&emsp;诞生于1960年的Lisp是第一门真正使用内存动态分配和垃圾收集技术的语言。如今内存的动态分配和内存回收技术已经非常成熟，了解垃圾收集(GC)和内存分配的原理，从而可以在排查内存溢出和内存泄漏问题时，在垃圾收集成为系统提高并发量的瓶颈时，我们有足够的能力进行监控和调节。</p><p>&emsp;&emsp;<a href="../2019050801.html" title="Title">Java内存区域和内存溢出异常</a>中介绍了内存运行时的各个区域，其中程序计数器、虚拟机栈、本地方法栈三个区域和线程共享相同生命周期；栈中的栈帧随着方法进入和退出进行入栈出栈操作，每个栈帧分配的内存大小在确定类结构时便可得知(不考虑JIT编译器优化)因此这些区域的内存分配和回收都具有确定性，在方法或线程结束时便已回收，所以无需多考虑回收问题。</p><p>&emsp;&emsp;Java堆和方法区则不同，一个接口的多个实现类需要的内存可能不同，一个方法内的多个分支需要的内存也可能不同，只有程序运行时才能得知要创建多少对象，这些区域的内存分配和回收都是动态的，所以值得讨论。</p><hr><h2 id="第一节-对象已死了吗"><a href="#第一节-对象已死了吗" class="headerlink" title="第一节 对象已死了吗"></a><strong>第一节 对象已死了吗</strong></h2><p>&emsp;&emsp;垃圾回收第一件工作便是确认对象是”存活”还是已”死亡”。</p><hr><h3 id="1-1-引用计数算法"><a href="#1-1-引用计数算法" class="headerlink" title="1.1 引用计数算法"></a><strong>1.1 引用计数算法</strong></h3><p>&emsp;&emsp;常见的判断对象是否存活的算法是这样的：给对象中添加一个引用计数器，每当有地方引用它，计数器值就加1；当引用失效时，计数器值就减1；任何时刻计数器为0的对象就是不可能再被使用的。</p><p>&emsp;&emsp;<strong>引用计数算法</strong>(Reference Counting)的实现简单，判定效率也很高，所以也有很多著名的应用案例。但主流的Java虚拟机都没有选用引用计数算法来管理内存，主要的原因是它很难解决<strong>对象之间相互循环引用</strong>的问题。</p><p>&emsp;&emsp;比如，以下代码中的testGC()方法。objA和objB互相引用，所以计数都不为0，引用计数算法无法通知GC收集器回收它们。</p><figure class="highlight axapta"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * testGC()执行后，objA和objB会不会被GC呢？</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ReferenceCountingGC</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> Object instance = <span class="keyword">null</span>;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> _1MB = <span class="number">1024</span> * <span class="number">1024</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 这个成员属性的唯一意义就是占点内存，以便能在GC日志中看清楚是否被回收过</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">byte</span>[] bigSize = <span class="keyword">new</span> <span class="keyword">byte</span>[<span class="number">2</span> * _1MB];</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> testGC()&#123;</span><br><span class="line">        ReferenceCountingGC objA = <span class="keyword">new</span> ReferenceCountingGC();</span><br><span class="line">        ReferenceCountingGC objB = <span class="keyword">new</span> ReferenceCountingGC();</span><br><span class="line">        objA.instance = objB;</span><br><span class="line">        objB.instance = objA;</span><br><span class="line"></span><br><span class="line">        objA = <span class="keyword">null</span>;</span><br><span class="line">        objB = <span class="keyword">null</span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//假设在这行发生GC，objA和objB能否被回收？</span></span><br><span class="line">        System.gc();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>&emsp;&emsp;但运行并观察GC日志，发现虚拟机并没有因为对象互相引用就没有回收，也印证了虚拟机没有采用引用计数算法。</p><hr><h3 id="1-2-可达性分析算法"><a href="#1-2-可达性分析算法" class="headerlink" title="1.2 可达性分析算法"></a><strong>1.2 可达性分析算法</strong></h3><p>&emsp;&emsp;主流商用程序语言的主流实现都是采用<strong>可达性分析</strong>(Reachability Analysis)来判定对象是否存活。基本思路是：通过一系列的称为“GC Roots”的对象作为起始点，从这些节点开始向下搜索，搜索所走过的路径称为<strong>引用链</strong>(Reference Chain)，当一个对象到GC Roots没有任何引用链相连时，证明此对象是不可用的。</p><p>&emsp;&emsp;如下图所示，对象5、6、7虽然互有关联，但它们到GC Roots是不可达的，所以会被判定为可回收对象。</p><p><img src="https://pic-1258215793.cos.ap-shanghai.myqcloud.com/content/20190801/201908010113.png" alt="可达性分析算法判定对象是否可回收"></p><blockquote><p>对于Java语言，可被视作GC Roots的对象包括以下几种：</p><ul><li>虚拟机栈(栈帧中的本地变量表)中引用的对象</li><li>方法区中类静态属性引用的对象</li><li>方法区中常量引用的对象</li><li>本地方法栈中JNI(即一般说的Native方法)引用的对象</li></ul></blockquote><hr><h3 id="1-3-引用"><a href="#1-3-引用" class="headerlink" title="1.3 引用"></a><strong>1.3 引用</strong></h3><p>&emsp;&emsp;无论采用哪种算法，判定对象是否存活都与“引用”有关。在JDK 1.2之前，Java中对引用的定义很传统：<strong>如果reference类型的数据中存储的数值代表的是另外一块内存的起始地址，就称这块内存代表着一个引用</strong>。这种定义方式使对象只有被引用和没被引用两种状态，而无法描述这样一类对象：<strong>当内存空间还足够时，则能保留在内存中；如果内存空间在垃圾收集后还很紧张，则可以清除的对象</strong>。</p><p>&emsp;&emsp;在JDK 1.2以后，Java对引用的概念进行了扩充，将引用分为<strong>强引用</strong>(Strong Reference)、<strong>软引用</strong>(Soft Reference)、<strong>弱引用</strong>(Weak Reference)、<strong>虚引用</strong>(Phantom Reference)4种，这4种引用强度依次逐渐减弱。</p><blockquote><ul><li>强引用就是指在程序代码中普遍存在的，类似“Object obj = new Object()”这类引用，只要强引用还存在，垃圾收集器就不会回收被引用的对象。</li><li>软引用是用来描述一些还有用但并非必须的对象。对于软引用关联着的对象，在系统将要发生内存溢出异常之前，会把这些对象列入回收范围之中进行二次回收。如果此次回收仍没有足够内存，才会抛出内存溢出异常。JDK 1.2以后，提供了SoftReference类来实现软引用。</li><li>弱引用也是用来描述非必需对象的，但相较软引用更弱一些，被弱引用关联的对象只能生存到下一次垃圾收集发生之前。<strong>当垃圾收集器工作时，无论当前内存是否足够，都会回收掉只被弱引用关联的对象</strong>。JDK 1.2以后，提供了WeakReference类来实现软引用。</li><li>虚引用也叫做幽灵引用或者幻影引用，是最弱的一种引用关系。一个对象是否有虚引用存在，完全不会对其生存时间有任何影响，也无法通过虚引用来获取一个对象实例。<strong>为一个对象设置虚引用关联的唯一目的就是能在这个对象被收集器回收时收到一个系统通知</strong>。JDK 1.2以后，提供了PhantomReference类来实现软引用。</li></ul></blockquote><hr><h3 id="1-4-生存还是死亡"><a href="#1-4-生存还是死亡" class="headerlink" title="1.4 生存还是死亡"></a><strong>1.4 生存还是死亡</strong></h3><p>&emsp;&emsp;即使在可达性分析算法中不可达的对象也并非是“非死不可”的，它们会先处于一个“缓刑”阶段，真正的迎来对象的死亡至少还要经历两次标记过程：如果对象在进行可达性分析后发现没有与GC Roots相连接的引用链，那它将会被第一次标记并且进行一次筛选，筛选的条件是此对象是否有必要执行finalize()方法。当对象没有覆盖finalize()方法，或者finalize()方法已经被虚拟机调用过，虚拟机会将这两种情况都视为“没有必要执行”。</p><p>&emsp;&emsp;如果这个对象已经被判定为有必要执行finalize()方法，那么这个对象会被放置在一个叫F-Queue的队列中，并在稍后由一个由虚拟机自动建立的、低优先级的Finalizer线程去“执行”它。<strong>执行</strong>指的是虚拟机会触发这个方法，但并不承诺会等待它运行结束，如果一个对象在finalize()方法中执行缓慢，或者发生了死循环，将很可能导致F-Queue队列中其他对象永久处于等待状态，甚至导致整个内存回收系统崩溃。finalize()方法是对象逃脱死亡命运的最后一次机会，稍后GC将对F-Queue中的对象进行第二次小规模的标记，如果对象想要在这时“拯救自己”——只要重新与引用链上的任意一个对象建立关联即可(譬如把自己赋值给某个类变量或对象的成员变量)，它会在第二次标记时被移除出“即将回收”的集合。</p><p>&emsp;&emsp;以下代码演示对象在执行finalize()方法后仍可以存活。</p><figure class="highlight cs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 此代码演示了两点：</span></span><br><span class="line"><span class="comment"> *  1.对象可以在被GC时自我拯救</span></span><br><span class="line"><span class="comment"> *  2.这种自救的机会只有一次，因为一个对象的finalize()方法最多只会被系统自动的调用一次</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">FinalizeEscapeGC</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> FinalizeEscapeGC SAVE_HOOK = <span class="literal">null</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">isAlive</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">        System.<span class="keyword">out</span>.println(<span class="string">"yes, i am still alive :)"</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">finalize</span>(<span class="params"></span>) throws Throwable </span>&#123;</span><br><span class="line">        super.finalize();</span><br><span class="line">        System.<span class="keyword">out</span>.println(<span class="string">"finalize method executed!"</span>);</span><br><span class="line">        FinalizeEscapeGC.SAVE_HOOK = <span class="keyword">this</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span>(<span class="params">String[] args</span>) throws Throwable</span>&#123;</span><br><span class="line">        SAVE_HOOK = <span class="keyword">new</span> FinalizeEscapeGC();</span><br><span class="line"></span><br><span class="line">        <span class="comment">//对象第一次成功的拯救自己</span></span><br><span class="line">        SAVE_HOOK = <span class="literal">null</span>;</span><br><span class="line">        System.gc();</span><br><span class="line">        <span class="comment">//因为finalize方法优先级很低，所以暂停0.5秒以等待它</span></span><br><span class="line">        Thread.sleep(<span class="number">500</span>);</span><br><span class="line">        <span class="keyword">if</span>(SAVE_HOOK != <span class="literal">null</span>)&#123;</span><br><span class="line">            SAVE_HOOK.isAlive();</span><br><span class="line">        &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">            System.<span class="keyword">out</span>.println(<span class="string">"no, i am dead :("</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//下面代码与上面完全相同，但这次自救却失败了</span></span><br><span class="line">        SAVE_HOOK = <span class="literal">null</span>;</span><br><span class="line">        System.gc();</span><br><span class="line">        <span class="comment">//因为finalize方法优先级很低，所以暂停0.5秒以等待它</span></span><br><span class="line">        Thread.sleep(<span class="number">500</span>);</span><br><span class="line">        <span class="keyword">if</span>(SAVE_HOOK != <span class="literal">null</span>)&#123;</span><br><span class="line">            SAVE_HOOK.isAlive();</span><br><span class="line">        &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">            System.<span class="keyword">out</span>.println(<span class="string">"no, i am dead :("</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>&emsp;&emsp;运行结果如下。SAVE_HOOK对象的finalize()方法确实被GC收集器触发过，且在被收集前成功逃脱了。</p><figure class="highlight oxygene"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">finalize</span> <span class="function"><span class="keyword">method</span> <span class="title">executed</span>!</span></span><br><span class="line"><span class="function"><span class="title">yes</span>, <span class="title">i</span> <span class="title">am</span> <span class="title">still</span> <span class="title">alive</span> :</span>)</span><br><span class="line">no, i am dead :(</span><br></pre></td></tr></table></figure><p>&emsp;&emsp;一个值得注意的地方是，两段相同代码，一次逃脱成功，一次失败。原因就是任何对象的finalize()方法都只会被系统自动调用一次，如果对象面临下一次回收，finalize()方法不会再次执行。</p><p>&emsp;&emsp;通过finalize()方法来避免GC并不是一种值得提倡的用法，其运行代价高昂，不确定性大，无法保证各个对象的调用顺序。finalize()方法能做的所有工作try-finally和其他方式都可以做个更好，finalize()可以被开发人员忽略。</p><hr><h3 id="1-5-回收方法区"><a href="#1-5-回收方法区" class="headerlink" title="1.5 回收方法区"></a><strong>1.5 回收方法区</strong></h3><p>&emsp;&emsp;方法区(HotSpot中的永久代)不强制要求VM实现垃圾收集，在堆中，尤其是新生代中，一次垃圾收集一般可以回收70%~95%的空间，而永久代要远低于此。</p><p>&emsp;&emsp;永久代的垃圾回收主要回收两部分内容：<strong>废弃常量</strong>和<strong>无用的类</strong>。</p><p>&emsp;&emsp;回收废弃常量类似于回收Java堆中的对象，以常量池中字面量的回收为例，假设一个字符串“abc”已经进入了常量池中，但当前系统没有任何一个String对象是叫“abc”的，也就是没有任何String对象或其他地方引用常量池中的“abc”常量，如果此时发生内存回收，有必要的话会将此常量清理出常量池。常量池中的其他类(接口)、方法、字段的符号引用也与此类似。</p><h4 id="判断类是否无用"><a href="#判断类是否无用" class="headerlink" title="判断类是否无用"></a><strong>判断类是否无用</strong></h4><blockquote><p>判断类为无用类的三个条件：</p><ul><li>该类所有实例都已经被回收，也就是Java堆中不存在该类的任何实例。</li><li>加载该类的ClassLoader已经被回收。</li><li>该类对应的java.lang.Class对象没有在任何地方被引用，无法在任何地方通过反射访问该类的方法。</li></ul></blockquote><p>&emsp;&emsp;判断类是否无用相比判断常量是否废弃要苛刻许多，当类满足以上条件时，虚拟机才可以进行回收，但不会像对象一样，不使用就必然会回收。HotSpot虚拟机提供了-Xnoclassgc参数进行控制是否对类进行回收，还可以使用-verbose:class以及-XX:+TraceClassLoading、-XX:+TraceClassUnLoading查看类加载和卸载信息，其中-verbose:class和-XX:+TraceClassLoading可以在Product版的虚拟机中使用，-XX:+TraceClassUnLoading参数需要FastDebug版的虚拟机支持。</p><p>&emsp;&emsp;在大量使用反射、动态反射、CGLib等ByteCode框架、动态生成JSP以及OSGi这类频繁自定义ClassLoader的场景都需要虚拟机具备类卸载的功能，以保证永久代不会溢出。</p><hr><p><em>参考博客和文章书籍等：</em></p><blockquote><p>《深入理解Java虚拟机》</p></blockquote><p><em>因博客主等未标明不可引用，若部分内容涉及侵权请及时告知，我会尽快修改和删除相关内容</em></p>]]></content>
    
    <summary type="html">
    
      简单介绍Java虚拟机中的垃圾收集器，包括：引用计数算法，可达性分析算法，引用，对象判断生死过程，回收方法区等。
    
    </summary>
    
      <category term="技术文档" scheme="http://linyishui.top/categories/%E6%8A%80%E6%9C%AF%E6%96%87%E6%A1%A3/"/>
    
    
      <category term="java" scheme="http://linyishui.top/tags/java/"/>
    
      <category term="jvm" scheme="http://linyishui.top/tags/jvm/"/>
    
  </entry>
  
  <entry>
    <title>Java虚拟机中程序执行过程</title>
    <link href="http://linyishui.top/2019090901.html"/>
    <id>http://linyishui.top/2019090901.html</id>
    <published>2019-09-09T06:37:37.000Z</published>
    <updated>2019-10-24T10:28:19.017Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="类加载过程"><a href="#类加载过程" class="headerlink" title="类加载过程"></a><strong>类加载过程</strong></h1><h2 id="引文"><a href="#引文" class="headerlink" title="引文"></a><strong>引文</strong></h2><p>&emsp;&emsp;在Java语言里，<strong>new表达式</strong>是负责创建实例的，调用<strong>构造器</strong>去对实例做初始化；构造器自身的返回值类型是void，并不是“构造器返回了新创建的对象的引用”，而是new表达式的值是新创建的对象的引用。</p><p>&emsp;&emsp;对应的，在JVM里，“new”字节码指令只负责把实例创建出来（包括分配空间、设定类型、所有字段设置默认值等工作），并且把指向新创建对象的引用压到操作数栈顶。此时该引用还不能直接使用，处于未初始化状态（uninitialized）；如果某方法a含有代码试图通过未初始化状态的引用来调用任何实例方法，那么方法a会通不过JVM的字节码校验，从而被JVM拒绝执行。</p><p>&emsp;&emsp;能对未初始化状态的引用做的唯一一种事情就是通过它调用实例构造器，在Class文件层面表现为特殊初始化方法“&lt; init &gt;”。实际调用的指令是invokespecial，而在实际调用前要把需要的参数按顺序压到操作数栈上。在上面的字节码例子中，压参数的指令包括dup和ldc两条，分别把隐藏参数（新创建的实例的引用，对于实例构造器来说就是“this”）与显式声明的第一个实际参数（”ab”常量的引用）压到操作数栈上。<br>在构造器返回之后，新创建的实例的引用就可以正常使用了。</p><h3 id="举例分析"><a href="#举例分析" class="headerlink" title="举例分析"></a><strong>举例分析</strong></h3><p>&emsp;&emsp;假设我们要运行Test类，首先虚拟机启动，尝试执行main方法发现类还未加载，即虚拟机还未包含Test类的二进制表示。加载过程通过引导类加载器查找.class并加载Test类。</p><p>&emsp;&emsp;Test类加载后，在调用main之前需要先进行初始化。所有的类或接口在初始化前要先进行链接。链接包括校验、准备和可选的解析。</p><p>&emsp;&emsp;校验阶段会检查被加载的Test类是否良构，是否具有正确的符号表，代码是否遵循Java编程语言和虚拟机的语义要求。</p><p>&emsp;&emsp;准备阶段涉及到静态存储的内存分配，以及所有在Java虚拟机的实现内部需要使用的数据结构的内存分配，比如方法表。</p><p>&emsp;&emsp;解析是检查Test中对其他类和接口的符号引用的过程，通过加载提及的其他类和接口来检查这些引用是否正确。可以选择非常早的解析也可以选择在符号引用被实际使用时再解析。</p><p>&emsp;&emsp;接着进入初始化过程，初始化顺序有所有的类变量初始化器和静态初始化器按行文顺序构成。要求直接超类的初始化顺序必须先于子类。</p><p>&emsp;&emsp;最后，完成初始化后Test类的main方法才会被调用。要求main函数必须声明为：public static void，且必须指定类型为String数组的形式参数。</p><figure class="highlight arduino"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> main(<span class="keyword">String</span>[] args)</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> main(<span class="keyword">String</span>... args)</span><br></pre></td></tr></table></figure><hr><h2 id="第一节-虚拟机启动"><a href="#第一节-虚拟机启动" class="headerlink" title="第一节 虚拟机启动"></a><strong>第一节 虚拟机启动</strong></h2><p>&emsp;&emsp;<strong>虚拟机的启动</strong>是通过加载指定的类，然后调用指定类中main方法。</p><p>&emsp;&emsp;Java虚拟机会动态的加载、链接与初始化类和接口。</p><blockquote><ul><li>加载是根据特定名称查找类或接口类型的二进制表示(.class)，并由二进制表示来创建类或接口的过程。</li><li>链接是为了让类或接口可以被Java虚拟机执行，而将类或接口并入虚拟机运行时状态的过程。</li><li>类或接口的初始化是指执行类或接口的初始化方法&lt; clinit &gt;</li></ul></blockquote><hr><h2 id="第二节-加载过程"><a href="#第二节-加载过程" class="headerlink" title="第二节 加载过程"></a><strong>第二节 加载过程</strong></h2><p>&emsp;&emsp;<strong>加载</strong>是指查找到具有特定名的类或接口类型的二进制形式的过程。</p><p>&emsp;&emsp;典型实现：获取之前由Java编译器对源代码进行计算产生的二进制表示，从该二进制形式中构建表示该类或接口的Class对象。二进制格式通常是.class文件格式，但也可以是其他满足虚拟机要求的格式。ClassLoader类的defineClass方法可以被用来从class文件格式的二进制表示中构建Class对象。</p><p>&emsp;&emsp;<strong>加载过程</strong>是由ClassLoader类以及其子类实现的。不同子类可以实现不同的加载策略，类加载器可以缓存类或接口的二进制表示、基于预期使用而预抓取它们，以及一起加载有关联的一组类。</p><p>&emsp;&emsp;类加载过程产生了错误，会抛出LinkageError子类(ClassCircularityError，ClassFormatError，NotClassDefFoundError)之一的异常。因为加载涉及到对新数据结构分配内存，所以有可能会抛出OutOfMemoryError。</p><blockquote><p>&emsp;&emsp;创建一个标记为N的类或接口C，首先虚拟机要在方法区上为C创建与虚拟机中实现匹配的内部表示，C的创建可以由另一个类或接口D触发，其运行时常量池引用了C，也可以由D调用反射等方法触发。(数组类直接由Java虚拟机创建，其没有外部的.class二进制表示，非数组类则由类加载器加载.class来创建)</p><p>&emsp;&emsp;虚拟机首先检查加载器L是否被记录为N的初始加载器，如果是则这次尝试创建操作无效，且加载动作会抛出异常LinkageError；如果不是，虚拟机尝试解析.class文件。解析阶段的异常先省略，解析C的直接父类或直接父接口省略。虚拟机标记C的定义类加载器为L，并记录L是C的初始加载器。</p></blockquote><hr><h2 id="第三节-链接过程"><a href="#第三节-链接过程" class="headerlink" title="第三节 链接过程"></a><strong>第三节 链接过程</strong></h2><p>&emsp;&emsp;<strong>链接</strong>是指获取类或接口类型的二进制形式，并将其与Java虚拟机的运行时状态结合起来，使其可以被执行的过程。</p><blockquote><p>链接涉及三种不同的行为：</p><ul><li>校验</li><li>准备</li><li>符号引用的解析</li></ul></blockquote><p>&emsp;&emsp;因为链接涉及到对新数据结构分配内存，所以有可能会抛出OutOfMemoryError。</p><blockquote><p>&emsp;&emsp;链接包括验证和准备类或接口、其直接父类、其直接父接口、其元素类型。解析这个类或接口中的符号引用是链接过程的可选部分，虚拟机可以选择在用到符号引用时再去解析(延迟解析)，或者验证类时就解析每个引用(预先解析)。要求类或接口链接前必须被成功的加载过，初始化之前必须被成功的验证和准备过。</p></blockquote><h3 id="校验"><a href="#校验" class="headerlink" title="校验"></a><strong>校验</strong></h3><p>&emsp;&emsp;校验可以保证类或接口的二进制表示在结构上正确。如果校验过程发生错误，会抛出LinkageError的子类VerifyError的异常。</p><blockquote><p>&emsp;&emsp;验证过程可能会使其他类或接口被加载，但未必需要验证或准备他们。</p></blockquote><h3 id="准备"><a href="#准备" class="headerlink" title="准备"></a><strong>准备</strong></h3><p>&emsp;&emsp;准备包括创建类或接口的static域(类变量和类常量)和将这些域初始化为缺省值，不需要执行任何源代码，或者说虚拟机字节码指令，静态域的显式初始化器会作为初始化过程的一部分而执行，而不是准备过程的一部分。</p><blockquote><p>Java虚拟机的实现可以在准备阶段预计算额外的数据结构，以使后续对此类或接口的操作更加高效，特别有用的“方法表”或其他具有相同功能的数据结构，允许在类的实例上调用任何方法而无需在调用时搜索其超类。</p></blockquote><h3 id="解析"><a href="#解析" class="headerlink" title="解析"></a><strong>解析</strong></h3><p>&emsp;&emsp;类或接口的二进制表示会使用其他类或接口的二进制名字来以符号方式引用其他类或接口，以及它们的域、方法和构造器。这些符号引用包括域和方法所属的类或接口类型的名字、域和方法自身的名字，以及恰当的类型信息。</p><blockquote><p>符号引用：一组符号描述锁引用的目标，如CONSTANT_XX_info等常量。其引用目标未必加载到内存中。在编译阶段时，类的实际地址还未可知，所以只能用符号引用来代替。</p><p>直接引用：可以是直接指向目标的指针，相对偏移量，一个能间接定位到目标的句柄。有了直接引用目标一定已经加载到内存了。</p></blockquote><p>&emsp;&emsp;在符号引用可以被使用前，它们必须先被解析，在解析时会检查符号引用是否正确，并且在典型情况下，若某个符号引用被重复的使用，那么它会被可以更高效处理的直接引用所替代。</p><p>&emsp;&emsp;如果在解析过程中发生错误，会抛出IncompatibleClassChangeError或其子类(IllegalAccessError，InstantiationError，NoSuchFieldError，NoSuchMethodError)之一。如果一个类声明了一个native方法，但找不到此方法的实现，就会抛出LinkageError的子类UnsatisfiedLinkError。</p><blockquote><p>&emsp;&emsp;<strong>解析</strong>是根据运行时常量池里的符号引用来动态决定具体指的过程，Java虚拟机通过一些指令将符号引用指向运行时常量池，执行指令(anewarray,checkcast,getfield,getstatic,instanceof,invokedynamic,invokeinterface,invokespecial,invokestatic,invokevirtual,ldc,ldc_w,multianewarray,new,putfield,putstatic)需要对符号引用进行解析。对于除invokedynamic以外的指令，碰到此指令并解析它的符号引用后，表示对其他指令相同的符号引用已被解析过了。各种符号引用的解析过程先省略。</p></blockquote><hr><h2 id="第四节-初始化过程"><a href="#第四节-初始化过程" class="headerlink" title="第四节 初始化过程"></a><strong>第四节 初始化过程</strong></h2><p>&emsp;&emsp;类的初始化包括执行其静态初始化器和执行用于在类中声明的static域(类变量)的初始化器。接口的初始化包括执行用于在接口中声明的域(常量)的初始化器。在类被初始化之前，其直接超类必须先被初始化，但该类实现的接口并没有初始化，类似的，接口的超接口在该接口被初始化之前，还没有被初始化。</p><p>&emsp;&emsp;</p><blockquote><p>&emsp;&emsp;初始化对于类或接口就是执行其初始化方法，只有以下指令会导致初始化：new，getstatic，putstatic，invokestatic。这些指令都会通过字段或方法引用来直接或间接引用某个类。执行new指令时，若指令引用的类或接口没初始化则进行初始化。在初始化以前，类或接口必须已经被链接过，即经过了验证和准备阶段，可能已经解析过了。</p></blockquote><blockquote><p>以下情况第一次方式时，类或接口类型T会在紧靠此时刻之前被初始化：</p><ul><li>T是类，并且创建了T的实例</li><li>T是类，并且T声明的static方法被调用</li><li>T声明的static域被赋值</li><li>T声明的static域被使用，并且该域不是常量变量</li><li>T是顶层类，并且在词法上嵌套在T内的assert语句被执行</li></ul></blockquote><p>&emsp;&emsp;对static域的引用只会导致实际声明它的类或接口被初始化，即使它可能是通过子类名、子接口名或实现了某个接口的类名而被引用的。</p><p>&emsp;&emsp;对Class类中和java.lang.reflect包中的某些反射方法的调用也会导致类和接口被初始化。</p><p>&emsp;&emsp;其他任何情况都不会使类或接口被初始化。</p><h3 id="实例-超类在子类之前被初始化"><a href="#实例-超类在子类之前被初始化" class="headerlink" title="实例 超类在子类之前被初始化"></a><strong>实例 超类在子类之前被初始化</strong></h3><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Super</span> </span>&#123;</span><br><span class="line">    <span class="keyword">static</span> &#123; System.out.<span class="built_in">print</span>(<span class="string">"Super "</span>); &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">One</span> </span>&#123;</span><br><span class="line">    <span class="keyword">static</span> &#123; System.out.<span class="built_in">print</span>(<span class="string">"One "</span>); &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Two</span> <span class="keyword">extends</span> <span class="title">Super</span> </span>&#123;</span><br><span class="line">    <span class="keyword">static</span> &#123; System.out.<span class="built_in">print</span>(<span class="string">"Two "</span>); &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Test</span> </span>&#123;</span><br><span class="line">    public <span class="keyword">static</span> <span class="keyword">void</span> main(<span class="built_in">String</span>[] args) &#123;</span><br><span class="line">        One o = <span class="keyword">null</span>;</span><br><span class="line">        Two t = <span class="keyword">new</span> Two();</span><br><span class="line">        System.out.<span class="built_in">print</span>((<span class="built_in">Object</span>) o == (<span class="built_in">Object</span>) t);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>&emsp;&emsp;结果输出如下。类One永远不会初始化，因此永远不会被链接。类Two只有在其超类Super被初始化之后才会被初始化。</p><figure class="highlight gradle"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">Super</span> Two <span class="keyword">false</span></span><br></pre></td></tr></table></figure><h3 id="实例-只有声明static域的类才会被初始化"><a href="#实例-只有声明static域的类才会被初始化" class="headerlink" title="实例 只有声明static域的类才会被初始化"></a><strong>实例 只有声明static域的类才会被初始化</strong></h3><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Super</span> </span>&#123;</span><br><span class="line">    static int taxi = <span class="number">1729</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Sub</span> <span class="keyword">extends</span> <span class="title">Super</span> </span>&#123;</span><br><span class="line">    static &#123; <span class="type">System</span>.out.print(<span class="string">"Sub "</span>); &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Test</span> </span>&#123;</span><br><span class="line">    public static void main(<span class="type">String</span>[] args) &#123;</span><br><span class="line">        <span class="type">System</span>.out.print(<span class="type">Sub</span>.taxi);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>&emsp;&emsp;结果输出如下。因为Sub类永远没有被初始化，对Sub.taxi的引用实际上是对在Super类中声明的域的引用，它不会触发对Sub类的初始化。</p><figure class="highlight lsl"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">1729</span></span><br></pre></td></tr></table></figure><h3 id="实例-接口初始化不会初始化超接口"><a href="#实例-接口初始化不会初始化超接口" class="headerlink" title="实例 接口初始化不会初始化超接口"></a><strong>实例 接口初始化不会初始化超接口</strong></h3><figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">interface I &#123;</span><br><span class="line">    int i = 1, ii = Test.out(<span class="string">"ii"</span>,2);</span><br><span class="line">&#125;</span><br><span class="line">interface J extends I &#123;</span><br><span class="line">    int j = Test.out(<span class="string">"j"</span>,3), jj = Test.out(<span class="string">"jj"</span>,4);</span><br><span class="line">&#125;</span><br><span class="line">interface K extends J &#123;</span><br><span class="line">    int k = Test.out(<span class="string">"k"</span>,5);</span><br><span class="line">&#125;</span><br><span class="line">interface Test &#123;</span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        System.out.println(J.i);</span><br><span class="line">        System.out.println(K.j);</span><br><span class="line">    &#125;</span><br><span class="line">    static int out(String s, int i)&#123;</span><br><span class="line">        System.out.println(s + <span class="string">"="</span> + i);</span><br><span class="line">        return i;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>&emsp;&emsp;结果输出如下。J.i引用的域是一个常量变量，因此它不会使I被初始化。K.j引用的域实际上是在接口J中声明的，它不是常量变量，它会导致J接口的域被初始化，但超接口I中的域和接口K中的域都不会初始化。</p><p>&emsp;&emsp;尽管K被用来引用接口J中的域j，但接口K并不会被初始化。</p><figure class="highlight lsl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">1</span></span><br><span class="line">j=<span class="number">3</span></span><br><span class="line">jj=<span class="number">4</span></span><br><span class="line"><span class="number">3</span></span><br></pre></td></tr></table></figure><h3 id="详细的初始化过程"><a href="#详细的初始化过程" class="headerlink" title="详细的初始化过程"></a><strong>详细的初始化过程</strong></h3><p>&emsp;&emsp;暂缺，请参考《Java语言规范》12.4.2</p><hr><h2 id="第五节-创建新的类实例"><a href="#第五节-创建新的类实例" class="headerlink" title="第五节 创建新的类实例"></a><strong>第五节 创建新的类实例</strong></h2><p>&emsp;&emsp;暂缺，请参考《Java语言规范》12.5</p><hr><h2 id="第六节-类实例的终结"><a href="#第六节-类实例的终结" class="headerlink" title="第六节 类实例的终结"></a><strong>第六节 类实例的终结</strong></h2><p>&emsp;&emsp;暂缺，请参考《Java语言规范》12.6</p><hr><h2 id="第七节-卸载类和接口"><a href="#第七节-卸载类和接口" class="headerlink" title="第七节 卸载类和接口"></a><strong>第七节 卸载类和接口</strong></h2><p>&emsp;&emsp;暂缺，请参考《Java语言规范》12.7</p><hr><h2 id="第八节-程序退出"><a href="#第八节-程序退出" class="headerlink" title="第八节 程序退出"></a><strong>第八节 程序退出</strong></h2><p>&emsp;&emsp;暂缺，请参考《Java语言规范》12.8</p><hr><p><em>参考博客和文章书籍等：</em></p><blockquote><p>《Java语言规范》</p></blockquote><blockquote><p>《Java虚拟机规范》</p></blockquote><p><em>因博客主等未标明不可引用，若部分内容涉及侵权请及时告知，我会尽快修改和删除相关内容</em></p>]]></content>
    
    <summary type="html">
    
      简单介绍Java虚拟机中的程序执行过程，包括：虚拟机启动，举例分析，加载过程，链接过程，初始化过程，创建新的类实例，类实例的终结，卸载类和接口，程序退出等。
    
    </summary>
    
      <category term="技术文档" scheme="http://linyishui.top/categories/%E6%8A%80%E6%9C%AF%E6%96%87%E6%A1%A3/"/>
    
    
      <category term="java" scheme="http://linyishui.top/tags/java/"/>
    
      <category term="jvm" scheme="http://linyishui.top/tags/jvm/"/>
    
  </entry>
  
  <entry>
    <title>Git工作流</title>
    <link href="http://linyishui.top/2019090801.html"/>
    <id>http://linyishui.top/2019090801.html</id>
    <published>2019-09-08T06:26:04.000Z</published>
    <updated>2019-10-24T10:28:41.740Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><hr><p><em>参考博客和文章书籍等：</em></p><blockquote><p><a href="https://zhuanlan.zhihu.com/p/72769536" title="Title" target="_blank" rel="noopener">一种实用的 Git 工作流</a></p></blockquote><blockquote><p><a href="https://www.zhihu.com/question/20866683" title="Title" target="_blank" rel="noopener">如何优雅的使用 Git？</a></p></blockquote><blockquote><p><a href="https://v2ex.com/t/554218" title="Title" target="_blank" rel="noopener">请教大家 master 分支和 release 分支有什么区别</a></p></blockquote><!--https://www.zhihu.com/question/34540623高效阅读Github源代码(2)https://zhuanlan.zhihu.com/p/56435917盘点一下Github上开源的Java面试/学习相关的仓库https://zhuanlan.zhihu.com/p/53881873拒绝重复造轮子！GitHub推出新功能repository templateshttps://zhuanlan.zhihu.com/p/68492736什么样的 GitHub 可以写在简历上？https://zhuanlan.zhihu.com/p/58386954GitHub 上有哪些优秀的 Java 爬虫项目？https://www.zhihu.com/question/31427895--><p><em>因博客主等未标明不可引用，若部分内容涉及侵权请及时告知，我会尽快修改和删除相关内容</em></p>]]></content>
    
    <summary type="html">
    
      待整理一套比较适合当前工作和私人项目的Git工作流。
    
    </summary>
    
      <category term="技术文档" scheme="http://linyishui.top/categories/%E6%8A%80%E6%9C%AF%E6%96%87%E6%A1%A3/"/>
    
    
      <category term="git" scheme="http://linyishui.top/tags/git/"/>
    
  </entry>
  
  <entry>
    <title>A successful Git branching model-抠脚翻译</title>
    <link href="http://linyishui.top/2019090701.html"/>
    <id>http://linyishui.top/2019090701.html</id>
    <published>2019-09-07T10:24:04.000Z</published>
    <updated>2019-10-23T06:33:02.752Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><p><em>请一定要结合英文原文观看，以防误导。</em></p><h1 id="经典Git分支模型"><a href="#经典Git分支模型" class="headerlink" title="经典Git分支模型"></a><strong>经典Git分支模型</strong></h1><h2 id="前文"><a href="#前文" class="headerlink" title="前文"></a><strong>前文</strong></h2><p>&emsp;&emsp;文章主要介绍作者在撰文前一年左右在自己的项目中(包括工作和私下的)的开发模型，后续的事实证明真的很有成效。文章不会包含任何的项目相关信息，只会涉及分支策略和发布管理的内容。</p><p><img src="https://pic-1258215793.cos.ap-shanghai.myqcloud.com/content/20190801/201908010103.png" alt="Git分支图"></p><hr><h2 id="为什么选择Git"><a href="#为什么选择Git" class="headerlink" title="为什么选择Git"></a><strong>为什么选择Git</strong></h2><p>&emsp;&emsp;关于Git与集中式源码控制系统的优缺点的详尽讨论，可以参见<a href="http://git.or.cz/gitwiki/GitSvnComparsion" title="Title" target="_blank" rel="noopener">GitSvnComparsion</a>，那里有诸多的论战。</p><p>&emsp;&emsp;作为一名开发者，我更喜欢Git而不是其他任意一个工具。Git真正的改变了开发者对于合并和分支的认知，我来自于古老的CVS/Subversion世界，合并和分支一直被认为是有些可怕的(小心合并冲突，会让你头疼)和偶尔才会做一次的事情。</p><p>&emsp;&emsp;但是对于Git，这些操作变的十分简单和便捷，甚至被认为是日常工作流的核心部分之一。比如在一些CVS/Subversion的书籍中，合并和分支会在比较靠后的章节中才会初次讨论，属于进阶部分；而在Git书籍中却往往在第三章基础部分就已经出现了。</p><p>&emsp;&emsp;因为其简单性和重复性的特征，合并和分支不再是令人害怕的事情。版本控制工具应该在合并/分支上能相比其他工具提供更多的协助。</p><p>&emsp;&emsp;关于工具的介绍已经足够多了，接下来让我们进入开发模型部分。我将要介绍的模型本质上不过是一组流程，每一个团队成员都必须遵守这些流程才能进入到一个受管理的软件开发过程。</p><hr><h2 id="分散但又集中"><a href="#分散但又集中" class="headerlink" title="分散但又集中"></a><strong>分散但又集中</strong></h2><p>&emsp;&emsp;我们使用的仓库体制与这个分支模型能很好的结合在一起，就是使用一个中心”真实(truth)”仓库。需要注意的是，这个仓库只是被我们视为中央仓库(由于Git是DVCS-分布式版本控制系统，因此在技术层面上并没有中央仓库这个东西)。我们先用origin来指代这个仓库，这个名称对于所有Git用户都不会陌生。</p><p><img src="https://pic-1258215793.cos.ap-shanghai.myqcloud.com/content/20190801/201908010104.png" alt="子团队协作"></p><p>&emsp;&emsp;每个开发者会推送(push)和拉取(pull)到origin，但是除了集中控制的推拉关系外，每个开发者还可以从其他同伴那里拉取变更的内容从而组成了一个个子团队。例如，可能很有用的情况：两个或更多开发者一起工作开发一个新的大功能，这时将正在进行中的工作推送到origin可能会显得过早了。在上图中，有Alice和Bob, Alice和David，以及Clair和David的子团队。</p><p>&emsp;&emsp;从技术上讲，这意味着Alice定义了一个命名为bob的Git remote，指向Bob的仓库，反之亦然。</p><hr><h2 id="主分支"><a href="#主分支" class="headerlink" title="主分支"></a><strong>主分支</strong></h2><p>&emsp;&emsp;根本上讲，发展模式在很大程度上受到现有模式的启发。如中央仓库包括两个主要的分支，其生命周期为无限期。</p><ul><li>master</li><li>develop</li></ul><p><img src="https://pic-1258215793.cos.ap-shanghai.myqcloud.com/content/20190801/201908010105.png" alt="主分支"></p><p>&emsp;&emsp;每一个Git用户都很熟悉对应origin的master分支，还存在着另一个与master平行的分支叫做develop。</p><p>&emsp;&emsp;我们认为origin/master是HEAD指向的源码一直对应生产就绪状态(production-ready)的主要分支。</p><p>&emsp;&emsp;我们认为origin/develop是HEAD指向的源码一直对应为下一版本提供开发修改的最新一次交付的状态(production-ready)的主要分支，有些人会把它称为“整合分支”，这是所有每晚自动构建的基础。</p><p>&emsp;&emsp;当develop分支中的源码达到稳定点并准备发布时，所有的修改都应该以某种方式合并到master分支，然后用发布号标记。我们会在后面的内容再详细介绍这一部分。</p><p>&emsp;&emsp;因此，每次将修改合并回master分支时，根据定义这其实就是一个新的生产版本。我们通常会对此非常严格，因此理论上讲，每当有提交到master时，我们可以使用Git hook脚本自动构建和推送我们的软件到生产服务器上。</p><hr><h2 id="辅助分支"><a href="#辅助分支" class="headerlink" title="辅助分支"></a><strong>辅助分支</strong></h2><p>&emsp;&emsp;除了主分支master和develop以外，我们的开发模型还使用各种辅助分支以帮助团队成员之间进行并行开发，简化功能跟踪，为生产发布做准备，并协助快速解决生产中的实际问题。但与主分支不同的是这些分支的生命周期有限，最终都会被删除。</p><blockquote><p>我们可以使用的不同类型的分支包括：</p><ul><li>Feature branches 功能分支</li><li>Release branches 发布版本分支</li><li>Hotfix branches 热修复分支</li></ul></blockquote><p>&emsp;&emsp;这些分支中的每一个都有其特定的目的，并受严格的规则约束，包括哪些分支可能是其原始分支，哪些分支必须是其合并目标。我们会马上逐个的简单介绍它们。</p><p>&emsp;&emsp;从技术角度看，这些分支绝不是”特殊”的。分支类型是按照我们的使用方式进行的分类，它们本身仍然只是普通的Git分支。</p><h3 id="Feature分支"><a href="#Feature分支" class="headerlink" title="Feature分支"></a><strong>Feature分支</strong></h3><blockquote><p>可能源自于：develop</p><p>必须合并回：develop</p><p>分支命名约束：除了master, develop, release-<em>, or hotfix-</em></p></blockquote><p><img src="https://pic-1258215793.cos.ap-shanghai.myqcloud.com/content/20190801/201908010106.png" alt="Feature分支"></p><p>&emsp;&emsp;Feature分支(有时也叫主题分支-topic)用于为即将或较远未来发布的版本开发新的功能。当开始开发功能时，此功能将要被合并到的目标版本可能还未可得知。Feature分支的本质是只要功能还在开发中就会一直存在，但最终会合并回develop分支(以确保将新功能加入即将发布的版本)或直接丢弃(如果开发结果令人失望)。</p><p>&emsp;&emsp;Feature分支通常仅存在于开发人员的本地库中，而不会在origin远程库。</p><h4 id="创建一个Feature分支"><a href="#创建一个Feature分支" class="headerlink" title="创建一个Feature分支"></a><strong>创建一个Feature分支</strong></h4><p>&emsp;&emsp;在开始开发一个新功能时，请从develop分支中开启新的分支。</p><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ git checkout -<span class="selector-tag">b</span> myfeature develop</span><br><span class="line">Switched to <span class="selector-tag">a</span> new branch <span class="string">"myfeature"</span></span><br></pre></td></tr></table></figure><h4 id="将已完成分支合并入develop分支"><a href="#将已完成分支合并入develop分支" class="headerlink" title="将已完成分支合并入develop分支"></a><strong>将已完成分支合并入develop分支</strong></h4><p>&emsp;&emsp;已经完成的功能可以合并到develop分支，以确保会将它们添加到即将发布的版本。</p><figure class="highlight gams"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="symbol">$</span> git checkout develop</span><br><span class="line">Switched to branch <span class="string">'develop'</span></span><br><span class="line"><span class="symbol">$</span> git merge --<span class="keyword">no</span>-ff myfeature</span><br><span class="line"><span class="function"><span class="title">Updating</span></span> ea1b82a.<span class="number">.05e9557</span></span><br><span class="line">(Summary of changes)</span><br><span class="line"><span class="symbol">$</span> git branch -d myfeature</span><br><span class="line">Deleted branch myfeature (was <span class="number">05e9557</span>).</span><br><span class="line"><span class="symbol">$</span> git push origin develop</span><br></pre></td></tr></table></figure><p>&emsp;&emsp;–no-ff指令会使合并总会创建一个新的提交对象，即使合并可以通过fast-forward模式来执行。这样可以避免丢失Feature分支的历史信息，并将所有添加了功能的提交分组在一起。</p><p><img src="https://pic-1258215793.cos.ap-shanghai.myqcloud.com/content/20190801/201908010107.png" alt="对比"></p><p>&emsp;&emsp;在后一种情况下，很难从Git历史记录中看到那些提交对象一起实现了功能——你将不得不手动读取所有的日志信息。在后一种情况下，还原整个功能(即一组提交)确实很令人头疼，但如果使用–no-ff指令则可以很轻松的还原。</p><p>&emsp;&emsp;是的，这会创建更多的(空)提交对象，但收益远大于成本。</p><h3 id="release分支"><a href="#release分支" class="headerlink" title="release分支"></a><strong>release分支</strong></h3><blockquote><p>可能源自于：develop</p><p>必须合并回：develop 和 master</p><p>分支命名约束：release-*</p></blockquote><p>&emsp;&emsp;release分支为新的产品版本的发布准备提供支持，允许开发者在最后时刻进行细致的准备工作。此外允许进行小型错误的修复和准备版本的元数据(包括版本号、构建日期等)。</p><p>&emsp;&emsp;从develop分支分离出新的release分支的关键时刻是develop(差不多)对应上新版本的期望状态。至少在这个时间点上，所有针对待构建版本的功能必须合并到develop分支，所有针对未来版本的功能则可能不会——它们必须等到release分支分离出来。</p><p>&emsp;&emsp;正是在release分支的开始为即将发布的版本分配了版本号，较早则没有。直到这一刻，develop分支都对应着”下个版本”的修改，但是直到release分支开始之前，尚不清楚”下个版本”最终会变成0.3还是1.0。相关操作是在release分支开始才发生的，并且由项目的版本号bump规则来执行。</p><h4 id="创建一个release分支"><a href="#创建一个release分支" class="headerlink" title="创建一个release分支"></a><strong>创建一个release分支</strong></h4><p>&emsp;&emsp;release分支是从develop分支上创建的。比如，可以说版本1.1.5是当前的生产版本，我们会有一个大的版本更新即将发布。develop的状态已为”下个版本”准备就绪，我们决定将其确定为版本1.2(而不是1.1.6或2.0)。因此，我们创建了release分支，并通过版本号进行了命名。</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">$ git checkout -b <span class="keyword">release</span><span class="number">-1.2</span> develop</span><br><span class="line">Switched <span class="keyword">to</span> a <span class="keyword">new</span> branch <span class="string">"release-1.2"</span></span><br><span class="line">$ ./bump-version.sh <span class="number">1.2</span></span><br><span class="line">Files modified successfully, <span class="keyword">version</span> bumped <span class="keyword">to</span> <span class="number">1.2</span>.</span><br><span class="line">$ git <span class="keyword">commit</span> -a -m <span class="string">"Bumped version number to 1.2"</span></span><br><span class="line">[<span class="keyword">release</span><span class="number">-1.2</span> <span class="number">74</span>d9424] Bumped <span class="keyword">version</span> <span class="built_in">number</span> <span class="keyword">to</span> <span class="number">1.2</span></span><br><span class="line"><span class="number">1</span> files <span class="keyword">changed</span>, <span class="number">1</span> insertions(+), <span class="number">1</span> deletions(-)</span><br></pre></td></tr></table></figure><p>&emsp;&emsp;创建并切换到新的分支后，我们bump版本号。bump-version.sh在这里是一个虚构的shell脚本，它会修改一些工作副本的文件并映射到新的版本。当然这可以是一个手动更改——要点是某些文件会更改。然后提交bump版本号。</p><p>&emsp;&emsp;这个新分支可能已经存在了一定的时间，直到版本可以明确地发布出去。在此期间，一些Bug修复可能会应用在此分支上(而不是develop分支)。禁止在这个分支添加新的大型功能，它们必须合并到develop分支，因此需要等待下次大型版本更新。</p><h4 id="完成一个release分支"><a href="#完成一个release分支" class="headerlink" title="完成一个release分支"></a><strong>完成一个release分支</strong></h4><p>&emsp;&emsp;当release分支的状态就绪，并到真实发布阶段时，需要执行一些操作。首先，将release分支合并到master分支(记住，每次对master分支的提交都是一次新的发布)。然后，必须标记对master分支的提交，以便于将来比较容易的对这个历史版本的参考。最后，需要将release分支上的变更重新合并到develop分支，以便将来的发布版本也会包含这些Bug修复。</p><p>&emsp;&emsp;前两个Git步骤：</p><figure class="highlight crmsh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">$ git checkout <span class="literal">master</span></span><br><span class="line">Switched to branch '<span class="literal">master</span>'</span><br><span class="line">$ git merge --no-ff release-<span class="number">1.2</span></span><br><span class="line">Merge made by recursive.</span><br><span class="line">(Summary of changes)</span><br><span class="line">$ git <span class="keyword">tag</span> <span class="title">-a</span> <span class="number">1.2</span></span><br></pre></td></tr></table></figure><p>&emsp;&emsp;此发布版本现在已完成，并标记1.2以供将来参考。</p><blockquote><p>编辑：你可能也想使用 -s 或 -u &lt; key &gt;指令来对标记进行加密签名。</p></blockquote><p>&emsp;&emsp;为了保留release分支上所做的修改，我们仍需要将其合并回develop分支。</p><figure class="highlight livecodeserver"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">$ git checkout develop</span><br><span class="line">Switched <span class="built_in">to</span> branch <span class="string">'develop'</span></span><br><span class="line">$ git <span class="built_in">merge</span> <span class="comment">--no-ff release-1.2</span></span><br><span class="line">Merge made <span class="keyword">by</span> recursive.</span><br><span class="line">(Summary <span class="keyword">of</span> changes)</span><br></pre></td></tr></table></figure><p>&emsp;&emsp;这一步很可能导致合并冲突(非常可能发生，因为我们已经修改了版本号)。如果导致了合并冲突，请修复后再提交。</p><p>&emsp;&emsp;现在我们已经完成了工作，可以删除release分支了，不会再需要它了。</p><figure class="highlight arduino"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ git branch -d <span class="built_in">release</span><span class="number">-1.2</span></span><br><span class="line">Deleted branch <span class="built_in">release</span><span class="number">-1.2</span> (was ff452fe).</span><br></pre></td></tr></table></figure><h3 id="Hotfix分支"><a href="#Hotfix分支" class="headerlink" title="Hotfix分支"></a><strong>Hotfix分支</strong></h3><blockquote><p>可能源自于：master</p><p>必须合并回：develop 和 master</p><p>分支命名约束：hotfix-*</p></blockquote><p><img src="https://pic-1258215793.cos.ap-shanghai.myqcloud.com/content/20190801/201908010108.png" alt="Hotfix分支"></p><p>&emsp;&emsp;Hotfix分支非常像release分支，他们都为了新的版本发布做准备工作，尽管是未计划过的。他们源自于对未达到期望的实时生产版本的快速反应。当必须立刻解决生产版本中的严重Bug时，可以从master分支上对应生产版本的标记分离出一个Hotfix分支。</p><p>&emsp;&emsp;本质上当一个开发者在准备一个快速的生产修复时，其他团队成员可以继续工作(在develop分支上)。</p><h4 id="创建一个Hotfix分支"><a href="#创建一个Hotfix分支" class="headerlink" title="创建一个Hotfix分支"></a><strong>创建一个Hotfix分支</strong></h4><p>&emsp;&emsp;Hotfix分支是在master分支上创建的。比如，我们说当前正在运行的版本是1.2，并且因为严重的Bug造成了一些问题。而直接在develop分支上进行修改是不稳定的。所以我们会分离出一个Hotfix分支来解决问题。</p><figure class="highlight lsl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">$ git checkout -b hotfix<span class="number">-1.2</span><span class="number">.1</span> master</span><br><span class="line">Switched to a new branch <span class="string">"hotfix-1.2.1"</span></span><br><span class="line">$ ./bump-version.sh <span class="number">1.2</span><span class="number">.1</span></span><br><span class="line">Files modified successfully, version bumped to <span class="number">1.2</span><span class="number">.1</span>.</span><br><span class="line">$ git commit -a -m <span class="string">"Bumped version number to 1.2.1"</span></span><br><span class="line">[hotfix<span class="number">-1.2</span><span class="number">.1</span> <span class="number">41e61</span>bb] Bumped version number to <span class="number">1.2</span><span class="number">.1</span></span><br><span class="line"><span class="number">1</span> files <span class="section">changed</span>, <span class="number">1</span> insertions(+), <span class="number">1</span> deletions(-)</span><br></pre></td></tr></table></figure><p>&emsp;&emsp;在分离出分支后别忘了bump版本号。</p><p>&emsp;&emsp;然后，修复Bug并在一次或多次提交中提交所有修改内容。</p><figure class="highlight lsl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$ git commit -m <span class="string">"Fixed severe production problem"</span></span><br><span class="line">[hotfix<span class="number">-1.2</span><span class="number">.1</span> abbe5d6] Fixed severe production problem</span><br><span class="line"><span class="number">5</span> files <span class="section">changed</span>, <span class="number">32</span> insertions(+), <span class="number">17</span> deletions(-)</span><br></pre></td></tr></table></figure><h4 id="完成一个Hotfix分支"><a href="#完成一个Hotfix分支" class="headerlink" title="完成一个Hotfix分支"></a><strong>完成一个Hotfix分支</strong></h4><p>&emsp;&emsp;完成工作后，Bug修复需要合并回master分支，也需要合并回develop分支，以确保下一个版本更新也包括这些修复。这与release分支的完成过程非常类似。</p><p>&emsp;&emsp;首先，更新到master分支并标记版本。</p><figure class="highlight crmsh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">$ git checkout <span class="literal">master</span></span><br><span class="line">Switched to branch '<span class="literal">master</span>'</span><br><span class="line">$ git merge --no-ff hotfix-<span class="number">1.2</span>.<span class="number">1</span></span><br><span class="line">Merge made by recursive.</span><br><span class="line">(Summary of changes)</span><br><span class="line">$ git <span class="keyword">tag</span> <span class="title">-a</span> <span class="number">1.2</span>.<span class="number">1</span></span><br></pre></td></tr></table></figure><blockquote><p>编辑：你可能也想使用 -s 或 -u &lt; key &gt;指令来对标记进行加密签名。</p></blockquote><p>&emsp;&emsp;然后，也合并修复内容到develop分支。</p><figure class="highlight livecodeserver"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">$ git checkout develop</span><br><span class="line">Switched <span class="built_in">to</span> branch <span class="string">'develop'</span></span><br><span class="line">$ git <span class="built_in">merge</span> <span class="comment">--no-ff hotfix-1.2.1</span></span><br><span class="line">Merge made <span class="keyword">by</span> recursive.</span><br><span class="line">(Summary <span class="keyword">of</span> changes)</span><br></pre></td></tr></table></figure><p>&emsp;&emsp;此规则的一个例外是：<strong>当已存在一个release分支时，需要把修复内容合并到release分支，而不是develop分支</strong>。当release分支已经完成后，合并到release分支的修复内容最终也会合并到develop分支。(如果开发人员需要立即修复这些Bug，并且不能等到release分支完成，也可以安全的将修复内容合并到develop)</p><p>&emsp;&emsp;最后，删除临时分支。</p><figure class="highlight lsl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ git branch -d hotfix<span class="number">-1.2</span><span class="number">.1</span></span><br><span class="line">Deleted branch hotfix<span class="number">-1.2</span><span class="number">.1</span> (was abbe5d6).</span><br></pre></td></tr></table></figure><hr><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a><strong>总结</strong></h2><p>&emsp;&emsp;尽管这个分支模型并没有什么让人震惊的新东西，但本文开头的”全局图”在我们的项目中被证明是很有用的。它形成了一个易于理解的优雅的思维模型，并可以使团队成员对分支和发布过程形成一种共识。</p><p>&emsp;&emsp;此处提供了图片的高质量PDF版本，你可以把它挂在墙上，以便随时快速的参考。</p><p>&emsp;&emsp;更新：为一些提出要求的人：这里是主图表图片(Apple Keynote)的<a href="http://github.com/downloads/nvie/gitflow/Git-branching-model-src.key.zip" title="Title" target="_blank" rel="noopener">gitflow-model.src.key</a>。</p><p><a href="https://pic-1258215793.cos.ap-shanghai.myqcloud.com/content/20190801/Git-branching-model.pdf" target="_blank">Git-branching-model.pdf</a></p><hr><p><em>参考博客和文章书籍等：</em></p><blockquote><p><a href="https://nvie.com/posts/a-successful-git-branching-model/" title="Title" target="_blank" rel="noopener">A successful Git branching model</a></p></blockquote><p><em>因博客主等未标明不可引用，若部分内容涉及侵权请及时告知，我会尽快修改和删除相关内容</em></p>]]></content>
    
    <summary type="html">
    
      通过本人捉急的四六级英语水平，结合翻译工具和男性的第六感，翻译一篇比较经典的文章《A successful Git branching model》。
    
    </summary>
    
      <category term="技术文档" scheme="http://linyishui.top/categories/%E6%8A%80%E6%9C%AF%E6%96%87%E6%A1%A3/"/>
    
    
      <category term="git" scheme="http://linyishui.top/tags/git/"/>
    
  </entry>
  
  <entry>
    <title>stanford公开课sql基础题</title>
    <link href="http://linyishui.top/2019090601.html"/>
    <id>http://linyishui.top/2019090601.html</id>
    <published>2019-09-06T07:28:55.000Z</published>
    <updated>2019-10-28T12:12:44.357Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="sql基础题"><a href="#sql基础题" class="headerlink" title="sql基础题"></a><strong>sql基础题</strong></h1><h2 id="一、课件题目"><a href="#一、课件题目" class="headerlink" title="一、课件题目"></a><strong>一、课件题目</strong></h2><p>&emsp;&emsp;Suppose you’ve started a new movie-rating website, and you’ve been collecting data on reviewers’ ratings of various movies. There’s not much data yet, but you can still try out some interesting queries. Here’s the schema:  </p><p>&emsp;&emsp;Movie ( <u>mID</u>, title, year, director )  There is a movie with ID number mID, a title, a release year, and a director.  </p><p>&emsp;&emsp;Reviewer ( <u>rID</u>, name )  The reviewer with ID number rID has a certain name.  </p><p>&emsp;&emsp;Rating ( <u>rID</u>, <u>mID</u>, stars, ratingDate ) [rID, mID are foreign keys] The reviewer rID gave the movie mID a number of stars rating (1-5) on a certain ratingDate. </p><p>&emsp;&emsp;Write SQL statements to answer the following questions: </p><ol><li>Find the titles of all movies directed by Steven Spielberg.  </li><li>Find all years that have a movie that received a rating of 4 or 5, and sort them in increasing order of rating.  </li><li>Find the titles of all movies that have no ratings.  </li><li>Some reviewers didn’t provide a date with their rating. Find the names of all reviewers who have ratings with a NULL value for the date.  </li><li>Write a query to return the ratings data in a more readable format: reviewer name, movie title, stars, and ratingDate. </li><li>For all cases where the same reviewer rated the same movie twice and gave it a higher rating the second time, return the reviewer’s name and the title of the movie.  </li><li>For each movie that has at least one rating, find the highest number of stars that movie received. Return the movie title and number of stars. Sort by movie title. (hint: use GROUP BY)  </li><li>List movie titles and average ratings, from highest-rated to lowest-rated. If two or more movies have the same average rating, list them in alphabetical order.  </li><li>Find the names of all reviewers who have contributed three or more ratings.  </li><li>Find the names of all reviewers who rated Gone with the Wind. </li><li>For any rating where the reviewer is the same as the director of the movie, return the reviewer name, movie title, and number of stars. </li><li>Return all reviewer names and movie names together in a single column, alphabetized. (Sorting by the first name of the reviewer and first word in the title is fine; no need for special processing on last names or removing “The”.) </li><li>Find the titles of all movies not reviewed by Chris Jackson. </li><li>For all pairs of reviewers such that both reviewers gave a rating to the same movie, return the names of both reviewers. Eliminate duplicates, don’t pair reviewers with themselves, and include each pair only once. For each pair, return the names in the pair in alphabetical order. </li><li>For each rating that is the lowest (fewest stars) in the database, return the reviewer name, movie title, and number of stars of such ratings. </li><li>Find the reviewer who reviewed all movies. </li><li>Find the movies reviewed by Sarah Martinez and not reviewed by Chris Jackson. (hint: use NOT IN) </li><li>Find the movies that have been reviewed by at least two reviewers. Please write an SQL with only one SELECT and without GROUP BY. </li><li>Find the movies that have been reviewed by at least two reviewers. Please write an SQL with subquery. </li><li>Find the reviewers who do not review any movie. </li></ol><p>&emsp;&emsp;Note: When you use XAMPP+MySQL to check the correctness of your solution, please be noted that EXCEPT is not supported in MySQL.</p><h2 id="二、建表、数据"><a href="#二、建表、数据" class="headerlink" title="二、建表、数据"></a><strong>二、建表、数据</strong></h2><p>&emsp;&emsp;基于SqlServer。</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">--创建数据库</span></span><br><span class="line"><span class="keyword">create</span> <span class="keyword">database</span> standford;</span><br><span class="line"></span><br><span class="line"><span class="keyword">use</span> standford;</span><br><span class="line"></span><br><span class="line"><span class="comment">--创建表</span></span><br><span class="line"><span class="keyword">create</span> <span class="keyword">table</span> movie(</span><br><span class="line">    <span class="keyword">mid</span> <span class="built_in">int</span> primary <span class="keyword">key</span> ,</span><br><span class="line">    title <span class="built_in">varchar</span>(<span class="number">30</span>),</span><br><span class="line">    <span class="keyword">year</span> <span class="built_in">int</span>,</span><br><span class="line">    director <span class="built_in">varchar</span>(<span class="number">30</span>)</span><br><span class="line">);</span><br><span class="line"></span><br><span class="line"><span class="keyword">create</span> <span class="keyword">table</span> reviewer(</span><br><span class="line">    rid <span class="built_in">int</span> primary <span class="keyword">key</span> ,</span><br><span class="line">    <span class="keyword">name</span> <span class="built_in">varchar</span>(<span class="number">30</span>)</span><br><span class="line">);</span><br><span class="line"></span><br><span class="line"><span class="keyword">create</span> <span class="keyword">table</span> rating(</span><br><span class="line">    <span class="keyword">mid</span> <span class="built_in">int</span>,</span><br><span class="line">    rid <span class="built_in">int</span>,</span><br><span class="line">    stars <span class="built_in">int</span>,</span><br><span class="line">    ratingDate <span class="built_in">date</span></span><br><span class="line">);</span><br><span class="line"></span><br><span class="line"><span class="comment">--外键约束</span></span><br><span class="line"><span class="keyword">ALTER</span> <span class="keyword">TABLE</span> rating </span><br><span class="line">  <span class="keyword">WITH</span> <span class="keyword">CHECK</span> <span class="keyword">ADD</span> <span class="keyword">CONSTRAINT</span> fk_rating_movie_mid FOREIGN <span class="keyword">KEY</span> (<span class="keyword">mid</span>) <span class="keyword">references</span> movie(<span class="keyword">mid</span>);</span><br><span class="line"><span class="keyword">ALTER</span> <span class="keyword">TABLE</span> rating </span><br><span class="line">  <span class="keyword">WITH</span> <span class="keyword">CHECK</span> <span class="keyword">ADD</span> <span class="keyword">CONSTRAINT</span> fk_rating_reviewer_rid FOREIGN <span class="keyword">KEY</span> (rid) <span class="keyword">references</span> reviewer(rid);</span><br><span class="line"></span><br><span class="line"><span class="comment">--填充数据</span></span><br><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> movie(<span class="keyword">mid</span>,title,<span class="keyword">year</span>,director) <span class="keyword">values</span> (<span class="number">101</span>,<span class="string">'Gone with the Wind'</span>,<span class="number">1939</span>,<span class="string">'Victor Fleming'</span>);</span><br><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> movie(<span class="keyword">mid</span>,title,<span class="keyword">year</span>,director) <span class="keyword">values</span> (<span class="number">102</span>,<span class="string">'Star Wars'</span>,<span class="number">1977</span>,<span class="string">'George Lucas'</span>);</span><br><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> movie(<span class="keyword">mid</span>,title,<span class="keyword">year</span>,director) <span class="keyword">values</span> (<span class="number">103</span>,<span class="string">'The Sound of Music'</span>,<span class="number">1965</span>,<span class="string">'Robert Wise'</span>);</span><br><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> movie(<span class="keyword">mid</span>,title,<span class="keyword">year</span>,director) <span class="keyword">values</span> (<span class="number">104</span>,<span class="string">'E.T.'</span>,<span class="number">1982</span>,<span class="string">'Steven Spielberg'</span>);</span><br><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> movie(<span class="keyword">mid</span>,title,<span class="keyword">year</span>,director) <span class="keyword">values</span> (<span class="number">105</span>,<span class="string">'Titanic'</span>,<span class="number">1997</span>,<span class="string">'James Cameron'</span>);</span><br><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> movie(<span class="keyword">mid</span>,title,<span class="keyword">year</span>,director) <span class="keyword">values</span> (<span class="number">106</span>,<span class="string">'Snow White'</span>,<span class="number">1937</span>,<span class="literal">null</span>);</span><br><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> movie(<span class="keyword">mid</span>,title,<span class="keyword">year</span>,director) <span class="keyword">values</span> (<span class="number">107</span>,<span class="string">'Avatar'</span>,<span class="number">2009</span>,<span class="string">'James Cameron'</span>);</span><br><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> movie(<span class="keyword">mid</span>,title,<span class="keyword">year</span>,director) <span class="keyword">values</span> (<span class="number">108</span>,<span class="string">'Raiders of the Lost Ark'</span>,<span class="number">1981</span>,<span class="string">'Steven Spielberg'</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> reviewer(rid,<span class="keyword">name</span>) <span class="keyword">values</span> (<span class="number">201</span>,<span class="string">'Sarah Martinez'</span>);</span><br><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> reviewer(rid,<span class="keyword">name</span>) <span class="keyword">values</span> (<span class="number">202</span>,<span class="string">'Daniel Lewis'</span>);</span><br><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> reviewer(rid,<span class="keyword">name</span>) <span class="keyword">values</span> (<span class="number">203</span>,<span class="string">'Brittany Harris'</span>);</span><br><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> reviewer(rid,<span class="keyword">name</span>) <span class="keyword">values</span> (<span class="number">204</span>,<span class="string">'Mike Anderson'</span>);</span><br><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> reviewer(rid,<span class="keyword">name</span>) <span class="keyword">values</span> (<span class="number">205</span>,<span class="string">'Chris Jackson'</span>);</span><br><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> reviewer(rid,<span class="keyword">name</span>) <span class="keyword">values</span> (<span class="number">206</span>,<span class="string">'Elizabeth Thomas'</span>);</span><br><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> reviewer(rid,<span class="keyword">name</span>) <span class="keyword">values</span> (<span class="number">207</span>,<span class="string">'James Cameron'</span>);</span><br><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> reviewer(rid,<span class="keyword">name</span>) <span class="keyword">values</span> (<span class="number">208</span>,<span class="string">'Ashley White'</span>);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> rating(rid,<span class="keyword">mid</span>,stars,ratingDate) <span class="keyword">values</span> (<span class="number">201</span>,<span class="number">101</span>,<span class="number">2</span>,<span class="string">'2011-01-22'</span>);</span><br><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> rating(rid,<span class="keyword">mid</span>,stars,ratingDate) <span class="keyword">values</span> (<span class="number">201</span>,<span class="number">101</span>,<span class="number">4</span>,<span class="string">'2011-01-27'</span>);</span><br><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> rating(rid,<span class="keyword">mid</span>,stars,ratingDate) <span class="keyword">values</span> (<span class="number">202</span>,<span class="number">106</span>,<span class="number">4</span>,<span class="literal">null</span>);</span><br><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> rating(rid,<span class="keyword">mid</span>,stars,ratingDate) <span class="keyword">values</span> (<span class="number">203</span>,<span class="number">103</span>,<span class="number">2</span>,<span class="string">'2011-01-20'</span>);</span><br><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> rating(rid,<span class="keyword">mid</span>,stars,ratingDate) <span class="keyword">values</span> (<span class="number">203</span>,<span class="number">108</span>,<span class="number">4</span>,<span class="string">'2011-01-12'</span>);</span><br><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> rating(rid,<span class="keyword">mid</span>,stars,ratingDate) <span class="keyword">values</span> (<span class="number">203</span>,<span class="number">108</span>,<span class="number">2</span>,<span class="string">'2011-01-30'</span>);</span><br><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> rating(rid,<span class="keyword">mid</span>,stars,ratingDate) <span class="keyword">values</span> (<span class="number">204</span>,<span class="number">101</span>,<span class="number">3</span>,<span class="string">'2011-01-09'</span>);</span><br><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> rating(rid,<span class="keyword">mid</span>,stars,ratingDate) <span class="keyword">values</span> (<span class="number">205</span>,<span class="number">103</span>,<span class="number">3</span>,<span class="string">'2011-01-27'</span>);</span><br><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> rating(rid,<span class="keyword">mid</span>,stars,ratingDate) <span class="keyword">values</span> (<span class="number">205</span>,<span class="number">104</span>,<span class="number">2</span>,<span class="string">'2011-01-22'</span>);</span><br><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> rating(rid,<span class="keyword">mid</span>,stars,ratingDate) <span class="keyword">values</span> (<span class="number">205</span>,<span class="number">108</span>,<span class="number">4</span>,<span class="literal">null</span>);</span><br><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> rating(rid,<span class="keyword">mid</span>,stars,ratingDate) <span class="keyword">values</span> (<span class="number">206</span>,<span class="number">107</span>,<span class="number">3</span>,<span class="string">'2011-01-15'</span>);</span><br><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> rating(rid,<span class="keyword">mid</span>,stars,ratingDate) <span class="keyword">values</span> (<span class="number">206</span>,<span class="number">106</span>,<span class="number">5</span>,<span class="string">'2011-01-19'</span>);</span><br><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> rating(rid,<span class="keyword">mid</span>,stars,ratingDate) <span class="keyword">values</span> (<span class="number">207</span>,<span class="number">107</span>,<span class="number">5</span>,<span class="string">'2011-01-20'</span>);</span><br><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> rating(rid,<span class="keyword">mid</span>,stars,ratingDate) <span class="keyword">values</span> (<span class="number">208</span>,<span class="number">104</span>,<span class="number">3</span>,<span class="string">'2011-01-02'</span>);</span><br></pre></td></tr></table></figure><h2 id="三、作答"><a href="#三、作答" class="headerlink" title="三、作答"></a><strong>三、作答</strong></h2><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">--1. Find the titles of all movies directed by Steven Spielberg.  </span></span><br><span class="line"><span class="keyword">select</span> title</span><br><span class="line"><span class="keyword">from</span> movie</span><br><span class="line"><span class="keyword">where</span> director = <span class="string">'Steven Spielberg'</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">--2. Find all years that have a movie that received a rating of 4 or 5, and sort them in increasing order of rating.  </span></span><br><span class="line"><span class="keyword">select</span> <span class="keyword">year</span></span><br><span class="line"><span class="keyword">from</span> movie</span><br><span class="line"><span class="keyword">left</span> <span class="keyword">join</span> (<span class="keyword">select</span> <span class="keyword">max</span>(stars) <span class="keyword">as</span> maxStars,<span class="keyword">mid</span> <span class="keyword">from</span> rating <span class="keyword">group</span> <span class="keyword">by</span> <span class="keyword">mid</span>) maxRating</span><br><span class="line"><span class="keyword">on</span> movie.mid = maxRating.mid</span><br><span class="line"><span class="keyword">where</span> <span class="keyword">exists</span>(<span class="keyword">select</span> <span class="number">1</span> </span><br><span class="line">             <span class="keyword">from</span> rating</span><br><span class="line"> <span class="keyword">where</span> movie.mid = rating.mid</span><br><span class="line">   <span class="keyword">and</span> rating.stars <span class="keyword">in</span> (<span class="number">4</span>,<span class="number">5</span>))</span><br><span class="line"><span class="keyword">order</span> <span class="keyword">by</span> (<span class="keyword">select</span> <span class="keyword">max</span>(stars) <span class="keyword">from</span> rating <span class="keyword">where</span> movie.mid = rating.mid <span class="keyword">group</span> <span class="keyword">by</span> <span class="keyword">mid</span>),<span class="keyword">year</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">--对应</span></span><br><span class="line"><span class="keyword">select</span> *</span><br><span class="line"><span class="keyword">from</span> movie</span><br><span class="line"><span class="keyword">left</span> <span class="keyword">join</span> rating</span><br><span class="line"><span class="keyword">on</span> movie.mid = rating.mid</span><br><span class="line"><span class="keyword">left</span> <span class="keyword">join</span> (<span class="keyword">select</span> <span class="keyword">max</span>(stars) <span class="keyword">as</span> maxStars,<span class="keyword">mid</span> <span class="keyword">from</span> rating <span class="keyword">group</span> <span class="keyword">by</span> <span class="keyword">mid</span>) maxRating</span><br><span class="line"><span class="keyword">on</span> movie.mid = maxRating.mid</span><br><span class="line"><span class="keyword">where</span> rating.stars <span class="keyword">in</span> (<span class="number">4</span>,<span class="number">5</span>)</span><br><span class="line"><span class="keyword">order</span> <span class="keyword">by</span> maxStars,<span class="keyword">year</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">--3. Find the titles of all movies that have no ratings.  </span></span><br><span class="line"><span class="keyword">select</span> title</span><br><span class="line"><span class="keyword">from</span> movie</span><br><span class="line"><span class="keyword">where</span> <span class="keyword">not</span> <span class="keyword">exists</span>(<span class="keyword">select</span> <span class="number">1</span></span><br><span class="line">             <span class="keyword">from</span> rating</span><br><span class="line"> <span class="keyword">where</span> movie.mid = rating.mid);</span><br><span class="line"></span><br><span class="line"><span class="comment">--4. Some reviewers didn't provide a date with their rating. Find the names of all reviewers who have ratings with a NULL value for the date.  </span></span><br><span class="line"><span class="keyword">select</span> <span class="keyword">name</span></span><br><span class="line"><span class="keyword">from</span> reviewer</span><br><span class="line"><span class="keyword">where</span> <span class="keyword">exists</span>(<span class="keyword">select</span> <span class="number">1</span></span><br><span class="line">             <span class="keyword">from</span> rating</span><br><span class="line"> <span class="keyword">where</span> reviewer.rid = rating.rid</span><br><span class="line">   <span class="keyword">and</span> ratingDate <span class="keyword">is</span> <span class="literal">null</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">--5. Write a query to return the ratings data in a more readable format: reviewer name, movie title, stars, and ratingDate. </span></span><br><span class="line"><span class="keyword">select</span> reviewer.name <span class="keyword">as</span> reviewerName,</span><br><span class="line">       movie.title <span class="keyword">as</span> movieTitle,</span><br><span class="line">   rating.stars,</span><br><span class="line">   rating.ratingDate</span><br><span class="line"><span class="keyword">from</span> rating</span><br><span class="line"><span class="keyword">left</span> <span class="keyword">join</span> movie <span class="keyword">on</span> movie.mid = rating.mid</span><br><span class="line"><span class="keyword">left</span> <span class="keyword">join</span> reviewer <span class="keyword">on</span> reviewer.rid = rating.rid;</span><br><span class="line"></span><br><span class="line"><span class="comment">--6. For all cases where the same reviewer rated the same movie twice and gave it a higher rating the second time, return the reviewer's name and the title of the movie.  </span></span><br><span class="line"><span class="keyword">select</span> reviewer.name <span class="keyword">as</span> reviewerName,</span><br><span class="line">       movie.title <span class="keyword">as</span> movieTitle,ratingDate,stars</span><br><span class="line"><span class="keyword">from</span> rating</span><br><span class="line"><span class="keyword">left</span> <span class="keyword">join</span> movie <span class="keyword">on</span> movie.mid = rating.mid</span><br><span class="line"><span class="keyword">left</span> <span class="keyword">join</span> reviewer <span class="keyword">on</span> reviewer.rid = rating.rid</span><br><span class="line"><span class="keyword">left</span> <span class="keyword">join</span> (<span class="keyword">select</span> <span class="keyword">max</span>(ratingDate) <span class="keyword">as</span> maxDate,<span class="keyword">max</span>(stars) <span class="keyword">as</span> maxStars,<span class="keyword">mid</span>,rid</span><br><span class="line">           <span class="keyword">from</span> rating</span><br><span class="line">   <span class="keyword">group</span> <span class="keyword">by</span> <span class="keyword">mid</span>,rid) maxSelect</span><br><span class="line"><span class="keyword">on</span> rating.rid = maxSelect.rid <span class="keyword">and</span> rating.mid = maxSelect.mid</span><br><span class="line"><span class="keyword">where</span> rating.ratingDate = maxDate <span class="keyword">and</span> rating.stars = maxStars</span><br><span class="line">  <span class="keyword">and</span> <span class="keyword">exists</span>(<span class="keyword">select</span> <span class="number">1</span></span><br><span class="line">             <span class="keyword">from</span> rating r</span><br><span class="line">         <span class="keyword">group</span> <span class="keyword">by</span> <span class="keyword">mid</span>,rid</span><br><span class="line">         <span class="keyword">having</span> rating.rid = r.rid</span><br><span class="line">            <span class="keyword">and</span> rating.mid = r.mid</span><br><span class="line">            <span class="keyword">and</span> <span class="keyword">count</span>(*) = <span class="number">2</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">--7. For each movie that has at least one rating, find the highest number of stars that movie received. Return the movie title and number of stars. Sort by movie title. (hint: use GROUP BY)  </span></span><br><span class="line"><span class="keyword">select</span> movie.title,maxStars</span><br><span class="line"><span class="keyword">from</span> movie</span><br><span class="line"><span class="keyword">left</span> <span class="keyword">join</span> (<span class="keyword">select</span> <span class="keyword">max</span>(stars) <span class="keyword">as</span> maxStars,<span class="keyword">mid</span> <span class="keyword">from</span> rating <span class="keyword">group</span> <span class="keyword">by</span> <span class="keyword">mid</span>) maxRating</span><br><span class="line"><span class="keyword">on</span> movie.mid = maxRating.mid</span><br><span class="line"><span class="keyword">where</span> <span class="keyword">exists</span>(<span class="keyword">select</span> <span class="number">1</span> <span class="keyword">from</span> rating <span class="keyword">where</span> movie.mid = rating.mid <span class="keyword">group</span> <span class="keyword">by</span> <span class="keyword">mid</span> <span class="keyword">having</span> <span class="keyword">count</span>(*) &gt; <span class="number">0</span>)</span><br><span class="line"><span class="keyword">order</span> <span class="keyword">by</span> movie.title;</span><br><span class="line"></span><br><span class="line"><span class="comment">--8. List movie titles and average ratings, from highest-rated to lowest-rated. If two or more movies have the same average rating, list them in alphabetical order.  </span></span><br><span class="line"><span class="keyword">select</span> movie.title,<span class="keyword">AVG</span>(stars) <span class="keyword">as</span> avgStars</span><br><span class="line"><span class="keyword">from</span> rating</span><br><span class="line"><span class="keyword">left</span> <span class="keyword">join</span> movie <span class="keyword">on</span> movie.mid = rating.mid</span><br><span class="line"><span class="keyword">group</span> <span class="keyword">by</span> movie.mid,movie.title</span><br><span class="line"><span class="keyword">order</span> <span class="keyword">by</span> <span class="keyword">AVG</span>(stars) <span class="keyword">desc</span>,movie.title;</span><br><span class="line"></span><br><span class="line"><span class="comment">--9. Find the names of all reviewers who have contributed three or more ratings.  </span></span><br><span class="line"><span class="keyword">select</span> <span class="keyword">name</span></span><br><span class="line"><span class="keyword">from</span> reviewer</span><br><span class="line"><span class="keyword">where</span> <span class="keyword">exists</span>(<span class="keyword">select</span> <span class="number">1</span></span><br><span class="line">             <span class="keyword">from</span> rating</span><br><span class="line"> <span class="keyword">where</span> rating.rid = reviewer.rid</span><br><span class="line">         <span class="keyword">group</span> <span class="keyword">by</span> rid</span><br><span class="line"> <span class="keyword">having</span> <span class="keyword">count</span>(*) &gt; <span class="number">2</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">--10. Find the names of all reviewers who rated Gone with the Wind. </span></span><br><span class="line"><span class="keyword">select</span> <span class="keyword">name</span></span><br><span class="line"><span class="keyword">from</span> reviewer</span><br><span class="line"><span class="keyword">where</span> <span class="keyword">exists</span>(<span class="keyword">select</span> <span class="number">1</span></span><br><span class="line">             <span class="keyword">from</span> rating</span><br><span class="line"> <span class="keyword">left</span> <span class="keyword">join</span> movie <span class="keyword">on</span> rating.mid = movie.mid</span><br><span class="line"> <span class="keyword">where</span> rating.rid = reviewer.rid</span><br><span class="line">           <span class="keyword">and</span> title = <span class="string">'Gone with the Wind'</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">--11. For any rating where the reviewer is the same as the director of the movie, return the reviewer name, movie title, and number of stars. </span></span><br><span class="line"><span class="comment">--查询导演作为评论人的电影，返回评论人名和电影名</span></span><br><span class="line"><span class="keyword">select</span> <span class="keyword">distinct</span> reviewer.name <span class="keyword">as</span> reviewerName,</span><br><span class="line">       movie.title <span class="keyword">as</span> movieTitle</span><br><span class="line"><span class="keyword">from</span> rating</span><br><span class="line"><span class="keyword">left</span> <span class="keyword">join</span> movie <span class="keyword">on</span> movie.mid = rating.mid</span><br><span class="line"><span class="keyword">left</span> <span class="keyword">join</span> reviewer <span class="keyword">on</span> reviewer.rid = rating.rid</span><br><span class="line"><span class="keyword">where</span> reviewer.name = movie.director;</span><br><span class="line"></span><br><span class="line"><span class="comment">--12. Return all reviewer names and movie names together in a single column, alphabetized. (Sorting by the first name of the reviewer and first word in the title is fine; no need for special processing on last names or removing "The".) </span></span><br><span class="line"><span class="comment">--把所有评论人名和电影名放入一列返回，按评论人名和标题名首字母排序，不需要对姓氏进行特殊处理或删除“the”</span></span><br><span class="line"><span class="keyword">select</span> title <span class="keyword">from</span> movie</span><br><span class="line"><span class="keyword">union</span></span><br><span class="line"><span class="keyword">select</span> <span class="keyword">name</span> <span class="keyword">from</span> reviewer</span><br><span class="line"><span class="keyword">order</span> <span class="keyword">by</span> title;</span><br><span class="line"></span><br><span class="line"><span class="comment">--13. Find the titles of all movies not reviewed by Chris Jackson. </span></span><br><span class="line"><span class="comment">--查询所有未受Chris Jackson评论的电影名</span></span><br><span class="line"><span class="keyword">select</span> title</span><br><span class="line"><span class="keyword">from</span> movie</span><br><span class="line"><span class="keyword">where</span> <span class="keyword">not</span> <span class="keyword">exists</span>(<span class="keyword">select</span> <span class="number">1</span></span><br><span class="line">             <span class="keyword">from</span> rating</span><br><span class="line"> <span class="keyword">left</span> <span class="keyword">join</span> reviewer <span class="keyword">on</span> reviewer.rid = rating.rid</span><br><span class="line"> <span class="keyword">where</span> rating.mid = movie.mid</span><br><span class="line">           <span class="keyword">and</span> <span class="keyword">name</span> = <span class="string">'Chris Jackson'</span>); </span><br><span class="line"></span><br><span class="line"><span class="comment">--14. For all pairs of reviewers such that both reviewers gave a rating to the same movie, return the names of both reviewers. Eliminate duplicates, don't pair reviewers with themselves, and include each pair only once. For each pair, return the names in the pair in alphabetical order. </span></span><br><span class="line"><span class="comment">--当有两个评论人给同个电影评论时返回两个评论人名，删除重复项，按姓名排序</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">select</span> * </span><br><span class="line"><span class="keyword">from</span>(<span class="keyword">select</span> <span class="keyword">case</span> <span class="keyword">when</span> reviewer1.name &lt;= reviewer2.name <span class="keyword">then</span> reviewer1.name <span class="keyword">else</span> reviewer2.name <span class="keyword">end</span> a, <span class="comment">--去除顺序相关</span></span><br><span class="line">            <span class="keyword">case</span> <span class="keyword">when</span> reviewer1.name &lt;= reviewer2.name <span class="keyword">then</span> reviewer2.name <span class="keyword">else</span> reviewer1.name <span class="keyword">end</span> b</span><br><span class="line">            <span class="keyword">from</span> rating r1</span><br><span class="line">            <span class="keyword">join</span> reviewer reviewer1 <span class="keyword">on</span> r1.rid = reviewer1.rid</span><br><span class="line"><span class="keyword">join</span> rating r2 <span class="keyword">on</span> r1.mid = r2.mid <span class="keyword">and</span> r1.rid != r2.rid <span class="comment">--配对</span></span><br><span class="line"><span class="keyword">join</span> reviewer reviewer2 <span class="keyword">on</span> r2.rid = reviewer2.rid) m</span><br><span class="line"><span class="keyword">group</span> <span class="keyword">by</span> a,b <span class="comment">--分组去重</span></span><br><span class="line"><span class="keyword">order</span> <span class="keyword">by</span> a,b; <span class="comment">--按姓名排序</span></span><br><span class="line"></span><br><span class="line"><span class="comment">--顺序相关去重 select * from tb1 group by A, B having count(*) &gt;0;</span></span><br><span class="line"><span class="comment">--顺序不相关去重 select aa,bb from (select case when a&lt;=b then a else b end aa,case when a&lt;=b then b else a end bb from tbl) tt group by aa,bb;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">--15. For each rating that is the lowest (fewest stars) in the database, return the reviewer name, movie title, and number of stars of such ratings. </span></span><br><span class="line"><span class="comment">--查询库中的最低评分，返回评论人名，电影名和评分</span></span><br><span class="line"><span class="keyword">select</span> reviewer.name <span class="keyword">as</span> reviewerName,</span><br><span class="line">       movie.title <span class="keyword">as</span> movieTitle,</span><br><span class="line">   stars</span><br><span class="line"><span class="keyword">from</span> rating</span><br><span class="line"><span class="keyword">left</span> <span class="keyword">join</span> movie <span class="keyword">on</span> movie.mid = rating.mid</span><br><span class="line"><span class="keyword">left</span> <span class="keyword">join</span> reviewer <span class="keyword">on</span> reviewer.rid = rating.rid</span><br><span class="line"><span class="keyword">where</span> rating.stars = (<span class="keyword">select</span> <span class="keyword">min</span>(stars) <span class="keyword">from</span> rating);</span><br><span class="line"></span><br><span class="line"><span class="comment">--16. Find the reviewer who reviewed all movies. </span></span><br><span class="line"><span class="keyword">select</span> <span class="keyword">name</span></span><br><span class="line"><span class="keyword">from</span> reviewer</span><br><span class="line"><span class="keyword">where</span> (<span class="keyword">select</span> <span class="keyword">count</span>(*)</span><br><span class="line">       <span class="keyword">from</span> (<span class="keyword">SELECT</span> <span class="keyword">distinct</span> rid,<span class="keyword">mid</span></span><br><span class="line">             <span class="keyword">from</span> rating</span><br><span class="line">             <span class="keyword">where</span> reviewer.rid = rating.rid ) a ) <span class="comment">--统计当前用户观看电影数</span></span><br><span class="line">      = (<span class="keyword">select</span> <span class="keyword">count</span>(*) <span class="keyword">from</span> movie); <span class="comment">--统计电影总数</span></span><br><span class="line"></span><br><span class="line"><span class="comment">--17. Find the movies reviewed by Sarah Martinez and not reviewed by Chris Jackson. (hint: use NOT IN) </span></span><br><span class="line"><span class="comment">--查询Sarah Martinez有评论而Chris Jackson未评论的电影</span></span><br><span class="line"><span class="keyword">select</span> title</span><br><span class="line"><span class="keyword">from</span> movie</span><br><span class="line"><span class="keyword">where</span> <span class="keyword">mid</span> <span class="keyword">in</span> (<span class="keyword">select</span> <span class="keyword">mid</span> <span class="keyword">from</span> rating,reviewer <span class="keyword">where</span> rating.rid = reviewer.rid <span class="keyword">and</span> reviewer.name = <span class="string">'Sarah Martinez'</span>)</span><br><span class="line">  <span class="keyword">and</span> <span class="keyword">mid</span> <span class="keyword">not</span> <span class="keyword">in</span> (<span class="keyword">select</span> <span class="keyword">mid</span> <span class="keyword">from</span> rating,reviewer <span class="keyword">where</span> rating.rid = reviewer.rid <span class="keyword">and</span> reviewer.name = <span class="string">'Chris Jackson'</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">--18. Find the movies that have been reviewed by at least two reviewers. Please write an SQL with only one SELECT and without GROUP BY. </span></span><br><span class="line"><span class="keyword">select</span> <span class="keyword">distinct</span> a.mid</span><br><span class="line"><span class="keyword">from</span> rating <span class="keyword">as</span> a</span><br><span class="line"><span class="keyword">join</span> rating <span class="keyword">as</span> b </span><br><span class="line"><span class="keyword">on</span> a.mid = b.mid </span><br><span class="line"><span class="keyword">and</span> a.rid != b.rid;</span><br><span class="line"></span><br><span class="line"><span class="comment">--19. Find the movies that have been reviewed by at least two reviewers. Please write an SQL with subquery. </span></span><br><span class="line"><span class="keyword">select</span> <span class="keyword">mid</span>,title</span><br><span class="line"><span class="keyword">from</span> movie</span><br><span class="line"><span class="keyword">where</span> (<span class="keyword">select</span> <span class="keyword">count</span>(*) <span class="keyword">from</span> rating <span class="keyword">where</span> movie.mid = rating.mid) &gt; <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">--20. Find the reviewers who do not review any movie. </span></span><br><span class="line"><span class="keyword">select</span> <span class="keyword">name</span></span><br><span class="line"><span class="keyword">from</span> reviewer</span><br><span class="line"><span class="keyword">where</span> (<span class="keyword">select</span> <span class="keyword">count</span>(*) <span class="keyword">from</span> rating <span class="keyword">where</span> reviewer.rid = rating.rid) = <span class="number">0</span>;</span><br></pre></td></tr></table></figure><h2 id="四、答案"><a href="#四、答案" class="headerlink" title="四、答案"></a><strong>四、答案</strong></h2><figure class="highlight vbnet"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">1.</span><span class="keyword">SELECT</span> <span class="keyword">DISTINCT</span> title <span class="keyword">FROM</span> movie <span class="keyword">Where</span> director=<span class="comment">'Steven Spielberg';</span></span><br><span class="line"></span><br><span class="line"><span class="number">2.</span><span class="keyword">SELECT</span> <span class="keyword">DISTINCT</span> Year,stars <span class="keyword">From</span> movie, rating <span class="keyword">WHERE</span> movie.<span class="keyword">mID</span>=rating.<span class="keyword">mID</span> <span class="keyword">and</span> (rating.stars = <span class="number">4</span> <span class="keyword">OR</span> rating.stars= <span class="number">5</span>) <span class="keyword">ORDER</span> <span class="keyword">BY</span> rating.stars ASC;</span><br><span class="line"></span><br><span class="line"><span class="number">3.</span><span class="keyword">SELECT</span> <span class="keyword">DISTINCT</span> title <span class="keyword">from</span> movie <span class="keyword">where</span> <span class="keyword">mID</span> <span class="keyword">not</span> <span class="keyword">in</span> (<span class="keyword">SELECT</span> <span class="keyword">mID</span> <span class="keyword">from</span> rating )</span><br><span class="line">(mysql does <span class="keyword">not</span> support except)(<span class="keyword">SELECT</span> title <span class="keyword">FROM</span> movie) EXCEPT (<span class="keyword">SELECT</span> title <span class="keyword">FROM</span> movie, rating  <span class="keyword">WHERE</span> movie.<span class="keyword">mID</span> = rating.<span class="keyword">mID</span>)</span><br><span class="line"></span><br><span class="line"><span class="number">4.</span><span class="keyword">SELECT</span> <span class="keyword">DISTINCT</span> Name <span class="keyword">FROM</span> reviewer, rating <span class="keyword">WHERE</span> reviewer.rID=rating.rID <span class="keyword">and</span> rating.ratingDate <span class="keyword">is</span> null;</span><br><span class="line"></span><br><span class="line"><span class="number">5.</span><span class="keyword">SELECT</span> <span class="keyword">DISTINCT</span> name, title, stars, ratingDate <span class="keyword">FROM</span> movie, rating, reviewer <span class="keyword">WHERE</span> movie.<span class="keyword">mID</span> = rating.<span class="keyword">mID</span> <span class="keyword">AND</span> reviewer.rID = rating.rID;</span><br><span class="line"><span class="number">5.</span><span class="keyword">SELECT</span> <span class="keyword">DISTINCT</span> name, title, stars, ratingDate <span class="keyword">FROM</span> movie <span class="keyword">join</span> rating <span class="keyword">join</span> reviewer <span class="keyword">ON</span> movie.<span class="keyword">mID</span> = rating.<span class="keyword">mID</span> <span class="keyword">AND</span> reviewer.rID = rating.rID;</span><br><span class="line"></span><br><span class="line"><span class="number">6.</span><span class="keyword">SELECT</span> <span class="keyword">DISTINCT</span> name, title <span class="keyword">From</span> movie , reviewer, rating, rating <span class="keyword">as</span> rating2 <span class="keyword">WHERE</span> rating.<span class="keyword">mID</span>=movie.<span class="keyword">mID</span> <span class="keyword">and</span> reviewer.rID=rating.rID <span class="keyword">and</span> rating.rID=rating2.rID <span class="keyword">and</span> rating.<span class="keyword">mID</span> = rating2.<span class="keyword">mID</span> <span class="keyword">and</span> rating.stars&lt;rating2.stars <span class="keyword">and</span> rating.ratingDate&lt;rating2.ratingDate;</span><br><span class="line"></span><br><span class="line"><span class="number">7.</span><span class="keyword">SELECT</span> <span class="keyword">DISTINCT</span> title , MAX(stars) <span class="keyword">From</span> movie,rating <span class="keyword">WHERE</span> movie.<span class="keyword">mID</span>=rating.<span class="keyword">mID</span> <span class="keyword">GROUP</span> <span class="keyword">BY</span> movie.<span class="keyword">mID</span> <span class="keyword">Order</span> <span class="keyword">by</span> movie.title;</span><br><span class="line"></span><br><span class="line"><span class="number">8.</span><span class="keyword">SELECT</span> <span class="keyword">DISTINCT</span> title, AVG (stars) <span class="keyword">from</span> movie, rating <span class="keyword">WHERE</span> movie.<span class="keyword">mID</span> = rating.<span class="keyword">mID</span> <span class="keyword">GROUP</span> <span class="keyword">BY</span> title <span class="keyword">ORDER</span> <span class="keyword">BY</span> AVG (stars) DESC, title ASC;</span><br><span class="line"></span><br><span class="line"><span class="number">9.</span><span class="keyword">SELECT</span> <span class="keyword">DISTINCT</span> name <span class="keyword">From</span> ((<span class="keyword">SELECT</span> reviewer.name, count(rating.<span class="keyword">mID</span>) <span class="keyword">From</span> reviewer, rating <span class="keyword">Where</span> reviewer.rID = rating.rID <span class="keyword">Group</span> <span class="keyword">by</span> reviewer.rID Having count(rating.<span class="keyword">mID</span>) &gt; <span class="number">2</span>) <span class="keyword">as</span> r);</span><br><span class="line"><span class="number">9.</span><span class="keyword">SELECT</span> <span class="keyword">DISTINCT</span> name <span class="keyword">From</span> rating <span class="keyword">as</span> r1, rating <span class="keyword">as</span> r2, rating <span class="keyword">as</span> r3, reviewer <span class="keyword">where</span> reviewer.rID=r1.rID <span class="keyword">and</span> r1.rID = r2.rID <span class="keyword">and</span> r2.rID = r3.rID <span class="keyword">and</span> (r1.<span class="keyword">mID</span> &lt;&gt; r2.<span class="keyword">mID</span> <span class="keyword">or</span> r1.ratingDate&lt;&gt;r2.ratingDate) <span class="keyword">and</span> (r2.<span class="keyword">mID</span>&lt;&gt;r3.<span class="keyword">mID</span> <span class="keyword">or</span> r2.ratingDate&lt;&gt;r3.ratingDate) <span class="keyword">and</span> (r1.<span class="keyword">mID</span>&lt;&gt; r3.<span class="keyword">mID</span> <span class="keyword">or</span> r1.ratingDate&lt;&gt;r3.ratingDate);</span><br><span class="line"></span><br><span class="line"><span class="number">10.</span><span class="keyword">SELECT</span> <span class="keyword">DISTINCT</span> name <span class="keyword">From</span> movie, reviewer, rating <span class="keyword">Where</span> movie.<span class="keyword">mID</span>=rating.<span class="keyword">mID</span> <span class="keyword">and</span> reviewer.rID=rating.rID <span class="keyword">and</span> movie.title=<span class="comment">'Gone with the Wind';</span></span><br><span class="line"></span><br><span class="line"><span class="number">11.</span><span class="keyword">SELECT</span> <span class="keyword">DISTINCT</span> name, stars, title <span class="keyword">From</span> movie, reviewer, rating <span class="keyword">Where</span> reviewer.name=movie.director <span class="keyword">AND</span> movie.<span class="keyword">mID</span>=rating.<span class="keyword">mID</span> <span class="keyword">and</span> reviewer.rID=rating.rID;</span><br><span class="line"></span><br><span class="line"><span class="number">12.</span><span class="keyword">SELECT</span> <span class="keyword">DISTINCT</span> name <span class="keyword">From</span> (<span class="keyword">SELECT</span> name <span class="keyword">From</span> reviewer Union <span class="keyword">SELECT</span> title <span class="keyword">as</span> name <span class="keyword">From</span> movie) <span class="keyword">as</span> a <span class="keyword">Order</span> <span class="keyword">by</span> name</span><br><span class="line"></span><br><span class="line"><span class="number">13.</span><span class="keyword">SELECT</span> <span class="keyword">DISTINCT</span> M.title <span class="keyword">from</span> movie M, rating R <span class="keyword">where</span> M.<span class="keyword">mID</span> = R.<span class="keyword">mID</span> <span class="keyword">and</span> M.title <span class="keyword">not</span> <span class="keyword">in</span> (<span class="keyword">SELECT</span> movie.title <span class="keyword">from</span> movie,reviewer,rating <span class="keyword">where</span> movie.<span class="keyword">mID</span>= rating.<span class="keyword">mID</span> <span class="keyword">and</span> reviewer.rID = rating.rID <span class="keyword">and</span> name =<span class="comment">'Chris Jackson')</span></span><br><span class="line"></span><br><span class="line"><span class="number">14.</span><span class="keyword">SELECT</span> <span class="keyword">DISTINCT</span> re1.name, re2.name <span class="keyword">FROM</span> rating r1, rating r2, reviewer re1, reviewer re2 <span class="keyword">WHERE</span> r1.rID != r2.rID <span class="keyword">AND</span> r1.<span class="keyword">mID</span> = r2.<span class="keyword">mID</span> <span class="keyword">AND</span> re1.rID = r1.rID <span class="keyword">AND</span> re2.rID = r2.rID <span class="keyword">AND</span> re1.name &lt; re2.name;</span><br><span class="line"></span><br><span class="line"><span class="number">15.</span><span class="keyword">SELECT</span> <span class="keyword">DISTINCT</span> name,title,stars <span class="keyword">FROM</span> reviewer,movie,rating <span class="keyword">WHERE</span> stars <span class="keyword">in</span> (<span class="keyword">SELECT</span> min(stars) <span class="keyword">From</span> rating) <span class="keyword">AND</span> reviewer.rid = rating.rid <span class="keyword">and</span> movie.<span class="keyword">mid</span>= rating.<span class="keyword">mid</span>;</span><br><span class="line"></span><br><span class="line"><span class="number">16.</span><span class="keyword">SELECT</span> <span class="keyword">DISTINCT</span> R.rID, R.name <span class="keyword">FROM</span> reviewer R <span class="keyword">WHERE</span> <span class="keyword">NOT</span> EXISTS (<span class="keyword">SELECT</span> <span class="keyword">mID</span> <span class="keyword">FROM</span> movie <span class="keyword">WHERE</span> <span class="keyword">mID</span> <span class="keyword">not</span> <span class="keyword">in</span> (<span class="keyword">SELECT</span> <span class="keyword">mID</span> <span class="keyword">FROM</span> rating <span class="keyword">WHERE</span> rID = R.rID));</span><br><span class="line">(mysql does <span class="keyword">not</span> support except)<span class="keyword">SELECT</span> R.rID, R.name <span class="keyword">FROM</span> reviewer R <span class="keyword">WHERE</span> <span class="keyword">NOT</span> EXISTS (<span class="keyword">SELECT</span> <span class="keyword">mID</span> <span class="keyword">FROM</span> movie EXCEPT(<span class="keyword">SELECT</span> <span class="keyword">mID</span> <span class="keyword">FROM</span> reviewer, rating <span class="keyword">WHERE</span> reviewer.rID = rating.rID));</span><br><span class="line"></span><br><span class="line"><span class="number">17.</span><span class="keyword">SELECT</span> <span class="keyword">DISTINCT</span> M.* <span class="keyword">from</span> movie M, rating R, reviewer V <span class="keyword">where</span> M.<span class="keyword">mID</span> = R.<span class="keyword">mID</span> <span class="keyword">and</span> V.rID = R.rID <span class="keyword">and</span> name =<span class="comment">'Sarah Martinez' and title not in (SELECT title from movie M, rating R, reviewer V where M.mID = R.mID and V.rID = R.rID and name ='Chris Jackson')</span></span><br><span class="line">(mysql does <span class="keyword">not</span> support except)(<span class="keyword">SELECT</span> M.* <span class="keyword">from</span> movie M, rating R, reviewer V <span class="keyword">where</span> M.<span class="keyword">mID</span> = R.<span class="keyword">mID</span> <span class="keyword">and</span> V.rID = R.rID <span class="keyword">and</span> name =<span class="comment">'Tom') EXCEPT (SELECT * from movie M, rating R, reviewer V where M.mID = R.mID and V.rID = R.rID and name ='Jerry')</span></span><br><span class="line"></span><br><span class="line"><span class="number">18.</span><span class="keyword">SELECT</span> <span class="keyword">DISTINCT</span> title <span class="keyword">From</span> reviewer, rating, movie, rating <span class="keyword">as</span> rating1 <span class="keyword">WHERE</span> movie.<span class="keyword">mID</span>=rating.<span class="keyword">mID</span> <span class="keyword">and</span> reviewer.rID=rating.rID <span class="keyword">and</span> rating.rID!=rating1.rID <span class="keyword">and</span> rating.<span class="keyword">mID</span> = rating1.<span class="keyword">mID</span>;</span><br><span class="line"></span><br><span class="line"><span class="number">19.</span><span class="keyword">SELECT</span> * <span class="keyword">from</span> movie M <span class="keyword">where</span> M.<span class="keyword">mID</span> <span class="keyword">in</span> (<span class="keyword">SELECT</span> R.<span class="keyword">mID</span> <span class="keyword">from</span> rating R <span class="keyword">GROUP</span> <span class="keyword">BY</span> R.<span class="keyword">mID</span> having count(rID) &gt;= <span class="number">2</span>);</span><br><span class="line"></span><br><span class="line"><span class="number">20.</span><span class="keyword">SELECT</span> <span class="keyword">DISTINCT</span> reviewer.name <span class="keyword">From</span> reviewer <span class="keyword">where</span> reviewer.name <span class="keyword">not</span> <span class="keyword">in</span> (<span class="keyword">SELECT</span> reviewer.name <span class="keyword">From</span> reviewer,rating <span class="keyword">Where</span> reviewer.rID=rating.rID);</span><br><span class="line">(mysql does <span class="keyword">not</span> support except)<span class="keyword">SELECT</span> reviewer.name <span class="keyword">From</span> reviewer Except (<span class="keyword">SELECT</span> reviewer.name <span class="keyword">From</span> reviewer,rating <span class="keyword">Where</span> reviewer.rID=rating.rID);</span><br></pre></td></tr></table></figure><hr><p><em>参考博客和文章书籍等：</em></p><blockquote><p>stanford-sql课件第二章英文版</p></blockquote><p><em>因博客主等未标明不可引用，若部分内容涉及侵权请及时告知，我会尽快修改和删除相关内容</em></p>]]></content>
    
    <summary type="html">
    
      stanford公开课sql基础题
    
    </summary>
    
      <category term="技术文档" scheme="http://linyishui.top/categories/%E6%8A%80%E6%9C%AF%E6%96%87%E6%A1%A3/"/>
    
    
      <category term="sql" scheme="http://linyishui.top/tags/sql/"/>
    
      <category term="database" scheme="http://linyishui.top/tags/database/"/>
    
  </entry>
  
  <entry>
    <title>Git &lt;整&gt;</title>
    <link href="http://linyishui.top/2019090501.html"/>
    <id>http://linyishui.top/2019090501.html</id>
    <published>2019-09-05T09:13:47.000Z</published>
    <updated>2019-10-21T10:08:04.409Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>&emsp;&emsp;<em>内容主要整理自<a href="https://www.liaoxuefeng.com/wiki/896043488029600" title="Title" target="_blank" rel="noopener">廖雪峰的官方网站</a>，如果读后有收获可以去链接网站扫码打赏支持一下。</em></p><h1 id="Git"><a href="#Git" class="headerlink" title="Git"></a><strong>Git</strong></h1><h2 id="第一节-什么是Git"><a href="#第一节-什么是Git" class="headerlink" title="第一节 什么是Git"></a><strong>第一节 什么是Git</strong></h2><p>&emsp;&emsp;Git是一款开源的分布式版本控制系统。分布式即多人多用户，通过拷贝镜像的方式运转，版本控制即对项目的历史版本记录。Git最早来源于Linux的作者Linus，通过C语言开发，后来的GitHub则专门为开源项目提供免费的Git存储服务。</p><p>&emsp;&emsp;CVS和SVN都是集中式的版本控制系统。</p><blockquote><p>集中式和分布式的区别：</p><p>&emsp;&emsp;集中式的版本库存放于中央服务器，开发者需要从服务器获取最新版本，然后将更新内容发送给服务器。所以集中式要求必须要在联网环境下才能工作。分布式系统则没有中央服务器，每台用户电脑都有完整的版本库，所以不需要联网环境，在修改时把各自修改的内容互相推送来进行协作。通常会有一台机器充当”中央服务器”，方便记录所有人的修改。</p></blockquote><hr><h2 id="第二节-安装"><a href="#第二节-安装" class="headerlink" title="第二节 安装"></a><strong>第二节 安装</strong></h2><p>&emsp;&emsp;根据自己的操作系统(Linux，Unix，Mac，Windows等)进行安装，具体过程不贴，网上可以随处找到。</p><hr><h2 id="第三节-版本库"><a href="#第三节-版本库" class="headerlink" title="第三节 版本库"></a><strong>第三节 版本库</strong></h2><p>&emsp;&emsp;<strong>版本库</strong>(repository)，即项目仓库。可以理解为一个盒子或者目录，里面所有文件都会被Git管理，所以每个文件的各种操作都会被记录下来，可以随时追踪其历史，并还原某个时间点所处的状态。</p><h3 id="添加、提交、查看"><a href="#添加、提交、查看" class="headerlink" title="添加、提交、查看"></a><strong>添加、提交、查看</strong></h3><blockquote><p>git init </p></blockquote><p>&emsp;&emsp;此命令可以把当前目录作为Git可以管理的仓库。执行后会多出.git目录，用来跟踪管理版本库，默认隐藏。</p><p>&emsp;&emsp;所有的版本控制系统只能跟踪文本文件的改动，如txt，html，java等，可以记录文件中所有文本的变动。但对于图片和视频这些二进制文件，系统无法记录具体的变化(Word文件是二进制格式，所以无法跟踪其文本变更)。</p><blockquote><p>git add readme.txt</p></blockquote><p>&emsp;&emsp;在目录下创建readme文件，然后执行上述命令，告诉Git将文件添加到仓库。</p><blockquote><p>git commit -m “add a new txt”</p></blockquote><p>&emsp;&emsp;通过git commit指令告诉Git，把文件提交给仓库。-m后跟提交说明，可多次add添加，一次统一提交commit。</p><blockquote><p>git status</p></blockquote><p>&emsp;&emsp;修改readme文件内容，再执行上述指令，返回信息表示文件已修改但未提交</p><p>&emsp;&emsp;再一次执行git add，然后git status，发现返回信息更新，表示文件准备提交，最后git commit。然后git status，发现目录没有需要提交的文件。</p><blockquote><p>git diff</p></blockquote><p>&emsp;&emsp;如果文件修改，可以通过上述指令查看修改内容。</p><h3 id="版本回退"><a href="#版本回退" class="headerlink" title="版本回退"></a><strong>版本回退</strong></h3><blockquote><p>git log</p></blockquote><p>&emsp;&emsp;通过上述指令，可以查看操作日志，</p><blockquote><p>git reset –hard HEAD^</p></blockquote><blockquote><p>git reset –hard 1094a</p></blockquote><p>&emsp;&emsp;git reset指令回退目录到指定版本，版本号不需要输入完整，Git会自动查询匹配</p><blockquote><p>git reflog</p></blockquote><p>&emsp;&emsp;可以通过git reflog指令查看每次操作，而回退版本只是修改当前版本为旧版本，并更新文件，但不会影响被覆盖的版本，仍可以随时切换回。</p><hr><h2 id="第四节-工作区和暂存区"><a href="#第四节-工作区和暂存区" class="headerlink" title="第四节 工作区和暂存区"></a><strong>第四节 工作区和暂存区</strong></h2><p>&emsp;&emsp;工作区就是开发人员PC中可以看到的文件目录，工作区有一个隐藏目录.git，是Git的<strong>版本库</strong>。</p><p>&emsp;&emsp;版本库内有一块<strong>暂存区</strong>state，git add指令就是将文件修改添加到暂存区。而git commit则是将暂存区内容提交到当前分支。Git会默认自动创建一个master分支，所以此时会将修改内容提交到master分支。</p><h3 id="文件修改"><a href="#文件修改" class="headerlink" title="文件修改"></a><strong>文件修改</strong></h3><p>&emsp;&emsp;Git专注于修改而不是文件，可以通过以下案例来了解相关内容。</p><p>&emsp;&emsp;尝试执行以下指令顺序。</p><blockquote><ol><li>修改文件</li><li>git add xx</li><li>git status</li><li>再修改文件</li><li>git commit -m “git tracks changes”</li><li>git status</li></ol></blockquote><p>&emsp;&emsp;会发现后一次修改并未提交，信息如下。</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">$ git status</span><br><span class="line">On branch master</span><br><span class="line">Changes not staged for <span class="keyword">commit</span>:</span><br><span class="line">  (<span class="keyword">use</span> <span class="string">"git add &lt;file&gt;..."</span> <span class="keyword">to</span> <span class="keyword">update</span> what will be committed)</span><br><span class="line">  (<span class="keyword">use</span> <span class="string">"git checkout -- &lt;file&gt;..."</span> <span class="keyword">to</span> discard changes <span class="keyword">in</span> working <span class="keyword">directory</span>)</span><br><span class="line"></span><br><span class="line">        modified:   t.txt</span><br><span class="line"></span><br><span class="line"><span class="keyword">no</span> changes added <span class="keyword">to</span> <span class="keyword">commit</span> (<span class="keyword">use</span> <span class="string">"git add"</span> <span class="keyword">and</span>/<span class="keyword">or</span> <span class="string">"git commit -a"</span>)</span><br></pre></td></tr></table></figure><p>&emsp;&emsp;原因是在第一次修改后，执行了git add到暂存区，然后再进行二次修改，再提交时把暂存区内容提交，但二次修改还未加入暂存区。所以修改后必须要先add再提交才会有效果。</p><h3 id="撤销修改"><a href="#撤销修改" class="headerlink" title="撤销修改"></a><strong>撤销修改</strong></h3><blockquote><ol><li>修改文件，添加一行文字</li><li>add，commit</li><li>删除此行</li><li>git status</li></ol></blockquote><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">On branch master</span><br><span class="line">Changes not staged for <span class="keyword">commit</span>:</span><br><span class="line">  (<span class="keyword">use</span> <span class="string">"git add &lt;file&gt;..."</span> <span class="keyword">to</span> <span class="keyword">update</span> what will be committed)</span><br><span class="line">  (<span class="keyword">use</span> <span class="string">"git checkout -- &lt;file&gt;..."</span> <span class="keyword">to</span> discard changes <span class="keyword">in</span> working <span class="keyword">directory</span>)</span><br><span class="line"></span><br><span class="line">        modified:   t.txt</span><br><span class="line"></span><br><span class="line"><span class="keyword">no</span> changes added <span class="keyword">to</span> <span class="keyword">commit</span> (<span class="keyword">use</span> <span class="string">"git add"</span> <span class="keyword">and</span>/<span class="keyword">or</span> <span class="string">"git commit -a"</span>)</span><br></pre></td></tr></table></figure><blockquote><p>git checkout – <file></file></p></blockquote><p>&emsp;&emsp;git checkout指令表示可以撤销修改，分为两种情况：1.文件修改后还未add到暂存区，撤销后就和版本库一致。2.文件已添加到暂存区，又做了修改，撤销修改就回到add后的状态。总之就是让此文件回到最近一次commit或add的状态。</p><blockquote><p>git reset HEAD <file></file></p></blockquote><p>&emsp;&emsp;通过此指令可以把暂存区的修改撤销，重新放回工作区。</p><p>&emsp;&emsp;如果想回退已经commit的修改，则需要通过前文的版本回退。</p><h3 id="删除文件"><a href="#删除文件" class="headerlink" title="删除文件"></a><strong>删除文件</strong></h3><p>&emsp;&emsp;先删除文件，再git status。</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">$ git status</span><br><span class="line">On branch master</span><br><span class="line">Changes not staged for <span class="keyword">commit</span>:</span><br><span class="line">  (<span class="keyword">use</span> <span class="string">"git add/rm &lt;file&gt;..."</span> <span class="keyword">to</span> <span class="keyword">update</span> what will be committed)</span><br><span class="line">  (<span class="keyword">use</span> <span class="string">"git checkout -- &lt;file&gt;..."</span> <span class="keyword">to</span> discard changes <span class="keyword">in</span> working <span class="keyword">directory</span>)</span><br><span class="line"></span><br><span class="line">        deleted:    t.txt</span><br><span class="line"></span><br><span class="line"><span class="keyword">no</span> changes added <span class="keyword">to</span> <span class="keyword">commit</span> (<span class="keyword">use</span> <span class="string">"git add"</span> <span class="keyword">and</span>/<span class="keyword">or</span> <span class="string">"git commit -a"</span>)</span><br></pre></td></tr></table></figure><p>&emsp;&emsp;Git发现文件被删除，所以我们通过rm删除，并commit，使文件从版本库也删除。</p><blockquote><p>git rm <file></file></p></blockquote><p>&emsp;&emsp;还有可能删除了，可以通过checkout恢复。</p><hr><h2 id="第五节-远程仓库"><a href="#第五节-远程仓库" class="headerlink" title="第五节 远程仓库"></a><strong>第五节 远程仓库</strong></h2><p>&emsp;&emsp;实际开发中，我们需要一台服务器作为远程仓库来备份版本库以及作为用户的协调中枢。而GitHub就是提供Git仓库托管服务的网站。</p><p>&emsp;&emsp;注册账号过程跳过。本地Git仓库和GitHub远程仓库是通过SSH加密传输的，所以需要配置密钥。</p><blockquote><p>$ ssh-keygen -t rsa -C “<a href="mailto:youremail@example.com" target="_blank" rel="noopener">youremail@example.com</a>“</p></blockquote><p>&emsp;&emsp;可以通过上述命令创建SSH Key，然后在用户文档，找到.ssh目录，会有id_rsa和id_rsa.pub两个文件，即SSH Key的密钥对，pub表示公钥。然后在github网站配置SSH Keys。</p><p>&emsp;&emsp;然后可以在GitHub上创建一个远程仓库。然后复制SSH地址：Clone with SSH</p><blockquote><p>$ git remote add origin <a href="mailto:git@github.com" target="_blank" rel="noopener">git@github.com</a>:xx1/xx2</p></blockquote><p>&emsp;&emsp;通过此命令可以关联本地仓库和远程仓库，xx1是用户名，xx2为项目名。Git默认会给远程库起名origin。</p><blockquote><p>$ git push -u origin master</p></blockquote><blockquote><p>$ git push origin master</p></blockquote><p>&emsp;&emsp;通过此命令把本地库所有内容推送到远程库。由于远程库是空的，所以首次推送添加了-u参数，Git不但会把本地master分支内容推送到远程新的master分支，还会将他们关联，以后的推送或拉取就可以简化命令。</p><blockquote><p>$ git clone <a href="mailto:git@github.com" target="_blank" rel="noopener">git@github.com</a>:xx1/xx2</p></blockquote><p>&emsp;&emsp;上面是先有本地库再开启远程库，此命令则是先有远程库时克隆其内容到本地。</p><hr><h2 id="第六节-分支管理"><a href="#第六节-分支管理" class="headerlink" title="第六节 分支管理"></a><strong>第六节 分支管理</strong></h2><p>&emsp;&emsp;Git的分支管理要远远优秀于SVN。</p><p><img src="https://pic-1258215793.cos.ap-shanghai.myqcloud.com/content/20190801/201908010103.png" alt="Git分支图"></p><p>&emsp;&emsp;master分支即主分支，可以把Head看作指针，HEAD指向当前分支，而分支则指向提交。每个点就是一次提交，所以每次commit就会推动分支前进一步。新的分支则处在一条新的时间线，在平时各个分支间没有任何关系。</p><h3 id="创建与合并分支"><a href="#创建与合并分支" class="headerlink" title="创建与合并分支"></a><strong>创建与合并分支</strong></h3><p>&emsp;&emsp;Git创建分支效率很高，创建新的分支指针，再更新HEAD的指向即可。当一个分支上任务结束，则需要合并到主分支上，合并就是matser直接指向当前提交，就完成了合并工作。合并之后可以删除没用的分支。</p><blockquote><p>$ git checkout -b dev</p></blockquote><blockquote><p>$ git branch dev</p><p>$ git checkout dev</p></blockquote><p>&emsp;&emsp;创建并切换到dev分支，-b参数表示创建并切换，等价于后两条指令。</p><blockquote><p>$ git branch</p></blockquote><p>&emsp;&emsp;查看当前分支。</p><blockquote><p>$ git checkout master</p></blockquote><p>&emsp;&emsp;切换回master分支。</p><blockquote><p>$ git merge dev</p></blockquote><p>&emsp;&emsp;合并指定分支到当前分支。</p><blockquote><p>$ git branch -d dev</p></blockquote><p>&emsp;&emsp;合并后删除分支。</p><blockquote><p>$ git switch -c dev</p><p>$ git switch matser</p></blockquote><p>&emsp;&emsp;新版本推荐用switch指令代替checkout来进行切换，后者容易和撤销修改搞混。-c参数表示创建。</p><h3 id="解决冲突"><a href="#解决冲突" class="headerlink" title="解决冲突"></a><strong>解决冲突</strong></h3><blockquote><ol><li>创建新分支：$ git switch -c feature1</li><li>修改文件内容。</li><li>提交修改到分支：$ git add x.txt  $ git commit -m “feature1 submit”</li><li>切换到master分支(Git提醒当前master分支比origin/master分支超前)：$ git switch master</li><li>在修改文件上新增内容。</li><li>提交：$ git add x.txt $ git commit -m “master submit”</li><li>执行合并分支请求：$ git merge feature1</li></ol></blockquote><p>&emsp;&emsp;结果Git提示发生冲突，可以通过git status查看冲突文件，也可以直接查看冲突文件。修改文件内容，再提交解决冲突部分。可以删除分支feature1了。</p><h3 id="分支管理策略"><a href="#分支管理策略" class="headerlink" title="分支管理策略"></a><strong>分支管理策略</strong></h3><p>&emsp;&emsp;通常情况下，合并分支是fast forward模式，但此模式删除分支会失去分支信息。如果禁用fast forward模式，Git就会在merge时生成一个新的commit，这样，从分支历史上就可以看出分支信息。</p><blockquote><p>$ git switch -c dev</p></blockquote><p>&emsp;&emsp;创建并切换dev分支</p><blockquote><p>$ git add readme.txt </p><p>$ git commit -m “add merge”</p></blockquote><p>&emsp;&emsp;修改readme.txt，并提交。</p><blockquote><p>$ git switch matser</p></blockquote><p>&emsp;&emsp;切回master</p><blockquote><p>$ git merge –no-ff -m “merge with no-ff” dev</p></blockquote><p>&emsp;&emsp;合并dev分支，–no-ff参数，表示禁用Fast forward</p><blockquote><p>$ git log</p></blockquote><p>&emsp;&emsp;合并后，用git log看看分支历史</p><p>&emsp;&emsp;在实际开发中，master分支应该仅用来发布新版本，不能直接在上面干活；干活都在dev分支上，也就是说，dev分支是不稳定的，到某个时候，比如1.0版本发布时，再把dev分支合并到master上，在master分支发布1.0版本。</p><h3 id="Bug分支"><a href="#Bug分支" class="headerlink" title="Bug分支"></a><strong>Bug分支</strong></h3><p>&emsp;&emsp;在Git创建和删除分支是比较简洁的操作，所以每个bug都可以通过一个新的临时分支来修复，修复后再合并分支，然后将临时分支删除。</p><p>&emsp;&emsp;假定一个工作场景：你接到一个编号101的bug修复任务，很自然地你想创建一个分支issue-101来修复它，但是当前正在dev上进行的工作还没有提交。</p><blockquote><p>$ git status</p></blockquote><p>&emsp;&emsp;预计完成还需1天时间。但是必须在两个小时内修复该bug，怎么办？幸好，Git还提供了一个stash功能，可以把当前工作现场“储藏”起来，等以后恢复现场后继续工作。</p><blockquote><p>$ git stash</p></blockquote><p>&emsp;&emsp;现在用git status查看工作区，就是干净的（除非有没有被Git管理的文件），因此可以放心地创建分支来修复bug。</p><p>&emsp;&emsp;首先确定要在哪个分支上修复bug，假定需要在master分支上修复，就从master创建临时分支。</p><blockquote><p>$ git switch master</p><p>$ git switch -c issue-101</p></blockquote><p>&emsp;&emsp;然后修复bug，提交。</p><blockquote><p>$ git add readme.txt </p><p>$ git commit -m “fix bug 101”</p></blockquote><p>&emsp;&emsp;修复完成后，切换到master分支，并完成合并，最后删除issue-101分支。</p><blockquote><p>$ git switch master</p><p>$ git merge –no-ff -m “merged bug fix 101” issue-101</p></blockquote><p>&emsp;&emsp;回到dev分支继续工作。</p><blockquote><p>$ git switch dev</p><p>$ git status</p></blockquote><p>&emsp;&emsp;通过git stash list查看之前保存的工作现场</p><blockquote><p>$ git stash list</p></blockquote><p>&emsp;&emsp;找到工作现场后，就要恢复工作现场。一是用git stash apply恢复，但是恢复后stash内容并不删除，需要用git stash drop来删除；另一种方式是用git stash pop，恢复的同时把stash内容也删了。</p><blockquote><p>$ git stash pop</p><p>$ git stash list</p></blockquote><p>&emsp;&emsp;如果保存了多次现场，可以指定恢复。</p><blockquote><p>$ git stash apply stash@{0}</p></blockquote><p>&emsp;&emsp;修改BUG是在master上开分支最后合并的，那么当前dev分支一定还存在相同BUG，为了方便操作，Git专门提供了一个cherry-pick命令，让我们能复制一个特定的提交到当前分支。</p><blockquote><p>$ git branch</p><p>$ git cherry-pick 4c805e2</p></blockquote><p>&emsp;&emsp;复制提交：4c805e2 fix bug 101。Git自动给dev分支做了一次提交，注意这次提交的commit是1d4b803，它并不同于master的4c805e2，因为这两个commit只是改动相同，但确实是两个不同的commit。用git cherry-pick，我们就不需要在dev分支上手动再把修bug的过程重复一遍。</p><p>&emsp;&emsp;既然可以在master分支上修复bug后，在dev分支上可以“重放”这个修复过程，那么直接在dev分支上修复bug，然后在master分支上“重放”行不行？当然可以，不过你仍然需要git stash命令保存现场，才能从dev分支切换到master分支。</p><h3 id="Feature分支"><a href="#Feature分支" class="headerlink" title="Feature分支"></a><strong>Feature分支</strong></h3><p>&emsp;&emsp;添加一个新功能时，你肯定不希望因为一些实验性质的代码，把主分支搞乱了，所以每添加一个新功能，最好新建一个feature分支，在上面进行开发，完成后再合并，最后删除该feature分支。</p><p>&emsp;&emsp;假设我们收到了一个开发任务：开发代号为Vulcan的新功能，该功能计划用于下一代星际飞船。</p><blockquote><p>$ git switch -c feature-vulcan</p></blockquote><p>&emsp;&emsp;开发完毕，提交。</p><blockquote><p>$ git add vulcan.py</p><p>$ git status</p><p>$ git commit -m “add feature vulcan”</p></blockquote><p>&emsp;&emsp;切回dev，准备合并。</p><blockquote><p>$ git switch dev</p></blockquote><p>&emsp;&emsp;正常流程，合并成功然后删除。但是有些特殊情况，比如上级命令因经费不足，新功能必须取消。虽然白干了，但是这个包含机密资料的分支还是必须就地销毁。</p><blockquote><p>$ git branch -d feature-vulcan</p></blockquote><figure class="highlight subunit"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">error: </span>The branch 'feature-vulcan' is not fully merged.</span><br><span class="line">If you are sure you want to delete it, run 'git branch -D feature-vulcan'.</span><br></pre></td></tr></table></figure><p>&emsp;&emsp;销毁失败。Git友情提醒，feature-vulcan分支还没有被合并，如果删除，将丢失掉修改，如果要强行删除，需要使用大写的-D参数。。</p><p>&emsp;&emsp;强行删除。</p><blockquote><p>$ git branch -D feature-vulcan</p></blockquote><h3 id="多人协作"><a href="#多人协作" class="headerlink" title="多人协作"></a><strong>多人协作</strong></h3><p>&emsp;&emsp;当从远程仓库克隆时，实际上Git自动把本地的master分支和远程的master分支对应起来了，并且远程仓库的默认名称是origin。</p><p>&emsp;&emsp;要查看远程库的信息，就用git remote，或者用git remote -v显示更详细的信息，上面显示了可以抓取和推送的origin的地址。如果没有推送权限，就看不到push的地址。</p><blockquote><p>$ git remote</p></blockquote><h4 id="推送分支"><a href="#推送分支" class="headerlink" title="推送分支"></a><strong>推送分支</strong></h4><p>&emsp;&emsp;<strong>推送分支</strong>就是把该分支上的所有本地提交推送到远程库。推送时，要指定本地分支，这样Git就会把该分支推送到远程库对应的远程分支上。</p><blockquote><p>$ git push origin master</p></blockquote><p>&emsp;&emsp;如果要推送其他分支，比如dev，就改成。</p><blockquote><p>$ git push origin dev</p></blockquote><p>&emsp;&emsp;但是，并不是一定要把本地分支往远程推送，那么，哪些分支需要推送，哪些不需要呢？</p><ul><li><p>master分支是主分支，因此要时刻与远程同步；</p></li><li><p>dev分支是开发分支，团队所有成员都需要在上面工作，所以也需要与远程同步；</p></li><li><p>bug分支只用于在本地修复bug，就没必要推到远程了，除非老板要看看你每周到底修复了几个bug；</p></li><li><p>feature分支是否推到远程，取决于你是否和你的小伙伴合作在上面开发。</p></li></ul><h4 id="抓取分支"><a href="#抓取分支" class="headerlink" title="抓取分支"></a><strong>抓取分支</strong></h4><p>&emsp;&emsp;多人协作时，大家都会往master和dev分支上推送各自的修改。</p><blockquote><p>$ git clone <a href="mailto:git@github.com" target="_blank" rel="noopener">git@github.com</a>:xx/xx</p></blockquote><p>&emsp;&emsp;当团队成员从远程库clone时，默认情况下，他只能看到本地的master分支，可以用git branch命令看看。</p><blockquote><p>$ git branch</p></blockquote><p>&emsp;&emsp;当成员需要在dev分支上开发，就必须创建远程origin的dev分支到本地，于是他用这个命令创建本地dev分支。</p><blockquote><p>$ git switch -c dev origin/dev</p></blockquote><p>&emsp;&emsp;现在，他就可以在dev上继续修改，然后时不时地把dev分支push到远程：</p><blockquote><p>$ git add env.txt</p><p>$ git commit -m “add env”</p><p>$ git push origin dev</p></blockquote><h4 id="解决冲突-1"><a href="#解决冲突-1" class="headerlink" title="解决冲突"></a><strong>解决冲突</strong></h4><p>&emsp;&emsp;其他成员已经向origin/dev分支推送了他的提交，可能碰巧你也对同样的文件作了修改，并试图推送。</p><blockquote><p>$ git add env.txt</p><p>$ git commit -m “add new env”</p><p>$ git push origin dev</p></blockquote><figure class="highlight vim"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">To github.<span class="keyword">com</span>:xx/xx</span><br><span class="line"> ! [rejected]        dev -&gt; dev (non-fast-forward)</span><br><span class="line">error: failed <span class="keyword">to</span> push some refs <span class="keyword">to</span> <span class="string">'git@github.com:xx/xx'</span></span><br><span class="line">hin<span class="variable">t:</span> Updates were rejected because the tip of your current branch <span class="keyword">is</span> behind</span><br><span class="line">hin<span class="variable">t:</span> its remote counterpart. Integrate the remote <span class="keyword">changes</span> (<span class="keyword">e</span>.g.</span><br><span class="line">hin<span class="variable">t:</span> <span class="string">'git pull ...'</span>) before pushing again.</span><br><span class="line">hin<span class="variable">t:</span> See the <span class="string">'Note about fast-forwards'</span> in <span class="string">'git push --help'</span> <span class="keyword">for</span> details.</span><br></pre></td></tr></table></figure><p>&emsp;&emsp;推送失败，因为他人的最新提交和你试图推送的提交有冲突，解决办法也很简单，Git已经提示我们，先用git pull把最新的提交从origin/dev抓下来，然后，在本地合并，解决冲突，再推送。</p><blockquote><p>$ git pull</p></blockquote><figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">There is <span class="literal">no</span><span class="built_in"> tracking </span>information <span class="keyword">for</span> the current branch.</span><br><span class="line">Please specify which branch you want <span class="keyword">to</span> merge with.</span><br><span class="line">See git-pull(1) <span class="keyword">for</span> details.</span><br><span class="line"></span><br><span class="line">    git pull &lt;remote&gt; &lt;branch&gt;</span><br><span class="line"></span><br><span class="line"><span class="keyword">If</span> you wish <span class="keyword">to</span> <span class="builtin-name">set</span><span class="built_in"> tracking </span>information <span class="keyword">for</span> this branch you can <span class="keyword">do</span> so with:</span><br><span class="line"></span><br><span class="line">    git branch <span class="attribute">--set-upstream-to</span>=origin/&lt;branch&gt; dev</span><br></pre></td></tr></table></figure><p>&emsp;&emsp;git pull也失败了，原因是没有指定本地dev分支与远程origin/dev分支的链接，根据提示设置dev和origin/dev的链接。</p><blockquote><p>$ git branch –set-upstream-to=origin/dev dev</p></blockquote><figure class="highlight livecodeserver"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Branch <span class="string">'dev'</span> <span class="built_in">set</span> up <span class="built_in">to</span> track remote branch <span class="string">'dev'</span> <span class="built_in">from</span> <span class="string">'origin'</span>.</span><br></pre></td></tr></table></figure><p>&emsp;&emsp;再pull。</p><blockquote><p>$ git pull</p></blockquote><figure class="highlight livecodeserver"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Auto-merging env.txt</span><br><span class="line">CONFLICT (<span class="built_in">add</span>/<span class="built_in">add</span>): Merge conflict <span class="keyword">in</span> env.txt</span><br><span class="line">Automatic <span class="built_in">merge</span> failed; fix conflicts <span class="keyword">and</span> <span class="keyword">then</span> commit <span class="keyword">the</span> <span class="built_in">result</span>.</span><br></pre></td></tr></table></figure><p>&emsp;&emsp;这回git pull成功，但是合并有冲突，需要手动解决，解决的方法和分支管理中的解决冲突完全一样。解决后提交，再push：</p><blockquote><p>$ git commit -m “fix env conflict”</p><p>$ git push origin dev</p></blockquote><h3 id="Rebase"><a href="#Rebase" class="headerlink" title="Rebase"></a><strong>Rebase</strong></h3><p>&emsp;&emsp;多人在同一个分支上协作时，很容易出现冲突。即使没有冲突，后push的开发人员不得不先pull，在本地合并，然后才能push成功。</p><p>&emsp;&emsp;所以每次合并再push后，分支变成了这样。</p><figure class="highlight gherkin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">$ git log --graph --pretty=oneline --abbrev-commit</span><br><span class="line"></span><br><span class="line"><span class="symbol">*</span> d1be385 (HEAD -&gt; master, origin/master) init hello</span><br><span class="line"><span class="symbol">*</span>   e5e69f1 Merge branch 'dev'</span><br><span class="line">|<span class="string">\  </span></span><br><span class="line">|<span class="string"> *   57c53ab (origin/dev, dev) fix env conflict</span></span><br><span class="line">|<span class="string"> </span>|<span class="string">\  </span></span><br><span class="line">|<span class="string"> </span>|<span class="string"> * 7a5e5dd add env</span></span><br><span class="line">|<span class="string"> * </span>|<span class="string"> 7bd91f1 add new env</span></span><br><span class="line">|<span class="string"> </span>|<span class="string">/  </span></span><br><span class="line"><span class="string">* </span>|<span class="string">   12a631b merged bug fix 101</span></span><br><span class="line">|<span class="string">\ \  </span></span><br><span class="line">|<span class="string"> * </span>|<span class="string"> 4c805e2 fix bug 101</span></span><br><span class="line">|<span class="string">/ /  </span></span><br><span class="line"><span class="string">* </span>|<span class="string">   e1e9c68 merge with no-ff</span></span><br><span class="line">|<span class="string">\ \  </span></span><br><span class="line">|<span class="string"> </span>|<span class="string">/  </span></span><br><span class="line">|<span class="string"> * f52c633 add merge</span></span><br><span class="line">|<span class="string">/  </span></span><br><span class="line"><span class="string">*   cf810e4 conflict fixed</span></span><br></pre></td></tr></table></figure><p>&emsp;&emsp;看上去很乱，Git的提交历史可以是一条干净的直线吗？Git有一种称为rebase的操作，有人把它翻译成“变基”。</p><p>&emsp;&emsp;在和远程分支同步后，我们对hello.py这个文件做了两次提交。用git log命令看看：</p><figure class="highlight dockerfile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">$ git log --graph --pretty=oneline --abbrev-commit</span><br><span class="line"></span><br><span class="line">* <span class="number">582</span>d922 (HEAD -&gt; master) <span class="keyword">add</span><span class="bash"> author</span></span><br><span class="line"><span class="bash">* 8875536 add comment</span></span><br><span class="line"><span class="bash">* d1be385 (origin/master) init hello</span></span><br><span class="line"><span class="bash">*   e5e69f1 Merge branch <span class="string">'dev'</span></span></span><br><span class="line"><span class="bash">|\  </span></span><br><span class="line"><span class="bash">| *   57c53ab (origin/dev, dev) fix env conflict</span></span><br><span class="line"><span class="bash">| |\  </span></span><br><span class="line"><span class="bash">| | * 7a5e5dd add env</span></span><br><span class="line"><span class="bash">| * | 7bd91f1 add new env</span></span><br><span class="line"><span class="bash">...</span></span><br></pre></td></tr></table></figure><p>&emsp;&emsp;注意到Git用(HEAD -&gt; master)和(origin/master)标识出当前分支的HEAD和远程origin的位置分别是582d922 add author和d1be385 init hello，本地分支比远程分支快两个提交。</p><p>&emsp;&emsp;现在我们尝试推送本地分支。</p><figure class="highlight livecodeserver"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">$ git push origin master</span><br><span class="line"></span><br><span class="line">To github.com:xx/xx</span><br><span class="line"> ! [rejected]        master -&gt; master (fetch <span class="keyword">first</span>)</span><br><span class="line">error: failed <span class="built_in">to</span> push some refs <span class="built_in">to</span> <span class="string">'git@github.com:xx/xx'</span></span><br><span class="line">hint: Updates were rejected because <span class="keyword">the</span> remote <span class="keyword">contains</span> work that you <span class="built_in">do</span></span><br><span class="line">hint: <span class="keyword">not</span> have locally. This is usually caused <span class="keyword">by</span> another repository pushing</span><br><span class="line">hint: <span class="built_in">to</span> <span class="keyword">the</span> same ref. You may want <span class="built_in">to</span> <span class="keyword">first</span> integrate <span class="keyword">the</span> remote changes</span><br><span class="line">hint: (e.g., <span class="string">'git pull ...'</span>) <span class="keyword">before</span> pushing again.</span><br><span class="line">hint: See <span class="keyword">the</span> <span class="string">'Note about fast-forwards'</span> <span class="keyword">in</span> <span class="string">'git push --help'</span> <span class="keyword">for</span> details.</span><br></pre></td></tr></table></figure><p>&emsp;&emsp;很不幸失败了，这说明有人先于我们推送了远程分支。按照经验，先pull一下。</p><figure class="highlight vim"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">$ git pull</span><br><span class="line"></span><br><span class="line">remote: Counting object<span class="variable">s:</span> <span class="number">3</span>, done.</span><br><span class="line">remote: Compressing object<span class="variable">s:</span> <span class="number">100</span>% (<span class="number">1</span>/<span class="number">1</span>), done.</span><br><span class="line">remote: Total <span class="number">3</span> (delta <span class="number">1</span>), reused <span class="number">3</span> (delta <span class="number">1</span>), pack-reused <span class="number">0</span></span><br><span class="line">Unpacking object<span class="variable">s:</span> <span class="number">100</span>% (<span class="number">3</span>/<span class="number">3</span>), done.</span><br><span class="line">From github.<span class="keyword">com</span>:xx/xx</span><br><span class="line">   d1be385..f005ed4  master     -&gt; origin/master</span><br><span class="line"> * [<span class="keyword">new</span> <span class="keyword">tag</span>]         v1.<span class="number">0</span>       -&gt; v1.<span class="number">0</span></span><br><span class="line">Auto-merging hello.<span class="keyword">py</span></span><br><span class="line">Merge made by the <span class="string">'recursive'</span> strategy.</span><br><span class="line"> hello.<span class="keyword">py</span> | <span class="number">1</span> +</span><br><span class="line"> <span class="number">1</span> <span class="keyword">file</span> changed, <span class="number">1</span> insertion(+)</span><br></pre></td></tr></table></figure><p>&emsp;&emsp;再用git status看看状态。</p><figure class="highlight vbnet"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">$ git status</span><br><span class="line"></span><br><span class="line"><span class="keyword">On</span> branch master</span><br><span class="line">Your branch <span class="keyword">is</span> ahead <span class="keyword">of</span> <span class="comment">'origin/master' by 3 commits.</span></span><br><span class="line">  (use <span class="string">"git push"</span> <span class="keyword">to</span> publish your local commits)</span><br><span class="line"></span><br><span class="line"><span class="literal">nothing</span> <span class="keyword">to</span> commit, working tree clean</span><br></pre></td></tr></table></figure><p>&emsp;&emsp;加上刚才合并的提交，现在我们本地分支比远程分支超前3个提交。用git log看看。</p><figure class="highlight livecodeserver"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">$ git <span class="built_in">log</span> <span class="comment">--graph --pretty=oneline --abbrev-commit</span></span><br><span class="line"></span><br><span class="line">*   e0ea545 (HEAD -&gt; master) Merge branch <span class="string">'master'</span> <span class="keyword">of</span> github.com:xx/xx</span><br><span class="line">|\  </span><br><span class="line">| * f005ed4 (origin/master) <span class="built_in">set</span> exit=<span class="number">1</span></span><br><span class="line">* | <span class="number">582</span>d922 <span class="built_in">add</span> author</span><br><span class="line">* | <span class="number">8875536</span> <span class="built_in">add</span> comment</span><br><span class="line">|/  </span><br><span class="line">* d1be385 init hello</span><br><span class="line">...</span><br></pre></td></tr></table></figure><p>&emsp;&emsp;现在的状况就是提交历史分叉了，如果现在把本地分支push到远程，也是正确的，但对于一些人来说会觉得有些影响阅读。这个时候，rebase就派上了用场。我们输入命令git rebase试试。</p><figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">$ git rebase</span><br><span class="line"></span><br><span class="line">First, rewinding head <span class="keyword">to</span> replay your work on top of it<span class="built_in">..</span>.</span><br><span class="line">Applying: <span class="builtin-name">add</span> comment</span><br><span class="line">Using index <span class="builtin-name">info</span> <span class="keyword">to</span> reconstruct a base tree<span class="built_in">..</span>.</span><br><span class="line">Mhello.py</span><br><span class="line">Falling back <span class="keyword">to</span> patching base <span class="keyword">and</span> 3-way merge<span class="built_in">..</span>.</span><br><span class="line">Auto-merging hello.py</span><br><span class="line">Applying: <span class="builtin-name">add</span> author</span><br><span class="line">Using index <span class="builtin-name">info</span> <span class="keyword">to</span> reconstruct a base tree<span class="built_in">..</span>.</span><br><span class="line">Mhello.py</span><br><span class="line">Falling back <span class="keyword">to</span> patching base <span class="keyword">and</span> 3-way merge<span class="built_in">..</span>.</span><br><span class="line">Auto-merging hello.py</span><br></pre></td></tr></table></figure><p>&emsp;&emsp;输出了一大堆操作，到底是啥效果？再用git log看看：</p><figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">$ git log --graph <span class="attribute">--pretty</span>=oneline --abbrev-commit</span><br><span class="line"></span><br><span class="line">* 7e61ed4 (HEAD -&gt; master) <span class="builtin-name">add</span> author</span><br><span class="line">* 3611cfe <span class="builtin-name">add</span> comment</span><br><span class="line">* f005ed4 (origin/master) <span class="builtin-name">set</span> <span class="attribute">exit</span>=1</span><br><span class="line">* d1be385 init hello</span><br><span class="line"><span class="built_in">..</span>.</span><br></pre></td></tr></table></figure><p>&emsp;&emsp;原本分叉的提交现在变成一条直线了。原理非常简单，Git把我们本地的提交“挪动”了位置，放到了f005ed4 (origin/master) set exit=1之后，这样整个提交历史就成了一条直线。rebase操作前后，最终的提交内容是一致的，但是我们本地的commit修改内容已经变化了，它们的修改不再基于d1be385 init hello，而是基于f005ed4 (origin/master) set exit=1，但最后的提交7e61ed4内容是一致的。</p><p>&emsp;&emsp;这就是rebase操作的特点：把分叉的提交历史“整理”成一条直线，看上去更直观。缺点是本地的分叉提交已经被修改过了。</p><p>&emsp;&emsp;最后，通过push操作把本地分支推送到远程。</p><figure class="highlight ocaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">$ git push origin master</span><br><span class="line"></span><br><span class="line"><span class="type">Counting</span> objects: <span class="number">6</span>, <span class="keyword">done</span>.</span><br><span class="line"><span class="type">Delta</span> compression using up <span class="keyword">to</span> <span class="number">4</span> threads.</span><br><span class="line"><span class="type">Compressing</span> objects: <span class="number">100</span>% (<span class="number">5</span>/<span class="number">5</span>), <span class="keyword">done</span>.</span><br><span class="line"><span class="type">Writing</span> objects: <span class="number">100</span>% (<span class="number">6</span>/<span class="number">6</span>), <span class="number">576</span> <span class="built_in">bytes</span> | <span class="number">576.00</span> <span class="type">KiB</span>/s, <span class="keyword">done</span>.</span><br><span class="line"><span class="type">Total</span> <span class="number">6</span> (delta <span class="number">2</span>), reused <span class="number">0</span> (delta <span class="number">0</span>)</span><br><span class="line">remote: <span class="type">Resolving</span> deltas: <span class="number">100</span>% (<span class="number">2</span>/<span class="number">2</span>), completed <span class="keyword">with</span> <span class="number">1</span> local <span class="keyword">object</span>.</span><br><span class="line"><span class="type">To</span> github.com:michaelliao/learngit.git</span><br><span class="line">   f005ed4..<span class="number">7e61</span>ed4  master -&gt; master</span><br></pre></td></tr></table></figure><p>&emsp;&emsp;再用git log看看效果，远程分支的提交历史也是一条直线。</p><figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">$ git log --graph <span class="attribute">--pretty</span>=oneline --abbrev-commit</span><br><span class="line"></span><br><span class="line">* 7e61ed4 (HEAD -&gt; master, origin/master) <span class="builtin-name">add</span> author</span><br><span class="line">* 3611cfe <span class="builtin-name">add</span> comment</span><br><span class="line">* f005ed4 <span class="builtin-name">set</span> <span class="attribute">exit</span>=1</span><br><span class="line">* d1be385 init hello</span><br><span class="line"><span class="built_in">..</span>.</span><br></pre></td></tr></table></figure><p>&emsp;&emsp;rebase操作可以把本地未push的分叉提交历史整理成直线；rebase的目的是使得我们在查看历史提交的变化时更容易，因为分叉的提交需要三方对比。</p><hr><h2 id="第七节-标签管理"><a href="#第七节-标签管理" class="headerlink" title="第七节 标签管理"></a><strong>第七节 标签管理</strong></h2><p>&emsp;&emsp;发布一个版本时，我们通常先在版本库中打一个标签（tag），这样就唯一确定了打标签时刻的版本。将来无论什么时候，取某个标签的版本，就是把那个打标签的时刻的历史版本取出来。所以标签也是版本库的一个快照。</p><p>&emsp;&emsp;Git的标签虽然是版本库的快照，但其实它就是指向某个commit的指针（跟分支很像对不对？但是分支可以移动，标签不能移动），所以，创建和删除标签都是瞬间完成的。</p><h3 id="创建标签"><a href="#创建标签" class="headerlink" title="创建标签"></a><strong>创建标签</strong></h3><p>&emsp;&emsp;首先切换到需要打标签的分支上。</p><blockquote><p>$ git branch</p><p>$ git checkout master</p></blockquote><p>&emsp;&emsp;然后，敲命令git tag就可以打一个新标签。</p><blockquote><p>$ git tag v1.0</p></blockquote><p>&emsp;&emsp;可以用命令git tag查看所有标签。</p><blockquote><p>$ git tag</p></blockquote><p>&emsp;&emsp;默认标签是打在最新提交的commit上的。有时候如果忘了打标签怎么办？方法是找到历史提交的commit id，然后打上就可以了。</p><blockquote><p>$ git log –pretty=oneline –abbrev-commit</p></blockquote><figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">12a631b (HEAD -&gt; master, tag: v1.0, origin/master) merged bug fix 101</span><br><span class="line">4c805e2 fix bug 101</span><br><span class="line">e1e9c68 merge with no-ff</span><br><span class="line">f52c633 <span class="builtin-name">add</span> merge</span><br><span class="line">cf810e4 conflict fixed</span><br><span class="line">5dc6824 &amp; simple</span><br><span class="line">14096d0 <span class="keyword">AND</span> simple</span><br><span class="line">b17d20e branch test</span><br><span class="line">d46f35e <span class="builtin-name">remove</span> test.txt</span><br><span class="line">b84166e <span class="builtin-name">add</span> test.txt</span><br><span class="line">519219b git tracks changes</span><br><span class="line">e43a48b understand how stage works</span><br><span class="line">1094adb append GPL</span><br><span class="line">e475afc <span class="builtin-name">add</span> distributed</span><br><span class="line">eaadf4e wrote a readme file</span><br></pre></td></tr></table></figure><p>&emsp;&emsp;比方说要对add merge这次提交打标签，它对应的commit id是f52c633，敲入命令。</p><blockquote><p>$ git tag v0.9 f52c633</p></blockquote><p>&emsp;&emsp;再用命令git tag查看标签。</p><blockquote><p>$ git tag</p></blockquote><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-tag">v0</span><span class="selector-class">.9</span></span><br><span class="line"><span class="selector-tag">v1</span><span class="selector-class">.0</span></span><br></pre></td></tr></table></figure><p>&emsp;&emsp;注意，标签不是按时间顺序列出，而是按字母排序的。可以用git show查看标签信息。</p><blockquote><p>$ git show v0.9</p></blockquote><figure class="highlight llvm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">commit f<span class="number">52</span><span class="keyword">c</span><span class="number">63349</span>bc<span class="number">3</span><span class="keyword">c</span><span class="number">1593499807e5</span><span class="keyword">c</span><span class="number">8e972</span>b<span class="number">82</span><span class="keyword">c</span><span class="number">8</span>f<span class="number">286</span> (tag: v<span class="number">0.9</span>)</span><br><span class="line">Author: Michael Liao &lt;askxuefeng<span class="title">@gmail.com</span>&gt;</span><br><span class="line">Date:   Fri May <span class="number">18</span> <span class="number">21</span>:<span class="number">56</span>:<span class="number">54</span> <span class="number">2018</span> +<span class="number">0800</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">add</span> merge</span><br><span class="line"></span><br><span class="line">diff --git a/readme.txt b/readme.txt</span><br><span class="line">...</span><br></pre></td></tr></table></figure><p>&emsp;&emsp;可以看到，v0.9确实打在add merge这次提交上。</p><p>&emsp;&emsp;还可以创建带有说明的标签，用-a指定标签名，-m指定说明文字。</p><blockquote><p>$ git tag -a v0.1 -m “version 0.1 released” 1094adb</p></blockquote><p>&emsp;&emsp;用命令git show可以看到说明文字：</p><blockquote><p>$ git show v0.1</p></blockquote><figure class="highlight groovy"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">tag v0<span class="number">.1</span></span><br><span class="line"><span class="string">Tagger:</span> Michael Liao &lt;askxuefeng<span class="meta">@gmail</span>.com&gt;</span><br><span class="line"><span class="string">Date:</span>   Fri May <span class="number">18</span> <span class="number">22</span>:<span class="number">48</span>:<span class="number">43</span> <span class="number">2018</span> +<span class="number">0800</span></span><br><span class="line"></span><br><span class="line">version <span class="number">0.1</span> released</span><br><span class="line"></span><br><span class="line">commit <span class="number">1094</span>adb7b9b3807259d8cb349e7df1d4d6477073 (<span class="string">tag:</span> v0<span class="number">.1</span>)</span><br><span class="line"><span class="string">Author:</span> Michael Liao &lt;askxuefeng<span class="meta">@gmail</span>.com&gt;</span><br><span class="line"><span class="string">Date:</span>   Fri May <span class="number">18</span> <span class="number">21</span>:<span class="number">06</span>:<span class="number">15</span> <span class="number">2018</span> +<span class="number">0800</span></span><br><span class="line"></span><br><span class="line">    append GPL</span><br><span class="line"></span><br><span class="line">diff --git a<span class="regexp">/readme.txt b/</span>readme.txt</span><br><span class="line">...</span><br></pre></td></tr></table></figure><p>&emsp;&emsp;注意：标签总是和某个commit挂钩。如果这个commit既出现在master分支，又出现在dev分支，那么在这两个分支上都可以看到这个标签。</p><h3 id="操作标签"><a href="#操作标签" class="headerlink" title="操作标签"></a><strong>操作标签</strong></h3><p>&emsp;&emsp;如果标签打错了，也可以删除。</p><blockquote><p>$ git tag -d v0.1</p></blockquote><p>&emsp;&emsp;因为创建的标签都只存储在本地，不会自动推送到远程。所以，打错的标签可以在本地安全删除。</p><p>&emsp;&emsp;如果要推送某个标签到远程，使用命令git push origin。</p><blockquote><p>$ git push origin v1.0</p></blockquote><p>&emsp;&emsp;或者，一次性推送全部尚未推送到远程的本地标签。</p><blockquote><p>$ git push origin –tags</p></blockquote><p>&emsp;&emsp;如果标签已经推送到远程，要删除远程标签就麻烦一点，先从本地删除。</p><blockquote><p>$ git tag -d v0.9</p></blockquote><p>&emsp;&emsp;然后，从远程删除。删除命令也是push，但是格式如下。</p><blockquote><p>$ git push origin :refs/tags/v0.9</p></blockquote><p>&emsp;&emsp;要看看是否真的从远程库删除了标签，可以登陆GitHub查看。</p><hr><h2 id="第八节-使用GitHub参与开源项目"><a href="#第八节-使用GitHub参与开源项目" class="headerlink" title="第八节 使用GitHub参与开源项目"></a><strong>第八节 使用GitHub参与开源项目</strong></h2><p>&emsp;&emsp;我们一直用GitHub作为免费的远程仓库，如果是个人的开源项目，放到GitHub上是完全没有问题的。其实GitHub还是一个开源协作社区，通过GitHub，既可以让别人参与你的开源项目，也可以参与别人的开源项目。</p><p>&emsp;&emsp;在GitHub出现以前，开源项目开源容易，但让广大人民群众参与进来比较困难，因为要参与，就要提交代码，而给每个想提交代码的群众都开一个账号那是不现实的，因此，群众也仅限于报个bug，即使能改掉bug，也只能把diff文件用邮件发过去，很不方便。但是在GitHub上，利用Git极其强大的克隆和分支功能，广大人民群众真正可以第一次自由参与各种开源项目了。</p><p>&emsp;&emsp;如何参与一个开源项目呢？比如人气极高的bootstrap项目，这是一个非常强大的CSS框架，你可以访问它的项目主页<a href="https://github.com/twbs/bootstrap，点“Fork”就在自己的账号下克隆了一个bootstrap仓库，然后，从自己的账号下clone：" target="_blank" rel="noopener">https://github.com/twbs/bootstrap，点“Fork”就在自己的账号下克隆了一个bootstrap仓库，然后，从自己的账号下clone：</a></p><blockquote><p>git clone <a href="mailto:git@github.com" target="_blank" rel="noopener">git@github.com</a>:michaelliao/bootstrap.git</p></blockquote><p>&emsp;&emsp;一定要从自己的账号下clone仓库，这样你才能推送修改。如果从bootstrap的作者的仓库地址<a href="mailto:git@github.com" target="_blank" rel="noopener">git@github.com</a>:twbs/bootstrap.git克隆，因为没有权限，你将不能推送修改。</p><p>&emsp;&emsp;Bootstrap的官方仓库twbs/bootstrap、你在GitHub上克隆的仓库my/bootstrap，以及你自己克隆到本地电脑的仓库，他们的关系就像下图显示的那样：</p><figure class="highlight stata"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">┌─ GitHub ────────────────────────────────────┐</span><br><span class="line">│                                             │</span><br><span class="line">│ ┌─────────────────┐     ┌─────────────────┐ │</span><br><span class="line">│ │ twbs/<span class="keyword">bootstrap</span>  │────&gt;│  my/<span class="keyword">bootstrap</span>   │ │</span><br><span class="line">│ └─────────────────┘     └─────────────────┘ │</span><br><span class="line">│                                  ▲          │</span><br><span class="line">└──────────────────────────────────┼──────────┘</span><br><span class="line">                                   ▼</span><br><span class="line">                          ┌─────────────────┐</span><br><span class="line">                          │ <span class="keyword">local</span>/<span class="keyword">bootstrap</span> │</span><br><span class="line">                          └─────────────────┘</span><br></pre></td></tr></table></figure><p>&emsp;&emsp;如果你想修复bootstrap的一个bug，或者新增一个功能，立刻就可以开始干活，干完后，往自己的仓库推送。</p><p>&emsp;&emsp;如果你希望bootstrap的官方库能接受你的修改，你就可以在GitHub上发起一个pull request。当然，对方是否接受你的pull request就不一定了。</p><h3 id="小结"><a href="#小结" class="headerlink" title="小结"></a><strong>小结</strong></h3><p>&emsp;&emsp;在GitHub上，可以任意Fork开源仓库；</p><p>&emsp;&emsp;自己拥有Fork后的仓库的读写权限；</p><p>&emsp;&emsp;可以推送pull request给官方仓库来贡献代码。</p><hr><h2 id="第九节-搭建Git服务器"><a href="#第九节-搭建Git服务器" class="headerlink" title="第九节 搭建Git服务器"></a><strong>第九节 搭建Git服务器</strong></h2><p>&emsp;&emsp;GitHub就是一个免费托管开源代码的远程仓库。但是对于某些视源代码如生命的商业公司来说，既不想公开源代码，又舍不得给GitHub交保护费，那就只能自己搭建一台Git服务器作为私有仓库使用。</p><p>&emsp;&emsp;搭建Git服务器需要准备一台运行Linux的机器，强烈推荐用Ubuntu或Debian，这样通过几条简单的apt命令就可以完成安装。</p><p>&emsp;&emsp;假设你已经有sudo权限的用户账号，下面正式开始安装。</p><ol><li>第一步，安装git：</li></ol><blockquote><p>$ sudo apt-get install git</p></blockquote><ol start="2"><li>第二步，创建一个git用户，用来运行git服务</li></ol><blockquote><p>$ sudo adduser git</p></blockquote><ol start="3"><li>第三步，创建证书登录：</li></ol><p>&emsp;&emsp;收集所有需要登录的用户的公钥，就是他们自己的id_rsa.pub文件，把所有公钥导入到/home/git/.ssh/authorized_keys文件里，一行一个。</p><ol start="4"><li>第四步，初始化Git仓库：</li></ol><p>&emsp;&emsp;先选定一个目录作为Git仓库，假定是/srv/sample.git，在/srv目录下输入命令：</p><blockquote><p>$ sudo git init –bare sample.git</p></blockquote><p>&emsp;&emsp;Git就会创建一个裸仓库，裸仓库没有工作区，因为服务器上的Git仓库纯粹是为了共享，所以不让用户直接登录到服务器上去改工作区，并且服务器上的Git仓库通常都以.git结尾。然后，把owner改为git：</p><blockquote><p>$ sudo chown -R git:git sample.git</p></blockquote><ol start="5"><li>第五步，禁用shell登录：</li></ol><p>&emsp;&emsp;出于安全考虑，第二步创建的git用户不允许登录shell，这可以通过编辑/etc/passwd文件完成。找到类似下面的一行：</p><blockquote><p>git:x:1001:1001:,,,:/home/git:/bin/bash</p></blockquote><p>&emsp;&emsp;改为：</p><blockquote><p>git:x:1001:1001:,,,:/home/git:/usr/bin/git-shell</p></blockquote><p>&emsp;&emsp;这样，git用户可以正常通过ssh使用git，但无法登录shell，因为我们为git用户指定的git-shell每次一登录就自动退出。</p><ol start="6"><li>第六步，克隆远程仓库：</li></ol><p>现在，可以通过git clone命令克隆远程仓库了，在各自的电脑上运行：</p><blockquote><p>$ git clone git@server:/srv/sample.git</p></blockquote><p>Cloning into ‘sample’…<br>warning: You appear to have cloned an empty repository.</p><p>&emsp;&emsp;剩下的推送就简单了。</p><h3 id="管理公钥"><a href="#管理公钥" class="headerlink" title="管理公钥"></a><strong>管理公钥</strong></h3><p>&emsp;&emsp;如果团队很小，把每个人的公钥收集起来放到服务器的/home/git/.ssh/authorized_keys文件里就是可行的。如果团队有几百号人，就没法这么玩了，这时，可以用Gitosis来管理公钥。这里我们不介绍怎么玩Gitosis了，几百号人的团队基本都在500强了，相信找个高水平的Linux管理员问题不大。</p><h3 id="管理权限"><a href="#管理权限" class="headerlink" title="管理权限"></a><strong>管理权限</strong></h3><p>&emsp;&emsp;有很多不但视源代码如生命，而且视员工为窃贼的公司，会在版本控制系统里设置一套完善的权限控制，每个人是否有读写权限会精确到每个分支甚至每个目录下。因为Git是为Linux源代码托管而开发的，所以Git也继承了开源社区的精神，不支持权限控制。不过，因为Git支持钩子（hook），所以，可以在服务器端编写一系列脚本来控制提交等操作，达到权限控制的目的。Gitolite就是这个工具。这里我们也不介绍Gitolite了，不要把有限的生命浪费到权限斗争中。</p><h3 id="小结-1"><a href="#小结-1" class="headerlink" title="小结"></a><strong>小结</strong></h3><p>&emsp;&emsp;搭建Git服务器非常简单，通常10分钟即可完成；</p><p>&emsp;&emsp;要方便管理公钥，用Gitosis；</p><p>&emsp;&emsp;要像SVN那样变态地控制权限，用Gitolite。</p><hr><p><em>参考博客和文章书籍等：</em></p><blockquote><p><a href="https://www.liaoxuefeng.com/wiki/896043488029600" title="Title" target="_blank" rel="noopener">廖雪峰的官方网站</a></p></blockquote><blockquote><p><a href="https://nvie.com/posts/a-successful-git-branching-model/" title="Title" target="_blank" rel="noopener">A successful Git branching model</a></p></blockquote><p><em>因博客主等未标明不可引用，若部分内容涉及侵权请及时告知，我会尽快修改和删除相关内容</em></p>]]></content>
    
    <summary type="html">
    
      简单整理Git相关内容和操作，内容来源于：廖雪峰的官方网站
    
    </summary>
    
      <category term="技术文档" scheme="http://linyishui.top/categories/%E6%8A%80%E6%9C%AF%E6%96%87%E6%A1%A3/"/>
    
    
      <category term="git" scheme="http://linyishui.top/tags/git/"/>
    
  </entry>
  
  <entry>
    <title>《设计模式：可复用面向对象软件的基础》读书笔记</title>
    <link href="http://linyishui.top/2019090401.html"/>
    <id>http://linyishui.top/2019090401.html</id>
    <published>2019-09-04T07:26:13.000Z</published>
    <updated>2019-10-17T07:25:39.866Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="设计模式"><a href="#设计模式" class="headerlink" title="设计模式"></a><strong>设计模式</strong></h1><h2 id="一、前言、引言"><a href="#一、前言、引言" class="headerlink" title="一、前言、引言"></a><strong>一、前言、引言</strong></h2><p>&emsp;&emsp;<strong>本书主要描述</strong>在面向对象软件设计过程中针对特定问题简洁而优雅的解决方案。根据模式的性质进行<strong>分类</strong>：创建型、结构型和行为型。</p><p>&emsp;&emsp;<strong>粒度</strong>：指的是系统内存扩展增量的最小值，指数据仓库中数据单位保存数据的细化程度。对于程序设计来说，粒度就是程序中的一个最小单元划分，比如面向过程语言中的单元是过程和函数，是程序中的最小组件，而这些组件就可以实现最基本的代码重用。但当程序变大变复杂就会显得粒度太低，过多的函数非常难以管理。</p><p>&emsp;&emsp;<strong>粗/细粒度</strong>：指相对规模的划分，可以理解为抽象程度。</p><p>&emsp;&emsp;很难一次就得到兼具复用性和灵活性的设计，<strong>重复设计</strong>是不可避免的，但有经验的面向对象设计者能做出良好的设计。</p><p>&emsp;&emsp;其中<strong>内行的一点</strong>是，不是解决任何问题都要从头做起，复用以前用过的解决方案，待有好的解决方案时，再一次次的使用新的方案。</p><p>&emsp;&emsp;<strong>本书的目的</strong>就是将面向对象软件的设计经验作为<strong>设计模式</strong>记录下来</p><p>&emsp;&emsp;<strong>本书的设计模式</strong>是对被用来在特定场景下解决一般设计问题的类和相互通信的对象的描述。</p><hr><h2 id="二、模式的四要素"><a href="#二、模式的四要素" class="headerlink" title="二、模式的四要素"></a><strong>二、模式的四要素</strong></h2><p>&emsp;&emsp;模式由四个基本要素组成：</p><ol><li>名称：方便记忆和使用，加强思考。</li><li>问题：描述模式的使用场景，也可以包括使用模式必须包括的一系列先决条件。</li><li>解决方案：模式设计的组成成分，之间的相互关系及各自的职责和协作方式。</li><li>效果：模式应用的效果以及使用模式应权衡的问题。</li></ol><hr><h2 id="三、MVC的设计模式"><a href="#三、MVC的设计模式" class="headerlink" title="三、MVC的设计模式"></a><strong>三、MVC的设计模式</strong></h2><p>&emsp;&emsp;MVC包括三类对象，模型Model是应用对象，视图View是在屏幕上的表示，控制器Controller定义用户界面对用户输入的响应方式。</p><p>&emsp;&emsp;MVC分离了用户界面设计的这些对象，来提高灵活性和复用性。</p><p>&emsp;&emsp;MVC通过创建一个”订购/通知”的协议来<strong>分离</strong>V和M。视图需要保证其显示正确的反映了模型的状态。一旦模型数据发生变化，需要通知相关视图，视图则进行刷新，这样一个模型可以提供不同的多个视图表现，也可以只更新视图而无需重写模型。</p><p>&emsp;&emsp;MVC的这种分离设计也用于进行对象分离，进行解耦，即<strong>观察者模式</strong>(Observer)。</p><p>&emsp;&emsp;MVC另一个特征是视图可以进行嵌套，也就是将对象划分为一组，并将这组对象看作一个对象。即<strong>组合模式</strong>(Composite)。此模式通过创建一个类的层次结构，用一些子类来定义原子对象，其他类来定义组合对象，组合对象即原子对象组合而成的对象。</p><p>&emsp;&emsp;MVC也可以在不改变视图的情况下改变对用户输入的响应方式。这些都是解耦之后带来的灵活性提升。</p><p>&emsp;&emsp;View-Controller关系是策略模式(Strategy)的一个例子。</p><p>&emsp;&emsp;MVC还涉及到的设计模式：用来指定视图缺省控制器的工厂方法模式(Factory method)，用来增加视图滚动的装饰器模式(Decorator)，不过这些都是次要的应用了。</p><hr><h2 id="四、介绍设计模式的统一结构"><a href="#四、介绍设计模式的统一结构" class="headerlink" title="四、介绍设计模式的统一结构"></a><strong>四、介绍设计模式的统一结构</strong></h2><p>&emsp;&emsp;本书通过以下抽象结构来统一介绍设计模式。</p><ol><li>模式名和分类</li><li>意图：回答这些问题(此模式是做什么的？其基本原理和意图是什么？它解决的是什么样的特定设计问题？)</li><li>别名</li><li>动机：用来说明一个设计问题以及如何使用模式中的类和对象来解决此问题的特定情境。</li><li>适用性：什么情况下适用？此模式又改进了哪些不良设计？我们又该如何识别这些情况？</li><li>结构：通过基于对象建模技术(OMT)的表示法对模式中的类进行图形描述。</li><li>参与者：模式中的类和对象以及它们的职责。</li><li>协作：参与者如何协作实现职责。</li><li>效果：模式怎样支持其目标？使用此模式的效果和所需做的权衡取舍？系统结构的哪些方面可以独立改变？</li><li>实现：实现此模式时需要知道的提示、技术要点以及应该避免的缺陷，还有是否存在某些特定于实现语言的问题。</li><li>代码示例</li><li>已知应用：实际系统中模式案例。</li><li>相关模式：和此模式紧密相关的模式有哪些？不同之处是什么？此模式应该和哪些模式一起使用？</li></ol><hr><h2 id="五、所有设计模式"><a href="#五、所有设计模式" class="headerlink" title="五、所有设计模式"></a><strong>五、所有设计模式</strong></h2><p>&emsp;&emsp;本书包含的模式：</p><table><thead><tr><th style="text-align:center">参与</th><th style="text-align:center">创建型</th><th style="text-align:center">结构型</th><th style="text-align:center">行为型</th></tr></thead><tbody><tr><td style="text-align:center">类</td><td style="text-align:center">Factory Method <br> 工厂方法</td><td style="text-align:center">Adapter(类) <br> 适配器-类</td><td style="text-align:center">Interpreter <br> 解释器 <br> Template Method <br> 模板方法</td></tr><tr><td style="text-align:center">对象</td><td style="text-align:center">Abstract Factory <br> 抽象工厂 <br> Builder <br> 生成器 <br> Prototype <br> 原型 <br> Singleton <br> 单例</td><td style="text-align:center">Adapter(对象) <br> 适配器-对象 <br> Bridge <br> 桥接 <br> Composite <br> 组合 <br> Decorator <br> 装饰 <br> Facade <br> 外观 <br> Flyweight <br> 享元 <br> Proxy <br> 代理</td><td style="text-align:center">Chain of Responsibility <br> 职责链 <br> Command <br> 命令 <br> Iterator <br> 迭代器 <br> Mediator <br> 中介者 <br> Memento <br> 备忘录 <br> Observer <br> 观察者 <br> State <br> 状态 <br> Strategy <br> 策略 <br> Visitor <br> 访问者</td></tr></tbody></table><p>&emsp;&emsp;根据目的准则划分：创建型、结构型和行为型。其中创建型模式与对象的创建有关；结构型模式处理类和对象的组合；行为型模式对类或对象怎样交互和怎样分配进行描述。</p><p>&emsp;&emsp;根据范围准则划分：类和对象。类模式处理类和子类的关系，关系通过继承建立，是静态的，编译时便确定。对象模式则处理对象间的关系，这些关系在运行时刻可以变换。</p><ol><li>创建型类模式，将对象的部分创建工作延迟到子类。</li><li>创建型对象模式，将对象的部分创建工作延迟到另一个对象。</li><li>结构型类模式，使用继承机制来组合类。</li><li>结构型对象模式，描述了对象的组装方式。</li><li>行为型类模式，使用继承描述算法和控制流。</li><li>行为型对象模式，描述一组对象怎样协作完成单个对象无法完成的任务。</li></ol><p>&emsp;&emsp;组合模式(Composite)常和迭代器模式(Iterator)或访问者模式(Visitor)一起使用。原型模式(Prototype)常用量替代抽象工厂模式(Abstract Factory)。组合模式(Composite)和装饰模式(Decorator)结构类似。</p><p><img src="https://pic-1258215793.cos.ap-shanghai.myqcloud.com/content/20190801/201908010101.png" alt="设计模式之间的关系"></p><hr><h2 id="六、设计模式怎样解决设计问题"><a href="#六、设计模式怎样解决设计问题" class="headerlink" title="六、设计模式怎样解决设计问题"></a><strong>六、设计模式怎样解决设计问题</strong></h2><h3 id="1-寻找合适的对象"><a href="#1-寻找合适的对象" class="headerlink" title="1 寻找合适的对象"></a><strong>1 寻找合适的对象</strong></h3><p>&emsp;&emsp;客户请求是使对象执行操作的唯一方法，操作又是对象改变内部数据的唯一方法。因为这些限制，对象的内部状态是被封装的。面向对象设计最困难的部分是将系统分解为对象集合。</p><p>&emsp;&emsp;面向对象设计支持众多的设计方法。可以写出一个问题描述，挑出名词和动词，进而创建相应的类和操作；也可以关注于系统的协作和职责关系；也可以对现实世界建模，再将分析时发现的对象转化至设计中。</p><p>&emsp;&emsp;设计中往往需要抽象出现实世界并不存在的对象的抽象方法，这对设计的灵活性是很重要的。</p><h3 id="2-决定对象的粒度"><a href="#2-决定对象的粒度" class="headerlink" title="2 决定对象的粒度"></a><strong>2 决定对象的粒度</strong></h3><p>&emsp;&emsp;对象可以表示下自硬件上到整个应用的任何事物。</p><p>&emsp;&emsp;外观模式(Facade)描述了怎样用对象表示完整的子系统；享元模式(Flyweight)描述了如何支持大量的最小粒度的对象。其他一些设计模式描述了将一个对象分解成许多小对象的特定方法。抽象工厂模式(Abstract Factory)和生成器模式(Builder)产生那些专门负责生成其他对象的对象。访问者模式(Visitor)和命令模式(Command)生成的对象专门负责实现对其他对象或对象组的请求。</p><h3 id="3-指定对象接口"><a href="#3-指定对象接口" class="headerlink" title="3 指定对象接口"></a><strong>3 指定对象接口</strong></h3><p>&emsp;&emsp;对象声明的每一个操作指定操作名、作为参数的对象和返回值，这就是所谓的操作的型构(signature)。对象操作所定义的所有操作型构的集合被称为该对象的接口(interface)。</p><p>&emsp;&emsp;类型(type)是用来标识特定接口的一个名字，当一个类型的接口包含另一个类型的接口时，可以说它是另一个类型的子类型(subtype)，另一个类型则是它的超类型(supertype)</p><p>&emsp;&emsp;当给对象发送请求时，所引起的具体操作既与请求本身有关又与接受对象有关，支持相同请求的不同对象可能对请求激发的操作有不同的实现。发送给对象的请求和它的相应操作在运行时刻的连接称之为<strong>动态绑定</strong>。动态绑定就是指发送的请求直到运行时刻才受具体的实现的约束，动态绑定允许你在运行时刻彼此替换有相同接口的对象。这种可替换性就称作<strong>多态</strong>。</p><h3 id="4-描述对象的实现"><a href="#4-描述对象的实现" class="headerlink" title="4 描述对象的实现"></a><strong>4 描述对象的实现</strong></h3><p>&emsp;&emsp;<strong>针对接口编程，而不是针对实现编程。</strong></p><p>&emsp;&emsp;理解对象实例化，类继承，抽象类和具体类，混入类。</p><p>&emsp;&emsp;<strong>类继承</strong>和<strong>接口继承</strong>的比较，类继承根据一个对象的实现定义了另一个对象的实现，即代码和表示的共享机制。接口继承则描述了一个对象什么时候能被用来替代另一个对象。</p><p>&emsp;&emsp;类继承实现了可复用，而继承拥有定义具有相同接口的对象族的能力，而多态则依赖于这种能力。只根据抽象类中定义的接口来操纵对象的好处：1.客户无须知道他们使用对象的特定类型，只须对象有客户所期望的接口。2.客户无须知道他们使用的对象是用什么类来实现的，他们只须知道定义接口的抽象类。</p><h3 id="5-运用复用机制"><a href="#5-运用复用机制" class="headerlink" title="5 运用复用机制"></a><strong>5 运用复用机制</strong></h3><h4 id="继承和组合的比较"><a href="#继承和组合的比较" class="headerlink" title="继承和组合的比较"></a><strong>继承和组合的比较</strong></h4><p>&emsp;&emsp;<strong>优先使用对象组合，而不是类继承</strong></p><p>&emsp;&emsp;功能复用最常用的技术是<strong>类继承</strong>和<strong>对象组合</strong>。</p><p>&emsp;&emsp;类继承这种通过生成子类的复用通常被称为<strong>白箱复用</strong>，白箱指可视性，即父类内部细节对子类可见。</p><p>&emsp;&emsp;对象组合是类继承之外的另一种复用选择，新的复杂的功能可以通过组装或组合对象来获取。要求被组合的对象具有良好定义的接口，所以被称为<strong>黑箱复用</strong>，因为对象的内部细节是不可见的。</p><p>&emsp;&emsp;继承和组合各有优缺点。</p><blockquote><p>继承优点：</p><ol><li>类继承在编译时静态定义，可以直接应用。</li><li>类继承比较方便的改变被复用的实现。</li></ol></blockquote><blockquote><p>继承缺点：</p><ol><li>类继承在编译时便确定，无法在运行时再改变继承自父类的实现。</li><li>“继承破坏了封装性”，继承对子类揭露父类的内部细节。</li><li>父类任何变化必然导致子类发生变化。这种依赖关系限制了灵活性并最终会限制复用性。一个解决方案是只继承抽象类，因为抽象类提供较少的实现。</li></ol></blockquote><blockquote><p>组合优点：</p><ol><li>对象组合通过获得对其他对象的引用而在运行阶段动态定义。</li><li>组合要求对象遵守彼此的接口约定，进而促进接口制定的规范性。</li><li>这些接口并不会妨碍你将一个对象和其他对象一起使用。而且因为对象只能通过接口访问，所以并没有破坏封装性；</li><li>只要类型一致，运行阶段可以用一个对象替代另一个对象。</li></ol></blockquote><p>&emsp;&emsp;继承实现复用往往比组合要容易许多，所以通常会结合起来使用。</p><h4 id="委托"><a href="#委托" class="headerlink" title="委托"></a><strong>委托</strong></h4><p>&emsp;&emsp;委托是一种组合方法，使组合具有和继承一样的复用能力，是对象组合的一个特例，可以替代继承。</p><p>&emsp;&emsp;在委托方式下，有两个对象参与处理一个请求，接受请求的对象将操作委托给他的<strong>代理者</strong>，类似于子类委托给父类。</p><p>&emsp;&emsp;比如我们实现了一个矩形类来处理所有矩形操作，窗口类可以复用矩形类的操作，而不必成为矩形类的子类。</p><blockquote><p>委托优点：便于在运行阶段组合对象操作，以及改变这些操作的组合方式。</p><p>委托缺点：</p><ol><li>动态的、高度参数化的软件比静态软件更难于理解。</li><li>运行时效率相比会降低。</li></ol></blockquote><p>&emsp;&emsp;所以委托适合于其使设计更加简单的情况，委托可以得到的效率与上下文有关，最适合符合特定程式的情景，即标准模式的情景。</p><p>&emsp;&emsp;状态模式(State)、策略模式(Strategy)和访问者模式(Visitor)中都使用了委托。</p><p>&emsp;&emsp;状态模式中，一个对象将请求委托给一个描述当前状态的State对象来处理。策略模式中，一个对象将一个特定的请求委托给一个描述请求执行策略的对象，一个对象只会有一个状态，但对于不同的请求可以有多个策略。而访问者模式中，对象结构的每个元素上的操作总是被委托到Visitor对象。</p><h4 id="继承和参数化类型的比较"><a href="#继承和参数化类型的比较" class="headerlink" title="继承和参数化类型的比较"></a><strong>继承和参数化类型的比较</strong></h4><p>&emsp;&emsp;<strong>参数化类型</strong>是另一种功能复用技术，是类属(generic)或模板(templates)。定义一个类型时并不去指定该类型所用到的其他所有类型，未经指定的类型在使用时通过参数的形式提供。</p><p>&emsp;&emsp;参数化类型和继承都无法在运行阶段改变，但参数化类型允许改变类所用到的类型。</p><h3 id="6-关联运行阶段和编译阶段的结构"><a href="#6-关联运行阶段和编译阶段的结构" class="headerlink" title="6 关联运行阶段和编译阶段的结构"></a><strong>6 关联运行阶段和编译阶段的结构</strong></h3><p>&emsp;&emsp;编译阶段的代码结构由继承关系固定的类组成。而运行阶段的结构则由快速变化的通信对象网络组成。</p><p>&emsp;&emsp;对象间有<strong>聚合</strong>和<strong>相识</strong>的关系。聚合表示一个对象拥有/包含另一个对象或其一部分。相识则表示一个对象仅知道另一个对象，可以说是关联或引用的关系，可以彼此请求但无需负责。聚合意味着对象有相同的生命周期，而相识则是比聚合耦合度更低的关系。</p><h3 id="7-设计应支持变化"><a href="#7-设计应支持变化" class="headerlink" title="7 设计应支持变化"></a><strong>7 设计应支持变化</strong></h3><ol><li><strong>通过显式的指定一个类来创建对象。</strong>这样会使程序受特定实现的约束，而不是特定接口的约束，为了避免这种情况，应该间接的创建对象。(相关模式：Abstract Factory,Factory Method，Prototype)</li><li><strong>对特殊操作的依赖。</strong>当为请求指定一个特殊化的操作时，就固定了请求的方式。为了避免写死代码，应该可以在编译或运行阶段可以方便的改变响应请求的方法。(相关模式：Chain of Responsibility,Command)</li><li><strong>对硬件和软件平台的依赖。</strong>依赖于特定平台，很难进行移植。<br>(相关模式：Abstract Factory,Bridge)</li><li><strong>对对象表示或实现的依赖。</strong>知道对象将怎样表示、保存、定位或实现的客户在对象进行变化时也需要进行变化，最好隐藏这些信息以防连锁变化。<br>(相关模式：Abstract Factory,Bridge,Memento,Proxy)</li><li><strong>算法依赖。</strong>算法在开发和复用时常常被扩展、优化和替代，尽量避免依赖于某个特定算法。<br>(相关模式：Builder,Iterator,Strategy,Template Method,Visitor)</li><li><strong>紧耦合。</strong>紧耦合的类很难独立的被复用，因为他们之间相互依赖。松散耦合可以提高一个类本身被复用的可能性，使系统更易于学习、移植、修改和扩展。设计模式通过抽象耦合和分层技术来提高松散耦合。<br>(相关模式：Abstract Factory,Command,Facade,Mediator,Observer,Chain of Responsibility)</li><li><strong>通过生成子类来扩充功能。</strong>通常很难通过定义子类来定制对象，新类会有固定的实现开销，还需要对父类的深入了解。可以通过对象组合和委托技术，以新的方式来组合已有对象，而不是通过定义已存在类的子类的方式加入程序。<br>(相关模式：Bridge,Chain of Responsibility,Composite,Decorator,Observer,Strategy)</li><li><strong>不能方便的对类进行修改。</strong>有时不得不修改一个难以修改的类，如引用他人代码，但没有源码，或是修改一个类要同时修改关联的众多子类。<br>(相关模式：Adapter,Decorator,Visitor)</li></ol><hr><h2 id="七、怎样选择设计模式"><a href="#七、怎样选择设计模式" class="headerlink" title="七、怎样选择设计模式"></a><strong>七、怎样选择设计模式</strong></h2><ol><li>思考设计模式是怎样解决设计问题</li><li>浏览模式的意图部分</li><li>研究模式怎样互相关联</li><li>研究目的相似的模式</li><li>检查重新设计的原因</li><li>考虑你的设计中哪些是可变的</li></ol><p><img src="https://pic-1258215793.cos.ap-shanghai.myqcloud.com/content/20190801/201908010102.png" alt="设计模式所支持的设计的可变方面"></p><hr><h2 id="八、怎样使用设计模式"><a href="#八、怎样使用设计模式" class="headerlink" title="八、怎样使用设计模式"></a><strong>八、怎样使用设计模式</strong></h2><ol><li>大致浏览一遍模式</li><li>回头研究结构部分、参与者部分和协作部分</li><li>看代码示例部分，看看这个模式代码形式的具体例子</li><li>选择模式参与者的名字，使他们在应用上下文中有意义</li><li>定义类</li><li>定义模式中专用于应用的操作名称</li><li>实现执行模式中责任和协作的操作</li></ol><hr><p><em>参考博客和文章书籍等：</em></p><blockquote><p>《设计模式：可复用面向对象软件的基础》</p></blockquote><p><em>因博客主等未标明不可引用，若部分内容涉及侵权请及时告知，我会尽快修改和删除相关内容</em></p>]]></content>
    
    <summary type="html">
    
      《设计模式：可复用面向对象软件的基础》读书笔记，涉及前言，引言和第一章内容。
    
    </summary>
    
      <category term="技术文档" scheme="http://linyishui.top/categories/%E6%8A%80%E6%9C%AF%E6%96%87%E6%A1%A3/"/>
    
    
      <category term="java" scheme="http://linyishui.top/tags/java/"/>
    
      <category term="design pattern" scheme="http://linyishui.top/tags/design-pattern/"/>
    
      <category term="mvc" scheme="http://linyishui.top/tags/mvc/"/>
    
  </entry>
  
  <entry>
    <title>Shiro</title>
    <link href="http://linyishui.top/2019090201.html"/>
    <id>http://linyishui.top/2019090201.html</id>
    <published>2019-09-02T08:42:14.000Z</published>
    <updated>2019-10-14T08:54:14.469Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>（未完待续…）</p><hr><p><em>参考博客和文章书籍等：</em></p><blockquote><p><a href="https://blog.csdn.net/u014203449/article/details/80888637" title="Title" target="_blank" rel="noopener">六。shiro集群，将session保存到数据库和redis，使用户保持登录状态</a></p></blockquote><blockquote><p><a href="https://blog.csdn.net/quanaianzj/article/details/83858575" title="Title" target="_blank" rel="noopener">shiro 登陆成功后subject依然为空</a></p></blockquote><blockquote><p><a href="https://blog.csdn.net/swl1993831/article/details/90905040" title="Title" target="_blank" rel="noopener">Shiro+JWT实现用户登陆认证，权限控制</a></p></blockquote><blockquote><p><a href="https://blog.csdn.net/u010475041/article/details/78140643" title="Title" target="_blank" rel="noopener">CAS单点登录-客户端集成(shiro、springboot、jwt、pac4j)（十）</a></p></blockquote><blockquote><p><a href="https://blog.csdn.net/qq_14952889/article/details/69554670" title="Title" target="_blank" rel="noopener">实现shiro多方式登录系统</a></p></blockquote><blockquote><p><a href="http://www.mamicode.com/info-detail-2337846.html" title="Title" target="_blank" rel="noopener">shiro实战系列(十)之Subject</a></p></blockquote><blockquote><p><a href="https://blog.csdn.net/weixin_42873937/article/details/82460997" title="Title" target="_blank" rel="noopener">使用JWT实现单点登录（完全跨域方案）</a></p></blockquote><p><em>因博客主等未标明不可引用，若部分内容涉及侵权请及时告知，我会尽快修改和删除相关内容</em></p>]]></content>
    
    <summary type="html">
    
      简单介绍Shiro。
    
    </summary>
    
      <category term="技术文档" scheme="http://linyishui.top/categories/%E6%8A%80%E6%9C%AF%E6%96%87%E6%A1%A3/"/>
    
    
      <category term="java" scheme="http://linyishui.top/tags/java/"/>
    
      <category term="security" scheme="http://linyishui.top/tags/security/"/>
    
      <category term="shiro" scheme="http://linyishui.top/tags/shiro/"/>
    
  </entry>
  
  <entry>
    <title>Pac4j</title>
    <link href="http://linyishui.top/2019090101.html"/>
    <id>http://linyishui.top/2019090101.html</id>
    <published>2019-09-01T07:54:56.000Z</published>
    <updated>2019-10-14T08:40:59.827Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="Pac4j简介"><a href="#Pac4j简介" class="headerlink" title="Pac4j简介"></a><strong>Pac4j简介</strong></h1><p>&emsp;&emsp;pac4j是一个简单而强大的安全引擎，用于Java对用户进行身份验证、获取其配置文件和管理授权，以确保web应用程序安全。它提供了一套完整的概念和组件。它基于Java 8，并在Apache 2许可下使用。它可用于大多数框架/工具和支持大多数认证/授权机制。</p><hr><h2 id="第一节-主要概念和组件介绍"><a href="#第一节-主要概念和组件介绍" class="headerlink" title="第一节 主要概念和组件介绍"></a><strong>第一节 主要概念和组件介绍</strong></h2><blockquote><ol><li><strong>client</strong>(客户端): 客户端表示身份验证机制（流程），它执行登录过程并返回一个用户概要文件。间接客户端(IndirectClient)用于UI身份验证，而直接客户端(DirectClient)则用于web服务身份验证。</li><li><strong>authenticator</strong>(认证器)：HTTP客户端验证凭证需要一个认证器。它是ProfileService的一个子组件，该组件验证凭证，同时也处理用户的创建、更新和移除操作。</li><li><strong>authorizer</strong>(授权器)：授权器用于检查已认证用户的授权或当前web上下文中的授权。</li><li><strong>matcher</strong>(匹配器)：一个匹配器定义了security是否必须应用到安全过滤器。</li><li><strong>config</strong>(配置)：配置通过客户端、授权器和匹配器定义安全配置。</li><li><strong>user profile</strong>(用户概要文件)：用户概要是已认证用户的概要。它有一个标识符、属性、角色、权限、一个“记住-我”属性和一个链接标识符。</li><li><strong>web context</strong>(web上下文)：web上下文是对pac4j实现特有的HTTP请求和响应的抽象，而关联的SessionStore表示会话的实现。</li><li><strong>security filter</strong>(安全过滤器)：(或者不论使用什么原理去拦截的HTTP请求)根据客户端和授权配置，通过检查用户已认证和已授权来保护一个URL。如果用户没有被认证，它对直接客户端展示认证，对间接客户端启动登录进程。</li><li><strong>callback controller</strong>(回调控制器)：对间接客户端结束登录进程后的回调。</li><li><strong>logout controller</strong>(退出登录控制器)：处理应用程序和/或身份服务器注销。</li></ol></blockquote><hr><h2 id="第二节-认证机制"><a href="#第二节-认证机制" class="headerlink" title="第二节 认证机制"></a><strong>第二节 认证机制</strong></h2><p>&emsp;&emsp;client支持多种认证机制：OAuth - SAML - CAS - OpenID Connect - HTTP - OpenID - Google App Engine - Kerberos (SPNEGO)</p><p>&emsp;&emsp;Authenticators认证器：LDAP - SQL - JWT - MongoDB - CouchDB - IP address - REST API</p><h3 id="1-Clients"><a href="#1-Clients" class="headerlink" title="1 Clients"></a><strong>1 Clients</strong></h3><p>（未完待续…）</p><h3 id="2-Authenticators"><a href="#2-Authenticators" class="headerlink" title="2 Authenticators"></a><strong>2 Authenticators</strong></h3><p>（未完待续…）</p><hr><h2 id="第三节-认证机制-授权器"><a href="#第三节-认证机制-授权器" class="headerlink" title="第三节 认证机制-授权器"></a><strong>第三节 认证机制-授权器</strong></h2><p>▸ Roles/permissions - Anonymous/remember-me/(fully) authenticated - Profile type, attribute<br>▸ CORS - CSRF - Security headers - IP address, HTTP method</p><p>&emsp;&emsp;大多数pac4j组件实现DefaultAuthorizationChecker组件来使用pac4j的逻辑和授权。因此，下列授权器可以通过短名称自动找到：</p><blockquote><ol><li>hsts：StrictTransportSecurityHeader 认证器</li><li>nosniff： XContentTypeOptionsHeader 认证器</li><li>noframe： XFrameOptionsHeader 认证器</li><li>xssprotection： XSSProtectionHeader 认证器</li><li>nocache： CacheControlHeader 认证器</li><li>securityheaders： as a shortcut for hsts,nosniff,noframe,xssprotection,nocache</li><li>csrfToken： CsrfTokenGeneratorAuthorizer 认证器</li><li>csrfCheck： CsrfAuthorizer 认证器</li><li>csrf as a shortcut for csrfToken,csrfCheck</li><li>isAnonymous：IsAnonymousAuthorizer 认证器</li><li>isAuthenticated：IsAuthenticatedAuthorizer 认证器</li><li>isFullyAuthenticated：IsFullyAuthenticatedAuthorizer 认证器</li><li>isRemembered： IsRememberedAuthorizer 认证器</li><li>allowAjaxRequests for a default configuration of the CorsAuthorizer authorizer with the Access-Control-Allow-Origin header set to *.</li></ol></blockquote><p>&emsp;&emsp;这些短名称都作为常量定义在DefaultAuthorizers类中。</p><p>（未完待续…）</p><hr><h2 id="第四节-适配器"><a href="#第四节-适配器" class="headerlink" title="第四节 适配器"></a><strong>第四节 适配器</strong></h2><p>（未完待续…）</p><hr><h2 id="第五节-安全配置"><a href="#第五节-安全配置" class="headerlink" title="第五节 安全配置"></a><strong>第五节 安全配置</strong></h2><p>（未完待续…）</p><hr><h2 id="第六节-用户配置文件"><a href="#第六节-用户配置文件" class="headerlink" title="第六节 用户配置文件"></a><strong>第六节 用户配置文件</strong></h2><p>（未完待续…）</p><hr><h2 id="第七节-会话存储和存储"><a href="#第七节-会话存储和存储" class="headerlink" title="第七节 会话存储和存储"></a><strong>第七节 会话存储和存储</strong></h2><p>（未完待续…）</p><hr><h2 id="第八节-发布说明-向后兼容性"><a href="#第八节-发布说明-向后兼容性" class="headerlink" title="第八节 发布说明 - 向后兼容性"></a><strong>第八节 发布说明 - 向后兼容性</strong></h2><p>（未完待续…）</p><hr><h2 id="第九节-认证流程-大图"><a href="#第九节-认证流程-大图" class="headerlink" title="第九节 认证流程 - 大图"></a><strong>第九节 认证流程 - 大图</strong></h2><p>（未完待续…）</p><hr><h2 id="第十节-自定义"><a href="#第十节-自定义" class="headerlink" title="第十节 自定义"></a><strong>第十节 自定义</strong></h2><p>（未完待续…）</p><hr><h2 id="第十一节-第三方扩展"><a href="#第十一节-第三方扩展" class="headerlink" title="第十一节 第三方扩展"></a><strong>第十一节 第三方扩展</strong></h2><p>（未完待续…）</p><hr><h2 id="第十二节-Java文档"><a href="#第十二节-Java文档" class="headerlink" title="第十二节 Java文档"></a><strong>第十二节 Java文档</strong></h2><p>（未完待续…）</p><hr><p><em>参考博客和文章书籍等：</em></p><blockquote><p><a href="http://www.pac4j.org/docs/index.html" title="Title" target="_blank" rel="noopener">Pac4j官方文档</a></p></blockquote><blockquote><p><a href="https://blog.csdn.net/u010004082/article/details/79744481" title="Title" target="_blank" rel="noopener">Pac4j文档翻译（3.0）</a></p></blockquote><p><em>因博客主等未标明不可引用，若部分内容涉及侵权请及时告知，我会尽快修改和删除相关内容</em></p>]]></content>
    
    <summary type="html">
    
      简单介绍Pac4j。
    
    </summary>
    
      <category term="技术文档" scheme="http://linyishui.top/categories/%E6%8A%80%E6%9C%AF%E6%96%87%E6%A1%A3/"/>
    
    
      <category term="java" scheme="http://linyishui.top/tags/java/"/>
    
      <category term="security" scheme="http://linyishui.top/tags/security/"/>
    
      <category term="pac4j" scheme="http://linyishui.top/tags/pac4j/"/>
    
  </entry>
  
  <entry>
    <title>线程池</title>
    <link href="http://linyishui.top/2019082901.html"/>
    <id>http://linyishui.top/2019082901.html</id>
    <published>2019-08-29T09:21:10.000Z</published>
    <updated>2019-10-12T10:04:48.153Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="线程池"><a href="#线程池" class="headerlink" title="线程池"></a><strong>线程池</strong></h1><p>&emsp;&emsp;Java中的线程池是运用场景最多的并发框架，几乎所有需要异步或并发执行任务的程序 都可以使用线程池。在开发过程中，合理地使用线程池能够带来3个好处。</p><p>&emsp;&emsp;第一：降低资源消耗。通过重复利用已创建的线程降低线程创建和销毁造成的消耗。</p><p>&emsp;&emsp;第二：提高响应速度。当任务到达时，任务可以不需要等到线程创建就能立即执行。</p><p>&emsp;&emsp;第三：提高线程的可管理性。线程是稀缺资源，如果无限制地创建，不仅会消耗系统资源，</p><p>&emsp;&emsp;还会降低系统的稳定性，使用线程池可以进行统一分配、调优和监控。但是，要做到合理利用线程池，必须对其实现原理了如指掌。</p><hr><h2 id="第一节-线程池的实现原理"><a href="#第一节-线程池的实现原理" class="headerlink" title="第一节 线程池的实现原理"></a><strong>第一节 线程池的实现原理</strong></h2><p>&emsp;&emsp;当向线程池提交一个任务之后，线程池是如何处理这个任务的呢？本节来看一下线程池 的主要处理流程，处理流程图如下图所示。从图中可以看出，当提交一个新任务到线程池时，线程池的处理流程如下。</p><p><img src="https://pic-1258215793.cos.ap-shanghai.myqcloud.com/content/20190701/201907010109.png" alt="线程池的主要处理流程"></p><ol><li>线程池判断核心线程池里的线程是否都在执行任务。如果不是，则创建一个新的工作线程来执行任务。如果核心线程池里的线程都在执行任务，则进入下个流程。</li><li>线程池判断工作队列是否已经满。如果工作队列没有满，则将新提交的任务存储在这个工作队列里。如果工作队列满了，则进入下个流程。</li><li>线程池判断线程池的线程是否都处于工作状态。如果没有，则创建一个新的工作线程来执行任务。如果已经满了，则交给饱和策略来处理这个任务。</li></ol><p>&emsp;&emsp;ThreadPoolExecutor执行execute()方法的示意图，如下图所示。</p><p><img src="https://pic-1258215793.cos.ap-shanghai.myqcloud.com/content/20190701/201907010110.png" alt="ThreadPoolExecutor执行示意图"></p><p>&emsp;&emsp;ThreadPoolExecutor执行execute方法分下面4种情况。</p><ol><li>如果当前运行的线程少于corePoolSize，则创建新线程来执行任务（注意，执行这一步骤需要获取全局锁）。</li><li>如果运行的线程等于或多于corePoolSize，则将任务加入BlockingQueue。</li><li>如果无法将任务加入BlockingQueue（队列已满），则创建新的线程来处理任务（注意，执行这一步骤需要获取全局锁）。</li><li>如果创建新线程将使当前运行的线程超出maximumPoolSize，任务将被拒绝，并调用 RejectedExecutionHandler.rejectedExecution()方法。</li></ol><p>&emsp;&emsp;ThreadPoolExecutor采取上述步骤的总体设计思路，是为了在执行execute()方法时，尽可能地避免获取全局锁（那将会是一个严重的可伸缩瓶颈）。在ThreadPoolExecutor完成预热之后 （当前运行的线程数大于等于corePoolSize），几乎所有的execute()方法调用都是执行步骤2，而步骤2不需要获取全局锁。</p><p>&emsp;&emsp;源码分析：上面的流程分析让我们很直观地了解了线程池的工作原理，让我们再通过源代码来看看是如何实现的，线程池执行任务的方法如下。</p><figure class="highlight aspectj"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="function"><span class="keyword">void</span> <span class="title">execute</span><span class="params">(Runnable command)</span> </span>&#123;        </span><br><span class="line">    <span class="keyword">if</span> (command == <span class="keyword">null</span>)            </span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> NullPointerException(); </span><br><span class="line">    <span class="comment">// 如果线程数小于基本线程数，则创建线程并执行当前任务 </span></span><br><span class="line">    <span class="keyword">if</span> (poolSize &gt;= corePoolSize || !addIfUnderCorePoolSize(command)) &#123; </span><br><span class="line">        <span class="comment">// 如线程数大于等于基本线程数或线程创建失败，则将当前任务放到工作队列中。 </span></span><br><span class="line">        <span class="keyword">if</span> (runState == RUNNING &amp;&amp; workQueue.offer(command)) &#123;        </span><br><span class="line">            <span class="keyword">if</span> (runState != RUNNING || poolSize == <span class="number">0</span>)                    </span><br><span class="line">                ensureQueuedTaskHandled(command); </span><br><span class="line">        &#125; </span><br><span class="line">        <span class="comment">// 如果线程池不处于运行中或任务无法放入队列，并且当前线程数量小于最大允许的线程数量， </span></span><br><span class="line">        <span class="comment">// 则创建一个线程执行任务。 </span></span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (!addIfUnderMaximumPoolSize(command)) </span><br><span class="line">        <span class="comment">// 抛出RejectedExecutionException异常 </span></span><br><span class="line">        reject(command); </span><br><span class="line">        <span class="comment">// is shutdown or saturated            </span></span><br><span class="line">    &#125;        </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>&emsp;&emsp;工作线程：线程池创建线程时，会将线程封装成工作线程Worker，Worker在执行完任务后，还会循环获取工作队列里的任务来执行。我们可以从Worker类的run()方法里看到这点。</p><figure class="highlight gradle"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> run() &#123;    </span><br><span class="line">    <span class="keyword">try</span> &#123;        </span><br><span class="line">        Runnable <span class="keyword">task</span> = firstTask;        </span><br><span class="line">        firstTask = <span class="keyword">null</span>;        </span><br><span class="line">        <span class="keyword">while</span> (<span class="keyword">task</span> != <span class="keyword">null</span> || (<span class="keyword">task</span> = getTask()) != <span class="keyword">null</span>) &#123;                </span><br><span class="line">            runTask(<span class="keyword">task</span>);</span><br><span class="line">            <span class="keyword">task</span> = <span class="keyword">null</span>;        </span><br><span class="line">        &#125;    </span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;            </span><br><span class="line">        workerDone(<span class="keyword">this</span>);    </span><br><span class="line">    &#125; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>&emsp;&emsp;ThreadPoolExecutor中线程执行任务的示意图如下图所示。</p><p><img src="https://pic-1258215793.cos.ap-shanghai.myqcloud.com/content/20190701/201907010111.png" alt="ThreadPoolExecutor执行任务示意图"></p><p>&emsp;&emsp;线程池中的线程执行任务分两种情况，如下。</p><ol><li>在execute()方法中创建一个线程时，会让这个线程执行当前任务。</li><li>这个线程执行完上图中1的任务后，会反复从BlockingQueue获取任务来执行。</li></ol><hr><h2 id="第二节-线程池的使用"><a href="#第二节-线程池的使用" class="headerlink" title="第二节 线程池的使用"></a><strong>第二节 线程池的使用</strong></h2><h3 id="1-线程池的创建"><a href="#1-线程池的创建" class="headerlink" title="1 线程池的创建"></a><strong>1 线程池的创建</strong></h3><p>&emsp;&emsp;我们可以通过ThreadPoolExecutor来创建一个线程池。</p><figure class="highlight aspectj"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">new</span>  ThreadPoolExecutor(corePoolSize, maximumPoolSize, keepAliveTime, milliseconds,runnableTaskQueue, <span class="keyword">handler</span>);</span><br></pre></td></tr></table></figure><p>&emsp;&emsp;创建一个线程池时需要输入几个参数，如下。</p><ol><li><p>corePoolSize（线程池的基本大小）：当提交一个任务到线程池时，线程池会创建一个线程来执行任务，即使其他空闲的基本线程能够执行新任务也会创建线程，等到需要执行的任 务数大于线程池基本大小时就不再创建。如果调用了线程池的prestartAllCoreThreads()方法，线程池会提前创建并启动所有基本线程。</p></li><li><p>runnableTaskQueue（任务队列）：用于保存等待执行的任务的阻塞队列。可以选择以下几个阻塞队列。</p></li></ol><ul><li>ArrayBlockingQueue：是一个基于数组结构的有界阻塞队列，此队列按FIFO（先进先出）原则对元素进行排序。</li><li>LinkedBlockingQueue：一个基于链表结构的阻塞队列，此队列按FIFO排序元素，吞吐量通 常要高于ArrayBlockingQueue。静态工厂方法Executors.newFixedThreadPool()使用了这个队列。</li><li>SynchronousQueue：一个不存储元素的阻塞队列。每个插入操作必须等到另一个线程调用 移除操作，否则插入操作一直处于阻塞状态，吞吐量通常要高于Linked-BlockingQueue，静态工 厂方法Executors.newCachedThreadPool使用了这个队列。</li><li>PriorityBlockingQueue：一个具有优先级的无限阻塞队列。</li></ul><ol start="3"><li><p>maximumPoolSize（线程池最大数量）：线程池允许创建的最大线程数。如果队列满了，并且已创建的线程数小于最大线程数，则线程池会再创建新的线程执行任务。值得注意的是，如果使用了无界的任务队列这个参数就没什么效果。</p></li><li><p>ThreadFactory：用于设置创建线程的工厂，可以通过线程工厂给每个创建出来的线程设 置更有意义的名字。使用开源框架guava提供的ThreadFactoryBuilder可以快速给线程池里的线程设置有意义的名字，代码如下。</p></li></ol><figure class="highlight less"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-tag">new</span> <span class="selector-tag">ThreadFactoryBuilder</span>()<span class="selector-class">.setNameFormat</span>(<span class="string">"XX-task-%d"</span>)<span class="selector-class">.build</span>();</span><br></pre></td></tr></table></figure><ol start="5"><li>RejectedExecutionHandler（饱和策略）：当队列和线程池都满了，说明线程池处于饱和状态，那么必须采取一种策略处理提交的新任务。这个策略默认情况下是AbortPolicy，表示无法处理新任务时抛出异常。在JDK 1.5中Java线程池框架提供了以下4种策略。</li></ol><ul><li>AbortPolicy：直接抛出异常。</li><li>CallerRunsPolicy：只用调用者所在线程来运行任务。</li><li>DiscardOldestPolicy：丢弃队列里最近的一个任务，并执行当前任务。</li><li>DiscardPolicy：不处理，丢弃掉。当然，也可以根据应用场景需要来实现RejectedExecutionHandler接口自定义策略。如记录日志或持久化存储不能处理的任务。</li><li>keepAliveTime（线程活动保持时间）：线程池的工作线程空闲后，保持存活的时间。所以，如果任务很多，并且每个任务执行的时间比较短，可以调大时间，提高线程的利用率。</li><li>TimeUnit（线程活动保持时间的单位）：可选的单位有天（DAYS）、小时（HOURS）、分钟 （MINUTES）、毫秒（MILLISECONDS）、微秒（MICROSECONDS，千分之一毫秒）和纳秒（NANOSECONDS，千分之一微秒）。</li></ul><h3 id="2-向线程池提交任务"><a href="#2-向线程池提交任务" class="headerlink" title="2 向线程池提交任务"></a><strong>2 向线程池提交任务</strong></h3><p>&emsp;&emsp;可以使用两个方法向线程池提交任务，分别为execute()和submit()方法。execute()方法用于提交不需要返回值的任务，所以无法判断任务是否被线程池执行成功。 通过以下代码可知execute()方法输入的任务是一个Runnable类的实例。</p><figure class="highlight aspectj"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">threadsPool.execute(<span class="keyword">new</span> Runnable() &#123;                        </span><br><span class="line">    <span class="meta">@Override</span>                        </span><br><span class="line">    <span class="keyword">public</span> <span class="function"><span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;                                </span><br><span class="line">        <span class="comment">// TODO Auto-generated method stub                        </span></span><br><span class="line">    &#125;                </span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p>&emsp;&emsp;submit()方法用于提交需要返回值的任务。线程池会返回一个future类型的对象，通过这个 future对象可以判断任务是否执行成功，并且可以通过future的get()方法来获取返回值，get()方 法会阻塞当前线程直到任务完成，而使用get（long timeout，TimeUnit unit）方法则会阻塞当前线程一段时间后立即返回，这时候有可能任务没有执行完。</p><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">Future&lt;<span class="built_in">Object</span>&gt; future = executor.submit(harReturnValuetask);                </span><br><span class="line"><span class="keyword">try</span> &#123;                        </span><br><span class="line">    <span class="built_in">Object</span> s = future.<span class="keyword">get</span>();                </span><br><span class="line">&#125; <span class="keyword">catch</span> (InterruptedException e) &#123;                        </span><br><span class="line">    <span class="comment">// 处理中断异常                </span></span><br><span class="line">&#125; <span class="keyword">catch</span> (ExecutionException e) &#123;                        </span><br><span class="line">    <span class="comment">// 处理无法执行任务异常                </span></span><br><span class="line">&#125; <span class="keyword">finally</span> &#123;                        </span><br><span class="line">    <span class="comment">// 关闭线程池                        </span></span><br><span class="line">    executor.shutdown();                </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="3-关闭线程池"><a href="#3-关闭线程池" class="headerlink" title="3 关闭线程池"></a><strong>3 关闭线程池</strong></h3><p>&emsp;&emsp;可以通过调用线程池的shutdown或shutdownNow方法来关闭线程池。它们的原理是遍历线 程池中的工作线程，然后逐个调用线程的interrupt方法来中断线程，所以无法响应中断的任务 可能永远无法终止。但是它们存在一定的区别，shutdownNow首先将线程池的状态设置成 STOP，然后尝试停止所有的正在执行或暂停任务的线程，并返回等待执行任务的列表，而 shutdown只是将线程池的状态设置成SHUTDOWN状态，然后中断所有没有正在执行任务的线程。</p><p>&emsp;&emsp;只要调用了这两个关闭方法中的任意一个，isShutdown方法就会返回true。当所有的任务 都已关闭后，才表示线程池关闭成功，这时调用isTerminaed方法会返回true。至于应该调用哪 一种方法来关闭线程池，应该由提交到线程池的任务特性决定，通常调用shutdown方法来关闭 线程池，如果任务不一定要执行完，则可以调用shutdownNow方法。</p><h3 id="4-合理地配置线程池"><a href="#4-合理地配置线程池" class="headerlink" title="4 合理地配置线程池"></a><strong>4 合理地配置线程池</strong></h3><p>&emsp;&emsp;要想合理地配置线程池，就必须首先分析任务特性，可以从以下几个角度来分析。</p><ul><li>任务的性质：CPU密集型任务、IO密集型任务和混合型任务。</li><li>任务的优先级：高、中和低。</li><li>任务的执行时间：长、中和短。</li><li>任务的依赖性：是否依赖其他系统资源，如数据库连接。</li></ul><p>&emsp;&emsp;性质不同的任务可以用不同规模的线程池分开处理。CPU密集型任务应配置尽可能小的 线程，如配置Ncpu+1个线程的线程池。由于IO密集型任务线程并不是一直在执行任务，则应配 置尽可能多的线程，如2*Ncpu。混合型的任务，如果可以拆分，将其拆分成一个CPU密集型任务 和一个IO密集型任务，只要这两个任务执行的时间相差不是太大，那么分解后执行的吞吐量</p><p>&emsp;&emsp;将高于串行执行的吞吐量。如果这两个任务执行时间相差太大，则没必要进行分解。可以通过 Runtime.getRuntime().availableProcessors()方法获得当前设备的CPU个数。</p><p>&emsp;&emsp;优先级不同的任务可以使用优先级队列PriorityBlockingQueue来处理。它可以让优先级高的任务先执行。</p><p>&emsp;&emsp;注意如果一直有优先级高的任务提交到队列里，那么优先级低的任务可能永远不能<br>执行。</p><p>&emsp;&emsp;执行时间不同的任务可以交给不同规模的线程池来处理，或者可以使用优先级队列，让执行时间短的任务先执行。</p><p>&emsp;&emsp;依赖数据库连接池的任务，因为线程提交SQL后需要等待数据库返回结果，等待的时间越 长，则CPU空闲时间就越长，那么线程数应该设置得越大，这样才能更好地利用CPU。</p><p>&emsp;&emsp;建议使用有界队列。有界队列能增加系统的稳定性和预警能力，可以根据需要设大一点儿，比如几千。有一次，我们系统里后台任务线程池的队列和线程池全满了，不断抛出抛弃任 务的异常，通过排查发现是数据库出现了问题，导致执行SQL变得非常缓慢，因为后台任务线程池里的任务全是需要向数据库查询和插入数据的，所以导致线程池里的工作线程全部阻塞，任务积压在线程池里。如果当时我们设置成无界队列，那么线程池的队列就会越来越多，有可能会撑满内存，导致整个系统不可用，而不只是后台任务出现问题。当然，我们的系统所有的任务是用单独的服务器部署的，我们使用不同规模的线程池完成不同类型的任务，但是出现这样问题时也会影响到其他任务。</p><h3 id="5-线程池的监控"><a href="#5-线程池的监控" class="headerlink" title="5 线程池的监控"></a><strong>5 线程池的监控</strong></h3><p>&emsp;&emsp;如果在系统中大量使用线程池，则有必要对线程池进行监控，方便在出现问题时，可以根据线程池的使用状况快速定位问题。可以通过线程池提供的参数进行监控，在监控线程池的时候可以使用以下属性。</p><ul><li>taskCount：线程池需要执行的任务数量。</li><li>completedTaskCount：线程池在运行过程中已完成的任务数量，小于或等于taskCount。</li><li>largestPoolSize：线程池里曾经创建过的最大线程数量。通过这个数据可以知道线程池是否曾经满过。如该数值等于线程池的最大大小，则表示线程池曾经满过。</li><li>getPoolSize：线程池的线程数量。如果线程池不销毁的话，线程池里的线程不会自动销毁，所以这个大小只增不减。</li><li>getActiveCount：获取活动的线程数。</li></ul><p>&emsp;&emsp;通过扩展线程池进行监控。可以通过继承线程池来自定义线程池，重写线程池的 beforeExecute、afterExecute和terminated方法，也可以在任务执行前、执行后和线程池关闭前执行一些代码来进行监控。例如，监控任务的平均执行时间、最大执行时间和最小执行时间等。这几个方法在线程池里是空方法。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">beforeExecute</span><span class="params">(Thread t, Runnable r)</span> </span>&#123; &#125;</span><br></pre></td></tr></table></figure><p>9.3　本章小结</p><p>&emsp;&emsp;在工作中我经常发现，很多人因为不了解线程池的实现原理，把线程池配置错误，从而导致了各种问题。本章介绍了为什么要使用线程池、如何使用线程池和线程池的使用原理，相信阅读完本章之后，读者能更准确、更有效地使用线程池。</p><hr><p><em>参考博客和文章书籍等：</em></p><blockquote><p>《Java并发编程的艺术》</p></blockquote><p><em>因博客主等未标明不可引用，若部分内容涉及侵权请及时告知，我会尽快修改和删除相关内容</em></p>]]></content>
    
    <summary type="html">
    
      介绍Java中线程池，包括：线程池的实现原理和使用等。
    
    </summary>
    
      <category term="技术文档" scheme="http://linyishui.top/categories/%E6%8A%80%E6%9C%AF%E6%96%87%E6%A1%A3/"/>
    
    
      <category term="java" scheme="http://linyishui.top/tags/java/"/>
    
      <category term="lock" scheme="http://linyishui.top/tags/lock/"/>
    
  </entry>
  
  <entry>
    <title>Java常用并发工具类</title>
    <link href="http://linyishui.top/2019082801.html"/>
    <id>http://linyishui.top/2019082801.html</id>
    <published>2019-08-28T08:44:47.000Z</published>
    <updated>2019-10-12T09:20:02.759Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="Java中的并发工具类"><a href="#Java中的并发工具类" class="headerlink" title="Java中的并发工具类"></a><strong>Java中的并发工具类</strong></h1><p>&emsp;&emsp;在JDK的并发包里提供了几个非常有用的并发工具类。CountDownLatch、CyclicBarrier和Semaphore工具类提供了一种并发流程控制的手段，Exchanger工具类则提供了在线程间交换数据的一种手段。本章会配合一些应用场景来介绍如何使用这些工具类。</p><hr><h2 id="第一节-等待多线程完成的CountDownLatch"><a href="#第一节-等待多线程完成的CountDownLatch" class="headerlink" title="第一节 等待多线程完成的CountDownLatch"></a><strong>第一节 等待多线程完成的CountDownLatch</strong></h2><p>&emsp;&emsp;CountDownLatch允许一个或多个线程等待其他线程完成操作。</p><p>&emsp;&emsp;假如有这样一个需求：我们需要解析一个Excel里多个sheet的数据，此时可以考虑使用多线程，每个线程解析一个sheet里的数据，等到所有的sheet都解析完之后，程序需要提示解析完成。在这个需求中，要实现主线程等待所有线程完成sheet的解析操作，最简单的做法是使用 join()方法，如代码清单8-1所示。</p><figure class="highlight cs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">JoinCountDownLatchTest</span> &#123;    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span>(<span class="params">String[] args</span>) throws InterruptedException </span>&#123;        </span><br><span class="line">        Thread parser1 = <span class="keyword">new</span> Thread(<span class="keyword">new</span> Runnable() &#123;            </span><br><span class="line">            @Override   </span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span>(<span class="params"></span>) </span>&#123;            </span><br><span class="line"></span><br><span class="line">            &#125;        </span><br><span class="line">        &#125;);        </span><br><span class="line">        </span><br><span class="line">        Thread parser2 = <span class="keyword">new</span> Thread(<span class="keyword">new</span> Runnable() &#123;            </span><br><span class="line">            @Override    </span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span>(<span class="params"></span>) </span>&#123;    </span><br><span class="line">                System.<span class="keyword">out</span>.println(<span class="string">"parser2 finish"</span>);            </span><br><span class="line">            &#125;        </span><br><span class="line">        &#125;);    </span><br><span class="line">        </span><br><span class="line">        parser1.start();    </span><br><span class="line">        parser2.start();    </span><br><span class="line">        parser1.<span class="keyword">join</span>();    </span><br><span class="line">        parser2.<span class="keyword">join</span>();    </span><br><span class="line">        System.<span class="keyword">out</span>.println(<span class="string">"all parser finish"</span>);    </span><br><span class="line">    &#125; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>&emsp;&emsp;join用于让当前执行线程等待join线程执行结束。其实现原理是不停检查join线程是否存活，如果join线程存活则让当前线程永远等待。其中，wait（0）表示永远等待下去，代码片段如下。</p><figure class="highlight gcode"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">while</span> <span class="comment">(isAlive()</span>) &#123; </span><br><span class="line">    wait<span class="comment">(0)</span>; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>&emsp;&emsp;直到join线程中止后，线程的this.notifyAll()方法会被调用，调用notifyAll()方法是在JVM里 实现的，所以在JDK里看不到，大家可以查看JVM源码。<br>在JDK 1.5之后的并发包中提供的CountDownLatch也可以实现join的功能，并且比join的功能更多，如下所示。</p><figure class="highlight cs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">CountDownLatchTest</span> &#123; </span><br><span class="line">    staticCountDownLatch c = <span class="keyword">new</span> CountDownLatch(<span class="number">2</span>); </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span>(<span class="params">String[] args</span>) throws InterruptedException </span>&#123; </span><br><span class="line">        <span class="keyword">new</span> Thread(<span class="keyword">new</span> Runnable() &#123;            </span><br><span class="line">            @Override </span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span>(<span class="params"></span>) </span>&#123; </span><br><span class="line">                System.<span class="keyword">out</span>.println(<span class="number">1</span>); </span><br><span class="line">                c.countDown(); </span><br><span class="line">                System.<span class="keyword">out</span>.println(<span class="number">2</span>); </span><br><span class="line">                c.countDown();            </span><br><span class="line">            &#125;       </span><br><span class="line">        &#125;).start(); </span><br><span class="line">        c.<span class="keyword">await</span>(); </span><br><span class="line">        System.<span class="keyword">out</span>.println(<span class="string">"3"</span>);    </span><br><span class="line">    &#125; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>&emsp;&emsp;CountDownLatch的构造函数接收一个int类型的参数作为计数器，如果你想等待N个点完成，这里就传入N。</p><p>&emsp;&emsp;当我们调用CountDownLatch的countDown方法时，N就会减1，CountDownLatch的await方法 会阻塞当前线程，直到N变成零。由于countDown方法可以用在任何地方，所以这里说的N个点，可以是N个线程，也可以是1个线程里的N个执行步骤。用在多个线程时，只需要把这个CountDownLatch的引用传递到线程里即可。</p><p>&emsp;&emsp;如果有某个解析sheet的线程处理得比较慢，我们不可能让主线程一直等待，所以可以使 用另外一个带指定时间的await方法——await（long time，TimeUnit unit），这个方法等待特定时 间后，就会不再阻塞当前线程。join也有类似的方法。</p><p>&emsp;&emsp;注意　计数器必须大于等于0，只是等于0时候，计数器就是零，调用await方法时不会阻塞当前线程。CountDownLatch不可能重新初始化或者修改CountDownLatch对象的内部计数 器的值。一个线程调用countDown方法happen-before，另外一个线程调用await方法。</p><hr><h2 id="第二节-同步屏障CyclicBarrier"><a href="#第二节-同步屏障CyclicBarrier" class="headerlink" title="第二节 同步屏障CyclicBarrier"></a><strong>第二节 同步屏障CyclicBarrier</strong></h2><p>&emsp;&emsp;CyclicBarrier的字面意思是可循环使用（Cyclic）的屏障（Barrier）。它要做的事情是，让一组线程到达一个屏障（也可以叫同步点）时被阻塞，直到最后一个线程到达屏障时，屏障才会开门，所有被屏障拦截的线程才会继续运行。</p><h3 id="1-CyclicBarrier简介"><a href="#1-CyclicBarrier简介" class="headerlink" title="1 CyclicBarrier简介"></a><strong>1 CyclicBarrier简介</strong></h3><p>&emsp;&emsp;CyclicBarrier默认的构造方法是CyclicBarrier（int parties），其参数表示屏障拦截的线程数量，每个线程调用await方法告诉CyclicBarrier我已经到达了屏障，然后当前线程被阻塞。示例代码如下所示。</p><figure class="highlight cs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">CyclicBarrierTest</span> &#123; </span><br><span class="line">    staticCyclicBarrier c = <span class="keyword">new</span> CyclicBarrier(<span class="number">2</span>); </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span>(<span class="params">String[] args</span>) </span>&#123;        </span><br><span class="line">        <span class="keyword">new</span> Thread(<span class="keyword">new</span> Runnable() &#123;            </span><br><span class="line">            @Override            </span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span>(<span class="params"></span>) </span>&#123;                </span><br><span class="line">                <span class="keyword">try</span> &#123;                    </span><br><span class="line">                    c.<span class="keyword">await</span>();                </span><br><span class="line">                &#125; <span class="keyword">catch</span> (Exception e) &#123;                </span><br><span class="line"></span><br><span class="line">                &#125;                </span><br><span class="line">                System.<span class="keyword">out</span>.println(<span class="number">1</span>);            </span><br><span class="line">            &#125;        </span><br><span class="line">        &#125;).start(); </span><br><span class="line">        </span><br><span class="line">        <span class="keyword">try</span> &#123;        </span><br><span class="line">            c.<span class="keyword">await</span>();        </span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;        </span><br><span class="line"></span><br><span class="line">        &#125;        </span><br><span class="line">        </span><br><span class="line">        System.<span class="keyword">out</span>.println(<span class="number">2</span>);    </span><br><span class="line">    &#125; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>&emsp;&emsp;因为主线程和子线程的调度是由CPU决定的，两个线程都有可能先执行，所以会产生两种输出，第一种可能输出如下。</p><figure class="highlight basic"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="symbol">1 </span><span class="number">2</span></span><br></pre></td></tr></table></figure><p>&emsp;&emsp;第二种可能输出如下。</p><figure class="highlight basic"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="symbol">2 </span><span class="number">1</span></span><br></pre></td></tr></table></figure><p>&emsp;&emsp;如果把new CyclicBarrier(2)修改成new CyclicBarrier(3)，则主线程和子线程会永远等待， 因为没有第三个线程执行await方法，即没有第三个线程到达屏障，所以之前到达屏障的两个线程都不会继续执行。</p><p>&emsp;&emsp;CyclicBarrier还提供一个更高级的构造函数CyclicBarrier（int parties，Runnable barrierAction），用于在线程到达屏障时，优先执行barrierAction，方便处理更复杂的业务场景，如下所示。</p><figure class="highlight cs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line">import java.util.concurrent.CyclicBarrier; </span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">CyclicBarrierTest2</span> &#123;        </span><br><span class="line">    <span class="keyword">static</span> CyclicBarrier c = <span class="keyword">new</span> CyclicBarrier(<span class="number">2</span>, <span class="keyword">new</span> A());        </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span>(<span class="params">String[] args</span>) </span>&#123;                </span><br><span class="line">        <span class="keyword">new</span> Thread(<span class="keyword">new</span> Runnable() &#123;                        </span><br><span class="line">            @Override                        </span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span>(<span class="params"></span>) </span>&#123;                                </span><br><span class="line">                <span class="keyword">try</span> &#123;                                        </span><br><span class="line">                    c.<span class="keyword">await</span>();                                </span><br><span class="line">                &#125; <span class="keyword">catch</span> (Exception e) &#123;                                </span><br><span class="line"></span><br><span class="line">                &#125;                                </span><br><span class="line">                System.<span class="keyword">out</span>.println(<span class="number">1</span>);                        </span><br><span class="line">            &#125;                </span><br><span class="line">        &#125;).start();                </span><br><span class="line">        </span><br><span class="line">        <span class="keyword">try</span> &#123;                        </span><br><span class="line">            c.<span class="keyword">await</span>();                </span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;                </span><br><span class="line"></span><br><span class="line">        &#125;                </span><br><span class="line">        </span><br><span class="line">        System.<span class="keyword">out</span>.println(<span class="number">2</span>);        </span><br><span class="line">    &#125;        </span><br><span class="line">    </span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">class</span> <span class="title">A</span> <span class="title">implements</span> <span class="title">Runnable</span> &#123;                </span><br><span class="line">        @Override                </span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span>(<span class="params"></span>) </span>&#123;                        </span><br><span class="line">            System.<span class="keyword">out</span>.println(<span class="number">3</span>);                </span><br><span class="line">        &#125;        </span><br><span class="line">    &#125; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>&emsp;&emsp;因为CyclicBarrier设置了拦截线程的数量是2，所以必须等代码中的第一个线程和线程A 都执行完之后，才会继续执行主线程，然后输出2，所以代码执行后的输出如下。</p><figure class="highlight basic"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="symbol">3 </span><span class="number">1</span></span><br><span class="line"><span class="number">2</span></span><br></pre></td></tr></table></figure><h3 id="2-CyclicBarrier的应用场景"><a href="#2-CyclicBarrier的应用场景" class="headerlink" title="2 CyclicBarrier的应用场景"></a><strong>2 CyclicBarrier的应用场景</strong></h3><p>&emsp;&emsp;CyclicBarrier可以用于多线程计算数据，最后合并计算结果的场景。例如，用一个Excel保存了用户所有银行流水，每个Sheet保存一个账户近一年的每笔银行流水，现在需要统计用户的日均银行流水，先用多线程处理每个sheet里的银行流水，都执行完之后，得到每个sheet的日均银行流水，最后，再用barrierAction用这些线程的计算结果，计算出整个Excel的日均银行流水，如下所示。</p><figure class="highlight haxe"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.Map.Entry; </span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.BrokenBarrierException; </span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.ConcurrentHashMap; </span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.CyclicBarrier; </span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.Executor; </span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.Executors; </span><br><span class="line"></span><br><span class="line"><span class="comment">/** </span></span><br><span class="line"><span class="comment"> * 银行流水处理服务类 </span></span><br><span class="line"><span class="comment"> *  </span></span><br><span class="line"><span class="comment"> * @authorftf </span></span><br><span class="line"><span class="comment"> *  </span></span><br><span class="line"><span class="comment"> */</span> </span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">BankWaterService</span> <span class="keyword"><span class="keyword">implements</span> <span class="type">Runnable</span></span> </span>&#123;        </span><br><span class="line">    <span class="comment">/**         </span></span><br><span class="line"><span class="comment">     * 创建4个屏障，处理完之后执行当前类的run方法         </span></span><br><span class="line"><span class="comment">     */</span>        </span><br><span class="line">    <span class="keyword">private</span> CyclicBarrier c = <span class="keyword">new</span> <span class="type">CyclicBarrier</span>(<span class="number">4</span>, <span class="built_in">this</span>);        </span><br><span class="line">    </span><br><span class="line">    <span class="comment">/**         </span></span><br><span class="line"><span class="comment">     * 假设只有4个sheet，所以只启动4个线程         </span></span><br><span class="line"><span class="comment">     */</span>        </span><br><span class="line">    <span class="keyword">private</span> Executor executor = Executors.<span class="keyword">new</span><span class="type">FixedThreadPool</span>(<span class="number">4</span>);        </span><br><span class="line">        </span><br><span class="line">    <span class="comment">/**         </span></span><br><span class="line"><span class="comment">     * 保存每个sheet计算出的银流结果         </span></span><br><span class="line"><span class="comment">     */</span>        </span><br><span class="line">    <span class="keyword">private</span> ConcurrentHashMap&lt;<span class="keyword">String</span>, Integer&gt;sheetBankWaterCount = <span class="keyword">new</span> <span class="type">ConcurrentHashMap</span>&lt;<span class="keyword">String</span>, Integer&gt;();        </span><br><span class="line">    privatevoid count() &#123;                </span><br><span class="line">        <span class="keyword">for</span> (inti = <span class="number">0</span>; i&lt; <span class="number">4</span>; i++) &#123;                        </span><br><span class="line">            executor.execute(<span class="keyword">new</span> <span class="type">Runnable</span>() &#123;                                </span><br><span class="line">                @Override                                </span><br><span class="line">                publicvoid run() &#123;                                        </span><br><span class="line">                    <span class="comment">// 计算当前sheet的银流数据，计算代码省略                                        </span></span><br><span class="line">                    sheetBankWaterCount.put(Thread.currentThread().getName(), <span class="number">1</span>);                                        </span><br><span class="line">                    <span class="comment">// 银流计算完成，插入一个屏障                                        </span></span><br><span class="line">                     <span class="keyword">try</span> &#123;</span><br><span class="line">                        c.await();                                        </span><br><span class="line">                    &#125; <span class="keyword">catch</span> (InterruptedException | BrokenBarrierException e) &#123;    </span><br><span class="line">                        e.printStackTrace();                                       </span><br><span class="line">                    &#125;                                </span><br><span class="line">                &#125;                        </span><br><span class="line">            &#125;);                </span><br><span class="line">        &#125;      </span><br><span class="line">    &#125;        </span><br><span class="line">        </span><br><span class="line">    @Override        </span><br><span class="line">    publicvoid run() &#123;                </span><br><span class="line">        intresult = <span class="number">0</span>;                </span><br><span class="line">        <span class="comment">// 汇总每个sheet计算出的结果                </span></span><br><span class="line">        <span class="keyword">for</span> (Entry&lt;<span class="keyword">String</span>, Integer&gt;sheet : <span class="type">sheetBankWaterCount</span>.entrySet()) &#123;                        </span><br><span class="line">            result += sheet.getValue();                </span><br><span class="line">        &#125;                </span><br><span class="line">        <span class="comment">// 将结果输出                </span></span><br><span class="line">        sheetBankWaterCount.put(<span class="string">"result"</span>, result);                </span><br><span class="line">        System.out.println(result);        </span><br><span class="line">    &#125;        </span><br><span class="line">        </span><br><span class="line">    <span class="keyword">public</span> staticvoid main(<span class="keyword">String</span>[] args) &#123;                </span><br><span class="line">        BankWaterService bankWaterCount = <span class="keyword">new</span> <span class="type">BankWaterService</span>();                </span><br><span class="line">        bankWaterCount.count();        </span><br><span class="line">    &#125; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>&emsp;&emsp;使用线程池创建4个线程，分别计算每个sheet里的数据，每个sheet计算结果是1，再由 BankWaterService线程汇总4个sheet计算出的结果，输出结果如下。</p><figure class="highlight lsl"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">4</span></span><br></pre></td></tr></table></figure><h3 id="3-CyclicBarrier和CountDownLatch的区别"><a href="#3-CyclicBarrier和CountDownLatch的区别" class="headerlink" title="3 CyclicBarrier和CountDownLatch的区别"></a><strong>3 CyclicBarrier和CountDownLatch的区别</strong></h3><p>&emsp;&emsp;CountDownLatch的计数器只能使用一次，而CyclicBarrier的计数器可以使用reset()方法重置。所以CyclicBarrier能处理更为复杂的业务场景。例如，如果计算发生错误，可以重置计数器，并让线程重新执行一次。</p><p>&emsp;&emsp;CyclicBarrier还提供其他有用的方法，比如getNumberWaiting方法可以获得Cyclic-Barrier阻塞的线程数量。isBroken()方法用来了解阻塞的线程是否被中断。上段代码执行完之后会返回true，其中isBroken的使用代码如下所示。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.concurrent.BrokenBarrierException; </span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.CyclicBarrier; </span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">CyclicBarrierTest3</span> </span>&#123; </span><br><span class="line">    staticCyclicBarrier c = <span class="keyword">new</span> CyclicBarrier(<span class="number">2</span>);    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException，BrokenBarrierException </span>&#123;        </span><br><span class="line">        Thread thread = <span class="keyword">new</span> Thread(<span class="keyword">new</span> Runnable() &#123;            </span><br><span class="line">            <span class="meta">@Override</span> </span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123; </span><br><span class="line">                <span class="keyword">try</span> &#123; </span><br><span class="line">                    c.await();                </span><br><span class="line">                &#125; <span class="keyword">catch</span> (Exception e) &#123;                </span><br><span class="line"></span><br><span class="line">                &#125;            </span><br><span class="line">            &#125;       </span><br><span class="line">        &#125;); </span><br><span class="line">        thread.start(); </span><br><span class="line">        thread.interrupt(); </span><br><span class="line">        <span class="keyword">try</span> &#123; </span><br><span class="line">            c.await();        </span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123; </span><br><span class="line">            System.out.println(c.isBroken());        </span><br><span class="line">        &#125;    </span><br><span class="line">    &#125; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>&emsp;&emsp;输出如下所示。</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="literal">true</span></span><br></pre></td></tr></table></figure><hr><h2 id="第三节-控制并发线程数的Semaphore"><a href="#第三节-控制并发线程数的Semaphore" class="headerlink" title="第三节 控制并发线程数的Semaphore"></a><strong>第三节 控制并发线程数的Semaphore</strong></h2><p>&emsp;&emsp;Semaphore（信号量）是用来控制同时访问特定资源的线程数量，它通过协调各个线程，以保证合理的使用公共资源。多年以来，我都觉得从字面上很难理解Semaphore所表达的含义，只能把它比作是控制流量的红绿灯。比如××马路要限制流量，只允许同时有一百辆车在这条路上行使，其他的都必须在路口等待，所以前一百辆车会看到绿灯，可以开进这条马路，后面的车会看到红灯，不能驶入××马路，但是如果前一百辆中有5辆车已经离开了××马路，那么后面就允许有5辆车驶入马路，这个例子里说的车就是线程，驶入马路就表示线程在执行，离开马路就表示线程执行完成，看见红灯就表示线程被阻塞，不能执行。</p><h3 id="1-应用场景"><a href="#1-应用场景" class="headerlink" title="1 应用场景"></a><strong>1 应用场景</strong></h3><p>&emsp;&emsp;Semaphore可以用于做流量控制，特别是公用资源有限的应用场景，比如数据库连接。假如有一个需求，要读取几万个文件的数据，因为都是IO密集型任务，我们可以启动几十个线程并发地读取，但是如果读到内存后，还需要存储到数据库中，而数据库的连接数只有10个，这时我们必须控制只有10个线程同时获取数据库连接保存数据，否则会报错无法获取数据库连接。这个时候，就可以使用Semaphore来做流量控制，如下所示。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SemaphoreTest</span> </span>&#123;    </span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> THREAD_COUNT = <span class="number">30</span>;    </span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> ExecutorServicethreadPool = Executors.newFixedThreadPool(THREAD_COUNT);    </span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> Semaphore s = <span class="keyword">new</span> Semaphore(<span class="number">10</span>);    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;    </span><br><span class="line">        <span class="keyword">for</span> (inti = <span class="number">0</span>; i&lt; THREAD_COUNT; i++) &#123;    </span><br><span class="line">            threadPool.execute(<span class="keyword">new</span> Runnable() &#123;                </span><br><span class="line">                <span class="meta">@Override</span>    </span><br><span class="line">                <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;    </span><br><span class="line">                    <span class="keyword">try</span> &#123;    </span><br><span class="line">                        s.acquire();</span><br><span class="line">                        System.out.println(<span class="string">"save data"</span>);    </span><br><span class="line">                        s.release();                    </span><br><span class="line">                    &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;                    </span><br><span class="line"></span><br><span class="line">                    &#125;                </span><br><span class="line">                &#125;           </span><br><span class="line">            &#125;);        </span><br><span class="line">        &#125; threadPool.shutdown();    </span><br><span class="line">    &#125; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>&emsp;&emsp;在代码中，虽然有30个线程在执行，但是只允许10个并发执行。Semaphore的构造方法Semaphore（int permits）接受一个整型的数字，表示可用的许可证数量。Semaphore（10）表示允许10个线程获取许可证，也就是最大并发数是10。Semaphore的用法也很简单，首先线程使用Semaphore的acquire()方法获取一个许可证，使用完之后调用release()方法归还许可证。还可以用tryAcquire()方法尝试获取许可证。</p><h3 id="2-其他方法"><a href="#2-其他方法" class="headerlink" title="2 其他方法"></a><strong>2 其他方法</strong></h3><p>&emsp;&emsp;Semaphore还提供一些其他方法，具体如下。</p><ul><li>intavailablePermits()：返回此信号量中当前可用的许可证数。</li><li>intgetQueueLength()：返回正在等待获取许可证的线程数。</li><li>booleanhasQueuedThreads()：是否有线程正在等待获取许可证。</li><li>void reducePermits（int reduction）：减少reduction个许可证，是个protected方法。</li><li>Collection getQueuedThreads()：返回所有等待获取许可证的线程集合，是个protected方法。</li></ul><hr><h2 id="第四节-线程间交换数据的Exchanger"><a href="#第四节-线程间交换数据的Exchanger" class="headerlink" title="第四节 线程间交换数据的Exchanger"></a><strong>第四节 线程间交换数据的Exchanger</strong></h2><p>&emsp;&emsp;Exchanger（交换者）是一个用于线程间协作的工具类。Exchanger用于进行线程间的数据交换。它提供一个同步点，在这个同步点，两个线程可以交换彼此的数据。这两个线程通过exchange方法交换数据，如果第一个线程先执行exchange()方法，它会一直等待第二个线程也执行exchange方法，当两个线程都到达同步点时，这两个线程就可以交换数据，将本线程生产出来的数据传递给对方。</p><p>&emsp;&emsp;下面来看一下Exchanger的应用场景。</p><p>&emsp;&emsp;Exchanger可以用于遗传算法，遗传算法里需要选出两个人作为交配对象，这时候会交换两人的数据，并使用交叉规则得出2个交配结果。Exchanger也可以用于校对工作，比如我们需要将纸制银行流水通过人工的方式录入成电子银行流水，为了避免错误，采用AB岗两人进行录入，录入到Excel之后，系统需要加载这两个Excel，并对两个Excel数据进行校对，看看是否录入一致，代码如下所示。</p><figure class="highlight arduino"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> class ExchangerTest &#123; </span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> final Exchanger&lt;<span class="keyword">String</span>&gt; exgr = <span class="keyword">new</span> Exchanger&lt;<span class="keyword">String</span>&gt;(); </span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> ExecutorServicethreadPool = Executors.newFixedThreadPool(<span class="number">2</span>); </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> main(<span class="keyword">String</span>[] args) &#123; </span><br><span class="line">        threadPool.execute(<span class="keyword">new</span> Runnable() &#123;            </span><br><span class="line">            @Override </span><br><span class="line">            <span class="keyword">public</span> <span class="keyword">void</span> <span class="built_in">run</span>() &#123; </span><br><span class="line">                <span class="built_in">try</span> &#123;                    </span><br><span class="line">                    <span class="keyword">String</span> A = <span class="string">"银行流水A"</span>;　　　　</span><br><span class="line">                    <span class="comment">// A录入银行流水数据 </span></span><br><span class="line">                    exgr.exchange(A);                </span><br><span class="line">                &#125; <span class="built_in">catch</span> (InterruptedException e) &#123;                </span><br><span class="line"></span><br><span class="line">                &#125;            </span><br><span class="line">            &#125;        </span><br><span class="line">        &#125;); </span><br><span class="line">        </span><br><span class="line">        threadPool.execute(<span class="keyword">new</span> Runnable() &#123;            </span><br><span class="line">            @Override </span><br><span class="line">            <span class="keyword">public</span> <span class="keyword">void</span> <span class="built_in">run</span>() &#123; </span><br><span class="line">                <span class="built_in">try</span> &#123;                    </span><br><span class="line">                    <span class="keyword">String</span> B = <span class="string">"银行流水B"</span>;　　　　</span><br><span class="line">                    <span class="comment">// B录入银行流水数据                    </span></span><br><span class="line">                    <span class="keyword">String</span> A = exgr.exchange(<span class="string">"B"</span>); </span><br><span class="line">                    System.out.<span class="built_in">println</span>(<span class="string">"A和B数据是否一致："</span> + A.equals(B) + <span class="string">"，A录入的是："</span> + A + <span class="string">"，B录入是："</span> + B);                </span><br><span class="line">                &#125; <span class="built_in">catch</span> (InterruptedException e) &#123;                </span><br><span class="line"></span><br><span class="line">                &#125;           </span><br><span class="line">            &#125;        </span><br><span class="line">        &#125;); </span><br><span class="line">        </span><br><span class="line">        threadPool.<span class="built_in">shutdown</span>();    </span><br><span class="line">    &#125; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>&emsp;&emsp;如果两个线程有一个没有执行exchange()方法，则会一直等待，如果担心有特殊情况发生，避免一直等待，可以使用exchange（V x，longtimeout，TimeUnit unit）设置最大等待时长。</p><p>&emsp;&emsp;本章配合一些应用场景介绍JDK中提供的几个并发工具类，大家记住这个工具类的用途，一旦有对应的业务场景，不妨试试这些工具类。</p><hr><p><em>参考博客和文章书籍等：</em></p><blockquote><p>《Java并发编程的艺术》</p></blockquote><p><em>因博客主等未标明不可引用，若部分内容涉及侵权请及时告知，我会尽快修改和删除相关内容</em></p>]]></content>
    
    <summary type="html">
    
      介绍Java常用并发工具类，包括：等待多线程完成的CountDownLatch，同步屏障CyclicBarrier，控制并发线程数的Semaphore，线程间交换数据的Exchanger等。
    
    </summary>
    
      <category term="技术文档" scheme="http://linyishui.top/categories/%E6%8A%80%E6%9C%AF%E6%96%87%E6%A1%A3/"/>
    
    
      <category term="java" scheme="http://linyishui.top/tags/java/"/>
    
      <category term="lock" scheme="http://linyishui.top/tags/lock/"/>
    
  </entry>
  
  <entry>
    <title>Fork/Join框架</title>
    <link href="http://linyishui.top/2019082601.html"/>
    <id>http://linyishui.top/2019082601.html</id>
    <published>2019-08-26T08:57:17.000Z</published>
    <updated>2019-10-11T09:21:35.719Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="Fork-Join框架"><a href="#Fork-Join框架" class="headerlink" title="Fork/Join框架"></a><strong>Fork/Join框架</strong></h1><p>&emsp;&emsp;本节将会介绍Fork/Join框架的基本原理、算法、设计方式、应用与实现等。</p><hr><h2 id="第一节-什么是Fork-Join框架"><a href="#第一节-什么是Fork-Join框架" class="headerlink" title="第一节 什么是Fork/Join框架"></a><strong>第一节 什么是Fork/Join框架</strong></h2><p>&emsp;&emsp;Fork/Join框架是Java 7提供的一个用于并行执行任务的框架，是一个把大任务分割成若干个小任务，最终汇总每个小任务结果后得到大任务结果的框架。</p><p>&emsp;&emsp;我们再通过Fork和Join这两个单词来理解一下Fork/Join框架。Fork就是把一个大任务切分 为若干子任务并行的执行，Join就是合并这些子任务的执行结果，最后得到这个大任务的结果。比如计算1+2+…+10000，可以分割成10个子任务，每个子任务分别对1000个数进行求和，最终汇总这10个子任务的结果。Fork/Join的运行流程如下图所示。</p><p><img src="https://pic-1258215793.cos.ap-shanghai.myqcloud.com/content/20190701/201907010107.png" alt="Fork Join的运行流程图"></p><hr><h2 id="第二节-工作窃取算法"><a href="#第二节-工作窃取算法" class="headerlink" title="第二节 工作窃取算法"></a><strong>第二节 工作窃取算法</strong></h2><p>　<br>&emsp;&emsp;工作窃取（work-stealing）算法是指某个线程从其他队列里窃取任务来执行。那么，为什么需要使用工作窃取算法呢？假如我们需要做一个比较大的任务，可以把这个任务分割为若干互不依赖的子任务，为了减少线程间的竞争，把这些子任务分别放到不同的队列里，并为每个队列创建一个单独的线程来执行队列里的任务，线程和队列一一对应。比如A线程负责处理A队列里的任务。但是，有的线程会先把自己队列里的任务干完，而其他线程对应的队列里还有任务等待处理。干完活的线程与其等着，不如去帮其他线程干活，于是它就去其他线程的队列里窃取一个任务来执行。而在这时它们会访问同一个队列，所以为了减少窃取任务线程和被窃取任务线程之间的竞争，通常会使用双端队列，被窃取任务线程永远从双端队列的头部拿任务执行，而窃取任务的线程永远从双端队列的尾部拿任务执行。</p><p>&emsp;&emsp;工作窃取的运行流程如下图所示。</p><p><img src="https://pic-1258215793.cos.ap-shanghai.myqcloud.com/content/20190701/201907010108.png" alt="工作窃取运行流程图"></p><p>&emsp;&emsp;工作窃取算法的优点：充分利用线程进行并行计算，减少了线程间的竞争。</p><p>&emsp;&emsp;工作窃取算法的缺点：在某些情况下还是存在竞争，比如双端队列里只有一个任务时。并且该算法会消耗了更多的系统资源，比如创建多个线程和多个双端队列。</p><hr><h2 id="第三节-Fork-Join框架的设计"><a href="#第三节-Fork-Join框架的设计" class="headerlink" title="第三节 Fork/Join框架的设计"></a><strong>第三节 Fork/Join框架的设计</strong></h2><p>&emsp;&emsp;我们已经很清楚Fork/Join框架的需求了，那么可以思考一下，如果让我们来设计一个Fork/Join框架，该如何设计？这个思考有助于你理解Fork/Join框架的设计。</p><ul><li>步骤1　分割任务。首先我们需要有一个fork类来把大任务分割成子任务，有可能子任务还是很大，所以还需要不停地分割，直到分割出的子任务足够小。</li><li>步骤2　执行任务并合并结果。分割的子任务分别放在双端队列里，然后几个启动线程分别从双端队列里获取任务执行。子任务执行完的结果都统一放在一个队列里，启动一个线程从队列里拿数据，然后合并这些数据。</li></ul><p>&emsp;&emsp;Fork/Join使用两个类来完成以上两件事情。</p><h3 id="1-ForkJoinTask"><a href="#1-ForkJoinTask" class="headerlink" title="1 ForkJoinTask"></a><strong>1 ForkJoinTask</strong></h3><p>&emsp;&emsp;我们要使用ForkJoin框架，必须首先创建一个ForkJoin任务。它提供在任务中执行fork()和join()操作的机制。通常情况下，我们不需要直接继承ForkJoinTask类，只需要继承它的子类，Fork/Join框架提供了以下两个子类。</p><ul><li>RecursiveAction：用于没有返回结果的任务。</li><li>RecursiveTask：用于有返回结果的任务。</li></ul><h3 id="2-ForkJoinPool"><a href="#2-ForkJoinPool" class="headerlink" title="2 ForkJoinPool"></a><strong>2 ForkJoinPool</strong></h3><p>&emsp;&emsp;ForkJoinTask需要通过ForkJoinPool来执行。任务分割出的子任务会添加到当前工作线程所维护的双端队列中，进入队列的头部。当一个工作线程的队列里暂时没有任务时，它会随机从其他工作线程的队列的尾部获取一个任务。</p><hr><h2 id="第四节-使用Fork-Join框架"><a href="#第四节-使用Fork-Join框架" class="headerlink" title="第四节 使用Fork/Join框架"></a><strong>第四节 使用Fork/Join框架</strong></h2><p>&emsp;&emsp;让我们通过一个简单的需求来使用Fork/Join框架，需求是：计算1+2+3+4的结果。</p><p>&emsp;&emsp;使用Fork/Join框架首先要考虑到的是如何分割任务，如果希望每个子任务最多执行两个数的相加，那么我们设置分割的阈值是2，由于是4个数字相加，所以Fork/Join框架会把这个任务fork成两个子任务，子任务一负责计算1+2，子任务二负责计算3+4，然后再join两个子任务的结果。因为是有结果的任务，所以必须继承RecursiveTask，实现代码如下。</p><figure class="highlight arduino"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><span class="line">package fj; </span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.ExecutionException; </span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.ForkJoinPool; </span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.Future; </span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.RecursiveTask; </span><br><span class="line"><span class="keyword">public</span> class CountTask extends RecursiveTask&lt;Integer&gt; &#123;        </span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> final <span class="keyword">int</span> THRESHOLD = <span class="number">2</span>;　　<span class="comment">// 阈值        </span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> start;        </span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> <span class="built_in">end</span>;        </span><br><span class="line">    <span class="keyword">public</span> CountTask(<span class="keyword">int</span> start, <span class="keyword">int</span> <span class="built_in">end</span>) &#123;                </span><br><span class="line">        <span class="keyword">this</span>.start = start;                </span><br><span class="line">        <span class="keyword">this</span>.<span class="built_in">end</span> = <span class="built_in">end</span>;        </span><br><span class="line">    &#125;        </span><br><span class="line">    </span><br><span class="line">    @Override        </span><br><span class="line">    <span class="keyword">protected</span> Integer compute() &#123;                </span><br><span class="line">        <span class="keyword">int</span> sum = <span class="number">0</span>;                </span><br><span class="line">        <span class="comment">// 如果任务足够小就计算任务                </span></span><br><span class="line">        <span class="keyword">boolean</span> canCompute = (<span class="built_in">end</span> - start) &lt;= THRESHOLD;                </span><br><span class="line">        <span class="built_in">if</span> (canCompute) &#123;                        </span><br><span class="line">            <span class="built_in">for</span> (<span class="keyword">int</span> i = start; i &lt;= <span class="built_in">end</span>; i++) &#123;                                </span><br><span class="line">                sum += i;                        </span><br><span class="line">            &#125;                </span><br><span class="line">        &#125; <span class="built_in">else</span> &#123;                        </span><br><span class="line">            <span class="comment">// 如果任务大于阈值，就分裂成两个子任务计算                        </span></span><br><span class="line">            <span class="keyword">int</span> middle = (start + <span class="built_in">end</span>) / <span class="number">2</span>;                        </span><br><span class="line">            CountTask leftTask = <span class="keyword">new</span> CountTask(start, middle);                        </span><br><span class="line">            CountTask rightTask = <span class="keyword">new</span> CountTask(middle + <span class="number">1</span>, <span class="built_in">end</span>);                        </span><br><span class="line">            <span class="comment">// 执行子任务                        </span></span><br><span class="line">            leftTask.fork();                        </span><br><span class="line">            rightTask.fork();                        </span><br><span class="line">            <span class="comment">// 等待子任务执行完，并得到其结果                        </span></span><br><span class="line">            <span class="keyword">int</span> leftResult=leftTask.join();                        </span><br><span class="line">            <span class="keyword">int</span> rightResult=rightTask.join();                        </span><br><span class="line">            <span class="comment">// 合并子任务                        </span></span><br><span class="line">            sum = leftResult  + rightResult;                </span><br><span class="line">        &#125;                </span><br><span class="line">        <span class="built_in">return</span> sum;        </span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> main(<span class="keyword">String</span>[] args) &#123;                </span><br><span class="line">        ForkJoinPool forkJoinPool = <span class="keyword">new</span> ForkJoinPool();                </span><br><span class="line">        <span class="comment">// 生成一个计算任务，负责计算1+2+3+4                </span></span><br><span class="line">        CountTask task = <span class="keyword">new</span> CountTask(<span class="number">1</span>, <span class="number">4</span>);                </span><br><span class="line">        <span class="comment">// 执行一个任务                </span></span><br><span class="line">        Future&lt;Integer&gt; result = forkJoinPool.submit(task);                </span><br><span class="line">        <span class="built_in">try</span> &#123;                        </span><br><span class="line">            System.out.<span class="built_in">println</span>(result.<span class="built_in">get</span>());                </span><br><span class="line">        &#125; <span class="built_in">catch</span> (InterruptedException e) &#123;                </span><br><span class="line"></span><br><span class="line">        &#125; <span class="built_in">catch</span> (ExecutionException e) &#123;                </span><br><span class="line"></span><br><span class="line">        &#125;        </span><br><span class="line">    &#125; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>&emsp;&emsp;通过这个例子，我们进一步了解ForkJoinTask，ForkJoinTask与一般任务的主要区别在于它需要实现compute方法，在这个方法里，首先需要判断任务是否足够小，如果足够小就直接执行任务。如果不足够小，就必须分割成两个子任务，每个子任务在调用fork方法时，又会进入compute方法，看看当前子任务是否需要继续分割成子任务，如果不需要继续分割，则执行当前子任务并返回结果。使用join方法会等待子任务执行完并得到其结果。</p><hr><h2 id="第五节-Fork-Join框架的异常处理"><a href="#第五节-Fork-Join框架的异常处理" class="headerlink" title="第五节 Fork/Join框架的异常处理"></a><strong>第五节 Fork/Join框架的异常处理</strong></h2><p>&emsp;&emsp;ForkJoinTask在执行的时候可能会抛出异常，但是我们没办法在主线程里直接捕获异常， 所以ForkJoinTask提供了isCompletedAbnormally()方法来检查任务是否已经抛出异常或已经被取消了，并且可以通过ForkJoinTask的getException方法获取异常。使用如下代码。</p><figure class="highlight ada"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span>(<span class="keyword">task</span>.isCompletedAbnormally())&#123;                        </span><br><span class="line">    System.<span class="keyword">out</span>.println(<span class="keyword">task</span>.getException());                </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>&emsp;&emsp;getException方法返回Throwable对象，如果任务被取消了则返回CancellationException。如果任务没有完成或者没有抛出异常则返回null。</p><h2 id="第六节-Fork-Join框架的实现原理"><a href="#第六节-Fork-Join框架的实现原理" class="headerlink" title="第六节 Fork/Join框架的实现原理"></a><strong>第六节 Fork/Join框架的实现原理</strong></h2><p>&emsp;&emsp;ForkJoinPool由ForkJoinTask数组和ForkJoinWorkerThread数组组成，ForkJoinTask数组负责将存放程序提交给ForkJoinPool的任务，而ForkJoinWorkerThread数组负责执行这些任务。</p><h3 id="（1）ForkJoinTask的fork方法实现原理"><a href="#（1）ForkJoinTask的fork方法实现原理" class="headerlink" title="（1）ForkJoinTask的fork方法实现原理"></a><strong>（1）ForkJoinTask的fork方法实现原理</strong></h3><p>&emsp;&emsp;当我们调用ForkJoinTask的fork方法时，程序会调用ForkJoinWorkerThread的pushTask方法异步地执行这个任务，然后立即返回结果。代码如下。</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> ForkJoinTask&lt;V&gt; fork() &#123;        </span><br><span class="line">    ((ForkJoinWorkerThread) Thread.currentThread())            </span><br><span class="line">                                  .pushTask(<span class="keyword">this</span>);        </span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">this</span>; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>&emsp;&emsp;pushTask方法把当前任务存放在ForkJoinTask数组队列里。然后再调用ForkJoinPool的signalWork()方法唤醒或创建一个工作线程来执行任务。代码如下。</p><figure class="highlight nix"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">final void pushTask(ForkJoinTask&lt;&gt; t) &#123;        </span><br><span class="line">    ForkJoinTask&lt;&gt;[] q; int s, m;        </span><br><span class="line">    <span class="keyword">if</span> ((<span class="attr">q</span> = queue) != <span class="literal">null</span>) &#123;　　　　</span><br><span class="line">        // ignore <span class="keyword">if</span> queue removed            </span><br><span class="line">        long <span class="attr">u</span> = (((<span class="attr">s</span> = queueTop) &amp; (<span class="attr">m</span> = q.length - <span class="number">1</span>)) &lt;&lt; ASHIFT) + ABASE;            </span><br><span class="line">        UNSAFE.putOrderedObject(q, u, t);            </span><br><span class="line">        <span class="attr">queueTop</span> = s + <span class="number">1</span>;　　　　　　</span><br><span class="line">        // <span class="literal">or</span> use putOrderedInt            </span><br><span class="line">        <span class="keyword">if</span> ((s <span class="attr">-=</span> queueBase) &lt;= <span class="number">2</span>)                </span><br><span class="line">            pool.signalWork();            </span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (<span class="attr">s</span> == m)                </span><br><span class="line">            growQueue();        </span><br><span class="line">    &#125;    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="（2）ForkJoinTask的join方法实现原理"><a href="#（2）ForkJoinTask的join方法实现原理" class="headerlink" title="（2）ForkJoinTask的join方法实现原理"></a><strong>（2）ForkJoinTask的join方法实现原理</strong></h3><p>&emsp;&emsp;Join方法的主要作用是阻塞当前线程并等待获取结果。让我们一起看看ForkJoinTask的join方法的实现，代码如下。</p><figure class="highlight aspectj"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="function">V <span class="title">join</span><span class="params">()</span> </span>&#123;        </span><br><span class="line">    <span class="keyword">if</span> (doJoin() != NORMAL)            </span><br><span class="line">        <span class="function"><span class="keyword">return</span> <span class="title">reportResult</span><span class="params">()</span></span>;        </span><br><span class="line">    <span class="keyword">else</span>            </span><br><span class="line">        <span class="function"><span class="keyword">return</span> <span class="title">getRawResult</span><span class="params">()</span></span>; </span><br><span class="line">&#125; </span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="function">V <span class="title">reportResult</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> s; </span><br><span class="line">    Throwable ex;        </span><br><span class="line">    <span class="keyword">if</span> ((s = status) == CANCELLED)            </span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> CancellationException();        </span><br><span class="line">    <span class="keyword">if</span> (s == EXCEPTIONAL &amp;&amp; (ex = getThrowableException()) != <span class="keyword">null</span>)            </span><br><span class="line">        UNSAFE.throwException(ex);        </span><br><span class="line">    <span class="function"><span class="keyword">return</span> <span class="title">getRawResult</span><span class="params">()</span></span>;    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>&emsp;&emsp;首先，它调用了doJoin()方法，通过doJoin()方法得到当前任务的状态来判断返回什么结果，任务状态有4种：已完成（NORMAL）、被取消（CANCELLED）、信号（SIGNAL）和出现异常（EXCEPTIONAL）。</p><ul><li>如果任务状态是已完成，则直接返回任务结果。</li><li>如果任务状态是被取消，则直接抛出CancellationException。</li><li>如果任务状态是抛出异常，则直接抛出对应的异常。</li></ul><p>&emsp;&emsp;让我们再来分析一下doJoin()方法的实现代码。</p><figure class="highlight aspectj"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="function"><span class="keyword">int</span> <span class="title">doJoin</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    Thread t; </span><br><span class="line">    ForkJoinWorkerThread w; </span><br><span class="line">    <span class="keyword">int</span> s; </span><br><span class="line">    <span class="keyword">boolean</span> completed;        </span><br><span class="line">    <span class="keyword">if</span> ((t = Thread.currentThread()) <span class="keyword">instanceof</span> ForkJoinWorkerThread) &#123;            </span><br><span class="line">        <span class="keyword">if</span> ((s = status) &lt; <span class="number">0</span>)                </span><br><span class="line">            <span class="keyword">return</span> s;            </span><br><span class="line">        <span class="keyword">if</span> ((w = (ForkJoinWorkerThread)t).unpushTask(<span class="keyword">this</span>)) &#123;                </span><br><span class="line">            <span class="keyword">try</span> &#123;                    </span><br><span class="line">                completed = exec();                </span><br><span class="line">            &#125; <span class="keyword">catch</span> (Throwable rex) &#123;                    </span><br><span class="line">                <span class="function"><span class="keyword">return</span> <span class="title">setExceptionalCompletion</span><span class="params">(rex)</span></span>;                </span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (completed)                    </span><br><span class="line">                <span class="function"><span class="keyword">return</span> <span class="title">setCompletion</span><span class="params">(NORMAL)</span></span>;            </span><br><span class="line">        &#125;            </span><br><span class="line">        <span class="function"><span class="keyword">return</span> w.<span class="title">joinTask</span><span class="params">(<span class="keyword">this</span>)</span></span>;        </span><br><span class="line">    &#125; <span class="keyword">else</span>            </span><br><span class="line">        <span class="function"><span class="keyword">return</span> <span class="title">externalAwaitDone</span><span class="params">()</span></span>;    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>&emsp;&emsp;在doJoin()方法里，首先通过查看任务的状态，看任务是否已经执行完成，如果执行完成，则直接返回任务状态；如果没有执行完，则从任务数组里取出任务并执行。如果任务顺利执行完成，则设置任务状态为NORMAL，如果出现异常，则记录异常，并将任务状态设置为EXCEPTIONAL。</p><hr><p><em>参考博客和文章书籍等：</em></p><blockquote><p>《Java并发编程的艺术》</p></blockquote><p><em>因博客主等未标明不可引用，若部分内容涉及侵权请及时告知，我会尽快修改和删除相关内容</em></p>]]></content>
    
    <summary type="html">
    
      介绍Java中Fork/Join框架，包括：基本介绍，工作窃取算法，Fork/Join框架的设计，使用Fork/Join框架，Fork/Join框架的异常处理等。
    
    </summary>
    
      <category term="技术文档" scheme="http://linyishui.top/categories/%E6%8A%80%E6%9C%AF%E6%96%87%E6%A1%A3/"/>
    
    
      <category term="java" scheme="http://linyishui.top/tags/java/"/>
    
      <category term="lock" scheme="http://linyishui.top/tags/lock/"/>
    
  </entry>
  
  <entry>
    <title>阻塞队列</title>
    <link href="http://linyishui.top/2019082501.html"/>
    <id>http://linyishui.top/2019082501.html</id>
    <published>2019-08-25T08:44:25.000Z</published>
    <updated>2019-10-11T09:21:34.798Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="Java中的阻塞队列"><a href="#Java中的阻塞队列" class="headerlink" title="Java中的阻塞队列"></a><strong>Java中的阻塞队列</strong></h1><p>&emsp;&emsp;本篇将介绍什么是阻塞队列，以及Java中阻塞队列的4种处理方式，并介绍Java 7中提供的7种阻塞队列，最后分析阻塞队列的一种实现方式。</p><hr><h2 id="第一节-什么是阻塞队列"><a href="#第一节-什么是阻塞队列" class="headerlink" title="第一节 什么是阻塞队列"></a><strong>第一节 什么是阻塞队列</strong></h2><p>&emsp;&emsp;阻塞队列（BlockingQueue）是一个支持两个附加操作的队列。这两个附加的操作支持阻塞的插入和移除方法。</p><ol><li><p>支持阻塞的插入方法：意思是当队列满时，队列会阻塞插入元素的线程，直到队列不满。</p></li><li><p>支持阻塞的移除方法：意思是在队列为空时，获取元素的线程会等待队列变为非空。</p></li></ol><p>&emsp;&emsp;阻塞队列常用于生产者和消费者的场景，生产者是向队列里添加元素的线程，消费者是从队列里取元素的线程。阻塞队列就是生产者用来存放元素、消费者用来获取元素的容器。</p><p>&emsp;&emsp;在阻塞队列不可用时，这两个附加操作提供了4种处理方式，如表6-1所示。</p><p><img src="https://pic-1258215793.cos.ap-shanghai.myqcloud.com/content/20190701/201907010106.png" alt="插入和移除操作的4中处理方式"></p><ul><li>抛出异常：当队列满时，如果再往队列里插入元素，会抛出IllegalStateException（”Queue full”）异常。当队列空时，从队列里获取元素会抛出NoSuchElementException异常。</li><li>返回特殊值：当往队列插入元素时，会返回元素是否插入成功，成功返回true。如果是移除方法，则是从队列里取出一个元素，如果没有则返回null。</li><li>一直阻塞：当阻塞队列满时，如果生产者线程往队列里put元素，队列会一直阻塞生产者线程，直到队列可用或者响应中断退出。当队列空时，如果消费者线程从队列里take元素，队列会阻塞住消费者线程，直到队列不为空。</li><li>超时退出：当阻塞队列满时，如果生产者线程往队列里插入元素，队列会阻塞生产者线程一段时间，如果超过了指定的时间，生产者线程就会退出。</li></ul><p>&emsp;&emsp;这两个附加操作的4种处理方式不方便记忆，所以我找了一下这几个方法的规律。put和 take分别尾首含有字母t，offer和poll都含有字母o。</p><p>&emsp;&emsp;注意: 如果是无界阻塞队列，队列不可能会出现满的情况，所以使用put或offer方法永 远不会被阻塞，而且使用offer方法时，该方法永远返回true。</p><hr><h2 id="第二节-Java里的阻塞队列"><a href="#第二节-Java里的阻塞队列" class="headerlink" title="第二节 Java里的阻塞队列"></a><strong>第二节 Java里的阻塞队列</strong></h2><p>&emsp;&emsp;JDK 7提供了7个阻塞队列，如下。</p><ul><li>ArrayBlockingQueue：一个由数组结构组成的有界阻塞队列。</li><li>LinkedBlockingQueue：一个由链表结构组成的有界阻塞队列。</li><li>PriorityBlockingQueue：一个支持优先级排序的无界阻塞队列。</li><li>DelayQueue：一个使用优先级队列实现的无界阻塞队列。</li><li>SynchronousQueue：一个不存储元素的阻塞队列。</li><li>LinkedTransferQueue：一个由链表结构组成的无界阻塞队列。</li><li>LinkedBlockingDeque：一个由链表结构组成的双向阻塞队列。</li></ul><h3 id="1-ArrayBlockingQueue"><a href="#1-ArrayBlockingQueue" class="headerlink" title="1 ArrayBlockingQueue"></a><strong>1 ArrayBlockingQueue</strong></h3><p>&emsp;&emsp;ArrayBlockingQueue是一个用数组实现的有界阻塞队列。此队列按照先进先出（FIFO）的原则对元素进行排序。</p><p>&emsp;&emsp;默认情况下不保证线程公平的访问队列，所谓公平访问队列是指阻塞的线程，可以按照阻塞的先后顺序访问队列，即先阻塞线程先访问队列。非公平性是对先等待的线程是非公平的，当队列可用时，阻塞的线程都可以争夺访问队列的资格，有可能先阻塞的线程最后才访问队列。为了保证公平性，通常会降低吞吐量。我们可以使用以下代码创建一个公平的阻塞队列。</p><figure class="highlight haxe"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ArrayBlockingQueue fairQueue = <span class="keyword">new</span>  <span class="type">ArrayBlockingQueue</span>(<span class="number">1000</span>,<span class="literal">true</span>);</span><br></pre></td></tr></table></figure><p>&emsp;&emsp;访问者的公平性是使用可重入锁实现的，代码如下。</p><figure class="highlight haxe"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> ArrayBlockingQueue(int capacity, boolean fair) &#123;        </span><br><span class="line">    <span class="keyword">if</span> (capacity &lt;= <span class="number">0</span>)            </span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="type">IllegalArgumentException</span>();        </span><br><span class="line">    <span class="built_in">this</span>.items = <span class="keyword">new</span> <span class="type">Object</span>[capacity];        </span><br><span class="line">    lock = <span class="keyword">new</span> <span class="type">ReentrantLock</span>(fair);        </span><br><span class="line">    notEmpty = lock.<span class="keyword">new</span><span class="type">Condition</span>();        </span><br><span class="line">    notFull =  lock.<span class="keyword">new</span><span class="type">Condition</span>(); </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="2-LinkedBlockingQueue"><a href="#2-LinkedBlockingQueue" class="headerlink" title="2 LinkedBlockingQueue"></a><strong>2 LinkedBlockingQueue</strong></h3><p>&emsp;&emsp;LinkedBlockingQueue是一个用链表实现的有界阻塞队列。此队列的默认和最大长度为Integer.MAX_VALUE。此队列按照先进先出的原则对元素进行排序。</p><h3 id="3-PriorityBlockingQueue"><a href="#3-PriorityBlockingQueue" class="headerlink" title="3 PriorityBlockingQueue"></a><strong>3 PriorityBlockingQueue</strong></h3><p>&emsp;&emsp;PriorityBlockingQueue是一个支持优先级的无界阻塞队列。默认情况下元素采取自然顺序升序排列。也可以自定义类实现compareTo()方法来指定元素排序规则，或者初始化PriorityBlockingQueue时，指定构造参数Comparator来对元素进行排序。需要注意的是不能保证同优先级元素的顺序。</p><h3 id="4-DelayQueue"><a href="#4-DelayQueue" class="headerlink" title="4 DelayQueue"></a><strong>4 DelayQueue</strong></h3><p>&emsp;&emsp;DelayQueue是一个支持延时获取元素的无界阻塞队列。队列使用PriorityQueue来实现。队列中的元素必须实现Delayed接口，在创建元素时可以指定多久才能从队列中获取当前元素。</p><p>&emsp;&emsp;只有在延迟期满时才能从队列中提取元素。</p><p>&emsp;&emsp;DelayQueue非常有用，可以将DelayQueue运用在以下应用场景。</p><ul><li>缓存系统的设计：可以用DelayQueue保存缓存元素的有效期，使用一个线程循环查询DelayQueue，一旦能从DelayQueue中获取元素时，表示缓存有效期到了。</li><li>定时任务调度：使用DelayQueue保存当天将会执行的任务和执行时间，一旦从DelayQueue中获取到任务就开始执行，比如TimerQueue就是使用DelayQueue实现的。</li></ul><h4 id="（1）如何实现Delayed接口"><a href="#（1）如何实现Delayed接口" class="headerlink" title="（1）如何实现Delayed接口"></a><strong>（1）如何实现Delayed接口</strong></h4><p>&emsp;&emsp;DelayQueue队列的元素必须实现Delayed接口。我们可以参考ScheduledThreadPoolExecutor里ScheduledFutureTask类的实现，一共有三步。</p><p>&emsp;&emsp;第一步：在对象创建的时候，初始化基本数据。使用time记录当前对象延迟到什么时候可 以使用，使用sequenceNumber来标识元素在队列中的先后顺序。代码如下。</p><figure class="highlight aspectj"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> AtomicLong sequencer = <span class="keyword">new</span> AtomicLong(<span class="number">0</span>); </span><br><span class="line">ScheduledFutureTask(Runnable r, V result, <span class="keyword">long</span> ns, <span class="keyword">long</span> period) &#123; </span><br><span class="line">ScheduledFutureTask(Runnable r, V result, <span class="keyword">long</span> ns, <span class="keyword">long</span> period) &#123;            </span><br><span class="line">    <span class="keyword">super</span>(r, result);            </span><br><span class="line">    <span class="keyword">this</span>.time = ns;            </span><br><span class="line">    <span class="keyword">this</span>.period = period;            </span><br><span class="line">    <span class="keyword">this</span>.sequenceNumber = sequencer.getAndIncrement(); </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>&emsp;&emsp;第二步：实现getDelay方法，该方法返回当前元素还需要延时多长时间，单位是纳秒，代码如下。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">long</span> <span class="title">getDelay</span><span class="params">(TimeUnit unit)</span> </span>&#123;            </span><br><span class="line">    <span class="keyword">return</span> unit.convert(time - now(), TimeUnit.NANOSECONDS);        </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>&emsp;&emsp;通过构造函数可以看出延迟时间参数ns的单位是纳秒，自己设计的时候最好使用纳秒，因为实现getDelay()方法时可以指定任意单位，一旦以秒或分作为单位，而延时时间又精确不到纳秒就麻烦了。使用时请注意当time小于当前时间时，getDelay会返回负数。</p><p>&emsp;&emsp;第三步：实现compareTo方法来指定元素的顺序。例如，让延时时间最长的放在队列的末尾。实现代码如下。</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> int compareTo(Delayed other) &#123;            </span><br><span class="line">    <span class="keyword">if</span> (other == <span class="keyword">this</span>)　　<span class="comment">// compare zero ONLY if same object                </span></span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;            </span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span> (other instanceof ScheduledFutureTask) &#123;                </span><br><span class="line">        ScheduledFutureTask&lt;&gt; x = (ScheduledFutureTask&lt;&gt;)other;                </span><br><span class="line">        long diff = time - x.time;                </span><br><span class="line">        <span class="keyword">if</span> (diff &lt; <span class="number">0</span>)                    </span><br><span class="line">            <span class="keyword">return</span> <span class="number">-1</span>;                </span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (diff &gt; <span class="number">0</span>)                    </span><br><span class="line">            <span class="keyword">return</span> <span class="number">1</span>;                </span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (sequenceNumber &lt; x.sequenceNumber)                    </span><br><span class="line">            <span class="keyword">return</span> <span class="number">-1</span>;                </span><br><span class="line">        <span class="keyword">else</span>                    </span><br><span class="line">            <span class="keyword">return</span> <span class="number">1</span>;            </span><br><span class="line">    &#125;            </span><br><span class="line">    </span><br><span class="line">    long d = (getDelay(TimeUnit.NANOSECONDS) other.getDelay(TimeUnit.NANOSECONDS));            </span><br><span class="line">    <span class="keyword">return</span> (d == <span class="number">0</span>)  <span class="number">0</span> : ((d &lt; <span class="number">0</span>)  <span class="number">-1</span> : <span class="number">1</span>);        </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="（2）如何实现延时阻塞队列"><a href="#（2）如何实现延时阻塞队列" class="headerlink" title="（2）如何实现延时阻塞队列"></a><strong>（2）如何实现延时阻塞队列</strong></h4><p>&emsp;&emsp;延时阻塞队列的实现很简单，当消费者从队列里获取元素时，如果元素没有达到延时时间，就阻塞当前线程。</p><figure class="highlight arduino"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">long</span> <span class="built_in">delay</span> = first.getDelay(TimeUnit.NANOSECONDS); </span><br><span class="line"><span class="built_in">if</span> (<span class="built_in">delay</span> &lt;= <span class="number">0</span>)    </span><br><span class="line">    <span class="built_in">return</span> q.poll(); </span><br><span class="line"><span class="built_in">else</span> <span class="built_in">if</span> (leader != null)        </span><br><span class="line">    <span class="built_in">available</span>.await(); </span><br><span class="line"><span class="built_in">else</span> &#123;    </span><br><span class="line">    Thread thisThread = Thread.currentThread(); </span><br><span class="line">    leader = thisThread;        </span><br><span class="line">    <span class="built_in">try</span> &#123;                </span><br><span class="line">        <span class="built_in">available</span>.awaitNanos(<span class="built_in">delay</span>);            </span><br><span class="line">    &#125; finally &#123;                </span><br><span class="line">        <span class="built_in">if</span> (leader == thisThread)                </span><br><span class="line">            leader = null;            </span><br><span class="line">    &#125;    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>&emsp;&emsp;代码中的变量leader是一个等待获取队列头部元素的线程。如果leader不等于空，表示已经有线程在等待获取队列的头元素。所以，使用await()方法让当前线程等待信号。如果leader等于空，则把当前线程设置成leader，并使用awaitNanos()方法让当前线程等待接收信号或等待delay时间。</p><h3 id="5-SynchronousQueue"><a href="#5-SynchronousQueue" class="headerlink" title="5 SynchronousQueue"></a><strong>5 SynchronousQueue</strong></h3><p>&emsp;&emsp;SynchronousQueue是一个不存储元素的阻塞队列。每一个put操作必须等待一个take操作，否则不能继续添加元素。</p><p>&emsp;&emsp;它支持公平访问队列。默认情况下线程采用非公平性策略访问队列。使用以下构造方法可以创建公平性访问的SynchronousQueue，如果设置为true，则等待的线程会采用先进先出的顺序访问队列。</p><figure class="highlight aspectj"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">SynchronousQueue</span><span class="params">(<span class="keyword">boolean</span> fair)</span> </span>&#123;        </span><br><span class="line">    transferer = fair  <span class="keyword">new</span> TransferQueue() : <span class="keyword">new</span> TransferStack();    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>&emsp;&emsp;SynchronousQueue可以看成是一个传球手，负责把生产者线程处理的数据直接传递给消费者线程。队列本身并不存储任何元素，非常适合传递性场景。</p><p>&emsp;&emsp;SynchronousQueue的吞吐量高于LinkedBlockingQueue和ArrayBlockingQueue。</p><h3 id="6-LinkedTransferQueue"><a href="#6-LinkedTransferQueue" class="headerlink" title="6 LinkedTransferQueue"></a><strong>6 LinkedTransferQueue</strong></h3><p>&emsp;&emsp;LinkedTransferQueue是一个由链表结构组成的无界阻塞TransferQueue队列。相对于其他阻塞队列，LinkedTransferQueue多了tryTransfer和transfer方法。</p><h4 id="（1）transfer方法"><a href="#（1）transfer方法" class="headerlink" title="（1）transfer方法"></a><strong>（1）transfer方法</strong></h4><p>&emsp;&emsp;如果当前有消费者正在等待接收元素（消费者使用take()方法或带时间限制的poll()方法 时），transfer方法可以把生产者传入的元素立刻transfer（传输）给消费者。如果没有消费者在等待接收元素，transfer方法会将元素存放在队列的tail节点，并等到该元素被消费者消费了才返回。transfer方法的关键代码如下。</p><figure class="highlight lisp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Node pred = tryAppend(<span class="name">s</span>, haveData)<span class="comment">; </span></span><br><span class="line">return awaitMatch(<span class="name">s</span>, pred, e, (<span class="name">how</span> == TIMED), nanos)<span class="comment">;</span></span><br></pre></td></tr></table></figure><p>&emsp;&emsp;第一行代码是试图把存放当前元素的s节点作为tail节点。第二行代码是让CPU自旋等待消费者消费元素。因为自旋会消耗CPU，所以自旋一定的次数后使用Thread.yield()方法来暂停当前正在执行的线程，并执行其他线程。</p><h4 id="（2）tryTransfer方法"><a href="#（2）tryTransfer方法" class="headerlink" title="（2）tryTransfer方法"></a><strong>（2）tryTransfer方法</strong></h4><p>&emsp;&emsp;tryTransfer方法是用来试探生产者传入的元素是否能直接传给消费者。如果没有消费者等待接收元素，则返回false。和transfer方法的区别是tryTransfer方法无论消费者是否接收，方法立即返回，而transfer方法是必须等到消费者消费了才返回。</p><p>&emsp;&emsp;对于带有时间限制的tryTransfer（E e，long timeout，TimeUnit unit）方法，试图把生产者传入的元素直接传给消费者，但是如果没有消费者消费该元素则等待指定的时间再返回，如果超时还没消费元素，则返回false，如果在超时时间内消费了元素，则返回true。</p><h3 id="7-LinkedBlockingDeque"><a href="#7-LinkedBlockingDeque" class="headerlink" title="7 LinkedBlockingDeque"></a><strong>7 LinkedBlockingDeque</strong></h3><p>&emsp;&emsp;LinkedBlockingDeque是一个由链表结构组成的双向阻塞队列。所谓双向队列指的是可以从队列的两端插入和移出元素。双向队列因为多了一个操作队列的入口，在多线程同时入队时，也就减少了一半的竞争。相比其他的阻塞队列，LinkedBlockingDeque多了addFirst、 addLast、offerFirst、offerLast、peekFirst和peekLast等方法，以First单词结尾的方法，表示插入、 获取（peek）或移除双端队列的第一个元素。以Last单词结尾的方法，表示插入、获取或移除双端队列的最后一个元素。另外，插入方法add等同于addLast，移除方法remove等效于removeFirst。但是take方法却等同于takeFirst，不知道是不是JDK的bug，使用时还是用带有First和Last后缀的方法更清楚。</p><p>&emsp;&emsp;在初始化LinkedBlockingDeque时可以设置容量防止其过度膨胀。另外，双向阻塞队列可以运用在“工作窃取”模式中。</p><hr><h2 id="第三节-阻塞队列的实现原理"><a href="#第三节-阻塞队列的实现原理" class="headerlink" title="第三节 阻塞队列的实现原理"></a><strong>第三节 阻塞队列的实现原理</strong></h2><p>&emsp;&emsp;如果队列是空的，消费者会一直等待，当生产者添加元素时，消费者是如何知道当前队列有元素的呢？如果让你来设计阻塞队列你会如何设计，如何让生产者和消费者进行高效率的通信呢？让我们先来看看JDK是如何实现的。</p><p>&emsp;&emsp;使用通知模式实现。所谓通知模式，就是当生产者往满的队列里添加元素时会阻塞住生产者，当消费者消费了一个队列中的元素后，会通知生产者当前队列可用。通过查看JDK源码发现ArrayBlockingQueue使用了Condition来实现，代码如下。</p><figure class="highlight cs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> final Condition notFull; </span><br><span class="line"><span class="keyword">private</span> final Condition notEmpty; </span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">ArrayBlockingQueue</span>(<span class="params"><span class="keyword">int</span> capacity, boolean fair</span>) </span>&#123;        </span><br><span class="line">    <span class="comment">// 省略其他代码        </span></span><br><span class="line">    notEmpty = <span class="keyword">lock</span>.newCondition();        </span><br><span class="line">    notFull =  <span class="keyword">lock</span>.newCondition();    </span><br><span class="line">&#125; </span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">put</span>(<span class="params">E e</span>) throws InterruptedException </span>&#123;        </span><br><span class="line">    checkNotNull(e);        </span><br><span class="line">    final ReentrantLock <span class="keyword">lock</span> = <span class="keyword">this</span>.<span class="keyword">lock</span>;        </span><br><span class="line">    <span class="keyword">lock</span>.lockInterruptibly();        </span><br><span class="line">    <span class="keyword">try</span> &#123;            </span><br><span class="line">        <span class="keyword">while</span> (count == items.length)                </span><br><span class="line">            notFull.<span class="keyword">await</span>();            </span><br><span class="line">            insert(e);        </span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;            </span><br><span class="line">            <span class="keyword">lock</span>.unlock();        </span><br><span class="line">        &#125; </span><br><span class="line">    &#125; </span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> E <span class="title">take</span>(<span class="params"></span>) throws InterruptedException </span>&#123;      </span><br><span class="line">        final ReentrantLock <span class="keyword">lock</span> = <span class="keyword">this</span>.<span class="keyword">lock</span>;        </span><br><span class="line">        <span class="keyword">lock</span>.lockInterruptibly();        </span><br><span class="line">        <span class="keyword">try</span> &#123;            </span><br><span class="line">            <span class="keyword">while</span> (count == <span class="number">0</span>)                </span><br><span class="line">            notEmpty.<span class="keyword">await</span>();            </span><br><span class="line">            <span class="keyword">return</span> extract();        </span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;            </span><br><span class="line">            <span class="keyword">lock</span>.unlock();        </span><br><span class="line">        &#125; </span><br><span class="line">    &#125; </span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">insert</span>(<span class="params">E x</span>) </span>&#123;        </span><br><span class="line">        items[putIndex] = x;        </span><br><span class="line">        putIndex = inc(putIndex);        </span><br><span class="line">        ++count;        </span><br><span class="line">        notEmpty.signal();    </span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>&emsp;&emsp;当往队列里插入一个元素时，如果队列不可用，那么阻塞生产者主要通过LockSupport.park（this）来实现。</p><figure class="highlight crmsh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">public final void await() throws InterruptedException &#123;            </span><br><span class="line">    if (Thread.interrupted())                </span><br><span class="line">        throw new InterruptedException();            </span><br><span class="line">    <span class="keyword">Node</span> <span class="title">node</span> = addConditionWaiter();            </span><br><span class="line">    int savedState = fullyRelease(<span class="keyword">node</span><span class="title">);            </span></span><br><span class="line"><span class="title">    int</span> interruptMode = <span class="number">0</span>;            </span><br><span class="line">    </span><br><span class="line">    while (!isOnSyncQueue(<span class="keyword">node</span><span class="title">)) &#123;                </span></span><br><span class="line"><span class="title">        LockSupport</span>.park(this);                </span><br><span class="line">        if ((interruptMode = checkInterruptWhileWaiting(<span class="keyword">node</span><span class="title">)) != 0</span>)                    </span><br><span class="line">            break;            </span><br><span class="line">    &#125;            </span><br><span class="line">    if (acquireQueued(<span class="keyword">node</span><span class="title">, savedState</span>) &amp;&amp; interruptMode != THROW_IE)                </span><br><span class="line">        interruptMode = REINTERRUPT;            </span><br><span class="line">        </span><br><span class="line">    if (<span class="keyword">node</span>.<span class="title">nextWaiter</span> != null) // clean up if cancelled                </span><br><span class="line">        unlinkCancelledWaiters();            </span><br><span class="line">        </span><br><span class="line">    if (interruptMode != <span class="number">0</span>)                </span><br><span class="line">        reportInterruptAfterWait(interruptMode);        </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>&emsp;&emsp;继续进入源码，发现调用setBlocker先保存一下将要阻塞的线程，然后调用unsafe.park阻塞当前线程。</p><figure class="highlight cs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">park</span>(<span class="params">Object blocker</span>) </span>&#123;        </span><br><span class="line">    Thread t = Thread.currentThread();        </span><br><span class="line">    setBlocker(t, blocker);        </span><br><span class="line">    <span class="keyword">unsafe</span>.park(<span class="literal">false</span>, <span class="number">0</span>L);        </span><br><span class="line">    setBlocker(t, <span class="literal">null</span>);    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>&emsp;&emsp;unsafe.park是个native方法，代码如下。</p><figure class="highlight aspectj"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">native</span> <span class="function"><span class="keyword">void</span> <span class="title">park</span><span class="params">(<span class="keyword">boolean</span> isAbsolute, <span class="keyword">long</span> time)</span></span>;</span><br></pre></td></tr></table></figure><p>&emsp;&emsp;park这个方法会阻塞当前线程，只有以下4种情况中的一种发生时，该方法才会返回。</p><ul><li>与park对应的unpark执行或已经执行时。“已经执行”是指unpark先执行，然后再执行park的情况。</li><li>线程被中断时。</li><li>等待完time参数指定的毫秒数时。</li><li>异常现象发生时，这个异常现象没有任何原因。</li></ul><p>&emsp;&emsp;继续看一下JVM是如何实现park方法：park在不同的操作系统中使用不同的方式实现，在 Linux下使用的是系统方法pthread_cond_wait实现。实现代码在JVM源码路径src/os/linux/vm/os_linux.cpp里的os::PlatformEvent::park方法，代码如下。</p><figure class="highlight sqf"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line">void os::PlatformEvent::park() &#123;    </span><br><span class="line">    int v ;            </span><br><span class="line">    <span class="keyword">for</span> (;;) &#123;                </span><br><span class="line">        v = <span class="variable">_Event</span> ;            </span><br><span class="line">        <span class="keyword">if</span> (Atomic::cmpxchg (v-<span class="number">1</span>, &amp;<span class="variable">_Event</span>, v) == v)  break ;            </span><br><span class="line">    &#125;            </span><br><span class="line">    </span><br><span class="line">    guarantee (v &gt;= <span class="number">0</span>, <span class="string">"invariant"</span>) ;            </span><br><span class="line">    <span class="keyword">if</span> (v == <span class="number">0</span>) &#123;            </span><br><span class="line">        <span class="comment">// Do this the hard way by blocking ...            </span></span><br><span class="line">        int status = pthread_mutex_lock(<span class="variable">_mutex</span>);            </span><br><span class="line">        assert_status(status == <span class="number">0</span>, status, <span class="string">"mutex_lock"</span>);            </span><br><span class="line">        guarantee (<span class="variable">_nParked</span> == <span class="number">0</span>, <span class="string">"invariant"</span>) ;            </span><br><span class="line">        ++ <span class="variable">_nParked</span> ;            </span><br><span class="line">        <span class="keyword">while</span> (<span class="variable">_Event</span> &lt; <span class="number">0</span>) &#123;            </span><br><span class="line">            status = pthread_cond_wait(<span class="variable">_cond</span>, <span class="variable">_mutex</span>);            </span><br><span class="line">            <span class="comment">// for some reason, under 2.7 lwp_cond_wait() may return ETIME ...            </span></span><br><span class="line">            <span class="comment">// Treat this the same as if the wait was interrupted            </span></span><br><span class="line">            <span class="keyword">if</span> (status == ETIME) &#123; status = EINTR; &#125;            </span><br><span class="line">            assert_status(status == <span class="number">0</span> || status == EINTR, status, <span class="string">"cond_wait"</span>);            </span><br><span class="line">        &#125;            </span><br><span class="line">        -- <span class="variable">_nParked</span> ;            </span><br><span class="line">        <span class="comment">// In theory we could move the ST of 0 into _Event past the unlock(),            </span></span><br><span class="line">        <span class="comment">// but then we'd need a MEMBAR after the ST.            </span></span><br><span class="line">        <span class="variable">_Event</span> = <span class="number">0</span> ;            </span><br><span class="line">        status = pthread_mutex_unlock(<span class="variable">_mutex</span>);            </span><br><span class="line">        assert_status(status == <span class="number">0</span>, status, <span class="string">"mutex_unlock"</span>);            </span><br><span class="line">    &#125;            </span><br><span class="line">    guarantee (<span class="variable">_Event</span> &gt;= <span class="number">0</span>, <span class="string">"invariant"</span>) ;            </span><br><span class="line">    &#125;    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>&emsp;&emsp;pthread_cond_wait是一个多线程的条件变量函数，cond是condition的缩写，字面意思可以理解为线程在等待一个条件发生，这个条件是一个全局变量。这个方法接收两个参数：一个共享变量_cond，一个互斥量_mutex。而unpark方法在Linux下是使用pthread_cond_signal实现的。park方法在Windows下则是使用WaitForSingleObject实现的。想知道pthread_cond_wait是如何实现的，可以参考glibc-2.5的nptl/sysdeps/pthread/pthread_cond_wait.c。</p><p>&emsp;&emsp;当线程被阻塞队列阻塞时，线程会进入WAITING（parking）状态。我们可以使用jstack dump阻塞的生产者线程看到这点，如下。</p><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">"main"</span> prio=<span class="number">5</span> tid=<span class="number">0</span>x00007fc83c000000 nid=<span class="number">0</span>x10164e000 waiting on condition [<span class="number">0</span>x0000000101        </span><br><span class="line">       java<span class="selector-class">.lang</span><span class="selector-class">.Thread</span><span class="selector-class">.State</span>: WAITING (parking)              </span><br><span class="line">             at sun<span class="selector-class">.misc</span><span class="selector-class">.Unsafe</span><span class="selector-class">.park</span>(Native Method)              </span><br><span class="line">             - parking to wait <span class="keyword">for</span>  &lt;<span class="number">0</span>x0000000140559fe8&gt; (<span class="selector-tag">a</span> java<span class="selector-class">.util</span><span class="selector-class">.concurrent</span><span class="selector-class">.locks</span> AbstractQueuedSynchronizer<span class="variable">$ConditionObject</span>)        at java<span class="selector-class">.util</span><span class="selector-class">.concurrent</span><span class="selector-class">.locks</span><span class="selector-class">.LockSupport</span><span class="selector-class">.park</span>(LockSupport<span class="selector-class">.java</span>:<span class="number">186</span>)              </span><br><span class="line">             at java<span class="selector-class">.util</span><span class="selector-class">.concurrent</span><span class="selector-class">.locks</span><span class="selector-class">.AbstractQueuedSynchronizer</span><span class="variable">$ConditionObject</span>.await(AbstractQueuedSynchronizer<span class="selector-class">.java</span>:<span class="number">2043</span>)         at java<span class="selector-class">.util</span><span class="selector-class">.concurrent</span><span class="selector-class">.ArrayBlockingQueue</span><span class="selector-class">.put</span>(ArrayBlockingQueue<span class="selector-class">.java</span>:<span class="number">32</span>              </span><br><span class="line">             at blockingqueue<span class="selector-class">.ArrayBlockingQueueTest</span><span class="selector-class">.main</span>(ArrayBlockingQueueTest<span class="selector-class">.java</span>:</span><br></pre></td></tr></table></figure><hr><p><em>参考博客和文章书籍等：</em></p><blockquote><p>《Java并发编程的艺术》</p></blockquote><p><em>因博客主等未标明不可引用，若部分内容涉及侵权请及时告知，我会尽快修改和删除相关内容</em></p>]]></content>
    
    <summary type="html">
    
      介绍Java中阻塞队列，包括：内容简介，Java提供的7个阻塞队列，阻塞队列的实现原理等。
    
    </summary>
    
      <category term="技术文档" scheme="http://linyishui.top/categories/%E6%8A%80%E6%9C%AF%E6%96%87%E6%A1%A3/"/>
    
    
      <category term="java" scheme="http://linyishui.top/tags/java/"/>
    
      <category term="lock" scheme="http://linyishui.top/tags/lock/"/>
    
  </entry>
  
  <entry>
    <title>ConcurrentLinkedQueue的实现原理</title>
    <link href="http://linyishui.top/2019082401.html"/>
    <id>http://linyishui.top/2019082401.html</id>
    <published>2019-08-24T08:31:43.000Z</published>
    <updated>2019-10-11T09:21:39.380Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="ConcurrentLinkedQueue的实现原理"><a href="#ConcurrentLinkedQueue的实现原理" class="headerlink" title="ConcurrentLinkedQueue的实现原理"></a><strong>ConcurrentLinkedQueue的实现原理</strong></h1><p>&emsp;&emsp;在并发编程中，有时候需要使用线程安全的队列。如果要实现一个线程安全的队列有两种方式：一种是使用<strong>阻塞算法</strong>，另一种是使用<strong>非阻塞算法</strong>。</p><p>&emsp;&emsp;使用阻塞算法的队列可以用一个锁（入队和出队用同一把锁）或两个锁（入队和出队用不同的锁）等方式来实现。非阻塞的实现方式则可以使用循环CAS的方式来实现。本篇内容主要整理Doug Lea是如何使用非阻塞的方式来实现线程安全队列ConcurrentLinkedQueue的。</p><p>&emsp;&emsp;ConcurrentLinkedQueue是一个<strong>基于链接节点的无界线程安全队列</strong>，它采用<strong>先进先出</strong>的规则对节点进行排序，当我们添加一个元素的时候，它会添加到队列的尾部；当我们获取一个元素时，它会返回队列头部的元素。它采用了“wait-free”算法（即CAS算法）来实现，该算法在Michael&amp;Scott算法上进行了一些修改。</p><hr><h2 id="第一节-ConcurrentLinkedQueue的结构"><a href="#第一节-ConcurrentLinkedQueue的结构" class="headerlink" title="第一节 ConcurrentLinkedQueue的结构"></a><strong>第一节 ConcurrentLinkedQueue的结构</strong></h2><p>&emsp;&emsp;通过ConcurrentLinkedQueue的类图来分析一下它的结构，如下图所示。</p><p><img src="https://pic-1258215793.cos.ap-shanghai.myqcloud.com/content/20190701/201907010103.png" alt="ConcurrentLinkedQueue的类图"></p><p>&emsp;&emsp;ConcurrentLinkedQueue由head节点和tail节点组成，每个节点（Node）由节点元素（item）和指向下一个节点（next）的引用组成，节点与节点之间就是通过这个next关联起来，从而组成一张链表结构的队列。默认情况下head节点存储的元素为空，tail节点等于head节点。</p><figure class="highlight crmsh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">private transient volatile <span class="keyword">Node</span><span class="title">&lt;E</span>&gt; tail = head;</span><br></pre></td></tr></table></figure><hr><h2 id="第二节-入队列"><a href="#第二节-入队列" class="headerlink" title="第二节 入队列"></a><strong>第二节 入队列</strong></h2><p>&emsp;&emsp;本节将介绍入队列的相关知识。</p><h3 id="1-入队列的过程"><a href="#1-入队列的过程" class="headerlink" title="1 入队列的过程"></a><strong>1 入队列的过程</strong></h3><p>&emsp;&emsp;入队列就是将入队节点添加到队列的尾部。为了方便理解入队时队列的变化，以及head节点和tail节点的变化，这里以一个示例来展开介绍。假设我们想在一个队列中依次插入4个节点，为了帮助大家理解，每添加一个节点就做了一个队列的快照图，如下图所示。</p><p><img src="https://pic-1258215793.cos.ap-shanghai.myqcloud.com/content/20190701/201907010104.png" alt="队列添加元素的快照图"></p><p>&emsp;&emsp;上图所示的过程如下。</p><ul><li>添加元素1。队列更新head节点的next节点为元素1节点。又因为tail节点默认情况下等于head节点，所以它们的next节点都指向元素1节点。</li><li>添加元素2。队列首先设置元素1节点的next节点为元素2节点，然后更新tail节点指向元素2节点。</li><li>添加元素3，设置tail节点的next节点为元素3节点。</li><li>添加元素4，设置元素3的next节点为元素4节点，然后将tail节点指向元素4节点。</li></ul><p>&emsp;&emsp;通过调试入队过程并观察head节点和tail节点的变化，发现入队主要做两件事情：第一是将入队节点设置成当前队列尾节点的下一个节点；第二是更新tail节点，如果tail节点的next节点不为空，则将入队节点设置成tail节点，如果tail节点的next节点为空，则将入队节点设置成tail的next节点，所以tail节点不总是尾节点（理解这一点对于我们研究源码会非常有帮助）。</p><p>&emsp;&emsp;通过对上面的分析，我们从单线程入队的角度理解了入队过程，但是多个线程同时进行入队的情况就变得更加复杂了，因为可能会出现其他线程插队的情况。如果有一个线程正在入队，那么它必须先获取尾节点，然后设置尾节点的下一个节点为入队节点，但这时可能有另外一个线程插队了，那么队列的尾节点就会发生变化，这时当前线程要暂停入队操作，然后重新获取尾节点。让我们再通过源码来详细分析一下它是如何使用CAS算法来入队的。</p><figure class="highlight gradle"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">boolean</span> offer(E e) &#123;        </span><br><span class="line">    <span class="keyword">if</span> (e == <span class="keyword">null</span>) </span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> NullPointerException();    </span><br><span class="line">    <span class="comment">// 入队前，创建一个入队节点        </span></span><br><span class="line">    Node&lt;E&gt; n = <span class="keyword">new</span> Node&lt;E&gt;(e);        </span><br><span class="line">    retry:        </span><br><span class="line">    <span class="comment">// 死循环，入队不成功反复入队。        </span></span><br><span class="line">    <span class="keyword">for</span> (;;) &#123;            </span><br><span class="line">        <span class="comment">// 创建一个指向tail节点的引用            </span></span><br><span class="line">        Node&lt;E&gt; t = tail;            </span><br><span class="line">        <span class="comment">// p用来表示队列的尾节点，默认情况下等于tail节点。            </span></span><br><span class="line">        Node&lt;E&gt; p = t;            </span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> hops = <span class="number">0</span>; ; hops++) &#123;            </span><br><span class="line">            <span class="comment">// 获得p节点的下一个节点。                </span></span><br><span class="line">            Node&lt;E&gt; <span class="keyword">next</span> = succ(p);    </span><br><span class="line">            <span class="comment">// next节点不为空，说明p不是尾节点，需要更新p后在将它指向next节点                </span></span><br><span class="line">            <span class="keyword">if</span> (<span class="keyword">next</span> != <span class="keyword">null</span>) &#123;                    </span><br><span class="line">                <span class="comment">// 循环了两次及其以上，并且当前节点还是不等于尾节点                    </span></span><br><span class="line">                <span class="keyword">if</span> (hops &gt; HOPS &amp;&amp; t != tail)                        </span><br><span class="line">                    <span class="keyword">continue</span> retry;                     </span><br><span class="line">                p = <span class="keyword">next</span>;                </span><br><span class="line">            &#125;                </span><br><span class="line">            <span class="comment">// 如果p是尾节点，则设置p节点的next节点为入队节点。                </span></span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (p.casNext(<span class="keyword">null</span>, n)) &#123;                    </span><br><span class="line">                <span class="comment">/*如果tail节点有大于等于1个next节点，则将入队节点设置成tail节点，                      </span></span><br><span class="line"><span class="comment">                更新失败了也没关系，因为失败了表示有其他线程成功更新了tail节点*/</span> </span><br><span class="line">                <span class="keyword">if</span> (hops &gt;= HOPS)                        </span><br><span class="line">                    casTail(t, n); </span><br><span class="line">                    <span class="comment">// 更新tail节点，允许失败                    </span></span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">true</span>;                </span><br><span class="line">            &#125;                </span><br><span class="line">            <span class="comment">// p有next节点,表示p的next节点是尾节点，则重新设置p节点                </span></span><br><span class="line">            <span class="keyword">else</span> &#123;                    </span><br><span class="line">                p = succ(p);                </span><br><span class="line">            &#125;            </span><br><span class="line">        &#125;        </span><br><span class="line">    &#125;    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>&emsp;&emsp;从源代码角度来看，整个入队过程主要做两件事情：第一是定位出尾节点；第二是使用CAS算法将入队节点设置成尾节点的next节点，如不成功则重试。</p><h3 id="2-定位尾节点"><a href="#2-定位尾节点" class="headerlink" title="2 定位尾节点"></a><strong>2 定位尾节点</strong></h3><p>&emsp;&emsp;tail节点并不总是尾节点，所以每次入队都必须先通过tail节点来找到尾节点。尾节点可能是tail节点，也可能是tail节点的next节点。代码中循环体中的第一个if就是判断tail是否有next节点，有则表示next节点可能是尾节点。获取tail节点的next节点需要注意的是p节点等于p的next节点的情况，只有一种可能就是p节点和p的next节点都等于空，表示这个队列刚初始化，正准备添加节点，所以需要返回head节点。获取p节点的next节点代码如下。</p><figure class="highlight crmsh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">final <span class="keyword">Node</span><span class="title">&lt;E</span>&gt; succ(<span class="keyword">Node</span><span class="title">&lt;E</span>&gt; p) &#123;        </span><br><span class="line">    <span class="keyword">Node</span><span class="title">&lt;E</span>&gt; next = p.getNext();        </span><br><span class="line">    return (p == next)  </span><br><span class="line">    head : next;    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="3-设置入队节点为尾节点"><a href="#3-设置入队节点为尾节点" class="headerlink" title="3 设置入队节点为尾节点"></a><strong>3 设置入队节点为尾节点</strong></h3><p>&emsp;&emsp;p.casNext（null，n）方法用于将入队节点设置为当前队列尾节点的next节点，如果p是null，表示p是当前队列的尾节点，如果不为null，表示有其他线程更新了尾节点，则需要重新获取当前队列的尾节点。</p><h3 id="4-HOPS的设计意图"><a href="#4-HOPS的设计意图" class="headerlink" title="4 HOPS的设计意图"></a><strong>4 HOPS的设计意图</strong></h3><p>&emsp;&emsp;上面分析过对于先进先出的队列入队所要做的事情是将入队节点设置成尾节点，doug lea写的代码和逻辑还是稍微有点复杂。那么，我用以下方式来实现是否可行？</p><figure class="highlight aspectj"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="function"><span class="keyword">boolean</span> <span class="title">offer</span><span class="params">(E e)</span> </span>&#123;        </span><br><span class="line">    <span class="keyword">if</span> (e == <span class="keyword">null</span>)                        </span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> NullPointerException();                </span><br><span class="line">    Node&lt;E&gt; n = <span class="keyword">new</span> Node&lt;E&gt;(e);                </span><br><span class="line">    <span class="keyword">for</span> (;;) &#123;                        </span><br><span class="line">        Node&lt;E&gt; t = tail;                        </span><br><span class="line">        <span class="keyword">if</span> (t.casNext(<span class="keyword">null</span>, n) &amp;&amp; casTail(t, n)) &#123;                                </span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">true</span>;                        </span><br><span class="line">        &#125;                </span><br><span class="line">    &#125;    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>&emsp;&emsp;让tail节点永远作为队列的尾节点，这样实现代码量非常少，而且逻辑清晰和易懂。但是，这么做有个缺点，每次都需要使用循环CAS更新tail节点。如果能减少CAS更新tail节点的次数，就能提高入队的效率，所以doug lea使用hops变量来控制并减少tail节点的更新频率，并不是每次节点入队后都将tail节点更新成尾节点，而是当tail节点和尾节点的距离大于等于常量HOPS的值（默认等于1）时才更新tail节点，tail和尾节点的距离越长，使用CAS更新tail节点的次数就会越少，但是距离越长带来的负面效果就是每次入队时定位尾节点的时间就越长，因为循环体需要多循环一次来定位出尾节点，但是这样仍然能提高入队的效率，因为从本质上来看它通过增加对volatile变量的读操作来减少对volatile变量的写操作，而对volatile变量的写操作开销要远远大于读操作，所以入队效率会有所提升。</p><figure class="highlight aspectj"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> HOPS = <span class="number">1</span>;</span><br></pre></td></tr></table></figure><p>&emsp;&emsp;注意入队方法永远返回true，所以不要通过返回值判断入队是否成功。</p><h2 id="第三节-出队列"><a href="#第三节-出队列" class="headerlink" title="第三节 出队列"></a><strong>第三节 出队列</strong></h2><p>&emsp;&emsp;出队列的就是从队列里返回一个节点元素，并清空该节点对元素的引用。让我们通过每个节点出队的快照来观察一下head节点的变化，如下图所示。</p><p>&emsp;&emsp;从图中可知，并不是每次出队时都更新head节点，当head节点里有元素时，直接弹出head节点里的元素，而不会更新head节点。只有当head节点里没有元素时，出队操作才会更新head节点。这种做法也是通过hops变量来减少使用CAS更新head节点的消耗，从而提高出队效率。</p><p>&emsp;&emsp;让我们再通过源码来深入分析下出队过程。</p><p><img src="https://pic-1258215793.cos.ap-shanghai.myqcloud.com/content/20190701/201907010105.png" alt="队列出节点快照图"></p><figure class="highlight gradle"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> E poll() &#123;                </span><br><span class="line">    Node&lt;E&gt; h = head;        </span><br><span class="line">    <span class="comment">// p表示头节点，需要出队的节点</span></span><br><span class="line">    Node&lt;E&gt; p = h;                </span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> hops = <span class="number">0</span>;; hops++) &#123;                        </span><br><span class="line">        <span class="comment">// 获取p节点的元素                        </span></span><br><span class="line">        E item = p.getItem();                        </span><br><span class="line">        <span class="comment">// 如果p节点的元素不为空，使用CAS设置p节点引用的元素为null,                        </span></span><br><span class="line">        <span class="comment">// 如果成功则返回p节点的元素。                        </span></span><br><span class="line">        <span class="keyword">if</span> (item != <span class="keyword">null</span> &amp;&amp; p.casItem(item, <span class="keyword">null</span>)) &#123;                                </span><br><span class="line">            <span class="keyword">if</span> (hops &gt;= HOPS) &#123;                                        </span><br><span class="line">                <span class="comment">// 将p节点下一个节点设置成head节点                                        </span></span><br><span class="line">                Node&lt;E&gt; q = p.getNext();                                        </span><br><span class="line">                updateHead(h, (q != <span class="keyword">null</span>)  q : p);                                </span><br><span class="line">            &#125;                                </span><br><span class="line">            <span class="keyword">return</span> item;                        </span><br><span class="line">        &#125;                        </span><br><span class="line">        <span class="comment">// 如果头节点的元素为空或头节点发生了变化，这说明头节点已经被另外                        </span></span><br><span class="line">        <span class="comment">// 一个线程修改了。那么获取p节点的下一个节点                        </span></span><br><span class="line">        Node&lt;E&gt; <span class="keyword">next</span> = succ(p);                        </span><br><span class="line">        <span class="comment">// 如果p的下一个节点也为空，说明这个队列已经空了                        </span></span><br><span class="line">        <span class="keyword">if</span> (<span class="keyword">next</span> == <span class="keyword">null</span>) &#123;            </span><br><span class="line">            <span class="comment">// 更新头节点。                                </span></span><br><span class="line">            updateHead(h, p);                                </span><br><span class="line">            <span class="keyword">break</span>;                        </span><br><span class="line">        &#125;                        </span><br><span class="line">        <span class="comment">// 如果下一个元素不为空，则将头节点的下一个节点设置成头节点                        </span></span><br><span class="line">        p = <span class="keyword">next</span>;                </span><br><span class="line">    &#125;               </span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">null</span>;        </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>&emsp;&emsp;首先获取头节点的元素，然后判断头节点元素是否为空，如果为空，表示另外一个线程已经进行了一次出队操作将该节点的元素取走，如果不为空，则使用CAS的方式将头节点的引用设置成null，如果CAS成功，则直接返回头节点的元素，如果不成功，表示另外一个线程已经进行了一次出队操作更新了head节点，导致元素发生了变化，需要重新获取头节点。</p><hr><p><em>参考博客和文章书籍等：</em></p><blockquote><p>《Java并发编程的艺术》</p></blockquote><p><em>因博客主等未标明不可引用，若部分内容涉及侵权请及时告知，我会尽快修改和删除相关内容</em></p>]]></content>
    
    <summary type="html">
    
      介绍Java中ConcurrentLinkedQueue的实现原理，包括：ConcurrentLinkedQueue的结构，入队列，出队列等。
    
    </summary>
    
      <category term="技术文档" scheme="http://linyishui.top/categories/%E6%8A%80%E6%9C%AF%E6%96%87%E6%A1%A3/"/>
    
    
      <category term="java" scheme="http://linyishui.top/tags/java/"/>
    
      <category term="lock" scheme="http://linyishui.top/tags/lock/"/>
    
  </entry>
  
  <entry>
    <title>ConcurrentHashMap的实现原理与使用</title>
    <link href="http://linyishui.top/2019082301.html"/>
    <id>http://linyishui.top/2019082301.html</id>
    <published>2019-08-23T07:53:56.000Z</published>
    <updated>2019-10-11T09:21:42.736Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="ConcurrentHashMap的实现原理与使用"><a href="#ConcurrentHashMap的实现原理与使用" class="headerlink" title="ConcurrentHashMap的实现原理与使用"></a><strong>ConcurrentHashMap的实现原理与使用</strong></h1><p>&emsp;&emsp;ConcurrentHashMap是线程安全且高效的HashMap。我们需要了解该容器是如何在保证线程安全的同时又能保证高效的操作。</p><hr><h2 id="第一节-为什么要使用ConcurrentHashMap"><a href="#第一节-为什么要使用ConcurrentHashMap" class="headerlink" title="第一节 为什么要使用ConcurrentHashMap"></a><strong>第一节 为什么要使用ConcurrentHashMap</strong></h2><p>&emsp;&emsp;在并发编程中使用HashMap可能导致程序死循环。而使用线程安全的HashTable效率又非常低下，基于以上两个原因，便有了ConcurrentHashMap的登场机会。</p><h3 id="1-线程不安全的HashMap"><a href="#1-线程不安全的HashMap" class="headerlink" title="1 线程不安全的HashMap"></a><strong>1 线程不安全的HashMap</strong></h3><p>&emsp;&emsp;在多线程环境下，使用HashMap进行put操作会引起死循环，导致CPU利用率接近100%，所以在并发情况下不能使用HashMap。例如，执行以下代码会引起死循环。</p><figure class="highlight processing"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">final</span> <span class="keyword">HashMap</span>&lt;<span class="keyword">String</span>, <span class="keyword">String</span>&gt; <span class="built_in">map</span> = <span class="keyword">new</span> <span class="keyword">HashMap</span>&lt;<span class="keyword">String</span>, <span class="keyword">String</span>&gt;(<span class="number">2</span>);        </span><br><span class="line">Thread t = <span class="keyword">new</span> Thread(<span class="keyword">new</span> Runnable() &#123;            </span><br><span class="line">    @Override            </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> run() &#123;<span class="comment">//重写run函数，循环创建并启动新线程                </span></span><br><span class="line">        <span class="keyword">for</span> (<span class="built_in">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10000</span>; i++) &#123;                    </span><br><span class="line">            <span class="keyword">new</span> Thread(<span class="keyword">new</span> Runnable() &#123;                        </span><br><span class="line">                @Override                        </span><br><span class="line">                <span class="keyword">public</span> <span class="keyword">void</span> run() &#123;<span class="comment">//线程向HashMap写入一组随机字符键值对                    </span></span><br><span class="line">                    <span class="built_in">map</span>.put(UUID.randomUUID().toString(), <span class="string">""</span>);                        </span><br><span class="line">                &#125;                    </span><br><span class="line">            &#125;, <span class="string">"ftf"</span> + i).start();                </span><br><span class="line">        &#125;            </span><br><span class="line">    &#125;        </span><br><span class="line">&#125;, <span class="string">"ftf"</span>);        </span><br><span class="line">t.start();        </span><br><span class="line">t.<span class="built_in">join</span>();</span><br></pre></td></tr></table></figure><p>&emsp;&emsp;HashMap在并发执行put操作时会引起死循环，是因为多线程会导致HashMap的Entry链表形成环形数据结构，一旦形成环形数据结构，Entry的next节点永远不为空，就会产生死循环获取Entry。</p><h3 id="2-效率低下的HashTable"><a href="#2-效率低下的HashTable" class="headerlink" title="2 效率低下的HashTable"></a><strong>2 效率低下的HashTable</strong></h3><p>&emsp;&emsp;HashTable容器使用<strong>synchronized</strong>来保证线程安全，但在线程竞争激烈的情况下HashTable的效率非常低下。因为当一个线程访问HashTable的同步方法，其他线程也访问HashTable的同步方法时，会进入阻塞或轮询状态。如线程1使用put进行元素添加，线程2不但不能使用put方法添加元素，也不能使用get方法来获取元素，所以竞争越激烈效率越低。</p><h3 id="3-ConcurrentHashMap的锁分段技术可有效提升并发访问率"><a href="#3-ConcurrentHashMap的锁分段技术可有效提升并发访问率" class="headerlink" title="3 ConcurrentHashMap的锁分段技术可有效提升并发访问率"></a><strong>3 ConcurrentHashMap的锁分段技术可有效提升并发访问率</strong></h3><p>&emsp;&emsp;HashTable容器在竞争激烈的并发环境下表现出效率低下的原因是所有访问HashTable的线程都必须竞争同一把锁，假如容器里有多把锁，每一把锁用于锁容器其中一部分数据，那么当多线程访问容器里不同数据段的数据时，线程间就不会存在锁竞争，从而可以有效提高并发访问效率，这就是ConcurrentHashMap所使用的锁分段技术。<strong>首先将数据分成一段一段地存储，然后给每一段数据配一把锁，当一个线程占用锁访问其中一个段数据的时候，其他段的数据也能被其他线程访问</strong>。</p><hr><h2 id="第二节-ConcurrentHashMap的结构"><a href="#第二节-ConcurrentHashMap的结构" class="headerlink" title="第二节 ConcurrentHashMap的结构"></a><strong>第二节 ConcurrentHashMap的结构</strong></h2><p>&emsp;&emsp;通过ConcurrentHashMap的类图来分析ConcurrentHashMap的结构，如下图所示。ConcurrentHashMap是由<strong>Segment数组结构</strong>和<strong>HashEntry数组结构</strong>组成。Segment是一种可重入锁（ReentrantLock），在ConcurrentHashMap里扮演锁的角色；HashEntry则用于存储键值对数据。一个ConcurrentHashMap里包含一个Segment数组。</p><p><img src="https://pic-1258215793.cos.ap-shanghai.myqcloud.com/content/20190701/201907010101.png" alt="ConcurrentHashMap的类图"></p><p>&emsp;&emsp;Segment的结构和HashMap类似，是一种数组和链表结构。一个Segment里包含一个HashEntry数组，每个HashEntry是一个链表结构的元素，每个Segment守护着一个HashEntry数组里的元素，当对HashEntry数组的数据进行修改时，必须首先获得与它对应的Segment锁，如下图所示。</p><p><img src="https://pic-1258215793.cos.ap-shanghai.myqcloud.com/content/20190701/201907010102.png" alt="ConcurrentHashMap的结构图"></p><hr><h2 id="第三节-ConcurrentHashMap的初始化"><a href="#第三节-ConcurrentHashMap的初始化" class="headerlink" title="第三节 ConcurrentHashMap的初始化"></a><strong>第三节 ConcurrentHashMap的初始化</strong></h2><p>&emsp;&emsp;ConcurrentHashMap初始化方法是通过initialCapacity、loadFactor和concurrencyLevel等几个参数来初始化segment数组、段偏移量segmentShift、段掩码segmentMask和每个segment里的HashEntry数组来实现的。</p><h3 id="1-初始化segments数组"><a href="#1-初始化segments数组" class="headerlink" title="1 初始化segments数组"></a><strong>1 初始化segments数组</strong></h3><p>&emsp;&emsp;让我们来看一下初始化segments数组的源代码。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (concurrencyLevel &gt; MAX_SEGMENTS)            </span><br><span class="line">    concurrencyLevel = MAX_SEGMENTS;        </span><br><span class="line"><span class="keyword">int</span> sshift = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">int</span> ssize = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">while</span> (ssize &lt; concurrencyLevel) &#123;            </span><br><span class="line">    ++sshift;            </span><br><span class="line">    ssize &lt;&lt;= <span class="number">1</span>;<span class="comment">//左移一位，左边移除，右边补0，相当于*2        </span></span><br><span class="line">&#125;        </span><br><span class="line"></span><br><span class="line">segmentShift = <span class="number">32</span> - sshift;<span class="comment">//计算得到段偏移量        </span></span><br><span class="line">segmentMask = ssize - <span class="number">1</span>;<span class="comment">//计算得到段掩码        </span></span><br><span class="line"><span class="keyword">this</span>.segments = Segment.newArray(ssize);</span><br></pre></td></tr></table></figure><p>&emsp;&emsp;由上面的代码可知，segments数组的长度ssize是通过concurrencyLevel计算得出的。为了能通过按位与的散列算法来定位segments数组的索引，必须保证segments数组的长度是2的N次方 （power-of-two size），所以必须计算出一个大于或等于concurrencyLevel的最小的2的N次方值来作为segments数组的长度。假如concurrencyLevel等于14、15或16，ssize都会等于16，即容器里锁的个数也是16。</p><p>&emsp;&emsp;注意concurrencyLevel的最大值是65535，这意味着segments数组的长度最大为65536，对应的二进制是16位。</p><h3 id="2-初始化segmentShift和segmentMask"><a href="#2-初始化segmentShift和segmentMask" class="headerlink" title="2 初始化segmentShift和segmentMask"></a><strong>2 初始化segmentShift和segmentMask</strong></h3><p>&emsp;&emsp;这两个全局变量需要在定位segment时的散列算法里使用，sshift等于ssize从1向左移位的次数，在默认情况下concurrencyLevel等于16，1需要向左移位移动4次，所以sshift等于4。 （ssize: 1-&gt;2-&gt;4-&gt;8-&gt;16 sshift = 4）</p><p>&emsp;&emsp;segmentShift用于定位参与散列运算的位数，segmentShift等于32减sshift，所以等于28，这里之所以用32是因为ConcurrentHashMap里的hash()方法输出的最大数是32位的，后面的测试中我们可以看到这点。</p><p>&emsp;&emsp;segmentMask是散列运算的掩码，等于ssize减1，即15，掩码的二进制各个位的值都是1。因为ssize的最大长度是65536，所以segmentShift最大值是16，segmentMask最大值是65535，对应的二进制是16位，每个位都是1。</p><h3 id="3-初始化每个segment"><a href="#3-初始化每个segment" class="headerlink" title="3 初始化每个segment"></a><strong>3 初始化每个segment</strong></h3><p>&emsp;&emsp;输入参数initialCapacity是ConcurrentHashMap的初始化容量，loadfactor是每个segment的负载因子，在构造方法里需要通过这两个参数来初始化数组中的每个segment。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (initialCapacity &gt; MAXIMUM_CAPACITY)            </span><br><span class="line">    initialCapacity = MAXIMUM_CAPACITY;   </span><br><span class="line"><span class="keyword">int</span> c = initialCapacity / ssize;     </span><br><span class="line"><span class="keyword">if</span> (c * ssize &lt; initialCapacity)<span class="comment">//ssize不是initialCapacity的约数，则c+1</span></span><br><span class="line">    ++c;    </span><br><span class="line"><span class="keyword">int</span> <span class="built_in">cap</span> = <span class="number">1</span>; </span><br><span class="line">while (<span class="built_in">cap</span> &lt; c) <span class="comment">//cap为2的c次方        </span></span><br><span class="line">    <span class="built_in">cap</span> &lt;&lt;= <span class="number">1</span>;        </span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; this.segments.length; ++i)            </span><br><span class="line">    this.segments[i] = <span class="built_in">new</span> Segment&lt;K,V&gt;(<span class="built_in">cap</span>, loadFactor);</span><br></pre></td></tr></table></figure><p>&emsp;&emsp;上面代码中的变量cap就是segment里HashEntry数组的长度，它等于initialCapacity除以ssize的倍数c，如果c大于1，就会取大于等于c的2的N次方值，所以cap不是1，就是2的N次方。 </p><p>&emsp;&emsp;segment的容量threshold＝（int）cap*loadFactor，默认情况下initialCapacity等于16，loadfactor等于 0.75，通过运算cap等于1，threshold等于零。</p><hr><h2 id="第四节-定位Segment"><a href="#第四节-定位Segment" class="headerlink" title="第四节 定位Segment"></a><strong>第四节 定位Segment</strong></h2><p>&emsp;&emsp;既然ConcurrentHashMap使用分段锁Segment来保护不同段的数据，那么在插入和获取元素的时候，必须先通过散列算法定位到Segment。可以看到ConcurrentHashMap会首先使用Wang/Jenkins hash的变种算法对元素的hashCode进行一次<strong>再散列</strong>。</p><figure class="highlight nginx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="attribute">private</span> static int hash(int h) &#123;        </span><br><span class="line">    <span class="attribute">h</span> += (h &lt;&lt; <span class="number">15</span>)<span class="regexp"> ^</span> 0xffffcd7d;        </span><br><span class="line">    <span class="attribute">h</span><span class="regexp"> ^=</span> (h &gt;&gt;&gt; <span class="number">10</span>);       </span><br><span class="line">    <span class="attribute">h</span> += (h &lt;&lt; <span class="number">3</span>);        </span><br><span class="line">    <span class="attribute">h</span><span class="regexp"> ^=</span> (h &gt;&gt;&gt; <span class="number">6</span>);        </span><br><span class="line">    <span class="attribute">h</span> += (h &lt;&lt; <span class="number">2</span>) + (h &lt;&lt; <span class="number">14</span>);        </span><br><span class="line">    <span class="attribute">return</span> h<span class="regexp"> ^</span> (h &gt;&gt;&gt; <span class="number">16</span>);    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>&emsp;&emsp;之所以进行再散列，目的是减少散列冲突，使元素能够均匀地分布在不同的Segment上，从而提高容器的存取效率。假如散列的质量差到极点，那么所有的元素都在一个Segment中，不仅存取元素缓慢，分段锁也会失去意义。原作者做了一个测试，不通过再散列而直接执行散列计算。</p><figure class="highlight arduino"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">System.out.<span class="built_in">println</span>(Integer.<span class="built_in">parseInt</span>(<span class="string">"0001111"</span>, <span class="number">2</span>) &amp; <span class="number">15</span>); </span><br><span class="line">System.out.<span class="built_in">println</span>(Integer.<span class="built_in">parseInt</span>(<span class="string">"0011111"</span>, <span class="number">2</span>) &amp; <span class="number">15</span>); </span><br><span class="line">System.out.<span class="built_in">println</span>(Integer.<span class="built_in">parseInt</span>(<span class="string">"0111111"</span>, <span class="number">2</span>) &amp; <span class="number">15</span>); </span><br><span class="line">System.out.<span class="built_in">println</span>(Integer.<span class="built_in">parseInt</span>(<span class="string">"1111111"</span>, <span class="number">2</span>) &amp; <span class="number">15</span>);</span><br></pre></td></tr></table></figure><p>&emsp;&emsp;计算后输出的散列值全是15，通过这个例子可以发现，如果不进行再散列，散列冲突会非常严重，因为只要低位一样，无论高位是什么数，其散列值总是一样。我们再把上面的二进制数据进行再散列后结果如下（为了方便阅读，不足32位的高位补了0，每隔4位用竖线分割下）。</p><figure class="highlight lsl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">0100</span>｜<span class="number">0111</span>｜<span class="number">0110</span>｜<span class="number">0111</span>｜<span class="number">1101</span>｜<span class="number">1010</span>｜<span class="number">0100</span>｜<span class="number">1110</span> </span><br><span class="line"><span class="number">1111</span>｜<span class="number">0111</span>｜<span class="number">0100</span>｜<span class="number">0011</span>｜<span class="number">0000</span>｜<span class="number">0001</span>｜<span class="number">1011</span>｜<span class="number">1000</span> </span><br><span class="line"><span class="number">0111</span>｜<span class="number">0111</span>｜<span class="number">0110</span>｜<span class="number">1001</span>｜<span class="number">0100</span>｜<span class="number">0110</span>｜<span class="number">0011</span>｜<span class="number">1110</span> </span><br><span class="line"><span class="number">1000</span>｜<span class="number">0011</span>｜<span class="number">0000</span>｜<span class="number">0000</span>｜<span class="number">1100</span>｜<span class="number">1000</span>｜<span class="number">0001</span>｜<span class="number">1010</span></span><br></pre></td></tr></table></figure><p>&emsp;&emsp;可以发现，每一位的数据都散列开了，通过这种再散列能让数字的每一位都参加到散列运算当中，从而减少散列冲突。ConcurrentHashMap通过以下散列算法定位segment。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">final</span> Segment&lt;K,V&gt; <span class="title">segmentFor</span><span class="params">(<span class="keyword">int</span> hash)</span> </span>&#123;        </span><br><span class="line">    <span class="keyword">return</span> segments[(hash &gt;&gt;&gt; segmentShift) &amp; segmentMask];    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>&emsp;&emsp;默认情况下segmentShift为28，segmentMask为15，再散列后的数最大是32位二进制数据，向右无符号移动28位，意思是让高4位参与到散列运算中，(hash&gt;&gt;&gt;segmentShift) &amp; segmentMask的运算结果分别是4、15、7和8，可以看到散列值没有发生冲突。</p><hr><h2 id="第五节-ConcurrentHashMap的操作"><a href="#第五节-ConcurrentHashMap的操作" class="headerlink" title="第五节 ConcurrentHashMap的操作"></a><strong>第五节 ConcurrentHashMap的操作</strong></h2><p>&emsp;&emsp;本节介绍ConcurrentHashMap的3种操作——get操作、put操作和size操作。</p><h3 id="1-get操作"><a href="#1-get操作" class="headerlink" title="1 get操作"></a><strong>1 get操作</strong></h3><p>&emsp;&emsp;Segment的get操作实现非常简单和高效。先经过一次再散列，然后使用这个散列值通过散列运算定位到Segment，再通过散列算法定位到元素，代码如下。</p><figure class="highlight processing"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> V <span class="built_in">get</span>(<span class="keyword">Object</span> <span class="built_in">key</span>) &#123;        </span><br><span class="line">    <span class="built_in">int</span> hash = hash(<span class="built_in">key</span>.hashCode());        </span><br><span class="line">    <span class="keyword">return</span> segmentFor(hash).<span class="built_in">get</span>(<span class="built_in">key</span>, hash);    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>&emsp;&emsp;get操作的高效之处在于整个get过程不需要加锁，除非读到的值是空才会加锁重读。</p><p>&emsp;&emsp;我们知道HashTable容器的get方法是需要加锁的，那么ConcurrentHashMap的get操作是如何做到不加锁的呢？原因是它的get方法里将要使用的共享变量都定义成volatile类型，如用于统计当前Segement大小的count字段和用于存储值的HashEntry的value。定义成volatile的变量，能够在线程之间保持可见性，能够被多线程同时读，并且保证不会读到过期的值，但是只能被单线程写 （有一种情况可以被多线程写，就是写入的值不依赖于原值），在get操作里只需要读不需要写共享变量count和value，所以可以不用加锁。之所以不会读到过期的值，是因为根据Java内存模型的happen before原则，对volatile字段的写入操作先于读操作，即使两个线程同时修改和获取volatile变量，get操作也能拿到最新的值，这是用volatile替换锁的经典应用场景。</p><figure class="highlight fortran"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">transient <span class="keyword">volatile</span> <span class="built_in">int</span> <span class="built_in">count</span>; </span><br><span class="line"><span class="keyword">volatile</span> V <span class="keyword">value</span>;</span><br></pre></td></tr></table></figure><p>&emsp;&emsp;在定位元素的代码里我们可以发现，定位HashEntry和定位Segment的散列算法虽然一样， 都与数组的长度减去1再相“与”，但是相“与”的值不一样，定位Segment使用的是元素的 hashcode通过再散列后得到的值的高位，而定位HashEntry直接使用的是再散列后的值。其目的是避免两次散列后的值一样，虽然元素在Segment里散列开了，但是却没有在HashEntry里散列开。</p><figure class="highlight glsl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">hash &gt;&gt;&gt; segmentShift) &amp; segmentMask　<span class="comment">// 定位Segment所使用的hash算法 </span></span><br><span class="line"><span class="type">int</span> <span class="keyword">index</span> = hash &amp; (tab.<span class="built_in">length</span> - <span class="number">1</span>);　<span class="comment">// 定位HashEntry所使用的hash算法</span></span><br></pre></td></tr></table></figure><h3 id="2-put操作"><a href="#2-put操作" class="headerlink" title="2 put操作"></a><strong>2 put操作</strong></h3><p>&emsp;&emsp;由于put方法里需要对共享变量进行写入操作，所以为了线程安全，在操作共享变量时必 须加锁。put方法首先定位到Segment，然后在Segment里进行插入操作。插入操作需要经历两个步骤，第一步判断是否需要对Segment里的HashEntry数组进行扩容，第二步定位添加元素的位置，然后将其放在HashEntry数组里。</p><h4 id="（1）是否需要扩容"><a href="#（1）是否需要扩容" class="headerlink" title="（1）是否需要扩容"></a><strong>（1）是否需要扩容</strong></h4><p>&emsp;&emsp;在插入元素前会先判断Segment里的HashEntry数组是否超过容量（threshold），如果超过阈值，则对数组进行扩容。值得一提的是，Segment的扩容判断比HashMap更恰当，因为HashMap是在插入元素后判断元素是否已经到达容量的，如果到达了就进行扩容，但是很有可能扩容之后没有新元素插入，这时HashMap就进行了一次无效的扩容。</p><h4 id="（2）如何扩容"><a href="#（2）如何扩容" class="headerlink" title="（2）如何扩容"></a><strong>（2）如何扩容</strong></h4><p>&emsp;&emsp;在扩容的时候，首先会创建一个容量是原来容量两倍的数组，然后将原数组里的元素进行再散列后插入到新的数组里。为了高效，ConcurrentHashMap不会对整个容器进行扩容，而只对某个segment进行扩容。</p><h3 id="3-size操作"><a href="#3-size操作" class="headerlink" title="3 size操作"></a><strong>3 size操作</strong></h3><p>&emsp;&emsp;如果要统计整个ConcurrentHashMap里元素的大小，就必须统计所有Segment里元素的大小后求和。Segment里的全局变量count是一个volatile变量，那么在多线程场景下，是不是直接把所有Segment的count相加就可以得到整个ConcurrentHashMap大小了呢？不是的，虽然相加时可以获取每个Segment的count的最新值，但是可能累加前使用的count发生了变化，那么统计结果就不准了。所以，最安全的做法是在统计size的时候把所有Segment的put、remove和clean方法<br>全部锁住，但是这种做法显然非常低效。</p><p>&emsp;&emsp;因为在累加count操作过程中，之前累加过的count发生变化的几率非常小，所以 ConcurrentHashMap的做法是先尝试2次通过不锁住Segment的方式来统计各个Segment大小，如果统计的过程中，容器的count发生了变化，则再采用加锁的方式来统计所有Segment的大小。</p><p>&emsp;&emsp;那么ConcurrentHashMap是如何判断在统计的时候容器是否发生了变化呢？使用modCount变量，在put、remove和clean方法里操作元素前都会将变量modCount进行加1，那么在统计size前后比较modCount是否发生变化，从而得知容器的大小是否发生变化。</p><hr><p><em>参考博客和文章书籍等：</em></p><blockquote><p>《Java并发编程的艺术》</p></blockquote><p><em>因博客主等未标明不可引用，若部分内容涉及侵权请及时告知，我会尽快修改和删除相关内容</em></p>]]></content>
    
    <summary type="html">
    
      介绍Java中ConcurrentHashMap的实现原理与使用，包括：来源(相比HashMap以及HashTable的改善)，ConcurrentHashMap的结构，初始化过程，定位Segment，ConcurrentHashMap的相关操作等。
    
    </summary>
    
      <category term="技术文档" scheme="http://linyishui.top/categories/%E6%8A%80%E6%9C%AF%E6%96%87%E6%A1%A3/"/>
    
    
      <category term="java" scheme="http://linyishui.top/tags/java/"/>
    
      <category term="lock" scheme="http://linyishui.top/tags/lock/"/>
    
  </entry>
  
  <entry>
    <title>基于CAS+Pa4j+Spring Boot+Shiro实现单点登录</title>
    <link href="http://linyishui.top/2019082201.html"/>
    <id>http://linyishui.top/2019082201.html</id>
    <published>2019-08-22T06:38:20.000Z</published>
    <updated>2019-10-14T07:45:51.614Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="基于CAS-Pa4j-Spring-Boot-Shiro实现单点登录"><a href="#基于CAS-Pa4j-Spring-Boot-Shiro实现单点登录" class="headerlink" title="基于CAS+Pa4j+Spring Boot+Shiro实现单点登录"></a><strong>基于CAS+Pa4j+Spring Boot+Shiro实现单点登录</strong></h1><hr><h2 id="第一节-依赖"><a href="#第一节-依赖" class="headerlink" title="第一节 依赖"></a><strong>第一节 依赖</strong></h2><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!-- shiro --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.apache.shiro<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>shiro-core<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>1.4.0<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.apache.shiro<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>shiro-spring<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>1.4.0<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>com.auth0<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>java-jwt<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>3.2.0<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.apache.shiro<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>shiro-ehcache<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>1.4.0<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">&lt;!-- pac4j --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.pac4j<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>pac4j-cas<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>3.0.2<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.pac4j<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>pac4j-http<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>3.0.2<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.pac4j<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>pac4j-jwt<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>3.0.2<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>io.buji<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>buji-pac4j<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>4.0.0<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">exclusions</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">exclusion</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>shiro-web<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.apache.shiro<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">exclusion</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">exclusions</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure><hr><h2 id="第二节-配置部分"><a href="#第二节-配置部分" class="headerlink" title="第二节 配置部分"></a><strong>第二节 配置部分</strong></h2><p>&emsp;&emsp;Pac4jConfig对PAC4J相关部件进行配置</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Pac4jConfig</span> </span>&#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 工程路径</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Value</span>(<span class="string">"$&#123;cas.serverName&#125;"</span>)</span><br><span class="line">    <span class="keyword">private</span> String projectUrl;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 服务器cas服务路径</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Value</span>(<span class="string">"$&#123;cas.casServerUrlPrefix&#125;"</span>)</span><br><span class="line">    <span class="keyword">private</span> String casServerUrlPrefix;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * cas登陆路径</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Value</span>(<span class="string">"$&#123;cas.casServerLoginUrl&#125;"</span>)</span><br><span class="line">    <span class="keyword">private</span> String casServerLoginUrl;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 项目cas客户端名</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Value</span>(<span class="string">"$&#123;cas.client-name&#125;"</span>)</span><br><span class="line">    <span class="keyword">private</span> String clientName;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 登录地址</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Value</span>(<span class="string">"$&#123;cas.callbackUrl&#125;"</span>)</span><br><span class="line">    <span class="keyword">private</span> String callbackUrl;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> UserRepository userRepository;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> Environment environment;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * JWT Token 生成器，对CommonProfile生成然后每次携带token访问</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> JwtGenerator</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@SuppressWarnings</span>(<span class="string">"rawtypes"</span>)</span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> JwtGenerator <span class="title">jwtGenerator</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> JwtGenerator(<span class="keyword">new</span> SecretSignatureConfiguration(SecurityConsts.LOGIN_SALT.getValue()),</span><br><span class="line">                <span class="keyword">new</span> SecretEncryptionConfiguration(SecurityConsts.LOGIN_SALT.getValue()));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * JwtAuthenticator用于认证由JwtGenerator或其他方法生成的JWT令牌，即JWT校验器</span></span><br><span class="line"><span class="comment">     * 即目前设置的ParameterClient-jwtClient进行的校验器，是rest或者前后端分离的核心校验器</span></span><br><span class="line"><span class="comment">     * HTTP客户端验证凭证需要一个认证器。它是ProfileService的一个子组件，该组件验证凭证，同时也处理用户的创建、更新和移除操作。</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> JwtAuthenticator</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> JwtAuthenticator <span class="title">jwtAuthenticator</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        JwtAuthenticator jwtAuthenticator = <span class="keyword">new</span> JwtAuthenticator();</span><br><span class="line">        <span class="comment">//签名配置：SecretSignatureConfiguration，RSASignatureConfiguration，ECEncryptionConfiguration</span></span><br><span class="line">        jwtAuthenticator.addSignatureConfiguration(<span class="keyword">new</span> SecretSignatureConfiguration(SecurityConsts.LOGIN_SALT.getValue()));</span><br><span class="line">        <span class="comment">//加密配置：SecretEncryptionConfiguration，RSAEncryptionConfiguration，ECEncryptionConfiguration</span></span><br><span class="line">        jwtAuthenticator.addEncryptionConfiguration(<span class="keyword">new</span> SecretEncryptionConfiguration(SecurityConsts.LOGIN_SALT.getValue()));</span><br><span class="line">        <span class="keyword">return</span> jwtAuthenticator;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 请求cas服务端配置</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> CasConfiguration <span class="title">casConfig</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">final</span> CasConfiguration configuration = <span class="keyword">new</span> CasConfiguration();</span><br><span class="line">        <span class="comment">//CAS server登录地址</span></span><br><span class="line">        configuration.setLoginUrl(casServerLoginUrl);</span><br><span class="line">        <span class="comment">//CAS 版本，默认为 CAS30，我们使用的是 CAS20</span></span><br><span class="line">        configuration.setProtocol(CasProtocol.CAS20);</span><br><span class="line">        configuration.setAcceptAnyProxy(<span class="keyword">true</span>);</span><br><span class="line">        configuration.setPrefixUrl(casServerUrlPrefix);</span><br><span class="line">        configuration.setLogoutHandler(<span class="keyword">new</span> ShiroCasLogoutHandler());</span><br><span class="line">        <span class="keyword">return</span> configuration;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 配置多个Client，每个Client对应一种登陆协议，可以在Clients中配置所有协议，默认Client，以及如何区分回调哪个Client</span></span><br><span class="line"><span class="comment">     * client支持多种认证机制：OAuth、SAML、CAS、OpenID Connect、HTTP、OpenID、Google APP Engine、Kerberos(SPNEGO)</span></span><br><span class="line"><span class="comment">     * Authenticators：LDAP、SQL、JWT、MongoDB、CouchDB、IP address、REST API</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> casClient</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> Clients <span class="title">clients</span><span class="params">(CasClient casClient,</span></span></span><br><span class="line"><span class="function"><span class="params">                              CasRestFormClient casRestFormClient,</span></span></span><br><span class="line"><span class="function"><span class="params">                              ParameterClient jwtClient,</span></span></span><br><span class="line"><span class="function"><span class="params">                              FormClient formClient,</span></span></span><br><span class="line"><span class="function"><span class="params">                              IndirectBasicAuthClient ibaClient,</span></span></span><br><span class="line"><span class="function"><span class="params">                              DirectBasicAuthClient dbaClient)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//可以设置默认client</span></span><br><span class="line">        Clients clients = <span class="keyword">new</span> Clients();</span><br><span class="line">        <span class="comment">//支持的client全部设置进去</span></span><br><span class="line">        clients.setClients(casClient,casRestFormClient,jwtClient,formClient,ibaClient,dbaClient);</span><br><span class="line">        clients.setCallbackUrl(<span class="string">"https://localhost:8443/"</span>);</span><br><span class="line">        <span class="keyword">return</span> clients;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * cas客户端配置</span></span><br><span class="line"><span class="comment">     * 客户端表示身份验证机制（流）。它执行登录过程并返回一个用户概要文件。间接客户端用于UI身份验证，而直接客户端则用于web服务身份验证。</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> casConfig 配置通过客户端、授权器和匹配器定义安全配置</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> cas客户端</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> CasClient <span class="title">casClient</span><span class="params">(CasConfiguration casConfig)</span></span>&#123;</span><br><span class="line">        CasClient casClient = <span class="keyword">new</span> CasClient(casConfig);</span><br><span class="line">        <span class="comment">//客户端回调地址</span></span><br><span class="line">        casClient.setCallbackUrl(callbackUrl);</span><br><span class="line">        casClient.setName(clientName);</span><br><span class="line">        <span class="keyword">return</span> casClient;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 通过rest接口可以获取tgt,获取service ticket,甚至可以获取casProfile</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> CasRestFormClient <span class="title">casRestFormClient</span><span class="params">(CasConfiguration casConfig)</span></span>&#123;</span><br><span class="line">        CasRestFormClient casRestFormClient = <span class="keyword">new</span> CasRestFormClient();</span><br><span class="line">        casRestFormClient.setConfiguration(casConfig);</span><br><span class="line">        casRestFormClient.setName(<span class="string">"rest"</span>);</span><br><span class="line">        <span class="keyword">return</span> casRestFormClient;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> ParameterClient <span class="title">jwtClient</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="comment">// token校验器，可以用HeaderClient更安全</span></span><br><span class="line">        ParameterClient jwtClient = <span class="keyword">new</span> ParameterClient(<span class="string">"token"</span>, jwtAuthenticator());</span><br><span class="line">        jwtClient.setSupportGetRequest(<span class="keyword">true</span>);</span><br><span class="line">        jwtClient.setSupportPostRequest(<span class="keyword">true</span>);</span><br><span class="line">        jwtClient.setName(<span class="string">"jwt"</span>);</span><br><span class="line">        <span class="keyword">return</span> jwtClient;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> FormClient <span class="title">formClient</span><span class="params">()</span></span>&#123;</span><br><span class="line">        FormClient formClient = <span class="keyword">new</span> FormClient();</span><br><span class="line">        formClient.setLoginUrl(<span class="string">"https://localhost:8443/loginForm.html"</span>);</span><br><span class="line">        formClient.setName(<span class="string">"form"</span>);</span><br><span class="line">        formClient.setAuthenticator(<span class="keyword">new</span> UserIdPasswordAuthenticator(userRepository,environment));</span><br><span class="line"><span class="comment">//        formClient.setCallbackUrl("https://localhost:8443/callback?client_name=form");</span></span><br><span class="line">        <span class="keyword">return</span> formClient;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> IndirectBasicAuthClient <span class="title">ibaClient</span><span class="params">()</span></span>&#123;</span><br><span class="line">        IndirectBasicAuthClient ibaClient = <span class="keyword">new</span> IndirectBasicAuthClient();</span><br><span class="line">        ibaClient.setName(<span class="string">"iba"</span>);</span><br><span class="line">        ibaClient.setAuthenticator(<span class="keyword">new</span> UserIdPasswordAuthenticator(userRepository,environment));</span><br><span class="line">        <span class="keyword">return</span> ibaClient;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> DirectBasicAuthClient <span class="title">dbaClient</span><span class="params">()</span></span>&#123;</span><br><span class="line">        DirectBasicAuthClient dbaClient = <span class="keyword">new</span> DirectBasicAuthClient();</span><br><span class="line">        dbaClient.setName(<span class="string">"dba"</span>);</span><br><span class="line">        dbaClient.setAuthenticator(<span class="keyword">new</span> UserIdPasswordAuthenticator(userRepository,environment));</span><br><span class="line">        <span class="keyword">return</span> dbaClient;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     *  pac4j配置</span></span><br><span class="line"><span class="comment">     *    配置自定义的cas客户端和session存储</span></span><br><span class="line"><span class="comment">     *    配置通过客户端、授权器和匹配器定义安全配置</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> clients 客户端s</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> 配置</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Bean</span>(<span class="string">"authConfig"</span>)</span><br><span class="line">    <span class="function"><span class="keyword">public</span> Config <span class="title">config</span><span class="params">(Clients clients)</span> </span>&#123;</span><br><span class="line">        Config config = <span class="keyword">new</span> Config(clients);</span><br><span class="line"><span class="comment">//        config.setSessionStore(shiroSessionStore);</span></span><br><span class="line"><span class="comment">//        config.addAuthorizer();</span></span><br><span class="line"><span class="comment">//        config.addMatcher();</span></span><br><span class="line">        <span class="keyword">return</span> config;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>&emsp;&emsp;配置了6种认证客户端：casClient是cas客户端用于cas认证，casRestFormClient是REST风格的cas认证客户端，jwtClient是JWT认证客户端，formClient是表单认证客户端，ibaClient是间接认证客户端，dbaClient是直接认证客户端。</p><p>&emsp;&emsp;ShiroConfig</p><figure class="highlight arduino"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br></pre></td><td class="code"><pre><span class="line">@Configuration</span><br><span class="line"><span class="keyword">public</span> class ShiroConfig &#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 项目工程路径</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    @Value(<span class="string">"$&#123;cas.serverName&#125;"</span>)</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">String</span> serverName;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 项目cas服务路径</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    @Value(<span class="string">"$&#123;cas.casServerUrlPrefix&#125;"</span>)</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">String</span> casServerUrlPrefix;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 登陆</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    @Value(<span class="string">"$&#123;cas.casServerLoginUrl&#125;"</span>)</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">String</span> casServerLoginUrl;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 登出</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    @Value(<span class="string">"$&#123;cas.casServerLogoutUrl&#125;"</span>)</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">String</span> casServerLogoutUrl;</span><br><span class="line"></span><br><span class="line">    @Value(<span class="string">"$&#123;cas.client-name&#125;"</span>)</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">String</span> clientName;</span><br><span class="line">    @Value(<span class="string">"$&#123;cas.loginUrl&#125;"</span>)</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">String</span> loginUrl;</span><br><span class="line">    @Value(<span class="string">"$&#123;cas.logoutUrl&#125;"</span>)</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">String</span> logoutUrl;</span><br><span class="line">    @Value(<span class="string">"$&#123;cas.casFilterUrlPattern&#125;"</span>)</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">String</span> casFilterUrlPattern;</span><br><span class="line">    @Value(<span class="string">"$&#123;cookie-path&#125;"</span>)</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">String</span> cookiePath;</span><br><span class="line">    @Autowired</span><br><span class="line">    <span class="keyword">public</span> ShiroCacheManager shiroCacheManager;</span><br><span class="line"></span><br><span class="line">    @Bean</span><br><span class="line">    <span class="keyword">public</span> Pac4jSubjectFactory subjectFactory() &#123;</span><br><span class="line">        <span class="built_in">return</span> <span class="keyword">new</span> Pac4jSubjectFactory();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 注册自定义CasRealm</span></span><br><span class="line"><span class="comment">     * @return CasRealm</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    @Bean</span><br><span class="line">    <span class="keyword">public</span> CasRealm casRealm() &#123;</span><br><span class="line">        CasRealm realm = <span class="keyword">new</span> CasRealm();</span><br><span class="line">        realm.setName(<span class="string">"casRealm"</span>);</span><br><span class="line">        <span class="built_in">return</span> realm;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 注册和配置SecurityManager</span></span><br><span class="line"><span class="comment">     * 需要注意：</span></span><br><span class="line"><span class="comment">     *   1.多realm认证只会抛出AuthenticationException，因此如果要想在外部判断到底是在认证的哪一步发生的错误需要自己定义一些异常类型。</span></span><br><span class="line"><span class="comment">     *   2.shiro没有提供根据条件指定realm的功能，如果需要实现这样的功能只能通过继承与重写来实现。</span></span><br><span class="line"><span class="comment">     * @return SecurityManager</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    @Bean(<span class="string">"securityManager"</span>)</span><br><span class="line">    <span class="keyword">public</span> SecurityManager securityManager() &#123;</span><br><span class="line">        DefaultWebSecurityManager manager = <span class="keyword">new</span> DefaultWebSecurityManager();</span><br><span class="line"><span class="comment">//      // TODO-多个realms进配置在这里</span></span><br><span class="line"><span class="comment">//        ModularRealmAuthenticator modularRealmAuthenticator = new ModularRealmAuthenticator();</span></span><br><span class="line"><span class="comment">//        modularRealmAuthenticator.setAuthenticationStrategy(new FirstSuccessfulStrategy());</span></span><br><span class="line"><span class="comment">//        //Shiro提供了三种策略：AllSuccessFulStrategy, AtLeastOneSuccessFulAtrategy, FirstSuccessFulStrategy，默认使用AtLeastOneSuccessFulAtrategy，通常不需要特别配置</span></span><br><span class="line"><span class="comment">//        manager.setAuthenticator(modularRealmAuthenticator);</span></span><br><span class="line"><span class="comment">//        List&lt;Realm&gt; realms = new ArrayList&lt;&gt;();</span></span><br><span class="line"><span class="comment">//        realms.add(getAdminRealm(userService, roleService, authService, jedisUtils));</span></span><br><span class="line"><span class="comment">//        realms.add(getCasRealm(userService, roleService, authService,jedisUtils));</span></span><br><span class="line"><span class="comment">//        manager.setRealms(realms);</span></span><br><span class="line">        <span class="comment">// 设置自定义Realm</span></span><br><span class="line">        manager.setRealm(casRealm());</span><br><span class="line"><span class="comment">//        // 指定 SubjectFactory</span></span><br><span class="line"><span class="comment">//        manager.setSubjectFactory(subjectFactory());</span></span><br><span class="line"><span class="comment">//        // 记住密码管理</span></span><br><span class="line"><span class="comment">//        manager.setRememberMeManager(rememberMeManager());</span></span><br><span class="line"><span class="comment">//        // session管理</span></span><br><span class="line"><span class="comment">//        manager.setSessionManager(sessionManager());</span></span><br><span class="line">        <span class="comment">/*</span></span><br><span class="line"><span class="comment">         * 关闭shiro自带的session，详情见文档</span></span><br><span class="line"><span class="comment">         * http://shiro.apache.org/session-management.html#SessionManagement-StatelessApplications%28Sessionless%29</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        DefaultSubjectDAO subjectDAO = <span class="keyword">new</span> DefaultSubjectDAO();</span><br><span class="line">        DefaultSessionStorageEvaluator defaultSessionStorageEvaluator = <span class="keyword">new</span> DefaultSessionStorageEvaluator();</span><br><span class="line">        defaultSessionStorageEvaluator.setSessionStorageEnabled(false);</span><br><span class="line">        subjectDAO.setSessionStorageEvaluator(defaultSessionStorageEvaluator);</span><br><span class="line">        manager.setSubjectDAO(subjectDAO);</span><br><span class="line">        <span class="comment">// 设置缓存管理器</span></span><br><span class="line">        manager.setCacheManager(shiroCacheManager);</span><br><span class="line">        <span class="built_in">return</span> manager;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 注册shiroFilter，配置相关过滤器</span></span><br><span class="line"><span class="comment">     * @return ShiroFilterFactoryBean</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    @Bean(<span class="string">"shiroFilter"</span>)</span><br><span class="line">    <span class="keyword">public</span> ShiroFilterFactoryBean factory(SecurityManager securityManager,</span><br><span class="line">                                          Config <span class="built_in">config</span>) &#123;</span><br><span class="line">        ShiroFilterFactoryBean shiroFilterFactoryBean = <span class="keyword">new</span> ShiroFilterFactoryBean();</span><br><span class="line">        <span class="comment">// 必须设置 SecurityManager</span></span><br><span class="line">        shiroFilterFactoryBean.setSecurityManager(securityManager);</span><br><span class="line">        <span class="comment">// 如果不设置默认会自动寻找Web工程根目录下的"/login.jsp"页面</span></span><br><span class="line">        shiroFilterFactoryBean.setLoginUrl(casFilterUrlPattern);</span><br><span class="line">        <span class="comment">// 登录成功后要跳转的链接</span></span><br><span class="line">        shiroFilterFactoryBean.setSuccessUrl(<span class="string">"/hello"</span>);</span><br><span class="line">        <span class="comment">// 未授权界面;</span></span><br><span class="line">        shiroFilterFactoryBean.setUnauthorizedUrl(<span class="string">"/403"</span>);</span><br><span class="line">        <span class="comment">//自定义拦截器</span></span><br><span class="line">        Map&lt;<span class="keyword">String</span>, Filter&gt; filters = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line">        <span class="comment">//Cas资源认证拦截器</span></span><br><span class="line">        <span class="comment">//(或者不论使用什么原理去拦截的HTTP请求)根据客户端和授权配置，通过检查用户已认证和已授权来保护一个URL。</span></span><br><span class="line">        <span class="comment">// 如果用户没有被认证，它对直接客户端展示认证，对间接客户端启动登录进程。</span></span><br><span class="line">        SecurityFilter formSecurityFilter = <span class="keyword">new</span> SecurityFilter();</span><br><span class="line">        formSecurityFilter.setConfig(<span class="built_in">config</span>);</span><br><span class="line">        formSecurityFilter.setClients(<span class="string">"form"</span>);</span><br><span class="line">        filters.<span class="built_in">put</span>(<span class="string">"formSecurityFilter"</span>, formSecurityFilter);</span><br><span class="line">        SecurityFilter basicAuthSecurityFilter = <span class="keyword">new</span> SecurityFilter();</span><br><span class="line">        basicAuthSecurityFilter.setConfig(<span class="built_in">config</span>);</span><br><span class="line">        basicAuthSecurityFilter.setClients(<span class="string">"iba"</span>);</span><br><span class="line">        filters.<span class="built_in">put</span>(<span class="string">"basicAuthSecurityFilter"</span>, basicAuthSecurityFilter);</span><br><span class="line">        SecurityFilter casSecurityFilter = <span class="keyword">new</span> SecurityFilter();</span><br><span class="line">        casSecurityFilter.setConfig(<span class="built_in">config</span>);</span><br><span class="line">        casSecurityFilter.setClients(<span class="string">"cas"</span>);</span><br><span class="line">        filters.<span class="built_in">put</span>(<span class="string">"casSecurityFilter"</span>, casSecurityFilter);</span><br><span class="line">        SecurityFilter jwtSecurityFilter = <span class="keyword">new</span> SecurityFilter();</span><br><span class="line">        jwtSecurityFilter.setConfig(<span class="built_in">config</span>);</span><br><span class="line">        jwtSecurityFilter.setClients(<span class="string">"jwt"</span>);</span><br><span class="line">        filters.<span class="built_in">put</span>(<span class="string">"jwtSecurityFilter"</span>, jwtSecurityFilter);</span><br><span class="line">        SecurityFilter dbaSecurityFilter = <span class="keyword">new</span> SecurityFilter();</span><br><span class="line">        dbaSecurityFilter.setConfig(<span class="built_in">config</span>);</span><br><span class="line">        dbaSecurityFilter.setClients(<span class="string">"dba,jwt"</span>);</span><br><span class="line">        filters.<span class="built_in">put</span>(<span class="string">"dbaSecurityFilter"</span>, dbaSecurityFilter);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//Cas认证后回调拦截器</span></span><br><span class="line">        <span class="comment">//对间接客户端结束登录进程后的回调</span></span><br><span class="line">        io.buji.pac4j.filter.CallbackFilter callbackFilter = <span class="keyword">new</span> io.buji.pac4j.filter.CallbackFilter();</span><br><span class="line">        callbackFilter.setConfig(<span class="built_in">config</span>);</span><br><span class="line">        callbackFilter.setDefaultUrl(<span class="string">"https://localhost:8443/"</span>);</span><br><span class="line">        callbackFilter.setMultiProfile(true);</span><br><span class="line">        filters.<span class="built_in">put</span>(<span class="string">"callbackFilter"</span>, callbackFilter);</span><br><span class="line">        <span class="comment">//Cas注销拦截器</span></span><br><span class="line">        <span class="comment">//处理应用程序和/或身份服务器注销</span></span><br><span class="line">        LogoutFilter logoutFilter = <span class="keyword">new</span> LogoutFilter();</span><br><span class="line">        logoutFilter.setConfig(<span class="built_in">config</span>);</span><br><span class="line">        logoutFilter.setCentralLogout(true);</span><br><span class="line">        logoutFilter.setLocalLogout(true);</span><br><span class="line">        logoutFilter.setDefaultUrl(serverName + <span class="string">"callback?client_name"</span> + clientName);</span><br><span class="line">        filters.<span class="built_in">put</span>(<span class="string">"logoutFilter"</span>, logoutFilter);</span><br><span class="line">        shiroFilterFactoryBean.setFilters(filters);</span><br><span class="line">        loadShiroFilterChain(shiroFilterFactoryBean);</span><br><span class="line">        <span class="built_in">return</span> shiroFilterFactoryBean;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 加载shiroFilter权限控制规则（从数据库读取然后配置）</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * @param shiroFilterFactoryBean</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">void</span> loadShiroFilterChain(ShiroFilterFactoryBean shiroFilterFactoryBean) &#123;</span><br><span class="line">        <span class="comment">/*下面这些规则配置最好配置到配置文件中 */</span></span><br><span class="line">        Map&lt;<span class="keyword">String</span>, <span class="keyword">String</span>&gt; filterChainDefinitionMap = <span class="keyword">new</span> LinkedHashMap&lt;&gt;();</span><br><span class="line">        <span class="comment">// authc：该过滤器下的页面必须登录后才能访问，它是Shiro内置的一个拦截器org.apache.shiro.web.filter.authc.FormAuthenticationFilter</span></span><br><span class="line">        <span class="comment">// anon: 可以理解为不拦截</span></span><br><span class="line">        <span class="comment">// user: 登录了就不拦截</span></span><br><span class="line">        <span class="comment">// roles["admin"] 用户拥有admin角色</span></span><br><span class="line">        <span class="comment">// perms["permission1"] 用户拥有permission1权限</span></span><br><span class="line">        <span class="comment">// filter顺序按照定义顺序匹配，匹配到就验证，验证完毕结束。</span></span><br><span class="line">        <span class="comment">// url匹配通配符支持：? * **,分别表示匹配1个，匹配0-n个（不含子路径），匹配下级所有路径</span></span><br><span class="line">        filterChainDefinitionMap.<span class="built_in">put</span>(<span class="string">"/form/**"</span>, <span class="string">"formSecurityFilter"</span>);</span><br><span class="line">        filterChainDefinitionMap.<span class="built_in">put</span>(<span class="string">"/cas/**"</span>, <span class="string">"casSecurityFilter"</span>);</span><br><span class="line">        filterChainDefinitionMap.<span class="built_in">put</span>(<span class="string">"/iba/**"</span>, <span class="string">"basicAuthSecurityFilter"</span>);</span><br><span class="line">        filterChainDefinitionMap.<span class="built_in">put</span>(<span class="string">"/jwt/**"</span>, <span class="string">"noSessionCreation,jwtSecurityFilter"</span>);</span><br><span class="line">        filterChainDefinitionMap.<span class="built_in">put</span>(<span class="string">"/dba/**"</span>, <span class="string">"noSessionCreation,dbaSecurityFilter"</span>);</span><br><span class="line">        filterChainDefinitionMap.<span class="built_in">put</span>(<span class="string">"/callback"</span>, <span class="string">"callbackFilter"</span>);</span><br><span class="line">        filterChainDefinitionMap.<span class="built_in">put</span>(<span class="string">"/logout"</span>, <span class="string">"logoutFilter"</span>);</span><br><span class="line">        filterChainDefinitionMap.<span class="built_in">put</span>(<span class="string">"/"</span>, <span class="string">"anon"</span>);</span><br><span class="line">        filterChainDefinitionMap.<span class="built_in">put</span>(<span class="string">"/token"</span>, <span class="string">"formSecurityFilter"</span>);</span><br><span class="line">        filterChainDefinitionMap.<span class="built_in">put</span>(<span class="string">"/**"</span>, <span class="string">"noSessionCreation,jwtSecurityFilter"</span>);</span><br><span class="line">        shiroFilterFactoryBean.setFilterChainDefinitionMap(filterChainDefinitionMap);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    @Bean</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> LifecycleBeanPostProcessor lifecycleBeanPostProcessor() &#123;</span><br><span class="line">        <span class="built_in">return</span> <span class="keyword">new</span> LifecycleBeanPostProcessor();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 下面的代码是添加注解支持</span></span><br><span class="line"><span class="comment">     * 开启Shiro的注解(如@RequiresRoles,@RequiresPermissions),需借助SpringAOP扫描使用Shiro注解的类,并在必要时进行安全逻辑验证</span></span><br><span class="line"><span class="comment">     * 配置以下两个bean(DefaultAdvisorAutoProxyCreator(可选)和AuthorizationAttributeSourceAdvisor)即可实现此功能</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    @Bean</span><br><span class="line">    @DependsOn(<span class="string">"lifecycleBeanPostProcessor"</span>)</span><br><span class="line">    <span class="keyword">public</span> DefaultAdvisorAutoProxyCreator defaultAdvisorAutoProxyCreator() &#123;</span><br><span class="line">        DefaultAdvisorAutoProxyCreator defaultAdvisorAutoProxyCreator = <span class="keyword">new</span> DefaultAdvisorAutoProxyCreator();</span><br><span class="line">        <span class="comment">// 强制使用cglib，防止重复代理和可能引起代理出错的问题</span></span><br><span class="line">        <span class="comment">// https://zhuanlan.zhihu.com/p/29161098</span></span><br><span class="line">        defaultAdvisorAutoProxyCreator.setProxyTargetClass(true);</span><br><span class="line">        <span class="built_in">return</span> defaultAdvisorAutoProxyCreator;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Bean</span><br><span class="line">    <span class="keyword">public</span> AuthorizationAttributeSourceAdvisor authorizationAttributeSourceAdvisor(SecurityManager securityManager) &#123;</span><br><span class="line">        AuthorizationAttributeSourceAdvisor advisor = <span class="keyword">new</span> AuthorizationAttributeSourceAdvisor();</span><br><span class="line">        advisor.setSecurityManager(securityManager);</span><br><span class="line">        <span class="built_in">return</span> advisor;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>&emsp;&emsp;自定义Realm-CasRealm，继承Pac4jRealm，支持Pac4jToken，重写相关方法。</p><figure class="highlight aspectj"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Data</span></span><br><span class="line"><span class="meta">@Service</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">CasRealm</span> <span class="keyword">extends</span> <span class="title">Pac4jRealm</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> Logger logger = Logger.getLogger(CasRealm.class);</span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> UserService userService;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">CasRealm</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 返回一个唯一的Realm名字</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="function">String <span class="title">getName</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="function"><span class="keyword">return</span> <span class="keyword">super</span>.<span class="title">getName</span><span class="params">()</span></span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 判断此Realm是否支持此Token</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="function"><span class="keyword">boolean</span> <span class="title">supports</span><span class="params">(AuthenticationToken token)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> token <span class="keyword">instanceof</span> Pac4jToken;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 认证</span></span><br><span class="line"><span class="comment">     * Shiro登录认证(原理：用户提交 用户名和密码 --- shiro 封装令牌 ---- realm 通过用户名将密码查询返回 ---- shiro</span></span><br><span class="line"><span class="comment">     * 自动去比较查询出密码和用户输入密码是否一致---- 进行登陆控制 )</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> authenticationToken</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     * <span class="doctag">@throws</span> AuthenticationException</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">protected</span> <span class="function">AuthenticationInfo <span class="title">doGetAuthenticationInfo</span><span class="params">(AuthenticationToken authenticationToken)</span> <span class="keyword">throws</span> AuthenticationException </span>&#123;</span><br><span class="line">        logger.info(<span class="string">"Shiro开始登录认证"</span>);</span><br><span class="line">        Pac4jToken pac4jToken = (Pac4jToken) authenticationToken;</span><br><span class="line">        List&lt;CommonProfile&gt; profiles = pac4jToken.getProfiles();</span><br><span class="line">        Pac4jPrincipal principal = <span class="keyword">new</span> Pac4jPrincipal(profiles,getPrincipalNameAttribute());</span><br><span class="line">        System.out.println(<span class="string">"Pac4jPrincipal: "</span> + principal.toString());</span><br><span class="line">        CommonProfile profile = principal.getProfile();</span><br><span class="line">        System.out.println(<span class="string">"CommonProfile: "</span> + profile.toString());</span><br><span class="line">        <span class="comment">//获取用户信息</span></span><br><span class="line">        String userId = profile.getId();</span><br><span class="line">        System.out.println(<span class="string">"userId: "</span> + userId);</span><br><span class="line">        User user = userService.findByUserId(userId);</span><br><span class="line">        <span class="comment">// 账号不存在</span></span><br><span class="line">        <span class="keyword">if</span>(user == <span class="keyword">null</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 账号未启用</span></span><br><span class="line">        <span class="keyword">if</span> (user.getDelFlag()) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        List&lt;Role&gt; roles = userService.findAllRoleByUserId(user.getUserId());</span><br><span class="line">        List&lt;Auth&gt; auths = userService.findAllAuthByUserId(user.getUserId());</span><br><span class="line">        Set&lt;String&gt; roleSet = <span class="keyword">new</span> HashSet&lt;&gt;();</span><br><span class="line">        Set&lt;String&gt; authSet = <span class="keyword">new</span> HashSet&lt;&gt;();</span><br><span class="line">        <span class="keyword">for</span> (Role role : roles) &#123;</span><br><span class="line">            roleSet.add(role.getCode());</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (Auth auth : auths) &#123;</span><br><span class="line">            authSet.add(auth.getCode());</span><br><span class="line">        &#125;</span><br><span class="line">        profile.addAttribute(<span class="string">"userId"</span>,user.getUserId());</span><br><span class="line">        profile.addAttribute(<span class="string">"userName"</span>,user.getName());</span><br><span class="line">        profile.addAttribute(<span class="string">"orgId"</span>,user.getUnit().getUnitId());</span><br><span class="line">        profile.addAttribute(<span class="string">"currentTimeMillis"</span>,<span class="keyword">new</span> Timestamp(System.currentTimeMillis()).toString());</span><br><span class="line">        profile.setRoles(authSet);</span><br><span class="line">        profile.setPermissions(roleSet);</span><br><span class="line">        <span class="keyword">final</span> PrincipalCollection principalCollection = <span class="keyword">new</span> SimplePrincipalCollection(principal,getName());</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> SimpleAuthenticationInfo(principalCollection, pac4jToken.getCredentials());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 授权/验权（todo 后续有权限在此增加）</span></span><br><span class="line"><span class="comment">     *  单点登陆只需关心角色权限数据即可</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> principals</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">protected</span> <span class="function">AuthorizationInfo <span class="title">doGetAuthorizationInfo</span><span class="params">(PrincipalCollection principals)</span> </span>&#123;</span><br><span class="line">        logger.info(<span class="string">"doGetAuthorizationInfo()获取角色权限等信息进行校验"</span>);</span><br><span class="line">        SimpleAuthorizationInfo authorizationInfo = <span class="keyword">new</span> SimpleAuthorizationInfo();</span><br><span class="line">        Pac4jPrincipal principal = (Pac4jPrincipal)principals.getPrimaryPrincipal();</span><br><span class="line">        CommonProfile profile = principal.getProfile();</span><br><span class="line">        authorizationInfo.setRoles(profile.getRoles());</span><br><span class="line">        authorizationInfo.addStringPermissions(profile.getPermissions());</span><br><span class="line">        <span class="keyword">return</span> authorizationInfo;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>&emsp;&emsp;application.properties相关配置</p><figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="attribute">cookie-path</span>=/</span><br><span class="line"></span><br><span class="line"><span class="comment"># 项目工程路径</span></span><br><span class="line">cas.<span class="attribute">serverName</span>=https://127.0.0.1:8443/</span><br><span class="line"><span class="comment"># 项目cas服务路径</span></span><br><span class="line">cas.<span class="attribute">casServerUrlPrefix</span>=https://xxx.xxx.xxx.xxx/authserver/</span><br><span class="line"><span class="comment"># 项目cas登陆</span></span><br><span class="line">cas.<span class="attribute">casServerLoginUrl</span>=<span class="variable">$&#123;cas.casServerUrlPrefix&#125;</span>login</span><br><span class="line"><span class="comment"># 项目cas登出</span></span><br><span class="line">cas.<span class="attribute">casServerLogoutUrl</span>=<span class="variable">$&#123;cas.casServerUrlPrefix&#125;</span>logout</span><br><span class="line"><span class="comment"># 项目cas回调</span></span><br><span class="line">cas.<span class="attribute">casServerCallbackUrl</span>=<span class="variable">$&#123;cas.serverName&#125;</span>callback</span><br><span class="line"><span class="comment"># 项目cas客户端名</span></span><br><span class="line">cas.<span class="attribute">client-name</span>=cas</span><br><span class="line"><span class="comment"># casFilter UrlPattern</span></span><br><span class="line">cas.<span class="attribute">casFilterUrlPattern</span>=cas</span><br><span class="line"><span class="comment"># 登录地址</span></span><br><span class="line">cas.<span class="attribute">loginUrl</span>=<span class="variable">$&#123;cas.casServerLoginUrl&#125;</span>?service=$&#123;cas.serverName&#125;<span class="variable">$&#123;cas.casFilterUrlPattern&#125;</span></span><br><span class="line"><span class="comment"># 登出地址（casserver启用service跳转功能，需在webapps\cas\WEB-INF\cas.properties文件中启用cas.logout.followServiceRedirects=true）</span></span><br><span class="line">cas.<span class="attribute">logoutUrl</span>=<span class="variable">$&#123;cas.casServerLogoutUrl&#125;</span>?service=$&#123;cas.serverName&#125;<span class="variable">$&#123;cas.casFilterUrlPattern&#125;</span></span><br><span class="line"><span class="comment"># 登录地址</span></span><br><span class="line">cas.<span class="attribute">callbackUrl</span>=<span class="variable">$&#123;cas.serverName&#125;</span>callback?client_name=$&#123;cas.client-name&#125;</span><br><span class="line">cas.<span class="attribute">salt</span>=12345678901234567890123456789012</span><br></pre></td></tr></table></figure><hr><h2 id="第三节-测试部分"><a href="#第三节-测试部分" class="headerlink" title="第三节 测试部分"></a><strong>第三节 测试部分</strong></h2><p>&emsp;&emsp;MainController</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@RestController</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MainController</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> JwtGenerator jwtGenerator;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@RequestMapping(<span class="meta-string">"/"</span>)</span></span><br><span class="line">    <span class="keyword">public</span> String index()&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">"https://localhost:8443/form/index &lt;/br&gt;"</span> +</span><br><span class="line">                <span class="string">"    FormClient:               Protected url by form authentication 需要(use login = pwd) &lt;/br&gt;"</span> +</span><br><span class="line">                <span class="string">"&lt;/br&gt;"</span> +</span><br><span class="line">                <span class="string">"https://localhost:8443/iba/index &lt;/br&gt;"</span> +</span><br><span class="line">                <span class="string">"    IndirectBasicAuthClient:  Protected url by indirect basic auth 需要(use login = pwd) &lt;/br&gt;"</span>+</span><br><span class="line">                <span class="string">"&lt;/br&gt;"</span> +</span><br><span class="line">                <span class="string">"https://localhost:8443/cas/index &lt;/br&gt;"</span> +</span><br><span class="line">                <span class="string">"    CasClient:                Protected url by CAS 需要(use login = pwd) &lt;/br&gt;"</span> +</span><br><span class="line">                <span class="string">"&lt;/br&gt;"</span> +</span><br><span class="line">                <span class="string">"https://localhost:8443/token &lt;/br&gt;"</span> +</span><br><span class="line">                <span class="string">"    Generate a JWT token - after being authenticated &lt;/br&gt;"</span> +</span><br><span class="line">                <span class="string">"&lt;/br&gt;"</span> +</span><br><span class="line">                <span class="string">"https://localhost:8443/dba/index &lt;/br&gt;"</span> +</span><br><span class="line">                <span class="string">"    DirectBasicAuthClient:    Protected url by DirectBasicAuthClient  &lt;/br&gt;"</span> +</span><br><span class="line">                <span class="string">"                              需要POST the Authorization header with value: (Basic amxlbGV1OmpsZWxldQ==) &lt;/br&gt;"</span> +</span><br><span class="line">                <span class="string">"                              then by (/dba/index) ParameterClient: /dba/index (with request parameter: token=jwt_generated_token &lt;/br&gt;"</span> +</span><br><span class="line">                <span class="string">"&lt;/br&gt;"</span> +</span><br><span class="line">                <span class="string">"https://localhost:8443/jwt/index &lt;/br&gt;"</span> +</span><br><span class="line">                <span class="string">"                              ParameterClient:  Protected url by ParameterClient 需要(with request parameter: token=jwt_generated_token) &lt;/br&gt;"</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@RequestMapping(<span class="meta-string">"/token"</span>)</span></span><br><span class="line">    <span class="keyword">public</span> String token()&#123;</span><br><span class="line">        Subject subject = SecurityUtils.getSubject();</span><br><span class="line">        String token = <span class="string">"null"</span>;</span><br><span class="line">        <span class="keyword">final</span> PrincipalCollection collection = subject.getPrincipals();</span><br><span class="line">        <span class="keyword">if</span> (collection != <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="keyword">final</span> Pac4jPrincipal principal = collection.oneByType(Pac4jPrincipal.<span class="keyword">class</span>);</span><br><span class="line">            <span class="keyword">if</span> (principal != <span class="literal">null</span>) &#123;</span><br><span class="line">                CommonProfile profile = principal.getProfile();</span><br><span class="line">                token = jwtGenerator.generate(profile);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> token;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>&emsp;&emsp;FormController</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@RestController</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">FormController</span> </span>&#123;</span><br><span class="line">    <span class="meta">@RequestMapping(<span class="meta-string">"/form/index"</span>)</span></span><br><span class="line">    <span class="keyword">public</span> String index() &#123;</span><br><span class="line">        Subject subject = SecurityUtils.getSubject();</span><br><span class="line">        <span class="keyword">if</span>(subject == <span class="literal">null</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="string">"subject is null"</span>;</span><br><span class="line">        &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">            System.<span class="keyword">out</span>.println(<span class="string">"isAuthenticated ? "</span> + subject.isAuthenticated());</span><br><span class="line">            PrincipalCollection collection = SecurityUtils.getSubject().getPrincipals();</span><br><span class="line">            <span class="keyword">final</span> Pac4jPrincipal principal = collection.oneByType(Pac4jPrincipal.<span class="keyword">class</span>);</span><br><span class="line">            <span class="keyword">if</span> (principal == <span class="literal">null</span>) &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="string">"user is null"</span>;</span><br><span class="line">            &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="keyword">return</span> principal.toString();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>&emsp;&emsp;JwtController</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@RestController</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">JwtController</span> </span>&#123;</span><br><span class="line">    <span class="meta">@RequestMapping(<span class="meta-string">"/jwt/index"</span>)</span></span><br><span class="line">    <span class="keyword">public</span> Object index() &#123;</span><br><span class="line">        Subject subject = SecurityUtils.getSubject();</span><br><span class="line">        <span class="keyword">if</span>(subject == <span class="literal">null</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="string">"subject is null"</span>;</span><br><span class="line">        &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">            System.<span class="keyword">out</span>.println(<span class="string">"isAuthenticated ? "</span> + subject.isAuthenticated());</span><br><span class="line">            PrincipalCollection collection = SecurityUtils.getSubject().getPrincipals();</span><br><span class="line">            <span class="keyword">final</span> Pac4jPrincipal principal = collection.oneByType(Pac4jPrincipal.<span class="keyword">class</span>);</span><br><span class="line">            <span class="keyword">if</span> (principal == <span class="literal">null</span>) &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="string">"user is null"</span>;</span><br><span class="line">            &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="keyword">return</span> principal.toString();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>&emsp;&emsp;其他类似：/iba/index，/dba/index，/cas/index</p><p>&emsp;&emsp;分别访问主页面：<a href="https://localhost:8443/" target="_blank" rel="noopener">https://localhost:8443/</a></p><p>&emsp;&emsp;表单提交账号密码：<a href="https://localhost:8443/callback?client_name=form，携带username&amp;password，表单登录获得JSESSIONID。" target="_blank" rel="noopener">https://localhost:8443/callback?client_name=form，携带username&amp;password，表单登录获得JSESSIONID。</a></p><p>&emsp;&emsp;表单客户端访问：<a href="https://localhost:8443/form/index，返回用户信息Pac4jPrincipal。" target="_blank" rel="noopener">https://localhost:8443/form/index，返回用户信息Pac4jPrincipal。</a></p><p>&emsp;&emsp;获得令牌：<a href="https://localhost:8443/token，返回token。" target="_blank" rel="noopener">https://localhost:8443/token，返回token。</a></p><p>&emsp;&emsp;JWT客户端访问：<a href="https://localhost:8443/jwt/index?client_name=jwt&amp;token=eyJjdH...，返回用户信息Pac4jPrincipal。" target="_blank" rel="noopener">https://localhost:8443/jwt/index?client_name=jwt&amp;token=eyJjdH...，返回用户信息Pac4jPrincipal。</a></p><p>（未完待续…）</p><hr><p><em>参考博客和文章书籍等：</em></p><blockquote><p><a href="http://www.pac4j.org/docs/index.html" title="Title" target="_blank" rel="noopener">pac4j官网文档</a></p></blockquote><blockquote><p><a href="https://github.com/pac4j/pac4j/" title="Title" target="_blank" rel="noopener">GitHub pac4j/pac4j</a></p></blockquote><blockquote><p><a href="https://github.com.cnpmjs.org/bujiio/buji-pac4j" title="Title" target="_blank" rel="noopener">GitHub bujiio/buji-pac4j</a></p></blockquote><blockquote><p><a href="https://github.com/pac4j/buji-pac4j-demo" title="Title" target="_blank" rel="noopener">GitHub pac4j/buji-pac4j-demo</a></p></blockquote><p><em>因博客主等未标明不可引用，若部分内容涉及侵权请及时告知，我会尽快修改和删除相关内容</em></p>]]></content>
    
    <summary type="html">
    
      整理了一个基于CAS+Pa4j+Spring Boot+Shiro实现单点登录的项目DEMO的部分代码。
    
    </summary>
    
      <category term="技术文档" scheme="http://linyishui.top/categories/%E6%8A%80%E6%9C%AF%E6%96%87%E6%A1%A3/"/>
    
    
      <category term="java" scheme="http://linyishui.top/tags/java/"/>
    
      <category term="spring boot" scheme="http://linyishui.top/tags/spring-boot/"/>
    
      <category term="security" scheme="http://linyishui.top/tags/security/"/>
    
      <category term="shiro" scheme="http://linyishui.top/tags/shiro/"/>
    
      <category term="pac4j" scheme="http://linyishui.top/tags/pac4j/"/>
    
      <category term="cas" scheme="http://linyishui.top/tags/cas/"/>
    
  </entry>
  
  <entry>
    <title>Condition接口及实现原理</title>
    <link href="http://linyishui.top/2019081601.html"/>
    <id>http://linyishui.top/2019081601.html</id>
    <published>2019-08-16T07:13:38.000Z</published>
    <updated>2019-09-19T07:53:42.247Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="Condition接口"><a href="#Condition接口" class="headerlink" title="Condition接口"></a><strong>Condition接口</strong></h1><p>&emsp;任意一个Java对象，都拥有一组监视器方法（定义在java.lang.Object上），主要包括wait()、wait(long timeout)、notify()以及notifyAll()方法，这些方法与synchronized同步关键字配合，可以实现等待/通知模式。Condition接口也提供了类似Object的监视器方法，与Lock配合可以实现等待/通知模式，但是这两者在使用方式以及功能特性上还是有差别的。</p><p>&emsp;通过对比Object的监视器方法和Condition接口，可以更详细地了解Condition的特性，对比项与结果如下表所示。</p><p><img src="https://pic-1258215793.cos.ap-shanghai.myqcloud.com/content/20190316/201903160120.jpg" alt="Object的监视器方法与Condition接口的对比"></p><hr><h2 id="Condition接口与示例"><a href="#Condition接口与示例" class="headerlink" title="Condition接口与示例"></a><strong>Condition接口与示例</strong></h2><p>&emsp;Condition定义了等待/通知两种类型的方法，当前线程调用这些方法时，需要提前获取到Condition对象关联的锁。Condition对象是由Lock对象（调用Lock对象的newCondition()方法）创建出来的，换句话说，Condition是依赖Lock对象的。</p><p>&emsp;Condition的使用方式比较简单，需要注意在调用方法前获取锁，使用方式如下列代码所示。</p><figure class="highlight cs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">Lock <span class="keyword">lock</span> = <span class="keyword">new</span> ReentrantLock();</span><br><span class="line">Condition condition = <span class="keyword">lock</span>.newCondition();</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">conditionWait</span>(<span class="params"></span>) throws InterruptedException </span>&#123;</span><br><span class="line">    <span class="keyword">lock</span>.<span class="keyword">lock</span>();</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        condition.<span class="keyword">await</span>();</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        <span class="keyword">lock</span>.unlock();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">conditionSignal</span>(<span class="params"></span>) throws InterruptedException </span>&#123;</span><br><span class="line">    <span class="keyword">lock</span>.<span class="keyword">lock</span>();</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        condition.signal();</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        <span class="keyword">lock</span>.unlock();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>&emsp;如示例所示，一般都会将Condition对象作为成员变量。当调用await()方法后，当前线程会释放锁并在此等待，而其他线程调用Condition对象的signal()方法，通知当前线程后，当前线程才从await()方法返回，并且在返回前已经获取了锁。</p><p>&emsp;Condition定义的（部分）方法以及描述如下表所示。</p><p><img src="https://pic-1258215793.cos.ap-shanghai.myqcloud.com/content/20190316/201903160121.jpg" alt="Condition的（部分）方法以及描述"></p><p>&emsp;获取一个Condition必须通过Lock的newCondition()方法。下面通过一个有界队列的示例来深入了解Condition的使用方式。有界队列是一种特殊的队列，当队列为空时，队列的获取操作将会阻塞获取线程，直到队列中有新增元素，当队列已满时，队列的插入操作将会阻塞插入线程，直到队列出现“空位”，如下列代码所示。</p><figure class="highlight sqf"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line">public class BoundedQueue&lt;T&gt; &#123;</span><br><span class="line">    <span class="built_in">private</span> Object[] <span class="built_in">items</span>;</span><br><span class="line">    <span class="comment">// 添加的下标，删除的下标和数组当前数量</span></span><br><span class="line">    <span class="built_in">private</span> int addIndex, removeIndex, <span class="built_in">count</span>;</span><br><span class="line">    <span class="built_in">private</span> <span class="built_in">Lock</span> <span class="built_in">lock</span> = new ReentrantLock();</span><br><span class="line">    <span class="built_in">private</span> Condition notEmpty = <span class="built_in">lock</span>.newCondition();</span><br><span class="line">    <span class="built_in">private</span> Condition notFull = <span class="built_in">lock</span>.newCondition();</span><br><span class="line">    public BoundedQueue(int <span class="built_in">size</span>) &#123;</span><br><span class="line">        <span class="built_in">items</span> = new Object[<span class="built_in">size</span>];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 添加一个元素，如果数组满，则添加线程进入等待状态，直到有"空位"</span></span><br><span class="line">    public void add(T t) throws InterruptedException &#123;</span><br><span class="line">        <span class="built_in">lock</span>.<span class="built_in">lock</span>();</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">while</span> (<span class="built_in">count</span> == <span class="built_in">items</span>.length)</span><br><span class="line">                notFull.await();</span><br><span class="line">            <span class="built_in">items</span>[addIndex] = t;</span><br><span class="line">            <span class="keyword">if</span> (++addIndex == <span class="built_in">items</span>.length)</span><br><span class="line">                addIndex = <span class="number">0</span>;</span><br><span class="line">            ++<span class="built_in">count</span>;</span><br><span class="line">            notEmpty.signal();</span><br><span class="line">        &#125; finally &#123;</span><br><span class="line">            <span class="built_in">lock</span>.unlock();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 由头部删除一个元素，如果数组空，则删除线程进入等待状态，直到有新添加元素</span></span><br><span class="line">    @SuppressWarnings(<span class="string">"unchecked"</span>)</span><br><span class="line">    public T remove() throws InterruptedException &#123;</span><br><span class="line">        <span class="built_in">lock</span>.<span class="built_in">lock</span>();</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">while</span> (<span class="built_in">count</span> == <span class="number">0</span>)</span><br><span class="line">                notEmpty.await();</span><br><span class="line">            Object x = <span class="built_in">items</span>[removeIndex];</span><br><span class="line">            <span class="keyword">if</span> (++removeIndex == <span class="built_in">items</span>.length)</span><br><span class="line">                removeIndex = <span class="number">0</span>;</span><br><span class="line">            --<span class="built_in">count</span>;</span><br><span class="line">            notFull.signal();</span><br><span class="line">            return (T) x;</span><br><span class="line">        &#125; finally &#123;</span><br><span class="line">            <span class="built_in">lock</span>.unlock();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>&emsp;上述示例中，BoundedQueue通过add(T t)方法添加一个元素，通过remove()方法移出一个元素。以添加方法为例。</p><p>&emsp;首先需要获得锁，目的是确保数组修改的可见性和排他性。当数组数量等于数组长度时，表示数组已满，则调用notFull.await()，当前线程随之释放锁并进入等待状态。如果数组数量不等于数组长度，表示数组未满，则添加元素到数组中，同时通知等待在notEmpty上的线程，数组中已经有新元素可以获取。</p><p>&emsp;在添加和删除方法中使用while循环而非if判断，目的是防止过早或意外的通知，只有条件符合才能够退出循环。回想之前提到的等待/通知的经典范式，二者是非常类似的。</p><hr><h2 id="Condition的实现分析"><a href="#Condition的实现分析" class="headerlink" title="Condition的实现分析"></a><strong>Condition的实现分析</strong></h2><p>&emsp;ConditionObject是同步器AbstractQueuedSynchronizer的内部类，因为Condition的操作需要获取相关联的锁，所以作为同步器的内部类也较为合理。每个Condition对象都包含着一个队列（以下称为等待队列），该队列是Condition对象实现等待/通知功能的关键。</p><p>&emsp;下面将分析Condition的实现，主要包括：等待队列、等待和通知，下面提到的Condition如果不加说明均指的是ConditionObject。</p><h3 id="1-等待队列"><a href="#1-等待队列" class="headerlink" title="1.等待队列"></a><strong>1.等待队列</strong></h3><p>&emsp;等待队列是一个FIFO的队列，在队列中的每个节点都包含了一个线程引用，该线程就是在Condition对象上等待的线程，如果一个线程调用了Condition.await()方法，那么该线程将会释放锁、构造成节点加入等待队列并进入等待状态。事实上，节点的定义复用了同步器中节点的定义，也就是说，同步队列和等待队列中节点类型都是同步器的静态内部类AbstractQueuedSynchronizer.Node。</p><p>&emsp;一个Condition包含一个等待队列，Condition拥有首节点（firstWaiter）和尾节点（lastWaiter）。当前线程调用Condition.await()方法，将会以当前线程构造节点，并将节点从尾部加入等待队列，等待队列的基本结构如下图所示。</p><p><img src="https://pic-1258215793.cos.ap-shanghai.myqcloud.com/content/20190316/201903160122.jpg" alt="等待队列的基本结构"></p><p>&emsp;如图所示，Condition拥有首尾节点的引用，而新增节点只需要将原有的尾节点nextWaiter指向它，并且更新尾节点即可。上述节点引用更新的过程并没有使用CAS保证，原因在于调用await()方法的线程必定是获取了锁的线程，也就是说该过程是由锁来保证线程安全的。</p><p>&emsp;在Object的监视器模型上，一个对象拥有一个同步队列和等待队列，而并发包中的Lock（更确切地说是同步器）拥有一个同步队列和多个等待队列，其对应关系如下图所示。</p><p><img src="https://pic-1258215793.cos.ap-shanghai.myqcloud.com/content/20190316/201903160123.jpg" alt="同步队列与等待队列"></p><p>&emsp;如图所示，Condition的实现是同步器的内部类，因此每个Condition实例都能够访问同步器提供的方法，相当于每个Condition都拥有所属同步器的引用。</p><h3 id="2-等待"><a href="#2-等待" class="headerlink" title="2.等待"></a><strong>2.等待</strong></h3><p>&emsp;调用Condition的await()方法（或者以await开头的方法），会使当前线程进入等待队列并释放锁，同时线程状态变为等待状态。当从await()方法返回时，当前线程一定获取了Condition相关联的锁。</p><p>&emsp;如果从队列（同步队列和等待队列）的角度看await()方法，当调用await()方法时，相当于同步队列的首节点（获取了锁的节点）移动到Condition的等待队列中。</p><p>&emsp;Condition的await()方法，如下列代码所示。</p><figure class="highlight crmsh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">public final void await() throws InterruptedException &#123;</span><br><span class="line">    if (Thread.interrupted())</span><br><span class="line">    throw new InterruptedException();</span><br><span class="line">    // 当前线程加入等待队列</span><br><span class="line">    <span class="keyword">Node</span> <span class="title">node</span> = addConditionWaiter();</span><br><span class="line">    // 释放同步状态，也就是释放锁</span><br><span class="line">    int savedState = fullyRelease(<span class="keyword">node</span><span class="title">);</span></span><br><span class="line"><span class="title">    int</span> interruptMode = <span class="number">0</span>;</span><br><span class="line">    while (!isOnSyncQueue(<span class="keyword">node</span><span class="title">)) &#123;</span></span><br><span class="line"><span class="title">        LockSupport</span>.park(this);</span><br><span class="line">        if ((interruptMode = checkInterruptWhileWaiting(<span class="keyword">node</span><span class="title">)) != 0</span>)</span><br><span class="line">            break;</span><br><span class="line">    &#125;    </span><br><span class="line">    if (acquireQueued(<span class="keyword">node</span><span class="title">, savedState</span>) &amp;&amp; interruptMode != THROW_IE)</span><br><span class="line">        interruptMode = REINTERRUPT;</span><br><span class="line">    if (<span class="keyword">node</span>.<span class="title">nextWaiter</span> != null)</span><br><span class="line">        unlinkCancelledWaiters();</span><br><span class="line">    if (interruptMode != <span class="number">0</span>)</span><br><span class="line">        reportInterruptAfterWait(interruptMode);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>&emsp;调用该方法的线程成功获取了锁的线程，也就是同步队列中的首节点，该方法会将当前线程构造成节点并加入等待队列中，然后释放同步状态，唤醒同步队列中的后继节点，然后当前线程会进入等待状态。</p><p>&emsp;当等待队列中的节点被唤醒，则唤醒节点的线程开始尝试获取同步状态。如果不是通过其他线程调用Condition.signal()方法唤醒，而是对等待线程进行中断，则会抛出InterruptedException。</p><p>&emsp;如果从队列的角度去看，当前线程加入Condition的等待队列，该过程如下图示。</p><p><img src="https://pic-1258215793.cos.ap-shanghai.myqcloud.com/content/20190316/201903160124.jpg" alt="当前线程加入等待队列"></p><p>&emsp;如图所示，同步队列的首节点并不会直接加入等待队列，而是通过addConditionWaiter()方法把当前线程构造成一个新的节点并将其加入等待队列中。</p><h3 id="3-通知"><a href="#3-通知" class="headerlink" title="3.通知"></a><strong>3.通知</strong></h3><p>&emsp;调用Condition的signal()方法，将会唤醒在等待队列中等待时间最长的节点（首节点），在唤醒节点之前，会将节点移到同步队列中。</p><p>&emsp;Condition的signal()方法，如下列代码所示。</p><figure class="highlight aspectj"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="function"><span class="keyword">void</span> <span class="title">signal</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (!isHeldExclusively())</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> IllegalMonitorStateException();</span><br><span class="line">    Node first = firstWaiter;</span><br><span class="line">    <span class="keyword">if</span> (first != <span class="keyword">null</span>)</span><br><span class="line">        doSignal(first);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>&emsp;调用该方法的前置条件是当前线程必须获取了锁，可以看到signal()方法进行了isHeldExclusively()检查，也就是当前线程必须是获取了锁的线程。接着获取等待队列的首节点，将其移动到同步队列并使用LockSupport唤醒节点中的线程。</p><p>&emsp;节点从等待队列移动到同步队列的过程如下图所示。</p><p><img src="https://pic-1258215793.cos.ap-shanghai.myqcloud.com/content/20190316/201903160125.jpg" alt="节点从等待队列移动到同步队列"></p><p>&emsp;通过调用同步器的enq(Node node)方法，等待队列中的头节点线程安全地移动到同步队列。当节点移动到同步队列后，当前线程再使用LockSupport唤醒该节点的线程。</p><p>&emsp;被唤醒后的线程，将从await()方法中的while循环中退出（isOnSyncQueue(Node node)方法返回true，节点已经在同步队列中），进而调用同步器的acquireQueued()方法加入到获取同步状态的竞争中。</p><p>&emsp;成功获取同步状态（或者说锁）之后，被唤醒的线程将从先前调用的await()方法返回，此时该线程已经成功地获取了锁。</p><p>&emsp;Condition的signalAll()方法，相当于对等待队列中的每个节点均执行一次signal()方法，效果就是将等待队列中所有节点全部移动到同步队列中，并唤醒每个节点的线程。</p><hr><p><em>参考博客和文章书籍等：</em></p><blockquote><p>《Java并发编程的艺术》</p></blockquote><p><em>因博客主等未标明不可引用，若部分内容涉及侵权请及时告知，我会尽快修改和删除相关内容</em></p>]]></content>
    
    <summary type="html">
    
      介绍Java中的并发包中Condition接口相关内容：Condition接口与示例，Condition的实现分析：1.等待队列，2.等待，3.通知。
    
    </summary>
    
      <category term="技术文档" scheme="http://linyishui.top/categories/%E6%8A%80%E6%9C%AF%E6%96%87%E6%A1%A3/"/>
    
    
      <category term="java" scheme="http://linyishui.top/tags/java/"/>
    
      <category term="lock" scheme="http://linyishui.top/tags/lock/"/>
    
  </entry>
  
</feed>
