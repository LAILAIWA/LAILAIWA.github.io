<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>沂水博客</title>
  
  <subtitle>编程和心历记录</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://linyishui.top/"/>
  <updated>2019-09-20T08:10:34.100Z</updated>
  <id>http://linyishui.top/</id>
  
  <author>
    <name>沂水</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>2019081701</title>
    <link href="http://linyishui.top/2019081701.html"/>
    <id>http://linyishui.top/2019081701.html</id>
    <published>2019-09-20T08:10:34.000Z</published>
    <updated>2019-09-20T08:10:34.100Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script>]]></content>
    
    <summary type="html">
    
      
      
        &lt;link rel=&quot;stylesheet&quot; class=&quot;aplayer-secondary-style-marker&quot; href=&quot;\assets\css\APlayer.min.css&quot;&gt;&lt;script src=&quot;\assets\js\APlayer.min.js&quot; cla
      
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>Fork/Join框架</title>
    <link href="http://linyishui.top/2019082601.html"/>
    <id>http://linyishui.top/2019082601.html</id>
    <published>2019-08-26T08:57:17.000Z</published>
    <updated>2019-10-11T01:32:39.102Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="Fork-Join框架"><a href="#Fork-Join框架" class="headerlink" title="Fork/Join框架"></a><strong>Fork/Join框架</strong></h1><p>&emsp;&emsp;本节将会介绍Fork/Join框架的基本原理、算法、设计方式、应用与实现等。</p><h2 id="第一节-什么是Fork-Join框架"><a href="#第一节-什么是Fork-Join框架" class="headerlink" title="第一节 什么是Fork/Join框架"></a><strong>第一节 什么是Fork/Join框架</strong></h2><p>&emsp;&emsp;Fork/Join框架是Java 7提供的一个用于并行执行任务的框架，是一个把大任务分割成若干个小任务，最终汇总每个小任务结果后得到大任务结果的框架。</p><p>&emsp;&emsp;我们再通过Fork和Join这两个单词来理解一下Fork/Join框架。Fork就是把一个大任务切分 为若干子任务并行的执行，Join就是合并这些子任务的执行结果，最后得到这个大任务的结 果。比如计算1+2+…+10000，可以分割成10个子任务，每个子任务分别对1000个数进行求和， 最终汇总这10个子任务的结果。Fork/Join的运行流程如图6-6所示。</p><p><img src="https://pic-1258215793.cos.ap-shanghai.myqcloud.com/content/20190701/201907010107.png" alt="Fork Join的运行流程图"></p><h2 id="第二节-工作窃取算法"><a href="#第二节-工作窃取算法" class="headerlink" title="第二节 工作窃取算法"></a><strong>第二节 工作窃取算法</strong></h2><p>　<br>&emsp;&emsp;工作窃取（work-stealing）算法是指某个线程从其他队列里窃取任务来执行。那么，为什么需要使用工作窃取算法呢？假如我们需要做一个比较大的任务，可以把这个任务分割为若干互不依赖的子任务，为了减少线程间的竞争，把这些子任务分别放到不同的队列里，并为每个 队列创建一个单独的线程来执行队列里的任务，线程和队列一一对应。比如A线程负责处理A队列里的任务。但是，有的线程会先把自己队列里的任务干完，而其他线程对应的队列里还有任务等待处理。干完活的线程与其等着，不如去帮其他线程干活，于是它就去其他线程的队列里窃取一个任务来执行。而在这时它们会访问同一个队列，所以为了减少窃取任务线程和被窃取任务线程之间的竞争，通常会使用双端队列，被窃取任务线程永远从双端队列的头部拿任务执行，而窃取任务的线程永远从双端队列的尾部拿任务执行。</p><p>&emsp;&emsp;工作窃取的运行流程如图6-7所示。</p><p><img src="https://pic-1258215793.cos.ap-shanghai.myqcloud.com/content/20190701/201907010108.png" alt="工作窃取运行流程图"></p><p>&emsp;&emsp;工作窃取算法的优点：充分利用线程进行并行计算，减少了线程间的竞争。</p><p>&emsp;&emsp;工作窃取算法的缺点：在某些情况下还是存在竞争，比如双端队列里只有一个任务时。并且该算法会消耗了更多的系统资源，比如创建多个线程和多个双端队列。</p><h2 id="第三节-Fork-Join框架的设计"><a href="#第三节-Fork-Join框架的设计" class="headerlink" title="第三节 Fork/Join框架的设计"></a><strong>第三节 Fork/Join框架的设计</strong></h2><p>&emsp;&emsp;我们已经很清楚Fork/Join框架的需求了，那么可以思考一下，如果让我们来设计一个 Fork/Join框架，该如何设计？这个思考有助于你理解Fork/Join框架的设计。</p><ul><li>步骤1　分割任务。首先我们需要有一个fork类来把大任务分割成子任务，有可能子任务还是很大，所以还需要不停地分割，直到分割出的子任务足够小。</li><li>步骤2　执行任务并合并结果。分割的子任务分别放在双端队列里，然后几个启动线程分别从双端队列里获取任务执行。子任务执行完的结果都统一放在一个队列里，启动一个线程从队列里拿数据，然后合并这些数据。</li></ul><p>&emsp;&emsp;Fork/Join使用两个类来完成以上两件事情。</p><h3 id="1-ForkJoinTask"><a href="#1-ForkJoinTask" class="headerlink" title="1 ForkJoinTask"></a><strong>1 ForkJoinTask</strong></h3><p>&emsp;&emsp;我们要使用ForkJoin框架，必须首先创建一个ForkJoin任务。它提供在任务 中执行fork()和join()操作的机制。通常情况下，我们不需要直接继承ForkJoinTask类，只需要继 承它的子类，Fork/Join框架提供了以下两个子类。</p><ul><li>RecursiveAction：用于没有返回结果的任务。</li><li>RecursiveTask：用于有返回结果的任务。</li></ul><h3 id="2-ForkJoinPool"><a href="#2-ForkJoinPool" class="headerlink" title="2 ForkJoinPool"></a><strong>2 ForkJoinPool</strong></h3><p>&emsp;&emsp;ForkJoinTask需要通过ForkJoinPool来执行。任务分割出的子任务会添加到当前工作线程所维护的双端队列中，进入队列的头部。当<br>一个工作线程的队列里暂时没有任务时，它会随机从其他工作线程的队列的尾部获取一个任务。</p><h2 id="第四节-使用Fork-Join框架"><a href="#第四节-使用Fork-Join框架" class="headerlink" title="第四节 使用Fork/Join框架"></a><strong>第四节 使用Fork/Join框架</strong></h2><p>&emsp;&emsp;让我们通过一个简单的需求来使用Fork/Join框架，需求是：计算1+2+3+4的结果。</p><p>&emsp;&emsp;使用Fork/Join框架首先要考虑到的是如何分割任务，如果希望每个子任务最多执行两个 数的相加，那么我们设置分割的阈值是2，由于是4个数字相加，所以Fork/Join框架会把这个任务fork成两个子任务，子任务一负责计算1+2，子任务二负责计算3+4，然后再join两个子任务 的结果。因为是有结果的任务，所以必须继承RecursiveTask，实现代码如下。</p><figure class="highlight arduino"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><span class="line">package fj; </span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.ExecutionException; </span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.ForkJoinPool; </span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.Future; </span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.RecursiveTask; </span><br><span class="line"><span class="keyword">public</span> class CountTask extends RecursiveTask&lt;Integer&gt; &#123;        </span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> final <span class="keyword">int</span> THRESHOLD = <span class="number">2</span>;　　<span class="comment">// 阈值        </span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> start;        </span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> <span class="built_in">end</span>;        </span><br><span class="line">    <span class="keyword">public</span> CountTask(<span class="keyword">int</span> start, <span class="keyword">int</span> <span class="built_in">end</span>) &#123;                </span><br><span class="line">        <span class="keyword">this</span>.start = start;                </span><br><span class="line">        <span class="keyword">this</span>.<span class="built_in">end</span> = <span class="built_in">end</span>;        </span><br><span class="line">    &#125;        </span><br><span class="line">    </span><br><span class="line">    @Override        </span><br><span class="line">    <span class="keyword">protected</span> Integer compute() &#123;                </span><br><span class="line">        <span class="keyword">int</span> sum = <span class="number">0</span>;                </span><br><span class="line">        <span class="comment">// 如果任务足够小就计算任务                </span></span><br><span class="line">        <span class="keyword">boolean</span> canCompute = (<span class="built_in">end</span> - start) &lt;= THRESHOLD;                </span><br><span class="line">        <span class="built_in">if</span> (canCompute) &#123;                        </span><br><span class="line">            <span class="built_in">for</span> (<span class="keyword">int</span> i = start; i &lt;= <span class="built_in">end</span>; i++) &#123;                                </span><br><span class="line">                sum += i;                        </span><br><span class="line">            &#125;                </span><br><span class="line">        &#125; <span class="built_in">else</span> &#123;                        </span><br><span class="line">            <span class="comment">// 如果任务大于阈值，就分裂成两个子任务计算                        </span></span><br><span class="line">            <span class="keyword">int</span> middle = (start + <span class="built_in">end</span>) / <span class="number">2</span>;                        </span><br><span class="line">            CountTask leftTask = <span class="keyword">new</span> CountTask(start, middle);                        </span><br><span class="line">            CountTask rightTask = <span class="keyword">new</span> CountTask(middle + <span class="number">1</span>, <span class="built_in">end</span>);                        </span><br><span class="line">            <span class="comment">// 执行子任务                        </span></span><br><span class="line">            leftTask.fork();                        </span><br><span class="line">            rightTask.fork();                        </span><br><span class="line">            <span class="comment">// 等待子任务执行完，并得到其结果                        </span></span><br><span class="line">            <span class="keyword">int</span> leftResult=leftTask.join();                        </span><br><span class="line">            <span class="keyword">int</span> rightResult=rightTask.join();                        </span><br><span class="line">            <span class="comment">// 合并子任务                        </span></span><br><span class="line">            sum = leftResult  + rightResult;                </span><br><span class="line">        &#125;                </span><br><span class="line">        <span class="built_in">return</span> sum;        </span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> main(<span class="keyword">String</span>[] args) &#123;                </span><br><span class="line">        ForkJoinPool forkJoinPool = <span class="keyword">new</span> ForkJoinPool();                </span><br><span class="line">        <span class="comment">// 生成一个计算任务，负责计算1+2+3+4                </span></span><br><span class="line">        CountTask task = <span class="keyword">new</span> CountTask(<span class="number">1</span>, <span class="number">4</span>);                </span><br><span class="line">        <span class="comment">// 执行一个任务                </span></span><br><span class="line">        Future&lt;Integer&gt; result = forkJoinPool.submit(task);                </span><br><span class="line">        <span class="built_in">try</span> &#123;                        </span><br><span class="line">            System.out.<span class="built_in">println</span>(result.<span class="built_in">get</span>());                </span><br><span class="line">        &#125; <span class="built_in">catch</span> (InterruptedException e) &#123;                </span><br><span class="line"></span><br><span class="line">        &#125; <span class="built_in">catch</span> (ExecutionException e) &#123;                </span><br><span class="line"></span><br><span class="line">        &#125;        </span><br><span class="line">    &#125; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>&emsp;&emsp;通过这个例子，我们进一步了解ForkJoinTask，ForkJoinTask与一般任务的主要区别在于它需要实现compute方法，在这个方法里，首先需要判断任务是否足够小，如果足够小就直接执行任务。如果不足够小，就必须分割成两个子任务，每个子任务在调用fork方法时，又会进入compute方法，看看当前子任务是否需要继续分割成子任务，如果不需要继续分割，则执行当前子任务并返回结果。使用join方法会等待子任务执行完并得到其结果。</p><h2 id="第五节-Fork-Join框架的异常处理"><a href="#第五节-Fork-Join框架的异常处理" class="headerlink" title="第五节 Fork/Join框架的异常处理"></a><strong>第五节 Fork/Join框架的异常处理</strong></h2><p>&emsp;&emsp;ForkJoinTask在执行的时候可能会抛出异常，但是我们没办法在主线程里直接捕获异常， 所以ForkJoinTask提供了isCompletedAbnormally()方法来检查任务是否已经抛出异常或已经被取消了，并且可以通过ForkJoinTask的getException方法获取异常。使用如下代码。</p><figure class="highlight ada"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span>(<span class="keyword">task</span>.isCompletedAbnormally())&#123;                        </span><br><span class="line">    System.<span class="keyword">out</span>.println(<span class="keyword">task</span>.getException());                </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>&emsp;&emsp;getException方法返回Throwable对象，如果任务被取消了则返回CancellationException。如果任务没有完成或者没有抛出异常则返回null。</p><h2 id="第六节-Fork-Join框架的实现原理"><a href="#第六节-Fork-Join框架的实现原理" class="headerlink" title="第六节 Fork/Join框架的实现原理"></a><strong>第六节 Fork/Join框架的实现原理</strong></h2><p>&emsp;&emsp;ForkJoinPool由ForkJoinTask数组和ForkJoinWorkerThread数组组成，ForkJoinTask数组负责将存放程序提交给ForkJoinPool的任务，而ForkJoinWorkerThread数组负责执行这些任务。</p><h3 id="（1）ForkJoinTask的fork方法实现原理"><a href="#（1）ForkJoinTask的fork方法实现原理" class="headerlink" title="（1）ForkJoinTask的fork方法实现原理"></a><strong>（1）ForkJoinTask的fork方法实现原理</strong></h3><p>&emsp;&emsp;当我们调用ForkJoinTask的fork方法时，程序会调用ForkJoinWorkerThread的pushTask方法异步地执行这个任务，然后立即返回结果。代码如下。</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> ForkJoinTask&lt;V&gt; fork() &#123;        </span><br><span class="line">    ((ForkJoinWorkerThread) Thread.currentThread())            </span><br><span class="line">                                  .pushTask(<span class="keyword">this</span>);        </span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">this</span>; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>&emsp;&emsp;pushTask方法把当前任务存放在ForkJoinTask数组队列里。然后再调用ForkJoinPool的 signalWork()方法唤醒或创建一个工作线程来执行任务。代码如下。</p><figure class="highlight nix"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">final void pushTask(ForkJoinTask&lt;&gt; t) &#123;        </span><br><span class="line">    ForkJoinTask&lt;&gt;[] q; int s, m;        </span><br><span class="line">    <span class="keyword">if</span> ((<span class="attr">q</span> = queue) != <span class="literal">null</span>) &#123;　　　　</span><br><span class="line">        // ignore <span class="keyword">if</span> queue removed            </span><br><span class="line">        long <span class="attr">u</span> = (((<span class="attr">s</span> = queueTop) &amp; (<span class="attr">m</span> = q.length - <span class="number">1</span>)) &lt;&lt; ASHIFT) + ABASE;            </span><br><span class="line">        UNSAFE.putOrderedObject(q, u, t);            </span><br><span class="line">        <span class="attr">queueTop</span> = s + <span class="number">1</span>;　　　　　　</span><br><span class="line">        // <span class="literal">or</span> use putOrderedInt            </span><br><span class="line">        <span class="keyword">if</span> ((s <span class="attr">-=</span> queueBase) &lt;= <span class="number">2</span>)                </span><br><span class="line">            pool.signalWork();            </span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (<span class="attr">s</span> == m)                </span><br><span class="line">            growQueue();        </span><br><span class="line">    &#125;    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="（2）ForkJoinTask的join方法实现原理"><a href="#（2）ForkJoinTask的join方法实现原理" class="headerlink" title="（2）ForkJoinTask的join方法实现原理"></a><strong>（2）ForkJoinTask的join方法实现原理</strong></h3><p>&emsp;&emsp;Join方法的主要作用是阻塞当前线程并等待获取结果。让我们一起看看ForkJoinTask的join方法的实现，代码如下。</p><figure class="highlight aspectj"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="function">V <span class="title">join</span><span class="params">()</span> </span>&#123;        </span><br><span class="line">    <span class="keyword">if</span> (doJoin() != NORMAL)            </span><br><span class="line">        <span class="function"><span class="keyword">return</span> <span class="title">reportResult</span><span class="params">()</span></span>;        </span><br><span class="line">    <span class="keyword">else</span>            </span><br><span class="line">        <span class="function"><span class="keyword">return</span> <span class="title">getRawResult</span><span class="params">()</span></span>; </span><br><span class="line">&#125; </span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="function">V <span class="title">reportResult</span><span class="params">()</span> </span>&#123;        </span><br><span class="line">    <span class="keyword">int</span> s; </span><br><span class="line">    Throwable ex;        </span><br><span class="line">    <span class="keyword">if</span> ((s = status) == CANCELLED)            </span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> CancellationException();        </span><br><span class="line">    <span class="keyword">if</span> (s == EXCEPTIONAL &amp;&amp; (ex = getThrowableException()) != <span class="keyword">null</span>)            </span><br><span class="line">        UNSAFE.throwException(ex);        </span><br><span class="line">    <span class="function"><span class="keyword">return</span> <span class="title">getRawResult</span><span class="params">()</span></span>;    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>&emsp;&emsp;首先，它调用了doJoin()方法，通过doJoin()方法得到当前任务的状态来判断返回什么结 果，任务状态有4种：已完成（NORMAL）、被取消（CANCELLED）、信号（SIGNAL）和出现异常 （EXCEPTIONAL）。</p><ul><li>如果任务状态是已完成，则直接返回任务结果。</li><li>如果任务状态是被取消，则直接抛出CancellationException。</li><li>如果任务状态是抛出异常，则直接抛出对应的异常。</li></ul><p>&emsp;&emsp;让我们再来分析一下doJoin()方法的实现代码。</p><figure class="highlight aspectj"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="function"><span class="keyword">int</span> <span class="title">doJoin</span><span class="params">()</span> </span>&#123;        </span><br><span class="line">    Thread t; </span><br><span class="line">    ForkJoinWorkerThread w; </span><br><span class="line">    <span class="keyword">int</span> s; </span><br><span class="line">    <span class="keyword">boolean</span> completed;        </span><br><span class="line">    <span class="keyword">if</span> ((t = Thread.currentThread()) <span class="keyword">instanceof</span> ForkJoinWorkerThread) &#123;            </span><br><span class="line">        <span class="keyword">if</span> ((s = status) &lt; <span class="number">0</span>)                </span><br><span class="line">            <span class="keyword">return</span> s;            </span><br><span class="line">        <span class="keyword">if</span> ((w = (ForkJoinWorkerThread)t).unpushTask(<span class="keyword">this</span>)) &#123;                </span><br><span class="line">            <span class="keyword">try</span> &#123;                    </span><br><span class="line">                completed = exec();                </span><br><span class="line">            &#125; <span class="keyword">catch</span> (Throwable rex) &#123;                    </span><br><span class="line">                <span class="function"><span class="keyword">return</span> <span class="title">setExceptionalCompletion</span><span class="params">(rex)</span></span>;                </span><br><span class="line">            &#125;                </span><br><span class="line">            <span class="keyword">if</span> (completed)                    </span><br><span class="line">                <span class="function"><span class="keyword">return</span> <span class="title">setCompletion</span><span class="params">(NORMAL)</span></span>;            </span><br><span class="line">        &#125;            </span><br><span class="line">        <span class="function"><span class="keyword">return</span> w.<span class="title">joinTask</span><span class="params">(<span class="keyword">this</span>)</span></span>;        </span><br><span class="line">    &#125; <span class="keyword">else</span>            </span><br><span class="line">        <span class="function"><span class="keyword">return</span> <span class="title">externalAwaitDone</span><span class="params">()</span></span>;    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>&emsp;&emsp;在doJoin()方法里，首先通过查看任务的状态，看任务是否已经执行完成，如果执行完成，则直接返回任务状态；如果没有执行完，则从任务数组里取出任务并执行。如果任务顺利执行完成，则设置任务状态为NORMAL，如果出现异常，则记录异常，并将任务状态设置为EXCEPTIONAL。</p><hr><p><em>参考博客和文章书籍等：</em></p><blockquote><p>《Java并发编程的艺术》</p></blockquote><p><em>因博客主等未标明不可引用，若部分内容涉及侵权请及时告知，我会尽快修改和删除相关内容</em></p>]]></content>
    
    <summary type="html">
    
      介绍Java中Fork/Join框架。
    
    </summary>
    
      <category term="技术文档" scheme="http://linyishui.top/categories/%E6%8A%80%E6%9C%AF%E6%96%87%E6%A1%A3/"/>
    
    
      <category term="java" scheme="http://linyishui.top/tags/java/"/>
    
      <category term="lock" scheme="http://linyishui.top/tags/lock/"/>
    
  </entry>
  
  <entry>
    <title>阻塞队列</title>
    <link href="http://linyishui.top/2019082501.html"/>
    <id>http://linyishui.top/2019082501.html</id>
    <published>2019-08-25T08:44:25.000Z</published>
    <updated>2019-10-10T10:50:16.394Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="Java中的阻塞队列"><a href="#Java中的阻塞队列" class="headerlink" title="Java中的阻塞队列"></a><strong>Java中的阻塞队列</strong></h1><p>&emsp;&emsp;本节将介绍什么是阻塞队列，以及Java中阻塞队列的4种处理方式，并介绍Java 7中提供的 7种阻塞队列，最后分析阻塞队列的一种实现方式。</p><h2 id="第一节-什么是阻塞队列"><a href="#第一节-什么是阻塞队列" class="headerlink" title="第一节 什么是阻塞队列"></a><strong>第一节 什么是阻塞队列</strong></h2><p>&emsp;&emsp;阻塞队列（BlockingQueue）是一个支持两个附加操作的队列。这两个附加的操作支持阻塞的插入和移除方法。</p><ol><li><p>支持阻塞的插入方法：意思是当队列满时，队列会阻塞插入元素的线程，直到队列不满。</p></li><li><p>支持阻塞的移除方法：意思是在队列为空时，获取元素的线程会等待队列变为非空。</p></li></ol><p>&emsp;&emsp;阻塞队列常用于生产者和消费者的场景，生产者是向队列里添加元素的线程，消费者是从队列里取元素的线程。阻塞队列就是生产者用来存放元素、消费者用来获取元素的容器。</p><p>&emsp;&emsp;在阻塞队列不可用时，这两个附加操作提供了4种处理方式，如表6-1所示。</p><p><img src="https://pic-1258215793.cos.ap-shanghai.myqcloud.com/content/20190701/201907010106.png" alt="插入和移除操作的4中处理方式"></p><ul><li>抛出异常：当队列满时，如果再往队列里插入元素，会抛出IllegalStateException（”Queue full”）异常。当队列空时，从队列里获取元素会抛出NoSuchElementException异常。</li><li>返回特殊值：当往队列插入元素时，会返回元素是否插入成功，成功返回true。如果是移除方法，则是从队列里取出一个元素，如果没有则返回null。</li><li>一直阻塞：当阻塞队列满时，如果生产者线程往队列里put元素，队列会一直阻塞生产者线程，直到队列可用或者响应中断退出。当队列空时，如果消费者线程从队列里take元素，队列会阻塞住消费者线程，直到队列不为空。</li><li>超时退出：当阻塞队列满时，如果生产者线程往队列里插入元素，队列会阻塞生产者线程一段时间，如果超过了指定的时间，生产者线程就会退出。</li></ul><p>&emsp;&emsp;这两个附加操作的4种处理方式不方便记忆，所以我找了一下这几个方法的规律。put和 take分别尾首含有字母t，offer和poll都含有字母o。</p><p>&emsp;&emsp;注意: 如果是无界阻塞队列，队列不可能会出现满的情况，所以使用put或offer方法永 远不会被阻塞，而且使用offer方法时，该方法永远返回true。</p><h2 id="第二节-Java里的阻塞队列"><a href="#第二节-Java里的阻塞队列" class="headerlink" title="第二节 Java里的阻塞队列"></a><strong>第二节 Java里的阻塞队列</strong></h2><p>&emsp;&emsp;JDK 7提供了7个阻塞队列，如下。</p><ul><li>ArrayBlockingQueue：一个由数组结构组成的有界阻塞队列。</li><li>LinkedBlockingQueue：一个由链表结构组成的有界阻塞队列。</li><li>PriorityBlockingQueue：一个支持优先级排序的无界阻塞队列。</li><li>DelayQueue：一个使用优先级队列实现的无界阻塞队列。</li><li>SynchronousQueue：一个不存储元素的阻塞队列。</li><li>LinkedTransferQueue：一个由链表结构组成的无界阻塞队列。</li><li>LinkedBlockingDeque：一个由链表结构组成的双向阻塞队列。</li></ul><h3 id="1-ArrayBlockingQueue"><a href="#1-ArrayBlockingQueue" class="headerlink" title="1 ArrayBlockingQueue"></a><strong>1 ArrayBlockingQueue</strong></h3><p>&emsp;&emsp;ArrayBlockingQueue是一个用数组实现的有界阻塞队列。此队列按照先进先出（FIFO）的原则对元素进行排序。</p><p>&emsp;&emsp;默认情况下不保证线程公平的访问队列，所谓公平访问队列是指阻塞的线程，可以按照阻塞的先后顺序访问队列，即先阻塞线程先访问队列。非公平性是对先等待的线程是非公平的，当队列可用时，阻塞的线程都可以争夺访问队列的资格，有可能先阻塞的线程最后才访问队列。为了保证公平性，通常会降低吞吐量。我们可以使用以下代码创建一个公平的阻塞队列。</p><figure class="highlight haxe"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ArrayBlockingQueue fairQueue = <span class="keyword">new</span>  <span class="type">ArrayBlockingQueue</span>(<span class="number">1000</span>,<span class="literal">true</span>);</span><br></pre></td></tr></table></figure><p>&emsp;&emsp;访问者的公平性是使用可重入锁实现的，代码如下。</p><figure class="highlight haxe"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> ArrayBlockingQueue(int capacity, boolean fair) &#123;        </span><br><span class="line">    <span class="keyword">if</span> (capacity &lt;= <span class="number">0</span>)            </span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="type">IllegalArgumentException</span>();        </span><br><span class="line">    <span class="built_in">this</span>.items = <span class="keyword">new</span> <span class="type">Object</span>[capacity];        </span><br><span class="line">    lock = <span class="keyword">new</span> <span class="type">ReentrantLock</span>(fair);        </span><br><span class="line">    notEmpty = lock.<span class="keyword">new</span><span class="type">Condition</span>();        </span><br><span class="line">    notFull =  lock.<span class="keyword">new</span><span class="type">Condition</span>(); </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="2-LinkedBlockingQueue"><a href="#2-LinkedBlockingQueue" class="headerlink" title="2 LinkedBlockingQueue"></a><strong>2 LinkedBlockingQueue</strong></h3><p>&emsp;&emsp;LinkedBlockingQueue是一个用链表实现的有界阻塞队列。此队列的默认和最大长度为 Integer.MAX_VALUE。此队列按照先进先出的原则对元素进行排序。</p><h3 id="3-PriorityBlockingQueue"><a href="#3-PriorityBlockingQueue" class="headerlink" title="3 PriorityBlockingQueue"></a><strong>3 PriorityBlockingQueue</strong></h3><p>&emsp;&emsp;PriorityBlockingQueue是一个支持优先级的无界阻塞队列。默认情况下元素采取自然顺序 升序排列。也可以自定义类实现compareTo()方法来指定元素排序规则，或者初始化 PriorityBlockingQueue时，指定构造参数Comparator来对元素进行排序。需要注意的是不能保证同优先级元素的顺序。</p><h3 id="4-DelayQueue"><a href="#4-DelayQueue" class="headerlink" title="4 DelayQueue"></a><strong>4 DelayQueue</strong></h3><p>&emsp;&emsp;DelayQueue是一个支持延时获取元素的无界阻塞队列。队列使用PriorityQueue来实现。队列中的元素必须实现Delayed接口，在创建元素时可以指定多久才能从队列中获取当前元素。</p><p>&emsp;&emsp;只有在延迟期满时才能从队列中提取元素。</p><p>&emsp;&emsp;DelayQueue非常有用，可以将DelayQueue运用在以下应用场景。</p><ul><li>缓存系统的设计：可以用DelayQueue保存缓存元素的有效期，使用一个线程循环查询DelayQueue，一旦能从DelayQueue中获取元素时，表示缓存有效期到了。</li><li>定时任务调度：使用DelayQueue保存当天将会执行的任务和执行时间，一旦从 DelayQueue中获取到任务就开始执行，比如TimerQueue就是使用DelayQueue实现的。</li></ul><p>（1）如何实现Delayed接口</p><p>&emsp;&emsp;DelayQueue队列的元素必须实现Delayed接口。我们可以参考ScheduledThreadPoolExecutor里ScheduledFutureTask类的实现，一共有三步。</p><p>&emsp;&emsp;第一步：在对象创建的时候，初始化基本数据。使用time记录当前对象延迟到什么时候可 以使用，使用sequenceNumber来标识元素在队列中的先后顺序。代码如下。</p><figure class="highlight aspectj"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> AtomicLong sequencer = <span class="keyword">new</span> AtomicLong(<span class="number">0</span>); </span><br><span class="line">ScheduledFutureTask(Runnable r, V result, <span class="keyword">long</span> ns, <span class="keyword">long</span> period) &#123; </span><br><span class="line">ScheduledFutureTask(Runnable r, V result, <span class="keyword">long</span> ns, <span class="keyword">long</span> period) &#123;            </span><br><span class="line">    <span class="keyword">super</span>(r, result);            </span><br><span class="line">    <span class="keyword">this</span>.time = ns;            </span><br><span class="line">    <span class="keyword">this</span>.period = period;            </span><br><span class="line">    <span class="keyword">this</span>.sequenceNumber = sequencer.getAndIncrement(); </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>&emsp;&emsp;第二步：实现getDelay方法，该方法返回当前元素还需要延时多长时间，单位是纳秒，代码如下。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">long</span> <span class="title">getDelay</span><span class="params">(TimeUnit unit)</span> </span>&#123;            </span><br><span class="line">    <span class="keyword">return</span> unit.convert(time - now(), TimeUnit.NANOSECONDS);        </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>&emsp;&emsp;通过构造函数可以看出延迟时间参数ns的单位是纳秒，自己设计的时候最好使用纳秒，因为实现getDelay()方法时可以指定任意单位，一旦以秒或分作为单位，而延时时间又精确不到纳秒就麻烦了。使用时请注意当time小于当前时间时，getDelay会返回负数。</p><p>&emsp;&emsp;第三步：实现compareTo方法来指定元素的顺序。例如，让延时时间最长的放在队列的末尾。实现代码如下。</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> int compareTo(Delayed other) &#123;            </span><br><span class="line">    <span class="keyword">if</span> (other == <span class="keyword">this</span>)　　<span class="comment">// compare zero ONLY if same object                </span></span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;            </span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span> (other instanceof ScheduledFutureTask) &#123;                </span><br><span class="line">        ScheduledFutureTask&lt;&gt; x = (ScheduledFutureTask&lt;&gt;)other;                </span><br><span class="line">        long diff = time - x.time;                </span><br><span class="line">        <span class="keyword">if</span> (diff &lt; <span class="number">0</span>)                    </span><br><span class="line">            <span class="keyword">return</span> <span class="number">-1</span>;                </span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (diff &gt; <span class="number">0</span>)                    </span><br><span class="line">            <span class="keyword">return</span> <span class="number">1</span>;                </span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (sequenceNumber &lt; x.sequenceNumber)                    </span><br><span class="line">            <span class="keyword">return</span> <span class="number">-1</span>;                </span><br><span class="line">        <span class="keyword">else</span>                    </span><br><span class="line">            <span class="keyword">return</span> <span class="number">1</span>;            </span><br><span class="line">    &#125;            </span><br><span class="line">    </span><br><span class="line">    long d = (getDelay(TimeUnit.NANOSECONDS) other.getDelay(TimeUnit.NANOSECONDS));            </span><br><span class="line">    <span class="keyword">return</span> (d == <span class="number">0</span>)  <span class="number">0</span> : ((d &lt; <span class="number">0</span>)  <span class="number">-1</span> : <span class="number">1</span>);        </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>（2）如何实现延时阻塞队列</p><p>&emsp;&emsp;延时阻塞队列的实现很简单，当消费者从队列里获取元素时，如果元素没有达到延时时间，就阻塞当前线程。</p><figure class="highlight arduino"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">long</span> <span class="built_in">delay</span> = first.getDelay(TimeUnit.NANOSECONDS); </span><br><span class="line"><span class="built_in">if</span> (<span class="built_in">delay</span> &lt;= <span class="number">0</span>)    </span><br><span class="line">    <span class="built_in">return</span> q.poll(); </span><br><span class="line"><span class="built_in">else</span> <span class="built_in">if</span> (leader != null)        </span><br><span class="line">    <span class="built_in">available</span>.await(); </span><br><span class="line"><span class="built_in">else</span> &#123;    </span><br><span class="line">    Thread thisThread = Thread.currentThread(); </span><br><span class="line">    leader = thisThread;        </span><br><span class="line">    <span class="built_in">try</span> &#123;                </span><br><span class="line">        <span class="built_in">available</span>.awaitNanos(<span class="built_in">delay</span>);            </span><br><span class="line">    &#125; finally &#123;                </span><br><span class="line">        <span class="built_in">if</span> (leader == thisThread)                </span><br><span class="line">            leader = null;            </span><br><span class="line">    &#125;    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>&emsp;&emsp;代码中的变量leader是一个等待获取队列头部元素的线程。如果leader不等于空，表示已 经有线程在等待获取队列的头元素。所以，使用await()方法让当前线程等待信号。如果leader等于空，则把当前线程设置成leader，并使用awaitNanos()方法让当前线程等待接收信号或等待delay时间。</p><h3 id="5-SynchronousQueue"><a href="#5-SynchronousQueue" class="headerlink" title="5 SynchronousQueue"></a><strong>5 SynchronousQueue</strong></h3><p>&emsp;&emsp;SynchronousQueue是一个不存储元素的阻塞队列。每一个put操作必须等待一个take操作，否则不能继续添加元素。</p><p>&emsp;&emsp;它支持公平访问队列。默认情况下线程采用非公平性策略访问队列。使用以下构造方法 可以创建公平性访问的SynchronousQueue，如果设置为true，则等待的线程会采用先进先出的顺序访问队列。</p><figure class="highlight aspectj"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">SynchronousQueue</span><span class="params">(<span class="keyword">boolean</span> fair)</span> </span>&#123;        </span><br><span class="line">    transferer = fair  <span class="keyword">new</span> TransferQueue() : <span class="keyword">new</span> TransferStack();    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>&emsp;&emsp;SynchronousQueue可以看成是一个传球手，负责把生产者线程处理的数据直接传递给消费 者线程。队列本身并不存储任何元素，非常适合传递性场景。</p><p>&emsp;&emsp;SynchronousQueue的吞吐量高于LinkedBlockingQueue和ArrayBlockingQueue。</p><h3 id="6-LinkedTransferQueue"><a href="#6-LinkedTransferQueue" class="headerlink" title="6 LinkedTransferQueue"></a><strong>6 LinkedTransferQueue</strong></h3><p>&emsp;&emsp;LinkedTransferQueue是一个由链表结构组成的无界阻塞TransferQueue队列。相对于其他阻塞队列，LinkedTransferQueue多了tryTransfer和transfer方法。</p><p>（1）transfer方法</p><p>&emsp;&emsp;如果当前有消费者正在等待接收元素（消费者使用take()方法或带时间限制的poll()方法 时），transfer方法可以把生产者传入的元素立刻transfer（传输）给消费者。如果没有消费者在等 待接收元素，transfer方法会将元素存放在队列的tail节点，并等到该元素被消费者消费了才返 回。transfer方法的关键代码如下。</p><figure class="highlight lisp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Node pred = tryAppend(<span class="name">s</span>, haveData)<span class="comment">; </span></span><br><span class="line">return awaitMatch(<span class="name">s</span>, pred, e, (<span class="name">how</span> == TIMED), nanos)<span class="comment">;</span></span><br></pre></td></tr></table></figure><p>&emsp;&emsp;第一行代码是试图把存放当前元素的s节点作为tail节点。第二行代码是让CPU自旋等待 消费者消费元素。因为自旋会消耗CPU，所以自旋一定的次数后使用Thread.yield()方法来暂停当前正在执行的线程，并执行其他线程。</p><p>（2）tryTransfer方法</p><p>&emsp;&emsp;tryTransfer方法是用来试探生产者传入的元素是否能直接传给消费者。如果没有消费者等 待接收元素，则返回false。和transfer方法的区别是tryTransfer方法无论消费者是否接收，方法 立即返回，而transfer方法是必须等到消费者消费了才返回。</p><p>&emsp;&emsp;对于带有时间限制的tryTransfer（E e，long timeout，TimeUnit unit）方法，试图把生产者传入的元素直接传给消费者，但是如果没有消费者消费该元素则等待指定的时间再返回，如果超 时还没消费元素，则返回false，如果在超时时间内消费了元素，则返回true。</p><h3 id="7-LinkedBlockingDeque"><a href="#7-LinkedBlockingDeque" class="headerlink" title="7 LinkedBlockingDeque"></a><strong>7 LinkedBlockingDeque</strong></h3><p>&emsp;&emsp;LinkedBlockingDeque是一个由链表结构组成的双向阻塞队列。所谓双向队列指的是可以从队列的两端插入和移出元素。双向队列因为多了一个操作队列的入口，在多线程同时入队 时，也就减少了一半的竞争。相比其他的阻塞队列，LinkedBlockingDeque多了addFirst、 addLast、offerFirst、offerLast、peekFirst和peekLast等方法，以First单词结尾的方法，表示插入、 获取（peek）或移除双端队列的第一个元素。以Last单词结尾的方法，表示插入、获取或移除双 端队列的最后一个元素。另外，插入方法add等同于addLast，移除方法remove等效于 removeFirst。但是take方法却等同于takeFirst，不知道是不是JDK的bug，使用时还是用带有First 和Last后缀的方法更清楚。</p><p>&emsp;&emsp;在初始化LinkedBlockingDeque时可以设置容量防止其过度膨胀。另外，双向阻塞队列可以 运用在“工作窃取”模式中。</p><h2 id="第三节-阻塞队列的实现原理"><a href="#第三节-阻塞队列的实现原理" class="headerlink" title="第三节 阻塞队列的实现原理"></a><strong>第三节 阻塞队列的实现原理</strong></h2><p>&emsp;&emsp;如果队列是空的，消费者会一直等待，当生产者添加元素时，消费者是如何知道当前队列有元素的呢？如果让你来设计阻塞队列你会如何设计，如何让生产者和消费者进行高效率的 通信呢？让我们先来看看JDK是如何实现的。</p><p>&emsp;&emsp;使用通知模式实现。所谓通知模式，就是当生产者往满的队列里添加元素时会阻塞住生 产者，当消费者消费了一个队列中的元素后，会通知生产者当前队列可用。通过查看JDK源码发现ArrayBlockingQueue使用了Condition来实现，代码如下。</p><figure class="highlight cs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> final Condition notFull; </span><br><span class="line"><span class="keyword">private</span> final Condition notEmpty; </span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">ArrayBlockingQueue</span>(<span class="params"><span class="keyword">int</span> capacity, boolean fair</span>) </span>&#123;        </span><br><span class="line">    <span class="comment">// 省略其他代码        </span></span><br><span class="line">    notEmpty = <span class="keyword">lock</span>.newCondition();        </span><br><span class="line">    notFull =  <span class="keyword">lock</span>.newCondition();    </span><br><span class="line">&#125; </span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">put</span>(<span class="params">E e</span>) throws InterruptedException </span>&#123;        </span><br><span class="line">    checkNotNull(e);        </span><br><span class="line">    final ReentrantLock <span class="keyword">lock</span> = <span class="keyword">this</span>.<span class="keyword">lock</span>;        </span><br><span class="line">    <span class="keyword">lock</span>.lockInterruptibly();        </span><br><span class="line">    <span class="keyword">try</span> &#123;            </span><br><span class="line">        <span class="keyword">while</span> (count == items.length)                </span><br><span class="line">            notFull.<span class="keyword">await</span>();            </span><br><span class="line">            insert(e);        </span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;            </span><br><span class="line">            <span class="keyword">lock</span>.unlock();        </span><br><span class="line">        &#125; </span><br><span class="line">    &#125; </span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> E <span class="title">take</span>(<span class="params"></span>) throws InterruptedException </span>&#123;      </span><br><span class="line">        final ReentrantLock <span class="keyword">lock</span> = <span class="keyword">this</span>.<span class="keyword">lock</span>;        </span><br><span class="line">        <span class="keyword">lock</span>.lockInterruptibly();        </span><br><span class="line">        <span class="keyword">try</span> &#123;            </span><br><span class="line">            <span class="keyword">while</span> (count == <span class="number">0</span>)                </span><br><span class="line">            notEmpty.<span class="keyword">await</span>();            </span><br><span class="line">            <span class="keyword">return</span> extract();        </span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;            </span><br><span class="line">            <span class="keyword">lock</span>.unlock();        </span><br><span class="line">        &#125; </span><br><span class="line">    &#125; </span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">insert</span>(<span class="params">E x</span>) </span>&#123;        </span><br><span class="line">        items[putIndex] = x;        </span><br><span class="line">        putIndex = inc(putIndex);        </span><br><span class="line">        ++count;        </span><br><span class="line">        notEmpty.signal();    </span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>&emsp;&emsp;当往队列里插入一个元素时，如果队列不可用，那么阻塞生产者主要通过 LockSupport.park（this）来实现。</p><figure class="highlight crmsh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">public final void await() throws InterruptedException &#123;            </span><br><span class="line">    if (Thread.interrupted())                </span><br><span class="line">        throw new InterruptedException();            </span><br><span class="line">    <span class="keyword">Node</span> <span class="title">node</span> = addConditionWaiter();            </span><br><span class="line">    int savedState = fullyRelease(<span class="keyword">node</span><span class="title">);            </span></span><br><span class="line"><span class="title">    int</span> interruptMode = <span class="number">0</span>;            </span><br><span class="line">    </span><br><span class="line">    while (!isOnSyncQueue(<span class="keyword">node</span><span class="title">)) &#123;                </span></span><br><span class="line"><span class="title">        LockSupport</span>.park(this);                </span><br><span class="line">        if ((interruptMode = checkInterruptWhileWaiting(<span class="keyword">node</span><span class="title">)) != 0</span>)                    </span><br><span class="line">            break;            </span><br><span class="line">    &#125;            </span><br><span class="line">    if (acquireQueued(<span class="keyword">node</span><span class="title">, savedState</span>) &amp;&amp; interruptMode != THROW_IE)                </span><br><span class="line">        interruptMode = REINTERRUPT;            </span><br><span class="line">        </span><br><span class="line">    if (<span class="keyword">node</span>.<span class="title">nextWaiter</span> != null) // clean up if cancelled                </span><br><span class="line">        unlinkCancelledWaiters();            </span><br><span class="line">        </span><br><span class="line">    if (interruptMode != <span class="number">0</span>)                </span><br><span class="line">        reportInterruptAfterWait(interruptMode);        </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>&emsp;&emsp;继续进入源码，发现调用setBlocker先保存一下将要阻塞的线程，然后调用unsafe.park阻塞当前线程。</p><figure class="highlight cs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">park</span>(<span class="params">Object blocker</span>) </span>&#123;        </span><br><span class="line">    Thread t = Thread.currentThread();        </span><br><span class="line">    setBlocker(t, blocker);        </span><br><span class="line">    <span class="keyword">unsafe</span>.park(<span class="literal">false</span>, <span class="number">0</span>L);        </span><br><span class="line">    setBlocker(t, <span class="literal">null</span>);    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>&emsp;&emsp;unsafe.park是个native方法，代码如下。</p><figure class="highlight aspectj"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">native</span> <span class="function"><span class="keyword">void</span> <span class="title">park</span><span class="params">(<span class="keyword">boolean</span> isAbsolute, <span class="keyword">long</span> time)</span></span>;</span><br></pre></td></tr></table></figure><p>&emsp;&emsp;park这个方法会阻塞当前线程，只有以下4种情况中的一种发生时，该方法才会返回。</p><ul><li>与park对应的unpark执行或已经执行时。“已经执行”是指unpark先执行，然后再执行park的情况。</li><li>线程被中断时。</li><li>等待完time参数指定的毫秒数时。</li><li>异常现象发生时，这个异常现象没有任何原因。</li></ul><p>&emsp;&emsp;继续看一下JVM是如何实现park方法：park在不同的操作系统中使用不同的方式实现，在 Linux下使用的是系统方法pthread_cond_wait实现。实现代码在JVM源码路径 src/os/linux/vm/os_linux.cpp里的os::PlatformEvent::park方法，代码如下。</p><figure class="highlight sqf"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line">void os::PlatformEvent::park() &#123;    </span><br><span class="line">    int v ;            </span><br><span class="line">    <span class="keyword">for</span> (;;) &#123;                </span><br><span class="line">        v = <span class="variable">_Event</span> ;            </span><br><span class="line">        <span class="keyword">if</span> (Atomic::cmpxchg (v-<span class="number">1</span>, &amp;<span class="variable">_Event</span>, v) == v)  break ;            </span><br><span class="line">    &#125;            </span><br><span class="line">    </span><br><span class="line">    guarantee (v &gt;= <span class="number">0</span>, <span class="string">"invariant"</span>) ;            </span><br><span class="line">    <span class="keyword">if</span> (v == <span class="number">0</span>) &#123;            </span><br><span class="line">        <span class="comment">// Do this the hard way by blocking ...            </span></span><br><span class="line">        int status = pthread_mutex_lock(<span class="variable">_mutex</span>);            </span><br><span class="line">        assert_status(status == <span class="number">0</span>, status, <span class="string">"mutex_lock"</span>);            </span><br><span class="line">        guarantee (<span class="variable">_nParked</span> == <span class="number">0</span>, <span class="string">"invariant"</span>) ;            </span><br><span class="line">        ++ <span class="variable">_nParked</span> ;            </span><br><span class="line">        <span class="keyword">while</span> (<span class="variable">_Event</span> &lt; <span class="number">0</span>) &#123;            </span><br><span class="line">            status = pthread_cond_wait(<span class="variable">_cond</span>, <span class="variable">_mutex</span>);            </span><br><span class="line">            <span class="comment">// for some reason, under 2.7 lwp_cond_wait() may return ETIME ...            </span></span><br><span class="line">            <span class="comment">// Treat this the same as if the wait was interrupted            </span></span><br><span class="line">            <span class="keyword">if</span> (status == ETIME) &#123; status = EINTR; &#125;            </span><br><span class="line">            assert_status(status == <span class="number">0</span> || status == EINTR, status, <span class="string">"cond_wait"</span>);            </span><br><span class="line">        &#125;            </span><br><span class="line">        -- <span class="variable">_nParked</span> ;            </span><br><span class="line">        <span class="comment">// In theory we could move the ST of 0 into _Event past the unlock(),            </span></span><br><span class="line">        <span class="comment">// but then we'd need a MEMBAR after the ST.            </span></span><br><span class="line">        <span class="variable">_Event</span> = <span class="number">0</span> ;            </span><br><span class="line">        status = pthread_mutex_unlock(<span class="variable">_mutex</span>);            </span><br><span class="line">        assert_status(status == <span class="number">0</span>, status, <span class="string">"mutex_unlock"</span>);            </span><br><span class="line">    &#125;            </span><br><span class="line">    guarantee (<span class="variable">_Event</span> &gt;= <span class="number">0</span>, <span class="string">"invariant"</span>) ;            </span><br><span class="line">    &#125;    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>&emsp;&emsp;pthread_cond_wait是一个多线程的条件变量函数，cond是condition的缩写，字面意思可以理解为线程在等待一个条件发生，这个条件是一个全局变量。这个方法接收两个参数：一个共享变量_cond，一个互斥量_mutex。而unpark方法在Linux下是使用pthread_cond_signal实现的。 park方法在Windows下则是使用WaitForSingleObject实现的。想知道pthread_cond_wait是如何实 现的，可以参考glibc-2.5的nptl/sysdeps/pthread/pthread_cond_wait.c。</p><p>&emsp;&emsp;当线程被阻塞队列阻塞时，线程会进入WAITING（parking）状态。我们可以使用jstack dump阻塞的生产者线程看到这点，如下。</p><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">"main"</span> prio=<span class="number">5</span> tid=<span class="number">0</span>x00007fc83c000000 nid=<span class="number">0</span>x10164e000 waiting on condition [<span class="number">0</span>x0000000101        </span><br><span class="line">       java<span class="selector-class">.lang</span><span class="selector-class">.Thread</span><span class="selector-class">.State</span>: WAITING (parking)              </span><br><span class="line">             at sun<span class="selector-class">.misc</span><span class="selector-class">.Unsafe</span><span class="selector-class">.park</span>(Native Method)              </span><br><span class="line">             - parking to wait <span class="keyword">for</span>  &lt;<span class="number">0</span>x0000000140559fe8&gt; (<span class="selector-tag">a</span> java<span class="selector-class">.util</span><span class="selector-class">.concurrent</span><span class="selector-class">.locks</span> AbstractQueuedSynchronizer<span class="variable">$ConditionObject</span>)        at java<span class="selector-class">.util</span><span class="selector-class">.concurrent</span><span class="selector-class">.locks</span><span class="selector-class">.LockSupport</span><span class="selector-class">.park</span>(LockSupport<span class="selector-class">.java</span>:<span class="number">186</span>)              </span><br><span class="line">             at java<span class="selector-class">.util</span><span class="selector-class">.concurrent</span><span class="selector-class">.locks</span><span class="selector-class">.AbstractQueuedSynchronizer</span><span class="variable">$ConditionObject</span>.await(AbstractQueuedSynchronizer<span class="selector-class">.java</span>:<span class="number">2043</span>)         at java<span class="selector-class">.util</span><span class="selector-class">.concurrent</span><span class="selector-class">.ArrayBlockingQueue</span><span class="selector-class">.put</span>(ArrayBlockingQueue<span class="selector-class">.java</span>:<span class="number">32</span>              </span><br><span class="line">             at blockingqueue<span class="selector-class">.ArrayBlockingQueueTest</span><span class="selector-class">.main</span>(ArrayBlockingQueueTest<span class="selector-class">.java</span>:</span><br></pre></td></tr></table></figure><hr><p><em>参考博客和文章书籍等：</em></p><blockquote><p>《Java并发编程的艺术》</p></blockquote><p><em>因博客主等未标明不可引用，若部分内容涉及侵权请及时告知，我会尽快修改和删除相关内容</em></p>]]></content>
    
    <summary type="html">
    
      介绍Java中阻塞队列。
    
    </summary>
    
      <category term="技术文档" scheme="http://linyishui.top/categories/%E6%8A%80%E6%9C%AF%E6%96%87%E6%A1%A3/"/>
    
    
      <category term="java" scheme="http://linyishui.top/tags/java/"/>
    
      <category term="lock" scheme="http://linyishui.top/tags/lock/"/>
    
  </entry>
  
  <entry>
    <title>ConcurrentLinkedQueue的实现原理</title>
    <link href="http://linyishui.top/2019082401.html"/>
    <id>http://linyishui.top/2019082401.html</id>
    <published>2019-08-24T08:31:43.000Z</published>
    <updated>2019-10-10T09:25:48.012Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="ConcurrentLinkedQueue的实现原理"><a href="#ConcurrentLinkedQueue的实现原理" class="headerlink" title="ConcurrentLinkedQueue的实现原理"></a><strong>ConcurrentLinkedQueue的实现原理</strong></h1><p>&emsp;&emsp;在并发编程中，有时候需要使用线程安全的队列。如果要实现一个线程安全的队列有两种方式：一种是使用阻塞算法，另一种是使用非阻塞算法。使用阻塞算法的队列可以用一个锁（入队和出队用同一把锁）或两个锁（入队和出队用不同的锁）等方式来实现。非阻塞的实现方 式则可以使用循环CAS的方式来实现。本节让我们一起来研究一下Doug Lea是如何使用非阻 塞的方式来实现线程安全队列ConcurrentLinkedQueue的，相信从大师身上我们能学到不少并发编程的技巧。</p><p>&emsp;&emsp;ConcurrentLinkedQueue是一个基于链接节点的无界线程安全队列，它采用先进先出的规则对节点进行排序，当我们添加一个元素的时候，它会添加到队列的尾部；当我们获取一个元素时，它会返回队列头部的元素。它采用了“wait-free”算法（即CAS算法）来实现，该算法在 Michael&amp;Scott算法上进行了一些修改。</p><h2 id="第一节-ConcurrentLinkedQueue的结构"><a href="#第一节-ConcurrentLinkedQueue的结构" class="headerlink" title="第一节 ConcurrentLinkedQueue的结构"></a><strong>第一节 ConcurrentLinkedQueue的结构</strong></h2><p>&emsp;&emsp;通过ConcurrentLinkedQueue的类图来分析一下它的结构，如图6-3所示。</p><p><img src="https://pic-1258215793.cos.ap-shanghai.myqcloud.com/content/20190701/201907010103.png" alt="ConcurrentLinkedQueue的类图"></p><p>&emsp;&emsp;ConcurrentLinkedQueue由head节点和tail节点组成，每个节点（Node）由节点元素（item）和 指向下一个节点（next）的引用组成，节点与节点之间就是通过这个next关联起来，从而组成一 张链表结构的队列。默认情况下head节点存储的元素为空，tail节点等于head节点。</p><figure class="highlight crmsh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">private transient volatile <span class="keyword">Node</span><span class="title">&lt;E</span>&gt; tail = head;</span><br></pre></td></tr></table></figure><h2 id="第二节-入队列"><a href="#第二节-入队列" class="headerlink" title="第二节 入队列"></a><strong>第二节 入队列</strong></h2><p>&emsp;&emsp;本节将介绍入队列的相关知识。</p><h3 id="1-入队列的过程"><a href="#1-入队列的过程" class="headerlink" title="1 入队列的过程"></a><strong>1 入队列的过程</strong></h3><p>&emsp;&emsp;入队列就是将入队节点添加到队列的尾部。为了方便理解入队时队列的变化，以及head节 点和tail节点的变化，这里以一个示例来展开介绍。假设我们想在一个队列中依次插入4个节点，为了帮助大家理解，每添加一个节点就做了一个队列的快照图，如下图所示。</p><p><img src="https://pic-1258215793.cos.ap-shanghai.myqcloud.com/content/20190701/201907010104.png" alt="队列添加元素的快照图"></p><p>&emsp;&emsp;上图所示的过程如下。</p><ul><li>添加元素1。队列更新head节点的next节点为元素1节点。又因为tail节点默认情况下等于 head节点，所以它们的next节点都指向元素1节点。</li><li>添加元素2。队列首先设置元素1节点的next节点为元素2节点，然后更新tail节点指向元素2节点。</li><li>添加元素3，设置tail节点的next节点为元素3节点。</li><li>添加元素4，设置元素3的next节点为元素4节点，然后将tail节点指向元素4节点。</li></ul><p>&emsp;&emsp;通过调试入队过程并观察head节点和tail节点的变化，发现入队主要做两件事情：第一是 将入队节点设置成当前队列尾节点的下一个节点；第二是更新tail节点，如果tail节点的next节 点不为空，则将入队节点设置成tail节点，如果tail节点的next节点为空，则将入队节点设置成 tail的next节点，所以tail节点不总是尾节点（理解这一点对于我们研究源码会非常有帮助）。</p><p>&emsp;&emsp;通过对上面的分析，我们从单线程入队的角度理解了入队过程，但是多个线程同时进行入队的情况就变得更加复杂了，因为可能会出现其他线程插队的情况。如果有一个线程正在入队，那么它必须先获取尾节点，然后设置尾节点的下一个节点为入队节点，但这时可能有另外一个线程插队了，那么队列的尾节点就会发生变化，这时当前线程要暂停入队操作，然后重 新获取尾节点。让我们再通过源码来详细分析一下它是如何使用CAS算法来入队的。</p><figure class="highlight gradle"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">boolean</span> offer(E e) &#123;        </span><br><span class="line">    <span class="keyword">if</span> (e == <span class="keyword">null</span>) </span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> NullPointerException();    </span><br><span class="line">    <span class="comment">// 入队前，创建一个入队节点        </span></span><br><span class="line">    Node&lt;E&gt; n = <span class="keyword">new</span> Node&lt;E&gt;(e);        </span><br><span class="line">    retry:        </span><br><span class="line">    <span class="comment">// 死循环，入队不成功反复入队。        </span></span><br><span class="line">    <span class="keyword">for</span> (;;) &#123;            </span><br><span class="line">        <span class="comment">// 创建一个指向tail节点的引用            </span></span><br><span class="line">        Node&lt;E&gt; t = tail;            </span><br><span class="line">        <span class="comment">// p用来表示队列的尾节点，默认情况下等于tail节点。            </span></span><br><span class="line">        Node&lt;E&gt; p = t;            </span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> hops = <span class="number">0</span>; ; hops++) &#123;            </span><br><span class="line">            <span class="comment">// 获得p节点的下一个节点。                </span></span><br><span class="line">            Node&lt;E&gt; <span class="keyword">next</span> = succ(p);    </span><br><span class="line">            <span class="comment">// next节点不为空，说明p不是尾节点，需要更新p后在将它指向next节点                </span></span><br><span class="line">            <span class="keyword">if</span> (<span class="keyword">next</span> != <span class="keyword">null</span>) &#123;                    </span><br><span class="line">                <span class="comment">// 循环了两次及其以上，并且当前节点还是不等于尾节点                    </span></span><br><span class="line">                <span class="keyword">if</span> (hops &gt; HOPS &amp;&amp; t != tail)                        </span><br><span class="line">                    <span class="keyword">continue</span> retry;                     </span><br><span class="line">                p = <span class="keyword">next</span>;                </span><br><span class="line">            &#125;                </span><br><span class="line">            <span class="comment">// 如果p是尾节点，则设置p节点的next节点为入队节点。                </span></span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (p.casNext(<span class="keyword">null</span>, n)) &#123;                    </span><br><span class="line">                <span class="comment">/*如果tail节点有大于等于1个next节点，则将入队节点设置成tail节点，                      </span></span><br><span class="line"><span class="comment">                更新失败了也没关系，因为失败了表示有其他线程成功更新了tail节点*/</span> </span><br><span class="line">                <span class="keyword">if</span> (hops &gt;= HOPS)                        </span><br><span class="line">                    casTail(t, n); </span><br><span class="line">                    <span class="comment">// 更新tail节点，允许失败                    </span></span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">true</span>;                </span><br><span class="line">            &#125;                </span><br><span class="line">            <span class="comment">// p有next节点,表示p的next节点是尾节点，则重新设置p节点                </span></span><br><span class="line">            <span class="keyword">else</span> &#123;                    </span><br><span class="line">                p = succ(p);                </span><br><span class="line">            &#125;            </span><br><span class="line">        &#125;        </span><br><span class="line">    &#125;    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>&emsp;&emsp;从源代码角度来看，整个入队过程主要做两件事情：第一是定位出尾节点；第二是使用 CAS算法将入队节点设置成尾节点的next节点，如不成功则重试。</p><h3 id="2-定位尾节点"><a href="#2-定位尾节点" class="headerlink" title="2 定位尾节点"></a><strong>2 定位尾节点</strong></h3><p>&emsp;&emsp;tail节点并不总是尾节点，所以每次入队都必须先通过tail节点来找到尾节点。尾节点可能 是tail节点，也可能是tail节点的next节点。代码中循环体中的第一个if就是判断tail是否有next节 点，有则表示next节点可能是尾节点。获取tail节点的next节点需要注意的是p节点等于p的next 节点的情况，只有一种可能就是p节点和p的next节点都等于空，表示这个队列刚初始化，正准备添加节点，所以需要返回head节点。获取p节点的next节点代码如下。</p><figure class="highlight crmsh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">final <span class="keyword">Node</span><span class="title">&lt;E</span>&gt; succ(<span class="keyword">Node</span><span class="title">&lt;E</span>&gt; p) &#123;        </span><br><span class="line">    <span class="keyword">Node</span><span class="title">&lt;E</span>&gt; next = p.getNext();        </span><br><span class="line">    return (p == next)  </span><br><span class="line">    head : next;    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="3-设置入队节点为尾节点"><a href="#3-设置入队节点为尾节点" class="headerlink" title="3 设置入队节点为尾节点"></a><strong>3 设置入队节点为尾节点</strong></h3><p>&emsp;&emsp;p.casNext（null，n）方法用于将入队节点设置为当前队列尾节点的next节点，如果p是null， 表示p是当前队列的尾节点，如果不为null，表示有其他线程更新了尾节点，则需要重新获取当前队列的尾节点。</p><h3 id="4-HOPS的设计意图"><a href="#4-HOPS的设计意图" class="headerlink" title="4 HOPS的设计意图"></a><strong>4 HOPS的设计意图</strong></h3><p>&emsp;&emsp;上面分析过对于先进先出的队列入队所要做的事情是将入队节点设置成尾节点，doug lea写的代码和逻辑还是稍微有点复杂。那么，我用以下方式来实现是否可行？</p><figure class="highlight aspectj"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="function"><span class="keyword">boolean</span> <span class="title">offer</span><span class="params">(E e)</span> </span>&#123;        </span><br><span class="line">    <span class="keyword">if</span> (e == <span class="keyword">null</span>)                        </span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> NullPointerException();                </span><br><span class="line">    Node&lt;E&gt; n = <span class="keyword">new</span> Node&lt;E&gt;(e);                </span><br><span class="line">    <span class="keyword">for</span> (;;) &#123;                        </span><br><span class="line">        Node&lt;E&gt; t = tail;                        </span><br><span class="line">        <span class="keyword">if</span> (t.casNext(<span class="keyword">null</span>, n) &amp;&amp; casTail(t, n)) &#123;                                </span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">true</span>;                        </span><br><span class="line">        &#125;                </span><br><span class="line">    &#125;    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>&emsp;&emsp;让tail节点永远作为队列的尾节点，这样实现代码量非常少，而且逻辑清晰和易懂。但是， 这么做有个缺点，每次都需要使用循环CAS更新tail节点。如果能减少CAS更新tail节点的次 数，就能提高入队的效率，所以doug lea使用hops变量来控制并减少tail节点的更新频率，并不 是每次节点入队后都将tail节点更新成尾节点，而是当tail节点和尾节点的距离大于等于常量HOPS的值（默认等于1）时才更新tail节点，tail和尾节点的距离越长，使用CAS更新tail节点的次数就会越少，但是距离越长带来的负面效果就是每次入队时定位尾节点的时间就越长，因为循环体需要多循环一次来定位出尾节点，但是这样仍然能提高入队的效率，因为从本质上来 看它通过增加对volatile变量的读操作来减少对volatile变量的写操作，而对volatile变量的写操作开销要远远大于读操作，所以入队效率会有所提升。</p><figure class="highlight aspectj"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> HOPS = <span class="number">1</span>;</span><br></pre></td></tr></table></figure><p>&emsp;&emsp;注意入队方法永远返回true，所以不要通过返回值判断入队是否成功。</p><h2 id="第三节-出队列"><a href="#第三节-出队列" class="headerlink" title="第三节 出队列"></a><strong>第三节 出队列</strong></h2><p>&emsp;&emsp;出队列的就是从队列里返回一个节点元素，并清空该节点对元素的引用。让我们通过每 个节点出队的快照来观察一下head节点的变化，如图6-5所示。</p><p>&emsp;&emsp;从图中可知，并不是每次出队时都更新head节点，当head节点里有元素时，直接弹出head 节点里的元素，而不会更新head节点。只有当head节点里没有元素时，出队操作才会更新head 节点。这种做法也是通过hops变量来减少使用CAS更新head节点的消耗，从而提高出队效率。</p><p>&emsp;&emsp;让我们再通过源码来深入分析下出队过程。</p><p><img src="https://pic-1258215793.cos.ap-shanghai.myqcloud.com/content/20190701/201907010105.png" alt="队列出节点快照图"></p><figure class="highlight gradle"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> E poll() &#123;                </span><br><span class="line">    Node&lt;E&gt; h = head;        </span><br><span class="line">    <span class="comment">// p表示头节点，需要出队的节点</span></span><br><span class="line">    Node&lt;E&gt; p = h;                </span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> hops = <span class="number">0</span>;; hops++) &#123;                        </span><br><span class="line">        <span class="comment">// 获取p节点的元素                        </span></span><br><span class="line">        E item = p.getItem();                        </span><br><span class="line">        <span class="comment">// 如果p节点的元素不为空，使用CAS设置p节点引用的元素为null,                        </span></span><br><span class="line">        <span class="comment">// 如果成功则返回p节点的元素。                        </span></span><br><span class="line">        <span class="keyword">if</span> (item != <span class="keyword">null</span> &amp;&amp; p.casItem(item, <span class="keyword">null</span>)) &#123;                                </span><br><span class="line">            <span class="keyword">if</span> (hops &gt;= HOPS) &#123;                                        </span><br><span class="line">                <span class="comment">// 将p节点下一个节点设置成head节点                                        </span></span><br><span class="line">                Node&lt;E&gt; q = p.getNext();                                        </span><br><span class="line">                updateHead(h, (q != <span class="keyword">null</span>)  q : p);                                </span><br><span class="line">            &#125;                                </span><br><span class="line">            <span class="keyword">return</span> item;                        </span><br><span class="line">        &#125;                        </span><br><span class="line">        <span class="comment">// 如果头节点的元素为空或头节点发生了变化，这说明头节点已经被另外                        </span></span><br><span class="line">        <span class="comment">// 一个线程修改了。那么获取p节点的下一个节点                        </span></span><br><span class="line">        Node&lt;E&gt; <span class="keyword">next</span> = succ(p);                        </span><br><span class="line">        <span class="comment">// 如果p的下一个节点也为空，说明这个队列已经空了                        </span></span><br><span class="line">        <span class="keyword">if</span> (<span class="keyword">next</span> == <span class="keyword">null</span>) &#123;            </span><br><span class="line">            <span class="comment">// 更新头节点。                                </span></span><br><span class="line">            updateHead(h, p);                                </span><br><span class="line">            <span class="keyword">break</span>;                        </span><br><span class="line">        &#125;                        </span><br><span class="line">        <span class="comment">// 如果下一个元素不为空，则将头节点的下一个节点设置成头节点                        </span></span><br><span class="line">        p = <span class="keyword">next</span>;                </span><br><span class="line">    &#125;               </span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">null</span>;        </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>&emsp;&emsp;首先获取头节点的元素，然后判断头节点元素是否为空，如果为空，表示另外一个线程已经进行了一次出队操作将该节点的元素取走，如果不为空，则使用CAS的方式将头节点的引用设置成null，如果CAS成功，则直接返回头节点的元素，如果不成功，表示另外一个线程已经进行了一次出队操作更新了head节点，导致元素发生了变化，需要重新获取头节点。</p><hr><p><em>参考博客和文章书籍等：</em></p><blockquote><p>《Java并发编程的艺术》</p></blockquote><p><em>因博客主等未标明不可引用，若部分内容涉及侵权请及时告知，我会尽快修改和删除相关内容</em></p>]]></content>
    
    <summary type="html">
    
      介绍Java中ConcurrentLinkedQueue的实现原理。
    
    </summary>
    
      <category term="技术文档" scheme="http://linyishui.top/categories/%E6%8A%80%E6%9C%AF%E6%96%87%E6%A1%A3/"/>
    
    
      <category term="java" scheme="http://linyishui.top/tags/java/"/>
    
      <category term="lock" scheme="http://linyishui.top/tags/lock/"/>
    
  </entry>
  
  <entry>
    <title>ConcurrentHashMap的实现原理与使用</title>
    <link href="http://linyishui.top/2019082301.html"/>
    <id>http://linyishui.top/2019082301.html</id>
    <published>2019-08-23T07:53:56.000Z</published>
    <updated>2019-10-10T09:30:14.258Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="ConcurrentHashMap的实现原理与使用"><a href="#ConcurrentHashMap的实现原理与使用" class="headerlink" title="ConcurrentHashMap的实现原理与使用"></a><strong>ConcurrentHashMap的实现原理与使用</strong></h1><p>&emsp;&emsp;Java程序员进行并发编程时，相比于其他语言的程序员而言要倍感幸福，因为并发编程大师Doug Lea不遗余力地为Java开发者提供了非常多的并发容器和框架。本章让我们一起来见识一下大师操刀编写的并发容器和框架，并通过每节的原理分析一起来学习如何设计出精妙的并发程序。</p><p>&emsp;&emsp;ConcurrentHashMap是线程安全且高效的HashMap。本节让我们一起研究一下该容器是如何在保证线程安全的同时又能保证高效的操作。</p><h2 id="第一节-为什么要使用ConcurrentHashMap"><a href="#第一节-为什么要使用ConcurrentHashMap" class="headerlink" title="第一节 为什么要使用ConcurrentHashMap"></a><strong>第一节 为什么要使用ConcurrentHashMap</strong></h2><p>&emsp;&emsp;在并发编程中使用HashMap可能导致程序死循环。而使用线程安全的HashTable效率又非 常低下，基于以上两个原因，便有了ConcurrentHashMap的登场机会。</p><h3 id="1-线程不安全的HashMap"><a href="#1-线程不安全的HashMap" class="headerlink" title="1 线程不安全的HashMap"></a><strong>1 线程不安全的HashMap</strong></h3><p>&emsp;&emsp;在多线程环境下，使用HashMap进行put操作会引起死循环，导致CPU利用率接近100%，所 以在并发情况下不能使用HashMap。例如，执行以下代码会引起死循环。</p><figure class="highlight processing"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">final</span> <span class="keyword">HashMap</span>&lt;<span class="keyword">String</span>, <span class="keyword">String</span>&gt; <span class="built_in">map</span> = <span class="keyword">new</span> <span class="keyword">HashMap</span>&lt;<span class="keyword">String</span>, <span class="keyword">String</span>&gt;(<span class="number">2</span>);        </span><br><span class="line">Thread t = <span class="keyword">new</span> Thread(<span class="keyword">new</span> Runnable() &#123;            </span><br><span class="line">    @Override            </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> run() &#123;                </span><br><span class="line">        <span class="keyword">for</span> (<span class="built_in">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10000</span>; i++) &#123;                    </span><br><span class="line">            <span class="keyword">new</span> Thread(<span class="keyword">new</span> Runnable() &#123;                        </span><br><span class="line">                @Override                        </span><br><span class="line">                <span class="keyword">public</span> <span class="keyword">void</span> run() &#123;                            </span><br><span class="line">                    <span class="built_in">map</span>.put(UUID.randomUUID().toString(), <span class="string">""</span>);                        </span><br><span class="line">                &#125;                    </span><br><span class="line">            &#125;, <span class="string">"ftf"</span> + i).start();                </span><br><span class="line">        &#125;            </span><br><span class="line">    &#125;        </span><br><span class="line">&#125;, <span class="string">"ftf"</span>);        </span><br><span class="line">t.start();        </span><br><span class="line">t.<span class="built_in">join</span>();</span><br></pre></td></tr></table></figure><p>&emsp;&emsp;HashMap在并发执行put操作时会引起死循环，是因为多线程会导致HashMap的Entry链表形成环形数据结构，一旦形成环形数据结构，Entry的next节点永远不为空，就会产生死循环获取Entry。</p><h3 id="2-效率低下的HashTable"><a href="#2-效率低下的HashTable" class="headerlink" title="2 效率低下的HashTable"></a><strong>2 效率低下的HashTable</strong></h3><p>&emsp;&emsp;HashTable容器使用synchronized来保证线程安全，但在线程竞争激烈的情况下HashTable的效率非常低下。因为当一个线程访问HashTable的同步方法，其他线程也访问HashTable的同步方法时，会进入阻塞或轮询状态。如线程1使用put进行元素添加，线程2不但不能使用put方法添加元素，也不能使用get方法来获取元素，所以竞争越激烈效率越低。</p><h3 id="3-ConcurrentHashMap的锁分段技术可有效提升并发访问率"><a href="#3-ConcurrentHashMap的锁分段技术可有效提升并发访问率" class="headerlink" title="3 ConcurrentHashMap的锁分段技术可有效提升并发访问率"></a><strong>3 ConcurrentHashMap的锁分段技术可有效提升并发访问率</strong></h3><p>&emsp;&emsp;HashTable容器在竞争激烈的并发环境下表现出效率低下的原因是所有访问HashTable的线程都必须竞争同一把锁，假如容器里有多把锁，每一把锁用于锁容器其中一部分数据，那么当多线程访问容器里不同数据段的数据时，线程间就不会存在锁竞争，从而可以有效提高并发访问效率，这就是ConcurrentHashMap所使用的锁分段技术。首先将数据分成一段一段地存储，然后给每一段数据配一把锁，当一个线程占用锁访问其中一个段数据的时候，其他段的数据也能被其他线程访问。</p><h2 id="第二节-ConcurrentHashMap的结构"><a href="#第二节-ConcurrentHashMap的结构" class="headerlink" title="第二节 ConcurrentHashMap的结构"></a><strong>第二节 ConcurrentHashMap的结构</strong></h2><p>&emsp;&emsp;通过ConcurrentHashMap的类图来分析ConcurrentHashMap的结构，如图6-1所示。ConcurrentHashMap是由Segment数组结构和HashEntry数组结构组成。Segment是一种可重入锁（ReentrantLock），在ConcurrentHashMap里扮演锁的角色；HashEntry则用于存储键值对数 据。一个ConcurrentHashMap里包含一个Segment数组。</p><p>&emsp;&emsp;Segment的结构和HashMap类似，是一种数组和链表结构。一个Segment里包含一个HashEntry数组，每个HashEntry是一个链表结构的元素，每个Segment守护着一个HashEntry数组里的元素，当对HashEntry数组的数据进行修改时，必须首先获得与它对应的Segment锁，如下图所示。</p><p><img src="https://pic-1258215793.cos.ap-shanghai.myqcloud.com/content/20190701/201907010101.png" alt="ConcurrentHashMap的类图"></p><p><img src="https://pic-1258215793.cos.ap-shanghai.myqcloud.com/content/20190701/201907010102.png" alt="ConcurrentHashMap的结构图"></p><h2 id="第三节-ConcurrentHashMap的初始化"><a href="#第三节-ConcurrentHashMap的初始化" class="headerlink" title="第三节 ConcurrentHashMap的初始化"></a><strong>第三节 ConcurrentHashMap的初始化</strong></h2><p>&emsp;&emsp;ConcurrentHashMap初始化方法是通过initialCapacity、loadFactor和concurrencyLevel等几个参数来初始化segment数组、段偏移量segmentShift、段掩码segmentMask和每个segment里的HashEntry数组来实现的。</p><h3 id="1-初始化segments数组"><a href="#1-初始化segments数组" class="headerlink" title="1 初始化segments数组"></a><strong>1 初始化segments数组</strong></h3><p>&emsp;&emsp;让我们来看一下初始化segments数组的源代码。</p><figure class="highlight mipsasm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">if (concurrencyLevel &gt; MAX_SEGMENTS)            </span><br><span class="line">    concurrencyLevel = MAX_SEGMENTS<span class="comment">;        </span></span><br><span class="line">int sshift = <span class="number">0</span><span class="comment">;        </span></span><br><span class="line">int ssize = <span class="number">1</span><span class="comment">;       </span></span><br><span class="line">while (ssize &lt; concurrencyLevel) &#123;            </span><br><span class="line">    ++sshift<span class="comment">;            </span></span><br><span class="line">    ssize &lt;&lt;= <span class="number">1</span><span class="comment">;        </span></span><br><span class="line">&#125;        </span><br><span class="line"></span><br><span class="line">segmentShift = <span class="number">32</span> - sshift<span class="comment">;        </span></span><br><span class="line">segmentMask = ssize - <span class="number">1</span><span class="comment">;        </span></span><br><span class="line">this.segments = Segment.newArray(ssize)<span class="comment">;</span></span><br></pre></td></tr></table></figure><p>&emsp;&emsp;由上面的代码可知，segments数组的长度ssize是通过concurrencyLevel计算得出的。为了能 通过按位与的散列算法来定位segments数组的索引，必须保证segments数组的长度是2的N次方 （power-of-two size），所以必须计算出一个大于或等于concurrencyLevel的最小的2的N次方值 来作为segments数组的长度。假如concurrencyLevel等于14、15或16，ssize都会等于16，即容器里锁的个数也是16。</p><p>&emsp;&emsp;注意concurrencyLevel的最大值是65535，这意味着segments数组的长度最大为65536，对应的二进制是16位。</p><h3 id="2-初始化segmentShift和segmentMask"><a href="#2-初始化segmentShift和segmentMask" class="headerlink" title="2 初始化segmentShift和segmentMask"></a><strong>2 初始化segmentShift和segmentMask</strong></h3><p>&emsp;&emsp;这两个全局变量需要在定位segment时的散列算法里使用，sshift等于ssize从1向左移位的次数，在默认情况下concurrencyLevel等于16，1需要向左移位移动4次，所以sshift等于4。 segmentShift用于定位参与散列运算的位数，segmentShift等于32减sshift，所以等于28，这里之所 以用32是因为ConcurrentHashMap里的hash()方法输出的最大数是32位的，后面的测试中我们可以看到这点。segmentMask是散列运算的掩码，等于ssize减1，即15，掩码的二进制各个位的值都是1。因为ssize的最大长度是65536，所以segmentShift最大值是16，segmentMask最大值是65535，对应的二进制是16位，每个位都是1。</p><h3 id="3-初始化每个segment"><a href="#3-初始化每个segment" class="headerlink" title="3 初始化每个segment"></a><strong>3 初始化每个segment</strong></h3><p>&emsp;&emsp;输入参数initialCapacity是ConcurrentHashMap的初始化容量，loadfactor是每个segment的负载因子，在构造方法里需要通过这两个参数来初始化数组中的每个segment。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (initialCapacity &gt; MAXIMUM_CAPACITY)            </span><br><span class="line">    initialCapacity = MAXIMUM_CAPACITY;   </span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> c = initialCapacity / ssize;     </span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (c * ssize &lt; initialCapacity)            </span><br><span class="line">    ++c;    </span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> <span class="built_in">cap</span> = <span class="number">1</span>; </span><br><span class="line"></span><br><span class="line">while (<span class="built_in">cap</span> &lt; c)            </span><br><span class="line">    <span class="built_in">cap</span> &lt;&lt;= <span class="number">1</span>;        </span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; this.segments.length; ++i)            </span><br><span class="line">    this.segments[i] = <span class="built_in">new</span> Segment&lt;K,V&gt;(<span class="built_in">cap</span>, loadFactor);</span><br></pre></td></tr></table></figure><p>&emsp;&emsp;上面代码中的变量cap就是segment里HashEntry数组的长度，它等于initialCapacity除以ssize 的倍数c，如果c大于1，就会取大于等于c的2的N次方值，所以cap不是1，就是2的N次方。 segment的容量threshold＝（int）cap*loadFactor，默认情况下initialCapacity等于16，loadfactor等于 0.75，通过运算cap等于1，threshold等于零。</p><h2 id="第四节-定位Segment"><a href="#第四节-定位Segment" class="headerlink" title="第四节 定位Segment"></a><strong>第四节 定位Segment</strong></h2><p>&emsp;&emsp;既然ConcurrentHashMap使用分段锁Segment来保护不同段的数据，那么在插入和获取元素的时候，必须先通过散列算法定位到Segment。可以看到ConcurrentHashMap会首先使用Wang/Jenkins hash的变种算法对元素的hashCode进行一次再散列。</p><figure class="highlight nginx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="attribute">private</span> static int hash(int h) &#123;        </span><br><span class="line">    <span class="attribute">h</span> += (h &lt;&lt; <span class="number">15</span>)<span class="regexp"> ^</span> 0xffffcd7d;        </span><br><span class="line">    <span class="attribute">h</span><span class="regexp"> ^=</span> (h &gt;&gt;&gt; <span class="number">10</span>);       </span><br><span class="line">    <span class="attribute">h</span> += (h &lt;&lt; <span class="number">3</span>);        </span><br><span class="line">    <span class="attribute">h</span><span class="regexp"> ^=</span> (h &gt;&gt;&gt; <span class="number">6</span>);        </span><br><span class="line">    <span class="attribute">h</span> += (h &lt;&lt; <span class="number">2</span>) + (h &lt;&lt; <span class="number">14</span>);        </span><br><span class="line">    <span class="attribute">return</span> h<span class="regexp"> ^</span> (h &gt;&gt;&gt; <span class="number">16</span>);    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>&emsp;&emsp;之所以进行再散列，目的是减少散列冲突，使元素能够均匀地分布在不同的Segment上，从而提高容器的存取效率。假如散列的质量差到极点，那么所有的元素都在一个Segment中，不仅存取元素缓慢，分段锁也会失去意义。笔者做了一个测试，不通过再散列而直接执行散列计算。</p><figure class="highlight arduino"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">System.out.<span class="built_in">println</span>(Integer.<span class="built_in">parseInt</span>(<span class="string">"0001111"</span>, <span class="number">2</span>) &amp; <span class="number">15</span>); </span><br><span class="line">System.out.<span class="built_in">println</span>(Integer.<span class="built_in">parseInt</span>(<span class="string">"0011111"</span>, <span class="number">2</span>) &amp; <span class="number">15</span>); </span><br><span class="line">System.out.<span class="built_in">println</span>(Integer.<span class="built_in">parseInt</span>(<span class="string">"0111111"</span>, <span class="number">2</span>) &amp; <span class="number">15</span>); </span><br><span class="line">System.out.<span class="built_in">println</span>(Integer.<span class="built_in">parseInt</span>(<span class="string">"1111111"</span>, <span class="number">2</span>) &amp; <span class="number">15</span>);</span><br></pre></td></tr></table></figure><p>&emsp;&emsp;计算后输出的散列值全是15，通过这个例子可以发现，如果不进行再散列，散列冲突会非常严重，因为只要低位一样，无论高位是什么数，其散列值总是一样。我们再把上面的二进制数据进行再散列后结果如下（为了方便阅读，不足32位的高位补了0，每隔4位用竖线分割下）。</p><figure class="highlight lsl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">0100</span>｜<span class="number">0111</span>｜<span class="number">0110</span>｜<span class="number">0111</span>｜<span class="number">1101</span>｜<span class="number">1010</span>｜<span class="number">0100</span>｜<span class="number">1110</span> </span><br><span class="line"><span class="number">1111</span>｜<span class="number">0111</span>｜<span class="number">0100</span>｜<span class="number">0011</span>｜<span class="number">0000</span>｜<span class="number">0001</span>｜<span class="number">1011</span>｜<span class="number">1000</span> </span><br><span class="line"><span class="number">0111</span>｜<span class="number">0111</span>｜<span class="number">0110</span>｜<span class="number">1001</span>｜<span class="number">0100</span>｜<span class="number">0110</span>｜<span class="number">0011</span>｜<span class="number">1110</span> </span><br><span class="line"><span class="number">1000</span>｜<span class="number">0011</span>｜<span class="number">0000</span>｜<span class="number">0000</span>｜<span class="number">1100</span>｜<span class="number">1000</span>｜<span class="number">0001</span>｜<span class="number">1010</span></span><br></pre></td></tr></table></figure><p>&emsp;&emsp;可以发现，每一位的数据都散列开了，通过这种再散列能让数字的每一位都参加到散列运算当中，从而减少散列冲突。ConcurrentHashMap通过以下散列算法定位segment。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">final</span> Segment&lt;K,V&gt; <span class="title">segmentFor</span><span class="params">(<span class="keyword">int</span> hash)</span> </span>&#123;        </span><br><span class="line">    <span class="keyword">return</span> segments[(hash &gt;&gt;&gt; segmentShift) &amp; segmentMask];    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>&emsp;&emsp;默认情况下segmentShift为28，segmentMask为15，再散列后的数最大是32位二进制数据，向右无符号移动28位，意思是让高4位参与到散列运算中，（hash&gt;&gt;&gt;segmentShift） &amp;segmentMask的运算结果分别是4、15、7和8，可以看到散列值没有发生冲突。</p><h2 id="第五节-ConcurrentHashMap的操作"><a href="#第五节-ConcurrentHashMap的操作" class="headerlink" title="第五节 ConcurrentHashMap的操作"></a><strong>第五节 ConcurrentHashMap的操作</strong></h2><p>&emsp;&emsp;本节介绍ConcurrentHashMap的3种操作——get操作、put操作和size操作。</p><h3 id="1-get操作"><a href="#1-get操作" class="headerlink" title="1 get操作"></a><strong>1 get操作</strong></h3><p>&emsp;&emsp;Segment的get操作实现非常简单和高效。先经过一次再散列，然后使用这个散列值通过散 列运算定位到Segment，再通过散列算法定位到元素，代码如下。</p><figure class="highlight processing"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> V <span class="built_in">get</span>(<span class="keyword">Object</span> <span class="built_in">key</span>) &#123;        </span><br><span class="line">    <span class="built_in">int</span> hash = hash(<span class="built_in">key</span>.hashCode());        </span><br><span class="line">    <span class="keyword">return</span> segmentFor(hash).<span class="built_in">get</span>(<span class="built_in">key</span>, hash);    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>&emsp;&emsp;get操作的高效之处在于整个get过程不需要加锁，除非读到的值是空才会加锁重读。我们 知道HashTable容器的get方法是需要加锁的，那么ConcurrentHashMap的get操作是如何做到不 加锁的呢？原因是它的get方法里将要使用的共享变量都定义成volatile类型，如用于统计当前 Segement大小的count字段和用于存储值的HashEntry的value。定义成volatile的变量，能够在线程之间保持可见性，能够被多线程同时读，并且保证不会读到过期的值，但是只能被单线程写 （有一种情况可以被多线程写，就是写入的值不依赖于原值），在get操作里只需要读不需要写 共享变量count和value，所以可以不用加锁。之所以不会读到过期的值，是因为根据Java内存模 型的happen before原则，对volatile字段的写入操作先于读操作，即使两个线程同时修改和获取 volatile变量，get操作也能拿到最新的值，这是用volatile替换锁的经典应用场景。</p><figure class="highlight fortran"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">transient <span class="keyword">volatile</span> <span class="built_in">int</span> <span class="built_in">count</span>; </span><br><span class="line"><span class="keyword">volatile</span> V <span class="keyword">value</span>;</span><br></pre></td></tr></table></figure><p>&emsp;&emsp;在定位元素的代码里我们可以发现，定位HashEntry和定位Segment的散列算法虽然一样， 都与数组的长度减去1再相“与”，但是相“与”的值不一样，定位Segment使用的是元素的 hashcode通过再散列后得到的值的高位，而定位HashEntry直接使用的是再散列后的值。其目的是避免两次散列后的值一样，虽然元素在Segment里散列开了，但是却没有在HashEntry里散列开。</p><figure class="highlight glsl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">hash &gt;&gt;&gt; segmentShift) &amp; segmentMask　<span class="comment">// 定位Segment所使用的hash算法 </span></span><br><span class="line"><span class="type">int</span> <span class="keyword">index</span> = hash &amp; (tab.<span class="built_in">length</span> - <span class="number">1</span>);　<span class="comment">// 定位HashEntry所使用的hash算法</span></span><br></pre></td></tr></table></figure><h3 id="2-put操作"><a href="#2-put操作" class="headerlink" title="2 put操作"></a><strong>2 put操作</strong></h3><p>&emsp;&emsp;由于put方法里需要对共享变量进行写入操作，所以为了线程安全，在操作共享变量时必 须加锁。put方法首先定位到Segment，然后在Segment里进行插入操作。插入操作需要经历两个步骤，第一步判断是否需要对Segment里的HashEntry数组进行扩容，第二步定位添加元素的位置，然后将其放在HashEntry数组里。</p><p>（1）是否需要扩容</p><p>&emsp;&emsp;在插入元素前会先判断Segment里的HashEntry数组是否超过容量（threshold），如果超过阈值，则对数组进行扩容。值得一提的是，Segment的扩容判断比HashMap更恰当，因为HashMap是在插入元素后判断元素是否已经到达容量的，如果到达了就进行扩容，但是很有可能扩容 之后没有新元素插入，这时HashMap就进行了一次无效的扩容。</p><p>（2）如何扩容</p><p>&emsp;&emsp;在扩容的时候，首先会创建一个容量是原来容量两倍的数组，然后将原数组里的元素进 行再散列后插入到新的数组里。为了高效，ConcurrentHashMap不会对整个容器进行扩容，而只对某个segment进行扩容。</p><h3 id="3-size操作"><a href="#3-size操作" class="headerlink" title="3 size操作"></a><strong>3 size操作</strong></h3><p>&emsp;&emsp;如果要统计整个ConcurrentHashMap里元素的大小，就必须统计所有Segment里元素的大小 后求和。Segment里的全局变量count是一个volatile变量，那么在多线程场景下，是不是直接把所有Segment的count相加就可以得到整个ConcurrentHashMap大小了呢？不是的，虽然相加时 可以获取每个Segment的count的最新值，但是可能累加前使用的count发生了变化，那么统计结 果就不准了。所以，最安全的做法是在统计size的时候把所有Segment的put、remove和clean方法<br>全部锁住，但是这种做法显然非常低效。</p><p>&emsp;&emsp;因为在累加count操作过程中，之前累加过的count发生变化的几率非常小，所以 ConcurrentHashMap的做法是先尝试2次通过不锁住Segment的方式来统计各个Segment大小，如 果统计的过程中，容器的count发生了变化，则再采用加锁的方式来统计所有Segment的大小。</p><p>&emsp;&emsp;那么ConcurrentHashMap是如何判断在统计的时候容器是否发生了变化呢？使用modCount 变量，在put、remove和clean方法里操作元素前都会将变量modCount进行加1，那么在统计size 前后比较modCount是否发生变化，从而得知容器的大小是否发生变化。</p><hr><p><em>参考博客和文章书籍等：</em></p><blockquote><p>《Java并发编程的艺术》</p></blockquote><p><em>因博客主等未标明不可引用，若部分内容涉及侵权请及时告知，我会尽快修改和删除相关内容</em></p>]]></content>
    
    <summary type="html">
    
      介绍Java中ConcurrentHashMap的实现原理与使用。
    
    </summary>
    
      <category term="技术文档" scheme="http://linyishui.top/categories/%E6%8A%80%E6%9C%AF%E6%96%87%E6%A1%A3/"/>
    
    
      <category term="java" scheme="http://linyishui.top/tags/java/"/>
    
      <category term="lock" scheme="http://linyishui.top/tags/lock/"/>
    
  </entry>
  
  <entry>
    <title>基于CAS+Pa4j+Spring Boot+Shiro实现单点登录</title>
    <link href="http://linyishui.top/2019082201.html"/>
    <id>http://linyishui.top/2019082201.html</id>
    <published>2019-08-22T06:38:20.000Z</published>
    <updated>2019-10-10T03:04:16.503Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="基于CAS-Pa4j-Spring-Boot-Shiro实现单点登录"><a href="#基于CAS-Pa4j-Spring-Boot-Shiro实现单点登录" class="headerlink" title="基于CAS+Pa4j+Spring Boot+Shiro实现单点登录"></a><strong>基于CAS+Pa4j+Spring Boot+Shiro实现单点登录</strong></h1><hr><h2 id="1-依赖"><a href="#1-依赖" class="headerlink" title="1.依赖"></a><strong>1.依赖</strong></h2><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!-- shiro --&gt;</span></span><br><span class="line"> <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">     <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.apache.shiro<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">     <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>shiro-core<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">     <span class="tag">&lt;<span class="name">version</span>&gt;</span>1.4.0<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"> <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"> <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">     <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.apache.shiro<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">     <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>shiro-spring<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">     <span class="tag">&lt;<span class="name">version</span>&gt;</span>1.4.0<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"> <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"> <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">     <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>com.auth0<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">     <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>java-jwt<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">     <span class="tag">&lt;<span class="name">version</span>&gt;</span>3.2.0<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"> <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"> <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">     <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.apache.shiro<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">     <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>shiro-ehcache<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">     <span class="tag">&lt;<span class="name">version</span>&gt;</span>1.4.0<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"> <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"></span><br><span class="line"> <span class="comment">&lt;!-- pac4j --&gt;</span></span><br><span class="line"> <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">     <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.pac4j<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">     <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>pac4j-cas<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">     <span class="tag">&lt;<span class="name">version</span>&gt;</span>3.0.2<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"> <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"> <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">     <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.pac4j<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">     <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>pac4j-http<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">     <span class="tag">&lt;<span class="name">version</span>&gt;</span>3.0.2<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"> <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"> <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">     <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.pac4j<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">     <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>pac4j-jwt<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">     <span class="tag">&lt;<span class="name">version</span>&gt;</span>3.0.2<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"> <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"> <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">     <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>io.buji<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">     <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>buji-pac4j<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">     <span class="tag">&lt;<span class="name">version</span>&gt;</span>4.0.0<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">     <span class="tag">&lt;<span class="name">exclusions</span>&gt;</span></span><br><span class="line">         <span class="tag">&lt;<span class="name">exclusion</span>&gt;</span></span><br><span class="line">             <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>shiro-web<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">             <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.apache.shiro<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">         <span class="tag">&lt;/<span class="name">exclusion</span>&gt;</span></span><br><span class="line">     <span class="tag">&lt;/<span class="name">exclusions</span>&gt;</span></span><br><span class="line"> <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure><hr><h2 id="2-配置部分"><a href="#2-配置部分" class="headerlink" title="2.配置部分"></a><strong>2.配置部分</strong></h2><p>&emsp;&emsp;Pac4jConfig对PAC4J相关部件进行配置</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Pac4jConfig</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Value</span>(<span class="string">"$&#123;cas.casServerLoginUrl&#125;"</span>)</span><br><span class="line">    <span class="keyword">private</span> String casServerLoginUrl;</span><br><span class="line">    <span class="comment">/** 地址为：cas地址 */</span></span><br><span class="line">    <span class="meta">@Value</span>(<span class="string">"$&#123;cas.casServerUrlPrefix&#125;"</span>)</span><br><span class="line">    <span class="keyword">private</span> String casServerUrlPrefix;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/** 地址为：验证返回后的项目地址：http://localhost:8081 */</span></span><br><span class="line">    <span class="meta">@Value</span>(<span class="string">"$&#123;cas.serverName&#125;"</span>)</span><br><span class="line">    <span class="keyword">private</span> String projectUrl;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/** 相当于一个标志，可以随意 */</span></span><br><span class="line">    <span class="meta">@Value</span>(<span class="string">"$&#123;cas.client-name&#125;"</span>)</span><br><span class="line">    <span class="keyword">private</span> String clientName;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/** 地址为：cas地址 */</span></span><br><span class="line">    <span class="meta">@Value</span>(<span class="string">"$&#123;cas.callbackUrl&#125;"</span>)</span><br><span class="line">    <span class="keyword">private</span> String callbackUrl;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * JWT Token 生成器，对CommonProfile生成然后每次携带token访问</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> JwtGenerator</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@SuppressWarnings</span>(<span class="string">"rawtypes"</span>)</span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> JwtGenerator <span class="title">jwtGenerator</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> JwtGenerator(<span class="keyword">new</span> SecretSignatureConfiguration(SecurityConsts.LOGIN_SALT.getValue()),</span><br><span class="line">                <span class="keyword">new</span> SecretEncryptionConfiguration(SecurityConsts.LOGIN_SALT.getValue()));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * JwtAuthenticator用于认证由JwtGenerator或其他方法生成的JWT令牌，即JWT校验器</span></span><br><span class="line"><span class="comment">     * 即目前设置的ParameterClient-jwtClient进行的校验器，是rest或者前后端分离的核心校验器</span></span><br><span class="line"><span class="comment">     * HTTP客户端验证凭证需要一个认证器。它是ProfileService的一个子组件，该组件验证凭证，同时也处理用户的创建、更新和移除操作。</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> JwtAuthenticator</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> JwtAuthenticator <span class="title">jwtAuthenticator</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        JwtAuthenticator jwtAuthenticator = <span class="keyword">new</span> JwtAuthenticator();</span><br><span class="line">        <span class="comment">//签名配置：SecretSignatureConfiguration，RSASignatureConfiguration，ECEncryptionConfiguration</span></span><br><span class="line">        jwtAuthenticator.addSignatureConfiguration(<span class="keyword">new</span> SecretSignatureConfiguration(SecurityConsts.LOGIN_SALT.getValue()));</span><br><span class="line">        <span class="comment">//加密配置：SecretEncryptionConfiguration，RSAEncryptionConfiguration，ECEncryptionConfiguration</span></span><br><span class="line">        jwtAuthenticator.addEncryptionConfiguration(<span class="keyword">new</span> SecretEncryptionConfiguration(SecurityConsts.LOGIN_SALT.getValue()));</span><br><span class="line">        <span class="keyword">return</span> jwtAuthenticator;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 请求cas服务端配置</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> CasConfiguration <span class="title">casConfig</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">final</span> CasConfiguration configuration = <span class="keyword">new</span> CasConfiguration();</span><br><span class="line">        <span class="comment">//CAS server登录地址</span></span><br><span class="line">        configuration.setLoginUrl(casServerLoginUrl);</span><br><span class="line">        <span class="comment">//CAS 版本，默认为 CAS30</span></span><br><span class="line">        configuration.setProtocol(CasProtocol.CAS20);</span><br><span class="line">        configuration.setAcceptAnyProxy(<span class="keyword">true</span>);</span><br><span class="line">        configuration.setPrefixUrl(casServerUrlPrefix);</span><br><span class="line">        configuration.setLogoutHandler(<span class="keyword">new</span> ShiroCasLogoutHandler());</span><br><span class="line">        <span class="keyword">return</span> configuration;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 配置多个Client，每个Client对应一种登陆协议，可以在Clients中配置所有协议，默认Client，以及如何区分回调哪个Client</span></span><br><span class="line"><span class="comment">     * client支持多种认证机制：OAuth、SAML、CAS、OpenID Connect、HTTP、OpenID、Google APP Engine、Kerberos(SPNEGO)</span></span><br><span class="line"><span class="comment">     * Authenticators：LDAP、SQL、JWT、MongoDB、CouchDB、IP address、REST API</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> casClient</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> Clients</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> Clients <span class="title">clients</span><span class="params">(CasClient casClient,</span></span></span><br><span class="line"><span class="function"><span class="params">                              CasRestFormClient casRestFormClient,</span></span></span><br><span class="line"><span class="function"><span class="params">                              ParameterClient jwtClient,</span></span></span><br><span class="line"><span class="function"><span class="params">                              FormClient formClient,</span></span></span><br><span class="line"><span class="function"><span class="params">                              IndirectBasicAuthClient ibaClient,</span></span></span><br><span class="line"><span class="function"><span class="params">                              DirectBasicAuthClient dbaClient)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//可以设置默认client</span></span><br><span class="line">        Clients clients = <span class="keyword">new</span> Clients();</span><br><span class="line">        <span class="comment">//支持的client全部设置进去</span></span><br><span class="line">        clients.setClients(casClient,casRestFormClient,jwtClient,formClient,ibaClient,dbaClient);</span><br><span class="line">        clients.setCallbackUrl(<span class="string">"https://localhost:8443/"</span>);</span><br><span class="line">        <span class="keyword">return</span> clients;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * cas客户端配置</span></span><br><span class="line"><span class="comment">     * 客户端表示身份验证机制（流）。它执行登录过程并返回一个用户概要文件。</span></span><br><span class="line"><span class="comment">     * 间接客户端用于UI身份验证，而直接客户端则用于web服务身份验证。</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> casConfig 配置通过客户端、授权器和匹配器定义安全配置</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> cas客户端</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> CasClient <span class="title">casClient</span><span class="params">(CasConfiguration casConfig)</span></span>&#123;</span><br><span class="line">        CasClient casClient = <span class="keyword">new</span> CasClient(casConfig);</span><br><span class="line">        <span class="comment">//客户端回调地址</span></span><br><span class="line">        casClient.setCallbackUrl(callbackUrl);</span><br><span class="line">        casClient.setName(clientName);</span><br><span class="line">        <span class="keyword">return</span> casClient;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 通过rest接口可以获取tgt,获取service ticket,甚至可以获取casProfile</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> CasRestFormClient</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> CasRestFormClient <span class="title">casRestFormClient</span><span class="params">(CasConfiguration casConfig)</span></span>&#123;</span><br><span class="line">        CasRestFormClient casRestFormClient = <span class="keyword">new</span> CasRestFormClient();</span><br><span class="line">        casRestFormClient.setConfiguration(casConfig);</span><br><span class="line">        casRestFormClient.setName(<span class="string">"rest"</span>);</span><br><span class="line">        <span class="keyword">return</span> casRestFormClient;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> ParameterClient <span class="title">jwtClient</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="comment">// token校验器，可以用HeaderClient更安全</span></span><br><span class="line">        ParameterClient jwtClient = <span class="keyword">new</span> ParameterClient(<span class="string">"token"</span>, jwtAuthenticator());</span><br><span class="line">        jwtClient.setSupportGetRequest(<span class="keyword">true</span>);</span><br><span class="line">        jwtClient.setSupportPostRequest(<span class="keyword">true</span>);</span><br><span class="line">        jwtClient.setName(<span class="string">"jwt"</span>);</span><br><span class="line">        <span class="keyword">return</span> jwtClient;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> FormClient <span class="title">formClient</span><span class="params">()</span></span>&#123;</span><br><span class="line">        FormClient formClient = <span class="keyword">new</span> FormClient();</span><br><span class="line">        formClient.setLoginUrl(<span class="string">"https://localhost:8443/loginForm.html"</span>);</span><br><span class="line">        formClient.setName(<span class="string">"form"</span>);</span><br><span class="line">        formClient.setAuthenticator(<span class="keyword">new</span> SimpleTestUsernamePasswordAuthenticator());</span><br><span class="line">        <span class="keyword">return</span> formClient;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> IndirectBasicAuthClient <span class="title">ibaClient</span><span class="params">()</span></span>&#123;</span><br><span class="line">        IndirectBasicAuthClient ibaClient = <span class="keyword">new</span> IndirectBasicAuthClient();</span><br><span class="line">        ibaClient.setName(<span class="string">"iba"</span>);</span><br><span class="line">        ibaClient.setAuthenticator(<span class="keyword">new</span> SimpleTestUsernamePasswordAuthenticator());</span><br><span class="line">        <span class="keyword">return</span> ibaClient;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> DirectBasicAuthClient <span class="title">dbaClient</span><span class="params">()</span></span>&#123;</span><br><span class="line">        DirectBasicAuthClient dbaClient = <span class="keyword">new</span> DirectBasicAuthClient();</span><br><span class="line">        dbaClient.setName(<span class="string">"dba"</span>);</span><br><span class="line">        dbaClient.setAuthenticator(<span class="keyword">new</span> SimpleTestUsernamePasswordAuthenticator());</span><br><span class="line">        <span class="keyword">return</span> dbaClient;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     *  pac4j配置</span></span><br><span class="line"><span class="comment">     *    配置自定义的cas客户端和session存储</span></span><br><span class="line"><span class="comment">     *    配置通过客户端、授权器和匹配器定义安全配置</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> clients 客户端s</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> 配置</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Bean</span>(<span class="string">"authConfig"</span>)</span><br><span class="line">    <span class="function"><span class="keyword">public</span> Config <span class="title">config</span><span class="params">(Clients clients)</span> </span>&#123;</span><br><span class="line">        Config config = <span class="keyword">new</span> Config(clients);</span><br><span class="line"><span class="comment">//        config.setSessionStore(shiroSessionStore);</span></span><br><span class="line"><span class="comment">//        config.addAuthorizer();</span></span><br><span class="line"><span class="comment">//        config.addMatcher();</span></span><br><span class="line">        <span class="keyword">return</span> config;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>&emsp;&emsp;配置了6种认证客户端：casClient是cas客户端用于cas认证，casRestFormClient是REST风格的cas认证客户端，jwtClient是JWT认证客户端，formClient是表单认证客户端，ibaClient是间接认证客户端，dbaClient是直接认证客户端。</p><p>&emsp;&emsp;ShiroConfig</p><figure class="highlight arduino"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br></pre></td><td class="code"><pre><span class="line">@Configuration</span><br><span class="line"><span class="keyword">public</span> class ShiroConfig &#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 项目工程路径</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    @Value(<span class="string">"$&#123;cas.serverName&#125;"</span>)</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">String</span> serverName;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 项目cas服务路径</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    @Value(<span class="string">"$&#123;cas.casServerUrlPrefix&#125;"</span>)</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">String</span> casServerUrlPrefix;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 登陆</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    @Value(<span class="string">"$&#123;cas.casServerLoginUrl&#125;"</span>)</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">String</span> casServerLoginUrl;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 登出</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    @Value(<span class="string">"$&#123;cas.casServerLogoutUrl&#125;"</span>)</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">String</span> casServerLogoutUrl;</span><br><span class="line">    @Value(<span class="string">"$&#123;cas.client-name&#125;"</span>)</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">String</span> clientName;</span><br><span class="line">    @Value(<span class="string">"$&#123;cas.loginUrl&#125;"</span>)</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">String</span> loginUrl;</span><br><span class="line">    @Value(<span class="string">"$&#123;cas.logoutUrl&#125;"</span>)</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">String</span> logoutUrl;</span><br><span class="line">    @Value(<span class="string">"$&#123;cas.casFilterUrlPattern&#125;"</span>)</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">String</span> casFilterUrlPattern;</span><br><span class="line">    @Value(<span class="string">"$&#123;cookie-path&#125;"</span>)</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">String</span> cookiePath;</span><br><span class="line">    @Autowired</span><br><span class="line">    <span class="keyword">public</span> ShiroCacheManager shiroCacheManager;</span><br><span class="line"></span><br><span class="line">    @Bean</span><br><span class="line">    <span class="keyword">public</span> Pac4jSubjectFactory subjectFactory() &#123;</span><br><span class="line">        <span class="built_in">return</span> <span class="keyword">new</span> Pac4jSubjectFactory();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 注册自定义CasRealm</span></span><br><span class="line"><span class="comment">     * @return CasRealm</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    @Bean</span><br><span class="line">    <span class="keyword">public</span> CasRealm casRealm() &#123;</span><br><span class="line">        CasRealm realm = <span class="keyword">new</span> CasRealm();</span><br><span class="line">        realm.setName(<span class="string">"casRealm"</span>);</span><br><span class="line">        <span class="built_in">return</span> realm;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 注册和配置SecurityManager</span></span><br><span class="line"><span class="comment">     * 需要注意：</span></span><br><span class="line"><span class="comment">     *   1.多realm认证只会抛出AuthenticationException，因此如果要想在外部判断到底是在认证的哪一步发生的错误需要自己定义一些异常类型。</span></span><br><span class="line"><span class="comment">     *   2.shiro没有提供根据条件指定realm的功能，如果需要实现这样的功能只能通过继承与重写来实现。</span></span><br><span class="line"><span class="comment">     * @return SecurityManager</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    @Bean(<span class="string">"securityManager"</span>)</span><br><span class="line">    <span class="keyword">public</span> SecurityManager securityManager() &#123;</span><br><span class="line">        DefaultWebSecurityManager manager = <span class="keyword">new</span> DefaultWebSecurityManager();</span><br><span class="line"><span class="comment">//      // TODO-多个realms进配置在这里</span></span><br><span class="line"><span class="comment">//        ModularRealmAuthenticator modularRealmAuthenticator = new ModularRealmAuthenticator();</span></span><br><span class="line"><span class="comment">//        modularRealmAuthenticator.setAuthenticationStrategy(new FirstSuccessfulStrategy());</span></span><br><span class="line"><span class="comment">//        //Shiro提供了三种策略：AllSuccessFulStrategy, AtLeastOneSuccessFulAtrategy, FirstSuccessFulStrategy，默认使用AtLeastOneSuccessFulAtrategy，通常不需要特别配置</span></span><br><span class="line"><span class="comment">//        manager.setAuthenticator(modularRealmAuthenticator);</span></span><br><span class="line"><span class="comment">//        List&lt;Realm&gt; realms = new ArrayList&lt;&gt;();</span></span><br><span class="line"><span class="comment">//        realms.add(getAdminRealm(userService, roleService, authService, jedisUtils));</span></span><br><span class="line"><span class="comment">//        realms.add(getCasRealm(userService, roleService, authService,jedisUtils));</span></span><br><span class="line"><span class="comment">//        manager.setRealms(realms);</span></span><br><span class="line">        <span class="comment">// 设置自定义Realm</span></span><br><span class="line">        manager.setRealm(casRealm());</span><br><span class="line"><span class="comment">//        // 指定 SubjectFactory</span></span><br><span class="line"><span class="comment">//        manager.setSubjectFactory(subjectFactory());</span></span><br><span class="line"><span class="comment">//        // 记住密码管理</span></span><br><span class="line"><span class="comment">//        manager.setRememberMeManager(rememberMeManager());</span></span><br><span class="line"><span class="comment">//        // session管理</span></span><br><span class="line"><span class="comment">//        manager.setSessionManager(sessionManager());</span></span><br><span class="line">        <span class="comment">/*</span></span><br><span class="line"><span class="comment">         * 关闭shiro自带的session，详情见文档</span></span><br><span class="line"><span class="comment">         * http://shiro.apache.org/session-management.html#SessionManagement-StatelessApplications%28Sessionless%29</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        DefaultSubjectDAO subjectDAO = <span class="keyword">new</span> DefaultSubjectDAO();</span><br><span class="line">        DefaultSessionStorageEvaluator defaultSessionStorageEvaluator = <span class="keyword">new</span> DefaultSessionStorageEvaluator();</span><br><span class="line">        defaultSessionStorageEvaluator.setSessionStorageEnabled(false);</span><br><span class="line">        subjectDAO.setSessionStorageEvaluator(defaultSessionStorageEvaluator);</span><br><span class="line">        manager.setSubjectDAO(subjectDAO);</span><br><span class="line">        <span class="comment">// 设置缓存管理器</span></span><br><span class="line">        manager.setCacheManager(shiroCacheManager);</span><br><span class="line">        <span class="built_in">return</span> manager;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 注册shiroFilter，配置相关过滤器</span></span><br><span class="line"><span class="comment">     * @return ShiroFilterFactoryBean</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    @Bean(<span class="string">"shiroFilter"</span>)</span><br><span class="line">    <span class="keyword">public</span> ShiroFilterFactoryBean factory(SecurityManager securityManager,</span><br><span class="line">                                          Config <span class="built_in">config</span>) &#123;</span><br><span class="line">        ShiroFilterFactoryBean shiroFilterFactoryBean = <span class="keyword">new</span> ShiroFilterFactoryBean();</span><br><span class="line">        <span class="comment">// 必须设置 SecurityManager</span></span><br><span class="line">        shiroFilterFactoryBean.setSecurityManager(securityManager);</span><br><span class="line">        <span class="comment">// 如果不设置默认会自动寻找Web工程根目录下的"/login.jsp"页面</span></span><br><span class="line">        shiroFilterFactoryBean.setLoginUrl(casFilterUrlPattern);</span><br><span class="line">        <span class="comment">// 登录成功后要跳转的链接</span></span><br><span class="line">        shiroFilterFactoryBean.setSuccessUrl(<span class="string">"/hello"</span>);</span><br><span class="line">        <span class="comment">// 未授权界面;</span></span><br><span class="line">        shiroFilterFactoryBean.setUnauthorizedUrl(<span class="string">"/403"</span>);</span><br><span class="line">        <span class="comment">//自定义拦截器</span></span><br><span class="line">        Map&lt;<span class="keyword">String</span>, Filter&gt; filters = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line">        <span class="comment">//Cas资源认证拦截器</span></span><br><span class="line">        <span class="comment">//(或者不论使用什么原理去拦截的HTTP请求)根据客户端和授权配置，通过检查用户已认证和已授权来保护一个URL。</span></span><br><span class="line">        <span class="comment">// 如果用户没有被认证，它对直接客户端展示认证，对间接客户端启动登录进程。</span></span><br><span class="line">        SecurityFilter formSecurityFilter = <span class="keyword">new</span> SecurityFilter();</span><br><span class="line">        formSecurityFilter.setConfig(<span class="built_in">config</span>);</span><br><span class="line">        formSecurityFilter.setClients(<span class="string">"form"</span>);</span><br><span class="line">        filters.<span class="built_in">put</span>(<span class="string">"formSecurityFilter"</span>, formSecurityFilter);</span><br><span class="line">        SecurityFilter basicAuthSecurityFilter = <span class="keyword">new</span> SecurityFilter();</span><br><span class="line">        basicAuthSecurityFilter.setConfig(<span class="built_in">config</span>);</span><br><span class="line">        basicAuthSecurityFilter.setClients(<span class="string">"iba"</span>);</span><br><span class="line">        filters.<span class="built_in">put</span>(<span class="string">"basicAuthSecurityFilter"</span>, basicAuthSecurityFilter);</span><br><span class="line">        SecurityFilter casSecurityFilter = <span class="keyword">new</span> SecurityFilter();</span><br><span class="line">        casSecurityFilter.setConfig(<span class="built_in">config</span>);</span><br><span class="line">        casSecurityFilter.setClients(<span class="string">"cas"</span>);</span><br><span class="line">        filters.<span class="built_in">put</span>(<span class="string">"casSecurityFilter"</span>, casSecurityFilter);</span><br><span class="line">        SecurityFilter jwtSecurityFilter = <span class="keyword">new</span> SecurityFilter();</span><br><span class="line">        jwtSecurityFilter.setConfig(<span class="built_in">config</span>);</span><br><span class="line">        jwtSecurityFilter.setClients(<span class="string">"jwt"</span>);</span><br><span class="line">        filters.<span class="built_in">put</span>(<span class="string">"jwtSecurityFilter"</span>, jwtSecurityFilter);</span><br><span class="line">        SecurityFilter dbaSecurityFilter = <span class="keyword">new</span> SecurityFilter();</span><br><span class="line">        dbaSecurityFilter.setConfig(<span class="built_in">config</span>);</span><br><span class="line">        dbaSecurityFilter.setClients(<span class="string">"dba,jwt"</span>);</span><br><span class="line">        filters.<span class="built_in">put</span>(<span class="string">"dbaSecurityFilter"</span>, dbaSecurityFilter);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//Cas认证后回调拦截器</span></span><br><span class="line">        <span class="comment">//对间接客户端结束登录进程后的回调</span></span><br><span class="line">        io.buji.pac4j.filter.CallbackFilter callbackFilter = <span class="keyword">new</span> io.buji.pac4j.filter.CallbackFilter();</span><br><span class="line">        callbackFilter.setConfig(<span class="built_in">config</span>);</span><br><span class="line">        callbackFilter.setDefaultUrl(<span class="string">"https://localhost:8443/"</span>);</span><br><span class="line">        callbackFilter.setMultiProfile(true);</span><br><span class="line">        filters.<span class="built_in">put</span>(<span class="string">"callbackFilter"</span>, callbackFilter);</span><br><span class="line">        <span class="comment">//Cas注销拦截器</span></span><br><span class="line">        <span class="comment">//处理应用程序和/或身份服务器注销</span></span><br><span class="line">        LogoutFilter logoutFilter = <span class="keyword">new</span> LogoutFilter();</span><br><span class="line">        logoutFilter.setConfig(<span class="built_in">config</span>);</span><br><span class="line">        logoutFilter.setCentralLogout(true);</span><br><span class="line">        logoutFilter.setLocalLogout(true);</span><br><span class="line">        logoutFilter.setDefaultUrl(serverName + <span class="string">"callback?client_name"</span> + clientName);</span><br><span class="line">        filters.<span class="built_in">put</span>(<span class="string">"logoutFilter"</span>, logoutFilter);</span><br><span class="line">        shiroFilterFactoryBean.setFilters(filters);</span><br><span class="line">        loadShiroFilterChain(shiroFilterFactoryBean);</span><br><span class="line">        <span class="built_in">return</span> shiroFilterFactoryBean;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 加载shiroFilter权限控制规则（从数据库读取然后配置）</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * @param shiroFilterFactoryBean</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">void</span> loadShiroFilterChain(ShiroFilterFactoryBean shiroFilterFactoryBean) &#123;</span><br><span class="line">        <span class="comment">/*下面这些规则配置最好配置到配置文件中 */</span></span><br><span class="line">        Map&lt;<span class="keyword">String</span>, <span class="keyword">String</span>&gt; filterChainDefinitionMap = <span class="keyword">new</span> LinkedHashMap&lt;&gt;();</span><br><span class="line">        <span class="comment">// authc：该过滤器下的页面必须登录后才能访问，它是Shiro内置的一个拦截器org.apache.shiro.web.filter.authc.FormAuthenticationFilter</span></span><br><span class="line">        <span class="comment">// anon: 可以理解为不拦截</span></span><br><span class="line">        <span class="comment">// user: 登录了就不拦截</span></span><br><span class="line">        <span class="comment">// roles["admin"] 用户拥有admin角色</span></span><br><span class="line">        <span class="comment">// perms["permission1"] 用户拥有permission1权限</span></span><br><span class="line">        <span class="comment">// filter顺序按照定义顺序匹配，匹配到就验证，验证完毕结束。</span></span><br><span class="line">        <span class="comment">// url匹配通配符支持：? * **,分别表示匹配1个，匹配0-n个（不含子路径），匹配下级所有路径</span></span><br><span class="line">        filterChainDefinitionMap.<span class="built_in">put</span>(<span class="string">"/form/**"</span>, <span class="string">"formSecurityFilter"</span>);</span><br><span class="line">        filterChainDefinitionMap.<span class="built_in">put</span>(<span class="string">"/cas/**"</span>, <span class="string">"casSecurityFilter"</span>);</span><br><span class="line">        filterChainDefinitionMap.<span class="built_in">put</span>(<span class="string">"/iba/**"</span>, <span class="string">"basicAuthSecurityFilter"</span>);</span><br><span class="line">        filterChainDefinitionMap.<span class="built_in">put</span>(<span class="string">"/jwt/**"</span>, <span class="string">"noSessionCreation,jwtSecurityFilter"</span>);</span><br><span class="line">        filterChainDefinitionMap.<span class="built_in">put</span>(<span class="string">"/dba/**"</span>, <span class="string">"noSessionCreation,dbaSecurityFilter"</span>);</span><br><span class="line">        filterChainDefinitionMap.<span class="built_in">put</span>(<span class="string">"/callback"</span>, <span class="string">"callbackFilter"</span>);</span><br><span class="line">        filterChainDefinitionMap.<span class="built_in">put</span>(<span class="string">"/logout"</span>, <span class="string">"logoutFilter"</span>);</span><br><span class="line">        filterChainDefinitionMap.<span class="built_in">put</span>(<span class="string">"/"</span>, <span class="string">"anon"</span>);</span><br><span class="line">        filterChainDefinitionMap.<span class="built_in">put</span>(<span class="string">"/token"</span>, <span class="string">"formSecurityFilter"</span>);</span><br><span class="line">        filterChainDefinitionMap.<span class="built_in">put</span>(<span class="string">"/**"</span>, <span class="string">"noSessionCreation,jwtSecurityFilter"</span>);</span><br><span class="line">        shiroFilterFactoryBean.setFilterChainDefinitionMap(filterChainDefinitionMap);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    @Bean</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> LifecycleBeanPostProcessor lifecycleBeanPostProcessor() &#123;</span><br><span class="line">        <span class="built_in">return</span> <span class="keyword">new</span> LifecycleBeanPostProcessor();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 下面的代码是添加注解支持</span></span><br><span class="line"><span class="comment">     * 开启Shiro的注解(如@RequiresRoles,@RequiresPermissions),需借助SpringAOP扫描使用Shiro注解的类,并在必要时进行安全逻辑验证</span></span><br><span class="line"><span class="comment">     * 配置以下两个bean(DefaultAdvisorAutoProxyCreator(可选)和AuthorizationAttributeSourceAdvisor)即可实现此功能</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    @Bean</span><br><span class="line">    @DependsOn(<span class="string">"lifecycleBeanPostProcessor"</span>)</span><br><span class="line">    <span class="keyword">public</span> DefaultAdvisorAutoProxyCreator defaultAdvisorAutoProxyCreator() &#123;</span><br><span class="line">        DefaultAdvisorAutoProxyCreator defaultAdvisorAutoProxyCreator = <span class="keyword">new</span> DefaultAdvisorAutoProxyCreator();</span><br><span class="line">        <span class="comment">// 强制使用cglib，防止重复代理和可能引起代理出错的问题</span></span><br><span class="line">        <span class="comment">// https://zhuanlan.zhihu.com/p/29161098</span></span><br><span class="line">        defaultAdvisorAutoProxyCreator.setProxyTargetClass(true);</span><br><span class="line">        <span class="built_in">return</span> defaultAdvisorAutoProxyCreator;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Bean</span><br><span class="line">    <span class="keyword">public</span> AuthorizationAttributeSourceAdvisor authorizationAttributeSourceAdvisor(SecurityManager securityManager) &#123;</span><br><span class="line">        AuthorizationAttributeSourceAdvisor advisor = <span class="keyword">new</span> AuthorizationAttributeSourceAdvisor();</span><br><span class="line">        advisor.setSecurityManager(securityManager);</span><br><span class="line">        <span class="built_in">return</span> advisor;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>&emsp;&emsp;自定义Realm-CasRealm，继承Pac4jRealm，支持Pac4jToken，重写相关方法。</p><figure class="highlight aspectj"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Data</span></span><br><span class="line"><span class="meta">@Service</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">CasRealm</span> <span class="keyword">extends</span> <span class="title">Pac4jRealm</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> Logger logger = Logger.getLogger(CasRealm.class);</span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> UserService userService;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">CasRealm</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 返回一个唯一的Realm名字</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="function">String <span class="title">getName</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="function"><span class="keyword">return</span> <span class="keyword">super</span>.<span class="title">getName</span><span class="params">()</span></span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 判断此Realm是否支持此Token</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="function"><span class="keyword">boolean</span> <span class="title">supports</span><span class="params">(AuthenticationToken token)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> token <span class="keyword">instanceof</span> Pac4jToken;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 认证</span></span><br><span class="line"><span class="comment">     * Shiro登录认证(原理：用户提交 用户名和密码 --- shiro 封装令牌 ---- realm 通过用户名将密码查询返回 ---- shiro</span></span><br><span class="line"><span class="comment">     * 自动去比较查询出密码和用户输入密码是否一致---- 进行登陆控制 )</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> authenticationToken</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     * <span class="doctag">@throws</span> AuthenticationException</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">protected</span> <span class="function">AuthenticationInfo <span class="title">doGetAuthenticationInfo</span><span class="params">(AuthenticationToken authenticationToken)</span> <span class="keyword">throws</span> AuthenticationException </span>&#123;</span><br><span class="line">        logger.info(<span class="string">"Shiro开始登录认证"</span>);</span><br><span class="line">        Pac4jToken pac4jToken = (Pac4jToken) authenticationToken;</span><br><span class="line">        List&lt;CommonProfile&gt; profiles = pac4jToken.getProfiles();</span><br><span class="line">        Pac4jPrincipal principal = <span class="keyword">new</span> Pac4jPrincipal(profiles,getPrincipalNameAttribute());</span><br><span class="line">        System.out.println(<span class="string">"Pac4jPrincipal: "</span> + principal.toString());</span><br><span class="line">        CommonProfile profile = principal.getProfile();</span><br><span class="line">        System.out.println(<span class="string">"CommonProfile: "</span> + profile.toString());</span><br><span class="line">        <span class="comment">//获取用户信息</span></span><br><span class="line">        String userId = profile.getId();</span><br><span class="line">        System.out.println(<span class="string">"userId: "</span> + userId);</span><br><span class="line">        User user = userService.findByUserId(userId);</span><br><span class="line">        <span class="comment">// 账号不存在</span></span><br><span class="line">        <span class="keyword">if</span>(user == <span class="keyword">null</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 账号未启用</span></span><br><span class="line">        <span class="keyword">if</span> (user.getDelFlag()) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        List&lt;Role&gt; roles = userService.findAllRoleByUserId(user.getUserId());</span><br><span class="line">        List&lt;Auth&gt; auths = userService.findAllAuthByUserId(user.getUserId());</span><br><span class="line">        Set&lt;String&gt; roleSet = <span class="keyword">new</span> HashSet&lt;&gt;();</span><br><span class="line">        Set&lt;String&gt; authSet = <span class="keyword">new</span> HashSet&lt;&gt;();</span><br><span class="line">        <span class="keyword">for</span> (Role role : roles) &#123;</span><br><span class="line">            roleSet.add(role.getCode());</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (Auth auth : auths) &#123;</span><br><span class="line">            authSet.add(auth.getCode());</span><br><span class="line">        &#125;</span><br><span class="line">        profile.addAttribute(<span class="string">"userId"</span>,user.getUserId());</span><br><span class="line">        profile.addAttribute(<span class="string">"userName"</span>,user.getName());</span><br><span class="line">        profile.addAttribute(<span class="string">"orgId"</span>,user.getUnit().getUnitId());</span><br><span class="line">        profile.addAttribute(<span class="string">"currentTimeMillis"</span>,<span class="keyword">new</span> Timestamp(System.currentTimeMillis()).toString());</span><br><span class="line">        profile.setRoles(authSet);</span><br><span class="line">        profile.setPermissions(roleSet);</span><br><span class="line">        <span class="keyword">final</span> PrincipalCollection principalCollection = <span class="keyword">new</span> SimplePrincipalCollection(principal,getName());</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> SimpleAuthenticationInfo(principalCollection, pac4jToken.getCredentials());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 授权/验权（todo 后续有权限在此增加）</span></span><br><span class="line"><span class="comment">     *  单点登陆只需关心角色权限数据即可</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> principals</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">protected</span> <span class="function">AuthorizationInfo <span class="title">doGetAuthorizationInfo</span><span class="params">(PrincipalCollection principals)</span> </span>&#123;</span><br><span class="line">        logger.info(<span class="string">"doGetAuthorizationInfo()获取角色权限等信息进行校验"</span>);</span><br><span class="line">        SimpleAuthorizationInfo authorizationInfo = <span class="keyword">new</span> SimpleAuthorizationInfo();</span><br><span class="line">        Pac4jPrincipal principal = (Pac4jPrincipal)principals.getPrimaryPrincipal();</span><br><span class="line">        CommonProfile profile = principal.getProfile();</span><br><span class="line">        authorizationInfo.setRoles(profile.getRoles());</span><br><span class="line">        authorizationInfo.addStringPermissions(profile.getPermissions());</span><br><span class="line">        <span class="keyword">return</span> authorizationInfo;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>&emsp;&emsp;application.properties相关配置</p><figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="attribute">cookie-path</span>=/</span><br><span class="line"></span><br><span class="line"><span class="comment"># 项目工程路径</span></span><br><span class="line">cas.<span class="attribute">serverName</span>=https://127.0.0.1:8443/</span><br><span class="line"><span class="comment"># 项目cas服务路径</span></span><br><span class="line">cas.<span class="attribute">casServerUrlPrefix</span>=https://xxx.xxx.xxx.xxx/authserver/</span><br><span class="line"><span class="comment"># 项目cas登陆</span></span><br><span class="line">cas.<span class="attribute">casServerLoginUrl</span>=<span class="variable">$&#123;cas.casServerUrlPrefix&#125;</span>login</span><br><span class="line"><span class="comment"># 项目cas登出</span></span><br><span class="line">cas.<span class="attribute">casServerLogoutUrl</span>=<span class="variable">$&#123;cas.casServerUrlPrefix&#125;</span>logout</span><br><span class="line"><span class="comment"># 项目cas回调</span></span><br><span class="line">cas.<span class="attribute">casServerCallbackUrl</span>=<span class="variable">$&#123;cas.serverName&#125;</span>callback</span><br><span class="line"><span class="comment"># 项目cas客户端名</span></span><br><span class="line">cas.<span class="attribute">client-name</span>=cas</span><br><span class="line"><span class="comment"># casFilter UrlPattern</span></span><br><span class="line">cas.<span class="attribute">casFilterUrlPattern</span>=cas</span><br><span class="line"><span class="comment"># 登录地址</span></span><br><span class="line">cas.<span class="attribute">loginUrl</span>=<span class="variable">$&#123;cas.casServerLoginUrl&#125;</span>?service=$&#123;cas.serverName&#125;<span class="variable">$&#123;cas.casFilterUrlPattern&#125;</span></span><br><span class="line"><span class="comment"># 登出地址（casserver启用service跳转功能，需在webapps\cas\WEB-INF\cas.properties文件中启用cas.logout.followServiceRedirects=true）</span></span><br><span class="line">cas.<span class="attribute">logoutUrl</span>=<span class="variable">$&#123;cas.casServerLogoutUrl&#125;</span>?service=$&#123;cas.serverName&#125;<span class="variable">$&#123;cas.casFilterUrlPattern&#125;</span></span><br><span class="line"><span class="comment"># 登录地址</span></span><br><span class="line">cas.<span class="attribute">callbackUrl</span>=<span class="variable">$&#123;cas.serverName&#125;</span>callback?client_name=$&#123;cas.client-name&#125;</span><br><span class="line">cas.<span class="attribute">salt</span>=12345678901234567890123456789012</span><br></pre></td></tr></table></figure><hr><h2 id="3-测试部分"><a href="#3-测试部分" class="headerlink" title="3.测试部分"></a><strong>3.测试部分</strong></h2><p>&emsp;&emsp;MainController</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@RestController</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MainController</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> JwtGenerator jwtGenerator;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@RequestMapping(<span class="meta-string">"/"</span>)</span></span><br><span class="line">    <span class="keyword">public</span> String index()&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">"https://localhost:8443/form/index &lt;/br&gt;"</span> +</span><br><span class="line">                <span class="string">"    FormClient:               Protected url by form authentication 需要(use login = pwd) &lt;/br&gt;"</span> +</span><br><span class="line">                <span class="string">"&lt;/br&gt;"</span> +</span><br><span class="line">                <span class="string">"https://localhost:8443/iba/index &lt;/br&gt;"</span> +</span><br><span class="line">                <span class="string">"    IndirectBasicAuthClient:  Protected url by indirect basic auth 需要(use login = pwd) &lt;/br&gt;"</span>+</span><br><span class="line">                <span class="string">"&lt;/br&gt;"</span> +</span><br><span class="line">                <span class="string">"https://localhost:8443/cas/index &lt;/br&gt;"</span> +</span><br><span class="line">                <span class="string">"    CasClient:                Protected url by CAS 需要(use login = pwd) &lt;/br&gt;"</span> +</span><br><span class="line">                <span class="string">"&lt;/br&gt;"</span> +</span><br><span class="line">                <span class="string">"https://localhost:8443/token &lt;/br&gt;"</span> +</span><br><span class="line">                <span class="string">"    Generate a JWT token - after being authenticated &lt;/br&gt;"</span> +</span><br><span class="line">                <span class="string">"&lt;/br&gt;"</span> +</span><br><span class="line">                <span class="string">"https://localhost:8443/dba/index &lt;/br&gt;"</span> +</span><br><span class="line">                <span class="string">"    DirectBasicAuthClient:    Protected url by DirectBasicAuthClient  &lt;/br&gt;"</span> +</span><br><span class="line">                <span class="string">"                              需要POST the Authorization header with value: (Basic amxlbGV1OmpsZWxldQ==) &lt;/br&gt;"</span> +</span><br><span class="line">                <span class="string">"                              then by (/dba/index) ParameterClient: /dba/index (with request parameter: token=jwt_generated_token &lt;/br&gt;"</span> +</span><br><span class="line">                <span class="string">"&lt;/br&gt;"</span> +</span><br><span class="line">                <span class="string">"https://localhost:8443/jwt/index &lt;/br&gt;"</span> +</span><br><span class="line">                <span class="string">"                              ParameterClient:  Protected url by ParameterClient 需要(with request parameter: token=jwt_generated_token) &lt;/br&gt;"</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@RequestMapping(<span class="meta-string">"/token"</span>)</span></span><br><span class="line">    <span class="keyword">public</span> String token()&#123;</span><br><span class="line">        Subject subject = SecurityUtils.getSubject();</span><br><span class="line">        String token = <span class="string">"null"</span>;</span><br><span class="line">        <span class="keyword">final</span> PrincipalCollection collection = subject.getPrincipals();</span><br><span class="line">        <span class="keyword">if</span> (collection != <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="keyword">final</span> Pac4jPrincipal principal = collection.oneByType(Pac4jPrincipal.<span class="keyword">class</span>);</span><br><span class="line">            <span class="keyword">if</span> (principal != <span class="literal">null</span>) &#123;</span><br><span class="line">                CommonProfile profile = principal.getProfile();</span><br><span class="line">                token = jwtGenerator.generate(profile);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> token;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>&emsp;&emsp;FormController</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@RestController</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">FormController</span> </span>&#123;</span><br><span class="line">    <span class="meta">@RequestMapping(<span class="meta-string">"/form/index"</span>)</span></span><br><span class="line">    <span class="keyword">public</span> String index() &#123;</span><br><span class="line">        Subject subject = SecurityUtils.getSubject();</span><br><span class="line">        <span class="keyword">if</span>(subject == <span class="literal">null</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="string">"subject is null"</span>;</span><br><span class="line">        &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">            System.<span class="keyword">out</span>.println(<span class="string">"isAuthenticated ? "</span> + subject.isAuthenticated());</span><br><span class="line">            PrincipalCollection collection = SecurityUtils.getSubject().getPrincipals();</span><br><span class="line">            <span class="keyword">final</span> Pac4jPrincipal principal = collection.oneByType(Pac4jPrincipal.<span class="keyword">class</span>);</span><br><span class="line">            <span class="keyword">if</span> (principal == <span class="literal">null</span>) &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="string">"user is null"</span>;</span><br><span class="line">            &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="keyword">return</span> principal.toString();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>&emsp;&emsp;JwtController</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@RestController</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">JwtController</span> </span>&#123;</span><br><span class="line">    <span class="meta">@RequestMapping(<span class="meta-string">"/jwt/index"</span>)</span></span><br><span class="line">    <span class="keyword">public</span> Object index() &#123;</span><br><span class="line">        Subject subject = SecurityUtils.getSubject();</span><br><span class="line">        <span class="keyword">if</span>(subject == <span class="literal">null</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="string">"subject is null"</span>;</span><br><span class="line">        &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">            System.<span class="keyword">out</span>.println(<span class="string">"isAuthenticated ? "</span> + subject.isAuthenticated());</span><br><span class="line">            PrincipalCollection collection = SecurityUtils.getSubject().getPrincipals();</span><br><span class="line">            <span class="keyword">final</span> Pac4jPrincipal principal = collection.oneByType(Pac4jPrincipal.<span class="keyword">class</span>);</span><br><span class="line">            <span class="keyword">if</span> (principal == <span class="literal">null</span>) &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="string">"user is null"</span>;</span><br><span class="line">            &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="keyword">return</span> principal.toString();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>&emsp;&emsp;其他类似：/iba/index，/dba/index，/cas/index</p><p>&emsp;&emsp;分别访问主页面：<a href="https://localhost:8443/" target="_blank" rel="noopener">https://localhost:8443/</a></p><p>&emsp;&emsp;表单提交账号密码：<a href="https://localhost:8443/callback?client_name=form，携带username&amp;password，表单登录获得JSESSIONID。" target="_blank" rel="noopener">https://localhost:8443/callback?client_name=form，携带username&amp;password，表单登录获得JSESSIONID。</a></p><p>&emsp;&emsp;表单客户端访问：<a href="https://localhost:8443/form/index，返回用户信息Pac4jPrincipal。" target="_blank" rel="noopener">https://localhost:8443/form/index，返回用户信息Pac4jPrincipal。</a></p><p>&emsp;&emsp;获得令牌：<a href="https://localhost:8443/token，返回token。" target="_blank" rel="noopener">https://localhost:8443/token，返回token。</a></p><p>&emsp;&emsp;JWT客户端访问：<a href="https://localhost:8443/jwt/index?client_name=jwt&amp;token=eyJjdH...，返回用户信息Pac4jPrincipal。" target="_blank" rel="noopener">https://localhost:8443/jwt/index?client_name=jwt&amp;token=eyJjdH...，返回用户信息Pac4jPrincipal。</a></p><p>（未完待续…）</p><hr><p><em>参考博客和文章书籍等：</em></p><blockquote><p><a href="http://www.pac4j.org/docs/index.html" title="Title" target="_blank" rel="noopener">pac4j官网文档</a></p></blockquote><blockquote><p><a href="https://github.com/pac4j/pac4j/" title="Title" target="_blank" rel="noopener">GitHub pac4j/pac4j</a></p></blockquote><blockquote><p><a href="https://github.com.cnpmjs.org/bujiio/buji-pac4j" title="Title" target="_blank" rel="noopener">GitHub bujiio/buji-pac4j</a></p></blockquote><blockquote><p><a href="https://github.com/pac4j/buji-pac4j-demo" title="Title" target="_blank" rel="noopener">GitHub pac4j/buji-pac4j-demo</a></p></blockquote><p><em>因博客主等未标明不可引用，若部分内容涉及侵权请及时告知，我会尽快修改和删除相关内容</em></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;link rel=&quot;stylesheet&quot; class=&quot;aplayer-secondary-style-marker&quot; href=&quot;\assets\css\APlayer.min.css&quot;&gt;&lt;script src=&quot;\assets\js\APlayer.min.js&quot; cla
      
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>Condition接口及实现原理</title>
    <link href="http://linyishui.top/2019081601.html"/>
    <id>http://linyishui.top/2019081601.html</id>
    <published>2019-08-16T07:13:38.000Z</published>
    <updated>2019-09-19T07:53:42.247Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="Condition接口"><a href="#Condition接口" class="headerlink" title="Condition接口"></a><strong>Condition接口</strong></h1><p>&emsp;任意一个Java对象，都拥有一组监视器方法（定义在java.lang.Object上），主要包括wait()、wait(long timeout)、notify()以及notifyAll()方法，这些方法与synchronized同步关键字配合，可以实现等待/通知模式。Condition接口也提供了类似Object的监视器方法，与Lock配合可以实现等待/通知模式，但是这两者在使用方式以及功能特性上还是有差别的。</p><p>&emsp;通过对比Object的监视器方法和Condition接口，可以更详细地了解Condition的特性，对比项与结果如下表所示。</p><p><img src="https://pic-1258215793.cos.ap-shanghai.myqcloud.com/content/20190316/201903160120.jpg" alt="Object的监视器方法与Condition接口的对比"></p><hr><h2 id="Condition接口与示例"><a href="#Condition接口与示例" class="headerlink" title="Condition接口与示例"></a><strong>Condition接口与示例</strong></h2><p>&emsp;Condition定义了等待/通知两种类型的方法，当前线程调用这些方法时，需要提前获取到Condition对象关联的锁。Condition对象是由Lock对象（调用Lock对象的newCondition()方法）创建出来的，换句话说，Condition是依赖Lock对象的。</p><p>&emsp;Condition的使用方式比较简单，需要注意在调用方法前获取锁，使用方式如下列代码所示。</p><figure class="highlight cs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">Lock <span class="keyword">lock</span> = <span class="keyword">new</span> ReentrantLock();</span><br><span class="line">Condition condition = <span class="keyword">lock</span>.newCondition();</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">conditionWait</span>(<span class="params"></span>) throws InterruptedException </span>&#123;</span><br><span class="line">    <span class="keyword">lock</span>.<span class="keyword">lock</span>();</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        condition.<span class="keyword">await</span>();</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        <span class="keyword">lock</span>.unlock();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">conditionSignal</span>(<span class="params"></span>) throws InterruptedException </span>&#123;</span><br><span class="line">    <span class="keyword">lock</span>.<span class="keyword">lock</span>();</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        condition.signal();</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        <span class="keyword">lock</span>.unlock();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>&emsp;如示例所示，一般都会将Condition对象作为成员变量。当调用await()方法后，当前线程会释放锁并在此等待，而其他线程调用Condition对象的signal()方法，通知当前线程后，当前线程才从await()方法返回，并且在返回前已经获取了锁。</p><p>&emsp;Condition定义的（部分）方法以及描述如下表所示。</p><p><img src="https://pic-1258215793.cos.ap-shanghai.myqcloud.com/content/20190316/201903160121.jpg" alt="Condition的（部分）方法以及描述"></p><p>&emsp;获取一个Condition必须通过Lock的newCondition()方法。下面通过一个有界队列的示例来深入了解Condition的使用方式。有界队列是一种特殊的队列，当队列为空时，队列的获取操作将会阻塞获取线程，直到队列中有新增元素，当队列已满时，队列的插入操作将会阻塞插入线程，直到队列出现“空位”，如下列代码所示。</p><figure class="highlight sqf"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line">public class BoundedQueue&lt;T&gt; &#123;</span><br><span class="line">    <span class="built_in">private</span> Object[] <span class="built_in">items</span>;</span><br><span class="line">    <span class="comment">// 添加的下标，删除的下标和数组当前数量</span></span><br><span class="line">    <span class="built_in">private</span> int addIndex, removeIndex, <span class="built_in">count</span>;</span><br><span class="line">    <span class="built_in">private</span> <span class="built_in">Lock</span> <span class="built_in">lock</span> = new ReentrantLock();</span><br><span class="line">    <span class="built_in">private</span> Condition notEmpty = <span class="built_in">lock</span>.newCondition();</span><br><span class="line">    <span class="built_in">private</span> Condition notFull = <span class="built_in">lock</span>.newCondition();</span><br><span class="line">    public BoundedQueue(int <span class="built_in">size</span>) &#123;</span><br><span class="line">        <span class="built_in">items</span> = new Object[<span class="built_in">size</span>];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 添加一个元素，如果数组满，则添加线程进入等待状态，直到有"空位"</span></span><br><span class="line">    public void add(T t) throws InterruptedException &#123;</span><br><span class="line">        <span class="built_in">lock</span>.<span class="built_in">lock</span>();</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">while</span> (<span class="built_in">count</span> == <span class="built_in">items</span>.length)</span><br><span class="line">                notFull.await();</span><br><span class="line">            <span class="built_in">items</span>[addIndex] = t;</span><br><span class="line">            <span class="keyword">if</span> (++addIndex == <span class="built_in">items</span>.length)</span><br><span class="line">                addIndex = <span class="number">0</span>;</span><br><span class="line">            ++<span class="built_in">count</span>;</span><br><span class="line">            notEmpty.signal();</span><br><span class="line">        &#125; finally &#123;</span><br><span class="line">            <span class="built_in">lock</span>.unlock();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 由头部删除一个元素，如果数组空，则删除线程进入等待状态，直到有新添加元素</span></span><br><span class="line">    @SuppressWarnings(<span class="string">"unchecked"</span>)</span><br><span class="line">    public T remove() throws InterruptedException &#123;</span><br><span class="line">        <span class="built_in">lock</span>.<span class="built_in">lock</span>();</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">while</span> (<span class="built_in">count</span> == <span class="number">0</span>)</span><br><span class="line">                notEmpty.await();</span><br><span class="line">            Object x = <span class="built_in">items</span>[removeIndex];</span><br><span class="line">            <span class="keyword">if</span> (++removeIndex == <span class="built_in">items</span>.length)</span><br><span class="line">                removeIndex = <span class="number">0</span>;</span><br><span class="line">            --<span class="built_in">count</span>;</span><br><span class="line">            notFull.signal();</span><br><span class="line">            return (T) x;</span><br><span class="line">        &#125; finally &#123;</span><br><span class="line">            <span class="built_in">lock</span>.unlock();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>&emsp;上述示例中，BoundedQueue通过add(T t)方法添加一个元素，通过remove()方法移出一个元素。以添加方法为例。</p><p>&emsp;首先需要获得锁，目的是确保数组修改的可见性和排他性。当数组数量等于数组长度时，表示数组已满，则调用notFull.await()，当前线程随之释放锁并进入等待状态。如果数组数量不等于数组长度，表示数组未满，则添加元素到数组中，同时通知等待在notEmpty上的线程，数组中已经有新元素可以获取。</p><p>&emsp;在添加和删除方法中使用while循环而非if判断，目的是防止过早或意外的通知，只有条件符合才能够退出循环。回想之前提到的等待/通知的经典范式，二者是非常类似的。</p><hr><h2 id="Condition的实现分析"><a href="#Condition的实现分析" class="headerlink" title="Condition的实现分析"></a><strong>Condition的实现分析</strong></h2><p>&emsp;ConditionObject是同步器AbstractQueuedSynchronizer的内部类，因为Condition的操作需要获取相关联的锁，所以作为同步器的内部类也较为合理。每个Condition对象都包含着一个队列（以下称为等待队列），该队列是Condition对象实现等待/通知功能的关键。</p><p>&emsp;下面将分析Condition的实现，主要包括：等待队列、等待和通知，下面提到的Condition如果不加说明均指的是ConditionObject。</p><h3 id="1-等待队列"><a href="#1-等待队列" class="headerlink" title="1.等待队列"></a><strong>1.等待队列</strong></h3><p>&emsp;等待队列是一个FIFO的队列，在队列中的每个节点都包含了一个线程引用，该线程就是在Condition对象上等待的线程，如果一个线程调用了Condition.await()方法，那么该线程将会释放锁、构造成节点加入等待队列并进入等待状态。事实上，节点的定义复用了同步器中节点的定义，也就是说，同步队列和等待队列中节点类型都是同步器的静态内部类AbstractQueuedSynchronizer.Node。</p><p>&emsp;一个Condition包含一个等待队列，Condition拥有首节点（firstWaiter）和尾节点（lastWaiter）。当前线程调用Condition.await()方法，将会以当前线程构造节点，并将节点从尾部加入等待队列，等待队列的基本结构如下图所示。</p><p><img src="https://pic-1258215793.cos.ap-shanghai.myqcloud.com/content/20190316/201903160122.jpg" alt="等待队列的基本结构"></p><p>&emsp;如图所示，Condition拥有首尾节点的引用，而新增节点只需要将原有的尾节点nextWaiter指向它，并且更新尾节点即可。上述节点引用更新的过程并没有使用CAS保证，原因在于调用await()方法的线程必定是获取了锁的线程，也就是说该过程是由锁来保证线程安全的。</p><p>&emsp;在Object的监视器模型上，一个对象拥有一个同步队列和等待队列，而并发包中的Lock（更确切地说是同步器）拥有一个同步队列和多个等待队列，其对应关系如下图所示。</p><p><img src="https://pic-1258215793.cos.ap-shanghai.myqcloud.com/content/20190316/201903160123.jpg" alt="同步队列与等待队列"></p><p>&emsp;如图所示，Condition的实现是同步器的内部类，因此每个Condition实例都能够访问同步器提供的方法，相当于每个Condition都拥有所属同步器的引用。</p><h3 id="2-等待"><a href="#2-等待" class="headerlink" title="2.等待"></a><strong>2.等待</strong></h3><p>&emsp;调用Condition的await()方法（或者以await开头的方法），会使当前线程进入等待队列并释放锁，同时线程状态变为等待状态。当从await()方法返回时，当前线程一定获取了Condition相关联的锁。</p><p>&emsp;如果从队列（同步队列和等待队列）的角度看await()方法，当调用await()方法时，相当于同步队列的首节点（获取了锁的节点）移动到Condition的等待队列中。</p><p>&emsp;Condition的await()方法，如下列代码所示。</p><figure class="highlight crmsh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">public final void await() throws InterruptedException &#123;</span><br><span class="line">    if (Thread.interrupted())</span><br><span class="line">    throw new InterruptedException();</span><br><span class="line">    // 当前线程加入等待队列</span><br><span class="line">    <span class="keyword">Node</span> <span class="title">node</span> = addConditionWaiter();</span><br><span class="line">    // 释放同步状态，也就是释放锁</span><br><span class="line">    int savedState = fullyRelease(<span class="keyword">node</span><span class="title">);</span></span><br><span class="line"><span class="title">    int</span> interruptMode = <span class="number">0</span>;</span><br><span class="line">    while (!isOnSyncQueue(<span class="keyword">node</span><span class="title">)) &#123;</span></span><br><span class="line"><span class="title">        LockSupport</span>.park(this);</span><br><span class="line">        if ((interruptMode = checkInterruptWhileWaiting(<span class="keyword">node</span><span class="title">)) != 0</span>)</span><br><span class="line">            break;</span><br><span class="line">    &#125;    </span><br><span class="line">    if (acquireQueued(<span class="keyword">node</span><span class="title">, savedState</span>) &amp;&amp; interruptMode != THROW_IE)</span><br><span class="line">        interruptMode = REINTERRUPT;</span><br><span class="line">    if (<span class="keyword">node</span>.<span class="title">nextWaiter</span> != null)</span><br><span class="line">        unlinkCancelledWaiters();</span><br><span class="line">    if (interruptMode != <span class="number">0</span>)</span><br><span class="line">        reportInterruptAfterWait(interruptMode);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>&emsp;调用该方法的线程成功获取了锁的线程，也就是同步队列中的首节点，该方法会将当前线程构造成节点并加入等待队列中，然后释放同步状态，唤醒同步队列中的后继节点，然后当前线程会进入等待状态。</p><p>&emsp;当等待队列中的节点被唤醒，则唤醒节点的线程开始尝试获取同步状态。如果不是通过其他线程调用Condition.signal()方法唤醒，而是对等待线程进行中断，则会抛出InterruptedException。</p><p>&emsp;如果从队列的角度去看，当前线程加入Condition的等待队列，该过程如下图示。</p><p><img src="https://pic-1258215793.cos.ap-shanghai.myqcloud.com/content/20190316/201903160124.jpg" alt="当前线程加入等待队列"></p><p>&emsp;如图所示，同步队列的首节点并不会直接加入等待队列，而是通过addConditionWaiter()方法把当前线程构造成一个新的节点并将其加入等待队列中。</p><h3 id="3-通知"><a href="#3-通知" class="headerlink" title="3.通知"></a><strong>3.通知</strong></h3><p>&emsp;调用Condition的signal()方法，将会唤醒在等待队列中等待时间最长的节点（首节点），在唤醒节点之前，会将节点移到同步队列中。</p><p>&emsp;Condition的signal()方法，如下列代码所示。</p><figure class="highlight aspectj"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="function"><span class="keyword">void</span> <span class="title">signal</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (!isHeldExclusively())</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> IllegalMonitorStateException();</span><br><span class="line">    Node first = firstWaiter;</span><br><span class="line">    <span class="keyword">if</span> (first != <span class="keyword">null</span>)</span><br><span class="line">        doSignal(first);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>&emsp;调用该方法的前置条件是当前线程必须获取了锁，可以看到signal()方法进行了isHeldExclusively()检查，也就是当前线程必须是获取了锁的线程。接着获取等待队列的首节点，将其移动到同步队列并使用LockSupport唤醒节点中的线程。</p><p>&emsp;节点从等待队列移动到同步队列的过程如下图所示。</p><p><img src="https://pic-1258215793.cos.ap-shanghai.myqcloud.com/content/20190316/201903160125.jpg" alt="节点从等待队列移动到同步队列"></p><p>&emsp;通过调用同步器的enq(Node node)方法，等待队列中的头节点线程安全地移动到同步队列。当节点移动到同步队列后，当前线程再使用LockSupport唤醒该节点的线程。</p><p>&emsp;被唤醒后的线程，将从await()方法中的while循环中退出（isOnSyncQueue(Node node)方法返回true，节点已经在同步队列中），进而调用同步器的acquireQueued()方法加入到获取同步状态的竞争中。</p><p>&emsp;成功获取同步状态（或者说锁）之后，被唤醒的线程将从先前调用的await()方法返回，此时该线程已经成功地获取了锁。</p><p>&emsp;Condition的signalAll()方法，相当于对等待队列中的每个节点均执行一次signal()方法，效果就是将等待队列中所有节点全部移动到同步队列中，并唤醒每个节点的线程。</p><hr><p><em>参考博客和文章书籍等：</em></p><blockquote><p>《Java并发编程的艺术》</p></blockquote><p><em>因博客主等未标明不可引用，若部分内容涉及侵权请及时告知，我会尽快修改和删除相关内容</em></p>]]></content>
    
    <summary type="html">
    
      介绍Java中的并发包中Condition接口相关内容：Condition接口与示例，Condition的实现分析：1.等待队列，2.等待，3.通知。
    
    </summary>
    
      <category term="技术文档" scheme="http://linyishui.top/categories/%E6%8A%80%E6%9C%AF%E6%96%87%E6%A1%A3/"/>
    
    
      <category term="java" scheme="http://linyishui.top/tags/java/"/>
    
      <category term="lock" scheme="http://linyishui.top/tags/lock/"/>
    
  </entry>
  
  <entry>
    <title>LockSupport工具</title>
    <link href="http://linyishui.top/2019081501.html"/>
    <id>http://linyishui.top/2019081501.html</id>
    <published>2019-08-15T07:12:42.000Z</published>
    <updated>2019-09-19T07:45:19.496Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="LockSupport工具"><a href="#LockSupport工具" class="headerlink" title="LockSupport工具"></a><strong>LockSupport工具</strong></h1><p>&emsp;回顾<a href="../2019040401.html" title="Title">同步器AQS的实现原理</a>，当需要阻塞或唤醒一个线程的时候，都会使用LockSupport工具类来完成相应工作。LockSupport定义了一组的公共静态方法，这些方法提供了最基本的线程阻塞和唤醒功能，而LockSupport也成为构建同步组件的基础工具。</p><p>&emsp;LockSupport定义了一组以park开头的方法用来阻塞当前线程，以及unpark(Thread thread)方法来唤醒一个被阻塞的线程。Park有停车的意思，假设线程为车辆，那么park方法代表着停车，而unpark方法则是指车辆启动离开，这些方法以及描述如下表所示。</p><p><img src="https://pic-1258215793.cos.ap-shanghai.myqcloud.com/content/20190316/201903160118.jpg" alt="LockSupport提供的阻塞和唤醒方法"></p><p>&emsp;在Java 6中，LockSupport增加了park(Object blocker)、parkNanos(Object blocker,long nanos)和parkUntil(Object blocker,long deadline)3个方法，用于实现阻塞当前线程的功能，其中参数blocker是用来标识当前线程在等待的对象（以下称为阻塞对象），该对象主要用于问题排查和系统监控。</p><p>&emsp;下面的示例中，将对比parkNanos(long nanos)方法和parkNanos(Object blocker,long nanos)方法来展示阻塞对象blocker的用处，代码片段和线程dump（部分）如下表所示。</p><p><img src="https://pic-1258215793.cos.ap-shanghai.myqcloud.com/content/20190316/201903160119.jpg" alt="Blocker在线程dump中的作用"></p><p>&emsp;从表的线程dump结果可以看出，代码片段的内容都是阻塞当前线程10秒，但从线程dump结果可以看出，有阻塞对象的parkNanos方法能够传递给开发人员更多的现场信息。这是由于在Java 5之前，当线程阻塞（使用synchronized关键字）在一个对象上时，通过线程dump能够查看到该线程的阻塞对象，方便问题定位，而Java 5推出的Lock等并发工具时却遗漏了这一点，致使在线程dump时无法提供阻塞对象的信息。因此，在Java 6中，LockSupport新增了上述3个含有阻塞对象的park方法，用以替代原有的park方法。</p><hr><p><em>参考博客和文章书籍等：</em></p><blockquote><p>《Java并发编程的艺术》</p></blockquote><p><em>因博客主等未标明不可引用，若部分内容涉及侵权请及时告知，我会尽快修改和删除相关内容</em></p>]]></content>
    
    <summary type="html">
    
      介绍Java中的并发包中LockSupport工具相关内容。
    
    </summary>
    
      <category term="技术文档" scheme="http://linyishui.top/categories/%E6%8A%80%E6%9C%AF%E6%96%87%E6%A1%A3/"/>
    
    
      <category term="java" scheme="http://linyishui.top/tags/java/"/>
    
      <category term="lock" scheme="http://linyishui.top/tags/lock/"/>
    
  </entry>
  
  <entry>
    <title>锁Q&amp;A</title>
    <link href="http://linyishui.top/2019081401.html"/>
    <id>http://linyishui.top/2019081401.html</id>
    <published>2019-08-14T02:40:27.000Z</published>
    <updated>2019-09-17T02:43:17.977Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h2 id="Q-amp-A"><a href="#Q-amp-A" class="headerlink" title="Q&amp;A"></a><strong>Q&amp;A</strong></h2><blockquote><p><strong>什么是阻塞队列？阻塞队列的实现原理是什么？如何使用阻塞队列来实现生产者-消费者模型？</strong></p><p>&emsp;阻塞队列（BlockingQueue）是一个支持两个附加操作的队列。</p><p>&emsp;这两个附加的操作是：在队列为空时，获取元素的线程会等待队列变为非空。当队列满时，存储元素的线程会等待队列可用。</p><p>&emsp;阻塞队列常用于生产者和消费者的场景，生产者是往队列里添加元素的线程，消费者是从队列里拿元素的线程。阻塞队列就是生产者存放元素的容器，而消费者也只从容器里拿元素。</p><p>&emsp;JDK7提供了7个阻塞队列。分别是：</p><p>&emsp;* ArrayBlockingQueue ：一个由数组结构组成的有界阻塞队列。</p><p>&emsp;* LinkedBlockingQueue ：一个由链表结构组成的有界阻塞队列。</p><p>&emsp;* PriorityBlockingQueue ：一个支持优先级排序的无界阻塞队列。</p><p>&emsp;* DelayQueue：一个使用优先级队列实现的无界阻塞队列。</p><p>&emsp;* SynchronousQueue：一个不存储元素的阻塞队列。</p><p>&emsp;* LinkedTransferQueue：一个由链表结构组成的无界阻塞队列。</p><p>&emsp;* LinkedBlockingDeque：一个由链表结构组成的双向阻塞队列。</p><p>&emsp;Java 5之前实现同步存取时，可以使用普通的一个集合，然后在使用线程的协作和线程同步可以实现生产者，消费者模式，主要的技术就是用好，wait ,notify,notifyAll,sychronized这些关键字。而在java 5之后，可以使用阻塞队列来实现，此方式大大简少了代码量，使得多线程编程更加容易，安全方面也有保障。</p><p>&emsp;BlockingQueue接口是Queue的子接口，它的主要用途并不是作为容器，而是作为线程同步的的工具，因此他具有一个很明显的特性，当生产者线程试图向BlockingQueue放入元素时，如果队列已满，则线程被阻塞，当消费者线程试图从中取出一个元素时，如果队列为空，则该线程会被阻塞，正是因为它所具有这个特性，所以在程序中多个线程交替向BlockingQueue中放入元素，取出元素，它可以很好的控制线程之间的通信。</p><p>&emsp;阻塞队列使用最经典的场景就是socket客户端数据的读取和解析，读取数据的线程不断将数据放入队列，然后解析线程不断从队列取数据解析。</p></blockquote><blockquote><p><strong>互斥锁和自旋锁、信号量的区别？</strong></p><p>&emsp;互斥锁也可以叫互斥量，广义上讲可以值所有实现互斥作用的同步机制。狭义上讲指的就是mutex这种特定的二元锁机制。互斥锁的作用就是互斥，mutual exclusive，是用来保护临界区(critical section)的 。所谓临界区就是代码的一个区间，如果两个线程同时执行就有可能出问题，所以需要互斥锁来保护。</p><p>&emsp;信号量（semaphore） 是一种更高级的同步机制，mutex（互斥锁） 可以说是 semaphore（信号量） 在仅取值0/1时的特例。Semaphore可以有更多的取值空间，用来实现更加复杂的同步，而不单单是线程间互斥。</p><p>&emsp;自旋锁 是一种 互斥锁 的实现方式而已，相比一般的互斥锁会在等待期间放弃cpu，自旋锁（spinlock） 则是不断循环并测试锁的状态，这样就一直占着cpu。所以相比于自旋锁和信号量，在申请锁失败的话，自旋锁会不断的查询，申请线程不会进入休眠，信号量和互斥锁如果申请锁失败的话线程进入休眠，如果申请锁被释放后会唤醒休眠的线程。</p><p>&emsp;同步锁 好像没啥特殊说法，你可以理解为能实现同步作用的都可以叫同步锁，比如信号量。最后，不要钻这些名词的牛角尖，更重要的是理解这些东西背后的原理，叫什么名字并没有什么好说的。这些东西在不同的语言和平台上又有可能会有不同的叫法，其实本质上就这么回事。</p></blockquote><p>未完待续..</p>]]></content>
    
    <summary type="html">
    
      锁相关内容问与答
    
    </summary>
    
      <category term="技术文档" scheme="http://linyishui.top/categories/%E6%8A%80%E6%9C%AF%E6%96%87%E6%A1%A3/"/>
    
    
      <category term="java" scheme="http://linyishui.top/tags/java/"/>
    
      <category term="lock" scheme="http://linyishui.top/tags/lock/"/>
    
      <category term="Q&amp;A" scheme="http://linyishui.top/tags/Q-A/"/>
    
  </entry>
  
  <entry>
    <title>条件等待队列</title>
    <link href="http://linyishui.top/2019081301.html"/>
    <id>http://linyishui.top/2019081301.html</id>
    <published>2019-08-13T01:08:52.000Z</published>
    <updated>2019-09-19T07:54:15.687Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="条件等待队列"><a href="#条件等待队列" class="headerlink" title="条件等待队列"></a><strong>条件等待队列</strong></h1><p>&emsp;当多个线程 await() 在同一个条件变量上时，会形成一个条件等待队列。同一个锁可以创建多个条件变量，就会存在多个条件等待队列。这个队列和 AQS 的队列结构很接近，只不过它不是双向队列，而是单向队列。队列中的节点和 AQS 等待队列的节点是同一个类，但是节点指针不是 prev 和 next，而是 nextWaiter。</p><figure class="highlight crmsh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">class AQS &#123;</span><br><span class="line">  ...</span><br><span class="line">  class ConditionObject &#123;</span><br><span class="line">    <span class="keyword">Node</span> <span class="title">firstWaiter</span>;  // 指向第一个节点</span><br><span class="line">    <span class="keyword">Node</span> <span class="title">lastWaiter</span>;  // 指向第二个节点</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  class <span class="keyword">Node</span> <span class="title">&#123;</span></span><br><span class="line"><span class="title">    static</span> final int CONDITION = -<span class="number">2</span>;</span><br><span class="line">    static final int SIGNAL = -<span class="number">1</span>;</span><br><span class="line">    Thread thread;  // 当前等待的线程</span><br><span class="line">    <span class="keyword">Node</span> <span class="title">nextWaiter</span>;  // 指向下一个条件等待节点</span><br><span class="line"></span><br><span class="line">    <span class="keyword">Node</span> <span class="title">prev</span>;</span><br><span class="line">    <span class="keyword">Node</span> <span class="title">next</span>;</span><br><span class="line">    int waitStatus;  // waitStatus = CONDITION</span><br><span class="line">  &#125;</span><br><span class="line">  ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="https://pic-1258215793.cos.ap-shanghai.myqcloud.com/content/20190316/201903160107.jpg" alt=""></p><p>&emsp;ConditionObject 是 AQS 的内部类，这个对象里会有一个隐藏的指针 this$0 指向外部的 AQS 对象，ConditionObject 可以直接访问 AQS 对象的所有属性和方法（加锁解锁）。位于条件等待队列里的所有节点的 waitStatus 状态都被标记为 CONDITION，表示节点是因为条件变量而等待。</p><hr><h1 id="队列转移"><a href="#队列转移" class="headerlink" title="队列转移"></a><strong>队列转移</strong></h1><p>&emsp;当条件变量的 signal() 方法被调用时，条件等待队列的头节点线程会被唤醒，该节点从条件等待队列中被摘走，然后被转移到 AQS 的等待队列中，准备排队尝试重新获取锁。这时节点的状态从 CONDITION 转为 SIGNAL，表示当前节点是被条件变量唤醒转移过来的。</p><figure class="highlight crmsh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">class AQS &#123;</span><br><span class="line">  ...</span><br><span class="line">  boolean transferForSignal(<span class="keyword">Node</span> <span class="title">node</span>) &#123;</span><br><span class="line">    // 重置节点状态</span><br><span class="line">    if (!<span class="keyword">node</span>.<span class="title">compareAndSetWaitStatus</span>(<span class="keyword">Node</span>.<span class="title">CONDITION</span>, <span class="number">0</span>))</span><br><span class="line">      return <span class="literal">false</span></span><br><span class="line">    <span class="keyword">Node</span> <span class="title">p</span> = enq(<span class="keyword">node</span><span class="title">); // 进入 AQS</span> 等待队列</span><br><span class="line">    int ws = p.waitStatus;</span><br><span class="line">    // 再修改状态为SIGNAL</span><br><span class="line">    if (ws &gt; <span class="number">0</span> || !p.compareAndSetWaitStatus(ws, <span class="keyword">Node</span>.<span class="title">SIGNAL</span>))</span><br><span class="line">       LockSupport.unpark(<span class="keyword">node</span>.<span class="title">thread</span>);</span><br><span class="line">       return <span class="literal">true</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>&emsp;被转移的节点的 nextWaiter 字段的含义也发生了变更，在条件队列里它是下一个节点的指针，在 AQS 等待队列里它是共享锁还是互斥锁的标志。</p><p><img src="https://pic-1258215793.cos.ap-shanghai.myqcloud.com/content/20190316/201903160108.jpg" alt="Java 并发包常用类库依赖结构"></p><hr><p><em>参考博客和文章书籍等：</em></p><blockquote><p>《Java核心技术 卷Ⅰ》</p></blockquote><p><em>因博客主等未标明不可引用，若部分内容涉及侵权请及时告知，我会尽快修改和删除相关内容</em></p>]]></content>
    
    <summary type="html">
    
      介绍Java中的条件等待队列相关内容：条件等待队列和队列转移
    
    </summary>
    
      <category term="技术文档" scheme="http://linyishui.top/categories/%E6%8A%80%E6%9C%AF%E6%96%87%E6%A1%A3/"/>
    
    
      <category term="java" scheme="http://linyishui.top/tags/java/"/>
    
      <category term="lock" scheme="http://linyishui.top/tags/lock/"/>
    
  </entry>
  
  <entry>
    <title>Lock接口</title>
    <link href="http://linyishui.top/2019081201.html"/>
    <id>http://linyishui.top/2019081201.html</id>
    <published>2019-08-12T08:36:10.000Z</published>
    <updated>2019-09-19T09:47:11.412Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="Lock"><a href="#Lock" class="headerlink" title="Lock"></a><strong>Lock</strong></h1><p>&emsp;Lock提供了和synchronized类似的同步功能，但需要显式的获取和释放锁，缺少了便捷性，但增加了锁获取与释放的可操作性、可中断的获取锁以 及超时获取锁等多种synchronized关键字所不具备的同步特性。</p><h2 id="第一节-创建和使用Lock"><a href="#第一节-创建和使用Lock" class="headerlink" title="第一节 创建和使用Lock"></a><strong>第一节 创建和使用Lock</strong></h2><figure class="highlight cos"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">Lock</span> <span class="keyword">lock</span> = <span class="keyword">new</span> ReentrantLock()<span class="comment">;</span></span><br><span class="line"><span class="keyword">lock</span>.<span class="keyword">lock</span>()<span class="comment">;</span></span><br><span class="line"><span class="keyword">try</span>&#123;</span><br><span class="line">    <span class="comment">//不要将获取锁的过程放入try块，若获取锁时发生异常，异常抛出也会导致锁的释放</span></span><br><span class="line">&#125;finally &#123;</span><br><span class="line">    <span class="comment">//保证释放</span></span><br><span class="line">    <span class="keyword">lock</span>.unlock()<span class="comment">;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><h2 id="第二节-Lock接口源码"><a href="#第二节-Lock接口源码" class="headerlink" title="第二节 Lock接口源码"></a><strong>第二节 Lock接口源码</strong></h2><p>&emsp;Lock是一个接口，它定义了锁获取和释放的基本操作。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Lock</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">lock</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">lockInterruptibly</span><span class="params">()</span> <span class="keyword">throws</span> InterruptedException</span>;</span><br><span class="line">    <span class="function"><span class="keyword">boolean</span> <span class="title">tryLock</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">boolean</span> <span class="title">tryLock</span><span class="params">(<span class="keyword">long</span> time, TimeUnit unit)</span> <span class="keyword">throws</span> InterruptedException</span>;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">unlock</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="function">Condition <span class="title">newCondition</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>&emsp;Lock的API如下图所示。</p><p><img src="https://pic-1258215793.cos.ap-shanghai.myqcloud.com/content/20190601/201906010102.png" alt="Lock的API"></p><hr><h2 id="第三节-Lock具备synchronized没有的特性"><a href="#第三节-Lock具备synchronized没有的特性" class="headerlink" title="第三节 Lock具备synchronized没有的特性"></a><strong>第三节 Lock具备synchronized没有的特性</strong></h2><p><img src="https://pic-1258215793.cos.ap-shanghai.myqcloud.com/content/20190601/201906010101.png" alt="Lock接口提供的synchronized关键字不具备的主要特性"></p><hr><p><em>参考博客和文章书籍等：</em></p><blockquote><p>《Java并发编程的艺术》</p></blockquote><p><em>因博客主等未标明不可引用，若部分内容涉及侵权请及时告知，我会尽快修改和删除相关内容</em></p>]]></content>
    
    <summary type="html">
    
      介绍Java中的并发包中Lock接口相关内容：显式获取和释放锁，Lock接口，Lock所具备的synchronized没有的特性等。
    
    </summary>
    
      <category term="技术文档" scheme="http://linyishui.top/categories/%E6%8A%80%E6%9C%AF%E6%96%87%E6%A1%A3/"/>
    
    
      <category term="java" scheme="http://linyishui.top/tags/java/"/>
    
      <category term="lock" scheme="http://linyishui.top/tags/lock/"/>
    
  </entry>
  
  <entry>
    <title>自学习</title>
    <link href="http://linyishui.top/2019081101.html"/>
    <id>http://linyishui.top/2019081101.html</id>
    <published>2019-08-11T08:23:41.000Z</published>
    <updated>2019-09-16T09:01:45.647Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>要学习锁机制，可能浅学会更加容易一些，但脱离的理论和底层细节，在知识点的理解上面就会有不确定的偏差值，久而久之点和点之间矛盾越来越多，知识也没有了统一性了，所以在回顾锁的应用之前，要先学习一下Java中怎么定义和实现锁这个东西的。</p><p>&emsp;学习一个知识点的时候，习惯上我会先搞清楚几个问题：</p><blockquote><ol><li><strong>为什么我要用这个技术？</strong> </li></ol><p>&emsp;确定学习必要性，理由可以如：当前工作需要，准备面试，个人兴趣等。编程的知识内容太多了，而我们的时间是有限的，所以不管是为了工作还是怎样高效的学习都是很有必要的，还有就是不要急于”跳级”学习，由基础开始由浅到深，身边有很多同学Java基础还未掌握好就开始学架构，分布式，服务集群等，一方面是当前不大可能有工作需要，另一方面是代码量和项目经验没有达到一定程度的情况下，可能不会那么容易的理解这些知识，因人而异吧，请在学习前根据自身情况做好规划，这还是蛮重要的。</p></blockquote><blockquote><ol start="2"><li>我怎么去使用这个技术？</li></ol><p>&emsp;学习一个技术，首先就是要会使用它，就像学数学公式一样，可能你不理解它的原理，也没精力或没能力去推理证明，但对于考试来说可能你只要会用就已经足够了。对于工作也是一样，往往我们学一个技术，要先能把它”跑起来”，然后在固定的场景下我们就可以解决一些问题了，但很多人可能就只停留在这个阶段了。这个程度连”了解xx技术”的水平都还没到，不然面试时可能就全是”用过XX吗？”，可能会是很荒诞的一个场景。</p></blockquote><blockquote><ol start="3"><li>如果有其它可以实现同样功能的技术，他们之间的优缺点是什么？引申一下就是什么场景下用什么技术？</li></ol><p>&emsp;不了解一个知识前，我们肯定是总结不出其优缺点，更别说和其它技术的对比了。但因为开发这类工作的特点，就是进度总是比较赶的，总会遇到陌生的难题，也算是工作和学习的区别之一吧，没有时间给你去闷头弄清楚这个，所以我个人会习惯在深入学习前，先查阅资料了解一下技术的相关背景，然后了解一下前人的使用经验，个人感觉这样会节省很多时间来应付一些比较紧急或不太重要的情况。</p></blockquote><p>&emsp;如果一个知识点能够准确回答以上三个问题，表示我已经基本能够正确的使用这个知识点了，大不了就多花点功夫在测试上嘛，但为了能串联知识，加强记忆，真正的掌握一项技术，在有多余时间和精力的情况下还需要再理解更深层的问题：</p><blockquote><ol><li>这个技术怎么运转的？或者说它的工作流程或工作原理是怎样的？</li></ol><p>&emsp;了解一下技术的每一步执行，弄清楚其底层实现，尝试自己手动实现一下。</p></blockquote><blockquote><ol start="2"><li>为什么会这样设计？</li></ol><p>&emsp;再清楚了技术是怎样运作之后，可以思考一下为什么会这样设计？比如是根据什么样的场景或需求所以这样设计，在怎样的情况下使用可能这样的设计会变得糟糕等。</p></blockquote><blockquote><ol start="3"><li>与其相关的知识点有哪些？</li></ol><p>&emsp;了解了以上内容后，对于单个知识点可以说已经掌握了，知识间都是相互联系的，我们为了方便学习而划分为一个个的学科，一个个的章节，一个个的知识点，当知识间可以串联起来汇聚为知识海后就可以成为我们的核心技能了，这是我目前努力的目标。</p></blockquote><p>&emsp;在工作以后，对于学习一定要有一个深刻的意识，即考虑经济效益，知识是没有边界的，人的精力和时间却是很有限的，我们在学习特别是工作后的学习中一定要做好规划，怎样保持适合自己的学习节奏？既能保持一定的学习频率和强度，利用好时间，又能在自己的职业生涯上实现快速的成长？是一个值得深思熟虑的问题。</p><p>&emsp;对于我来讲，现在的方法就是</p><ol><li>先确立一个目标：在短时间内保持一定深度的质量下快速学完Java后端开发技术栈。</li><li>然后制订一个自己会执行的计划：在工作之中留意知识的整理，并通过实战有一定的认知之后，在工作之余抽时间整理为博客文章，根据记忆曲线定期的回顾所整理的内容。</li><li>在一定的积累之后通过项目开发的方式把知识内容再一次的融入到某个自己的项目中，这个项目没有特定的业务需求，只有技术需求。</li></ol>]]></content>
    
    <summary type="html">
    
      闲谈，不泛用
    
    </summary>
    
      <category term="个人记录" scheme="http://linyishui.top/categories/%E4%B8%AA%E4%BA%BA%E8%AE%B0%E5%BD%95/"/>
    
    
      <category term="other" scheme="http://linyishui.top/tags/other/"/>
    
  </entry>
  
  <entry>
    <title>线程实际应用</title>
    <link href="http://linyishui.top/2019081001.html"/>
    <id>http://linyishui.top/2019081001.html</id>
    <published>2019-08-10T07:38:35.000Z</published>
    <updated>2019-09-19T08:10:02.310Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="等待超时模式"><a href="#等待超时模式" class="headerlink" title="等待超时模式"></a><strong>等待超时模式</strong></h1><h2 id="场景"><a href="#场景" class="headerlink" title="场景"></a><strong>场景</strong></h2><p>&emsp;调用方法后需要等待一段时间，若时间内可以得到结果，则立即返回结果，否则超时返回默认结果。</p><p>&emsp;等待/通知模式无法做到超时等待，步骤为加锁、条件循环和处理逻辑。</p><h2 id="内容"><a href="#内容" class="headerlink" title="内容"></a><strong>内容</strong></h2><p>&emsp;超时则需要添加一个时间段T，所以可以得到等待时间为T，超时的时间节点为nowTime+T。所以在原等待/通知模式上可以加入一个超时处理，在等待返回后判断是否超时即可。</p><p>&emsp;伪代码如下：</p><figure class="highlight processing"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//对当前对象加锁</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">Object</span> <span class="built_in">get</span>(<span class="keyword">long</span> mills) <span class="keyword">throws</span> InterruptedException&#123;</span><br><span class="line">    <span class="keyword">long</span> future = System.currentTimeMills() + mills;</span><br><span class="line">    <span class="keyword">long</span> remaining = mills;</span><br><span class="line">    <span class="comment">//当超时大于0并且result返回值不满足要求</span></span><br><span class="line">    <span class="keyword">while</span> ((result == <span class="keyword">null</span>) &amp;&amp; remaining &gt; <span class="number">0</span>)&#123;</span><br><span class="line">        wait(remaining);</span><br><span class="line">        remaining = future - System.currentTimeMills();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>&emsp;即使方法执行时间很长，也不会”永久”阻塞调用者，而是会按时返回。</p><h1 id="数据库连接池"><a href="#数据库连接池" class="headerlink" title="数据库连接池"></a><strong>数据库连接池</strong></h1><h2 id="场景-1"><a href="#场景-1" class="headerlink" title="场景"></a><strong>场景</strong></h2><p>&emsp;模拟从连接池中获取、使用和释放连接的过程。而客户端获取连接的过程被设定为等待超时模式。所以在一定时间若无法获取到可用连接，就会返回给客户端null。</p><h2 id="内容-1"><a href="#内容-1" class="headerlink" title="内容"></a><strong>内容</strong></h2><p>&emsp;ConnectionPool.java</p><figure class="highlight aspectj"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 连接池：通过构造函数初始化连接的最大上限，通过一个双向队列来维护连接，</span></span><br><span class="line"><span class="comment"> * 调用方需要先调用fetchConnection(long)方法来指定在多少毫秒内超时获取连接，</span></span><br><span class="line"><span class="comment"> * 当连接使用完毕后，需要调用releaseConnection(Connection)方法将连接放回线程池。</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ConnectionPool</span> </span>&#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 双向队列-维护连接</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> LinkedList&lt;Connection&gt; pool = <span class="keyword">new</span> LinkedList&lt;&gt;();</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">ConnectionPool</span><span class="params">(<span class="keyword">int</span> initialSize)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(initialSize &gt; <span class="number">0</span>)&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>;i &lt; initialSize;i++)&#123;</span><br><span class="line">                pool.addLast(ConnectionDriver.createConnection());</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="function"><span class="keyword">void</span> <span class="title">releaseConnection</span><span class="params">(Connection connection)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(connection != <span class="keyword">null</span>)&#123;</span><br><span class="line">            <span class="keyword">synchronized</span> (pool)&#123;</span><br><span class="line">                <span class="comment">// 连接释放后需要进行通知，这样其他消费者能够感知到连接池中已经归还了一个连接</span></span><br><span class="line">                pool.addLast(connection);</span><br><span class="line">                pool.notifyAll();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//在mills内无法获取到连接，将会返回null</span></span><br><span class="line">    <span class="keyword">public</span> <span class="function">Connection <span class="title">fetchConnection</span><span class="params">(<span class="keyword">long</span> mills)</span><span class="keyword">throws</span> InterruptedException</span>&#123;</span><br><span class="line">        <span class="keyword">synchronized</span> (pool)&#123;</span><br><span class="line">            <span class="comment">// 完全超时</span></span><br><span class="line">            <span class="keyword">if</span>(mills &lt;= <span class="number">0</span>)&#123;</span><br><span class="line">                <span class="keyword">while</span> (pool.isEmpty())&#123;</span><br><span class="line">                    pool.wait();</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="function"><span class="keyword">return</span> pool.<span class="title">removeFirst</span><span class="params">()</span></span>;</span><br><span class="line">            &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="keyword">long</span> future = System.currentTimeMillis() + mills;</span><br><span class="line">                <span class="keyword">long</span> remaining = mills;</span><br><span class="line">                <span class="keyword">while</span> (pool.isEmpty() &amp;&amp; remaining &gt; <span class="number">0</span>)&#123;</span><br><span class="line">                    pool.wait(remaining);</span><br><span class="line">                    remaining = future - System.currentTimeMillis();</span><br><span class="line">                &#125;</span><br><span class="line">                Connection result = <span class="keyword">null</span>;</span><br><span class="line">                <span class="keyword">if</span>(!pool.isEmpty())&#123;</span><br><span class="line">                    result = pool.removeFirst();</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">return</span> result;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>&emsp;ConnectionDriver.java</p><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"><span class="markdown">/**</span></span></span><br><span class="line"><span class="comment"><span class="markdown"> * 通过动态代理实现了Connection接口，代理只实现了在commit方法调用时休眠100毫秒</span></span></span><br><span class="line"><span class="comment"><span class="markdown"> */</span></span></span><br><span class="line">public <span class="class"><span class="keyword">class</span> <span class="title">ConnectionDriver</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">ConnectionHandler</span> <span class="keyword">implements</span> <span class="title">InvocationHandler</span> </span>&#123;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        public <span class="built_in">Object</span> invoke(<span class="built_in">Object</span> proxy, Method method, <span class="built_in">Object</span>[] args) throws Throwable &#123;</span><br><span class="line">            <span class="keyword">if</span>(method.getName().equals(<span class="string">"commit"</span>))&#123;</span><br><span class="line">                TimeUnit.MICROSECONDS.sleep(<span class="number">100</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//创建一个Connection的代理，在commit时休眠100毫秒</span></span><br><span class="line">    public <span class="keyword">static</span> <span class="keyword">final</span> Connection createConnection()&#123;</span><br><span class="line">        <span class="keyword">return</span> (Connection) Proxy.newProxyInstance(ConnectionDriver.<span class="keyword">class</span>.getClassLoader(),</span><br><span class="line">                <span class="keyword">new</span> Class&lt;?&gt;[]&#123; Connection.<span class="keyword">class</span>&#125;,<span class="keyword">new</span> ConnectionHandler());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>&emsp;ConnectionPoolTest.java</p><figure class="highlight gradle"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 模拟客户端ConnectionRunner获取、使用、最后释放连接的过程</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> ConnectionPoolTest &#123;</span><br><span class="line">    <span class="keyword">static</span> ConnectionPool pool = <span class="keyword">new</span> ConnectionPool(<span class="number">10</span>);</span><br><span class="line">    <span class="comment">//保证所有ConnectionRunner能够同时开始</span></span><br><span class="line">    <span class="keyword">static</span> CountDownLatch start = <span class="keyword">new</span> CountDownLatch(<span class="number">1</span>);</span><br><span class="line">    <span class="comment">//main线程将会等待所有ConnectionRunner结束后才能继续执行</span></span><br><span class="line">    <span class="keyword">static</span> CountDownLatch end;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> main(String[] args)<span class="keyword">throws</span> Exception&#123;</span><br><span class="line">        <span class="comment">//线程数量，可以修改线程数量进行观察</span></span><br><span class="line">        <span class="keyword">int</span> threadCount = <span class="number">10</span>;</span><br><span class="line">        end = <span class="keyword">new</span> CountDownLatch(threadCount);</span><br><span class="line">        <span class="keyword">int</span> <span class="keyword">count</span> = <span class="number">20</span>;</span><br><span class="line">        AtomicInteger got = <span class="keyword">new</span> AtomicInteger();</span><br><span class="line">        AtomicInteger notGot = <span class="keyword">new</span> AtomicInteger();</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>;i &lt; threadCount;i++)&#123;</span><br><span class="line">            Thread thread = <span class="keyword">new</span> Thread(<span class="keyword">new</span> ConnectionRunner(<span class="keyword">count</span>,got,notGot),<span class="string">"ConnectionRunnerThread"</span>);</span><br><span class="line">            thread.start();</span><br><span class="line">        &#125;</span><br><span class="line">        start.countDown();</span><br><span class="line">        end.await();</span><br><span class="line">        System.out.<span class="keyword">println</span>(<span class="string">"total invoke: "</span> + (threadCount * <span class="keyword">count</span>));</span><br><span class="line">        System.out.<span class="keyword">println</span>(<span class="string">"got connection: "</span> + got);</span><br><span class="line">        System.out.<span class="keyword">println</span>(<span class="string">"not got connection "</span> + notGot);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">class</span> ConnectionRunner <span class="keyword">implements</span> Runnable&#123;</span><br><span class="line">        <span class="keyword">int</span> <span class="keyword">count</span>;</span><br><span class="line">        AtomicInteger got;</span><br><span class="line">        AtomicInteger notGot;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">public</span> ConnectionRunner(<span class="keyword">int</span> <span class="keyword">count</span>, AtomicInteger got, AtomicInteger notGot) &#123;</span><br><span class="line">            <span class="keyword">this</span>.<span class="keyword">count</span> = <span class="keyword">count</span>;</span><br><span class="line">            <span class="keyword">this</span>.got = got;</span><br><span class="line">            <span class="keyword">this</span>.notGot = notGot;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        @Override</span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">void</span> run() &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                <span class="comment">//从线程池中获取连接，如果1000ms内无法获取到，将会返回null</span></span><br><span class="line">                <span class="comment">//分别统计连接获取的数量got和未获取到的数量notGot</span></span><br><span class="line">                start.await();</span><br><span class="line">            &#125;<span class="keyword">catch</span> (Exception ex)&#123;</span><br><span class="line">                ex.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">while</span> (<span class="keyword">count</span> &gt; <span class="number">0</span>)&#123;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    <span class="comment">//</span></span><br><span class="line">                    Connection connection = pool.fetchConnection(<span class="number">1000</span>);</span><br><span class="line">                    <span class="keyword">if</span>(connection != <span class="keyword">null</span>)&#123;</span><br><span class="line">                        <span class="keyword">try</span> &#123;</span><br><span class="line">                            connection.createStatement();</span><br><span class="line">                            connection.commit();</span><br><span class="line">                        &#125;<span class="keyword">finally</span> &#123;</span><br><span class="line">                            pool.releaseConnection(connection);</span><br><span class="line">                            got.incrementAndGet();</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">                        notGot.incrementAndGet();</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;<span class="keyword">catch</span> (Exception ex)&#123;</span><br><span class="line">                    ex.printStackTrace();</span><br><span class="line">                &#125;<span class="keyword">finally</span> &#123;</span><br><span class="line">                    <span class="keyword">count</span>--;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            end.countDown();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>&emsp;执行结果如下。</p><figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">total invoke: 200</span><br><span class="line">got connection: 200</span><br><span class="line"><span class="keyword">not</span> got<span class="built_in"> connection </span>0</span><br></pre></td></tr></table></figure><p>&emsp;上述事例中使用了CountDownLatch来确保ConnectionRunnerThread能够同时开始执行，并且在全部执行结束后，才使main线程从等待状态返回。当前设定的场景是10个线程同时运行获取连接池中的连接，通过调节线程数量来观察未获取到连接的情况。线程数、总获取次数、获取到的数量、未获取到的数量以及未获取到的比率，如表所示。</p><p><img src="https://pic-1258215793.cos.ap-shanghai.myqcloud.com/content/20190512/201905170157.png" alt="线程数量与连接获取的关系"></p><p>&emsp;从表中的数据统计可以看出，在资源一定的情况下（连接池中的10个连接），随着客户端线程的逐步增加，客户端出现超时无法获取连接的比率不断升高。虽然客户端线程在这种超时获取的模式下会出现连接无法获取的情况，但是它能够保证客户端线程不会一直挂在连接获取的操作上，而是“按时”返回，并告知客户端连接获取出现问题，是系统的一种自我保护机制。数据库连接池的设计也可以复用到其他的资源获取的场景，针对昂贵资源（比如数据库连接）的获取都应该加以超时限制。</p><h1 id="线程池技术及其示例"><a href="#线程池技术及其示例" class="headerlink" title="线程池技术及其示例"></a><strong>线程池技术及其示例</strong></h1><h2 id="场景-2"><a href="#场景-2" class="headerlink" title="场景"></a><strong>场景</strong></h2><p>&emsp;对于服务端的程序，经常面对的是客户端传入的短小（执行时间短、工作内容较为单一）任务，需要服务端快速处理并返回结果。如果服务端每次接受到一个任务，创建一个线程，然后进行执行，这在原型阶段是个不错的选择，但是面对成千上万的任务递交进服务器时，如果还是采用一个任务一个线程的方式，那么将会创建数以万记的线程，这不是一个好的选择。因为这会使操作系统频繁的进行线程上下文切换，无故增加系统的负载，而线程的创建和消亡都是需要耗费系统资源的，也无疑浪费了系统资源。</p><p>&emsp;线程池技术能够很好地解决这个问题，它预先创建了若干数量的线程，并且不能由用户直接对线程的创建进行控制，在这个前提下重复使用固定或较为固定数目的线程来完成任务的执行。这样做的好处是，一方面，消除了频繁创建和消亡线程的系统资源开销，另一方面，面对过量任务的提交能够平缓的劣化。</p><h2 id="内容-2"><a href="#内容-2" class="headerlink" title="内容"></a><strong>内容</strong></h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">ThreadPool</span>&lt;<span class="title">Job</span> <span class="keyword">extends</span> <span class="title">Runnable</span>&gt; </span>&#123;</span><br><span class="line">    <span class="comment">// 执行一个Job，这个Job需要实现Runnable</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">execute</span><span class="params">(Job job)</span></span>;</span><br><span class="line">    <span class="comment">// 关闭线程池</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">shutdown</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="comment">// 增加工作者线程</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">addWorkers</span><span class="params">(<span class="keyword">int</span> num)</span></span>;</span><br><span class="line">    <span class="comment">// 减少工作者线程</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">removeWorker</span><span class="params">(<span class="keyword">int</span> num)</span></span>;</span><br><span class="line">    <span class="comment">// 得到正在等待执行的任务数量</span></span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">getJobSize</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>&emsp;客户端可以通过execute(Job)方法将Job提交入线程池执行，而客户端自身不用等待Job的执行完成。除了execute(Job)方法以外，线程池接口提供了增大/减少工作者线程以及关闭线程池的方法。这里工作者线程代表着一个重复执行Job的线程，而每个由客户端提交的Job都将进入到一个工作队列中等待工作者线程的处理。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">DefaultThreadPool</span>&lt;<span class="title">Job</span> <span class="keyword">extends</span> <span class="title">Runnable</span>&gt; <span class="keyword">implements</span> <span class="title">ThreadPool</span>&lt;<span class="title">Job</span>&gt; </span>&#123;</span><br><span class="line">    <span class="comment">// 线程池最大限制数</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> MAX_WORKER_NUMBERS = <span class="number">10</span>;</span><br><span class="line">    <span class="comment">// 线程池默认的数量</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> DEFAULT_WORKER_NUMBERS = <span class="number">5</span>;</span><br><span class="line">    <span class="comment">// 线程池最小的数量</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> MIN_WORKER_NUMBERS    = <span class="number">1</span>;</span><br><span class="line">    <span class="comment">// 这是一个工作列表，将会向里面插入工作</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> LinkedList&lt;Job&gt; jobs = <span class="keyword">new</span> LinkedList&lt;&gt;();</span><br><span class="line">    <span class="comment">// 工作者列表</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> List&lt;Worker&gt; workers = Collections.synchronizedList(<span class="keyword">new</span> ArrayList&lt;Worker&gt;());</span><br><span class="line">    <span class="comment">// 工作者线程的数量</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> workerNum = DEFAULT_WORKER_NUMBERS;</span><br><span class="line">    <span class="comment">// 线程编号生成</span></span><br><span class="line">    <span class="keyword">private</span> AtomicLong threadNum = <span class="keyword">new</span> AtomicLong();</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">DefaultThreadPool</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        initializeWokers(DEFAULT_WORKER_NUMBERS);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">DefaultThreadPool</span><span class="params">(<span class="keyword">int</span> num)</span> </span>&#123;</span><br><span class="line">        workerNum = num &gt; MAX_WORKER_NUMBERS ? MAX_WORKER_NUMBERS : num &lt; MIN_WORKER_NUMBERS ? MIN_WORKER_NUMBERS : num;</span><br><span class="line">        initializeWokers(workerNum);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">execute</span><span class="params">(Job job)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (job != <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="comment">// 添加一个工作，然后进行通知</span></span><br><span class="line">            <span class="keyword">synchronized</span> (jobs) &#123;</span><br><span class="line">                jobs.addLast(job);</span><br><span class="line">                jobs.notify();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">shutdown</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (Worker worker : workers) &#123;</span><br><span class="line">            worker.shutdown();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">addWorkers</span><span class="params">(<span class="keyword">int</span> num)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">synchronized</span> (jobs) &#123;</span><br><span class="line">            <span class="comment">// 限制新增的Worker数量不能超过最大值</span></span><br><span class="line">            <span class="keyword">if</span> (num + <span class="keyword">this</span>.workerNum &gt; MAX_WORKER_NUMBERS) &#123;</span><br><span class="line">                num = MAX_WORKER_NUMBERS - <span class="keyword">this</span>.workerNum;</span><br><span class="line">            &#125;</span><br><span class="line">            initializeWokers(num);</span><br><span class="line">            <span class="keyword">this</span>.workerNum += num;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">removeWorker</span><span class="params">(<span class="keyword">int</span> num)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">synchronized</span> (jobs) &#123;</span><br><span class="line">            <span class="keyword">if</span> (num &gt;= <span class="keyword">this</span>.workerNum) &#123;</span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(<span class="string">"beyond workNum"</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 按照给定的数量停止Worker</span></span><br><span class="line">            <span class="keyword">int</span> count = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">while</span> (count &lt; num) &#123;</span><br><span class="line">                Worker worker = workers.get(count);</span><br><span class="line">                <span class="keyword">if</span> (workers.remove(worker)) &#123;</span><br><span class="line">                    worker.shutdown();</span><br><span class="line">                    count++;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">this</span>.workerNum -= count;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getJobSize</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> jobs.size();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 初始化线程工作者</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">initializeWokers</span><span class="params">(<span class="keyword">int</span> num)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; num; i++) &#123;</span><br><span class="line">            Worker worker = <span class="keyword">new</span> Worker();</span><br><span class="line">            workers.add(worker);</span><br><span class="line">            Thread thread = <span class="keyword">new</span> Thread(worker, <span class="string">"ThreadPool-Worker-"</span> + threadNum.            incrementAndGet());</span><br><span class="line">            thread.start();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 工作者，负责消费任务</span></span><br><span class="line">    <span class="class"><span class="keyword">class</span> <span class="title">Worker</span> <span class="keyword">implements</span> <span class="title">Runnable</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 是否工作</span></span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">volatile</span> <span class="keyword">boolean</span>    running    = <span class="keyword">true</span>;</span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            <span class="keyword">while</span> (running) &#123;</span><br><span class="line">                Job job = <span class="keyword">null</span>;</span><br><span class="line">                <span class="keyword">synchronized</span> (jobs) &#123;</span><br><span class="line">                    <span class="comment">// 如果工作者列表是空的，那么就wait</span></span><br><span class="line">                    <span class="keyword">while</span> (jobs.isEmpty()) &#123;</span><br><span class="line">                        <span class="keyword">try</span> &#123;</span><br><span class="line">                            jobs.wait();</span><br><span class="line">                        &#125; <span class="keyword">catch</span> (InterruptedException ex) &#123;</span><br><span class="line">                            <span class="comment">// 感知到外部对WorkerThread的中断操作，返回</span></span><br><span class="line">                            Thread.currentThread().interrupt();</span><br><span class="line">                            <span class="keyword">return</span>;</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="comment">// 取出一个Job</span></span><br><span class="line">                    job = jobs.removeFirst();</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span> (job != <span class="keyword">null</span>) &#123;</span><br><span class="line">                    <span class="keyword">try</span> &#123;</span><br><span class="line">                        job.run();</span><br><span class="line">                    &#125; <span class="keyword">catch</span> (Exception ex) &#123;</span><br><span class="line">                        <span class="comment">// 忽略Job执行中的Exception</span></span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">shutdown</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            running = <span class="keyword">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>&emsp;从线程池的实现可以看到，当客户端调用execute(Job)方法时，会不断地向任务列表jobs中 添加Job，而每个工作者线程会不断地从jobs上取出一个Job进行执行，当jobs为空时，工作者线程进入等待状态。</p><p>&emsp;添加一个Job后，对工作队列jobs调用了其notify()方法，而不是notifyAll()方法，因为能够 确定有工作者线程被唤醒，这时使用notify()方法将会比notifyAll()方法获得更小的开销（避免将等待队列中的线程全部移动到阻塞队列中）。</p><p>&emsp;可以看到，线程池的本质就是使用了一个线程安全的工作队列连接工作者线程和客户端线程，客户端线程将任务放入工作队列后便返回，而工作者线程则不断地从工作队列上取出工作并执行。当工作队列为空时，所有的工作者线程均等待在工作队列上，当有客户端提交了一个任务之后会通知任意一个工作者线程，随着大量的任务被提交，更多的工作者线程会被唤醒。</p><h1 id="一个基于线程池技术的简单Web服务器"><a href="#一个基于线程池技术的简单Web服务器" class="headerlink" title="一个基于线程池技术的简单Web服务器"></a><strong>一个基于线程池技术的简单Web服务器</strong></h1><h2 id="场景-3"><a href="#场景-3" class="headerlink" title="场景"></a><strong>场景</strong></h2><p>&emsp;目前的浏览器都支持多线程访问，比如说在请求一个HTML页面的时候，页面中包含的图片资源、样式资源会被浏览器发起并发的获取，这样用户就不会遇到一直等到一个图片完全下载完成才能继续查看文字内容的尴尬情况。</p><p>&emsp;如果Web服务器是单线程的，多线程的浏览器也没有用武之地，因为服务端还是一个请求 一个请求的顺序处理。因此，大部分Web服务器都是支持并发访问的。常用的Java Web服务器，如Tomcat、Jetty，在其处理请求的过程中都使用到了线程池技术。</p><h2 id="内容-3"><a href="#内容-3" class="headerlink" title="内容"></a><strong>内容</strong></h2><p>&emsp;下面通过使用前一节中的线程池来构造一个简单的Web服务器，这个Web服务器用来处理 HTTP请求，目前只能处理简单的文本和JPG图片内容。这个Web服务器使用main线程不断地接 受客户端Socket的连接，将连接以及请求提交给线程池处理，这样使得Web服务器能够同时处 理多个客户端请求，示例如代码所示。</p><figure class="highlight cs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">SimpleHttpServer</span> &#123;</span><br><span class="line">    <span class="comment">// 处理HttpRequest的线程池</span></span><br><span class="line">    <span class="keyword">static</span> ThreadPool&lt;HttpRequestHandler&gt; threadPool = <span class="keyword">new</span> DefaultThreadPool&lt;HttpRequestHandler&gt;(<span class="number">1</span>);</span><br><span class="line">    <span class="comment">// SimpleHttpServer的根路径</span></span><br><span class="line">    <span class="keyword">static</span> String basePath;</span><br><span class="line">    <span class="keyword">static</span> ServerSocket serverSocket;</span><br><span class="line">    <span class="comment">// 服务监听端口</span></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">int</span> port = <span class="number">8080</span>;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">setPort</span>(<span class="params"><span class="keyword">int</span> port</span>) </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (port &gt; <span class="number">0</span>) &#123;</span><br><span class="line">            SimpleHttpServer.port = port;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">setBasePath</span>(<span class="params">String basePath</span>) </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (basePath != <span class="literal">null</span> &amp;&amp; <span class="keyword">new</span> File(basePath).exists() &amp;&amp; <span class="keyword">new</span> File(basePath).</span><br><span class="line">                isDirectory()) &#123;</span><br><span class="line">            SimpleHttpServer.basePath = basePath;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 启动SimpleHttpServer</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">start</span>(<span class="params"></span>) throws Exception </span>&#123;</span><br><span class="line">        serverSocket = <span class="keyword">new</span> ServerSocket(port);</span><br><span class="line">        Socket socket = <span class="literal">null</span>;</span><br><span class="line">        <span class="keyword">while</span> ((socket = serverSocket.accept()) != <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="comment">// 接收一个客户端Socket，生成一个HttpRequestHandler，放入线程池执行</span></span><br><span class="line">            threadPool.execute(<span class="keyword">new</span> HttpRequestHandler(socket));</span><br><span class="line">        &#125;</span><br><span class="line">        serverSocket.close();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">class</span> <span class="title">HttpRequestHandler</span> <span class="title">implements</span> <span class="title">Runnable</span> &#123;</span><br><span class="line">        <span class="keyword">private</span> Socket socket;</span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="title">HttpRequestHandler</span>(<span class="params">Socket socket</span>) </span>&#123;</span><br><span class="line">            <span class="keyword">this</span>.socket = socket;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        @Override</span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">            String line = <span class="literal">null</span>;</span><br><span class="line">            BufferedReader br = <span class="literal">null</span>;</span><br><span class="line">            BufferedReader reader = <span class="literal">null</span>;</span><br><span class="line">            PrintWriter <span class="keyword">out</span> = <span class="literal">null</span>;</span><br><span class="line">            InputStream <span class="keyword">in</span> = <span class="literal">null</span>;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                reader = <span class="keyword">new</span> BufferedReader(<span class="keyword">new</span> InputStreamReader(socket.getInputStream()));</span><br><span class="line">                String header = reader.readLine();</span><br><span class="line">                <span class="comment">// 由相对路径计算出绝对路径</span></span><br><span class="line">                String filePath = basePath + header.split(<span class="string">" "</span>)[<span class="number">1</span>];</span><br><span class="line">                <span class="keyword">out</span> = <span class="keyword">new</span> PrintWriter(socket.getOutputStream());</span><br><span class="line">                <span class="comment">// 如果请求资源的后缀为jpg或者ico，则读取资源并输出</span></span><br><span class="line">                <span class="keyword">if</span> (filePath.endsWith(<span class="string">"jpg"</span>) || filePath.endsWith(<span class="string">"ico"</span>)) &#123;</span><br><span class="line">                    <span class="keyword">in</span> = <span class="keyword">new</span> FileInputStream(filePath);</span><br><span class="line">                    ByteArrayOutputStream baos = <span class="keyword">new</span> ByteArrayOutputStream();</span><br><span class="line">                    <span class="keyword">int</span> i = <span class="number">0</span>;</span><br><span class="line">                    <span class="keyword">while</span> ((i = <span class="keyword">in</span>.read()) != <span class="number">-1</span>) &#123;</span><br><span class="line">                        baos.write(i);</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="keyword">byte</span>[] array = baos.toByteArray();</span><br><span class="line">                    <span class="keyword">out</span>.println(<span class="string">"HTTP/1.1 200 OK"</span>);</span><br><span class="line">                    <span class="keyword">out</span>.println(<span class="string">"Server: Molly"</span>);</span><br><span class="line">                    <span class="keyword">out</span>.println(<span class="string">"Content-Type: image/jpeg"</span>);</span><br><span class="line">                    <span class="keyword">out</span>.println(<span class="string">"Content-Length: "</span> + array.length);</span><br><span class="line">                    <span class="keyword">out</span>.println(<span class="string">""</span>);</span><br><span class="line">                    socket.getOutputStream().write(array, <span class="number">0</span>, array.length);</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    br = <span class="keyword">new</span> BufferedReader(<span class="keyword">new</span> InputStreamReader(<span class="keyword">new</span> FileInputStream(filePath)));</span><br><span class="line">                    <span class="keyword">out</span> = <span class="keyword">new</span> PrintWriter(socket.getOutputStream());</span><br><span class="line">                    <span class="keyword">out</span>.println(<span class="string">"HTTP/1.1 200 OK"</span>);</span><br><span class="line">                    <span class="keyword">out</span>.println(<span class="string">"Server: Molly"</span>);</span><br><span class="line">                    <span class="keyword">out</span>.println(<span class="string">"Content-Type: text/html; charset=UTF-8"</span>);</span><br><span class="line">                    <span class="keyword">out</span>.println(<span class="string">""</span>);</span><br><span class="line">                    <span class="keyword">while</span> ((line = br.readLine()) != <span class="literal">null</span>) &#123;</span><br><span class="line">                        <span class="keyword">out</span>.println(line);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">out</span>.flush();</span><br><span class="line">            &#125; <span class="keyword">catch</span> (Exception ex) &#123;</span><br><span class="line">                <span class="keyword">out</span>.println(<span class="string">"HTTP/1.1 500"</span>);</span><br><span class="line">                <span class="keyword">out</span>.println(<span class="string">""</span>);</span><br><span class="line">                <span class="keyword">out</span>.flush();</span><br><span class="line">            &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">                close(br, <span class="keyword">in</span>, reader, <span class="keyword">out</span>, socket);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 关闭流或者Socket</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">close</span>(<span class="params">Closeable... closeables</span>) </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (closeables != <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="keyword">for</span> (Closeable closeable : closeables) &#123;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    closeable.close();</span><br><span class="line">                &#125; <span class="keyword">catch</span> (Exception ex) &#123;</span><br><span class="line">                    ex.printStackTrace();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>&emsp;该Web服务器处理用户请求的时序图如图所示。</p><p><img src="https://pic-1258215793.cos.ap-shanghai.myqcloud.com/content/20190512/201905170158.png" alt="SimpleHttpServer时序图"></p><p>&emsp;在图中，SimpleHttpServer在建立了与客户端的连接之后，并不会处理客户端的请求，而是将其包装成HttpRequestHandler并交由线程池处理。在线程池中的Worker处理客户端请求的同时，SimpleHttpServer能够继续完成后续客户端连接的建立，不会阻塞后续客户端的请求。</p><p>&emsp;接下来，通过一个测试对比来认识线程池技术带来服务器吞吐量的提高。我们准备了一个简单的HTML页面，内容如代码所示。</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">html</span>&gt;</span>    </span><br><span class="line">    <span class="tag">&lt;<span class="name">head</span>&gt;</span>       </span><br><span class="line">        <span class="tag">&lt;<span class="name">title</span>&gt;</span>测试页面<span class="tag">&lt;/<span class="name">title</span>&gt;</span>    </span><br><span class="line">    <span class="tag">&lt;/<span class="name">head</span>&gt;</span>    </span><br><span class="line">    </span><br><span class="line">    <span class="tag">&lt;<span class="name">body</span>&gt;</span>        </span><br><span class="line">        <span class="tag">&lt;<span class="name">h1</span>&gt;</span>第一张图片<span class="tag">&lt;/<span class="name">h1</span>&gt;</span>        </span><br><span class="line">        <span class="tag">&lt;<span class="name">img</span> <span class="attr">src</span>=<span class="string">"1.jpg"</span>  /&gt;</span>        </span><br><span class="line">        <span class="tag">&lt;<span class="name">h1</span>&gt;</span>第二张图片<span class="tag">&lt;/<span class="name">h1</span>&gt;</span>        </span><br><span class="line">        <span class="tag">&lt;<span class="name">img</span> <span class="attr">src</span>=<span class="string">"2.jpg"</span>  /&gt;</span>       </span><br><span class="line">        <span class="tag">&lt;<span class="name">h1</span>&gt;</span>第三张图片<span class="tag">&lt;/<span class="name">h1</span>&gt;</span>        </span><br><span class="line">        <span class="tag">&lt;<span class="name">img</span> <span class="attr">src</span>=<span class="string">"3.jpg"</span>  /&gt;</span>    </span><br><span class="line">    <span class="tag">&lt;/<span class="name">body</span>&gt;</span> </span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure><p>&emsp;将SimpleHttpServer的根目录设定到该HTML页面所在目录，并启动SimpleHttpServer，通过Apache HTTP server benchmarking tool（版本2.3）来测试不同线程数下，SimpleHttpServer的吞吐量表现。</p><p>&emsp;测试场景是5000次请求，分10个线程并发执行，测试内容主要考察响应时间（越小越好）和每秒查询的数量（越高越好），测试结果如表所示（机器CPU：i7-3635QM，内存为 8GB，实际输出可能与此表不同）。</p><p><img src="https://pic-1258215793.cos.ap-shanghai.myqcloud.com/content/20190512/201905170159.png" alt="测试结果"></p><p>&emsp;可以看到，随着线程池中线程数量的增加，SimpleHttpServer的吞吐量不断增大，响应时间不断变小，线程池的作用非常明显。</p><p>&emsp;但是，线程池中线程数量并不是越多越好，具体的数量需要评估每个任务的处理时间，以及当前计算机的处理器能力和数量。使用的线程过少，无法发挥处理器的性能；使用的线程过多，将会增加系统的无故开销，起到相反的作用。</p><h1 id="小结"><a href="#小结" class="headerlink" title="小结"></a><strong>小结</strong></h1><p>&emsp;本章从介绍多线程技术带来的好处开始，讲述了如何启动和终止线程以及线程的状态，详细阐述了多线程之间进行通信的基本方式和等待/通知经典范式。在线程应用示例中，使用了等待超时、数据库连接池以及简单线程池3个不同的示例巩固本章前面章节所介绍的Java多线程基础知识。最后通过一个简单的Web服务器将上述知识点串联起来，加深我们对这些知识点的理解。</p><hr><p><em>参考博客和文章书籍等：</em></p><blockquote><p>《Java并发编程的艺术》</p></blockquote><p><em>因博客主等未标明不可引用，若部分内容涉及侵权请及时告知，我会尽快修改和删除相关内容</em></p>]]></content>
    
    <summary type="html">
    
      介绍线程实际应用：等待超时模式，数据库连接池，线程池技术及其示例，一个基于线程池技术的简单Web服务器。
    
    </summary>
    
      <category term="技术文档" scheme="http://linyishui.top/categories/%E6%8A%80%E6%9C%AF%E6%96%87%E6%A1%A3/"/>
    
    
      <category term="java" scheme="http://linyishui.top/tags/java/"/>
    
      <category term="thread" scheme="http://linyishui.top/tags/thread/"/>
    
  </entry>
  
  <entry>
    <title>线程间通信</title>
    <link href="http://linyishui.top/2019080901.html"/>
    <id>http://linyishui.top/2019080901.html</id>
    <published>2019-08-09T03:26:52.000Z</published>
    <updated>2019-09-10T07:35:14.487Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="线程间通信"><a href="#线程间通信" class="headerlink" title="线程间通信"></a><strong>线程间通信</strong></h1><p>&emsp;线程拥有自己的栈空间，线程并不是孤立的运行，除了公共区域，线程间也要进行协作。</p><h2 id="volatile和synchronized"><a href="#volatile和synchronized" class="headerlink" title="volatile和synchronized"></a><strong>volatile和synchronized</strong></h2><p>&emsp;Java支持多个线程同时访问一个对象或者对象的成员变量，由于各个线程各自拥有拷贝，所以线程看到和处理的变量未必是最新值。</p><p>&emsp;关键字volatile可以保证线程访问变量的可见性，但会降低运行效率。而synchronized关键字保证了线程访问变量的可见性和排他性。</p><p>&emsp;synchronized锁同步块通过monitorenter和monitorexit指令，同步方法则是通过方法修饰符的ACC_SYNCHRONIZED来实现。无论是哪种方法，本质都是获取对象的监视器(monitor)，获取过程是排他的，只有一个线程可以拿到synchronized保护对象的监视器。</p><p>&emsp;更多内容可以参考<a href="../2019040201.html" title="Title">volatile</a>，<a href="../2019032701.html" title="Title">synchronized</a></p><hr><h2 id="等待-通知机制"><a href="#等待-通知机制" class="headerlink" title="等待/通知机制"></a><strong>等待/通知机制</strong></h2><p>&emsp;”生产者”线程修改了一个对象的值，”消费者”线程会感知到变化，最简单的实现就是让消费者线程不断地循环检查变量是否符合预期，如下所示。</p><figure class="highlight less"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-tag">while</span> (value != desire)&#123;<span class="comment">//满足条件则跳出循环</span></span><br><span class="line">    <span class="selector-tag">Thread</span><span class="selector-class">.sleep</span>(<span class="number">1000</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-tag">doSomething</span>();</span><br></pre></td></tr></table></figure><p>&emsp;但以上方式存在许多问题：1. 难以保证及时性，睡眠时间过长无法及时发现条件已修改，过短则会进行过多无效的尝试。2. 难以降低开销，通过降低睡眠时间会导致消耗更多的处理器资源。</p><p>&emsp;<strong>等待/通知机制</strong>则有效的解决了上述问题，并设计在Java的Object对象上。</p><p>&emsp;回顾一下Object的notify()和wait()方法。</p><figure class="highlight aspectj"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//通知一个在对象上等待的线程，使其从wait()方法返回，返回的前提是该线程已获取了对象的锁</span></span><br><span class="line"><span class="meta">@HotSpotIntrinsicCandidate</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">native</span> <span class="function"><span class="keyword">void</span> <span class="title">notify</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//通知所有等待在该对象上的线程</span></span><br><span class="line"><span class="meta">@HotSpotIntrinsicCandidate</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">native</span> <span class="function"><span class="keyword">void</span> <span class="title">notifyAll</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//调用该方法的线程进入WAITING状态，只有等待另外线程的通知或被中断才会返回，在调用此方法后会释放对象的锁</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="function"><span class="keyword">void</span> <span class="title">wait</span><span class="params">()</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">    wait(<span class="number">0</span>L);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//等待给定时间后若无通知，则超时返回</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">native</span> <span class="function"><span class="keyword">void</span> <span class="title">wait</span><span class="params">(<span class="keyword">long</span> timeout)</span> <span class="keyword">throws</span> InterruptedException</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="function"><span class="keyword">void</span> <span class="title">wait</span><span class="params">(<span class="keyword">long</span> timeout, <span class="keyword">int</span> nanos)</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (timeout &lt; <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(<span class="string">"timeout value is negative"</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (nanos &lt; <span class="number">0</span> || nanos &gt; <span class="number">999999</span>) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(</span><br><span class="line">                            <span class="string">"nanosecond timeout value out of range"</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (nanos &gt; <span class="number">0</span>) &#123;</span><br><span class="line">        timeout++;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    wait(timeout);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>&emsp;<strong>notify()</strong>：唤醒正在监听此对象的监视线程，同时多个线程等待时随机唤醒一个，选择是任意的可以由执行部分来决定，线程通过调用wait()等待对象，在当前线程放弃对象锁之前被唤醒的线程只能继续等待。唤醒的线程将和其它任意线程竞争并没有优先权力。</p><p>&emsp;<strong>wait()</strong> 使当前线程等待，直到它被唤醒，当前线程需要拥有此对象的监视器锁。此方法会将当前线程放入此对象的等待集合中，放弃在此对象上的同步声明(只是此对象的锁)，当线程等待时，所有可以同步此线程的任何其它对象都会保持锁定状态。(因为只能通过synchronized来获取监视器锁，所以这几个方法应该在同步代码块内调用，否则会抛出异常java.lang.IllegalMonitorStateException)</p><p>&emsp;出于线程调度的目的，线程将会被禁用，并处于休眠状态，直到被notify()任意选择中此线程唤醒，或其它线程调用notifyAll()唤醒，或其它线程调用interrupt()中断了当前线程，或指定的等待时间不为0且已到指定时间</p><p>&emsp;等待/通知机制就是指一个线程A调用了对象O的wait()进入等待状态，另一个线程B调用了对象O的notify()或notifyAll()，线程A收到通知后从对象O的wait()返回，进而执行后续操作，两个线程通过对象O作为中介进行交互。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">WaitNotify</span> </span>&#123;</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">boolean</span> flag = <span class="keyword">true</span>;</span><br><span class="line">    <span class="keyword">static</span> Object lock = <span class="keyword">new</span> Object();</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span><span class="keyword">throws</span> Exception</span>&#123;</span><br><span class="line">        Thread waitThread = <span class="keyword">new</span> Thread(<span class="keyword">new</span> Wait(),<span class="string">"WaitThread"</span>);</span><br><span class="line">        waitThread.start();</span><br><span class="line">        TimeUnit.SECONDS.sleep(<span class="number">1</span>);</span><br><span class="line">        Thread notifyThread = <span class="keyword">new</span> Thread(<span class="keyword">new</span> Notify(),<span class="string">"NotifyThread"</span>);</span><br><span class="line">        notifyThread.start();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Wait</span> <span class="keyword">implements</span> <span class="title">Runnable</span></span>&#123;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span></span>&#123;</span><br><span class="line">            <span class="comment">//加锁，拥有lock的monitor</span></span><br><span class="line">            <span class="keyword">synchronized</span> (lock)&#123;</span><br><span class="line">                <span class="comment">//当条件不满足时，继续wait，同时释放了lock的锁</span></span><br><span class="line">                <span class="keyword">while</span> (flag)&#123;</span><br><span class="line">                    <span class="keyword">try</span> &#123;</span><br><span class="line">                        System.out.println(Thread.currentThread() + <span class="string">" flag is true. wait @ "</span> + <span class="keyword">new</span> SimpleDateFormat(<span class="string">"HH:mm:ss"</span>).format(<span class="keyword">new</span> Date()));</span><br><span class="line">                        lock.wait();</span><br><span class="line">                    &#125;<span class="keyword">catch</span> (InterruptedException ex)&#123;</span><br><span class="line">                        ex.printStackTrace();</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="comment">//条件满足时，完成工作</span></span><br><span class="line">                System.out.println(Thread.currentThread() + <span class="string">" flag is false. running @ "</span> + <span class="keyword">new</span> SimpleDateFormat(<span class="string">"HH:mm:ss"</span>).format(<span class="keyword">new</span> Date()));</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Notify</span> <span class="keyword">implements</span> <span class="title">Runnable</span></span>&#123;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span></span>&#123;</span><br><span class="line">            <span class="comment">//加锁，拥有lock的monitor</span></span><br><span class="line">            <span class="keyword">synchronized</span> (lock)&#123;</span><br><span class="line">                <span class="comment">//获取lock的锁，然后进行通知，通知时不会释放lock的锁</span></span><br><span class="line">                <span class="comment">//直到当前线程释放了lock后，WaitThread才能从wait()中返回</span></span><br><span class="line">                System.out.println(Thread.currentThread() + <span class="string">" hold lock. notify @ "</span> + <span class="keyword">new</span> SimpleDateFormat(<span class="string">"HH:mm:ss"</span>).format(<span class="keyword">new</span> Date()));</span><br><span class="line">                lock.notifyAll();</span><br><span class="line">                flag = <span class="keyword">false</span>;</span><br><span class="line">                SleepUtils.second(<span class="number">5</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//再次加锁</span></span><br><span class="line">            <span class="keyword">synchronized</span> (lock)&#123;</span><br><span class="line">                <span class="comment">//当条件不满足时，继续wait，同时释放了lock的锁</span></span><br><span class="line">                System.out.println(Thread.currentThread() + <span class="string">" hold lock again. sleep @ "</span> + <span class="keyword">new</span> SimpleDateFormat(<span class="string">"HH:mm:ss"</span>).format(<span class="keyword">new</span> Date()));</span><br><span class="line">                SleepUtils.second(<span class="number">5</span>);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SleepUtils</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title">second</span><span class="params">(<span class="keyword">long</span> seconds)</span></span>&#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            TimeUnit.SECONDS.sleep(seconds);</span><br><span class="line">        &#125;<span class="keyword">catch</span> (InterruptedException ex)&#123;</span><br><span class="line">            ex.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>&emsp;运行结果如下。</p><figure class="highlight less"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-tag">Thread</span><span class="selector-attr">[WaitThread,5,main]</span> <span class="selector-tag">flag</span> <span class="selector-tag">is</span> <span class="selector-tag">true</span>. <span class="selector-tag">wait</span> @ <span class="selector-tag">18</span><span class="selector-pseudo">:15</span><span class="selector-pseudo">:32</span></span><br><span class="line"><span class="selector-tag">Thread</span><span class="selector-attr">[NotifyThread,5,main]</span> <span class="selector-tag">hold</span> <span class="selector-tag">lock</span>. <span class="selector-tag">notify</span> @ <span class="selector-tag">18</span><span class="selector-pseudo">:15</span><span class="selector-pseudo">:33</span></span><br><span class="line"><span class="selector-tag">Thread</span><span class="selector-attr">[NotifyThread,5,main]</span> <span class="selector-tag">hold</span> <span class="selector-tag">lock</span> <span class="selector-tag">again</span>. <span class="selector-tag">sleep</span> @ <span class="selector-tag">18</span><span class="selector-pseudo">:15</span><span class="selector-pseudo">:38</span></span><br><span class="line"><span class="selector-tag">Thread</span><span class="selector-attr">[WaitThread,5,main]</span> <span class="selector-tag">flag</span> <span class="selector-tag">is</span> <span class="selector-tag">false</span>. <span class="selector-tag">running</span> @ <span class="selector-tag">18</span><span class="selector-pseudo">:15</span><span class="selector-pseudo">:43</span></span><br></pre></td></tr></table></figure><ol><li>调用wait()，notify()和notifyAll()时，需要先对调用对象加锁。</li><li>调用wait()后，线程由RUNNING转为WAITING，并将当前线程放置到对象的等待队列。</li><li>notify()和notifyAll()调用后，等待线程依旧不会从wait()返回，需要等调用notify()和notifyAll()的线程释放锁后，等待线程才有机会从wait()返回</li><li>notify()方法将等待队列中的一个等待线程转移到同步队列中，而notifyAll()则将等待队列所有线程转移到同步队列中，被移动的线程状态由WAITING转为BLOCKED。</li><li>从wait()方法返回的前提是获取了调用对象的锁。</li></ol><p>&emsp;等待/通知机制依托于同步机制，目的就是确保等待线程从wait()返回时能够感知到通知线程对变量做出的修改。</p><p><img src="https://pic-1258215793.cos.ap-shanghai.myqcloud.com/content/20190512/201905170156.png" alt="WaitNotify.java运行过程"></p><p>&emsp;WaitThread线程和NotifyThread线程模拟了线程间等待通知机制流程，WaitThread首先获取了对象的锁，然后调用了对象的wait()方法，从而放弃锁并进入对象的等待队列WaitQueue中，进入等待状态。由于WaitThread释放了对象的锁，NotifyThread随后获取了对象的锁，并调用对象的notify()方法，将WaitThread从WaitQueue移到SynchronizedQueue中，此时WaitThread的状态变为阻塞状态。NotifyThread释放了锁之后，WaitThread再次获取到锁并从wait()方法返回继续执行。</p><hr><h2 id="等待-通知机制的经典范式"><a href="#等待-通知机制的经典范式" class="headerlink" title="等待/通知机制的经典范式"></a><strong>等待/通知机制的经典范式</strong></h2><h3 id="等待方-消费者"><a href="#等待方-消费者" class="headerlink" title="等待方-消费者"></a><strong>等待方-消费者</strong></h3><blockquote><p>遵守如下原则</p><ol><li>获取对象的锁。</li><li>如果条件不满足，那么调用对象的wait()方法，被通知后仍要检查条件。</li><li>条件满足则执行对应的逻辑。</li></ol></blockquote><p>&emsp;伪代码：</p><figure class="highlight less"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-tag">synchronized</span>(对象)&#123;</span><br><span class="line">    <span class="selector-tag">while</span>(条件不满足)&#123;</span><br><span class="line">        对象<span class="selector-class">.wait</span>();</span><br><span class="line">    &#125;</span><br><span class="line">    对应的处理逻辑</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="通知方-生产者"><a href="#通知方-生产者" class="headerlink" title="通知方-生产者"></a><strong>通知方-生产者</strong></h3><blockquote><p>遵守如下原则</p><ol><li>获取对象的锁。</li><li>改变条件。</li><li>通知所有等待在对象上的线程。</li></ol></blockquote><p>&emsp;伪代码：</p><figure class="highlight less"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-tag">synchronized</span>(对象)&#123;</span><br><span class="line">    改变条件</span><br><span class="line">    对象<span class="selector-class">.notifyAll</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><h2 id="管道输入-输出流"><a href="#管道输入-输出流" class="headerlink" title="管道输入/输出流"></a><strong>管道输入/输出流</strong></h2><p>&emsp;管道输入/输出流和文件输入/输出流或者网络输入/输出流的不同在于它主要用于线程之间的数据传输，传输的媒介为内存。</p><ol><li>PipedOutputStream 面向字节</li><li>PipedInputStream 面向字节</li><li>PipedReader 面向字符</li><li>PipedWriter 面向字符</li></ol><figure class="highlight cs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">Piped</span> &#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span>(<span class="params">String[] args</span>)throws Exception</span>&#123;</span><br><span class="line">        PipedWriter <span class="keyword">out</span> = <span class="keyword">new</span> PipedWriter();</span><br><span class="line">        PipedReader <span class="keyword">in</span> = <span class="keyword">new</span> PipedReader();</span><br><span class="line">        <span class="comment">//将输入输出流进行连接，否则在使用时会抛出IOException</span></span><br><span class="line">        <span class="keyword">out</span>.connect(<span class="keyword">in</span>);</span><br><span class="line">        Thread printThread = <span class="keyword">new</span> Thread(<span class="keyword">new</span> Print(<span class="keyword">in</span>),<span class="string">"PrintThread"</span>);</span><br><span class="line">        printThread.start();</span><br><span class="line">        <span class="keyword">int</span> receive = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">while</span> ((receive = System.<span class="keyword">in</span>.read()) != <span class="number">-1</span>)&#123;</span><br><span class="line">                <span class="keyword">out</span>.write(receive);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;<span class="keyword">finally</span> &#123;</span><br><span class="line">            <span class="keyword">out</span>.close();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">class</span> <span class="title">Print</span> <span class="title">implements</span> <span class="title">Runnable</span>&#123;</span><br><span class="line">        <span class="keyword">private</span> PipedReader <span class="keyword">in</span>;</span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="title">Print</span>(<span class="params">PipedReader <span class="keyword">in</span></span>)</span>&#123;</span><br><span class="line">            <span class="keyword">this</span>.<span class="keyword">in</span> = <span class="keyword">in</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        @Override</span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">            <span class="keyword">int</span> receive = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                <span class="keyword">while</span> ((receive = <span class="keyword">in</span>.read()) != <span class="number">-1</span>)&#123;</span><br><span class="line">                    <span class="comment">//char转asc码</span></span><br><span class="line">                    System.<span class="keyword">out</span>.print((<span class="keyword">char</span>) receive);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;<span class="keyword">catch</span> (IOException ex)&#123;</span><br><span class="line">                ex.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>&emsp;运行结果如下。main线程接收console的输入字符串，通过PipedWriter写入，然后PrintThread则通过PipedReader读出内容并打印。</p><figure class="highlight subunit"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">test </span>word</span><br><span class="line"><span class="keyword">test </span>word</span><br><span class="line">ok ok ok</span><br><span class="line">ok ok ok</span><br></pre></td></tr></table></figure><hr><h2 id="join"><a href="#join" class="headerlink" title="join()"></a><strong>join()</strong></h2><p>&emsp;当有线程A执行了thread.join()，表示线程A需要等待thread线程终止后才能从join()返回。等待前驱线程结束，接收前驱线程的结束通知即等待通知机制。</p><p>&emsp;更多内容请参考<a href="../2019051301.html" title="Title">Thread类源码剖析</a></p><hr><h2 id="ThreadLocal"><a href="#ThreadLocal" class="headerlink" title="ThreadLocal"></a><strong>ThreadLocal</strong></h2><p>&emsp;ThreadLocal，即线程变量，以ThreadLocal为键、以任意对象为值得存储结构。所以可以根据ThreadLocal给线程绑定值。</p><figure class="highlight aspectj"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Profiler</span> </span>&#123;</span><br><span class="line">    <span class="comment">//第一次get()调用会进行初始化(若没有调用set())，每个线程会调用一次</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> ThreadLocal&lt;Long&gt; TIME_THREADLOCAL = <span class="keyword">new</span> ThreadLocal&lt;Long&gt;()&#123;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="keyword">protected</span> <span class="function">Long <span class="title">initialValue</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            <span class="function"><span class="keyword">return</span> System.<span class="title">currentTimeMillis</span><span class="params">()</span></span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="function"><span class="keyword">void</span> <span class="title">begin</span><span class="params">()</span></span>&#123;</span><br><span class="line">        TIME_THREADLOCAL.set(System.currentTimeMillis());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="function"><span class="keyword">long</span> <span class="title">end</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> System.currentTimeMillis() - TIME_THREADLOCAL.get();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="function"><span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span><span class="keyword">throws</span> Exception</span>&#123;</span><br><span class="line">        Profiler.begin();</span><br><span class="line">        TimeUnit.SECONDS.sleep(<span class="number">2</span>);</span><br><span class="line">        System.out.println(<span class="string">"Cost: "</span> + Profiler.end() + <span class="string">" mills"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>&emsp;运行结果如下。</p><figure class="highlight avrasm"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="symbol">Cost:</span> <span class="number">2001</span> mills</span><br></pre></td></tr></table></figure><p>&emsp;Profiler可以用来计算函数耗时，在函数调用前执行begin()，调用后执行end()，而且两次调用不用再一个方法或类内，比如AOP编程中，在调用前切入点执行begin()，在调用后切入点执行end()。</p><hr><p><em>参考博客和文章书籍等：</em></p><blockquote><p>《Java并发编程的艺术》</p></blockquote><p><em>因博客主等未标明不可引用，若部分内容涉及侵权请及时告知，我会尽快修改和删除相关内容</em></p>]]></content>
    
    <summary type="html">
    
      介绍线程间通信：volatile和synchronized，等待/通知机制，经典范式，管道输入/输出流，join()，ThreadLocal等
    
    </summary>
    
      <category term="技术文档" scheme="http://linyishui.top/categories/%E6%8A%80%E6%9C%AF%E6%96%87%E6%A1%A3/"/>
    
    
      <category term="java" scheme="http://linyishui.top/tags/java/"/>
    
      <category term="thread" scheme="http://linyishui.top/tags/thread/"/>
    
  </entry>
  
  <entry>
    <title>跨域问题</title>
    <link href="http://linyishui.top/2019080801.html"/>
    <id>http://linyishui.top/2019080801.html</id>
    <published>2019-08-08T08:46:54.000Z</published>
    <updated>2019-08-29T03:10:52.637Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="跨域问题的来源"><a href="#跨域问题的来源" class="headerlink" title="跨域问题的来源"></a><strong>跨域问题的来源</strong></h1><h2 id="同源策略"><a href="#同源策略" class="headerlink" title="同源策略"></a><strong>同源策略</strong></h2><p>&emsp;浏览器的<strong>同源策略</strong>，对不同源的文档或脚本间交互进行了限制，是为了隔离恶意访问而设计的安全机制。</p><p>&emsp;如果两个页面的协议、端口和主机都相同，则两个页面具有相同的源。</p><blockquote><p>同源策略：</p><ol><li>通常允许跨域写操作（Cross-origin writes）。例如链接（links），重定向以及表单提交。特定少数的HTTP请求需要添加 preflight。</li><li>通常允许跨域资源嵌入（Cross-origin embedding）。</li><li>通常不允许跨域读操作（Cross-origin reads）。但常可以通过内嵌资源来巧妙的进行读取访问。例如可以读取嵌入图片的高度和宽度，调用内嵌脚本的方法，或availability of an embedded resource.</li></ol></blockquote><h2 id="为什么要限制不同源交互？"><a href="#为什么要限制不同源交互？" class="headerlink" title="为什么要限制不同源交互？"></a><strong>为什么要限制不同源交互？</strong></h2><p>&emsp;我们在实现登陆流程时曾使用过Cookie，在验证用户密码后会在响应头上添加Set-Cookie字段返回Token，在之后的通信中浏览器会携带此Cookie，来标识请求用户。假设用户登陆了A网站，收到了令牌，然后又登陆了伪装的B网站，B网站通过伪造界面的方式，误导用户点击后发送给A站请求，即我们熟悉的<strong>CSRF-跨站请求伪造攻击</strong>(<a href="../2019052201.html" title="Title">常见的安全漏洞和攻击方式</a>)。</p><hr><h1 id="如何允许跨源访问"><a href="#如何允许跨源访问" class="headerlink" title="如何允许跨源访问"></a><strong>如何允许跨源访问</strong></h1><h2 id="使用CORS允许跨源访问"><a href="#使用CORS允许跨源访问" class="headerlink" title="使用CORS允许跨源访问"></a><strong>使用CORS允许跨源访问</strong></h2><blockquote><p>&emsp;<strong>跨域资源共享</strong>(CORS：Cross-origin resource sharing)机制允许Web应用服务器进行跨域访问控制，从而使跨域数据传输得以安全进行。现代浏览器支持在API容器中（例如XMLHttpRequest或Fetch）使用CORS，以降低跨域HTTP请求所带来的风险。</p></blockquote><blockquote><p>&emsp;<strong>CORS</strong>是一种机制，它使用额外的HTTP头来告诉浏览器，让运行在一个origin (domain)上的Web应用被准许访问来自不同源服务器上的指定的资源。当一个资源从与该资源本身所在的服务器不同的域、协议或端口请求一个资源时，资源会发起一个跨域HTTP请求。</p></blockquote><blockquote><p>&emsp;比如，站点<a href="http://domain-a.com的某HTML页面通过" target="_blank" rel="noopener">http://domain-a.com的某HTML页面通过</a> <img> 的 src 请求 <a href="http://domain-b.com/image.jpg。网络上的许多页面都会加载来自不同域的CSS样式表，图像和脚本等资源。" target="_blank" rel="noopener">http://domain-b.com/image.jpg。网络上的许多页面都会加载来自不同域的CSS样式表，图像和脚本等资源。</a></p></blockquote><blockquote><p>&emsp;浏览器的同源策略限制从脚本内发起的跨源HTTP请求。例如，XMLHttpRequest和Fetch API遵循同源策略。这意味着使用这些API的Web应用程序只能从加载应用程序的同一个域请求HTTP资源，除非响应报文包含了正确CORS响应头。(这段描述不准确，并不一定是浏览器限制了发起跨站请求，也可能是跨站请求可以正常发起，但是返回结果被浏览器拦截了。)</p></blockquote><h2 id="CORS功能概述"><a href="#CORS功能概述" class="headerlink" title="CORS功能概述"></a><strong>CORS功能概述</strong></h2><blockquote><p>&emsp;跨域资源共享标准新增了一组HTTP首部字段，允许服务器声明哪些源站通过浏览器有权限访问哪些资源。另外，规范要求，对那些可能对服务器数据产生副作用的 HTTP请求方法（特别是GET以外的HTTP请求，或者搭配某些MIME类型的POST请求），浏览器必须首先使用OPTIONS方法发起一个预检请求（preflight request），从而获知服务端是否允许该跨域请求。服务器确认允许之后，才发起实际的HTTP请求。在预检请求的返回中，服务器端也可以通知客户端，是否需要携带身份凭证（包括Cookies和HTTP认证相关数据）。</p></blockquote><blockquote><p>&emsp;CORS请求失败会产生错误，但是为了安全，在JavaScript代码层面是无法获知到底具体是哪里出了问题。你只能查看浏览器的控制台以得知具体是哪里出现了错误。</p></blockquote><p>&emsp;更多内容可以参考：<a href="https://developer.mozilla.org/zh-CN/docs/Web/HTTP/Access_control_CORS" title="Title" target="_blank" rel="noopener">HTTP访问控制（CORS）</a></p><hr><h1 id="如何阻止跨源访问"><a href="#如何阻止跨源访问" class="headerlink" title="如何阻止跨源访问"></a><strong>如何阻止跨源访问</strong></h1><blockquote><ol><li>阻止跨域写操作，只要检测请求中的一个不可测的标记(CSRF token)即可，这个标记被称为Cross-Site Request Forgery (CSRF) 标记。必须使用这个标记来阻止页面的跨站读操作。</li><li>阻止资源的跨站读取，需要保证该资源是不可嵌入的。阻止嵌入行为是必须的，因为嵌入资源通常向其暴露信息。</li><li>阻止跨站嵌入，需要确保你的资源不能是以上列出的可嵌入资源格式。多数情况下浏览器都不会遵守 Content-Type 消息头。例如，如果您在HTML文档中指定&lt; script &gt;标记，则浏览器将尝试将HTML解析为JavaScript。 当您的资源不是您网站的入口点时，您还可以使用CSRF令牌来防止嵌入。</li></ol></blockquote><p><strong>跨源数据存储访问</strong></p><blockquote><p>&emsp;存储在浏览器中的数据，如localStorage和IndexedDB，以源进行分割。每个源都拥有自己单独的存储空间，一个源中的Javascript脚本不能对属于其它源的数据进行读写操作。</p></blockquote><blockquote><p>&emsp;Cookies 使用不同的源定义方式。一个页面可以为本域和任何父域设置cookie，只要是父域不是公共后缀（public suffix）即可。Firefox 和 Chrome 使用 Public Suffix List 决定一个域是否是一个公共后缀（public suffix）。Internet Explorer使用其自己的内部方法来确定域是否是公共后缀。不管使用哪个协议（HTTP/HTTPS）或端口号，浏览器都允许给定的域以及其任何子域名(sub-domains) 访问 cookie。设置 cookie 时，你可以使用Domain，Path，Secure，和Http-Only标记来限定其访问性。读取 cookie 时，不会知晓它的出处。 即使您仅使用安全的https连接，您看到的任何cookie都可能使用不安全的连接进行设置。</p></blockquote><hr><p><em>参考博客和文章书籍等：</em></p><blockquote><p><a href="https://developer.mozilla.org/zh-CN/docs/Web/HTTP/Access_control_CORS" title="Title" target="_blank" rel="noopener">HTTP访问控制（CORS）</a></p></blockquote><blockquote><p><a href="https://segmentfault.com/a/1190000015597029?utm_source=tag-newest" target="_blank" rel="noopener">https://segmentfault.com/a/1190000015597029?utm_source=tag-newest</a></p></blockquote><blockquote><p><a href="https://zhuanlan.zhihu.com/p/25778815" title="Title" target="_blank" rel="noopener">关于跨域，你想知道的全在这里</a></p></blockquote><blockquote><p><a href="https://zhuanlan.zhihu.com/p/66484450" title="Title" target="_blank" rel="noopener">一文搞懂跨域的所有问题</a></p></blockquote><p><em>因博客主等未标明不可引用，若部分内容涉及侵权请及时告知，我会尽快修改和删除相关内容</em></p>]]></content>
    
    <summary type="html">
    
      跨域问题的来源，同源策略，CORS等。
    
    </summary>
    
      <category term="技术文档" scheme="http://linyishui.top/categories/%E6%8A%80%E6%9C%AF%E6%96%87%E6%A1%A3/"/>
    
    
      <category term="web" scheme="http://linyishui.top/tags/web/"/>
    
      <category term="security" scheme="http://linyishui.top/tags/security/"/>
    
  </entry>
  
  <entry>
    <title>单点登录</title>
    <link href="http://linyishui.top/2019080701.html"/>
    <id>http://linyishui.top/2019080701.html</id>
    <published>2019-08-07T08:46:47.000Z</published>
    <updated>2019-10-10T03:04:07.042Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="背景"><a href="#背景" class="headerlink" title="背景"></a><strong>背景</strong></h1><h2 id="HTTP无状态协议"><a href="#HTTP无状态协议" class="headerlink" title="HTTP无状态协议"></a><strong>HTTP无状态协议</strong></h2><p>&emsp;&emsp;Web应用采用B/S架构，HTTP作为通信协议。HTTP是无状态协议，所以浏览器的每一次请求，服务器都会做独立处理，请求之间没有任何关联。</p><p>&emsp;&emsp;所以任何用户都可以通过浏览器来访问服务器资源，为了提高服务器安全性，必然要对访问者进行鉴别，响应合法请求，拦截非法请求。</p><p>&emsp;&emsp;而HTTP协议无状态，就需要浏览器和服务器共同维护对话的状态，即会话机制。</p><h2 id="会话机制"><a href="#会话机制" class="headerlink" title="会话机制"></a><strong>会话机制</strong></h2><p>&emsp;&emsp;浏览器首次请求服务器，服务器会创建一个会话，并将生成的会话ID通过响应返回给浏览器，浏览器收到后存储在客户端，并在之后的请求中携带会话ID，服务器就可以根据会话ID来判断请求者的身份。一般浏览器通过cookie来存储会话ID，发送HTTP请求自动携带cookie信息。如Tomcat应用服务器，会生成jsessionid的cookie信息，即会话ID。</p><h2 id="用户登录状态"><a href="#用户登录状态" class="headerlink" title="用户登录状态"></a><strong>用户登录状态</strong></h2><p>&emsp;&emsp;当浏览器和服务器之间实现了会话机制，就可以维护用户的登陆状态，通过引入登陆机制，密码验证等技术，来保证通信的安全性。</p><h2 id="多系统"><a href="#多系统" class="headerlink" title="多系统"></a><strong>多系统</strong></h2><p>&emsp;&emsp;Web网站系统由单系统发展为多系统组成的应用群，用户不应该一次次的登陆每一个子系统，系统本身复杂性越来越高，但对用户应该保持其简洁性，所以单点登陆的实现有其必要性。但单系统的登陆方案对于多系统来讲并不是很合适，单系统登陆的核心是cookie，而cookie会限制域，浏览器发出请求时只会携带对应域的cookie，所以最初的多系统登陆采用了统一顶级域名的放啊，将cookie域设置为最顶层的域名。但共享cookie有其弊端，首先所有系统域名要统一，然后各系统Web技术要相同，会话ID要统一管理，共享cookie无法实现跨语言平台，还有cookie本身不安全。</p><hr><h1 id="单点登陆"><a href="#单点登陆" class="headerlink" title="单点登陆"></a><strong>单点登陆</strong></h1><p>&emsp;&emsp;单点登陆，即Single Sign On，简称SSO。实现了登陆一次即可获取系统集的授权，跨系统无需再次登陆。</p><h2 id="登陆"><a href="#登陆" class="headerlink" title="登陆"></a><strong>登陆</strong></h2><p>&emsp;&emsp;SSO需要一个独立的认证中心，认证中心担负了系统群的登陆模块，其他系统只需获取认证中心的间接授权。间接授权通过令牌Token来实现，当SSO认证中心完成用户登陆，创建全局会话和授权Token，在之后的跳转过程中将Token发送给子系统，子系统获取Token可以凭此创建局部会话，局部会话的登陆方式和单系统相同。</p><p>–单点登陆授权验证流程</p><p>&emsp;&emsp;用户分别和SSO认证中心和各子系统建立会话，与认证中心创建全局会话，与各子系统创建局部会话。</p><p>&emsp;&emsp;观察淘宝，京东等网站的登陆过程，跳转URL和参数。</p><h2 id="注销"><a href="#注销" class="headerlink" title="注销"></a><strong>注销</strong></h2><p>&emsp;&emsp;子系统注销，会向认证中心发送注销请求，认证中心检查Token合法后，销毁全局会话，取出所有用此令牌注册的系统地址，向所有系统发送注销请求，子系统收到请求后销毁局部会话，最后SSO认证中心引导用户到登陆界面。</p><h2 id="系统间通信"><a href="#系统间通信" class="headerlink" title="系统间通信"></a><strong>系统间通信</strong></h2><p>&emsp;&emsp;认证中心和子系统需要相互通信来交换令牌，校验令牌以及发起注销请求，所以子系统需要集成SSO的客户端，而SSO认证中心则部署服务端，单点登陆过程即客户端和服务端的通信过程。sso认证中心与sso客户端通信方式有多种，这里以简单好用的httpClient为例，web service、rpc、restful api都可以</p><hr><h1 id="单点登陆实现"><a href="#单点登陆实现" class="headerlink" title="单点登陆实现"></a><strong>单点登陆实现</strong></h1><p>&emsp;&emsp;只是简要介绍下基于java的实现过程，不提供完整源码，明白了原理，我相信你们可以自己实现。sso采用客户端/服务端架构，我们先看sso-client与sso-server要实现的功能（下面：sso认证中心=sso-server）</p><blockquote><p>客户端sso-client要实现的功能</p><ol><li>拦截子系统未登录用户请求，跳转至sso认证中心</li><li>接收并存储sso认证中心发送的令牌</li><li>与sso-server通信，校验令牌的有效性</li><li>建立局部会话</li><li>拦截用户注销请求，向sso认证中心发送注销请求</li><li>接收sso认证中心发出的注销请求，销毁局部会话</li></ol></blockquote><blockquote><p>服务端sso-server要实现的功能</p><ol><li>验证用户的登录信息</li><li>创建全局会话</li><li>创建授权令牌</li><li>与sso-client通信发送令牌</li><li>校验sso-client令牌有效性</li><li>系统注册</li><li>接收sso-client注销请求，注销所有会话</li></ol></blockquote><h3 id="一、sso-client拦截未登录请求"><a href="#一、sso-client拦截未登录请求" class="headerlink" title="一、sso-client拦截未登录请求"></a><strong>一、sso-client拦截未登录请求</strong></h3><p>&emsp;&emsp;java拦截请求的方式有servlet、filter、listener三种方式，我们采用filter。在sso-client中新建LoginFilter.java类并实现Filter接口，在doFilter()方法中加入对未登录用户的拦截</p><figure class="highlight aspectj"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="function"><span class="keyword">void</span> <span class="title">doFilter</span><span class="params">(ServletRequest request, ServletResponse response, FilterChain chain)</span> <span class="keyword">throws</span> IOException, ServletException </span>&#123;</span><br><span class="line">   HttpServletRequest req = (HttpServletRequest) request;</span><br><span class="line">   HttpServletResponse res = (HttpServletResponse) response;</span><br><span class="line">   HttpSession session = req.getSession();</span><br><span class="line">    </span><br><span class="line">   <span class="keyword">if</span> (session.getAttribute(<span class="string">"isLogin"</span>)) &#123;</span><br><span class="line">       chain.doFilter(request, response);</span><br><span class="line">       <span class="keyword">return</span>;</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="comment">//跳转至sso认证中心</span></span><br><span class="line">   res.sendRedirect(<span class="string">"sso-server-url-with-system-url"</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="二、sso-server拦截未登录请求"><a href="#二、sso-server拦截未登录请求" class="headerlink" title="二、sso-server拦截未登录请求"></a><strong>二、sso-server拦截未登录请求</strong></h3><p>&emsp;&emsp;拦截从sso-client跳转至sso认证中心的未登录请求，跳转至登录页面，这个过程与sso-client完全一样</p><h3 id="三、sso-server验证用户登录信息"><a href="#三、sso-server验证用户登录信息" class="headerlink" title="三、sso-server验证用户登录信息"></a><strong>三、sso-server验证用户登录信息</strong></h3><p>&emsp;&emsp;用户在登录页面输入用户名密码，请求登录，sso认证中心校验用户信息，校验成功，将会话状态标记为“已登录”</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@RequestMapping(<span class="meta-string">"/login"</span>)</span></span><br><span class="line"><span class="keyword">public</span> String login(String username, String password, HttpServletRequest req) &#123;</span><br><span class="line">   <span class="keyword">this</span>.checkLoginInfo(username, password);</span><br><span class="line">   req.getSession().setAttribute(<span class="string">"isLogin"</span>, <span class="literal">true</span>);</span><br><span class="line">   <span class="keyword">return</span> <span class="string">"success"</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="四、sso-server创建授权令牌"><a href="#四、sso-server创建授权令牌" class="headerlink" title="四、sso-server创建授权令牌"></a><strong>四、sso-server创建授权令牌</strong></h3><p>&emsp;&emsp;授权令牌是一串随机字符，以什么样的方式生成都没有关系，只要不重复、不易伪造即可，下面是一个例子</p><figure class="highlight ebnf"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="attribute">String token</span> = UUID.randomUUID().toString();</span><br></pre></td></tr></table></figure><h3 id="五、sso-client取得令牌并校验"><a href="#五、sso-client取得令牌并校验" class="headerlink" title="五、sso-client取得令牌并校验"></a><strong>五、sso-client取得令牌并校验</strong></h3><p>&emsp;&emsp;sso认证中心登录后，跳转回子系统并附上令牌，子系统（sso-client）取得令牌，然后去sso认证中心校验，在LoginFilter.java的doFilter()中添加几行</p><figure class="highlight gauss"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 请求附带token参数</span></span><br><span class="line"><span class="keyword">String</span> <span class="built_in">token</span> = req.getParameter(<span class="string">"token"</span>);</span><br><span class="line"><span class="keyword">if</span> (<span class="built_in">token</span> != <span class="built_in">null</span>) &#123;</span><br><span class="line">   <span class="comment">// 去sso认证中心校验token</span></span><br><span class="line">   boolean verifyResult = this.verify(<span class="string">"sso-server-verify-url"</span>, <span class="built_in">token</span>);</span><br><span class="line">   <span class="keyword">if</span> (!verifyResult) &#123;</span><br><span class="line">       res.sendRedirect(<span class="string">"sso-server-url"</span>);</span><br><span class="line">       <span class="keyword">return</span>;</span><br><span class="line">   &#125;</span><br><span class="line">   chain.doFilter(request, response);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>&emsp;&emsp;verify()方法使用httpClient实现，这里仅简略介绍，httpClient详细使用方法请参考官方文档</p><figure class="highlight ebnf"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="attribute">HttpPost httpPost</span> = new HttpPost(<span class="string">"sso-server-verify-url-with-token"</span>);</span><br><span class="line"><span class="attribute">HttpResponse httpResponse</span> = httpClient.execute(httpPost);</span><br></pre></td></tr></table></figure><h3 id="六、sso-server接收并处理校验令牌请求"><a href="#六、sso-server接收并处理校验令牌请求" class="headerlink" title="六、sso-server接收并处理校验令牌请求"></a><strong>六、sso-server接收并处理校验令牌请求</strong></h3><p>&emsp;&emsp;用户在sso认证中心登录成功后，sso-server创建授权令牌并存储该令牌，所以，sso-server对令牌的校验就是去查找这个令牌是否存在以及是否过期，令牌校验成功后sso-server将发送校验请求的系统注册到sso认证中心（就是存储起来的意思）</p><p>&emsp;&emsp;令牌与注册系统地址通常存储在key-value数据库（如redis）中，redis可以为key设置有效时间也就是令牌的有效期。redis运行在内存中，速度非常快，正好sso-server不需要持久化任何数据。</p><p>&emsp;&emsp;令牌与注册系统地址可以用下图描述的结构存储在redis中，可能你会问，为什么要存储这些系统的地址？如果不存储，注销的时候就麻烦了，用户向sso认证中心提交注销请求，sso认证中心注销全局会话，但不知道哪些系统用此全局会话建立了自己的局部会话，也不知道要向哪些子系统发送注销请求注销局部会话</p><h3 id="七、sso-client校验令牌成功创建局部会话"><a href="#七、sso-client校验令牌成功创建局部会话" class="headerlink" title="七、sso-client校验令牌成功创建局部会话"></a><strong>七、sso-client校验令牌成功创建局部会话</strong></h3><p>&emsp;&emsp;令牌校验成功后，sso-client将当前局部会话标记为“已登录”，修改LoginFilter.java，添加几行</p><figure class="highlight actionscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (verifyResult) &#123;</span><br><span class="line">   session.setAttribute(<span class="string">"isLogin"</span>, <span class="literal">true</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>&emsp;&emsp;sso-client还需将当前会话id与令牌绑定，表示这个会话的登录状态与令牌相关，此关系可以用java的hashmap保存，保存的数据用来处理sso认证中心发来的注销请求</p><h3 id="八、注销过程"><a href="#八、注销过程" class="headerlink" title="八、注销过程"></a><strong>八、注销过程</strong></h3><p>&emsp;&emsp;用户向子系统发送带有“logout”参数的请求（注销请求），sso-client拦截器拦截该请求，向sso认证中心发起注销请求</p><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">String</span> logout = req.getParameter(<span class="string">"logout"</span>);</span><br><span class="line"><span class="keyword">if</span> (logout != <span class="keyword">null</span>) &#123;</span><br><span class="line">   <span class="keyword">this</span>.ssoServer.logout(token);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>&emsp;&emsp;sso认证中心也用同样的方式识别出sso-client的请求是注销请求（带有“logout”参数），sso认证中心注销全局会话</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@RequestMapping(<span class="meta-string">"/logout"</span>)</span></span><br><span class="line"><span class="keyword">public</span> String logout(HttpServletRequest req) &#123;</span><br><span class="line">   HttpSession session = req.getSession();</span><br><span class="line">   <span class="keyword">if</span> (session != <span class="literal">null</span>) &#123;</span><br><span class="line">       session.invalidate();<span class="comment">//触发LogoutListener</span></span><br><span class="line">   &#125;</span><br><span class="line">   <span class="keyword">return</span> <span class="string">"redirect:/"</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>&emsp;&emsp;sso认证中心有一个全局会话的监听器，一旦全局会话注销，将通知所有注册系统注销</p><figure class="highlight less"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-tag">public</span> <span class="selector-tag">class</span> <span class="selector-tag">LogoutListener</span> <span class="selector-tag">implements</span> <span class="selector-tag">HttpSessionListener</span> &#123;</span><br><span class="line">   <span class="variable">@Override</span></span><br><span class="line">   public void sessionCreated(HttpSessionEvent event) &#123;&#125;</span><br><span class="line">   <span class="variable">@Override</span></span><br><span class="line">   public void sessionDestroyed(HttpSessionEvent event) &#123;</span><br><span class="line">       <span class="comment">//通过httpClient向所有注册系统发送注销请求</span></span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><h1 id="CAS"><a href="#CAS" class="headerlink" title="CAS"></a><strong>CAS</strong></h1><h2 id="基于CAS-Spring-Boot实现客户端"><a href="#基于CAS-Spring-Boot实现客户端" class="headerlink" title="基于CAS+Spring Boot实现客户端"></a><strong>基于CAS+Spring Boot实现客户端</strong></h2><ol><li><p>新建Spring Boot项目</p></li><li><p>pom.xml添加依赖</p></li></ol><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!-- https://mvnrepository.com/artifact/org.jasig.cas.client/cas-client-core --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.jasig.cas.client<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>cas-client-core<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>3.2.1<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure><ol start="3"><li>application.properties添加配置</li></ol><figure class="highlight groovy"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">casServerUrlPrefix=<span class="string">https:</span><span class="comment">//xxxx/authserver/</span></span><br><span class="line">casServerLoginUrl=<span class="string">https:</span><span class="comment">//xxxx/authserver/login</span></span><br><span class="line">serverName=<span class="string">http:</span><span class="comment">//xxxx:8080/</span></span><br></pre></td></tr></table></figure><ol start="4"><li>添加配置类CasConfig.java</li></ol><figure class="highlight haxe"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br></pre></td><td class="code"><pre><span class="line">@Configuration</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">CasConfig</span> </span>&#123;</span><br><span class="line">    @Value(<span class="string">"$&#123;casServerUrlPrefix&#125;"</span>)</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">String</span> casServerUrlPrefix;</span><br><span class="line">    @Value(<span class="string">"$&#123;casServerLoginUrl&#125;"</span>)</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">String</span> casServerLoginUrl;</span><br><span class="line">    @Value(<span class="string">"$&#123;serverName&#125;"</span>)</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">String</span> serverName;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 用于单点退出，该监听器用于实现单点登出功能</span></span><br><span class="line"><span class="comment">     * @return</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    @Bean</span><br><span class="line">    <span class="keyword">public</span> SingleSignOutHttpSessionListener singleSignOutHttpSessionListener()&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="type">SingleSignOutHttpSessionListener</span>();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 该过滤器用于实现单点登出功能</span></span><br><span class="line"><span class="comment">     * @return</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    @Bean</span><br><span class="line">    <span class="keyword">public</span> FilterRegistrationBean singleSignOutFilter() &#123;</span><br><span class="line">        FilterRegistrationBean singleSignOutFilter = <span class="keyword">new</span> <span class="type">FilterRegistrationBean</span>();</span><br><span class="line">        singleSignOutFilter.setFilter(<span class="keyword">new</span> <span class="type">SingleSignOutFilter</span>());</span><br><span class="line">        singleSignOutFilter.setName(<span class="string">"singleSignOutFilter"</span>);</span><br><span class="line">        singleSignOutFilter.addUrlPatterns(<span class="string">"/*"</span>);</span><br><span class="line">        Map&lt;<span class="keyword">String</span>, <span class="keyword">String</span>&gt; initParameters = <span class="keyword">new</span> <span class="type">HashMap</span>&lt;&gt;();</span><br><span class="line">        initParameters.put(<span class="string">"casServerLoginUrl"</span>, casServerLoginUrl);</span><br><span class="line">        initParameters.put(<span class="string">"serverName"</span>, serverName);</span><br><span class="line">        singleSignOutFilter.setInitParameters(initParameters);</span><br><span class="line">        <span class="keyword">return</span> singleSignOutFilter;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 注册authenticationFilter，该过滤器负责用户的认证工作</span></span><br><span class="line"><span class="comment">     * @return</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    @Bean</span><br><span class="line">    <span class="keyword">public</span> FilterRegistrationBean authenticationFilter() &#123;</span><br><span class="line">        FilterRegistrationBean authenticationFilter = <span class="keyword">new</span> <span class="type">FilterRegistrationBean</span>();</span><br><span class="line">        authenticationFilter.setFilter(<span class="keyword">new</span> <span class="type">AuthenticationFilter</span>());</span><br><span class="line">        authenticationFilter.setName(<span class="string">"authenticationFilter"</span>);</span><br><span class="line">        authenticationFilter.addUrlPatterns(<span class="string">"/*"</span>);</span><br><span class="line">        Map&lt;<span class="keyword">String</span>, <span class="keyword">String</span>&gt; initParameters = <span class="keyword">new</span> <span class="type">HashMap</span>&lt;&gt;();</span><br><span class="line">        initParameters.put(<span class="string">"casServerLoginUrl"</span>, casServerLoginUrl);</span><br><span class="line">        initParameters.put(<span class="string">"serverName"</span>, serverName);</span><br><span class="line">        authenticationFilter.setInitParameters(initParameters);</span><br><span class="line">        <span class="keyword">return</span> authenticationFilter;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 该过滤器负责对Ticket的校验工作</span></span><br><span class="line"><span class="comment">     * @return</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    @Bean</span><br><span class="line">    <span class="keyword">public</span> FilterRegistrationBean validationFilter()&#123;</span><br><span class="line">        FilterRegistrationBean validationFilter = <span class="keyword">new</span> <span class="type">FilterRegistrationBean</span>();</span><br><span class="line">        validationFilter.setFilter(<span class="keyword">new</span> <span class="type">Cas20ProxyReceivingTicketValidationFilter</span>());</span><br><span class="line">        validationFilter.setName(<span class="string">"validationFilter"</span>);</span><br><span class="line">        validationFilter.addUrlPatterns(<span class="string">"/*"</span>);</span><br><span class="line">        Map&lt;<span class="keyword">String</span>, <span class="keyword">String</span>&gt; initParameters = <span class="keyword">new</span> <span class="type">HashMap</span>&lt;&gt;();</span><br><span class="line">        initParameters.put(<span class="string">"casServerUrlPrefix"</span>, casServerUrlPrefix);</span><br><span class="line">        initParameters.put(<span class="string">"serverName"</span>, serverName);</span><br><span class="line">        initParameters.put(<span class="string">"encoding"</span>, <span class="string">"UTF-8"</span>);</span><br><span class="line">        validationFilter.setInitParameters(initParameters);</span><br><span class="line">        <span class="keyword">return</span> validationFilter;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 该过滤器负责实现HttpServletRequest请求的包裹，比如允许开发者通过HttpServletRequest的getRemoteUser()方法获得SSO登录用户的登录名</span></span><br><span class="line"><span class="comment">     * @return</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    @Bean</span><br><span class="line">    <span class="keyword">public</span> FilterRegistrationBean httpServletRequestWrapperFilter() &#123;</span><br><span class="line">        FilterRegistrationBean httpServletRequestWrapperFilter = <span class="keyword">new</span> <span class="type">FilterRegistrationBean</span>();</span><br><span class="line">        httpServletRequestWrapperFilter.setFilter(<span class="keyword">new</span> <span class="type">HttpServletRequestWrapperFilter</span>());</span><br><span class="line">        httpServletRequestWrapperFilter.setName(<span class="string">"httpServletRequestWrapperFilter"</span>);</span><br><span class="line">        httpServletRequestWrapperFilter.addUrlPatterns(<span class="string">"/*"</span>);</span><br><span class="line">        Map&lt;<span class="keyword">String</span>, <span class="keyword">String</span>&gt; initParameters = <span class="keyword">new</span> <span class="type">HashMap</span>&lt;&gt;();</span><br><span class="line">        initParameters.put(<span class="string">"casServerLoginUrl"</span>, casServerLoginUrl);</span><br><span class="line">        initParameters.put(<span class="string">"serverName"</span>, serverName);</span><br><span class="line">        httpServletRequestWrapperFilter.setInitParameters(initParameters);</span><br><span class="line">        <span class="keyword">return</span> httpServletRequestWrapperFilter;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol start="5"><li><p>启动项目，测试并观察结果</p></li><li><p>获取用户信息</p></li><li><p>退出登录</p></li><li><p>获取Server SSL证书</p></li></ol><h2 id="基于CAS-Pa4j-Spring-Boot-Shiro实现单点登录"><a href="#基于CAS-Pa4j-Spring-Boot-Shiro实现单点登录" class="headerlink" title="基于CAS+Pa4j+Spring Boot+Shiro实现单点登录"></a><strong>基于CAS+Pa4j+Spring Boot+Shiro实现单点登录</strong></h2><p>&emsp;&emsp;<a href="../2019082201.html" title="Title">基于CAS+Pa4j+Spring Boot+Shiro实现单点登录</a></p><hr><p><em>参考博客和文章书籍等：</em></p><blockquote><p><a href="https://www.zhihu.com/question/342103776/answer/798611224" title="Title" target="_blank" rel="noopener">现在用的比较多的单点登录技术是什么</a></p></blockquote><p><em>因博客主等未标明不可引用，若部分内容涉及侵权请及时告知，我会尽快修改和删除相关内容</em></p>]]></content>
    
    <summary type="html">
    
      跨域问题的来源，同源策略，CORS等。
    
    </summary>
    
      <category term="技术文档" scheme="http://linyishui.top/categories/%E6%8A%80%E6%9C%AF%E6%96%87%E6%A1%A3/"/>
    
    
      <category term="security" scheme="http://linyishui.top/tags/security/"/>
    
  </entry>
  
  <entry>
    <title>Future接口，常见的线程池中的FutureTask实现</title>
    <link href="http://linyishui.top/2019080601.html"/>
    <id>http://linyishui.top/2019080601.html</id>
    <published>2019-08-06T13:28:03.000Z</published>
    <updated>2019-09-10T03:24:04.124Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="Callable"><a href="#Callable" class="headerlink" title="Callable"></a><strong>Callable</strong></h1><p>&emsp;&emsp;Callable是一个函数式接口，声明了call()函数，和run()的区别就是会返回具体的结果，且可以抛出异常。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@FunctionalInterface</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Callable</span>&lt;<span class="title">V</span>&gt; </span>&#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 计算结果并返回</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function">V <span class="title">call</span><span class="params">()</span> <span class="keyword">throws</span> Exception</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="Future"><a href="#Future" class="headerlink" title="Future"></a><strong>Future</strong></h1><p>&emsp;&emsp;Callable的返回值由Future接口获取。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Future</span>&lt;<span class="title">V</span>&gt; </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 尝试取消执行此任务，若任务已完成、已取消或其他原因无法取消则此尝试失败。若执行成功，且执行时任务尚未启动，则此任务不会再运行。若任务已启动，则mayInterruptIfRunning来决定是否中断其执行</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">boolean</span> <span class="title">cancel</span><span class="params">(<span class="keyword">boolean</span> mayInterruptIfRunning)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 若任务在正常完成前被取消则返回true</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">boolean</span> <span class="title">isCancelled</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 若任务执行完毕则返回true</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">boolean</span> <span class="title">isDone</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 等待计算完成，并返回结果</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function">V <span class="title">get</span><span class="params">()</span> <span class="keyword">throws</span> InterruptedException, ExecutionException</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 等待最多指定的时间来完成计算，返回结果</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function">V <span class="title">get</span><span class="params">(<span class="keyword">long</span> timeout, TimeUnit unit)</span></span></span><br><span class="line"><span class="function">        <span class="keyword">throws</span> InterruptedException, ExecutionException, TimeoutException</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>&emsp;&emsp;Future的get()方法是阻塞性的，当计算尚未结束时get()方法会一直阻塞，所以就导致了排队等待，严重的影响到运行效率。</p><figure class="highlight actionscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">RunnableFuture</span>&lt;<span class="title">V</span>&gt; <span class="keyword">extends</span> <span class="title">Runnable</span>, <span class="title">Future</span>&lt;<span class="title">V</span>&gt; </span>&#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 设置此Future为计算结果，除非被取消</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">void</span> run();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="FutureTask"><a href="#FutureTask" class="headerlink" title="FutureTask"></a><strong>FutureTask</strong></h1><figure class="highlight gradle"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br><span class="line">220</span><br><span class="line">221</span><br><span class="line">222</span><br><span class="line">223</span><br><span class="line">224</span><br><span class="line">225</span><br><span class="line">226</span><br><span class="line">227</span><br><span class="line">228</span><br><span class="line">229</span><br><span class="line">230</span><br><span class="line">231</span><br><span class="line">232</span><br><span class="line">233</span><br><span class="line">234</span><br><span class="line">235</span><br><span class="line">236</span><br><span class="line">237</span><br><span class="line">238</span><br><span class="line">239</span><br><span class="line">240</span><br><span class="line">241</span><br><span class="line">242</span><br><span class="line">243</span><br><span class="line">244</span><br><span class="line">245</span><br><span class="line">246</span><br><span class="line">247</span><br><span class="line">248</span><br><span class="line">249</span><br><span class="line">250</span><br><span class="line">251</span><br><span class="line">252</span><br><span class="line">253</span><br><span class="line">254</span><br><span class="line">255</span><br><span class="line">256</span><br><span class="line">257</span><br><span class="line">258</span><br><span class="line">259</span><br><span class="line">260</span><br><span class="line">261</span><br><span class="line">262</span><br><span class="line">263</span><br><span class="line">264</span><br><span class="line">265</span><br><span class="line">266</span><br><span class="line">267</span><br><span class="line">268</span><br><span class="line">269</span><br><span class="line">270</span><br><span class="line">271</span><br><span class="line">272</span><br><span class="line">273</span><br><span class="line">274</span><br><span class="line">275</span><br><span class="line">276</span><br><span class="line">277</span><br><span class="line">278</span><br><span class="line">279</span><br><span class="line">280</span><br><span class="line">281</span><br><span class="line">282</span><br><span class="line">283</span><br><span class="line">284</span><br><span class="line">285</span><br><span class="line">286</span><br><span class="line">287</span><br><span class="line">288</span><br><span class="line">289</span><br><span class="line">290</span><br><span class="line">291</span><br><span class="line">292</span><br><span class="line">293</span><br><span class="line">294</span><br><span class="line">295</span><br><span class="line">296</span><br><span class="line">297</span><br><span class="line">298</span><br><span class="line">299</span><br><span class="line">300</span><br><span class="line">301</span><br><span class="line">302</span><br><span class="line">303</span><br><span class="line">304</span><br><span class="line">305</span><br><span class="line">306</span><br><span class="line">307</span><br><span class="line">308</span><br><span class="line">309</span><br><span class="line">310</span><br><span class="line">311</span><br><span class="line">312</span><br><span class="line">313</span><br><span class="line">314</span><br><span class="line">315</span><br><span class="line">316</span><br><span class="line">317</span><br><span class="line">318</span><br><span class="line">319</span><br><span class="line">320</span><br><span class="line">321</span><br><span class="line">322</span><br><span class="line">323</span><br><span class="line">324</span><br><span class="line">325</span><br><span class="line">326</span><br><span class="line">327</span><br><span class="line">328</span><br><span class="line">329</span><br><span class="line">330</span><br><span class="line">331</span><br><span class="line">332</span><br><span class="line">333</span><br><span class="line">334</span><br><span class="line">335</span><br><span class="line">336</span><br><span class="line">337</span><br><span class="line">338</span><br><span class="line">339</span><br><span class="line">340</span><br><span class="line">341</span><br><span class="line">342</span><br><span class="line">343</span><br><span class="line">344</span><br><span class="line">345</span><br><span class="line">346</span><br><span class="line">347</span><br><span class="line">348</span><br><span class="line">349</span><br><span class="line">350</span><br><span class="line">351</span><br><span class="line">352</span><br><span class="line">353</span><br><span class="line">354</span><br><span class="line">355</span><br><span class="line">356</span><br><span class="line">357</span><br><span class="line">358</span><br><span class="line">359</span><br><span class="line">360</span><br><span class="line">361</span><br><span class="line">362</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 可被取消的异步运算</span></span><br><span class="line"><span class="comment"> * 此类为接口Future的实现类，实现了启动和取消计算，查询计算是否完成以及查询计算结果等方法。</span></span><br><span class="line"><span class="comment"> * 只有在计算完成后才能检索结果，在此之前get()会一直阻塞。计算完成后无法重新启动或者取消计算。</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> FutureTask&lt;V&gt; <span class="keyword">implements</span> RunnableFuture&lt;V&gt; &#123;</span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">     * 修订说明：当前与该类以前依赖AbstractQueuedSynchronizer的版本不同，主要是为了避免在取消竞争期间保留中断状态使用户觉得诧异。当前设计中的同步控制依赖于通过CAS更新的“状态”字段来跟踪完成情况，以及一个简单的treiber堆栈来保存等待的线程。</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * 样式说明：和往常一样，我们绕过使用atomicxfieldupdater的开销，而是直接使用不安全的内部函数。</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 当前任务的执行状态，初始为NEW.  只会在set,setException,cancel中转为终止状态，</span></span><br><span class="line"><span class="comment">     * 在过程中可能会有临时的状态：</span></span><br><span class="line"><span class="comment">     *   COMPLETING (在设置结果时) 和 INTERRUPTING (仅在中断程序以便cancel(true)时)</span></span><br><span class="line"><span class="comment">     * 这些状态转变采用比较廉价的ordered/lazy写入，因为这些值都是唯一的，无法被修改。</span></span><br><span class="line"><span class="comment">     * 可能发生的状态转换:</span></span><br><span class="line"><span class="comment">     * NEW -&gt; COMPLETING -&gt; NORMAL</span></span><br><span class="line"><span class="comment">     * NEW -&gt; COMPLETING -&gt; EXCEPTIONAL</span></span><br><span class="line"><span class="comment">     * NEW -&gt; CANCELLED</span></span><br><span class="line"><span class="comment">     * NEW -&gt; INTERRUPTING -&gt; INTERRUPTED</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">volatile</span> <span class="keyword">int</span> state;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> <span class="keyword">NEW</span>          = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> COMPLETING   = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> NORMAL       = <span class="number">2</span>;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> EXCEPTIONAL  = <span class="number">3</span>;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> CANCELLED    = <span class="number">4</span>;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> INTERRUPTING = <span class="number">5</span>;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> INTERRUPTED  = <span class="number">6</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/** 底层可调用，运行后为null */</span></span><br><span class="line">    <span class="keyword">private</span> Callable&lt;V&gt; callable;</span><br><span class="line">    <span class="comment">/** 返回的结果或get()抛出的异常 */</span></span><br><span class="line">    <span class="keyword">private</span> Object outcome; <span class="comment">// non-volatile, protected by state reads/writes</span></span><br><span class="line">    <span class="comment">/** 运行callable的thread，在run()进行了CAS */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">volatile</span> Thread runner;</span><br><span class="line">    <span class="comment">/** 等待线程的treiber堆栈 */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">volatile</span> WaitNode waiters;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 返回已完成任务的结果</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    @SuppressWarnings(<span class="string">"unchecked"</span>)</span><br><span class="line">    <span class="keyword">private</span> V report(<span class="keyword">int</span> s) <span class="keyword">throws</span> ExecutionException &#123;</span><br><span class="line">        Object x = outcome;</span><br><span class="line">        <span class="keyword">if</span> (s == NORMAL)</span><br><span class="line">            <span class="keyword">return</span> (V)x;</span><br><span class="line">        <span class="keyword">if</span> (s &gt;= CANCELLED)</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> CancellationException();</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> ExecutionException((Throwable)x);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 创建FutureTask&#125;在运行时执行给定的Callable</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> FutureTask(Callable&lt;V&gt; callable) &#123;</span><br><span class="line">        <span class="keyword">if</span> (callable == <span class="keyword">null</span>)</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> NullPointerException();</span><br><span class="line">        <span class="keyword">this</span>.callable = callable;</span><br><span class="line">        <span class="keyword">this</span>.state = <span class="keyword">NEW</span>;       <span class="comment">// 确保callable的可见性</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 创建FutureTask&#125;在运行时执行给定的Callable，并在get()成功结束后返回给定的结果</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> FutureTask(Runnable runnable, V result) &#123;</span><br><span class="line">        <span class="keyword">this</span>.callable = Executors.callable(runnable, result);</span><br><span class="line">        <span class="keyword">this</span>.state = <span class="keyword">NEW</span>;       <span class="comment">// ensure visibility of callable</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">boolean</span> isCancelled() &#123;</span><br><span class="line">        <span class="keyword">return</span> state &gt;= CANCELLED;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">boolean</span> isDone() &#123;</span><br><span class="line">        <span class="keyword">return</span> state != <span class="keyword">NEW</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">boolean</span> cancel(<span class="keyword">boolean</span> mayInterruptIfRunning) &#123;</span><br><span class="line">        <span class="keyword">if</span> (!(state == <span class="keyword">NEW</span> &amp;&amp;</span><br><span class="line">              UNSAFE.compareAndSwapInt(<span class="keyword">this</span>, stateOffset, <span class="keyword">NEW</span>,</span><br><span class="line">                  mayInterruptIfRunning ? INTERRUPTING : CANCELLED)))</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        <span class="keyword">try</span> &#123;    <span class="comment">// in case call to interrupt throws exception</span></span><br><span class="line">            <span class="keyword">if</span> (mayInterruptIfRunning) &#123;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    Thread t = runner;</span><br><span class="line">                    <span class="keyword">if</span> (t != <span class="keyword">null</span>)</span><br><span class="line">                        t.interrupt();</span><br><span class="line">                &#125; <span class="keyword">finally</span> &#123; <span class="comment">// final state</span></span><br><span class="line">                    UNSAFE.putOrderedInt(<span class="keyword">this</span>, stateOffset, INTERRUPTED);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            finishCompletion();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> V get() <span class="keyword">throws</span> InterruptedException, ExecutionException &#123;</span><br><span class="line">        <span class="keyword">int</span> s = state;</span><br><span class="line">        <span class="keyword">if</span> (s &lt;= COMPLETING)</span><br><span class="line">            s = awaitDone(<span class="keyword">false</span>, <span class="number">0</span>L);</span><br><span class="line">        <span class="keyword">return</span> report(s);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> V get(<span class="keyword">long</span> timeout, TimeUnit unit)</span><br><span class="line">        <span class="keyword">throws</span> InterruptedException, ExecutionException, TimeoutException &#123;</span><br><span class="line">        <span class="keyword">if</span> (unit == <span class="keyword">null</span>)</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> NullPointerException();</span><br><span class="line">        <span class="keyword">int</span> s = state;</span><br><span class="line">        <span class="keyword">if</span> (s &lt;= COMPLETING &amp;&amp;</span><br><span class="line">            (s = awaitDone(<span class="keyword">true</span>, unit.toNanos(timeout))) &lt;= COMPLETING)</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> TimeoutException();</span><br><span class="line">        <span class="keyword">return</span> report(s);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 当任务转换为状态isDone(正常流程或cancel()取消)时调用此方法，默认实现什么也不做，子类可以重写此函数来进行回调或执行记录。</span></span><br><span class="line"><span class="comment">     * 可以在函数内查询当前状态，来确定是否已取消此任务。</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">protected</span> <span class="keyword">void</span> done() &#123; &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 设置future的结果为给定值，除非此future已被set或已被cancel</span></span><br><span class="line"><span class="comment">     * 此方法会在完成计算后被run()内部调用</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">protected</span> <span class="keyword">void</span> set(V v) &#123;</span><br><span class="line">        <span class="keyword">if</span> (UNSAFE.compareAndSwapInt(<span class="keyword">this</span>, stateOffset, <span class="keyword">NEW</span>, COMPLETING)) &#123;</span><br><span class="line">            outcome = v;</span><br><span class="line">            UNSAFE.putOrderedInt(<span class="keyword">this</span>, stateOffset, NORMAL); <span class="comment">// final state</span></span><br><span class="line">            finishCompletion();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 使此future声明一个ExecutionException，并将给定的Throwable作为原因，除非此future已被set或已被cancel</span></span><br><span class="line"><span class="comment">     * 此方法会在完成计算失败时被run()内部调用</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">protected</span> <span class="keyword">void</span> setException(Throwable t) &#123;</span><br><span class="line">        <span class="keyword">if</span> (UNSAFE.compareAndSwapInt(<span class="keyword">this</span>, stateOffset, <span class="keyword">NEW</span>, COMPLETING)) &#123;</span><br><span class="line">            outcome = t;</span><br><span class="line">            UNSAFE.putOrderedInt(<span class="keyword">this</span>, stateOffset, EXCEPTIONAL); <span class="comment">// final state</span></span><br><span class="line">            finishCompletion();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> run() &#123;</span><br><span class="line">        <span class="keyword">if</span> (state != <span class="keyword">NEW</span> ||</span><br><span class="line">            !UNSAFE.compareAndSwapObject(<span class="keyword">this</span>, runnerOffset,</span><br><span class="line">                                         <span class="keyword">null</span>, Thread.currentThread()))</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            Callable&lt;V&gt; c = callable;</span><br><span class="line">            <span class="keyword">if</span> (c != <span class="keyword">null</span> &amp;&amp; state == <span class="keyword">NEW</span>) &#123;</span><br><span class="line">                V result;</span><br><span class="line">                <span class="keyword">boolean</span> ran;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    result = c.<span class="keyword">call</span>();</span><br><span class="line">                    ran = <span class="keyword">true</span>;</span><br><span class="line">                &#125; <span class="keyword">catch</span> (Throwable ex) &#123;</span><br><span class="line">                    result = <span class="keyword">null</span>;</span><br><span class="line">                    ran = <span class="keyword">false</span>;</span><br><span class="line">                    setException(ex);</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span> (ran)</span><br><span class="line">                    set(result);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            <span class="comment">// runner must be non-null until state is settled to</span></span><br><span class="line">            <span class="comment">// prevent concurrent calls to run()</span></span><br><span class="line">            runner = <span class="keyword">null</span>;</span><br><span class="line">            <span class="comment">// state must be re-read after nulling runner to prevent</span></span><br><span class="line">            <span class="comment">// leaked interrupts</span></span><br><span class="line">            <span class="keyword">int</span> s = state;</span><br><span class="line">            <span class="keyword">if</span> (s &gt;= INTERRUPTING)</span><br><span class="line">                handlePossibleCancellationInterrupt(s);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 在不设置结果的情况下进行计算，然后将此future设置为初始状态。若计算遇到异常或被cancel，则无法执行此操作。</span></span><br><span class="line"><span class="comment">     * 为了同本质上会执行多次的任务一起执行而设计，成功运行并重置则返回true</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">protected</span> <span class="keyword">boolean</span> runAndReset() &#123;</span><br><span class="line">        <span class="keyword">if</span> (state != <span class="keyword">NEW</span> ||</span><br><span class="line">            !UNSAFE.compareAndSwapObject(<span class="keyword">this</span>, runnerOffset,</span><br><span class="line">                                         <span class="keyword">null</span>, Thread.currentThread()))</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        <span class="keyword">boolean</span> ran = <span class="keyword">false</span>;</span><br><span class="line">        <span class="keyword">int</span> s = state;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            Callable&lt;V&gt; c = callable;</span><br><span class="line">            <span class="keyword">if</span> (c != <span class="keyword">null</span> &amp;&amp; s == <span class="keyword">NEW</span>) &#123;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    c.<span class="keyword">call</span>(); <span class="comment">// don't set result</span></span><br><span class="line">                    ran = <span class="keyword">true</span>;</span><br><span class="line">                &#125; <span class="keyword">catch</span> (Throwable ex) &#123;</span><br><span class="line">                    setException(ex);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            <span class="comment">// runner must be non-null until state is settled to</span></span><br><span class="line">            <span class="comment">// prevent concurrent calls to run()</span></span><br><span class="line">            runner = <span class="keyword">null</span>;</span><br><span class="line">            <span class="comment">// state must be re-read after nulling runner to prevent</span></span><br><span class="line">            <span class="comment">// leaked interrupts</span></span><br><span class="line">            s = state;</span><br><span class="line">            <span class="keyword">if</span> (s &gt;= INTERRUPTING)</span><br><span class="line">                handlePossibleCancellationInterrupt(s);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ran &amp;&amp; s == <span class="keyword">NEW</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 确保来自cancel(true)的任意中断只有在运行或运行和重置时才能传递给任务</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">void</span> handlePossibleCancellationInterrupt(<span class="keyword">int</span> s) &#123;</span><br><span class="line">        <span class="comment">// It is possible for our interrupter to stall before getting a</span></span><br><span class="line">        <span class="comment">// chance to interrupt us.  Let's spin-wait patiently.</span></span><br><span class="line">        <span class="keyword">if</span> (s == INTERRUPTING)</span><br><span class="line">            <span class="keyword">while</span> (state == INTERRUPTING)</span><br><span class="line">                Thread.yield(); <span class="comment">// wait out pending interrupt</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// assert state == INTERRUPTED;</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// We want to clear any interrupt we may have received from</span></span><br><span class="line">        <span class="comment">// cancel(true).  However, it is permissible to use interrupts</span></span><br><span class="line">        <span class="comment">// as an independent mechanism for a task to communicate with</span></span><br><span class="line">        <span class="comment">// its caller, and there is no way to clear only the</span></span><br><span class="line">        <span class="comment">// cancellation interrupt.</span></span><br><span class="line">        <span class="comment">//</span></span><br><span class="line">        <span class="comment">// Thread.interrupted();</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 简单的链表节点，用于在Treiber堆栈中记录等待的线程。</span></span><br><span class="line"><span class="comment">     * 请参阅其他类，如Phaser和SynchronousQueue，以获得更详细的解释。</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">class</span> WaitNode &#123;</span><br><span class="line">        <span class="keyword">volatile</span> Thread thread;</span><br><span class="line">        <span class="keyword">volatile</span> WaitNode <span class="keyword">next</span>;</span><br><span class="line">        WaitNode() &#123; thread = Thread.currentThread(); &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 移除所有等待线程并发出信号，调用done()，置callable为null</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">void</span> finishCompletion() &#123;</span><br><span class="line">        <span class="comment">// assert state &gt; COMPLETING;</span></span><br><span class="line">        <span class="keyword">for</span> (WaitNode q; (q = waiters) != <span class="keyword">null</span>;) &#123;</span><br><span class="line">            <span class="keyword">if</span> (UNSAFE.compareAndSwapObject(<span class="keyword">this</span>, waitersOffset, q, <span class="keyword">null</span>)) &#123;</span><br><span class="line">                <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">                    Thread t = q.thread;</span><br><span class="line">                    <span class="keyword">if</span> (t != <span class="keyword">null</span>) &#123;</span><br><span class="line">                        q.thread = <span class="keyword">null</span>;</span><br><span class="line">                        LockSupport.unpark(t);</span><br><span class="line">                    &#125;</span><br><span class="line">                    WaitNode <span class="keyword">next</span> = q.<span class="keyword">next</span>;</span><br><span class="line">                    <span class="keyword">if</span> (<span class="keyword">next</span> == <span class="keyword">null</span>)</span><br><span class="line">                        <span class="keyword">break</span>;</span><br><span class="line">                    q.<span class="keyword">next</span> = <span class="keyword">null</span>; <span class="comment">// unlink to help gc</span></span><br><span class="line">                    q = <span class="keyword">next</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        done();</span><br><span class="line"></span><br><span class="line">        callable = <span class="keyword">null</span>;        <span class="comment">// to reduce footprint</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 在中断或超时时等待完成或中止</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> awaitDone(<span class="keyword">boolean</span> timed, <span class="keyword">long</span> nanos)</span><br><span class="line">        <span class="keyword">throws</span> InterruptedException &#123;</span><br><span class="line">        <span class="keyword">final</span> <span class="keyword">long</span> deadline = timed ? System.nanoTime() + nanos : <span class="number">0</span>L;</span><br><span class="line">        WaitNode q = <span class="keyword">null</span>;</span><br><span class="line">        <span class="keyword">boolean</span> queued = <span class="keyword">false</span>;</span><br><span class="line">        <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">            <span class="keyword">if</span> (Thread.interrupted()) &#123;</span><br><span class="line">                removeWaiter(q);</span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> InterruptedException();</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">int</span> s = state;</span><br><span class="line">            <span class="keyword">if</span> (s &gt; COMPLETING) &#123;</span><br><span class="line">                <span class="keyword">if</span> (q != <span class="keyword">null</span>)</span><br><span class="line">                    q.thread = <span class="keyword">null</span>;</span><br><span class="line">                <span class="keyword">return</span> s;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (s == COMPLETING) <span class="comment">// cannot time out yet</span></span><br><span class="line">                Thread.yield();</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (q == <span class="keyword">null</span>)</span><br><span class="line">                q = <span class="keyword">new</span> WaitNode();</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (!queued)</span><br><span class="line">                queued = UNSAFE.compareAndSwapObject(<span class="keyword">this</span>, waitersOffset,</span><br><span class="line">                                                     q.<span class="keyword">next</span> = waiters, q);</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (timed) &#123;</span><br><span class="line">                nanos = deadline - System.nanoTime();</span><br><span class="line">                <span class="keyword">if</span> (nanos &lt;= <span class="number">0</span>L) &#123;</span><br><span class="line">                    removeWaiter(q);</span><br><span class="line">                    <span class="keyword">return</span> state;</span><br><span class="line">                &#125;</span><br><span class="line">                LockSupport.parkNanos(<span class="keyword">this</span>, nanos);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">                LockSupport.park(<span class="keyword">this</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 尝试取消链接超时或中断的等待节点，以避免积累垃圾。</span></span><br><span class="line"><span class="comment">     内部节点在没有CAS的情况下是不分割的，因为无论如何释放器都可以遍历到，相对来讲是无害的。</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">void</span> removeWaiter(WaitNode node) &#123;</span><br><span class="line">        <span class="keyword">if</span> (node != <span class="keyword">null</span>) &#123;</span><br><span class="line">            node.thread = <span class="keyword">null</span>;</span><br><span class="line">            retry:</span><br><span class="line">            <span class="keyword">for</span> (;;) &#123;          <span class="comment">// restart on removeWaiter race</span></span><br><span class="line">                <span class="keyword">for</span> (WaitNode pred = <span class="keyword">null</span>, q = waiters, s; q != <span class="keyword">null</span>; q = s) &#123;</span><br><span class="line">                    s = q.<span class="keyword">next</span>;</span><br><span class="line">                    <span class="keyword">if</span> (q.thread != <span class="keyword">null</span>)</span><br><span class="line">                        pred = q;</span><br><span class="line">                    <span class="keyword">else</span> <span class="keyword">if</span> (pred != <span class="keyword">null</span>) &#123;</span><br><span class="line">                        pred.<span class="keyword">next</span> = s;</span><br><span class="line">                        <span class="keyword">if</span> (pred.thread == <span class="keyword">null</span>) <span class="comment">// check for race</span></span><br><span class="line">                            <span class="keyword">continue</span> retry;</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="keyword">else</span> <span class="keyword">if</span> (!UNSAFE.compareAndSwapObject(<span class="keyword">this</span>, waitersOffset,</span><br><span class="line">                                                          q, s))</span><br><span class="line">                        <span class="keyword">continue</span> retry;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Unsafe mechanics</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> sun.misc.Unsafe UNSAFE;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">long</span> stateOffset;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">long</span> runnerOffset;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">long</span> waitersOffset;</span><br><span class="line">    <span class="keyword">static</span> &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            UNSAFE = sun.misc.Unsafe.getUnsafe();</span><br><span class="line">            <span class="keyword">Class</span>&lt;?&gt; k = FutureTask.<span class="keyword">class</span>;</span><br><span class="line">            stateOffset = UNSAFE.objectFieldOffset</span><br><span class="line">                (k.getDeclaredField(<span class="string">"state"</span>));</span><br><span class="line">            runnerOffset = UNSAFE.objectFieldOffset</span><br><span class="line">                (k.getDeclaredField(<span class="string">"runner"</span>));</span><br><span class="line">            waitersOffset = UNSAFE.objectFieldOffset</span><br><span class="line">                (k.getDeclaredField(<span class="string">"waiters"</span>));</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> Error(e);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      线程中断和终止
    
    </summary>
    
      <category term="技术文档" scheme="http://linyishui.top/categories/%E6%8A%80%E6%9C%AF%E6%96%87%E6%A1%A3/"/>
    
    
      <category term="java" scheme="http://linyishui.top/tags/java/"/>
    
      <category term="thread" scheme="http://linyishui.top/tags/thread/"/>
    
  </entry>
  
  <entry>
    <title>Executors剖析</title>
    <link href="http://linyishui.top/2019080501.html"/>
    <id>http://linyishui.top/2019080501.html</id>
    <published>2019-08-05T13:25:25.000Z</published>
    <updated>2019-09-10T03:24:00.176Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>&emsp;&emsp;从JDK1.5开始，Java API提供了Executor框架来创建线程池</p><p><img src="https://pic-1258215793.cos.ap-shanghai.myqcloud.com/content/20190512/776259-20160426201537486-1323529733.png" alt=""></p>]]></content>
    
    <summary type="html">
    
      线程中断和终止
    
    </summary>
    
      <category term="技术文档" scheme="http://linyishui.top/categories/%E6%8A%80%E6%9C%AF%E6%96%87%E6%A1%A3/"/>
    
    
      <category term="java" scheme="http://linyishui.top/tags/java/"/>
    
      <category term="thread" scheme="http://linyishui.top/tags/thread/"/>
    
  </entry>
  
  <entry>
    <title>线程中断和终止</title>
    <link href="http://linyishui.top/2019080401.html"/>
    <id>http://linyishui.top/2019080401.html</id>
    <published>2019-08-04T12:43:42.000Z</published>
    <updated>2019-09-10T03:29:06.251Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="线程中断和终止"><a href="#线程中断和终止" class="headerlink" title="线程中断和终止"></a><strong>线程中断和终止</strong></h1><p>&emsp;中断可以理解为线程的一个标识属性(flag)，当其他线程调用此线程的interrupt()时，对此线程进行中断操作。</p><p>&emsp;当run()执行完方法体最后一条语句经return返回时，或因未捕获的异常跳出时，线程会被终止。interrupt()可以用来请求终止线程，当线程调用interrupt()，其中断状态将被置位。线程应该不时的检查此中断标志，判断自己是否被中断。还有一个stop()方法可以强制终止线程，已被弃用。</p><h2 id="interrupt-和isInterrupted"><a href="#interrupt-和isInterrupted" class="headerlink" title="interrupt()和isInterrupted()"></a><strong>interrupt()和isInterrupted()</strong></h2><p>&emsp;线程则通过检查自己是否被中断进行响应，通过isInterrupted()来判断，也可以通过静态方法Thread.interrupted()来对当前线程的中断标识位进行复位。若该线程已处于终结状态，即使其已被中断过，在调用此线程对象的isInterrupted()时依旧会返回false。</p><figure class="highlight aspectj"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">while</span>(!Thread.currentThread().isInterrupted())&#123;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@HotSpotIntrinsicCandidate</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">native</span> <span class="function">Thread <span class="title">currentThread</span><span class="params">()</span></span>;<span class="comment">//静态方法currentThread()获取当前线程</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="function"><span class="keyword">boolean</span> <span class="title">isInterrupted</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">return</span> <span class="title">isInterrupted</span><span class="params">(<span class="keyword">false</span>)</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@HotSpotIntrinsicCandidate</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">native</span> <span class="function"><span class="keyword">boolean</span> <span class="title">isInterrupted</span><span class="params">(<span class="keyword">boolean</span> ClearInterrupted)</span></span>;<span class="comment">//测试是否有线程被中断，中断状态是否基于传递的参数值重置。</span></span><br></pre></td></tr></table></figure><p>&emsp;当线程被阻塞时，无法检测中断状态，也就是产生异常InterruptedException的地方。当在一个被阻塞的线程(调用过sleep()或wait())上调用interrupt()阻塞调用将会被InterruptedException异常中断。对于一些抛出InterruptedException的方法，在抛出异常前JVM就会擦除中断标识位，然后再抛出异常，所以isInterrupted()仍会返回false</p><p>&emsp;中断并不意味着线程终止，被中断的线程可以决定如何响应中断请求，也可以不理会中断，普遍的情况是把中断请求当作终止请求,如下所示。</p><figure class="highlight actionscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">Runnable r1 = () -&gt; &#123;</span><br><span class="line">    <span class="keyword">try</span>&#123;</span><br><span class="line">        <span class="keyword">while</span>(!Thread.currentThread().isInterrupted())&#123;</span><br><span class="line">            <span class="comment">//继续工作</span></span><br><span class="line">            Thread.sleep(delay);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;<span class="keyword">catch</span> (InterruptedException ex)&#123;<span class="comment">//建议直接在底层方法抛出InterruptedException异常，让调用者去捕获此异常</span></span><br><span class="line">        <span class="comment">//进程阻塞时被请求中断</span></span><br><span class="line">    &#125;<span class="keyword">finally</span> &#123;</span><br><span class="line">        <span class="comment">//释放资源，清理数据</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>&emsp;在中断状态被置位时调用sleep()方法并不会使线程休眠，反而会清除此状态并抛出InterruptedException，若在如上循环中加入sleep()，则没有必要用isInterrupted()，因为不会检测中断状态。</p><figure class="highlight aspectj"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Deprecated</span>(since=<span class="string">"1.2"</span>, forRemoval=<span class="keyword">true</span>)</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">synchronized</span> <span class="function"><span class="keyword">void</span> <span class="title">stop</span><span class="params">(Throwable obj)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> UnsupportedOperationException();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="function"><span class="keyword">void</span> <span class="title">interrupt</span><span class="params">()</span> </span>&#123;<span class="comment">//向线程发送中断请求，线程的中断状态被设置为true，若线程阻塞，则抛出异常</span></span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">this</span> != Thread.currentThread())</span><br><span class="line">        checkAccess();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">synchronized</span> (blockerLock) &#123;</span><br><span class="line">        Interruptible b = blocker;</span><br><span class="line">        <span class="keyword">if</span> (b != <span class="keyword">null</span>) &#123;</span><br><span class="line">            interrupt0();           <span class="comment">// Just to set the interrupt flag</span></span><br><span class="line">            b.interrupt(<span class="keyword">this</span>);</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    interrupt0();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="function"><span class="keyword">boolean</span> <span class="title">interrupted</span><span class="params">()</span> </span>&#123;<span class="comment">//测试当前线程是否被中断，静态方法，只要执行就会将当前状态重置为false</span></span><br><span class="line">    <span class="keyword">return</span> currentThread().isInterrupted(<span class="keyword">true</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="function"><span class="keyword">boolean</span> <span class="title">isInterrupted</span><span class="params">()</span> </span>&#123;<span class="comment">//测试线程是否被终止，此调用不会改变线程的中断状态</span></span><br><span class="line">    <span class="function"><span class="keyword">return</span> <span class="title">isInterrupted</span><span class="params">(<span class="keyword">false</span>)</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@HotSpotIntrinsicCandidate</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">native</span> <span class="function"><span class="keyword">boolean</span> <span class="title">isInterrupted</span><span class="params">(<span class="keyword">boolean</span> ClearInterrupted)</span></span>;<span class="comment">//测试线程是否被终止，中断状态是否重置基于参数判断</span></span><br></pre></td></tr></table></figure><hr><h2 id="suspend-、resume-和stop"><a href="#suspend-、resume-和stop" class="headerlink" title="suspend()、resume()和stop()"></a><strong>suspend()、resume()和stop()</strong></h2><p>&emsp;此三个方法分别实现了线程的暂停、恢复和停止操作。但因为其副作用而被停用，可以采用其他替代方案来代替暂停和恢复。被停用的原因：休眠线程后并不会释放其占用的资源，所以会导致死锁。</p><hr><h2 id="安全的终止线程"><a href="#安全的终止线程" class="headerlink" title="安全的终止线程"></a><strong>安全的终止线程</strong></h2><p>&emsp;中断操作是线程间的一种简单的交互方式，适合用来取消或停止任务。除了中断以外，还可以利用一个布尔变量来控制是否需要停止任务并终止线程。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Shutdown</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span><span class="keyword">throws</span> Exception</span>&#123;</span><br><span class="line">        <span class="comment">//线程1</span></span><br><span class="line">        Runner one = <span class="keyword">new</span> Runner();</span><br><span class="line">        Thread countThread = <span class="keyword">new</span> Thread(one,<span class="string">"CountThread"</span>);</span><br><span class="line">        countThread.start();</span><br><span class="line">        <span class="comment">//睡眠1秒，main线程对CountThread进行中断，使CountThread能够感知中断而结束</span></span><br><span class="line">        TimeUnit.SECONDS.sleep(<span class="number">1</span>);</span><br><span class="line">        countThread.interrupt();</span><br><span class="line"></span><br><span class="line">        <span class="comment">//线程2</span></span><br><span class="line">        Runner two = <span class="keyword">new</span> Runner();</span><br><span class="line">        countThread = <span class="keyword">new</span> Thread(two,<span class="string">"CountThread"</span>);</span><br><span class="line">        countThread.start();</span><br><span class="line">        <span class="comment">//睡眠1秒，main线程对Runner two进行取消，使CountThread能够感知on为false而结束</span></span><br><span class="line">        TimeUnit.SECONDS.sleep(<span class="number">1</span>);</span><br><span class="line">        two.cancel();</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Runner</span> <span class="keyword">implements</span> <span class="title">Runnable</span></span>&#123;</span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">long</span> i;</span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">volatile</span> <span class="keyword">boolean</span> on = <span class="keyword">true</span>;</span><br><span class="line"></span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span></span>&#123;</span><br><span class="line">            <span class="keyword">while</span> (on &amp;&amp; !Thread.currentThread().isInterrupted())&#123;</span><br><span class="line">                i++;</span><br><span class="line">            &#125;</span><br><span class="line">            System.out.println(<span class="string">"Count i = "</span> + i);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">cancel</span><span class="params">()</span></span>&#123;</span><br><span class="line">            on = <span class="keyword">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>&emsp;main线程通过中断操作和cancel()方法均可以使线程CountThread得以终止。这类通过标识位或中断操作的方法能够使线程在终止时可以有机会去清理资源，而不是直接将线程停止，因此这类方法更加安全和优雅。</p><hr><p><em>参考博客和文章书籍等：</em></p><blockquote><p>《Java并发编程的艺术》</p></blockquote><p><em>因博客主等未标明不可引用，若部分内容涉及侵权请及时告知，我会尽快修改和删除相关内容</em></p>]]></content>
    
    <summary type="html">
    
      线程中断和终止，interrupt()和isInterrupted()，suspend()、resume()和stop()，安全的终止线程等。
    
    </summary>
    
      <category term="技术文档" scheme="http://linyishui.top/categories/%E6%8A%80%E6%9C%AF%E6%96%87%E6%A1%A3/"/>
    
    
      <category term="java" scheme="http://linyishui.top/tags/java/"/>
    
      <category term="thread" scheme="http://linyishui.top/tags/thread/"/>
    
  </entry>
  
  <entry>
    <title>杠杆等常见术语</title>
    <link href="http://linyishui.top/2019080301.html"/>
    <id>http://linyishui.top/2019080301.html</id>
    <published>2019-08-03T03:37:23.000Z</published>
    <updated>2019-09-17T02:55:35.704Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="杠杆"><a href="#杠杆" class="headerlink" title="杠杆"></a><strong>杠杆</strong></h1><h2 id="什么是杠杆？"><a href="#什么是杠杆？" class="headerlink" title="什么是杠杆？"></a><strong>什么是杠杆？</strong></h2><blockquote><p>所谓<strong>杠杆</strong>，从狭义上讲，是指<strong>资产与股东权益之比</strong>；从广义讲，则是指<strong>通过负债实现以较小的资本金控制较大的资产规模，从而扩大盈利能力或购买力</strong>。</p></blockquote><p>&emsp;简单理解就是个体债务和实际收入的比值，当你用10块的本金通过借款90块，最后100块就是10倍的杠杆。</p><h2 id="杠杆对于个人有什么影响？"><a href="#杠杆对于个人有什么影响？" class="headerlink" title="杠杆对于个人有什么影响？"></a><strong>杠杆对于个人有什么影响？</strong></h2><p>&emsp;举个例子，个人通过自己本金100等额借到100借款，再用这200再去借到等额的200，如此迭代倍增借贷下去，用户就可以用一个较小的本金借到相当夸张倍数的资产，类似于力学的杠杆效应，支点是杠杆率。当然借款都伴随着利息，而推动用户不断提高杠杆率的动力来源自收益率大于利息，所以资产总量越大获得的利益差额就越大。所以在一个高度增长的经济环境下，通过这样的方法可以让个体获得巨大的利益。假设我们通过1W本金，通过利率5%借贷最多借到了20W。我们通过股票市场可以稳定赚到10%的利润。那么我们通过借贷获得的利润就是2W，再除去利息9500，获得纯利润10500，是我们本金能赚到的10倍。(比较粗糙的计算，理解原理即可)</p><p>&emsp;从上述例子可以看出来杠杆率其实相比负债率更能体现债务的偿还能力，比如一人固定资产如房子等价值500万，但其年收入为10万，如果他贷款250万，根据计算资产负债率=负债总额/资产总额，负债率只有33%，是比较正常的数值，但实际情况下如果不卖房子他是没有偿还能力的。</p><h3 id="银行借贷杠杆"><a href="#银行借贷杠杆" class="headerlink" title="银行借贷杠杆"></a><strong>银行借贷杠杆</strong></h3><p>&emsp;银行有一个准备金率，准备金是金融机构为保证客户提取存款和资金清算需要而准备的，是缴存在中央银行的存款，准备金率就是存款准备金占其存款总额的比例。假设准备金率是20%，所以当我有本金100时，我可以通过反复借贷拿到最多500元。这种方式叫<strong>间接融资</strong>，而间接融资很明显会产生一个杠杆效应，会增加市场货币。</p><p>&emsp;直接融资就是直接借出100给企业融资，增加直接融资的比例也间接的是在去杠杆。</p><h1 id="去杠杆"><a href="#去杠杆" class="headerlink" title="去杠杆"></a><strong>去杠杆</strong></h1><h2 id="为什么要去杠杆？"><a href="#为什么要去杠杆？" class="headerlink" title="为什么要去杠杆？"></a><strong>为什么要去杠杆？</strong></h2><p>&emsp;自从次贷危机爆发以来，“去杠杆化”一词遍从国外一直流行到国内。所谓“去杠杆化”，是指公司或者个人减少使用金融杠杆，把原来通过各种方式“借”到的钱退还出去的这样一个潮流。</p><p>&emsp;杠杆实际上就是借贷盈利，环境好的时候，资金回笼，参与者都能大赚一笔；环境不好的时候，利息压死人，所以要大量变卖手里的筹码，让大量企业和个人担负大量的债务，甚至瞬间破产。</p><p>&emsp;环境好的时候，企业会利用高杠杆扩大生产规模，追求更多的利益，生产出来的东西超过人们所需要的，就会导致产能过剩和资源浪费。</p><p>&emsp;在国内，可能大部分贷款都是用来炒股，炒房，做一些布局和烧钱的投资，或者搞高污染高耗能的产业，这些钱并没有用来提高生产力和创造足够多的实际经济贡献，社会产能结构慢慢失衡。</p><p>&emsp;2008年全球金融危机，背后就是高杠杆引发的一系列连锁反应。我国这么多年，一直在加杠杆，尤其是2008年以后，一直以高杠杆换取高增长的经济增速，杠杆高到一定程度就会到风险不可控的地步，为了逐渐减少金融风险，让经济回归正常发展，必须要去杠杆。</p><h2 id="高杠杆的影响？"><a href="#高杠杆的影响？" class="headerlink" title="高杠杆的影响？"></a><strong>高杠杆的影响？</strong></h2><p>&emsp;高杠杆率对应着高风险，在经济增长比较良好的阶段，市场规模一直在扩大，高杠杆总有人接盘，经济也没有太大的不良反应。</p><p>&emsp;杠杆是一个强力的经济工具，用好这个工具其实对经济和社会都是利大于弊的，有个经济现象叫“明斯基时刻”（Minsky Moment）是指海曼·明斯基Hyman Minsky(美国经济学家)所描述的时刻，即资产价值崩溃时刻。他的观点主要是经济长时期稳定可能导致债务增加、杠杆比率上升，进而从内部滋生爆发金融危机和陷入漫长去杠杆化周期的风险。明斯基时刻表示的是市场繁荣与衰退之间的转折点。在我的理解种人性在这里面起主导作用，而避免明斯基时刻。</p><h2 id="如何去杠杆？"><a href="#如何去杠杆？" class="headerlink" title="如何去杠杆？"></a><strong>如何去杠杆？</strong></h2><ol><li>缩紧信贷，提高门槛，加强监管。</li><li>减少负债，悬崖勒马，制度改革。</li></ol><h2 id="货币升值的影响？"><a href="#货币升值的影响？" class="headerlink" title="货币升值的影响？"></a><strong>货币升值的影响？</strong></h2><blockquote><p>从几个角度来分析：</p><ol><li>A币升值-&gt;A币能换到更多的B币-&gt;国民对外购买力增强</li><li>A币升值-&gt;B币只能换更少的A币-&gt;企业在A国成本不会有太大改变-&gt;对外商品定价不变的情况下利润一定是减少的-&gt;企业只能提高在外产品售价-&gt;商品失去竞争力</li></ol></blockquote><p>&emsp;利润计算：成本300A，售价100B，A和B兑换比例：4 : 1。所以此时企业利润为：100A/25B。当A币升值，兑换比例变为2 ：1，成本售价不变，企业亏损100A/25B，为了保持过往利润，需要将售价提升到200B。商品丧失掉在B对应市场的竞争力。 </p><hr><p><em>参考博客和文章书籍等：</em></p><blockquote><p><a href="https://www.zhihu.com/question/20417339/answer/136814369" title="Title" target="_blank" rel="noopener">金融机构的去杠杆化以及杠杆率是什么意思？</a></p></blockquote><blockquote><p><a href="http://www.sohu.com/a/237595453_250785" title="Title" target="_blank" rel="noopener">如何防范“明斯基时刻”？</a></p></blockquote><blockquote><p><a href="https://zh.wikipedia.org/zh/%E8%B3%87%E9%87%91%E6%A7%93%E6%A1%BF" title="Title" target="_blank" rel="noopener">资金杠杆-维基百科</a></p></blockquote><p><em>因博客主等未标明不可引用，若部分内容涉及侵权请及时告知，我会尽快修改和删除相关内容</em></p>]]></content>
    
    <summary type="html">
    
      简单理解新闻和文章常谈的去杠杆化，杠杆是什么，为什么要去杠杆？
    
    </summary>
    
      <category term="金融经济" scheme="http://linyishui.top/categories/%E9%87%91%E8%9E%8D%E7%BB%8F%E6%B5%8E/"/>
    
    
      <category term="economy" scheme="http://linyishui.top/tags/economy/"/>
    
  </entry>
  
</feed>
