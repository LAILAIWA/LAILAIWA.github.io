<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>沂水博客</title>
  
  <subtitle>编程和心历记录</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://linyishui.top/"/>
  <updated>2018-07-27T12:07:50.000Z</updated>
  <id>http://linyishui.top/</id>
  
  <author>
    <name>沂水</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>Hello World</title>
    <link href="http://linyishui.top/hello-world.html"/>
    <id>http://linyishui.top/hello-world.html</id>
    <published>2019-06-10T03:34:04.463Z</published>
    <updated>2018-07-27T12:07:50.000Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>Welcome to <a href="https://hexo.io/" target="_blank" rel="noopener">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/" target="_blank" rel="noopener">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html" target="_blank" rel="noopener">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues" target="_blank" rel="noopener">GitHub</a>.</p><h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo new <span class="string">"My New Post"</span></span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/writing.html" target="_blank" rel="noopener">Writing</a></p><h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo server</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/server.html" target="_blank" rel="noopener">Server</a></p><h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo generate</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/generating.html" target="_blank" rel="noopener">Generating</a></p><h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo deploy</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/deployment.html" target="_blank" rel="noopener">Deployment</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;link rel=&quot;stylesheet&quot; class=&quot;aplayer-secondary-style-marker&quot; href=&quot;\assets\css\APlayer.min.css&quot;&gt;&lt;script src=&quot;\assets\js\APlayer.min.js&quot; cla
      
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>常见的安全漏洞和攻击方式</title>
    <link href="http://linyishui.top/2019052201.html"/>
    <id>http://linyishui.top/2019052201.html</id>
    <published>2019-05-22T08:32:41.000Z</published>
    <updated>2019-06-12T10:16:24.470Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h2 id="防跨站"><a href="#防跨站" class="headerlink" title="防跨站"></a><strong>防跨站</strong></h2><p>&emsp;&emsp;跨站攻击：通过跨站点脚本，注入前端主要是HTML，当其它用户获取这些被注入的代码后，会窃取用户敏感cookie信息，攻击者根据这些信息进行会话劫持，直接以合法用户身份登陆账户。</p><p>&emsp;&emsp;CSRF(跨站请求伪造)：Crossing Site Recource Forge。</p><p>大致的触发流程是：</p><ol><li>用户登录了站点A，并且在Cookie中留下了A站点的认证信息</li><li>用户进入了站点B，而站点B用一些方式（比如一个提交行为是到A站点某关键接口的表单）引诱用户去点击。当用户点击时，会发出到A站点的请求。而浏览器会给这个请求附带上A站点的认证信息，从而让这个请求能够执行。这种行为可能是，但不限于，给某个A站点的某个其他用户提权/转账/发文辱骂等等。</li></ol><p>&emsp;&emsp;解决方案(部分可参考<a href="../2019052101.html" title="Title">Cookie，Session，Token</a>)：</p><ol><li>编码和过滤，将HTML字符转换为HTMLEntities编码，对js代码进行转义。</li><li>避免使用cookie，而使用Local Storage，但会使XSS攻击更容易。</li><li>使用CSRF Token作表单验证。</li><li>给所有接口都添加一个请求secret，来标记其来自于合法的客户端。</li><li>用Same-Site Cookie限制站点必须同域名才能携带cookie。</li><li>总是用json格式提交，禁止允许跨域的application/x-www-form-urlencoded格式，而使用application/json。</li><li>双认证，认证信息同时存放在HttpOnly Cookie和Authorization Header，并在服务器对比。</li><li>使用HTTPS，将Cookie设置为Secure，浏览器就可以只在访问https网址时才会携带Cookie。</li></ol><h2 id="防注入"><a href="#防注入" class="headerlink" title="防注入"></a><strong>防注入</strong></h2><p>SQL注入：将SQL命令隐藏在表单提交等请求中，达到欺骗服务器执行恶意的SQL操作。</p><p>解决方案：<br>1.使用预编译，不要拼接字符串<br>2.添加过滤<br>3.前端检测</p><h2 id="防篡改"><a href="#防篡改" class="headerlink" title="防篡改"></a><strong>防篡改</strong></h2><p>防止网页解决方案：<br>1.外挂轮询，通过检测程序，用轮询的方式判断网页完整性。<br>2.核心内嵌，在Web服务器中增加篡改检测模块，在网页流出时检查，被篡改时阻断访问，报警并恢复。<br>3.事件触发，利用操作系统的文件系统接口。</p><p>防止参数篡改：<br>参数加密</p><h2 id="防挂马"><a href="#防挂马" class="headerlink" title="防挂马"></a><strong>防挂马</strong></h2><p>挂马：即在网页中添加木马脚本。</p><p>解决方案：服务器端防止文件被读写。</p><h2 id="防黑客"><a href="#防黑客" class="headerlink" title="防黑客"></a><strong>防黑客</strong></h2><p>解决方案：好的安全框架+成熟的服务器安全系统。</p><h2 id="DNS攻击"><a href="#DNS攻击" class="headerlink" title="DNS攻击"></a><strong>DNS攻击</strong></h2><p>服务器端解决</p>]]></content>
    
    <summary type="html">
    
      介绍常见的安全漏洞和攻击方式。
    
    </summary>
    
      <category term="技术文档" scheme="http://linyishui.top/categories/%E6%8A%80%E6%9C%AF%E6%96%87%E6%A1%A3/"/>
    
    
      <category term="java" scheme="http://linyishui.top/tags/java/"/>
    
      <category term="security" scheme="http://linyishui.top/tags/security/"/>
    
  </entry>
  
  <entry>
    <title>Cookie，Session，Token</title>
    <link href="http://linyishui.top/2019052101.html"/>
    <id>http://linyishui.top/2019052101.html</id>
    <published>2019-05-21T08:54:27.000Z</published>
    <updated>2019-06-12T10:21:36.071Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="背景"><a href="#背景" class="headerlink" title="背景"></a><strong>背景</strong></h1><h2 id="Web认证技术的演变"><a href="#Web认证技术的演变" class="headerlink" title="Web认证技术的演变"></a><strong>Web认证技术的演变</strong></h2><p>&emsp;&emsp;早期的网站功能简单，访问量小，只要通过HTTP请求访问一个个资源就满足了需求。但随着交互式网站的发展，此时Web需要记录用户的状态等信息来维护会话，而HTTP是无状态的，所以就开始使用sessionid来标记用户请求，用来当作密匙区分用户。</p><p>&emsp;&emsp;sessionid的作用使其需要双边保存，随着访问用户的迅速增加，服务器端很难去维护动辄数十万百万的sessionid，所以就极大的限制了服务器的性能。一个小小的sessionid就引出了集群，负载均衡，主从备份等问题。所以如果可以从根源上替代sessionid，用好的设计来减少服务器的维护工作就变得尤为重要。</p><p>&emsp;&emsp;既然sessionid是为了验证用户身份，那么可不可以只让用户保存，也能来验证其合法性呢？token即令牌便是由此而来，就像古时君王赐予手下主将的虎符，当用户首次登陆验证后，系统就赐予用户token，以后用户就可以根据token来表明其身份，而不用每次都向系统进行验证。</p><p>&emsp;&emsp;因为Token的无状态设计，所以解决了Session机制导致的问题，但其也受限于无状态的设计，对于一些用户信息的管理必须要依赖于有状态时就显得不是那么适用了。</p><hr><h1 id="Cookie"><a href="#Cookie" class="headerlink" title="Cookie"></a><strong>Cookie</strong></h1><h2 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a><strong>介绍</strong></h2><p>&emsp;&emsp;cookie就是指浏览器中能持久存储的某种数据，由服务器生成发送给浏览器，浏览器以KV映射的形式保存cookie到指定目录下，在以后的请求中会一起把这部分数据发送给服务器。因为cookie保留在客户端，所以如今流行的浏览器对cookie加了诸多安全限制。</p><hr><h1 id="Session"><a href="#Session" class="headerlink" title="Session"></a><strong>Session</strong></h1><p>&emsp;&emsp;session即会话，服务器要确认当前对话对象身份，所以要给各个客户端分配不同的身份标识，客户端将身份标识存储在cookie中，在请求时一同发送给服务器，服务器端则通过session把用户信息临时存储在服务器上。</p><p>&emsp;&emsp;基于Session认证就是客户端要存储一份sessionid，请求时携带sessionid，服务器端维护session数据，并根据sessionid查询用户信息。</p><hr><h1 id="Token"><a href="#Token" class="headerlink" title="Token"></a><strong>Token</strong></h1><h2 id="介绍-1"><a href="#介绍-1" class="headerlink" title="介绍"></a><strong>介绍</strong></h2><p>&emsp;&emsp;token即令牌，用来通过对密匙和用户ID进行加密，生成对应的签名，返回给用户。用户发起请求时需要携带签名，服务器根据相同加密算法和签名进行校对，来判断数据是否被修改。</p><h2 id="JWT"><a href="#JWT" class="headerlink" title="JWT"></a><strong>JWT</strong></h2><p>&emsp;&emsp;JWT即Json Web Token，其主要结构如下。</p><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="title">base64</span><span class="params">(header)</span></span>.base64(json payload).signature</span><br><span class="line">&#123;</span><br><span class="line">    <span class="string">"alg"</span> : <span class="string">"HS256"</span>, <span class="comment">//加密算法</span></span><br><span class="line">    <span class="string">"typ"</span> : <span class="string">"JWT"</span> <span class="comment">//Token类型</span></span><br><span class="line">&#125;</span><br><span class="line">&#123;</span><br><span class="line">    username : <span class="string">'xxx'</span>,</span><br><span class="line">    email : <span class="string">'sa@xxx.com'</span>,</span><br><span class="line">    role : <span class="string">'user'</span>,</span><br><span class="line">    exp : <span class="number">123123123</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>header即头部，用来描述一些基本信息，比如这个token是用什么算法签名的，是什么版本的等等。</li><li>payload即负载，就是一个json object。你可以任意放置你想要的信息，只要符合json的格式即可。标准中已经规定好了有一些字段的意思，比如iat表示issue at，token签发的时间；exp表示token过期的时间等等。根据这些约定就可以实现一些小的代码库来检查比如token是不是过期了等等。但是请注意，很多人误解，认为JWT是加了密的，但其实payload是明文的。</li><li>signature是一个签名。服务器端可以自行选择一个算法和一个secret，与payload拼接上，得到一个签名。secret并不会在网络中传输，所以客户端无法伪造一个JWT。这样，一旦一个签名生成，再传回给服务器，服务器就可以知道这个token是不是它当初生成的。</li></ul><p>&emsp;&emsp;服务器端只要验证JWT签名正确，且未超时即可。服务器端直接从JWT中获取已验证的用户信息，而不用再去持久层取一次了。</p><h2 id="两种Web认证比较"><a href="#两种Web认证比较" class="headerlink" title="两种Web认证比较"></a><strong>两种Web认证比较</strong></h2><blockquote><p><strong>基于Session验证的方式存在的问题？</strong></p><ol><li>开销大：需要为用户维护session，用户增多时需要大量的内存开销。</li><li>扩展性差：无法直接在多台服务器间共享用户信息，而创建session的服务器和验证的服务器很肯不相同，需要共享session。</li><li>CORS(跨域资源共享)：数据跨越多台移动设备时就会有资源共享问题，要处理兼容性问题。</li><li>CSRF(跨站请求伪造)：容易受到跨站请求伪造攻击。</li></ol></blockquote><p>&emsp;&emsp;Token则是无状态的身份验证，解决了Session验证的诸多问题.每一次请求都发送token，放在headers中保证HTTP无状态，设置服务器Access-Control-Allow-Origin:*，保证服务器能接收到来自所有域的请求。</p><blockquote><p><strong>Token验证的优点？</strong></p><ol><li>无状态和可扩展：token存储在客户端，身份验证过程基本都在高速内存中执行，可以从一台服务器传送用户信息到另外一台服务器，也可以和第三方程序共享权限。</li><li>安全性：token可以避免CSRF攻击，即使是保存token到客户端也不牵涉到认证，且token有时效性。</li><li>多平台跨域：token只要通过了身份验证，便可以在任何域上发送请求。</li><li>开发便捷：无需再编写用户的一些数据库和缓存查询，降低了接口反应延迟。</li></ol></blockquote><p>&emsp;&emsp;但是JWT无法在服务器端对用户请求进行管理，也无法规范性的对payload数据进行控制。因此牵涉到管理用户登录信息的需求就很难避免去使用基于session的Web认证机制。所以在大部分场景需求下是不适合使用”纯净”的基于Token的Web认证，而是仅仅用JWT来代替sessionid。</p><blockquote><p>系统无法统计如用户登录次数，登录平台，也无法断开用户的登录。一旦实现如撤回token认证，就要重新实现session机制，就算不得无状态了。</p><p>虽然规范建议只将认证信息存入payload，但开发者往往会将所有用户信息放入，导致payload尺寸过大，又因为每次请求都要携带，造成了一定的性能损耗</p></blockquote><h2 id="存储位置"><a href="#存储位置" class="headerlink" title="存储位置"></a><strong>存储位置</strong></h2><p>客户端浏览器的存储位置主要为：</p><ul><li>Local Storage</li><li>Cookie</li></ul><h3 id="Local-Storage"><a href="#Local-Storage" class="headerlink" title="Local Storage"></a><strong>Local Storage</strong></h3><p>&emsp;&emsp;常用Header+Local Storage的方式来避免CSRF，但更容易被XSS攻击</p><h3 id="Cookie-1"><a href="#Cookie-1" class="headerlink" title="Cookie"></a><strong>Cookie</strong></h3><p>&emsp;&emsp;只有设置为HttpOnly的Cookie是脚本无法访问的，所以很适合用来存放token/sessionid</p><figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Set-Cookie: <span class="attribute">access_token</span>=xxxxxxxxxxxxxxxxxx; HttpOnly; Secure; <span class="attribute">Same-Site</span>=strict; <span class="attribute">Path</span>=/;</span><br></pre></td></tr></table></figure><p>&emsp;&emsp;使用此cookie可以完全隔离XSS攻击，而不用担心漏洞问题。</p><h3 id="防范CSRF"><a href="#防范CSRF" class="headerlink" title="防范CSRF"></a><strong>防范CSRF</strong></h3><p>&emsp;&emsp;在传统页面Web网站中，一般会使用CSRF Token。这是个非常流行的做法。像Tomcat这类的容器都会自带CSRF Token的产生和检查Filter。</p><blockquote><p><strong>CSRF Token流程</strong></p><p>&emsp;&emsp;客户端要首先向服务器请求一个带有提交表单的页面，服务器返回的页面中会嵌入一个CSRF Token。当用户提交表单时，CSRF Token会被一起携带发给服务器做验证。所以当服务器看到CSRF Token，就可以放心大胆的确认用户的的确确是看看到了提交前的表单界面，从而避免了用户稀里糊涂提交一个被伪造的表单的可能性。</p></blockquote><p>&emsp;&emsp;CSRF Token只适合于传统的页面请求，在SPA的情况下会比较尴尬。因为在SPA中，客户端与服务器之间的交互主要是通过接口完成的，没有页面的概念。此时的确可以照猫画虎的做一个接口让用户拿到CSRF Token，但这样什么也确认不了。因为攻击者可以调用同样的接口，拿到合法的CSRF Token。</p><blockquote><p>&emsp;&emsp;这时有几种办法：</p><ol><li><p>给所有接口都添加一个请求secret，来标记其来自于合法的客户端。这个secrect可以是固定的随机字符串，也可以通过某些动态算法产生。对于CSRF，浏览器只会做自动传Cookie而已，并不能帮助传入secret。这样一来，就可以确定消除CSRF的风险。但注意，这个机制仅能防范CSRF，而不能防范人为的攻击。黑客只要拿得到客户端，就一定能找到生成secret的办法。secret有一个顺带的功能是提高了第三方用户随意调用接口的门槛——他们必须得去查看客户端源代码，学会了怎么生成secret才能调用接口。</p></li><li><p>用Same-Site Cookie。回到上面CSRF步骤的第二步骤。当用户看到了B站点伪造的表单，点击了提交，向站点A发出请求时，被标记了Same-Site=strict的Cookie是不会被携带的，因为当时的主站点域名B和提交的站点域名A不一样。这是Same-Site=strict标记是个相对较新的标准。目前大部分浏览器都已经支持了。但如果大量的用户群还在类似于IE8这样的老系统上，这个招数便是无效的。</p></li><li><p>歪招，总是用json格式提交。CSRF可能发生的一个前提条件是必须用传统表单提交。这是因为传统表单提交可以跨域——你在站点B，可以提交表单给站点A。而Ajax的请求除非开启CORS，是不允许跨域的，所以天然的屏蔽掉了这个问题。传统表单的提交的格式必然是application/x-www-form-urlencoded。因此只要保证服务器能够拒绝处理所有application/x-www-form-urlencoded格式的POST请求，就能确保SPA不受CSRF的影响。那用啥呢？JSON - application/json。（我专门写这一条的原因是，jquery的ajax库的默认行为正是使用application/x-www-form-urlencoded格式。如果你还在用，可以考虑改一下。）</p></li><li><p>另一个歪招，双认证。将你的认证信息同时放在HttpOnly Cookie和Authorization Header。服务器要先比对这两个值是一样的，然后再去执行认证过程。这样可以同时防范XSS和CSRF。代价是，如果你的认证信息比较长，会浪费一些带宽。</p></li><li><p>使用HTTPS，将Cookie设置为Secure，浏览器就可以只在访问https网址时才会携带Cookie</p></li></ol></blockquote><blockquote><p>一个靠谱的Web认证应该：</p><ul><li>可以使用Session也可以使用Token做认证，但是总是要保证服务器端可以管理Session，通过Session是否存在来最终确定认证的有效性；</li><li>将认证信息存放在标记为HttpOnly，Secure，Same-Site=strict的Cookie中，从而避免XSS和CSRF；</li><li>总是使用https，只要你的网络链路经过了公网；</li><li>如果是传统的页面网站，请使用CSRF Token机制；</li><li>如果可以，做一个简单的请求secret，可以辅助防止CSRF，也可以稍稍的提高接口被爬取的门槛；</li><li>如果是SPA应用，放心大胆的禁用对application/x-www-form-urlencoded的支持</li><li>保证token/session必须有一个有效期</li></ul></blockquote><hr><h1 id="用户权限系统设计"><a href="#用户权限系统设计" class="headerlink" title="用户权限系统设计"></a><strong>用户权限系统设计</strong></h1><h2 id="案例说明"><a href="#案例说明" class="headerlink" title="案例说明"></a><strong>案例说明</strong></h2><p><strong>保安</strong></p><p>需求</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">实现一个公司大楼保安系统，识别所有进入人员身份，不同身份人员能进入房间区域受限，保护公司的财产安全</span><br></pre></td></tr></table></figure><p>思路</p><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">一、</span><br><span class="line"><span class="bullet">1. </span>人员信息要持久化存储，创建T_USERS(ID,NAME,PWD)</span><br><span class="line"><span class="bullet">2. </span>引入密码-加密(如密码hash等)，加强安全性</span><br><span class="line">二、避免用户和保安对话时密码被窃听</span><br><span class="line"><span class="bullet">3. </span>引入RSA非对称加密+数字签名算法构成HTTPS，保证无法被窃听，篡改。</span><br><span class="line">三、确保员工办公室只有自己能进去</span><br><span class="line"><span class="bullet">4. </span>每个办公室加一个门卫，员工进入大楼内每个门都需要进行一次身份验证</span><br><span class="line">四、防止机密信息外泄</span><br><span class="line"><span class="bullet">5. </span>引入Token令牌，存储身份和权限信息，保证时效性，只有主门卫有权限校对密码信息</span><br><span class="line">五、保证令牌的真实性和有效性</span><br><span class="line"><span class="bullet">6. </span>存储令牌信息，方便定时更新和查询</span><br><span class="line">六、门卫权限过大，令牌数据量大时难以维护和优化</span><br><span class="line"><span class="bullet">7. </span>去除令牌持久化设计，通过数字校验来验证令牌</span><br><span class="line"></span><br><span class="line">用户登录：请求Login，主门卫读用户表验证身份信息，确认后通过私钥生成一份数字签名(明文+签名)</span><br><span class="line">用户进入各个房间：各门卫用公钥解密签名，校验结果和明文，确认真实性，再读取明文数据确定权限。</span><br><span class="line"></span><br><span class="line">即JWT Json Web Token</span><br><span class="line"></span><br><span class="line">数字签名丢失：XSS，</span><br><span class="line">防止丢失，存入Cookie，LocalStorage？易被窃取，篡改或伪造，但对于JWT来讲Cookie是安全的，setCookie For http only</span><br><span class="line">缺点：无法很好的撤回已给出的签名</span><br></pre></td></tr></table></figure><p>&emsp;&emsp;</p><hr><p><em>参考博客和文章书籍等：</em></p><blockquote><p><a href="https://www.jianshu.com/p/805dc2a0f49e" target="_blank" rel="noopener">https://www.jianshu.com/p/805dc2a0f49e</a></p></blockquote><p><em>因博客主等未标明不可引用，若部分内容涉及侵权请及时告知，我会尽快修改和删除相关内容</em></p>]]></content>
    
    <summary type="html">
    
      介绍Cookie，Session，Token。
    
    </summary>
    
      <category term="技术文档" scheme="http://linyishui.top/categories/%E6%8A%80%E6%9C%AF%E6%96%87%E6%A1%A3/"/>
    
    
      <category term="java" scheme="http://linyishui.top/tags/java/"/>
    
      <category term="web" scheme="http://linyishui.top/tags/web/"/>
    
  </entry>
  
  <entry>
    <title>加密算法</title>
    <link href="http://linyishui.top/2019052001.html"/>
    <id>http://linyishui.top/2019052001.html</id>
    <published>2019-05-20T03:46:58.000Z</published>
    <updated>2019-06-12T03:20:00.966Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="哈希加密"><a href="#哈希加密" class="headerlink" title="哈希加密"></a><strong>哈希加密</strong></h1><h2 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a><strong>介绍</strong></h2><p>&emsp;&emsp;防止密码泄露，通过散列的方法对口令进行一次性的加密，加密过程不可逆，从哈希值无法直接还原到原密码。</p><p>&emsp;&emsp;但哈希加密很快就被破解了，可以通过如<strong>字典破解</strong>，<strong>暴力破解</strong>等效率很低的破解方法，也可以通过<strong>查表法</strong>，<strong>反向查表法</strong>，<strong>彩虹表</strong>等方式来高效破解。</p><h2 id="原理"><a href="#原理" class="headerlink" title="原理"></a><strong>原理</strong></h2><p>&emsp;&emsp;单向散列算法，通过算法H将较大集合P映射到一个较小集合Q，即Q=H(P)</p><p>&emsp;&emsp;P集合中任意元素p都有唯一q与其对应，但q可以对应多个p。H(P)可以快速计算，且难以通过q反推出p，给出一个p1，难以推出p2使H(p1)=H(p2)。</p><p>&emsp;&emsp;因为这些特性，哈希算法常用来存储密码。</p><h2 id="低效破解"><a href="#低效破解" class="headerlink" title="低效破解"></a><strong>低效破解</strong></h2><p>&emsp;&emsp;暴力破解，即尝试密码长度允许的所有排列组合，只要密码长度足够，就会因为无法达到一定的算力而无法破解，所以会建议一定的安全长度来保证安全性。</p><p>&emsp;&emsp;字典破解，即通过创建一个小型数据库，存储单词、短语、常用密码等，进行哈希换算，再和要破解的密码进行比照。</p><h2 id="高效破解"><a href="#高效破解" class="headerlink" title="高效破解"></a><strong>高效破解</strong></h2><p>&emsp;&emsp;查表法，即先计算一些常用密码的哈希值，然后存储到Table中，在破解时进行比对，内存时间平衡法通过大量的内存来减少破解时间，</p><p>&emsp;&emsp;反向查表法，即先通过暴力破解获取一些哈希值，构造一个哈希表，获取已知数据，计算对应哈希值，并查询对应的数据。</p><p>&emsp;&emsp;彩虹表，结合暴力法和查表法，对于Q=H(P)，通过算法R使P=R(Q)，然后计算H(p0)-&gt;R(q1)-&gt;H(p1)-&gt;R(q2)…-&gt;R(qn)-&gt;pn反复调用HR算法计算得到pn，存储p0和pn组合，代入不同的p0得到多组结果并存储。破解时根据获取的散列值q，进行一次R(q)得到c1，把c1和所存pn进行比较，若找到相等pn，则其对应的qn很有可能就是获取的散列值q，再进行一次HR计算，得到qn并比对，若相等则p(n-1)一定是想要的密令p，若不相等就继续直到遍历完所以存储组合。再对q进行R(q)-&gt;H(c1)-&gt;R(c2)，对比c2和qn，若相等，则对应的p(n-2)就很可能是所求密令，继续计算c3、c4直到c(n-1)。总体来讲就是通过0-n对存储了p0到pn链的所有数据，可以很大的节约空间，但就是需要进行n次比对，所以相比查表法在时间上是会有更多的牺牲。</p><hr><h1 id="加盐"><a href="#加盐" class="headerlink" title="加盐"></a><strong>加盐</strong></h1><h2 id="介绍-1"><a href="#介绍-1" class="headerlink" title="介绍"></a><strong>介绍</strong></h2><p>&emsp;&emsp;加盐即将口令通过和一个随机数Salt关联，只要口令改变随机数即改变。随机数以未加密的形式放入口令文件中，将口令和随机数一起加密。</p><p>&emsp;&emsp;后台开发时常用Hash值的形式来存储用户密码，当后台被攻击时，哈希值泄露，黑客仍可以通过如彩虹表等方式破解用户密码。通过加盐可以提高密码的破解难度。</p><h2 id="原理-1"><a href="#原理-1" class="headerlink" title="原理"></a><strong>原理</strong></h2><p>&emsp;&emsp;由哈希加密的H(P)变为H(P+Salt)，每次哈希计算所选用的盐值都是随机数。因为H发生变化，所以已有的彩虹表数据就会失效，需要根据新的H重新生成，所以破解难度就提高了。</p><h2 id="实现"><a href="#实现" class="headerlink" title="实现"></a><strong>实现</strong></h2><hr><h1 id="MD5"><a href="#MD5" class="headerlink" title="MD5"></a><strong>MD5</strong></h1><hr><h1 id="becrypt"><a href="#becrypt" class="headerlink" title="becrypt"></a><strong>becrypt</strong></h1><hr><h1 id="RSA"><a href="#RSA" class="headerlink" title="RSA"></a><strong>RSA</strong></h1><hr><h1 id="oauth"><a href="#oauth" class="headerlink" title="oauth"></a><strong>oauth</strong></h1>]]></content>
    
    <summary type="html">
    
      介绍Cookie，Session，Token。
    
    </summary>
    
      <category term="技术文档" scheme="http://linyishui.top/categories/%E6%8A%80%E6%9C%AF%E6%96%87%E6%A1%A3/"/>
    
    
      <category term="java" scheme="http://linyishui.top/tags/java/"/>
    
      <category term="web" scheme="http://linyishui.top/tags/web/"/>
    
  </entry>
  
  <entry>
    <title>Java学习书单</title>
    <link href="http://linyishui.top/2019051201.html"/>
    <id>http://linyishui.top/2019051201.html</id>
    <published>2019-05-20T03:00:26.000Z</published>
    <updated>2019-05-20T03:45:26.000Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>&emsp;&emsp;读书特别是对于程序员来说是学习的道路之一，在互联网如此便利的时代环境下，信息的获取是非常方便的，所以是否选择花一定的金钱和时间去购买阅读书籍需要程序员根据自己的情况和学习方式来选择。对于我来说，好的书籍能减少走弯路的可能性，也能快速的积累作者的知识精华，相比较之下阅读官方文档之类的就比较看个人能力和经验，有稍微大一些的学习门槛和理解偏差；但阅读书籍一定要注重实战，读书能快速接收到知识的同时也意味着可能快速的忘记，需要制订好科学的学习计划才能比较好的吸收为自己的技能。</p><p>&emsp;&emsp;最近越来越感觉实体书籍的麻烦之处了，太重太厚不能用各种姿势畅快的阅读，懒得去图书馆先翻两下就直接买了，到手发现内容有些烂或者不适合自己当前状态看，越买越多开销开始变大了等等；因为这些原因看书在我的学习比重中占比太小了，所以决定买个Kindle以后我读电子书好了，可以先在网上找资源，试读一下觉得不错了再买，可以省点钱少踩点坑，方便携带，随时随地都可以学习了，过段日子再买个轻薄本，以后妈妈再也不用担心我出门没法敲代码了。</p><h1 id="一、Java语言"><a href="#一、Java语言" class="headerlink" title="一、Java语言"></a><strong>一、Java语言</strong></h1><h2 id="1-《Java核心技术-卷Ⅰ》-8-0-《Java核心技术-卷Ⅱ》-7-2"><a href="#1-《Java核心技术-卷Ⅰ》-8-0-《Java核心技术-卷Ⅱ》-7-2" class="headerlink" title="1.《Java核心技术-卷Ⅰ》(8.0) + 《Java核心技术-卷Ⅱ》(7.2)"></a><strong>1.<a href="https://book.douban.com/subject/26880667/" title="Title" target="_blank" rel="noopener">《Java核心技术-卷Ⅰ》</a>(8.0) + <a href="https://book.douban.com/subject/27165931/" title="Title" target="_blank" rel="noopener">《Java核心技术-卷Ⅱ》</a>(7.2)</strong></h2><p>&emsp;&emsp;选内容的跳着读完了一遍，很厚。</p><p>&emsp;&emsp;分卷Ⅰ和卷Ⅱ，内容比较基础也很详细，译本感觉差强人意，有些地方会因为翻译而难以理解，可以结合英文版阅读，卷Ⅱ大幅篇章用来讲Swing和Awt很迷。</p><h2 id="2-《Java语言程序设计》-8-9"><a href="#2-《Java语言程序设计》-8-9" class="headerlink" title="2.《Java语言程序设计》(8.9)"></a><strong>2.<a href="https://book.douban.com/subject/26590745/" title="Title" target="_blank" rel="noopener">《Java语言程序设计》</a>(8.9)</strong></h2><p>&emsp;&emsp;梁勇版，大学时教材，因为比较久远所以印象不是很深了，应该比较入门，适合初学者。</p><h2 id="3-《Head-First-Java》-8-7"><a href="#3-《Head-First-Java》-8-7" class="headerlink" title="3.《Head First Java》(8.7)"></a><strong>3.<a href="https://book.douban.com/subject/2000732/" title="Title" target="_blank" rel="noopener">《Head First Java》</a>(8.7)</strong></h2><p>&emsp;&emsp;还未读过，据说很适合新手入门Java，比较经典的Java书籍。</p><h2 id="4-《Java编程思想》-9-1"><a href="#4-《Java编程思想》-9-1" class="headerlink" title="4.《Java编程思想》(9.1)"></a><strong>4.<a href="https://book.douban.com/subject/2130190/" title="Title" target="_blank" rel="noopener">《Java编程思想》</a>(9.1)</strong></h2><p>&emsp;&emsp;买了还未读过，适合不同阶段的Java程序员学习，内容详细且有深度，建议在有一定的基础后再阅读学习。</p><h2 id="5-《Effective-Java》-8-8"><a href="#5-《Effective-Java》-8-8" class="headerlink" title="5.《Effective Java》(8.8)"></a><strong>5.<a href="https://book.douban.com/subject/30412517/" title="Title" target="_blank" rel="noopener">《Effective Java》</a>(8.8)</strong></h2><p>&emsp;&emsp;据说主要讲了很多Java调优和规范，比较经典，等以后有机会读一下。</p><h2 id="6-《Java8实战》-9-2"><a href="#6-《Java8实战》-9-2" class="headerlink" title="6.《Java8实战》(9.2)"></a><strong>6.<a href="https://book.douban.com/subject/26772632/" title="Title" target="_blank" rel="noopener">《Java8实战》</a>(9.2)</strong></h2><p>&emsp;&emsp;面向 Java 8 的技能升级，豆瓣9.2分，有机会读一下。</p><h1 id="二、数据结构和算法"><a href="#二、数据结构和算法" class="headerlink" title="二、数据结构和算法"></a><strong>二、数据结构和算法</strong></h1><h2 id="1-《数据结构与算法-Java版》-8-6"><a href="#1-《数据结构与算法-Java版》-8-6" class="headerlink" title="1.《数据结构与算法-Java版》(8.6)"></a><strong>1.<a href="https://book.douban.com/subject/3351237/" title="Title" target="_blank" rel="noopener">《数据结构与算法-Java版》</a>(8.6)</strong></h2><p>&emsp;&emsp;适合新手入门学习数据结构，大学时数据结构是C语言版，后悔当时没直接学这本了。</p><h2 id="2-《算法-第4版》-9-4"><a href="#2-《算法-第4版》-9-4" class="headerlink" title="2.《算法-第4版》(9.4)"></a><strong>2.<a href="https://book.douban.com/subject/19952400/" title="Title" target="_blank" rel="noopener">《算法-第4版》</a>(9.4)</strong></h2><p>&emsp;&emsp;Sedgewick著，经典算法书，买了第4版看了大概一半了，示例都是用Java实现的非常适合Java程序员阅读，经典必读。</p><h2 id="3-刷题"><a href="#3-刷题" class="headerlink" title="3. 刷题"></a><strong>3. 刷题</strong></h2><p>&emsp;&emsp;在系统的学习完数据结构和算法后一定要勤于刷题，如LeetCode，也可以先刷一些知名公司的算法题库，或者先读《剑指Offer》。</p><h1 id="三、数据库"><a href="#三、数据库" class="headerlink" title="三、数据库"></a><strong>三、数据库</strong></h1><h2 id="1-《MySql技术内幕》-8-6"><a href="#1-《MySql技术内幕》-8-6" class="headerlink" title="1.《MySql技术内幕》(8.6)"></a><strong>1.<a href="https://book.douban.com/subject/24708143/" title="Title" target="_blank" rel="noopener">《MySql技术内幕》</a>(8.6)</strong></h2><p>&emsp;&emsp;了解InnoDB存储引擎底层原理必备的一本书。</p><h2 id="2-《高性能MySql》-9-3"><a href="#2-《高性能MySql》-9-3" class="headerlink" title="2.《高性能MySql》(9.3)"></a><strong>2.<a href="https://book.douban.com/subject/23008813/" title="Title" target="_blank" rel="noopener">《高性能MySql》</a>(9.3)</strong></h2><p>&emsp;&emsp;MySql的经典书籍，但不一定适合Java程序员阅读，建议根据自身情况选择。</p><h2 id="3-《Redis开发与运维》-9-0"><a href="#3-《Redis开发与运维》-9-0" class="headerlink" title="3.《Redis开发与运维》(9.0)"></a><strong>3.<a href="https://book.douban.com/subject/26971561/" title="Title" target="_blank" rel="noopener">《Redis开发与运维》</a>(9.0)</strong></h2><p>&emsp;&emsp;买了还没机会读，比较新，全面讲解Redis基本功能及其应用，并结合了线上开发与运维监控中的实际使用案例，深入分析并总结了实际开发运维中遇到的“陷阱”，以及背后的原因， 包含大规模集群开发与管理的场景、应用案例与开发技巧，为高效开发运维提供了大量实际经验和建议。</p><h2 id="4-《Redis实战》-8-0"><a href="#4-《Redis实战》-8-0" class="headerlink" title="4.《Redis实战》(8.0)"></a><strong>4.<a href="https://book.douban.com/subject/26612779/" title="Title" target="_blank" rel="noopener">《Redis实战》</a>(8.0)</strong></h2><p>&emsp;&emsp;适合入门学习Redis，快速的掌握相关知识。</p><h2 id="5-《Redis设计与实现》-8-5"><a href="#5-《Redis设计与实现》-8-5" class="headerlink" title="5.《Redis设计与实现》(8.5)"></a><strong>5.<a href="https://book.douban.com/subject/25900156/" title="Title" target="_blank" rel="noopener">《Redis设计与实现》</a>(8.5)</strong></h2><p>&emsp;&emsp;适合系统深入的学习Redis，本书比较详细的介绍了Redis的原理。</p><h1 id="四、框架"><a href="#四、框架" class="headerlink" title="四、框架"></a><strong>四、框架</strong></h1><h2 id="1-《Spring实战》-8-3"><a href="#1-《Spring实战》-8-3" class="headerlink" title="1.《Spring实战》(8.3)"></a><strong>1.<a href="https://book.douban.com/subject/26767354/" title="Title" target="_blank" rel="noopener">《Spring实战》</a>(8.3)</strong></h2><p>&emsp;&emsp;Spring框架入门书籍，还未读过，因为工作原因直接从Spring Boot入门的，有机会读一下。</p><h2 id="2-《JavaEE开发的颠覆者-Spring-Boot实战》-6-3"><a href="#2-《JavaEE开发的颠覆者-Spring-Boot实战》-6-3" class="headerlink" title="2.《JavaEE开发的颠覆者: Spring Boot实战》(6.3)"></a><strong>2.<a href="https://book.douban.com/subject/26762595/" title="Title" target="_blank" rel="noopener">《JavaEE开发的颠覆者: Spring Boot实战》</a>(6.3)</strong></h2><p>&emsp;&emsp;国内作者，入门学习，配合简单的代码实战，适合快速学习，建议有突击需求的可以看一下，但不建议购买。</p><h2 id="3-《Java-Web高级编程》-8-8"><a href="#3-《Java-Web高级编程》-8-8" class="headerlink" title="3.《Java Web高级编程》(8.8)"></a><strong>3.<a href="https://book.douban.com/subject/26581686/" title="Title" target="_blank" rel="noopener">《Java Web高级编程》</a>(8.8)</strong></h2><p>&emsp;&emsp;涵盖WebSockets、Spring Framework、JPA Hibernate和Spring Security。</p><h2 id="4-《精通Hibernate》-7-5"><a href="#4-《精通Hibernate》-7-5" class="headerlink" title="4.《精通Hibernate》(7.5)"></a><strong>4.<a href="https://book.douban.com/subject/26581686/" title="Title" target="_blank" rel="noopener">《精通Hibernate》</a>(7.5)</strong></h2><p>&emsp;&emsp;Hibernate入门。</p><h2 id="5-《MyBatis从入门到精通》-7-6"><a href="#5-《MyBatis从入门到精通》-7-6" class="headerlink" title="5.《MyBatis从入门到精通》(7.6)"></a><strong>5.<a href="https://book.douban.com/subject/27074809/" title="Title" target="_blank" rel="noopener">《MyBatis从入门到精通》</a>(7.6)</strong></h2><p>&emsp;&emsp;MyBatis入门。</p><h2 id="6-《MyBatis技术内幕》-7-9"><a href="#6-《MyBatis技术内幕》-7-9" class="headerlink" title="6.《MyBatis技术内幕》(7.9)"></a><strong>6.<a href="https://book.douban.com/subject/26581686/" title="Title" target="_blank" rel="noopener">《MyBatis技术内幕》</a>(7.9)</strong></h2><p>&emsp;&emsp;由浅到深学习MyBatis。</p><h2 id="7-《Expert-One-on-One-J2EE-Development-without-EJB中文版》-8-9"><a href="#7-《Expert-One-on-One-J2EE-Development-without-EJB中文版》-8-9" class="headerlink" title="7.《Expert One-on-One J2EE Development without EJB中文版》(8.9)"></a><strong>7.<a href="https://book.douban.com/subject/1436131/" title="Title" target="_blank" rel="noopener">《Expert One-on-One J2EE Development without EJB中文版》</a>(8.9)</strong></h2><p>&emsp;&emsp;经典，建议必读。</p><h2 id="8-《Maven实战》-8-2"><a href="#8-《Maven实战》-8-2" class="headerlink" title="8.《Maven实战》(8.2)"></a><strong>8.<a href="https://book.douban.com/subject/5345682/" title="Title" target="_blank" rel="noopener">《Maven实战》</a>(8.2)</strong></h2><p>&emsp;&emsp;想学习一下Maven可以看一下。</p><h2 id="9-《Netty权威指南》-6-9"><a href="#9-《Netty权威指南》-6-9" class="headerlink" title="9.《Netty权威指南》(6.9)"></a><strong>9.<a href="https://book.douban.com/subject/26373138/" title="Title" target="_blank" rel="noopener">《Netty权威指南》</a>(6.9)</strong></h2><p>&emsp;&emsp;没读过，有人推荐，有机会拜读一下。</p><h1 id="五、计算机网络"><a href="#五、计算机网络" class="headerlink" title="五、计算机网络"></a><strong>五、计算机网络</strong></h1><h2 id="1-《计算机网络》-7-8"><a href="#1-《计算机网络》-7-8" class="headerlink" title="1.《计算机网络》(7.8)"></a><strong>1.<a href="https://book.douban.com/subject/24740558/" title="Title" target="_blank" rel="noopener">《计算机网络》</a>(7.8)</strong></h2><p>&emsp;&emsp;谢希仁版，大学教材，很经典CS考研参考书籍，但可能不太好啃。</p><h2 id="2-《计算机网络-自顶向下方法》-8-9"><a href="#2-《计算机网络-自顶向下方法》-8-9" class="headerlink" title="2.《计算机网络-自顶向下方法》(8.9)"></a><strong>2.<a href="https://book.douban.com/subject/26176870/" title="Title" target="_blank" rel="noopener">《计算机网络-自顶向下方法》</a>(8.9)</strong></h2><p>&emsp;&emsp;买了还没看，据说很好，待看过再评价。</p><h2 id="3-《网络是怎样连接的》-9-2"><a href="#3-《网络是怎样连接的》-9-2" class="headerlink" title="3.《网络是怎样连接的》(9.2)"></a><strong>3.<a href="https://book.douban.com/subject/26941639/" title="Title" target="_blank" rel="noopener">《网络是怎样连接的》</a>(9.2)</strong></h2><p>&emsp;&emsp;户根勤著，读了前两章，简单易懂且内容丰富，内容的结构设计也很棒，非常适合小白阅读。</p><h2 id="4-《图解HTTP》-8-1"><a href="#4-《图解HTTP》-8-1" class="headerlink" title="4.《图解HTTP》(8.1)"></a><strong>4.<a href="https://book.douban.com/subject/25863515/" title="Title" target="_blank" rel="noopener">《图解HTTP》</a>(8.1)</strong></h2><p>&emsp;&emsp;漫画风格讲解网络知识，非常适合小白阅读。</p><h1 id="六、操作系统"><a href="#六、操作系统" class="headerlink" title="六、操作系统"></a><strong>六、操作系统</strong></h1><h2 id="1-《现代操作系统》-9-0"><a href="#1-《现代操作系统》-9-0" class="headerlink" title="1.《现代操作系统》(9.0)"></a><strong>1.<a href="https://book.douban.com/subject/27096665/" title="Title" target="_blank" rel="noopener">《现代操作系统》</a>(9.0)</strong></h2><p>&emsp;&emsp;很厚，目前没兴趣看，据说很经典，待看后具体评价。</p><h2 id="2-《UNIX环境高级编程》-9-5"><a href="#2-《UNIX环境高级编程》-9-5" class="headerlink" title="2.《UNIX环境高级编程》(9.5)"></a><strong>2.<a href="https://book.douban.com/subject/25900403/" title="Title" target="_blank" rel="noopener">《UNIX环境高级编程》</a>(9.5)</strong></h2><p>&emsp;&emsp;买了还没来得及看，非常经典。</p><h2 id="3-《鸟哥的Linux私房菜》-9-1"><a href="#3-《鸟哥的Linux私房菜》-9-1" class="headerlink" title="3.《鸟哥的Linux私房菜》(9.1)"></a><strong>3.<a href="https://book.douban.com/subject/4889838/" title="Title" target="_blank" rel="noopener">《鸟哥的Linux私房菜》</a>(9.1)</strong></h2><p>&emsp;&emsp;最有名的Linux入门书。</p><h1 id="七、其他"><a href="#七、其他" class="headerlink" title="七、其他"></a><strong>七、其他</strong></h1><h2 id="1-《深入理解Java虚拟机》-8-9"><a href="#1-《深入理解Java虚拟机》-8-9" class="headerlink" title="1.《深入理解Java虚拟机》(8.9)"></a><strong>1.<a href="https://book.douban.com/subject/24722612/" title="Title" target="_blank" rel="noopener">《深入理解Java虚拟机》</a>(8.9)</strong></h2><p>&emsp;&emsp;还未读完，读过部分的感受大概比较能深入进去，书中的内容很容易理解，很不错的一本书。</p><h2 id="2-《Java并发编程实战》-9-1"><a href="#2-《Java并发编程实战》-9-1" class="headerlink" title="2.《Java并发编程实战》(9.1)"></a><strong>2.<a href="https://book.douban.com/subject/10484692/" title="Title" target="_blank" rel="noopener">《Java并发编程实战》</a>(9.1)</strong></h2><p>&emsp;&emsp;准备读，Java并发包开发人员写的书，比如知名的Doug Lea，待读后再具体评价。</p><h2 id="3-《Java并发编程的艺术》-7-3"><a href="#3-《Java并发编程的艺术》-7-3" class="headerlink" title="3.《Java并发编程的艺术》(7.3)"></a><strong>3.<a href="https://book.douban.com/subject/26591326/" title="Title" target="_blank" rel="noopener">《Java并发编程的艺术》</a>(7.3)</strong></h2><p>&emsp;&emsp;买后还未读，国内作者，所以不会有译版的问题，待读后再具体评价。</p><h2 id="4-《Java多线程编程核心技术》-5-1"><a href="#4-《Java多线程编程核心技术》-5-1" class="headerlink" title="4.《Java多线程编程核心技术》(5.1)"></a><strong>4.<a href="https://book.douban.com/subject/26555197/" title="Title" target="_blank" rel="noopener">《Java多线程编程核心技术》</a>(5.1)</strong></h2><p>&emsp;&emsp;买后还未读，高洪岩著，待读后再具体评价。</p><h2 id="5-《Java并发编程-核心方法与框架》-2-8"><a href="#5-《Java并发编程-核心方法与框架》-2-8" class="headerlink" title="5.《Java并发编程-核心方法与框架》(2.8)"></a><strong>5.<a href="https://book.douban.com/subject/26859317/" title="Title" target="_blank" rel="noopener">《Java并发编程-核心方法与框架》</a>(2.8)</strong></h2><p>&emsp;&emsp;买后还未读，高洪岩著，据说很辣鸡，当时凑单买的，不建议购买。</p><h2 id="6-《实战Java高并发程序设计》-8-3"><a href="#6-《实战Java高并发程序设计》-8-3" class="headerlink" title="6.《实战Java高并发程序设计》(8.3)"></a><strong>6.<a href="https://book.douban.com/subject/26663605/" title="Title" target="_blank" rel="noopener">《实战Java高并发程序设计》</a>(8.3)</strong></h2><p>&emsp;&emsp;有机会读一下。</p><h2 id="7-《Java性能调优指南》-7-0"><a href="#7-《Java性能调优指南》-7-0" class="headerlink" title="7.《Java性能调优指南》(7.0)"></a><strong>7.<a href="https://book.douban.com/subject/26998058/" title="Title" target="_blank" rel="noopener">《Java性能调优指南》</a>(7.0)</strong></h2><p>&emsp;&emsp;没读过，有机会拜读一下。</p><h2 id="8-《大话设计模式》-8-3"><a href="#8-《大话设计模式》-8-3" class="headerlink" title="8.《大话设计模式》(8.3)"></a><strong>8.<a href="https://book.douban.com/subject/2334288/" title="Title" target="_blank" rel="noopener">《大话设计模式》</a>(8.3)</strong></h2><p>&emsp;&emsp;内容轻松有趣，本应该是枯燥难懂的设计模式让作者以比较有趣的方式展现给读者，强烈推荐。</p><h2 id="9-《设计模式-可复用面向对象软件的基础》-9-1"><a href="#9-《设计模式-可复用面向对象软件的基础》-9-1" class="headerlink" title="9.《设计模式-可复用面向对象软件的基础》(9.1)"></a><strong>9.<a href="https://book.douban.com/subject/1052241/" title="Title" target="_blank" rel="noopener">《设计模式-可复用面向对象软件的基础》</a>(9.1)</strong></h2><p>&emsp;&emsp;设计模式的经典书籍。</p><h2 id="10-《Head-First-设计模式（中文版）》-9-2"><a href="#10-《Head-First-设计模式（中文版）》-9-2" class="headerlink" title="10.《Head First 设计模式（中文版）》(9.2)"></a><strong>10.<a href="https://book.douban.com/subject/2243615/" title="Title" target="_blank" rel="noopener">《Head First 设计模式（中文版）》</a>(9.2)</strong></h2><p>&emsp;&emsp;设计模式入门书籍，强烈推荐。</p><h2 id="11-《代码整洁之道》-8-6"><a href="#11-《代码整洁之道》-8-6" class="headerlink" title="11.《代码整洁之道》(8.6)"></a><strong>11.<a href="https://book.douban.com/subject/4199741/" title="Title" target="_blank" rel="noopener">《代码整洁之道》</a>(8.6)</strong></h2><p>&emsp;&emsp;经典，建议必读，因为时间关系还未读完，但如果有时间我会选择先读这本书。</p><h2 id="12-《重构-改善既有代码的设计》-9-1"><a href="#12-《重构-改善既有代码的设计》-9-1" class="headerlink" title="12.《重构-改善既有代码的设计》(9.1)"></a><strong>12.<a href="https://book.douban.com/subject/4262627/" title="Title" target="_blank" rel="noopener">《重构-改善既有代码的设计》</a>(9.1)</strong></h2><p>&emsp;&emsp;买了还未读，很经典，有重构需求一定要看一下。</p><h1 id="八、分布式"><a href="#八、分布式" class="headerlink" title="八、分布式"></a><strong>八、分布式</strong></h1><p>&emsp;&emsp;学习阶段还未到以下内容，待将来再整理书单</p><h2 id="1-《分布式Java应用》-7-8"><a href="#1-《分布式Java应用》-7-8" class="headerlink" title="1.《分布式Java应用》(7.8)"></a><strong>1.<a href="https://book.douban.com/subject/4848587/" title="Title" target="_blank" rel="noopener">《分布式Java应用》</a>(7.8)</strong></h2><p>&emsp;&emsp;据说淘宝大牛创作，适合入门，没读过无法评价。</p><h2 id="2-《大型网站技术架构-核心原理与案例分析》-7-9"><a href="#2-《大型网站技术架构-核心原理与案例分析》-7-9" class="headerlink" title="2.《大型网站技术架构-核心原理与案例分析》(7.9)"></a><strong>2.<a href="https://book.douban.com/subject/25723064/" title="Title" target="_blank" rel="noopener">《大型网站技术架构-核心原理与案例分析》</a>(7.9)</strong></h2><p>&emsp;&emsp;据说推荐适合入门架构学习，有机会要读一下。</p><h2 id="3-《大型分布式网站架构设计与实践》-6-2"><a href="#3-《大型分布式网站架构设计与实践》-6-2" class="headerlink" title="3.《大型分布式网站架构设计与实践》(6.2)"></a><strong>3.<a href="https://book.douban.com/subject/25972633/" title="Title" target="_blank" rel="noopener">《大型分布式网站架构设计与实践》</a>(6.2)</strong></h2><p>&emsp;&emsp;偏向于实践，有机会再考虑是否需要读一下。</p><h2 id="4-《分布式服务框架-原理与实践》-6-8"><a href="#4-《分布式服务框架-原理与实践》-6-8" class="headerlink" title="4.《分布式服务框架-原理与实践》(6.8)"></a><strong>4.<a href="https://book.douban.com/subject/26702824/" title="Title" target="_blank" rel="noopener">《分布式服务框架-原理与实践》</a>(6.8)</strong></h2><p>&emsp;&emsp;偏向分布式服务的原理讲解和对应实践，有机会再考虑是否需要读一下。</p><h2 id="5-《大型网站系统与Java中间件开发实践》-7-9"><a href="#5-《大型网站系统与Java中间件开发实践》-7-9" class="headerlink" title="5.《大型网站系统与Java中间件开发实践》(7.9)"></a><strong>5.<a href="https://book.douban.com/subject/25867042/" title="Title" target="_blank" rel="noopener">《大型网站系统与Java中间件开发实践》</a>(7.9)</strong></h2><p>&emsp;&emsp;想学中间件相关内容可以看一下。</p><h2 id="6-《从Paxos到Zookeeper分布式一致性原理与实践》-7-8"><a href="#6-《从Paxos到Zookeeper分布式一致性原理与实践》-7-8" class="headerlink" title="6.《从Paxos到Zookeeper分布式一致性原理与实践》(7.8)"></a><strong>6.<a href="https://book.douban.com/subject/26292004/" title="Title" target="_blank" rel="noopener">《从Paxos到Zookeeper分布式一致性原理与实践》</a>(7.8)</strong></h2><p>&emsp;&emsp;zookeeper入门书籍，有机会要读一下。</p><h2 id="7-《大规模分布式存储系统》-7-9"><a href="#7-《大规模分布式存储系统》-7-9" class="headerlink" title="7.《大规模分布式存储系统》(7.9)"></a><strong>7.<a href="https://book.douban.com/subject/25723658/" title="Title" target="_blank" rel="noopener">《大规模分布式存储系统》</a>(7.9)</strong></h2><p>&emsp;&emsp;主要讲解分布式存储相关知识，有机会要读一下。</p><h2 id="8-《微服务设计》-8-2"><a href="#8-《微服务设计》-8-2" class="headerlink" title="8.《微服务设计》(8.2)"></a><strong>8.<a href="https://book.douban.com/subject/26772677/" title="Title" target="_blank" rel="noopener">《微服务设计》</a>(8.2)</strong></h2><p>&emsp;&emsp;是围绕微服务中的要解决的问题展开细聊，有机会要读一下。</p><h2 id="9-《微服务架构设计模式》-9-8"><a href="#9-《微服务架构设计模式》-9-8" class="headerlink" title="9.《微服务架构设计模式》(9.8)"></a><strong>9.<a href="https://book.douban.com/subject/33425123/" title="Title" target="_blank" rel="noopener">《微服务架构设计模式》</a>(9.8)</strong></h2><p>&emsp;&emsp;比较新，评价不错，有机会要读一下。</p><h1 id="九、云计算"><a href="#九、云计算" class="headerlink" title="九、云计算"></a><strong>九、云计算</strong></h1><p>&emsp;&emsp;学习阶段还未到以下内容，待将来再整理书单</p><h2 id="1-《OpenStack设计与实现》-7-3"><a href="#1-《OpenStack设计与实现》-7-3" class="headerlink" title="1.《OpenStack设计与实现》(7.3)"></a><strong>1.<a href="https://book.douban.com/subject/27034723/" title="Title" target="_blank" rel="noopener">《OpenStack设计与实现》</a>(7.3)</strong></h2><h2 id="2-《第一本Docker书》-7-4"><a href="#2-《第一本Docker书》-7-4" class="headerlink" title="2.《第一本Docker书》(7.4)"></a><strong>2.<a href="https://book.douban.com/subject/26285268/" title="Title" target="_blank" rel="noopener">《第一本Docker书》</a>(7.4)</strong></h2><h2 id="3-《Docker开发指南》-8-8"><a href="#3-《Docker开发指南》-8-8" class="headerlink" title="3.《Docker开发指南》(8.8)"></a><strong>3.<a href="https://book.douban.com/subject/27013734/" title="Title" target="_blank" rel="noopener">《Docker开发指南》</a>(8.8)</strong></h2><h2 id="4-《Docker——容器与容器云》-8-5"><a href="#4-《Docker——容器与容器云》-8-5" class="headerlink" title="4.《Docker——容器与容器云》(8.5)"></a><strong>4.<a href="https://book.douban.com/subject/26894736/" title="Title" target="_blank" rel="noopener">《Docker——容器与容器云》</a>(8.5)</strong></h2><h2 id="5-《kubenetes权威指南》-7-4"><a href="#5-《kubenetes权威指南》-7-4" class="headerlink" title="5.《kubenetes权威指南》(7.4)"></a><strong>5.<a href="https://book.douban.com/subject/27112874/" title="Title" target="_blank" rel="noopener">《kubenetes权威指南》</a>(7.4)</strong></h2><h1 id="十、大数据"><a href="#十、大数据" class="headerlink" title="十、大数据"></a><strong>十、大数据</strong></h1><p>&emsp;&emsp;学习阶段还未到以下内容，待将来再整理书单</p><h2 id="1-《大数据技术原理与应用》-9-0"><a href="#1-《大数据技术原理与应用》-9-0" class="headerlink" title="1.《大数据技术原理与应用》(9.0)"></a><strong>1.<a href="https://book.douban.com/subject/27606713/" title="Title" target="_blank" rel="noopener">《大数据技术原理与应用》</a>(9.0)</strong></h2><h2 id="2-《Hadoop实战》-7-7"><a href="#2-《Hadoop实战》-7-7" class="headerlink" title="2.《Hadoop实战》(7.7)"></a><strong>2.<a href="https://book.douban.com/subject/6859710/" title="Title" target="_blank" rel="noopener">《Hadoop实战》</a>(7.7)</strong></h2><h2 id="3-《Hadoop权威指南》-8-7"><a href="#3-《Hadoop权威指南》-8-7" class="headerlink" title="3.《Hadoop权威指南》(8.7)"></a><strong>3.<a href="https://book.douban.com/subject/27115351/" title="Title" target="_blank" rel="noopener">《Hadoop权威指南》</a>(8.7)</strong></h2><hr><p><em>参考博客和文章书籍等：</em></p><blockquote><p><a href="https://www.zhihu.com/question/39308607" target="_blank" rel="noopener">https://www.zhihu.com/question/39308607</a></p></blockquote><blockquote><p><a href="https://www.zhihu.com/question/23152601/answer/683431537" target="_blank" rel="noopener">https://www.zhihu.com/question/23152601/answer/683431537</a></p></blockquote><p><em>因博客主等未标明不可引用，若部分内容涉及侵权请及时告知，我会尽快修改和删除相关内容</em></p>]]></content>
    
    <summary type="html">
    
      记录Java学习中看过、在看以及准备看的书籍清单。
    
    </summary>
    
      <category term="个人记录" scheme="http://linyishui.top/categories/%E4%B8%AA%E4%BA%BA%E8%AE%B0%E5%BD%95/"/>
    
    
      <category term="java" scheme="http://linyishui.top/tags/java/"/>
    
  </entry>
  
  <entry>
    <title>CAS原理</title>
    <link href="http://linyishui.top/2019051801.html"/>
    <id>http://linyishui.top/2019051801.html</id>
    <published>2019-05-18T07:55:50.000Z</published>
    <updated>2019-05-23T09:25:16.000Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="CAS"><a href="#CAS" class="headerlink" title="CAS"></a><strong>CAS</strong></h1><h2 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a><strong>介绍</strong></h2><p>&emsp;&emsp;Compare and Swap即比较并交换，设计并发算法时常用到的一种技术，JVM中的CAS操作通过处理器提供的CMPXCHG指令来实现（<a href="../2019051601.html" title="Title">原子操作的实现原理</a>）。</p><p>&emsp;&emsp;CAS有三个操作数：内存值V、旧的预期值A、要修改的值B，当且仅当预期值A和内存值V相同时，将内存值修改为B并返回true，否则什么都不做并返回false。</p><p>&emsp;&emsp;普通的比较和CAS的区别主要是保证了原子性，前者在并发执行时是不安全的，原因和<a href="../2019051401.html" title="Title">并发和同步</a>中的银行例子一样，当判断生效后线程挂起，其它线程执行导致线程下次执行时状态已经不符合条件判断，但还是执行并返回了修改的结果。所以需要像<a href="../2019032902.html" title="Title">锁机制</a>那样给代码块加锁。<br><figure class="highlight aspectj"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">int</span> v = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">int</span> a = <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="function"><span class="keyword">boolean</span> <span class="title">compareAndSwapInt</span><span class="params">(<span class="keyword">int</span> b)</span></span>&#123;<span class="comment">//普通的比较</span></span><br><span class="line">    <span class="keyword">if</span> (a == v)&#123;</span><br><span class="line">        v = b;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">* 比较obj的offset处内存位置中的值和期望的值，如果相同则更新。此更新是不可中断的。</span></span><br><span class="line"><span class="comment">* </span></span><br><span class="line"><span class="comment">* <span class="doctag">@param</span> obj 需要更新的对象</span></span><br><span class="line"><span class="comment">* <span class="doctag">@param</span> offset obj中整型field的偏移量</span></span><br><span class="line"><span class="comment">* <span class="doctag">@param</span> expect 希望field中存在的值</span></span><br><span class="line"><span class="comment">* <span class="doctag">@param</span> update 如果期望值expect与field的当前值相同，设置filed的值为这个新值</span></span><br><span class="line"><span class="comment">* <span class="doctag">@return</span> 如果field的值被更改返回true</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="meta">@HotSpotIntrinsicCandidate</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">native</span> <span class="keyword">boolean</span> compareAndSetInt(Object o, <span class="keyword">long</span> offset,</span><br><span class="line">                                             <span class="keyword">int</span> expected,</span><br><span class="line">                                             <span class="keyword">int</span> x);</span><br></pre></td></tr></table></figure></p><p>&emsp;&emsp;CAS保证了比较和交换是一组原子操作，不会被中断执行。因为CAS是硬件级别的操作，所以效率比对普通的比较加锁要高一些。</p><hr><h2 id="AtomicInteger"><a href="#AtomicInteger" class="headerlink" title="AtomicInteger"></a><strong>AtomicInteger</strong></h2><p>&emsp;&emsp;java.util.concurrent.atomic并发包下的原子操作类都是基于CAS实现的，有AtomicInteger、AtomicBoolean、AtomicLong等</p><figure class="highlight aspectj"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">AtomicInteger</span> <span class="keyword">extends</span> <span class="title">Number</span> <span class="keyword">implements</span> <span class="title">java</span>.<span class="title">io</span>.<span class="title">Serializable</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> Unsafe unsafe = Unsafe.getUnsafe();<span class="comment">//Unsafe类</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">long</span> valueOffset;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            valueOffset = unsafe.objectFieldOffset</span><br><span class="line">                (AtomicInteger.class.getDeclaredField(<span class="string">"value"</span>));<span class="comment">//对象域偏移</span></span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception ex) &#123; <span class="keyword">throw</span> <span class="keyword">new</span> Error(ex); &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">volatile</span> <span class="keyword">int</span> value;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">long</span> VALUE = U.objectFieldOffset(AtomicInteger.class, <span class="string">"value"</span>);<span class="comment">//对象域偏移</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">volatile</span> <span class="keyword">int</span> value;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">final</span> <span class="function"><span class="keyword">int</span> <span class="title">get</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> value;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">final</span> <span class="function"><span class="keyword">void</span> <span class="title">set</span><span class="params">(<span class="keyword">int</span> newValue)</span> </span>&#123;</span><br><span class="line">        value = newValue;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">final</span> <span class="function"><span class="keyword">int</span> <span class="title">addAndGet</span><span class="params">(<span class="keyword">int</span> delta)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> U.getAndAddInt(<span class="keyword">this</span>, VALUE, delta) + delta;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">final</span> <span class="function"><span class="keyword">void</span> <span class="title">lazySet</span><span class="params">(<span class="keyword">int</span> newValue)</span> </span>&#123;</span><br><span class="line">        unsafe.putOrderedInt(<span class="keyword">this</span>, valueOffset, newValue);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">final</span> <span class="function"><span class="keyword">int</span> <span class="title">getAndSet</span><span class="params">(<span class="keyword">int</span> newValue)</span> </span>&#123;</span><br><span class="line">        <span class="function"><span class="keyword">return</span> unsafe.<span class="title">getAndSetInt</span><span class="params">(<span class="keyword">this</span>, valueOffset, newValue)</span></span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">final</span> <span class="function"><span class="keyword">boolean</span> <span class="title">compareAndSet</span><span class="params">(<span class="keyword">int</span> expect, <span class="keyword">int</span> update)</span> </span>&#123;</span><br><span class="line">        <span class="function"><span class="keyword">return</span> unsafe.<span class="title">compareAndSwapInt</span><span class="params">(<span class="keyword">this</span>, valueOffset, expect, update)</span></span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">final</span> <span class="function"><span class="keyword">boolean</span> <span class="title">weakCompareAndSet</span><span class="params">(<span class="keyword">int</span> expect, <span class="keyword">int</span> update)</span> </span>&#123;</span><br><span class="line">        <span class="function"><span class="keyword">return</span> unsafe.<span class="title">compareAndSwapInt</span><span class="params">(<span class="keyword">this</span>, valueOffset, expect, update)</span></span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    ....</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><h2 id="CAS实例-线程安全的计数器"><a href="#CAS实例-线程安全的计数器" class="headerlink" title="CAS实例-线程安全的计数器"></a><strong>CAS实例-线程安全的计数器</strong></h2><figure class="highlight cs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">CAS</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> AtomicInteger atomicI = <span class="keyword">new</span> AtomicInteger(<span class="number">0</span>);<span class="comment">//原子包装的整型</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> i = <span class="number">0</span>;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span>(<span class="params">String[] args</span>) </span>&#123;</span><br><span class="line">        final CAS cas = <span class="keyword">new</span> CAS();</span><br><span class="line">        List&lt;Thread&gt; ts = <span class="keyword">new</span> ArrayList&lt;Thread&gt;(<span class="number">600</span>);<span class="comment">//线程集合</span></span><br><span class="line">        <span class="keyword">long</span> start = System.currentTimeMillis();</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; <span class="number">100</span>; j++) &#123;</span><br><span class="line">            Thread t = <span class="keyword">new</span> Thread(<span class="keyword">new</span> Runnable() &#123;</span><br><span class="line">                @Override</span><br><span class="line">                <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">                    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10000</span>; i++) &#123;<span class="comment">//分别调用安全和不安全的计数器</span></span><br><span class="line">                        cas.count();</span><br><span class="line">                        cas.safeCount();</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;);</span><br><span class="line">            ts.<span class="keyword">add</span>(t);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (Thread t : ts) &#123;<span class="comment">//遍历执行所有线程</span></span><br><span class="line">            t.start();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 等待所有线程执行完成</span></span><br><span class="line">        <span class="keyword">for</span> (Thread t : ts) &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                t.<span class="keyword">join</span>();</span><br><span class="line">            &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        System.<span class="keyword">out</span>.println(cas.i);</span><br><span class="line">        System.<span class="keyword">out</span>.println(cas.atomicI.<span class="keyword">get</span>());</span><br><span class="line">        System.<span class="keyword">out</span>.println(System.currentTimeMillis() - start);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/** * 使用CAS实现线程安全计数器 */</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">safeCount</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">            <span class="keyword">int</span> i = atomicI.<span class="keyword">get</span>();</span><br><span class="line">            boolean suc = atomicI.compareAndSet(i, ++i);<span class="comment">//预期值i，更新值++i</span></span><br><span class="line">            <span class="keyword">if</span> (suc) &#123;<span class="comment">//执行成功则跳出，否则循环尝试</span></span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 非线程安全计数器</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">count</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">        i++;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//执行结果：</span></span><br><span class="line"><span class="number">991833</span></span><br><span class="line"><span class="number">1000000</span></span><br><span class="line"><span class="number">44</span></span><br></pre></td></tr></table></figure><p>&emsp;&emsp;假设v初始为1，线程1和线程2各自读取并处理v的副本。</p><p>&emsp;&emsp;线程1执行到weakCompareAndSetInt(o, offset, v, v + delta)，线程切换。</p><p>&emsp;&emsp;线程2执行weakCompareAndSetInt(o, offset, v, v + delta)，此时内存v为1，所以更新为v+1，此时内存v为4，线程切换。</p><p>&emsp;&emsp;线程1恢复，执行weakCompareAndSetInt发现内存为4，自己expected为3，所以执行失败返回false。</p><p>&emsp;&emsp;执行v = getIntVolatile(o, offset);线程2的修改对于线程1来说是可见的，所以线程1可以了解线程2修改了v并已经结束，所以v更新为4，并继续执行weakCompareAndSetInt，成功后v更新为5。</p><p>&emsp;&emsp;以上过程不管有多少线程插队执行，CAS都保证了线程最终要在最新的内存数据上进行修改，保证了线程安全。</p><p>&emsp;&emsp;CAS并不是完美的，因为其终究是根据值是否修改来判断是否有进行操作，当出现ABA操作导致值未变化也会被CAS认为是未被修改过，当然在大部分使用CAS的场景下，ABA就可以被当作未修改来处理，如果需要区分时CAS也就不一定是此场景的最优选择了。</p><hr><h2 id="CAS实现原子操作的三大问题"><a href="#CAS实现原子操作的三大问题" class="headerlink" title="CAS实现原子操作的三大问题"></a><strong>CAS实现原子操作的三大问题</strong></h2><p>&emsp;&emsp;Java的并发包中有些并发框架也使用了自旋CAS来实现原子操作，如LinkedTransferQueue的Xfer()方法，CAS常用来实现乐观锁，即每次的数据操作都是CAS，只有判断当前执行过程中没有其它线程对数据进行修改时才将结果存入。</p><h3 id="ABA问题"><a href="#ABA问题" class="headerlink" title="ABA问题"></a><strong>ABA问题</strong></h3><p>&emsp;&emsp;CAS操作值时要检查值有没有变化，所以如果值由A-&gt;B-&gt;A仍可以通过检测，实际是发生过变化的。</p><p>&emsp;&emsp;解决方法：如加入修改次数，版本号。1A-&gt;2B-&gt;3A。</p><p>&emsp;&emsp;Java 1.5后可以通过Atomic包中的AtomicStampedReference解决ABA问题。compareAndSet()会先检查当前引用是否等于预期引用，并检查当前标志是否等于预期标志，如果都相等，则以原子方式将引用和标志设置为给定的更新值。</p><figure class="highlight haxe"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> boolean compareAndSet(V   expectedReference,</span><br><span class="line">                             V   <span class="keyword">new</span><span class="type">Reference</span>,</span><br><span class="line">                             int expectedStamp,</span><br><span class="line">                             int <span class="keyword">new</span><span class="type">Stamp</span>) &#123;</span><br><span class="line">    Pair&lt;V&gt; current = pair;</span><br><span class="line">    <span class="keyword">return</span></span><br><span class="line">        expectedReference == current.reference &amp;&amp;</span><br><span class="line">        expectedStamp == current.stamp &amp;&amp;</span><br><span class="line">        ((<span class="keyword">new</span><span class="type">Reference</span> == current.reference &amp;&amp;</span><br><span class="line">          <span class="keyword">new</span><span class="type">Stamp</span> == current.stamp) ||</span><br><span class="line">         casPair(current, Pair.of(<span class="keyword">new</span><span class="type">Reference</span>, <span class="keyword">new</span><span class="type">Stamp</span>)));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> boolean casPair(Pair&lt;V&gt; cmp, Pair&lt;V&gt; val) &#123;</span><br><span class="line">    <span class="keyword">return</span> UNSAFE.compareAndSwapObject(<span class="built_in">this</span>, pairOffset, cmp, val);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="循环时间长开销大"><a href="#循环时间长开销大" class="headerlink" title="循环时间长开销大"></a><strong>循环时间长开销大</strong></h3><p>&emsp;&emsp;自旋CAS长时间不能执行成功，会给CPU带来巨大的性能开销。</p><p>&emsp;&emsp;解决办法：JVM支持处理器提供的pause指令。</p><blockquote><p><strong>pause指令有两个作用：</strong></p><ol><li>延迟流水线执行指令(de-pipeline)，使CPU不会消耗过多的执行资源，延迟的时间根据具体的实现决定。</li><li>避免在退出循环时因为内存顺序冲突(Memory Order Violation)引起CPU流水线被清空(CPU Pipeline Flush)，从而提高了CPU的执行效率。</li></ol></blockquote><h3 id="只能保证一个共享变量的原子操作"><a href="#只能保证一个共享变量的原子操作" class="headerlink" title="只能保证一个共享变量的原子操作"></a><strong>只能保证一个共享变量的原子操作</strong></h3><p>&emsp;&emsp;当对一个共享变量执行操作时，我们可以使用循环CAS的方式来保证原子操作，但是对多个共享变量操作时，循环CAS就无法保证操作的原子性。</p><p>&emsp;&emsp;解决办法：可以用锁，或者是把多个共享变量合并成一个共享变量来操作。</p><p>&emsp;&emsp;比如，有两个共享变量i＝2，j=a，合并一下ij=2a，然后用CAS来操作ij。</p><p>&emsp;&emsp;从Java 1.5开始，JDK提供了AtomicReference类来保证引用对象之间的原子性，就可以把多个变量放在一个对象里来进行CAS操作。</p><hr><p><em>参考博客和文章书籍等：</em></p><blockquote><p>《Java并发编程的艺术》</p></blockquote><p><em>因博客主等未标明不可引用，若部分内容涉及侵权请及时告知，我会尽快修改和删除相关内容</em></p>]]></content>
    
    <summary type="html">
    
      介绍Java中的CAS原理。
    
    </summary>
    
      <category term="技术文档" scheme="http://linyishui.top/categories/%E6%8A%80%E6%9C%AF%E6%96%87%E6%A1%A3/"/>
    
    
      <category term="java" scheme="http://linyishui.top/tags/java/"/>
    
      <category term="jvm" scheme="http://linyishui.top/tags/jvm/"/>
    
      <category term="cas" scheme="http://linyishui.top/tags/cas/"/>
    
  </entry>
  
  <entry>
    <title>try-catch，try-with-resource</title>
    <link href="http://linyishui.top/2019051101.html"/>
    <id>http://linyishui.top/2019051101.html</id>
    <published>2019-05-18T03:42:50.000Z</published>
    <updated>2019-05-18T10:45:18.000Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>&emsp;&emsp;try-catch是为了处理异常而设计的机制，可以结合<a href="../2019031601.html" title="Title">异常</a>相关知识一起学习。</p><h1 id="try-catch"><a href="#try-catch" class="headerlink" title="try-catch"></a><strong>try-catch</strong></h1><blockquote><p><strong>为什么要设计try-catch？</strong></p><p>&emsp;&emsp;程序需要有错误处理机制，所以有throws用来报错，也需要try-catch来处理错误。但try-catch需要被正确且合理的使用，需要每个开发人员搞懂原理和好的应用场景。</p><p>&emsp;&emsp;如一些人会只抛出异常，全部throw，这种做法是在躲避异常，不是一种好的编程习惯，对于程序来说异常和错误总是需要解决的。</p><p>&emsp;&emsp;而有一些人可能会在所有地方都try-catch，但并没有解决异常的能力没有真正的去处理异常，也就隐藏了BUG，同时也增加了try-catch的开发开销和性能开销，反而得不偿失。</p></blockquote><blockquote><p><strong>项目中应该使用try-catch的场景有哪些？</strong></p><p>&emsp;&emsp;1.当在业务模块遇到exception，一般会在底层throws，在业务顶层try-catch。比如登陆模块，我们实现了内部的登陆函数login()，那么就可能会有：UserNotFoundException、PwdNotMatchException等异常，如果在login()内try-catch，那么在表现层就无法详细的展示具体信息，当然总是会有解决办法的，比如返回errorcode，其相比直接throws让调用者处理来讲，至少首先灵活性差了，扩展性也不高，代码可复用性应该也比不上，这是我目前阶段的感受。</p><p>&emsp;&emsp;2.某些方法内需要进行一些处理，否则程序可能会崩溃或过度消耗资源，比如一些IO操作，网络操作。</p><p>&emsp;&emsp;3.需要对异常进行”翻译”、”记录”等情况，如隐藏一些数据库异常信息、记录异常日志。</p><p>&emsp;&emsp;建议初学者先避免使用try-catch，抛出异常让有经验的来擦屁股，在掌握try-catch以及异常的相关知识，并对项目有一定的理解后再尝试使用，或者按照项目设计的异常处理机制来处理。</p></blockquote><blockquote><p><strong>try-catch的优缺点？</strong></p><p>优点：</p><ol><li>增强了代码的鲁棒性。</li><li>比较灵活应对异常情况，提供解决方案。</li></ol><p>缺点：</p><ol><li>增加了代码的复杂度。</li><li>有一定的性能消耗。</li><li>在一定程度上会诱导初学者滥用。</li></ol></blockquote><h1 id="结构和执行顺序"><a href="#结构和执行顺序" class="headerlink" title="结构和执行顺序"></a><strong>结构和执行顺序</strong></h1><p>&emsp;&emsp;try-catch-finally结构如下，可以看作不同的模块。正常流程下会走try块，当try块发生catch定义的Exception时就跳至catch块，而finally则一定会被执行。</p><figure class="highlight actionscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">try</span>&#123;</span><br><span class="line">    <span class="comment">//code</span></span><br><span class="line">&#125;<span class="keyword">catch</span> (ExceptionType1 ex1 | ExceptionType2 ex2)&#123;</span><br><span class="line">    <span class="comment">//handler for this exception type</span></span><br><span class="line">&#125;<span class="keyword">finally</span> &#123;</span><br><span class="line">    <span class="comment">//一定执行</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//解耦合，实现单一职能，且可以捕获finally中异常</span></span><br><span class="line"><span class="keyword">try</span>&#123;</span><br><span class="line">    <span class="comment">//code</span></span><br><span class="line">    <span class="keyword">try</span>&#123;</span><br><span class="line">        <span class="comment">//code</span></span><br><span class="line">    &#125;<span class="keyword">finally</span> &#123;</span><br><span class="line">        <span class="comment">//一定执行</span></span><br><span class="line">    &#125;  </span><br><span class="line">&#125;<span class="keyword">catch</span> (ExceptionType1 ex1 | ExceptionType2 ex2)&#123;</span><br><span class="line">    <span class="comment">//handler for this exception type</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//也可以只有try-finally语句块</span></span><br><span class="line"><span class="keyword">try</span>&#123;</span><br><span class="line">    <span class="comment">//code</span></span><br><span class="line">&#125;<span class="keyword">finally</span> &#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>&emsp;&emsp;catch的异常可以合并，因为catch块只有发生异常时执行，而try内代码只有顺利的情况下才能全部执行，所以需要finally语句块可以保证某部分代码无论何种情况一定都会执行。比如读取文件流时，需要在退出方法前回收资源，最好的方法就是在finally语句块内执行，其执行顺序一直是最后且一定执行。</p><p>&emsp;&emsp;finally中代码会在return之前执行，若finally中也有return语句会覆盖其它地方的return。如下代码测试，分别计算1，2，3输出结果。</p><figure class="highlight cs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span>(<span class="params">String[] args</span>)</span>&#123;</span><br><span class="line">    System.<span class="keyword">out</span>.println(<span class="string">"f(1): "</span> +f(<span class="number">1</span>));</span><br><span class="line">    System.<span class="keyword">out</span>.println(<span class="string">"f(2): "</span> +f(<span class="number">2</span>));</span><br><span class="line">    System.<span class="keyword">out</span>.println(<span class="string">"f(3): "</span> +f(<span class="number">3</span>));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">f</span>(<span class="params"><span class="keyword">int</span> n</span>)</span>&#123;</span><br><span class="line">    <span class="keyword">try</span>&#123;</span><br><span class="line">        <span class="keyword">int</span> r = n * n;</span><br><span class="line">        <span class="keyword">return</span> r;</span><br><span class="line">    &#125;<span class="keyword">finally</span> &#123;</span><br><span class="line">        <span class="keyword">if</span>(n == <span class="number">2</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>&emsp;&emsp;结果如下。</p><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="title">f</span><span class="params">(<span class="number">1</span>)</span></span>: <span class="number">1</span></span><br><span class="line"><span class="function"><span class="title">f</span><span class="params">(<span class="number">2</span>)</span></span>: <span class="number">0</span></span><br><span class="line"><span class="function"><span class="title">f</span><span class="params">(<span class="number">3</span>)</span></span>: <span class="number">9</span></span><br></pre></td></tr></table></figure><p>&emsp;&emsp;所以try-catch-finally执行顺序为：<br><figure class="highlight smali"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">1. run try-code</span><br><span class="line">2.<span class="built_in"> if </span>has exception then<span class="built_in"> goto </span>3 else 6</span><br><span class="line">3. run catch-code</span><br><span class="line">4. run<span class="keyword"> final</span>ly-code</span><br><span class="line">5.<span class="built_in"> if </span>finally-code has<span class="built_in"> return </span>then<span class="built_in"> return-finally </span>else return-catch</span><br><span class="line">6. run<span class="keyword"> final</span>ly-code</span><br><span class="line">7.<span class="built_in"> if </span>finally-code has<span class="built_in"> return </span>then<span class="built_in"> return-finally </span>else return-try</span><br></pre></td></tr></table></figure></p><h1 id="try-with-resource"><a href="#try-with-resource" class="headerlink" title="try-with-resource"></a><strong>try-with-resource</strong></h1><p>&emsp;&emsp;Java SE7 以后新增了带资源的try语句，当try块退出时会自动调用res.close。</p><figure class="highlight cs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">try</span>(Resource res = ...)&#123;</span><br><span class="line">    work with res</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//try-catch-finally关闭文件资源</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span>(<span class="params">String[] args</span>)</span>&#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        Scanner <span class="keyword">in</span> = <span class="keyword">new</span> Scanner(<span class="keyword">new</span> FileInputStream(<span class="string">"/in.txt"</span>),<span class="string">"UTF-8"</span>);</span><br><span class="line">        PrintWriter <span class="keyword">out</span> = <span class="keyword">new</span> PrintWriter(<span class="string">"/out.txt"</span>);</span><br><span class="line">        <span class="keyword">while</span> (<span class="keyword">in</span>.hasNext())</span><br><span class="line">            <span class="keyword">out</span>.println(<span class="keyword">in</span>.next().toUpperCase());</span><br><span class="line">    &#125;<span class="keyword">catch</span> (FileNotFoundException ex)&#123;</span><br><span class="line">        ex.printStackTrace();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//try-with-resource关闭文件资源</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span>(<span class="params">String[] args</span>)</span>&#123;</span><br><span class="line">    <span class="keyword">try</span> (Scanner <span class="keyword">in</span> = <span class="keyword">new</span> Scanner(<span class="keyword">new</span> FileInputStream(<span class="string">"/in.txt"</span>),<span class="string">"UTF-8"</span>);</span><br><span class="line">        PrintWriter <span class="keyword">out</span> = <span class="keyword">new</span> PrintWriter(<span class="string">"/out.txt"</span>))&#123;</span><br><span class="line">        <span class="keyword">while</span> (<span class="keyword">in</span>.hasNext())</span><br><span class="line">            <span class="keyword">out</span>.println(<span class="keyword">in</span>.next().toUpperCase());</span><br><span class="line">    &#125;<span class="keyword">catch</span> (FileNotFoundException ex)&#123;</span><br><span class="line">        ex.printStackTrace();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//反编译后得到</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span>(<span class="params">String[] var0</span>) </span>&#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            Scanner var1 = <span class="keyword">new</span> Scanner(<span class="keyword">new</span> FileInputStream(<span class="string">"/in.txt"</span>), <span class="string">"UTF-8"</span>);</span><br><span class="line">            Throwable var2 = <span class="literal">null</span>;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                PrintWriter var3 = <span class="keyword">new</span> PrintWriter(<span class="string">"/out.txt"</span>);</span><br><span class="line">                Throwable var4 = <span class="literal">null</span>;</span><br><span class="line"></span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    <span class="keyword">while</span>(var1.hasNext()) &#123;</span><br><span class="line">                        var3.println(var1.next().toUpperCase());</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125; <span class="keyword">catch</span> (Throwable var29) &#123;</span><br><span class="line">                    var4 = var29;</span><br><span class="line">                    <span class="keyword">throw</span> var29;</span><br><span class="line">                &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">                    <span class="keyword">if</span> (var3 != <span class="literal">null</span>) &#123;</span><br><span class="line">                        <span class="keyword">if</span> (var4 != <span class="literal">null</span>) &#123;</span><br><span class="line">                            <span class="keyword">try</span> &#123;</span><br><span class="line">                                var3.close();</span><br><span class="line">                            &#125; <span class="keyword">catch</span> (Throwable var28) &#123;</span><br><span class="line">                                var4.addSuppressed(var28);</span><br><span class="line">                            &#125;</span><br><span class="line">                        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                            var3.close();</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;</span><br><span class="line"></span><br><span class="line">                &#125;</span><br><span class="line">            &#125; <span class="keyword">catch</span> (Throwable var31) &#123;</span><br><span class="line">                var2 = var31;</span><br><span class="line">                <span class="keyword">throw</span> var31;</span><br><span class="line">            &#125; <span class="keyword">finally</span> &#123;<span class="comment">//编译器自动生成资源关闭操作</span></span><br><span class="line">                <span class="keyword">if</span> (var1 != <span class="literal">null</span>) &#123;</span><br><span class="line">                    <span class="keyword">if</span> (var2 != <span class="literal">null</span>) &#123;</span><br><span class="line">                        <span class="keyword">try</span> &#123;</span><br><span class="line">                            var1.close();</span><br><span class="line">                        &#125; <span class="keyword">catch</span> (Throwable var27) &#123;</span><br><span class="line">                            var2.addSuppressed(var27);</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                        var1.close();</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (FileNotFoundException var33) &#123;</span><br><span class="line">            var33.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><hr><p><em>参考博客和文章书籍等：</em></p><blockquote><p>《Java核心技术 卷Ⅱ》</p></blockquote><blockquote><p><a href="https://mp.weixin.qq.com/s/6dqFNzfSe88vYMW_r3s3Bw" target="_blank" rel="noopener">https://mp.weixin.qq.com/s/6dqFNzfSe88vYMW_r3s3Bw</a></p></blockquote><p><em>因博客主未标明不可转载，若内容涉及侵权请及时告知，我会尽快修改和删除相关内容</em></p>]]></content>
    
    <summary type="html">
    
      涉及内容：try-catch-finally，try-with-resource
    
    </summary>
    
      <category term="技术文档" scheme="http://linyishui.top/categories/%E6%8A%80%E6%9C%AF%E6%96%87%E6%A1%A3/"/>
    
    
      <category term="java" scheme="http://linyishui.top/tags/java/"/>
    
  </entry>
  
  <entry>
    <title>自动装箱和拆箱，可变长参数，数值字面量</title>
    <link href="http://linyishui.top/2019051001.html"/>
    <id>http://linyishui.top/2019051001.html</id>
    <published>2019-05-18T02:18:40.000Z</published>
    <updated>2019-05-18T03:36:22.000Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="自动装箱和拆箱"><a href="#自动装箱和拆箱" class="headerlink" title="自动装箱和拆箱"></a><strong>自动装箱和拆箱</strong></h1><p>&emsp;&emsp;装箱：将基本类型用它们对应的引用类型包装起来。</p><p>&emsp;&emsp;拆箱：将包装类型转换为基本数据类型。</p><p>&emsp;&emsp;Java使用自动装箱和拆箱机制，节省了常用数值的内存开销和创建对象的开销，提高了效率，由编译器来完成，编译器会在编译期根据语法决定是否进行装箱和拆箱动作。</p><h2 id="场景"><a href="#场景" class="headerlink" title="场景"></a><strong>场景</strong></h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//装箱</span></span><br><span class="line">Integer i = <span class="number">1</span>;</span><br><span class="line"><span class="comment">//编译器自动处理为-&gt; </span></span><br><span class="line"><span class="comment">//Integer i = Integer.valueOf(1);</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//拆箱</span></span><br><span class="line"><span class="keyword">int</span> i1 = i;</span><br><span class="line"><span class="comment">//编译器自动处理为-&gt; </span></span><br><span class="line"><span class="comment">//int i1 = i.intValue();</span></span><br></pre></td></tr></table></figure><h2 id="作用"><a href="#作用" class="headerlink" title="作用"></a><strong>作用</strong></h2><p>&emsp;&emsp;也可以把包装类型的作用纳入：</p><ol><li>方便开发人员不用处理基本类型和包装类的转换过程</li><li>包装类扩展了基本类型，可以提供丰富的属性和API</li><li>包装类为泛型提供了支持</li><li>包装类把基本类型封装为了抽象对象，也就体现了对象的优点：更好的模拟现实</li></ol><h1 id="可变长参数"><a href="#可变长参数" class="headerlink" title="可变长参数"></a><strong>可变长参数</strong></h1><p>&emsp;&emsp;可变长参数在Java 1.5时引入，可以使方法将一个任意数目的值作为参数。</p><figure class="highlight processing"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> main(<span class="keyword">String</span>[] args) &#123;</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">"1"</span>,<span class="string">"2"</span>,<span class="string">"3"</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="built_in">print</span>(<span class="keyword">String</span>... strs)&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">String</span> <span class="built_in">str</span> : strs)</span><br><span class="line">        System.out.<span class="built_in">println</span>(<span class="built_in">str</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>&emsp;&emsp;反编译后如下，String…编译为字符串数组String[]，数组长度为参数个数。</p><figure class="highlight arduino"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> class VarParm &#123;</span><br><span class="line">    <span class="keyword">public</span> VarParm() &#123;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> main(<span class="keyword">String</span>[] var0) &#123;</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">"1"</span>, <span class="string">"2"</span>, <span class="string">"3"</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="built_in">print</span>(<span class="keyword">String</span>... var0) &#123;</span><br><span class="line">        <span class="keyword">String</span>[] var1 = var0;</span><br><span class="line">        <span class="keyword">int</span> var2 = var0.length;</span><br><span class="line"></span><br><span class="line">        <span class="built_in">for</span>(<span class="keyword">int</span> var3 = <span class="number">0</span>; var3 &lt; var2; ++var3) &#123;</span><br><span class="line">            <span class="keyword">String</span> var4 = var1[var3];</span><br><span class="line">            System.out.<span class="built_in">println</span>(var4);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="数值字面量"><a href="#数值字面量" class="headerlink" title="数值字面量"></a><strong>数值字面量</strong></h1><p>&emsp;&emsp;在Java 7引入了数值字面量，允许在整型和浮点型数字中添加下划线“_”，在编译时会被擦除，用来方便阅读</p><figure class="highlight cs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">NumLiteralValue</span> &#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span>(<span class="params">String[] args</span>) </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> a = <span class="number">10</span>_000_000;</span><br><span class="line">        System.<span class="keyword">out</span>.println(a);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">console: <span class="number">10000000</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//Decompile</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">NumLiteralValue</span> &#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">NumLiteralValue</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span>(<span class="params">String[] var0</span>) </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> var1 = <span class="number">10000000</span>;</span><br><span class="line">        System.<span class="keyword">out</span>.println(var1);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><p><em>参考博客和文章书籍等：</em></p><blockquote><p><a href="https://zhuanlan.zhihu.com/p/27657548" target="_blank" rel="noopener">https://zhuanlan.zhihu.com/p/27657548</a></p></blockquote><blockquote><p><a href="https://mp.weixin.qq.com/s/6dqFNzfSe88vYMW_r3s3Bw" target="_blank" rel="noopener">https://mp.weixin.qq.com/s/6dqFNzfSe88vYMW_r3s3Bw</a></p></blockquote><p><em>因博客主未标明不可转载，若内容涉及侵权请及时告知，我会尽快修改和删除相关内容</em></p>]]></content>
    
    <summary type="html">
    
      涉及内容：自动装箱和拆箱，可变长参数，数值字面量
    
    </summary>
    
      <category term="技术文档" scheme="http://linyishui.top/categories/%E6%8A%80%E6%9C%AF%E6%96%87%E6%A1%A3/"/>
    
    
      <category term="java" scheme="http://linyishui.top/tags/java/"/>
    
  </entry>
  
  <entry>
    <title>Java内存模型</title>
    <link href="http://linyishui.top/2019051701.html"/>
    <id>http://linyishui.top/2019051701.html</id>
    <published>2019-05-17T06:42:58.000Z</published>
    <updated>2019-05-23T09:50:40.000Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="Java内存模型"><a href="#Java内存模型" class="headerlink" title="Java内存模型"></a><strong>Java内存模型</strong></h1><h2 id="基本概念"><a href="#基本概念" class="headerlink" title="基本概念"></a><strong>基本概念</strong></h2><p>&emsp;&emsp;Java的并发采用的是共享内存模型，Java线程之间的通信总是隐式进行，整个通信过程对程序员完全透明。</p><h3 id="Java内存模型的抽象结构"><a href="#Java内存模型的抽象结构" class="headerlink" title="Java内存模型的抽象结构"></a><strong>Java内存模型的抽象结构</strong></h3><p>&emsp;&emsp;可以配合<a href="../2019050801.html" title="Title">Java内存区域和内存溢出异常</a>一起学习。</p><p>&emsp;&emsp;所有<strong>实例域</strong>、<strong>静态域</strong>和<strong>数组元素</strong>都存储在堆内存中，堆内存在线程之间共享，可以将它们看作<strong>共享变量</strong>。<strong>局部变量</strong>，<strong>方法定义参数</strong>和<strong>异常处理器参数</strong>不会在线程之间共享，它们不会有内存可见性问题，也不受内存模型的影响。</p><p>&emsp;&emsp;Java内存模型定义了线程和主内存之间的抽象关系：线程之间的共享变量存储在主内存（Main Memory）中，每个线程都有一个私有的本地内存（Local Memory），本地内存中存储了该线程以读/写共享变量的副本。本地内存是JMM的一个抽象概念，并不真实存在。它涵盖了缓存、写缓冲区、寄存器以及其他的硬件和编译器优化</p><p><img src="https://pic-1258215793.cos.ap-shanghai.myqcloud.com/content/20190512/Java%E5%86%85%E5%AD%98%E6%A8%A1%E5%9E%8B%E6%8A%BD%E8%B1%A1%E7%BB%93%E6%9E%84.png" alt="Java内存模型抽象结构"></p><h3 id="线程之间如何通信"><a href="#线程之间如何通信" class="headerlink" title="线程之间如何通信"></a><strong>线程之间如何通信</strong></h3><p>&emsp;&emsp;<strong>通信</strong>是指线程之间以何种机制来交换信息。在命令式编程中，线程之间的通信机制有两种：<strong>共享内存</strong>和<strong>消息传递</strong>。</p><p>&emsp;&emsp;在<strong>共享内存</strong>的并发模型里，线程之间共享程序的公共状态，通过写-读内存中的公共状态进行隐式通信。在<strong>消息传递</strong>的并发模型里，线程之间没有公共状态，线程之间必须通过发送消息来显式进行通信。</p><p>&emsp;&emsp;Java线程之间的通信由<strong>Java内存模型</strong>控制，Java内存模型决定一个线程对共享变量的写入何时对另一个线程可见。</p><blockquote><p><strong>线程A和线程B通信步骤：</strong></p><ol><li>线程A把本地内存A中更新过的共享变量刷新到主内存中去。</li><li>线程B到主内存中去读取线程A之前已更新过的共享变量。</li></ol></blockquote><p><img src="https://pic-1258215793.cos.ap-shanghai.myqcloud.com/content/20190512/%E7%BA%BF%E7%A8%8B%E9%97%B4%E9%80%9A%E4%BF%A1.png" alt="线程间通信"></p><p>&emsp;&emsp;如图所示，本地内存A和本地内存B由主内存中共享变量x的副本。假设初始时，这3个内存中的x值都为0。线程A在执行时，把更新后的x值（假设值为1）临时存放在自己的本地内存A中。当线程A和线程B需要通信时，线程A首先会把自己本地内存中修改后的x值刷新到主内存中，此时主内存中的x值变为了1。随后，线程B到主内存中去读取线程A更新后的x值，此时线程B的本地内存的x值也变为了1。</p><p>&emsp;&emsp;从整体来看，这两个步骤实质上是线程A在向线程B发送消息，而且这个通信过程必须要经过主内存。JMM通过控制主内存与每个线程的本地内存之间的交互，来为Java程序员提供内存可见性保证。</p><h3 id="线程之间如何同步"><a href="#线程之间如何同步" class="headerlink" title="线程之间如何同步"></a><strong>线程之间如何同步</strong></h3><p>&emsp;&emsp;同步是指程序中用于控制不同线程间操作发生相对顺序的机制。在共享内存并发模型里，同步是显式进行的。程序员必须显式指定某个方法或某段代码需要在线程之间互斥执行。在消息传递的并发模型里，由于消息的发送必须在消息的接收之前，因此同步是隐式进行的。</p><h2 id="从源代码到指令序列的重排序"><a href="#从源代码到指令序列的重排序" class="headerlink" title="从源代码到指令序列的重排序"></a><strong>从源代码到指令序列的重排序</strong></h2><hr><p><em>参考博客和文章书籍等：</em></p><blockquote><p>《Java并发编程的艺术》</p></blockquote><p><em>因博客主等未标明不可引用，若部分内容涉及侵权请及时告知，我会尽快修改和删除相关内容</em></p>]]></content>
    
    <summary type="html">
    
      介绍Java内存模型相关概念，顺序一致性，重排序，同步原语等。
    
    </summary>
    
      <category term="技术文档" scheme="http://linyishui.top/categories/%E6%8A%80%E6%9C%AF%E6%96%87%E6%A1%A3/"/>
    
    
      <category term="java" scheme="http://linyishui.top/tags/java/"/>
    
      <category term="jvm" scheme="http://linyishui.top/tags/jvm/"/>
    
  </entry>
  
  <entry>
    <title>原子操作的实现原理</title>
    <link href="http://linyishui.top/2019051601.html"/>
    <id>http://linyishui.top/2019051601.html</id>
    <published>2019-05-16T03:10:56.000Z</published>
    <updated>2019-05-23T09:24:40.000Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="原子性"><a href="#原子性" class="headerlink" title="原子性"></a><strong>原子性</strong></h1><h2 id="定义"><a href="#定义" class="headerlink" title="定义"></a><strong>定义</strong></h2><p>&emsp;&emsp;<strong>原子</strong>(atomic)是不能再被切割的最小粒子。</p><p>&emsp;&emsp;<strong>原子操作</strong>是不能被中断的一个或一系列操作。</p><h2 id="CPU常用术语"><a href="#CPU常用术语" class="headerlink" title="CPU常用术语"></a><strong>CPU常用术语</strong></h2><p><img src="https://pic-1258215793.cos.ap-shanghai.myqcloud.com/content/20190512/CPU%E6%9C%AF%E8%AF%AD.png" alt="CPU术语"></p><hr><h2 id="一、CPU实现原子操作"><a href="#一、CPU实现原子操作" class="headerlink" title="一、CPU实现原子操作"></a><strong>一、CPU实现原子操作</strong></h2><ol><li><p>简单读写：处理器保证从系统内存中读取或者写入一个字节是原子的，意思是当一个处理器读取一个字节时，其他处理器不能访问这个字节的内存地址。</p></li><li><p>复杂操作：处理器提供总线锁定和缓存锁定两个机制来保证复杂内存操作的原子性。</p></li></ol><p>非原子操作：如比较常用的读改写操作，最经典的i++就是，要分步执行读取、修改、写入操作。</p><h3 id="总线锁"><a href="#总线锁" class="headerlink" title="总线锁"></a><strong>总线锁</strong></h3><p>&emsp;&emsp;处理器可以通过总线锁来保证原子性，即通过在总线上输出LOCK #信号，使其他处理器的请求阻塞，此处理器就可以独占共享内存了。</p><p>&emsp;&emsp;因为总线锁封闭了处理器和内存间的通信，造成这个阶段其他处理器无法工作的局面，这是很大的性能开销，所以一些场合可以用<strong>缓存锁定</strong>来代替总线锁定。</p><h3 id="缓存锁定"><a href="#缓存锁定" class="headerlink" title="缓存锁定"></a><strong>缓存锁定</strong></h3><p>&emsp;&emsp;谓“缓存锁定”是指内存区域如果被缓存在处理器的缓存行中，并且在Lock操作期间被锁定，那么当它执行锁操作回写到内存时，处理器不在总线上声言LOCK＃信号，而是修改内部的内存地址，并允许它的缓存一致性机制来保证操作的原子性，因为缓存一致性机制会阻止同时修改由两个以上处理器缓存的内存区域数据，当其他处理器回写已被锁定的缓存行的数据时，会使缓存行无效。</p><p><strong>无法使用缓存锁定的情况：</strong></p><ol><li>CPU不支持缓存锁定</li><li>操作的数据无法被缓存到处理器的缓存区，或操作的数据跨了多个缓存行。</li></ol><h3 id="缓存一致性机制"><a href="#缓存一致性机制" class="headerlink" title="缓存一致性机制"></a><strong>缓存一致性机制</strong></h3><p>&emsp;&emsp;简单说就是：当某处理器对缓存中的数据进行了操作之后，通知其他处理器放弃储存在它们内部的缓存，或者从主内存中重新读取</p><blockquote><p>PS: 频繁使用的内存会缓存在处理器的L1、L2和L3高速缓存里，以便减少处理器和内存的交互。</p></blockquote><p><img src="https://pic-1258215793.cos.ap-shanghai.myqcloud.com/content/20190512/%E7%BC%93%E5%AD%98%E4%B8%80%E8%87%B4%E6%80%A7%E5%8D%8F%E8%AE%AE.png" alt="缓存一致性机制"></p><blockquote><p><strong>MESI协议</strong>(Modified、Exclusive、Share or Invalid)</p><p>Modified、Exclusive、Share or Invalid即缓存行的四个状态：</p><ol><li>Modified-<strong>被修改</strong>：处于此状态的数据，只在本CPU中有缓存数据，而其他CPU中没有。同时其状态相对于内存中的值来说，是已经被修改的，且没有更新到内存中。</li><li>Exclusive-<strong>独占</strong>：处于此状态的数据，只有在本CPU中有缓存，且其数据没有修改，即与内存中一致。</li><li>Share-<strong>共享</strong>：处于此状态的数据在多个CPU中都有缓存，且与内存一致。</li><li>Invalid-<strong>无效</strong>：本CPU中的这份缓存已经无效。</li></ol><p>此协议规定：</p><ul><li>一个处于Modified状态的缓存行，必须时刻监听所有试图读取该缓存行对应的主存地址的操作，如果监听到，则必须在此操作执行前把其缓存行中的数据写回CPU。 </li><li>一个处于Share状态的缓存行，必须时刻监听使该缓存行无效或者独享该缓存行的请求，如果监听到，则必须把其缓存行状态设置为I。 </li><li>一个处于Exclusive状态的缓存行，必须时刻监听其他试图读取该缓存行对应的主存地址的操作，如果监听到，则必须把其缓存行状态设置为S。</li></ul></blockquote><p>&emsp;&emsp;当某CPU读取数据时，若其缓存行的状态为Invalid，则需要从内存中读取数据，然后把状态改为Share；如果不是Invalid，则可以直接读取缓存中的数据。但还需要同时判断其他CPU的监听结果，如果其他CPU也有此数据的缓存，并处于Modified状态，则要等待其将数据更新回内存后，才能继续读取。</p><p>&emsp;&emsp;当某CPU写入数据时，只能在状态为Modified和Exclusive时才允许执行，否则需要发送<strong>RFO指令</strong>（Read Or Ownership，这是一种总线事务），通知其他CPU使其缓存无效，会有一定的性能开销，写入后将状态转换为Modified。</p><h3 id="指令支持"><a href="#指令支持" class="headerlink" title="指令支持"></a><strong>指令支持</strong></h3><p>&emsp;&emsp;CPU提供了一些Lock前缀的指令来支持两种锁定：</p><ul><li>位测试和修改指令：BTS、BTR、BTC</li><li>交换指令：XADD、CMPXCHG</li><li>操作和逻辑指令：ADD、OR等</li></ul><p>&emsp;&emsp;这些指令都会使被操作的内存区域加锁。</p><hr><h2 id="二、Java实现原子操作"><a href="#二、Java实现原子操作" class="headerlink" title="二、Java实现原子操作"></a><strong>二、Java实现原子操作</strong></h2><p>&emsp;&emsp;在Java中可以通过<strong>锁机制</strong>和<strong>循环CAS</strong>的方式来实现原子操作。</p><h3 id="锁机制"><a href="#锁机制" class="headerlink" title="锁机制"></a><strong>锁机制</strong></h3><p>&emsp;&emsp;可以参考<a href="../2019032902.html" title="Title">锁机制</a></p><p>&emsp;&emsp;锁机制保证了只有获得锁的线程才有权操作被锁定的内存区域，。JVM内部实现了很多种锁机制，有偏向锁、轻量级锁和互斥锁。有意思的是除了偏向锁，JVM实现锁的方式都用了循环CAS，即当一个线程想进入同步块的时候使用循环CAS的方式来获取锁，当它退出同步块的时候使用循环CAS释放锁。</p><h3 id="循环CAS"><a href="#循环CAS" class="headerlink" title="循环CAS"></a><strong>循环CAS</strong></h3><p>&emsp;&emsp;可以参考<a href="../2019051801.html" title="Title">CAS原理</a></p><p>&emsp;&emsp;循环CAS保证了共享变量的原子性操作。</p><hr><p><em>参考博客和文章书籍等：</em></p><blockquote><p>《Java并发编程的艺术》</p></blockquote><blockquote><p><a href="http://www.cnblogs.com/mengheng/p/3491092.html" target="_blank" rel="noopener">http://www.cnblogs.com/mengheng/p/3491092.html</a></p></blockquote><p><em>因博客主等未标明不可引用，若部分内容涉及侵权请及时告知，我会尽快修改和删除相关内容</em></p>]]></content>
    
    <summary type="html">
    
      原子操作的实现原理，简单介绍了缓存一致性机制
    
    </summary>
    
      <category term="技术文档" scheme="http://linyishui.top/categories/%E6%8A%80%E6%9C%AF%E6%96%87%E6%A1%A3/"/>
    
    
      <category term="java" scheme="http://linyishui.top/tags/java/"/>
    
      <category term="jvm" scheme="http://linyishui.top/tags/jvm/"/>
    
  </entry>
  
  <entry>
    <title>线程QA</title>
    <link href="http://linyishui.top/2019051501.html"/>
    <id>http://linyishui.top/2019051501.html</id>
    <published>2019-05-15T02:21:37.000Z</published>
    <updated>2019-05-22T02:36:48.000Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="Q-amp-A"><a href="#Q-amp-A" class="headerlink" title="Q&amp;A"></a><strong>Q&amp;A</strong></h1><blockquote><p><strong>1. 线程与进程的区别？</strong></p><p>&emsp;&emsp;进程是操作系统分配资源的最小单元，线程则是操作系统调度的最小单元。一个程序至少有一个进程，一个进程至少有一个线程。</p></blockquote><blockquote><p><strong>2. 上下文切换？</strong></p><p>&emsp;&emsp;操作系统通过将单个CPU的时间片分配给多个进程来达到并行处理的效果，多线程使用单个或少于线程数CPU时，需要轮转使用CPU。</p><p>&emsp;&emsp;不同线程切换CPU时，因为当前线程任务并没有完成，需要保存线程的运行状态，以便再下次切回时能够继续执行，在此过程中发生的切换数据即上下文切换，其目的是为了方便线程从中断点恢复执行。</p></blockquote><blockquote><p><strong>3. 什么是线程调度器和时间分片？</strong></p><p>&emsp;&emsp;线程调度器(Thread Scheduler)是一个操作系统服务，它负责为Runnable状态的线程分配CPU时间。一旦我们创建一个线程并启动它，它的执行便依赖于线程调度器的实现。 线程调度并不受到Java虚拟机控制，所以由应用程序来控制它是更好的选择（也就是说不要让你的程序依赖于线程的优先级）。</p><p>&emsp;&emsp;时间分片(Time Slicing)是指将可用的CPU时间分配给可用的Runnable线程的过程。分配CPU时间可以基于线程优先级或者线程等待的时间。</p></blockquote><blockquote><p><strong>4. 线程之间是如何通信的？</strong></p><p>&emsp;&emsp;共享变量，中断。当线程间是可以共享资源时，线程间通信是协调它们的重要的手段。Object类中wait() otify() otifyAll()方法可以用于线程间通信关于资源的锁的状态。</p></blockquote><blockquote><p><strong>5. notify()与notifyAll()区别？</strong></p><p>&emsp;&emsp;notifyAll()可以唤醒所有等待的线程，notify()只能唤醒一个</p></blockquote><blockquote><p><strong>6. wait()与sleep()区别？</strong></p><p>&emsp;&emsp;等待时wait会释放锁，而sleep一直持有锁。Wait通常被用于线程间交互，sleep通常被用于暂停执行。wait()方法会释放CPU执行权和占有的锁。</p><p>&emsp;&emsp;sleep(long)方法仅释放CPU使用权，锁仍然占用；线程被放入超时等待队列，与yield相比，它会使线程较长时间得不到运行。</p><p>&emsp;&emsp;yield()方法仅释放CPU执行权，锁仍然占用，线程会被放入就绪队列，会在短时间内再次执行。</p><p>&emsp;&emsp;wait和notify必须配套使用，即必须使用同一把锁调用；</p><p>&emsp;&emsp;wait和notify必须放在一个同步块中调用wait和notify的对象必须是他们所处同步块的锁对象。</p></blockquote><blockquote><p><strong>7. 为什么wait和notify方法要在同步块中调用？</strong></p><p>&emsp;&emsp;Java API强制要求这样做，非同步块内调用会抛出IllegalMonitorStateException异常。</p><p>&emsp;&emsp;当一个线程需要调用对象的wait()方法的时候，这个线程必须拥有该对象的锁，接着它就会释放这个对象锁并进入等待状态直到其他线程调用这个对象上的notify()方法。同样的，当一个线程需要调用对象的notify()方法时，它会释放这个对象的锁，以便其他在等待的线程就可以得到这个对象锁。由于所有的这些方法都需要线程持有对象的锁，这样就只能通过同步来实现，所以他们只能在同步方法或者同步块中被调用。避免wait和notify之间产生竞态条件。</p></blockquote><blockquote><p><strong>8. 为什么弃用stop()？</strong></p><p>&emsp;&emsp;</p></blockquote><blockquote><p><strong>9. 为什么wait, notify 和 notifyAll这些方法不在thread类里面？</strong></p><p>&emsp;&emsp;一个很明显的原因是JAVA提供的锁是对象级的而不是线程级的，每个对象都有锁，通过线程获得。由于wait，notify和notifyAll都是锁级别的操作，所以把他们定义在Object类中因为锁属于对象。Java的每个对象中都有一个锁(monitor，也可以成为监视器) 并且wait()，notify()等方法用于等待对象的锁或者通知其他线程对象的监视器可用。在Java的线程中并没有可供任何对象使用的锁和同步器。这就是为什么这些方法是Object类的一部分，这样Java的每一个类都有用于线程间通信的基本方法。</p></blockquote><blockquote><p><strong>10. 为什么Thread类的sleep()和yield ()方法是静态的？</strong></p><p>&emsp;&emsp;Thread类的sleep()和yield()方法将在当前正在执行的线程上运行。所以在其他处于等待状态的线程上调用这些方法是没有意义的。这就是为什么这些方法是静态的。它们可以在当前正在执行的线程中工作，并避免程序员错误的认为可以在其他非运行线程调用这些方法。</p></blockquote><blockquote><p><strong>11. 如何确保main()方法所在的线程是Java程序最后结束的线程？</strong></p><p>&emsp;&emsp;可以使用Thread类的join()方法来确保所有程序创建的线程在main()方法退出前结束。</p></blockquote><blockquote><p><strong>12. 为什么你应该在循环中检查等待条件?</strong></p><p>&emsp;&emsp;处于等待状态的线程可能会收到错误警报和伪唤醒，如果不在循环中检查等待条件，程序就会在没有满足结束条件的情况下退出。</p></blockquote><blockquote><p><strong>13. 什么是ThreadLocal变量？</strong></p><p>&emsp;&emsp;ThreadLocal是Java里一种特殊的变量。每个线程都有一个ThreadLocal就是每个线程都拥有了自己独立的一个变量，竞争条件被彻底消除了。它是为创建代价高昂的对象获取线程安全的好方法，比如你可以用ThreadLocal让SimpleDateFormat变成线程安全的，因为那个类创建代价高昂且每次调用都需要创建不同的实例所以不值得在局部范围使用它，如果为每个线程提供一个自己独有的变量拷贝，将大大提高效率。首先，通过复用减少了代价高昂的对象的创建个数。其次，你在没有使用高代价的同步或者不变性的情况下获得了线程安全。</p></blockquote><blockquote><p><strong>14. 在java中守护线程和本地线程区别？</strong></p><p>&emsp;&emsp;java中的线程分为两种：守护线程（Daemon）和用户线程（User）。</p><p>任何线程都可以设置为守护线程和用户线程，两者的区别：</p><p>&emsp;&emsp;唯一的区别是判断虚拟机(JVM)何时离开，Daemon是为其他线程提供服务，如果全部的User Thread已经撤离，Daemon 没有可服务的线程，JVM撤离。也可以理解为守护线程是JVM自动创建的线程（但不一定），用户线程是程序创建的线程；比如JVM的垃圾回收线程是一个守护线程，当所有线程已经撤离，不再产生垃圾，守护线程自然就没事可干了，当垃圾回收线程是Java虚拟机上仅剩的线程时，Java虚拟机会自动离开。只要有任何非守护线程还在运行，程序就不会终止。必须在线程启动之前调用setDaemon()方法，才能把它设置为守护线程。 注意： 后台进程在不执行finally子句的情况下就会终止其run()方法。比如：JVM的垃圾回收线程就是Daemon线程，Finalizer也是守护线程。</p><p>扩展：</p><p>&emsp;&emsp;Thread Dump打印出来的线程信息，含有daemon字样的线程即为守护进程，可能会有：服务守护进程、编译守护进程、windows下的监听Ctrl+break的守护进程、Finalizer守护进程、引用处理守护进程、GC守护进程。</p></blockquote><blockquote><p><strong>15. Java中interrupted 和 isInterrupted方法的区别？</strong></p><p>&emsp;&emsp;interrupt方法用于中断线程。调用该方法的线程的状态为将被置为”中断”状态。 注意：线程中断仅仅是置线程的中断状态位，不会停止线程。需要用户自己去监视线程的状态为并做处理。支持线程中断的方法（也就是线程中断后会抛出interruptedException的方法）就是在监视线程的中断状态，一旦线程的中断状态被置为“中断状态”，就会抛出中断异常。</p><p>&emsp;&emsp;interrupted 查询当前线程的中断状态，并且清除原状态。如果一个线程被中断了，第一次调用interrupted则返回true，第二次和后面的就返回false了。</p><p>&emsp;&emsp;isInterrupted 仅仅是查询当前线程的中断状态</p></blockquote><blockquote><p><strong>16. 什么是Callable和Future?</strong></p><p>&emsp;&emsp;Callable接口类似于Runnable，从名字就可以看出来了，但是Runnable不会返回结果，并且无法抛出返回结果的异常，而Callable功能更强大一些，被线程执行后，可以返回值，这个返回值可以被Future拿到，也就是说，Future可以拿到异步执行任务的返回值。可以认为是带有回调的Runnable。</p><p>&emsp;&emsp;Future接口表示异步任务，是还没有完成的任务给出的未来结果。所以说Callable用于产生结果，Future用于获取结果。</p></blockquote><blockquote><p><strong>17. java中有几种方法可以实现一个线程？</strong></p><p>&emsp;&emsp;•    继承 Thread 类</p><p>&emsp;&emsp;•    实现 Runnable 接口</p><p>&emsp;&emsp;•    实现 Callable 接口 + FutureTask，需要实现的是 call() 方法</p><p>&emsp;&emsp;•    线程池</p></blockquote><blockquote><p><strong>18. 为什么在Java中不推荐使用线程组？</strong></p><p>&emsp;&emsp;在<strong>未捕获异常的处理器</strong>章节有提到现在不推荐使用线程组，因为有更好的<strong>线程池</strong>，线程组自己不是线程安全的，且其stop等方法会造成死锁等安全问题。前者是为了方便线程的管理，后者是为了管理线程的生命周期，复用线程，减少创建销毁线程的开销。</p><p>&emsp;&emsp;创建线程要花费昂贵的资源和时间，如果任务来了才创建线程那么响应时间会变长，而且一个进程能创建的线程数有限。为了避免这些问题，在程序启动的时候就创建若干线程来响应处理，它们被称为线程池，里面的线程叫工作线程。从JDK1.5开始，Java API提供了Executor框架让你可以创建不同的线程池。</p></blockquote><blockquote><p><strong>19. 如何停止一个正在运行的线程？</strong></p><p>&emsp;&emsp;•    使用共享变量的方式，在这种方式中，之所以引入共享变量，是因为该变量可以被多个执行相同任务的线程用来作为是否中断的信号，通知中断线程的执行。</p><p>&emsp;&emsp;•    使用interrupt方法终止线程，如果一个线程由于等待某些事件的发生而被阻塞，又该怎样停止该线程呢？这种情况经常会发生，比如当一个线程由于需要等候键盘输入而被阻塞，或者调用Thread.join()方法，或者Thread.sleep()方法，在网络中调用ServerSocket.accept()方法，或者调用了DatagramSocket.receive()方法时，都有可能导致线程阻塞，使线程处于处于不可运行状态时，即使主程序中将该线程的共享变量设置为true，但该线程此时根本无法检查循环标志，当然也就无法立即中断。这里我们给出的建议是，不要使用stop()方法，而是使用Thread提供的interrupt()方法，因为该方法虽然不会中断一个正在运行的线程，但是它可以使一个被阻塞的线程抛出一个中断异常，从而使线程提前结束阻塞状态，退出堵塞代码。</p></blockquote><blockquote><p><strong>20. 什么是Executors框架？</strong></p><p>&emsp;&emsp;Executor框架是一个根据一组执行策略调用，调度，执行和控制的异步任务的框架。无限制的创建线程会引起应用程序内存溢出。所以创建一个线程池是个更好的的解决方案，因为可以限制线程的数量并且可以回收再利用这些线程。利用Executors框架可以非常方便的创建一个线程池。</p><p><strong>21. 为什么要使用Executor线程池框架 ？</strong></p><ol><li>每次执行任务创建线程 new Thread()比较消耗性能，创建一个线程是比较耗时、耗资源的。 </li><li>调用 new Thread()创建的线程缺乏管理，被称为野线程，而且可以无限制的创建，线程之间的相互竞争会导致过多占用系统资源而导致系统瘫痪，还有线程之间的频繁交替也会消耗很多系统资源。 </li><li>直接使用new Thread() 启动的线程不利于扩展，比如定时执行、定期执行、定时定期执行、线程中断等都不便实现。</li></ol><p><strong>22. 使用Executor线程池框架的优点？</strong></p><ol><li>能复用已存在并空闲的线程从而减少线程对象的创建从而减少了消亡线程的开销。 </li><li>可有效控制最大并发线程数，提高系统资源使用率，同时避免过多资源竞争。 </li><li>框架中已经有定时、定期、单线程、并发数控制等功能。 </li></ol><p>&emsp;&emsp;Executors 工具类的不同方法按照我们的需求创建了不同的线程池，来满足业务的需求。</p><p>&emsp;&emsp;Executor 接口对象能执行我们的线程任务。</p><p>&emsp;&emsp;ExecutorService接口继承了Executor接口并进行了扩展，提供了更多的方法我们能获得任务执行的状态并且可以获取任务的返回值。</p><p>&emsp;&emsp;使用ThreadPoolExecutor 可以创建自定义线程池。</p><p>&emsp;&emsp;Future 表示异步计算的结果，他提供了检查计算是否完成的方法，以等待计算的完成，并可以使用get()方法获取计算的结果。</p><p>&emsp;&emsp; 综上所述使用线程池框架Executor能更好的管理线程、提供系统资源使用率。</p></blockquote><blockquote><p><strong>23. Java中用到的线程调度算法是什么？</strong></p><p>&emsp;&emsp;采用时间片轮转的方式。可以设置线程的优先级，会映射到下层的系统上面的优先级上，如非特别需要，尽量不要用，防止线程饥饿。</p><p>&emsp;&emsp;计算机通常只有一个CPU,在任意时刻只能执行一条机器指令,每个线程只有获得CPU的使用权才能执行指令.所谓多线程的并发运行,其实是指从宏观上看,各个线程轮流获得CPU的使用权,分别执行各自的任务.在运行池中,会有多个处于就绪状态的线程在等待CPU,JAVA虚拟机的一项任务就是负责线程的调度,线程调度是指按照特定机制为多个线程分配CPU的使用权.</p><p>&emsp;&emsp;有两种调度模型：分时调度模型和抢占式调度模型。</p><p>&emsp;&emsp;分时调度模型是指让所有的线程轮流获得cpu的使用权,并且平均分配每个线程占用的CPU的时间片这个也比较好理解。</p><p>&emsp;&emsp;java虚拟机采用抢占式调度模型，是指优先让可运行池中优先级高的线程占用CPU，如果可运行池中的线程优先级相同，那么就随机选择一个线程，使其占用CPU。处于运行状态的线程会一直运行，直至它不得不放弃CPU。</p></blockquote><blockquote><p><strong>24. 什么是FutureTask?使用ExecutorService启动任务。</strong></p><p>&emsp;&emsp;在Java并发程序中FutureTask表示一个可以取消的异步运算。它有启动和取消运算、查询运算是否完成和取回运算结果等方法。只有当运算完成的时候结果才能取回，如果运算尚未完成get方法将会阻塞。一个FutureTask对象可以对调用了Callable和Runnable的对象进行包装，由于FutureTask也是调用了Runnable接口所以它可以提交给Executor来执行。</p></blockquote><blockquote><p><strong>25. 什么是并发容器的实现？</strong></p><p>&emsp;&emsp;何为同步容器：可以简单地理解为通过synchronized来实现同步的容器，如果有多个线程调用同步容器的方法，它们将会串行执行。比如Vector，Hashtable，以及Collections.synchronizedSet，synchronizedList等方法返回的容器。</p><p>&emsp;&emsp;可以通过查看Vector，Hashtable等这些同步容器的实现代码，可以看到这些容器实现线程安全的方式就是将它们的状态封装起来，并在需要同步的方法上加上关键字synchronized。</p><p>&emsp;&emsp;并发容器使用了与同步容器完全不同的加锁策略来提供更高的并发性和伸缩性，例如在ConcurrentHashMap中采用了一种粒度更细的加锁机制，可以称为分段锁，在这种锁机制下，允许任意数量的读线程并发地访问map，并且执行读操作的线程和写操作的线程也可以并发的访问map，同时允许一定数量的写操作线程并发地修改map，所以它可以在并发环境下实现更高的吞吐量。</p></blockquote><blockquote><p><strong>26. 多线程同步和互斥有几种实现方法，都是什么？</strong></p><p>&emsp;&emsp;线程同步是指线程之间所具有的一种制约关系，一个线程的执行依赖另一个线程的消息，当它没有得到另一个线程的消息时应等待，直到消息到达时才被唤醒。</p><p>&emsp;&emsp;线程互斥是指对于共享的进程系统资源，在各单个线程访问时的排它性。当有若干个线程都要使用某一共享资源时，任何时刻最多只允许一个线程去使用，其它要使用该资源的线程必须等待，直到占用资源者释放该资源。线程互斥可以看成是一种特殊的线程同步。</p><p>&emsp;&emsp;线程间的同步方法大体可分为两类：用户模式和内核模式。顾名思义，内核模式就是指利用系统内核对象的单一性来进行同步，使用时需要切换内核态与用户态，而用户模式就是不需要切换到内核态，只在用户态完成操作。<br>用户模式下的方法有：原子操作（例如一个单一的全局变量），临界区。内核模式下的方法有：事件，信号量，互斥量。</p></blockquote><blockquote><p><strong>27. 为什么代码会重排序？</strong></p><p>&emsp;&emsp;在执行程序时，为了提供性能，处理器和编译器常常会对指令进行重排序，但是不能随意重排序，不是你想怎么排序就怎么排序，它需要满足以下两个条件：</p><p>&emsp;&emsp;在单线程环境下不能改变程序运行的结果；</p><p>&emsp;&emsp;存在数据依赖关系的不允许重排序</p><p>&emsp;&emsp;需要注意的是：重排序不会影响单线程环境的执行结果，但是会破坏多线程的执行语义。</p></blockquote><blockquote><p><strong>28. 同步方法和同步块，哪个是更好的选择？</strong></p><p>&emsp;&emsp;同步块是更好的选择，因为它不会锁住整个对象（当然你也可以让它锁住整个对象）。同步方法会锁住整个对象，哪怕这个类中有多个不相关联的同步块，这通常会导致他们停止执行并需要等待获得这个对象上的锁。</p><p>&emsp;&emsp;同步块更要符合开放调用的原则，只在需要锁住的代码块锁住相应的对象，这样从侧面来说也可以避免死锁。</p></blockquote><blockquote><p><strong>29. 什么是Java Timer 类？如何创建一个有特定时间间隔的任务？</strong></p><p>&emsp;&emsp;java.util.Timer是一个工具类，可以用于安排一个线程在未来的某个特定时间执行。Timer类可以用安排一次性任务或者周期任务。</p><p>&emsp;&emsp;java.util.TimerTask是一个实现了Runnable接口的抽象类，我们需要去继承这个类来创建我们自己的定时任务并使用Timer去安排它的执行。</p><p>&emsp;&emsp;目前有开源的Qurtz可以用来创建定时任务。</p></blockquote><blockquote><p><strong>30. 为什么我们调用start()方法时会执行run()方法，为什么我们不能直接调用run()方法？</strong></p><p>&emsp;&emsp;当你调用start()方法时你将创建新的线程，并且执行在run()方法里的代码。 </p><p>&emsp;&emsp;但是如果你直接调用run()方法，它不会创建新的线程也不会执行调用线程的代码，只会把run方法当作普通方法去执行。</p></blockquote><blockquote><p><strong>31. 如何确保线程安全？</strong></p><p>&emsp;&emsp;在Java中可以有很多方法来保证线程安全——同步，使用原子类(atomic concurrent classes)，实现并发锁，使用volatile关键字，使用不变类和线程安全类。</p></blockquote><blockquote><p><strong>32. 怎么检测一个线程是否拥有锁？</strong></p><p>&emsp;&emsp;在java.lang.Thread中有一个方法叫holdsLock()，它返回true如果当且仅当当前线程拥有某个具体对象的锁。</p></blockquote><hr><p><em>参考博客和文章书籍等：</em></p><blockquote><p><a href="https://zhuanlan.zhihu.com/p/58117761" target="_blank" rel="noopener">https://zhuanlan.zhihu.com/p/58117761</a></p></blockquote><blockquote><p><a href="https://zhuanlan.zhihu.com/p/58265081" target="_blank" rel="noopener">https://zhuanlan.zhihu.com/p/58265081</a></p></blockquote><p><em>因博客主等未标明不可引用，若部分内容涉及侵权请及时告知，我会尽快修改和删除相关内容</em></p>]]></content>
    
    <summary type="html">
    
      介绍Java中的线程QA
    
    </summary>
    
      <category term="技术文档" scheme="http://linyishui.top/categories/%E6%8A%80%E6%9C%AF%E6%96%87%E6%A1%A3/"/>
    
    
      <category term="java" scheme="http://linyishui.top/tags/java/"/>
    
  </entry>
  
  <entry>
    <title>并发和同步</title>
    <link href="http://linyishui.top/2019051401.html"/>
    <id>http://linyishui.top/2019051401.html</id>
    <published>2019-05-14T02:21:23.000Z</published>
    <updated>2019-05-22T03:12:04.000Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><hr><h2 id="并发编程的三个问题"><a href="#并发编程的三个问题" class="headerlink" title="并发编程的三个问题"></a><strong>并发编程的三个问题</strong></h2><ul><li>原子性</li><li>可见性</li><li>有序性</li></ul><p>&emsp;&emsp;原子性：即一个或多个操作，要么全部执行，要么全不执行。保证一系列操作的原子性，要么加锁，要么通过CAS即实现乐观锁的方法，在修改时比较此时数据是否和之前读的时候一致。</p><p>&emsp;&emsp;可见性：多个线程访问同一个变量时，一个线程修改了此变量，其他线程也能立即看到最新的值。</p><p>&emsp;&emsp;有序性：即程序执行的顺序按代码的先后顺序，JVM执行代码时可能会因为指令重排序导致执行顺序和代码顺序不一致，但JVM会保证最终结果一致，JVM会让指令依赖的上一条指令先执行，而不会在上条执行前执行依赖于其的指令。但多线程时可能会有问题，某一指令并不依赖于任何指令，但其执行顺序如果和编程者所安排的不一致，可能会导致逻辑错误，在不该执行的时候执行，不该终止的时候终止。</p><hr><h1 id="同步"><a href="#同步" class="headerlink" title="同步"></a><strong>同步</strong></h1><p>&emsp;&emsp;在实际应用场景中，多个线程往往需要共享同一数据的存取，当多个线程都有对数据进行修改就会导致数据异常，这种情况叫<strong>竞争条件</strong>(race condition)。</p><p><em>以下测试代码来自corejava源代码</em></p><p>&emsp;&emsp;实现一个银行类来存储账户集合，并通过多线程不断进行存取金额，若运行正确，总金额应该一直保持不变。</p><figure class="highlight cs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">Bank</span></span><br><span class="line">&#123;</span><br><span class="line">   <span class="keyword">private</span> final <span class="keyword">double</span>[] accounts;</span><br><span class="line"></span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="title">Bank</span>(<span class="params"><span class="keyword">int</span> n, <span class="keyword">double</span> initialBalance</span>)</span></span><br><span class="line"><span class="function">   </span>&#123;</span><br><span class="line">      accounts = <span class="keyword">new</span> <span class="keyword">double</span>[n];</span><br><span class="line">      Arrays.fill(accounts, initialBalance);</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">transfer</span>(<span class="params"><span class="keyword">int</span> <span class="keyword">from</span>, <span class="keyword">int</span> to, <span class="keyword">double</span> amount</span>)</span></span><br><span class="line"><span class="function">   </span>&#123;</span><br><span class="line">      <span class="keyword">if</span> (accounts[<span class="keyword">from</span>] &lt; amount) <span class="keyword">return</span>;</span><br><span class="line">      System.<span class="keyword">out</span>.print(Thread.currentThread());</span><br><span class="line">      accounts[<span class="keyword">from</span>] -= amount;</span><br><span class="line">      System.<span class="keyword">out</span>.printf(<span class="string">" %10.2f from %d to %d"</span>, amount, <span class="keyword">from</span>, to);</span><br><span class="line">      accounts[to] += amount;</span><br><span class="line">      System.<span class="keyword">out</span>.printf(<span class="string">" Total Balance: %10.2f%n"</span>, getTotalBalance());</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">double</span> <span class="title">getTotalBalance</span>(<span class="params"></span>)</span></span><br><span class="line"><span class="function">   </span>&#123;</span><br><span class="line">      <span class="keyword">double</span> sum = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">      <span class="keyword">for</span> (<span class="keyword">double</span> a : accounts)</span><br><span class="line">         sum += a;</span><br><span class="line"></span><br><span class="line">      <span class="keyword">return</span> sum;</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">size</span>(<span class="params"></span>)</span></span><br><span class="line"><span class="function">   </span>&#123;</span><br><span class="line">      <span class="keyword">return</span> accounts.length;</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">UnsynchBankTest</span></span><br><span class="line">&#123;</span><br><span class="line">   <span class="keyword">public</span> <span class="keyword">static</span> final <span class="keyword">int</span> NACCOUNTS = <span class="number">100</span>;</span><br><span class="line">   <span class="keyword">public</span> <span class="keyword">static</span> final <span class="keyword">double</span> INITIAL_BALANCE = <span class="number">1000</span>;</span><br><span class="line">   <span class="keyword">public</span> <span class="keyword">static</span> final <span class="keyword">double</span> MAX_AMOUNT = <span class="number">1000</span>;</span><br><span class="line">   <span class="keyword">public</span> <span class="keyword">static</span> final <span class="keyword">int</span> DELAY = <span class="number">10</span>;</span><br><span class="line">   </span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span>(<span class="params">String[] args</span>)</span></span><br><span class="line"><span class="function">   </span>&#123;</span><br><span class="line">      Bank bank = <span class="keyword">new</span> Bank(NACCOUNTS, INITIAL_BALANCE);</span><br><span class="line">      <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; NACCOUNTS; i++)</span><br><span class="line">      &#123;</span><br><span class="line">         <span class="keyword">int</span> fromAccount = i;</span><br><span class="line">         Runnable r = () -&gt; &#123;</span><br><span class="line">            <span class="keyword">try</span></span><br><span class="line">            &#123;</span><br><span class="line">               <span class="keyword">while</span> (<span class="literal">true</span>)</span><br><span class="line">               &#123;</span><br><span class="line">                  <span class="keyword">int</span> toAccount = (<span class="keyword">int</span>) (bank.size() * Math.random());</span><br><span class="line">                  <span class="keyword">double</span> amount = MAX_AMOUNT * Math.random();</span><br><span class="line">                  bank.transfer(fromAccount, toAccount, amount);</span><br><span class="line">                  Thread.sleep((<span class="keyword">int</span>) (DELAY * Math.random()));</span><br><span class="line">               &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">catch</span> (InterruptedException e)</span><br><span class="line">            &#123;</span><br><span class="line">            &#125;            </span><br><span class="line">         &#125;;</span><br><span class="line">         Thread t = <span class="keyword">new</span> Thread(r);</span><br><span class="line">         t.start();</span><br><span class="line">      &#125;</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>&emsp;&emsp;运行结果。</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">...</span><br><span class="line"><span class="selector-tag">Thread</span><span class="selector-attr">[Thread-23,5,main]</span>     148<span class="selector-class">.04</span> <span class="selector-tag">from</span> 23 <span class="selector-tag">to</span> 78 <span class="selector-tag">Total</span> <span class="selector-tag">Balance</span>:  100000<span class="selector-class">.00</span></span><br><span class="line"><span class="selector-tag">Thread</span><span class="selector-attr">[Thread-50,5,main]</span>     584<span class="selector-class">.19</span> <span class="selector-tag">from</span> 50 <span class="selector-tag">to</span> 22 <span class="selector-tag">Total</span> <span class="selector-tag">Balance</span>:  100000<span class="selector-class">.00</span></span><br><span class="line"><span class="selector-tag">Thread</span><span class="selector-attr">[Thread-84,5,main]</span>     250<span class="selector-class">.77</span> <span class="selector-tag">from</span> 84 <span class="selector-tag">to</span> 12 <span class="selector-tag">Total</span> <span class="selector-tag">Balance</span>:  100000<span class="selector-class">.00</span></span><br><span class="line"><span class="selector-tag">Thread</span><span class="selector-attr">[Thread-59,5,main]</span>     664<span class="selector-class">.33</span> <span class="selector-tag">from</span> 59 <span class="selector-tag">to</span> 32<span class="selector-tag">Thread</span><span class="selector-attr">[Thread-2,5,main]</span>     723<span class="selector-class">.99</span> <span class="selector-tag">from</span> 2 <span class="selector-tag">to</span> 4 <span class="selector-tag">Total</span> <span class="selector-tag">Balance</span>:   99335<span class="selector-class">.67</span></span><br><span class="line"><span class="selector-tag">Thread</span><span class="selector-attr">[Thread-27,5,main]</span>     606<span class="selector-class">.12</span> <span class="selector-tag">from</span> 27 <span class="selector-tag">to</span> 25 <span class="selector-tag">Total</span> <span class="selector-tag">Balance</span>:   99335<span class="selector-class">.67</span></span><br><span class="line"><span class="selector-tag">Thread</span><span class="selector-attr">[Thread-5,5,main]</span>     647<span class="selector-class">.61</span> <span class="selector-tag">from</span> 5 <span class="selector-tag">to</span> 76 <span class="selector-tag">Total</span> <span class="selector-tag">Balance</span>:   99335<span class="selector-class">.67</span></span><br><span class="line">...</span><br></pre></td></tr></table></figure><p>&emsp;&emsp;为何总金额会有异常状态呢？</p><p>&emsp;&emsp;回顾上面所谈到的概念：并发特性。</p><p>&emsp;&emsp;测试例子中对于账户的更新操作是：</p><figure class="highlight accesslog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">accounts<span class="string">[from]</span> -= amount;</span><br><span class="line">accounts<span class="string">[to]</span> += amount;</span><br></pre></td></tr></table></figure><p>&emsp;&emsp;此指令并非一个原子操作，可以被分解为：1.将accounts[to]加载到寄存器。2.增加amount。3.将结果写回accounts[to]。</p><p>&emsp;&emsp;假设有线程1和2同时执行此指令，线程1执行步骤1和2，然后被剥离运行状态，线程2被唤醒并执行了这一系列指令，然后切换线程1执行完步骤3。所以线程1返回的结果会覆盖掉线程2的操作，导致最终金额不匹配</p><p>&emsp;&emsp;为了避免这种情况，保证线程安全，需要满足并发特性，所以就有了<a href="../2019032902.html" title="Title">锁机制</a>。</p>]]></content>
    
    <summary type="html">
    
      介绍Java中的并发和同步
    
    </summary>
    
      <category term="技术文档" scheme="http://linyishui.top/categories/%E6%8A%80%E6%9C%AF%E6%96%87%E6%A1%A3/"/>
    
    
      <category term="java" scheme="http://linyishui.top/tags/java/"/>
    
      <category term="thread" scheme="http://linyishui.top/tags/thread/"/>
    
  </entry>
  
  <entry>
    <title>Thread类源码剖析</title>
    <link href="http://linyishui.top/2019051301.html"/>
    <id>http://linyishui.top/2019051301.html</id>
    <published>2019-05-13T10:18:15.000Z</published>
    <updated>2019-05-22T03:11:56.000Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="类体"><a href="#类体" class="headerlink" title="类体"></a><strong>类体</strong></h1><figure class="highlight actionscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Thread</span> <span class="keyword">implements</span> <span class="title">Runnable</span> </span>&#123;<span class="comment">//实现Runnable接口</span></span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><h1 id="属性和静态域"><a href="#属性和静态域" class="headerlink" title="属性和静态域"></a><strong>属性和静态域</strong></h1><figure class="highlight aspectj"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">native</span> <span class="function"><span class="keyword">void</span> <span class="title">registerNatives</span><span class="params">()</span></span>;<span class="comment">//私有静态native方法，实现方法命名的解耦</span></span><br><span class="line"><span class="keyword">static</span> &#123;</span><br><span class="line">    registerNatives();<span class="comment">//静态块，确保创建对象前先调用registerNatives()</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">volatile</span> String name;<span class="comment">//线程名</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">int</span>            priority;<span class="comment">//线程优先级</span></span><br><span class="line"><span class="keyword">private</span> Thread         threadQ;</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">long</span>           eetop;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">boolean</span>     single_step;<span class="comment">//是否单步执行</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">boolean</span>     daemon = <span class="keyword">false</span>;<span class="comment">//是否守护线程</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">boolean</span>     stillborn = <span class="keyword">false</span>;<span class="comment">//虚拟机状态</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> Runnable <span class="keyword">target</span>;<span class="comment">//将会被执行的Runnable</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> ThreadGroup group;<span class="comment">//线程所属的线程组</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> ClassLoader contextClassLoader;<span class="comment">//线程对应的类加载器</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> AccessControlContext inheritedAccessControlContext;<span class="comment">//线程继承的访问控制环境</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">int</span> threadInitNumber;<span class="comment">//自动给匿名线程编号</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">synchronized</span> <span class="function"><span class="keyword">int</span> <span class="title">nextThreadNum</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> threadInitNumber++;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">ThreadLocal.ThreadLocalMap threadLocals = <span class="keyword">null</span>;<span class="comment">//线程对应的ThreadLocal值，此Map由ThreadLocal维护</span></span><br><span class="line"></span><br><span class="line">ThreadLocal.ThreadLocalMap inheritableThreadLocals = <span class="keyword">null</span>;<span class="comment">//线程对应的可继承ThreadLocal值，此Map由InheritableThreadLocal维护</span></span><br><span class="line"><span class="comment">//为子线程提供从父线程那里继承的值</span></span><br><span class="line"><span class="comment">//在创建子线程时，子线程会接收所有可继承的线程局部变量的初始值，以获得父线程所具有的值</span></span><br><span class="line"><span class="comment">//创建一个线程时如果保存了所有 InheritableThreadLocal 对象的值，那么这些值也将自动传递给子线程</span></span><br><span class="line"><span class="comment">//如果一个子线程调用 InheritableThreadLocal 的 get() ，那么它将与它的父线程看到同一个对象</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">long</span> stackSize;<span class="comment">//线程请求的堆栈大小，一些VM会无视</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">long</span> nativeParkEventPointer;<span class="comment">//在native线程终止后仍保持的JVM私有状态</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">long</span> tid;<span class="comment">//每个线程的唯一ID</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">long</span> threadSeqNumber;<span class="comment">//用来生成线程ID</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">volatile</span> <span class="keyword">int</span> threadStatus = <span class="number">0</span>;<span class="comment">//线程状态</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">synchronized</span> <span class="function"><span class="keyword">long</span> <span class="title">nextThreadID</span><span class="params">()</span> </span>&#123;<span class="comment">//得到下个线程的ID</span></span><br><span class="line">    <span class="keyword">return</span> ++threadSeqNumber;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">volatile</span> Object parkBlocker;<span class="comment">//中断阻塞器，当线程发生IO中断时，需要在线程中断状态后调用此对象的interrupt()</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">volatile</span> Interruptible blocker;<span class="comment">//阻塞器锁，用来处理阻塞情况</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> Object blockerLock = <span class="keyword">new</span> Object();<span class="comment">//阻断锁</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">blockedOn</span><span class="params">(Interruptible b)</span> </span>&#123;<span class="comment">//通过java.nio的sun.misc.SharedSecrets调用，设置blocker</span></span><br><span class="line">    <span class="keyword">synchronized</span> (blockerLock) &#123;</span><br><span class="line">        blocker = b;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">static</span> <span class="keyword">int</span> MIN_PRIORITY = <span class="number">1</span>;<span class="comment">//最小优先级</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">static</span> <span class="keyword">int</span> NORM_PRIORITY = <span class="number">5</span>;<span class="comment">//默认优先级</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">static</span> <span class="keyword">int</span> MAX_PRIORITY = <span class="number">10</span>;<span class="comment">//最大优先级</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> StackTraceElement[] EMPTY_STACK_TRACE</span><br><span class="line">    = <span class="keyword">new</span> StackTraceElement[<span class="number">0</span>];<span class="comment">//空堆栈跟踪元素数组</span></span><br><span class="line">    </span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> RuntimePermission SUBCLASS_IMPLEMENTATION_PERMISSION =</span><br><span class="line">                <span class="keyword">new</span> RuntimePermission(<span class="string">"enableContextClassLoaderOverride"</span>);</span><br></pre></td></tr></table></figure><hr><h1 id="构造函数"><a href="#构造函数" class="headerlink" title="构造函数"></a><strong>构造函数</strong></h1><figure class="highlight lasso"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">Thread</span>() &#123;<span class="comment">//默认构造器</span></span><br><span class="line">       init(<span class="built_in">null</span>, <span class="built_in">null</span>, <span class="string">"Thread-"</span> + nextThreadNum(), <span class="number">0</span>);</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="keyword">public</span> <span class="keyword">Thread</span>(Runnable target) &#123;</span><br><span class="line">       init(<span class="built_in">null</span>, target, <span class="string">"Thread-"</span> + nextThreadNum(), <span class="number">0</span>);</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="keyword">Thread</span>(Runnable target, AccessControlContext acc) &#123;</span><br><span class="line">       init(<span class="built_in">null</span>, target, <span class="string">"Thread-"</span> + nextThreadNum(), <span class="number">0</span>, acc, <span class="literal">false</span>);</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="keyword">public</span> <span class="keyword">Thread</span>(ThreadGroup <span class="keyword">group</span>, Runnable target) &#123;</span><br><span class="line">       init(<span class="keyword">group</span>, target, <span class="string">"Thread-"</span> + nextThreadNum(), <span class="number">0</span>);</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="keyword">public</span> <span class="keyword">Thread</span>(<span class="built_in">String</span> name) &#123;</span><br><span class="line">       init(<span class="built_in">null</span>, <span class="built_in">null</span>, name, <span class="number">0</span>);</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="keyword">public</span> <span class="keyword">Thread</span>(ThreadGroup <span class="keyword">group</span>, <span class="built_in">String</span> name) &#123;</span><br><span class="line">       init(<span class="keyword">group</span>, <span class="built_in">null</span>, name, <span class="number">0</span>);</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="keyword">public</span> <span class="keyword">Thread</span>(Runnable target, <span class="built_in">String</span> name) &#123;</span><br><span class="line">       init(<span class="built_in">null</span>, target, name, <span class="number">0</span>);</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="keyword">public</span> <span class="keyword">Thread</span>(ThreadGroup <span class="keyword">group</span>, Runnable target, <span class="built_in">String</span> name) &#123;</span><br><span class="line">       init(<span class="keyword">group</span>, target, name, <span class="number">0</span>);</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="keyword">public</span> <span class="keyword">Thread</span>(ThreadGroup <span class="keyword">group</span>, Runnable target, <span class="built_in">String</span> name,</span><br><span class="line">                 long stackSize) &#123;</span><br><span class="line">       init(<span class="keyword">group</span>, target, name, stackSize);</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure><hr><h1 id="native函数"><a href="#native函数" class="headerlink" title="native函数"></a><strong>native函数</strong></h1><figure class="highlight aspectj"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">native</span> <span class="function">Thread <span class="title">currentThread</span><span class="params">()</span></span>;<span class="comment">//返回当前正在执行的线程对象的引用</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">native</span> <span class="function"><span class="keyword">void</span> <span class="title">yield</span><span class="params">()</span></span>;<span class="comment">//可以向调度程序提示当前程序可以让出对处理器的使用，调度器可以忽略此提示。</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//使当前线程从执行状态（运行状态）变为可执行态（就绪状态）。cpu会从众多的可执行态里选择，也就是说，当前也就是刚刚的那个线程还是有可能会被再次执行到的，并不是说一定会执行其他线程而该线程在下一次中不会执行到了</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">native</span> <span class="function"><span class="keyword">void</span> <span class="title">sleep</span><span class="params">(<span class="keyword">long</span> millis)</span> <span class="keyword">throws</span> InterruptedException</span>;<span class="comment">//使当前线程休眠一定时间</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">native</span> <span class="function"><span class="keyword">void</span> <span class="title">start0</span><span class="params">()</span></span>;<span class="comment">//native启动线程</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">native</span> <span class="function"><span class="keyword">boolean</span> <span class="title">isInterrupted</span><span class="params">(<span class="keyword">boolean</span> ClearInterrupted)</span></span>;<span class="comment">//判断是否有线程被中断</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">native</span> <span class="function"><span class="keyword">boolean</span> <span class="title">isAlive</span><span class="params">()</span></span>;<span class="comment">//判断此线程是否alive，只要已启动并且未死亡即存活。</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">native</span> <span class="function"><span class="keyword">boolean</span> <span class="title">holdsLock</span><span class="params">(Object obj)</span></span>;<span class="comment">//仅当当前线程在指定的对象上持有monitor lock时返回true</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">native</span> <span class="keyword">static</span> StackTraceElement[][] dumpThreads(Thread[] threads);</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">native</span> <span class="keyword">static</span> Thread[] getThreads();</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">native</span> <span class="function"><span class="keyword">void</span> <span class="title">setPriority0</span><span class="params">(<span class="keyword">int</span> newPriority)</span></span>;<span class="comment">//设置线程优先级</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">native</span> <span class="function"><span class="keyword">void</span> <span class="title">stop0</span><span class="params">(Object o)</span></span>;<span class="comment">//停止线程</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">native</span> <span class="function"><span class="keyword">void</span> <span class="title">suspend0</span><span class="params">()</span></span>;<span class="comment">// 线程挂起(暂停)</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">native</span> <span class="function"><span class="keyword">void</span> <span class="title">resume0</span><span class="params">()</span></span>;<span class="comment">//将一个挂起线程复活继续执行</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">native</span> <span class="function"><span class="keyword">void</span> <span class="title">interrupt0</span><span class="params">()</span></span>;<span class="comment">//该线程的中断状态将被设置</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">native</span> <span class="function"><span class="keyword">void</span> <span class="title">setNativeName</span><span class="params">(String name)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Deprecated</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">native</span> <span class="function"><span class="keyword">int</span> <span class="title">countStackFrames</span><span class="params">()</span></span>;<span class="comment">//弃用</span></span><br></pre></td></tr></table></figure><hr><h1 id="普通函数"><a href="#普通函数" class="headerlink" title="普通函数"></a><strong>普通函数</strong></h1><h2 id="常用"><a href="#常用" class="headerlink" title="常用"></a><strong>常用</strong></h2><h3 id="init"><a href="#init" class="headerlink" title="init()"></a><strong>init()</strong></h3><figure class="highlight aspectj"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="function"><span class="keyword">void</span> <span class="title">init</span><span class="params">(ThreadGroup g, Runnable <span class="keyword">target</span>, String name, <span class="keyword">long</span> stackSize)</span> </span>&#123;<span class="comment">//用AccessControlContext初始化一个线程</span></span><br><span class="line">    init(g, <span class="keyword">target</span>, name, stackSize, <span class="keyword">null</span>, <span class="keyword">true</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 线程初始化.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> g 线程组</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> target Runnable接口目标对象提供run()</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> name 线程名</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> stackSize 所需堆栈大小</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> acc AccessControlContext</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> inheritThreadLocals 若为真则继承thread-locals的初始值</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">void</span> init(ThreadGroup g, Runnable <span class="keyword">target</span>, String name,</span><br><span class="line">                  <span class="keyword">long</span> stackSize, AccessControlContext acc,</span><br><span class="line">                  <span class="keyword">boolean</span> inheritThreadLocals) &#123;</span><br><span class="line">    <span class="keyword">if</span> (name == <span class="keyword">null</span>) &#123;<span class="comment">//线程name不允许为null</span></span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> NullPointerException(<span class="string">"name cannot be null"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">this</span>.name = name;</span><br><span class="line"></span><br><span class="line">    Thread parent = currentThread();<span class="comment">//获取当前线程</span></span><br><span class="line">    SecurityManager security = System.getSecurityManager();<span class="comment">//获取系统的安全管理器SecurityManager</span></span><br><span class="line">    <span class="keyword">if</span> (g == <span class="keyword">null</span>) &#123;<span class="comment">//若线程组为空</span></span><br><span class="line">        <span class="keyword">if</span> (security != <span class="keyword">null</span>) &#123;<span class="comment">//且SecurityManager不为空，则根据SecurityManager获取线程组</span></span><br><span class="line">            g = security.getThreadGroup();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (g == <span class="keyword">null</span>) &#123;<span class="comment">//若SecurityManager也没取到线程组，则直接继承当前线程的线程组</span></span><br><span class="line">            g = parent.getThreadGroup();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    g.checkAccess();<span class="comment">//一定要检查访问权限</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (security != <span class="keyword">null</span>) &#123;<span class="comment">//SecurityManager不为空时，检查是否有必要的权限</span></span><br><span class="line">        <span class="keyword">if</span> (isCCLOverridden(getClass())) &#123;</span><br><span class="line">            security.checkPermission(SUBCLASS_IMPLEMENTATION_PERMISSION);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    g.addUnstarted();<span class="comment">//增加线程组的未启动线程计数</span></span><br><span class="line">    <span class="comment">//未启动的线程不会添加到线程组中，以便在从不启动的情况下可以收集这些线程，但必须对它们进行计数，以便不会破坏其中包含未启动线程的守护进程线程组。</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">//初始化成员属性</span></span><br><span class="line">    <span class="comment">//每个线程都有一个优先级，高优先级线程的执行优先于低优先级线程。</span></span><br><span class="line">    <span class="comment">//每个线程都可以或不可以标记为一个守护程序。</span></span><br><span class="line">    <span class="comment">//当某个线程中运行的代码创建一个新 Thread 对象时，该新线程的初始优先级被设定为创建线程的优先级，</span></span><br><span class="line">    <span class="comment">//并且当且仅当创建线程是守护线程时，新线程才是守护程序</span></span><br><span class="line">    <span class="keyword">this</span>.group = g;</span><br><span class="line">    <span class="keyword">this</span>.daemon = parent.isDaemon();</span><br><span class="line">    <span class="keyword">this</span>.priority = parent.getPriority();</span><br><span class="line">    <span class="keyword">if</span> (security == <span class="keyword">null</span> || isCCLOverridden(parent.getClass()))</span><br><span class="line">        <span class="keyword">this</span>.contextClassLoader = parent.getContextClassLoader();</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        <span class="keyword">this</span>.contextClassLoader = parent.contextClassLoader;</span><br><span class="line">    <span class="keyword">this</span>.inheritedAccessControlContext =</span><br><span class="line">            acc != <span class="keyword">null</span> ? acc : AccessController.getContext();</span><br><span class="line">    <span class="keyword">this</span>.<span class="keyword">target</span> = <span class="keyword">target</span>;</span><br><span class="line">    setPriority(priority);</span><br><span class="line">    <span class="keyword">if</span> (inheritThreadLocals &amp;&amp; parent.inheritableThreadLocals != <span class="keyword">null</span>)</span><br><span class="line">        <span class="keyword">this</span>.inheritableThreadLocals =</span><br><span class="line">            ThreadLocal.createInheritedMap(parent.inheritableThreadLocals);</span><br><span class="line">    <span class="keyword">this</span>.stackSize = stackSize;</span><br><span class="line">    tid = nextThreadID();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><h3 id="join"><a href="#join" class="headerlink" title="join()"></a><strong>join()</strong></h3><p>&emsp;&emsp;在中断状态被置位时调用sleep()方法并不会使线程休眠，反而会清除此状态并抛出InterruptedException，若在如上循环中加入sleep()，则没有必要用isInterrupted()，因为不会检测中断状态。</p><figure class="highlight processing"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//线程不会失去监视器的所有权</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> sleep(<span class="keyword">long</span> <span class="built_in">millis</span>, <span class="built_in">int</span> nanos) <span class="keyword">throws</span> InterruptedException &#123;<span class="comment">//使当前线程休眠一定时间，millis为毫秒，nanos为纳秒</span></span><br><span class="line">    <span class="comment">//参数检查</span></span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">millis</span> &lt; <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(<span class="string">"timeout value is negative"</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (nanos &lt; <span class="number">0</span> || nanos &gt; <span class="number">999999</span>) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(</span><br><span class="line">                            <span class="string">"nanosecond timeout value out of range"</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//纳秒会按规则进到毫秒</span></span><br><span class="line">    <span class="keyword">if</span> (nanos &gt;= <span class="number">500000</span> || (nanos != <span class="number">0</span> &amp;&amp; <span class="built_in">millis</span> == <span class="number">0</span>)) &#123;</span><br><span class="line">        <span class="built_in">millis</span>++;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    sleep(<span class="built_in">millis</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 最多等待给定毫秒，有可能线程死亡，当参数为0表示永远等待</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="built_in">join</span>(<span class="keyword">long</span> <span class="built_in">millis</span>)</span><br><span class="line"><span class="keyword">throws</span> InterruptedException &#123;</span><br><span class="line">    <span class="keyword">long</span> base = System.currentTimeMillis();</span><br><span class="line">    <span class="keyword">long</span> now = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">millis</span> &lt; <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(<span class="string">"timeout value is negative"</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">millis</span> == <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">while</span> (isAlive()) &#123;<span class="comment">//当给定0，且线程存活，则一直调用wait(0)一直等待</span></span><br><span class="line">            wait(<span class="number">0</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">while</span> (isAlive()) &#123;<span class="comment">//线程存活，等待给定时间，直到到底时间或线程死亡</span></span><br><span class="line">            <span class="keyword">long</span> delay = <span class="built_in">millis</span> - now;</span><br><span class="line">            <span class="keyword">if</span> (delay &lt;= <span class="number">0</span>) &#123;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            wait(delay);</span><br><span class="line">            now = System.currentTimeMillis() - base;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 使当前线程休眠一定时间</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="built_in">join</span>(<span class="keyword">long</span> <span class="built_in">millis</span>, <span class="built_in">int</span> nanos)</span><br><span class="line"><span class="keyword">throws</span> InterruptedException &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">millis</span> &lt; <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(<span class="string">"timeout value is negative"</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (nanos &lt; <span class="number">0</span> || nanos &gt; <span class="number">999999</span>) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(</span><br><span class="line">                            <span class="string">"nanosecond timeout value out of range"</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (nanos &gt;= <span class="number">500000</span> || (nanos != <span class="number">0</span> &amp;&amp; <span class="built_in">millis</span> == <span class="number">0</span>)) &#123;</span><br><span class="line">        <span class="built_in">millis</span>++;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">join</span>(<span class="built_in">millis</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 当前线程一直休眠，直到死亡</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="built_in">join</span>() <span class="keyword">throws</span> InterruptedException &#123;</span><br><span class="line">    <span class="built_in">join</span>(<span class="number">0</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><h3 id="start-和run"><a href="#start-和run" class="headerlink" title="start()和run()"></a><strong>start()和run()</strong></h3><figure class="highlight aspectj"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="function"><span class="keyword">void</span> <span class="title">start</span><span class="params">()</span> </span>&#123;<span class="comment">//使线程进入可执行状态，告知线程管理器此线程已准备完毕，等待被调用run()</span></span><br><span class="line">    <span class="keyword">if</span> (threadStatus != <span class="number">0</span>)<span class="comment">//检查线程状态</span></span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> IllegalThreadStateException();</span><br><span class="line"></span><br><span class="line">    group.add(<span class="keyword">this</span>);<span class="comment">//告知线程组此线程准备启动，将线程加到线程组中</span></span><br><span class="line">    <span class="keyword">boolean</span> started = <span class="keyword">false</span>;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        start0();<span class="comment">//预启动线程</span></span><br><span class="line">        started = <span class="keyword">true</span>;<span class="comment">//标识已启动</span></span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">if</span> (!started) &#123;<span class="comment">//start0()执行失败</span></span><br><span class="line">                group.threadStartFailed(<span class="keyword">this</span>);<span class="comment">//线程组做相应处理</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Throwable ignore) &#123;</span><br><span class="line">            <span class="comment">/* do nothing. If start0 threw a Throwable then</span></span><br><span class="line"><span class="comment">              it will be passed up the call stack */</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">public</span> <span class="function"><span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;<span class="comment">//若线程由Runnable对象构造，则调用对应run()，否则什么都不做，继承Thread时应该重写此方法。</span></span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">target</span> != <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">target</span>.run();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><h3 id="Interrupt"><a href="#Interrupt" class="headerlink" title="Interrupt"></a><strong>Interrupt</strong></h3><figure class="highlight aspectj"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 中断线程</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * 若此线程在调用&#123;Object.wait(),join(),sleep()&#125;方法时被阻塞，则其中断状态会被清除，并抛出异常InterruptedException.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * 若线程在执行基于&#123;java.nio.channels.InterruptibleChannel&#125;上的IO操作时被阻塞，则此通道Channel会被关闭，设置线程的中断状态，线程会收到异常&#123;java.nio.channels.ClosedByInterruptException&#125;</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * 若线程在选择器&#123;<span class="doctag">@link</span> java.nio.channels.Selector&#125;阻塞，则设置线程的中断状态，并立即从选择操作返回，可能会带有非零值，就像调用了&#123;java.nio.channels.Selector#wakeup wakeup&#125;方法一样。</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * 非以上情况，设置线程的中断状态，中断一个非alive线程没有任何效果</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="function"><span class="keyword">void</span> <span class="title">interrupt</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">this</span> != Thread.currentThread())<span class="comment">//若线程不是在中断自己，则需要检查权限</span></span><br><span class="line">        checkAccess();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">synchronized</span> (blockerLock) &#123;</span><br><span class="line">        Interruptible b = blocker;</span><br><span class="line">        <span class="keyword">if</span> (b != <span class="keyword">null</span>) &#123;</span><br><span class="line">            interrupt0();           <span class="comment">//只是设置中断标志</span></span><br><span class="line">            b.interrupt(<span class="keyword">this</span>);</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    interrupt0();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 测试当前线程(current thread)是否已中断</span></span><br><span class="line"><span class="comment"> * </span></span><br><span class="line"><span class="comment"> * 此方法会清除线程的中断状态，也就意味着若无间断的连续两次调用此方法，第二次调用就会返回false</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="function"><span class="keyword">boolean</span> <span class="title">interrupted</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> currentThread().isInterrupted(<span class="keyword">true</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 测试此线程(this thread)是否已中断，不改变线程的中断状态</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="function"><span class="keyword">boolean</span> <span class="title">isInterrupted</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">return</span> <span class="title">isInterrupted</span><span class="params">(<span class="keyword">false</span>)</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="其他"><a href="#其他" class="headerlink" title="其他"></a><strong>其他</strong></h2><figure class="highlight gradle"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br><span class="line">220</span><br><span class="line">221</span><br><span class="line">222</span><br><span class="line">223</span><br><span class="line">224</span><br><span class="line">225</span><br><span class="line">226</span><br><span class="line">227</span><br><span class="line">228</span><br><span class="line">229</span><br><span class="line">230</span><br><span class="line">231</span><br><span class="line">232</span><br><span class="line">233</span><br><span class="line">234</span><br><span class="line">235</span><br><span class="line">236</span><br><span class="line">237</span><br><span class="line">238</span><br><span class="line">239</span><br><span class="line">240</span><br><span class="line">241</span><br><span class="line">242</span><br><span class="line">243</span><br><span class="line">244</span><br><span class="line">245</span><br><span class="line">246</span><br><span class="line">247</span><br><span class="line">248</span><br><span class="line">249</span><br><span class="line">250</span><br><span class="line">251</span><br><span class="line">252</span><br><span class="line">253</span><br><span class="line">254</span><br><span class="line">255</span><br><span class="line">256</span><br><span class="line">257</span><br><span class="line">258</span><br><span class="line">259</span><br><span class="line">260</span><br><span class="line">261</span><br><span class="line">262</span><br><span class="line">263</span><br><span class="line">264</span><br><span class="line">265</span><br><span class="line">266</span><br><span class="line">267</span><br><span class="line">268</span><br><span class="line">269</span><br><span class="line">270</span><br><span class="line">271</span><br><span class="line">272</span><br><span class="line">273</span><br><span class="line">274</span><br><span class="line">275</span><br><span class="line">276</span><br><span class="line">277</span><br><span class="line">278</span><br><span class="line">279</span><br><span class="line">280</span><br><span class="line">281</span><br><span class="line">282</span><br><span class="line">283</span><br><span class="line">284</span><br><span class="line">285</span><br><span class="line">286</span><br><span class="line">287</span><br><span class="line">288</span><br><span class="line">289</span><br><span class="line">290</span><br><span class="line">291</span><br><span class="line">292</span><br><span class="line">293</span><br><span class="line">294</span><br><span class="line">295</span><br><span class="line">296</span><br><span class="line">297</span><br><span class="line">298</span><br><span class="line">299</span><br><span class="line">300</span><br><span class="line">301</span><br><span class="line">302</span><br><span class="line">303</span><br><span class="line">304</span><br><span class="line">305</span><br><span class="line">306</span><br><span class="line">307</span><br><span class="line">308</span><br><span class="line">309</span><br><span class="line">310</span><br><span class="line">311</span><br><span class="line">312</span><br><span class="line">313</span><br><span class="line">314</span><br><span class="line">315</span><br><span class="line">316</span><br><span class="line">317</span><br><span class="line">318</span><br><span class="line">319</span><br><span class="line">320</span><br><span class="line">321</span><br><span class="line">322</span><br><span class="line">323</span><br><span class="line">324</span><br><span class="line">325</span><br><span class="line">326</span><br><span class="line">327</span><br><span class="line">328</span><br><span class="line">329</span><br><span class="line">330</span><br><span class="line">331</span><br><span class="line">332</span><br><span class="line">333</span><br><span class="line">334</span><br><span class="line">335</span><br><span class="line">336</span><br><span class="line">337</span><br><span class="line">338</span><br><span class="line">339</span><br><span class="line">340</span><br><span class="line">341</span><br><span class="line">342</span><br><span class="line">343</span><br><span class="line">344</span><br><span class="line">345</span><br><span class="line">346</span><br><span class="line">347</span><br><span class="line">348</span><br><span class="line">349</span><br><span class="line">350</span><br><span class="line">351</span><br><span class="line">352</span><br><span class="line">353</span><br><span class="line">354</span><br><span class="line">355</span><br><span class="line">356</span><br><span class="line">357</span><br><span class="line">358</span><br><span class="line">359</span><br><span class="line">360</span><br><span class="line">361</span><br><span class="line">362</span><br><span class="line">363</span><br><span class="line">364</span><br><span class="line">365</span><br><span class="line">366</span><br><span class="line">367</span><br><span class="line">368</span><br><span class="line">369</span><br><span class="line">370</span><br><span class="line">371</span><br><span class="line">372</span><br><span class="line">373</span><br><span class="line">374</span><br><span class="line">375</span><br><span class="line">376</span><br><span class="line">377</span><br><span class="line">378</span><br><span class="line">379</span><br><span class="line">380</span><br><span class="line">381</span><br><span class="line">382</span><br><span class="line">383</span><br><span class="line">384</span><br><span class="line">385</span><br><span class="line">386</span><br><span class="line">387</span><br><span class="line">388</span><br><span class="line">389</span><br><span class="line">390</span><br><span class="line">391</span><br><span class="line">392</span><br><span class="line">393</span><br><span class="line">394</span><br><span class="line">395</span><br><span class="line">396</span><br><span class="line">397</span><br><span class="line">398</span><br><span class="line">399</span><br><span class="line">400</span><br><span class="line">401</span><br><span class="line">402</span><br><span class="line">403</span><br><span class="line">404</span><br><span class="line">405</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> Thread <span class="keyword">implements</span> Runnable &#123;<span class="comment">//实现Runnable接口</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">native</span> <span class="keyword">void</span> yield();<span class="comment">//不太常用，可以向调度程序提示当前程序可以让出对处理器的使用，调度器可以忽略此提示，用来改善多线程对CPU的过度使用。</span></span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    <span class="keyword">protected</span> Object clone() <span class="keyword">throws</span> CloneNotSupportedException &#123;<span class="comment">//克隆出一个线程</span></span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> CloneNotSupportedException();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">void</span> exit() &#123;<span class="comment">//由系统调用，可以让线程在实际退出前可以有机会清理</span></span><br><span class="line">        <span class="keyword">if</span> (<span class="keyword">group</span> != <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">group</span>.threadTerminated(<span class="keyword">this</span>);</span><br><span class="line">            <span class="keyword">group</span> = <span class="keyword">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        target = <span class="keyword">null</span>;</span><br><span class="line">        threadLocals = <span class="keyword">null</span>;</span><br><span class="line">        inheritableThreadLocals = <span class="keyword">null</span>;</span><br><span class="line">        inheritedAccessControlContext = <span class="keyword">null</span>;</span><br><span class="line">        blocker = <span class="keyword">null</span>;</span><br><span class="line">        uncaughtExceptionHandler = <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 更改此线程的优先级</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">void</span> setPriority(<span class="keyword">int</span> newPriority) &#123;</span><br><span class="line">        ThreadGroup g;</span><br><span class="line">        checkAccess();<span class="comment">//检查权限</span></span><br><span class="line">        <span class="keyword">if</span> (newPriority &gt; MAX_PRIORITY || newPriority &lt; MIN_PRIORITY) &#123;<span class="comment">//正确性检查</span></span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>((g = getThreadGroup()) != <span class="keyword">null</span>) &#123;<span class="comment">//能获取到线程组，newPriority也要根据线程组最大限制调整</span></span><br><span class="line">            <span class="keyword">if</span> (newPriority &gt; g.getMaxPriority()) &#123;</span><br><span class="line">                newPriority = g.getMaxPriority();</span><br><span class="line">            &#125;</span><br><span class="line">            setPriority0(priority = newPriority);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 返回此线程的优先级</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">int</span> getPriority() &#123;</span><br><span class="line">        <span class="keyword">return</span> priority;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     *  更改此线程的线程名</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> setName(String name) &#123;</span><br><span class="line">        checkAccess();<span class="comment">//检查权限</span></span><br><span class="line">        <span class="keyword">if</span> (name == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> NullPointerException(<span class="string">"name cannot be null"</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">this</span>.name = name;</span><br><span class="line">        <span class="keyword">if</span> (threadStatus != <span class="number">0</span>) &#123;</span><br><span class="line">            setNativeName(name);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 返回此线程的线程名</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">final</span> String getName() &#123;</span><br><span class="line">        <span class="keyword">return</span> name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 返回此线程所属线程组，若线程已死亡，则返回null</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">final</span> ThreadGroup getThreadGroup() &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">group</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 返回当前线程的线程组和其子组中所有活动线程的估计数量，即递归迭代当前线程所属线程组所有子组</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> activeCount() &#123;</span><br><span class="line">        <span class="keyword">return</span> currentThread().getThreadGroup().activeCount();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 将当前线程所属线程组及其子组的所有活动线程复制到指定的数组中，如果数组长度不够，超过的会忽略，若一定要获取所有元素，请先检查线程数量</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> enumerate(Thread tarray[]) &#123;</span><br><span class="line">        <span class="keyword">return</span> currentThread().getThreadGroup().enumerate(tarray);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 打印当前线程的堆栈跟踪到标准错误流中，仅用于调试</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> dumpStack() &#123;</span><br><span class="line">        <span class="keyword">new</span> Exception(<span class="string">"Stack trace"</span>).printStackTrace();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 声明此线程为守护线程或用户线程，若运行的唯一一个线程为守护线程时，JVM会退出。此函数只能在线程声明启动前被调用。</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">void</span> setDaemon(<span class="keyword">boolean</span> on) &#123;</span><br><span class="line">        checkAccess();</span><br><span class="line">        <span class="keyword">if</span> (isAlive()) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> IllegalThreadStateException();</span><br><span class="line">        &#125;</span><br><span class="line">        daemon = on;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 测试此线程是否为守护线程</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">boolean</span> isDaemon() &#123;</span><br><span class="line">        <span class="keyword">return</span> daemon;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 确认当前正在运行的线程是否有修改此线程的权限</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">void</span> checkAccess() &#123;</span><br><span class="line">        SecurityManager security = System.getSecurityManager();</span><br><span class="line">        <span class="keyword">if</span> (security != <span class="keyword">null</span>) &#123;<span class="comment">//如果能取得系统安全管理器，则通过管理器检查此线程权限。</span></span><br><span class="line">            security.checkAccess(<span class="keyword">this</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 返回此线程的字符串表示：线程名+优先级+线程组名</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> String toString() &#123;</span><br><span class="line">        ThreadGroup <span class="keyword">group</span> = getThreadGroup();</span><br><span class="line">        <span class="keyword">if</span> (<span class="keyword">group</span> != <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="string">"Thread["</span> + getName() + <span class="string">","</span> + getPriority() + <span class="string">","</span> +</span><br><span class="line">                           <span class="keyword">group</span>.getName() + <span class="string">"]"</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="string">"Thread["</span> + getName() + <span class="string">","</span> + getPriority() + <span class="string">","</span> +</span><br><span class="line">                            <span class="string">""</span> + <span class="string">"]"</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 返回此线程的ContextClassLoader，此加载器由线程创建者提供，以供加载类和资源时在此线程中运行的代码使用</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    @CallerSensitive</span><br><span class="line">    <span class="keyword">public</span> ClassLoader getContextClassLoader() &#123;</span><br><span class="line">        <span class="keyword">if</span> (contextClassLoader == <span class="keyword">null</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">        SecurityManager sm = System.getSecurityManager();</span><br><span class="line">        <span class="keyword">if</span> (sm != <span class="keyword">null</span>) &#123;<span class="comment">//检查权限</span></span><br><span class="line">            ClassLoader.checkClassLoaderPermission(contextClassLoader,</span><br><span class="line">                                                   Reflection.getCallerClass());</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> contextClassLoader;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 设置此线程的ContextClassLoader，创建线程时可以设置其ContextClassLoader，允许创建者通过getContextClassLoader获取合适的类加载器</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> setContextClassLoader(ClassLoader cl) &#123;</span><br><span class="line">        SecurityManager sm = System.getSecurityManager();</span><br><span class="line">        <span class="keyword">if</span> (sm != <span class="keyword">null</span>) &#123;</span><br><span class="line">            sm.checkPermission(<span class="keyword">new</span> RuntimePermission(<span class="string">"setContextClassLoader"</span>));</span><br><span class="line">        &#125;</span><br><span class="line">        contextClassLoader = cl;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 返回此线程堆栈转储的堆栈跟踪元素数组</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> StackTraceElement[] getStackTrace() &#123;</span><br><span class="line">        <span class="keyword">if</span> (<span class="keyword">this</span> != Thread.currentThread()) &#123;</span><br><span class="line">            <span class="comment">// check for getStackTrace permission</span></span><br><span class="line">            SecurityManager security = System.getSecurityManager();</span><br><span class="line">            <span class="keyword">if</span> (security != <span class="keyword">null</span>) &#123;</span><br><span class="line">                security.checkPermission(</span><br><span class="line">                    SecurityConstants.GET_STACK_TRACE_PERMISSION);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// optimization so we do not call into the vm for threads that</span></span><br><span class="line">            <span class="comment">// have not yet started or have terminated</span></span><br><span class="line">            <span class="keyword">if</span> (!isAlive()) &#123;</span><br><span class="line">                <span class="keyword">return</span> EMPTY_STACK_TRACE;</span><br><span class="line">            &#125;</span><br><span class="line">            StackTraceElement[][] stackTraceArray = dumpThreads(<span class="keyword">new</span> Thread[] &#123;<span class="keyword">this</span>&#125;);</span><br><span class="line">            StackTraceElement[] stackTrace = stackTraceArray[<span class="number">0</span>];</span><br><span class="line">            <span class="comment">// a thread that was alive during the previous isAlive call may have</span></span><br><span class="line">            <span class="comment">// since terminated, therefore not having a stacktrace.</span></span><br><span class="line">            <span class="keyword">if</span> (stackTrace == <span class="keyword">null</span>) &#123;</span><br><span class="line">                stackTrace = EMPTY_STACK_TRACE;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> stackTrace;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">// Don't need JVM help for current thread</span></span><br><span class="line">            <span class="keyword">return</span> (<span class="keyword">new</span> Exception()).getStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 返回所有活动线程的堆栈跟踪元素映射，键为线程，值为StackTraceElement元素，其表示对应线程的堆栈转储</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> Map&lt;Thread, StackTraceElement[]&gt; getAllStackTraces() &#123;</span><br><span class="line">        <span class="comment">// check for getStackTrace permission</span></span><br><span class="line">        SecurityManager security = System.getSecurityManager();</span><br><span class="line">        <span class="keyword">if</span> (security != <span class="keyword">null</span>) &#123;</span><br><span class="line">            security.checkPermission(</span><br><span class="line">                SecurityConstants.GET_STACK_TRACE_PERMISSION);</span><br><span class="line">            security.checkPermission(</span><br><span class="line">                SecurityConstants.MODIFY_THREADGROUP_PERMISSION);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// Get a snapshot of the list of all threads</span></span><br><span class="line">        Thread[] threads = getThreads();</span><br><span class="line">        StackTraceElement[][] traces = dumpThreads(threads);</span><br><span class="line">        Map&lt;Thread, StackTraceElement[]&gt; m = <span class="keyword">new</span> HashMap&lt;&gt;(threads.length);</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; threads.length; i++) &#123;</span><br><span class="line">            StackTraceElement[] stackTrace = traces[i];</span><br><span class="line">            <span class="keyword">if</span> (stackTrace != <span class="keyword">null</span>) &#123;</span><br><span class="line">                m.put(threads[i], stackTrace);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// else terminated so we don't put it in the map</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> m;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">/** cache of subclass security audit results */</span></span><br><span class="line">    <span class="comment">/* Replace with ConcurrentReferenceHashMap when/if it appears in a future</span></span><br><span class="line"><span class="comment">     * release */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">class</span> Caches &#123;</span><br><span class="line">        <span class="comment">/** cache of subclass security audit results */</span></span><br><span class="line">        <span class="keyword">static</span> <span class="keyword">final</span> ConcurrentMap&lt;WeakClassKey,<span class="keyword">Boolean</span>&gt; subclassAudits =</span><br><span class="line">            <span class="keyword">new</span> ConcurrentHashMap&lt;&gt;();</span><br><span class="line"></span><br><span class="line">        <span class="comment">/** queue for WeakReferences to audited subclasses */</span></span><br><span class="line">        <span class="keyword">static</span> <span class="keyword">final</span> ReferenceQueue&lt;<span class="keyword">Class</span>&lt;?&gt;&gt; subclassAuditsQueue =</span><br><span class="line">            <span class="keyword">new</span> ReferenceQueue&lt;&gt;();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 验证是否可以在不违反安全约束的情况下构造此实例，子类不允许重写安全敏感的非final方法，否则会检查EnableContextClassLoaderOverride运行时权限</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">boolean</span> isCCLOverridden(<span class="keyword">Class</span>&lt;?&gt; cl) &#123;</span><br><span class="line">        <span class="keyword">if</span> (cl == Thread.<span class="keyword">class</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line"></span><br><span class="line">        processQueue(Caches.subclassAuditsQueue, Caches.subclassAudits);</span><br><span class="line">        WeakClassKey key = <span class="keyword">new</span> WeakClassKey(cl, Caches.subclassAuditsQueue);</span><br><span class="line">        <span class="keyword">Boolean</span> result = Caches.subclassAudits.get(key);</span><br><span class="line">        <span class="keyword">if</span> (result == <span class="keyword">null</span>) &#123;</span><br><span class="line">            result = <span class="keyword">Boolean</span>.valueOf(auditSubclass(cl));</span><br><span class="line">            Caches.subclassAudits.putIfAbsent(key, result);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> result.booleanValue();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 检查给定子类的反射，验证其是否重写了安全敏感的非final方法，若重写返回true，否则false</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">boolean</span> auditSubclass(<span class="keyword">final</span> <span class="keyword">Class</span>&lt;?&gt; subcl) &#123;</span><br><span class="line">        <span class="keyword">Boolean</span> result = AccessController.doPrivileged(</span><br><span class="line">            <span class="keyword">new</span> PrivilegedAction&lt;<span class="keyword">Boolean</span>&gt;() &#123;</span><br><span class="line">                <span class="keyword">public</span> <span class="keyword">Boolean</span> run() &#123;</span><br><span class="line">                    <span class="keyword">for</span> (<span class="keyword">Class</span>&lt;?&gt; cl = subcl;</span><br><span class="line">                         cl != Thread.<span class="keyword">class</span>;</span><br><span class="line">                         cl = cl.getSuperclass())</span><br><span class="line">                    &#123;</span><br><span class="line">                        <span class="keyword">try</span> &#123;</span><br><span class="line">                            cl.getDeclaredMethod(<span class="string">"getContextClassLoader"</span>, <span class="keyword">new</span> <span class="keyword">Class</span>&lt;?&gt;[<span class="number">0</span>]);</span><br><span class="line">                            <span class="keyword">return</span> <span class="keyword">Boolean</span>.<span class="keyword">TRUE</span>;</span><br><span class="line">                        &#125; <span class="keyword">catch</span> (NoSuchMethodException ex) &#123;</span><br><span class="line">                        &#125;</span><br><span class="line">                        <span class="keyword">try</span> &#123;</span><br><span class="line">                            <span class="keyword">Class</span>&lt;?&gt;[] params = &#123;ClassLoader.<span class="keyword">class</span>&#125;;</span><br><span class="line">                            cl.getDeclaredMethod(<span class="string">"setContextClassLoader"</span>, params);</span><br><span class="line">                            <span class="keyword">return</span> <span class="keyword">Boolean</span>.<span class="keyword">TRUE</span>;</span><br><span class="line">                        &#125; <span class="keyword">catch</span> (NoSuchMethodException ex) &#123;</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="keyword">return</span> <span class="keyword">Boolean</span>.<span class="keyword">FALSE</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        );</span><br><span class="line">        <span class="keyword">return</span> result.booleanValue();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 返回线程的ID，线程ID是一个唯一且为正的整型，在线程的生命周期里不能被修改，但线程死亡后可以复用</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">long</span> getId() &#123;</span><br><span class="line">        <span class="keyword">return</span> tid;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 线程状态，这些状态是JVM状态而不对应任何操作</span></span><br><span class="line"><span class="comment">     * </span></span><br><span class="line"><span class="comment">     * 包括：</span></span><br><span class="line"><span class="comment">     *     &#123;@link #NEW&#125; 尚未启动的线程</span></span><br><span class="line"><span class="comment">     *     &#123;@link #RUNNABLE&#125; 在JVM中执行的线程处于此状态</span></span><br><span class="line"><span class="comment">     *     &#123;@link #BLOCKED&#125; 等待监视器锁被阻塞的线程处于此状态</span></span><br><span class="line"><span class="comment">     *     &#123;@link #WAITING&#125; 无限的等待另一个线程执行特定操作的线程处于此状态</span></span><br><span class="line"><span class="comment">     *     &#123;@link #TIMED_WAITING&#125; 在指定的等待时间内等待另一个线程执行操作的线程处于此状态</span></span><br><span class="line"><span class="comment">     *     &#123;@link #TERMINATED&#125; 已退出的线程处于此状态</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> enum State &#123;</span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">         * Thread state for a thread which has not yet started.</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        <span class="keyword">NEW</span>,</span><br><span class="line"></span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">         * Thread state for a runnable thread.  A thread in the runnable</span></span><br><span class="line"><span class="comment">         * state is executing in the Java virtual machine but it may</span></span><br><span class="line"><span class="comment">         * be waiting for other resources from the operating system</span></span><br><span class="line"><span class="comment">         * such as processor.</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        RUNNABLE,</span><br><span class="line"></span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">         * Thread state for a thread blocked waiting for a monitor lock.</span></span><br><span class="line"><span class="comment">         * A thread in the blocked state is waiting for a monitor lock</span></span><br><span class="line"><span class="comment">         * to enter a synchronized block/method or</span></span><br><span class="line"><span class="comment">         * reenter a synchronized block/method after calling</span></span><br><span class="line"><span class="comment">         * &#123;@link Object#wait() Object.wait&#125;.</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        BLOCKED,</span><br><span class="line"></span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">         * Thread state for a waiting thread.</span></span><br><span class="line"><span class="comment">         * A thread is in the waiting state due to calling one of the</span></span><br><span class="line"><span class="comment">         * following methods:</span></span><br><span class="line"><span class="comment">         * &lt;ul&gt;</span></span><br><span class="line"><span class="comment">         *   &lt;li&gt;&#123;@link Object#wait() Object.wait&#125; with no timeout&lt;/li&gt;</span></span><br><span class="line"><span class="comment">         *   &lt;li&gt;&#123;@link #join() Thread.join&#125; with no timeout&lt;/li&gt;</span></span><br><span class="line"><span class="comment">         *   &lt;li&gt;&#123;@link LockSupport#park() LockSupport.park&#125;&lt;/li&gt;</span></span><br><span class="line"><span class="comment">         * &lt;/ul&gt;</span></span><br><span class="line"><span class="comment">         *</span></span><br><span class="line"><span class="comment">         * &lt;p&gt;A thread in the waiting state is waiting for another thread to</span></span><br><span class="line"><span class="comment">         * perform a particular action.</span></span><br><span class="line"><span class="comment">         *</span></span><br><span class="line"><span class="comment">         * For example, a thread that has called &lt;tt&gt;Object.wait()&lt;/tt&gt;</span></span><br><span class="line"><span class="comment">         * on an object is waiting for another thread to call</span></span><br><span class="line"><span class="comment">         * &lt;tt&gt;Object.notify()&lt;/tt&gt; or &lt;tt&gt;Object.notifyAll()&lt;/tt&gt; on</span></span><br><span class="line"><span class="comment">         * that object. A thread that has called &lt;tt&gt;Thread.join()&lt;/tt&gt;</span></span><br><span class="line"><span class="comment">         * is waiting for a specified thread to terminate.</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        WAITING,</span><br><span class="line"></span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">         * Thread state for a waiting thread with a specified waiting time.</span></span><br><span class="line"><span class="comment">         * A thread is in the timed waiting state due to calling one of</span></span><br><span class="line"><span class="comment">         * the following methods with a specified positive waiting time:</span></span><br><span class="line"><span class="comment">         * &lt;ul&gt;</span></span><br><span class="line"><span class="comment">         *   &lt;li&gt;&#123;@link #sleep Thread.sleep&#125;&lt;/li&gt;</span></span><br><span class="line"><span class="comment">         *   &lt;li&gt;&#123;@link Object#wait(long) Object.wait&#125; with timeout&lt;/li&gt;</span></span><br><span class="line"><span class="comment">         *   &lt;li&gt;&#123;@link #join(long) Thread.join&#125; with timeout&lt;/li&gt;</span></span><br><span class="line"><span class="comment">         *   &lt;li&gt;&#123;@link LockSupport#parkNanos LockSupport.parkNanos&#125;&lt;/li&gt;</span></span><br><span class="line"><span class="comment">         *   &lt;li&gt;&#123;@link LockSupport#parkUntil LockSupport.parkUntil&#125;&lt;/li&gt;</span></span><br><span class="line"><span class="comment">         * &lt;/ul&gt;</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        TIMED_WAITING,</span><br><span class="line"></span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">         * Thread state for a terminated thread.</span></span><br><span class="line"><span class="comment">         * The thread has completed execution.</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        TERMINATED;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 返回此线程的状态，此方法用来监视线程的系统状态，而不是用来作同步控制</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> State getState() &#123;</span><br><span class="line">        <span class="comment">// get current thread state</span></span><br><span class="line">        <span class="keyword">return</span> sun.misc.VM.toThreadState(threadStatus);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//省略了一些异常处理器函数等</span></span><br><span class="line">    ...</span><br><span class="line"></span><br><span class="line">  </span><br><span class="line">    @Deprecated</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">void</span> stop() &#123;<span class="comment">//已弃用，因为不安全</span></span><br><span class="line">        ...</span><br><span class="line">    &#125;</span><br><span class="line">    ...</span><br><span class="line"></span><br><span class="line">    @Deprecated</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> destroy() &#123;<span class="comment">//已弃用</span></span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> NoSuchMethodError();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Deprecated</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">void</span> suspend() &#123;<span class="comment">//已弃用</span></span><br><span class="line">        checkAccess();</span><br><span class="line">        suspend0();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Deprecated</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">void</span> resume() &#123;<span class="comment">//已弃用</span></span><br><span class="line">        checkAccess();</span><br><span class="line">        resume0();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      Java中Thread类的源码剖析
    
    </summary>
    
      <category term="技术文档" scheme="http://linyishui.top/categories/%E6%8A%80%E6%9C%AF%E6%96%87%E6%A1%A3/"/>
    
    
      <category term="java" scheme="http://linyishui.top/tags/java/"/>
    
      <category term="thread" scheme="http://linyishui.top/tags/thread/"/>
    
  </entry>
  
  <entry>
    <title>日志</title>
    <link href="http://linyishui.top/2019050901.html"/>
    <id>http://linyishui.top/2019050901.html</id>
    <published>2019-05-09T03:37:30.000Z</published>
    <updated>2019-05-17T10:17:58.000Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>&emsp;&emsp;</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;link rel=&quot;stylesheet&quot; class=&quot;aplayer-secondary-style-marker&quot; href=&quot;\assets\css\APlayer.min.css&quot;&gt;&lt;script src=&quot;\assets\js\APlayer.min.js&quot; cla
      
    
    </summary>
    
      <category term="日志" scheme="http://linyishui.top/categories/%E6%97%A5%E5%BF%97/"/>
    
    
      <category term="diary" scheme="http://linyishui.top/tags/diary/"/>
    
  </entry>
  
  <entry>
    <title>Java内存区域和内存溢出异常</title>
    <link href="http://linyishui.top/2019050801.html"/>
    <id>http://linyishui.top/2019050801.html</id>
    <published>2019-05-08T11:02:04.000Z</published>
    <updated>2019-05-23T08:02:22.000Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="一、运行时数据区域"><a href="#一、运行时数据区域" class="headerlink" title="一、运行时数据区域"></a><strong>一、运行时数据区域</strong></h1><h2 id="1-程序计数器（Program-Counter-Register）"><a href="#1-程序计数器（Program-Counter-Register）" class="headerlink" title="1. 程序计数器（Program Counter Register）"></a><strong>1. 程序计数器（Program Counter Register）</strong></h2><p>&emsp;&emsp;程序计数器就是当前线程所执行字节码的<strong>行号指示器</strong>，字节码解释器通过改变计数器的值来选取下一条需要执行的字节码指令，分支、循环、跳转、异常处理、线程恢复等功能都需要依赖程序计数器。</p><p>&emsp;&emsp;为了支持多线程间上下文切换，在线程恢复时能恢复到执行位置，每个线程都会有独立的程序计数器，所以程序计数器是<strong>线程私有</strong>内存。</p><h2 id="2-虚拟机栈（Java-Virtual-Machine-Stacks）"><a href="#2-虚拟机栈（Java-Virtual-Machine-Stacks）" class="headerlink" title="2. 虚拟机栈（Java Virtual Machine Stacks）"></a><strong>2. 虚拟机栈（Java Virtual Machine Stacks）</strong></h2><p>&emsp;&emsp;虚拟机栈描述Java方法执行的内存模型：每个方法在执行时会创建一个<strong>栈帧</strong>，用来存储局部变量表、操作数栈、动态链接、方法出口等信息，每个方法从调用直至执行完成的过程，对应着一个栈帧在虚拟机栈中入栈到出栈的过程。</p><p>&emsp;&emsp;虚拟机栈是<strong>线程私有</strong>内存。</p><p>&emsp;&emsp;<strong>局部变量表</strong>用来存放编译阶段可知的各种<strong>基本数据类型</strong>，<strong>对象引用类型</strong>，和<strong>returnAdress类型</strong>。</p><p>&emsp;&emsp;虚拟机规范规定此内存区域的两种异常：</p><ol><li>StackOverflowError 线程请求的栈深度超过虚拟机所允许的深度。</li><li>OutOfMemoryError 虚拟机动态扩展时无法申请到足够的内存。</li></ol><h2 id="3-本地方法栈（Native-Method-Stack）"><a href="#3-本地方法栈（Native-Method-Stack）" class="headerlink" title="3. 本地方法栈（Native Method Stack）"></a><strong>3. 本地方法栈（Native Method Stack）</strong></h2><p>&emsp;&emsp;本地方法栈类似于虚拟机栈，区别是虚拟机栈为虚拟机执行Java方法(字节码)服务，本地方法栈则为Native方法服务，甚至二者可以合并为一个方法栈。</p><h2 id="4-Java堆（Java-Heap）"><a href="#4-Java堆（Java-Heap）" class="headerlink" title="4. Java堆（Java Heap）"></a><strong>4. Java堆（Java Heap）</strong></h2><p>&emsp;&emsp;Java堆是一块<strong>线程共享</strong>的内存区域，堆就是用来存放所有的对象实例，所以<strong>所有的对象实例和数组都要在堆上分配</strong>（不绝对）。</p><p>&emsp;&emsp;垃圾回收管理主要发生在Java堆，所以也叫GC堆。内存回收的收集器采用的是分代收集算法：可以把GC堆分为<strong>新生代</strong>和<strong>老年代</strong>，更细分的话可以分为<strong>Eden空间</strong>、<strong>From Survivor空间</strong>、<strong>To Survivor空间</strong>等。从内存分配的角度看，Java堆可以分出一些线程私有的<strong>分配缓冲区</strong>。无论怎样划分，堆存储的都是对象实例。</p><h2 id="5-方法区（Method-Area）"><a href="#5-方法区（Method-Area）" class="headerlink" title="5. 方法区（Method Area）"></a><strong>5. 方法区（Method Area）</strong></h2><p>&emsp;&emsp;方法区是<strong>线程共享</strong>的内存区域，用来存储被VM加载的类信息、常量、静态常量、即时编译器编译后的代码等数据。方法区实际上可以看作堆的一个逻辑部分，但它的别名叫非堆(Non-Heap)，应该是为了和堆区域区分一下。方法区有时被叫做<strong>永久代</strong>，原因就是HotSpot的垃圾收集分代把方法区也纳入范围，GC收集器可以像管理Java堆一样管理方法区这块内存区域，而不用再为方法区再编写内存管理代码，但永久代的设计更容易遇到内存溢出的问题，所以在1.7之后的版本就把字符串常量池移到了堆中。</p><h2 id="6-运行时常量池（Runtime-Constant-Pool）"><a href="#6-运行时常量池（Runtime-Constant-Pool）" class="headerlink" title="6. 运行时常量池（Runtime Constant Pool）"></a><strong>6. 运行时常量池（Runtime Constant Pool）</strong></h2><p>&emsp;&emsp;运行时常量池是方法区的一部分，</p><p>&emsp;&emsp;Class文件除了包含类的版本、字段、方法、接口等描述信息外，还有一项就是常量池（Constant Pool Table），用来存放编译期生成的各种字面量和符号引用，常量池表的数据在类加载后会进入运行时常量池存放。除了符号引用外，一般也会把翻译出来的直接引用存储在运行时常量池中。</p><p>&emsp;&emsp;除了编译时获取的常量外，运行时也可以将新生成的常量放入运行时常量池，比较常用的就是String.intern()</p><h2 id="7-直接内存（Direct-Memory）"><a href="#7-直接内存（Direct-Memory）" class="headerlink" title="7. 直接内存（Direct Memory）"></a><strong>7. 直接内存（Direct Memory）</strong></h2><p>&emsp;&emsp;直接内存并不是虚拟机规范中定义的内存区域，但这部分内存会被频繁使用，如NIO类引入了一种基于Channel通道于Buffer缓冲区的新I/O方式，其使用Native函数库直接分配堆外内存区域，然后再通过存储在Java堆中的DirectByteBuffer对象作为这块内存的引用进行操作，这样就避免了一直在Java堆和Native堆中来回复制数据，从而提高了性能。</p><p>&emsp;&emsp;因为不属于虚拟机定义的内存区域，所以直接内存只受计算机本身内存大小和处理器寻址空间的限制，配置服务器虚拟机参数时需要考虑到这一部分区域，否则可能会在动态扩展时导致内存溢出。</p><blockquote><p>更多可以参考：<a href="../2019032501.html" title="Title">IO和NIO</a></p></blockquote><hr><h1 id="二、虚拟机中对象生命过程"><a href="#二、虚拟机中对象生命过程" class="headerlink" title="二、虚拟机中对象生命过程"></a><strong>二、虚拟机中对象生命过程</strong></h1><h2 id="1-对象的创建"><a href="#1-对象的创建" class="headerlink" title="1. 对象的创建"></a><strong>1. 对象的创建</strong></h2><p>&emsp;&emsp;在Java语言中，表面上看就是通过new关键字创建一个对象，在虚拟机中经历了一个怎样的过程？</p><h3 id="1-虚拟机在执行到new指令时，首先要检查此指令的参数能否在常量池定位到一个类的符号引用，同时检查这个符号引用所代表的类是否已经被加载、解析和初始化过。"><a href="#1-虚拟机在执行到new指令时，首先要检查此指令的参数能否在常量池定位到一个类的符号引用，同时检查这个符号引用所代表的类是否已经被加载、解析和初始化过。" class="headerlink" title="1. 虚拟机在执行到new指令时，首先要检查此指令的参数能否在常量池定位到一个类的符号引用，同时检查这个符号引用所代表的类是否已经被加载、解析和初始化过。"></a><strong>1. 虚拟机在执行到new指令时，首先要</strong>检查<strong>此指令的参数能否在常量池定位到一个类的符号引用，同时检查这个符号引用所代表的类是否已经被加载、解析和初始化过。</strong></h3><p>&emsp;&emsp;&emsp;&emsp;如果没有，则执行类的加载过程，详细请看博客<a href="../2019050801.html" title="Title">类的加载机制</a>。</p><h3 id="2-在类加载检查通过后，虚拟机会为新生的对象分配内存，在类加载后就可以确认所需内存大小。"><a href="#2-在类加载检查通过后，虚拟机会为新生的对象分配内存，在类加载后就可以确认所需内存大小。" class="headerlink" title="2. 在类加载检查通过后，虚拟机会为新生的对象分配内存，在类加载后就可以确认所需内存大小。"></a><strong>2. 在类加载检查通过后，虚拟机会为新生的对象</strong>分配内存<strong>，在类加载后就可以确认所需内存大小。</strong></h3><blockquote><p>&emsp;假设Java堆中的内存是规整的，分配内存就是将指针在空闲区域挪动对象大小的距离，这类分配方式叫<strong>指针碰撞</strong>。</p><p>&emsp;如果Java堆中内存并不规整，虚拟机就需要维护一个列表来记录可用的内存块，在分配时查询此表，找到足够大的空闲空间放置对象，并更新表内数据，这类分配方式叫<strong>空闲列表</strong>。</p><p>&emsp;Java堆是否规整由垃圾收集器是否由压缩整理功能决定，在使用Serial、ParNew等带Compact过程的收集器时使用<strong>指针碰撞</strong>，而使用CMS这类基于Mark-Sweep算法的收集器时，采用<strong>空闲列表</strong>。</p></blockquote><blockquote><p><strong>在划分空间时需要考虑线程安全问题：</strong></p><p>&emsp;比如给对象A分配内存，但指针还未来得及修改，此时对象B同时使用了指针来分配内存。</p><p>&emsp;解决方案一般如下：</p><ol><li>对分配内存空间的动作进行同步处理，虚拟机采用CAS+失败重试的方式来保证操作的原子性。</li><li>把内存分配的动作按照线程划分在不同的空间中进行，即每个线程都预先在Java堆中预先分配一小块内存区域，叫做<strong>本地线程分配缓冲（TLAB）</strong>，线程在自己的TLAB上面分配内存，只有当TLAB用完要分配新的TLAB时再同步锁定，虚拟机是否使用TLAB可以根据参数-XX:+/-UserTLAB来设定。</li></ol><p>&emsp;内存分配完成后，虚拟机会将被分配的内存区域初始化为<strong>0值</strong>(不包括对象头)，若采用TLAB可以提前到分配TLAB时进行，这一操作使对象在未被赋值的情况下可以被访问其对应数据类型的0值。</p></blockquote><h3 id="3-虚拟机对对象进行必要的设置，如对象所属类、对象哈希码、类的元数据信息、对象的GC分代年龄信息等。然后把这些信息存放在对象头（Object-Header）中。"><a href="#3-虚拟机对对象进行必要的设置，如对象所属类、对象哈希码、类的元数据信息、对象的GC分代年龄信息等。然后把这些信息存放在对象头（Object-Header）中。" class="headerlink" title="3. 虚拟机对对象进行必要的设置，如对象所属类、对象哈希码、类的元数据信息、对象的GC分代年龄信息等。然后把这些信息存放在对象头（Object Header）中。"></a><strong>3. 虚拟机对对象进行必要的</strong>设置<strong>，如对象所属类、对象哈希码、类的元数据信息、对象的GC分代年龄信息等。然后把这些信息存放在</strong>对象头（Object Header）<strong>中。</strong></h3><p>&emsp;&emsp;&emsp;&emsp;此过程结束，对VM来说对象已经创建完成，对于Java程序而言才刚刚开始，然后就是初始化&lt; init &gt;，此时所有字段都还为<strong>0</strong>。</p><h3 id="4-执行对象的-lt-init-gt-方法，把对象按开发设计进行初始化。"><a href="#4-执行对象的-lt-init-gt-方法，把对象按开发设计进行初始化。" class="headerlink" title="4. 执行对象的&lt; init &gt;方法，把对象按开发设计进行初始化。"></a><strong>4. 执行对象的&lt; init &gt;方法，把对象按开发设计进行初始化。</strong></h3><h2 id="2-对象的内存布局"><a href="#2-对象的内存布局" class="headerlink" title="2. 对象的内存布局"></a><strong>2. 对象的内存布局</strong></h2><p>&emsp;&emsp;在HotSpot虚拟机中，对象在内存中存储的布局分为3块区域：<strong>对象头</strong>（Header）、<strong>实例数据</strong>（Instance Data）和<strong>对齐填充</strong>（Padding）。</p><h3 id="2-1-对象头"><a href="#2-1-对象头" class="headerlink" title="2.1 对象头"></a><strong>2.1 对象头</strong></h3><p>&emsp;&emsp;对象头，包括两部分信息，第一部分存储对象自身的运行时数据，如哈希码、GC分代年龄、锁状态标志、线程持有的锁、偏向线程ID、偏向时间戳等，这部分被叫做<strong>Mark Word</strong></p><table><thead><tr><th style="text-align:left">存储内容</th><th style="text-align:center">标志位</th><th style="text-align:center">状态</th></tr></thead><tbody><tr><td style="text-align:left">对象哈希码、对象分代年龄</td><td style="text-align:center">01</td><td style="text-align:center">未锁定</td></tr><tr><td style="text-align:left">指向锁记录的指针</td><td style="text-align:center">00</td><td style="text-align:center">轻量级锁定</td></tr><tr><td style="text-align:left">指向重量级锁的指针</td><td style="text-align:center">10</td><td style="text-align:center">膨胀（重量级锁定）</td></tr><tr><td style="text-align:left">空，不需要记录信息</td><td style="text-align:center">11</td><td style="text-align:center">GC标记</td></tr><tr><td style="text-align:left">偏向线程ID、偏向时间戳、对象分代年龄</td><td style="text-align:center">01</td><td style="text-align:center">可偏向</td></tr></tbody></table><p>&emsp;&emsp;第二部分是类型指针，即对象指向它的类元数据的指针，VM通过这个指针确定此对象是哪个类的实例。</p><p>&emsp;&emsp;此外若对象是Java数组时，对象头需要记录数组长度，VM可以根据对象的元数据来确定Java对象大小，对于数组则无法确定。</p><h3 id="2-2-实例数据"><a href="#2-2-实例数据" class="headerlink" title="2.2 实例数据"></a><strong>2.2 实例数据</strong></h3><p>&emsp;&emsp;实例数据部分就是对象的具体信息，即类中定义的各类型信息，包含父类继承的，此部分的存储顺序会受<strong>虚拟机分配策略参数</strong>和字段在Java源码中定义顺序的影响。HotSpot的默认顺序：longs/doubles、ints、shorts/chars、bytes/booleans、oops（Ordinary Object Pointers）。</p><h3 id="2-3-对齐填充"><a href="#2-3-对齐填充" class="headerlink" title="2.3 对齐填充"></a><strong>2.3 对齐填充</strong></h3><p>&emsp;&emsp;没有其它含义，只是起占位符的作用，因为HosSpot VM要求对象起始地址必须是8字节的整数倍，也就是对象大小必须是8字节的整数倍，对象头刚好是8或16，当实例数据部分不对齐时就需要此部分来填充。</p><h2 id="3-对象的访问定位"><a href="#3-对象的访问定位" class="headerlink" title="3. 对象的访问定位"></a><strong>3. 对象的访问定位</strong></h2><p>&emsp;&emsp;如何访问对象？Java定义了reference类型规定了一个指向对象的引用，如何定位和访问堆中对象的物理位置需要VM的实现。主流的访问方式是<strong>句柄</strong>和<strong>直接指针</strong>。</p><h3 id="3-1-句柄"><a href="#3-1-句柄" class="headerlink" title="3.1 句柄"></a><strong>3.1 句柄</strong></h3><p>&emsp;&emsp;Java堆会划分一块内存作为句柄池，reference类型存储对象的<strong>句柄地址</strong>，句柄则包含了对象的实例数据和类型数据的具体地址信息。</p><p><img src="https://pic-1258215793.cos.ap-shanghai.myqcloud.com/content/20190512/%E9%80%9A%E8%BF%87%E5%8F%A5%E6%9F%84%E8%AE%BF%E9%97%AE%E5%AF%B9%E8%B1%A1.png" alt="通过句柄访问对象"></p><h3 id="3-2-直接指针"><a href="#3-2-直接指针" class="headerlink" title="3.2 直接指针"></a><strong>3.2 直接指针</strong></h3><p>&emsp;&emsp;Java堆布局时需要考虑到访问类型数据的信息，所以reference类型存储的是<strong>对象的堆地址</strong></p><p><img src="https://pic-1258215793.cos.ap-shanghai.myqcloud.com/content/20190512/%E9%80%9A%E8%BF%87%E5%8F%A5%E6%9F%84%E8%AE%BF%E9%97%AE%E5%AF%B9%E8%B1%A1.png" alt="通过直接指针访问对象"></p><p>&emsp;&emsp;句柄的优势是reference存储的是稳定的句柄地址，在对象被移动时只会改变句柄中的实例数据指针，而reference类型则无需修改。</p><p>&emsp;&emsp;直接指针的优势是速度更快，节省了一次指针定位的时间开销，因为对象的访问是很频繁的，所以此类开销是很可观的，HotSpot采用直接指针访问。</p><hr><h1 id="三、内存溢出"><a href="#三、内存溢出" class="headerlink" title="三、内存溢出"></a><strong>三、内存溢出</strong></h1><p>&emsp;&emsp;Java的内存区域除了程序计数器外都有发生OutOfMemoryError异常的可能：</p><h3 id="1-Java堆溢出"><a href="#1-Java堆溢出" class="headerlink" title="1. Java堆溢出"></a><strong>1. Java堆溢出</strong></h3><p>&emsp;&emsp;当对象数量超过堆的容量限制产生OOM异常，java.lang.OutOfMemoryError: Java heap space</p><p>&emsp;&emsp;解决方案是通过内存分析工具分析此时内存存储快照中，对象是否是必要的，确认是内存泄露还是内存溢出。</p><p>&emsp;&emsp;如果是内存泄露，可以通过工具进一步查看泄露对象到GC Roots的引用链，所以可以找到泄露对象通过怎样的路径与GC Roots关联导致垃圾收集器无法回收此对象。</p><p>&emsp;&emsp;如果不存在内存泄露，也就是对象都是必要的，就需要检查虚拟机的堆参数（-Xmx与-Xms），看一下是否可以调整一下，检查是否有些可以优化的部分，来减少一些对象的生命周期。降低运行时的内存消耗。</p><h3 id="2-虚拟机栈和本地方法栈溢出"><a href="#2-虚拟机栈和本地方法栈溢出" class="headerlink" title="2. 虚拟机栈和本地方法栈溢出"></a><strong>2. 虚拟机栈和本地方法栈溢出</strong></h3><p>&emsp;&emsp;HotSpot不区分虚拟机栈和本地方法栈，栈容量只由-Xss参数设定。</p><p>&emsp;&emsp;Java虚拟机规范规定了两种异常：1.如果线程请求的栈深度大于虚拟机所允许的最大深度，抛出StackOverflowError异常。2.如果虚拟机在扩展栈时无法申请到足够的内存空间，抛出OutOfMemoryError异常。</p><p>&emsp;&emsp;若栈空间无法继续分配时，如何确定是内存太小还是栈空间太大？</p><p>&emsp;&emsp;通过一些实验证明，在单线程时，无论是栈帧太大还是虚拟机栈容量太小，当内存无法分配时VM都会抛出StackOverflowError异常。多线程时可能会因为创建线程分配资源的问题产生内存溢出异常，此时内存溢出异常和栈空间大小没有太大关系，而且若不能减少线程数时只能通过减少最大堆和栈容量来换取更多的线程。</p><h3 id="3-方法去和运行时常量池溢出"><a href="#3-方法去和运行时常量池溢出" class="headerlink" title="3. 方法去和运行时常量池溢出"></a><strong>3. 方法去和运行时常量池溢出</strong></h3><p>&emsp;&emsp;运行时常量池是方法区的一部分，通过String.intern()方法来测试。</p><blockquote><p>&emsp;String.intern()方法作用：当字符串常量池中已包含某个String对象的字符串，就返回池中此字符串的String对象；否则要将此String对象包含的字符串添加到常量池中，并返回其引用。在1.6版本前常量池在永久代中，可以通过-XX:PermSize和-XX:MaxPermSize限制方法区大小。</p><p>更多可以参考：<a href="../2018122501.html" title="Title">Java字符串内存分配-字符串常量池</a>，<a href="../2019030101.html" title="Title">String的intern方法详解</a>等</p></blockquote><p>&emsp;&emsp;循环调用String.intern()创建字符串对象，会抛出java.lang.OutOfMemoryError: PermGen space异常提示运行时常量池溢出，PermGen space表示了运行时常量池属于方法区/永久代的一部分。</p><p>&emsp;&emsp;通过CGLib字节码技术在运行时动态生成类，模拟方法区溢出场景，因为类要被垃圾回收是比较苛刻的，所以如果需要大量生成类时一定要注意类的回收情况。</p><h3 id="4-本机内存溢出"><a href="#4-本机内存溢出" class="headerlink" title="4. 本机内存溢出"></a><strong>4. 本机内存溢出</strong></h3><p>&emsp;&emsp;Direct Memory容量可以根据-XX: MaxDirectMemorySize指定，默认等于-Xmx数值。</p><p>&emsp;&emsp;通过反射获取Unsafe实例进行内存分配，模拟内存溢出场景，会抛出java.lang.OutOfMemoryError，如果内存溢出时堆转储文件（Heap dump）很小没有异常，且有用到NIO时可以考虑此情况。</p><blockquote><p>更多可以参考：<a href="../2018121801.html" title="Title">Java反射</a>，<a href="../2019040501.html" title="Title">Unsafe类详解</a></p></blockquote><hr><p><em>参考博客和文章书籍等：</em></p><blockquote><p>《深入理解Java虚拟机》</p></blockquote><p><em>因博客主等未标明不可引用，若部分内容涉及侵权请及时告知，我会尽快修改和删除相关内容</em></p>]]></content>
    
    <summary type="html">
    
      简单介绍Java虚拟机中的Java内存区域和内存溢出异常。
    
    </summary>
    
      <category term="技术文档" scheme="http://linyishui.top/categories/%E6%8A%80%E6%9C%AF%E6%96%87%E6%A1%A3/"/>
    
    
      <category term="java" scheme="http://linyishui.top/tags/java/"/>
    
      <category term="jvm" scheme="http://linyishui.top/tags/jvm/"/>
    
  </entry>
  
  <entry>
    <title>抽象类，接口，注解</title>
    <link href="http://linyishui.top/2019050501.html"/>
    <id>http://linyishui.top/2019050501.html</id>
    <published>2019-05-05T09:17:22.000Z</published>
    <updated>2019-06-11T02:37:16.375Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="抽象类"><a href="#抽象类" class="headerlink" title="抽象类"></a><strong>抽象类</strong></h1><p>&emsp;&emsp;如字面意义，就是抽象的类，通过abstract关键字声明某个类或方法是抽象的。</p><p>&emsp;&emsp;抽象类可以包含抽象方法、域、实例方法等，当然在抽象的类中放置具体的数据和方法似乎有些违背其抽象的定义，但在程序设计时一般建议把最通用的域和方法放到顶层基类中，而不用刻意的考虑是否是抽象类。</p><p>&emsp;&emsp;抽象类的扩展可以通过两种方式：</p><ol><li>抽象类定义部分抽象方法或不定义任何抽象方法，这样的话子类就必须是抽象类，要负责声明部分抽象方法</li><li>抽象类定义全部的抽象方法，子类就可以是正常类，无需再声明为抽象类。</li></ol><p>&emsp;&emsp;抽象类不能被实例化，但可以声明抽象类型变量。</p><blockquote><p>类似下列调用a.method()；变量a是抽象类型或接口等都是合法的，因为它们不能实例化，所以会去调用子类或实现类对象。</p></blockquote><hr><h1 id="接口"><a href="#接口" class="headerlink" title="接口"></a><strong>接口</strong></h1><h2 id="简述"><a href="#简述" class="headerlink" title="简述"></a><strong>简述</strong></h2><p>&emsp;&emsp;接口不是类，是对类的一组需求描述，接口定义了一系列行为等，实现此接口的类就必须要包含接口定义的方法。通过implements关键字为类声明要实现哪些接口。</p><h2 id="特性"><a href="#特性" class="headerlink" title="特性"></a><strong>特性</strong></h2><ol><li>接口不是类，接口没有实例，所以不能在接口内引用实例域，也不能通过new去实例化，但可以声明接口变量</li><li>接口不能包含实例域，但可以定义常量，在Java8以后也可以实现方法</li><li>Java8以后也可以声明静态方法，静态方法有些破坏接口的抽象概念，但并不违法</li><li>可以通过在接口引入静态方法或直接实现方法来舍掉伴随类，如常用工具类Collections-Collection</li><li>接口中所有方法自动设置为public，但在类中实现此方法时依然要显示声明public，否则仍为default</li><li>接口中的域自动设为public static final</li><li>接口和类一样可以通过继承来扩展</li><li>类可以实现多个接口，为Java带来了极大的灵活性</li><li>接口的意义之一就是服务于Java的强类型特性，为编译器检查提供遍历。</li><li>可以通过default为接口方法提供一个默认实现，当然每次类实现时会覆盖它</li></ol><h2 id="解决默认方法冲突"><a href="#解决默认方法冲突" class="headerlink" title="解决默认方法冲突"></a><strong>解决默认方法冲突</strong></h2><p>&emsp;&emsp;当在接口中将某方法定义为默认，又在超类或其它接口中定义了同样的方法，则遵从以下规则：</p><ol><li>超类有限，超类若提供了具体方法，则相同参数的默认方法会被忽略</li><li>接口冲突，类实现的多个接口中有同参数同名的方法，其中有默认方法，类会同时得到两个方法，由程序员来实现此方法解决二义性，若没有默认方法，则不存在冲突。</li></ol><h2 id="回调"><a href="#回调" class="headerlink" title="回调"></a><strong>回调</strong></h2><p>&emsp;&emsp;回调是一种常见的设计模式，指定在发生某个事件时采取什么动作，如定时作业，Java中有一个Timer类，可以在一定的时间间隔后发出通告。如果我们构造一个定时器，需要设置一个时间间隔，并告知定时器在到达时间时要做哪些操作。</p><p>&emsp;&emsp;如何告知定时器执行操作？一些语言可以直接指定一个函数名，定时器会周期的调用它，Java则是采用面向对象的方法，它会将某个类的对象传递给定时器，然后定时器会调用此对象的方法，因为对象相比方法来说可以携带更多的信息，因此相比传递函数传递对象会更灵活。</p><figure class="highlight cs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title">ActionListener</span>&#123;<span class="comment">//通过此接口告知定时器要调用的方法，ActionEvent提供了事件的相关信息</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">actionPerformed</span>(<span class="params">ActionEvent <span class="keyword">event</span></span>)</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="比较"><a href="#比较" class="headerlink" title="比较"></a><strong>比较</strong></h2><p>&emsp;&emsp;当需要对对象数组进行排序时，会要求对象实现了Comparable接口，保证了对象是可比较的，排序实际上就是比较交换。当如String等Java提供的类或是不应该覆盖compareTo()方法的类需要有另外一种排序规则时，可以通过比较器Comparator定义一个排序规则，再通过Arrays等工具类进行排序。</p><h2 id="克隆"><a href="#克隆" class="headerlink" title="克隆"></a><strong>克隆</strong></h2><p>&emsp;&emsp;当要克隆一个对象时，要保证对象实现了Cloneable接口，此接口会要求类提供一个安全的clone方法。对象克隆更多内容可以参考<a href="../2018083001.html" title="Title">Java对象克隆</a></p><h2 id="接口和抽象类"><a href="#接口和抽象类" class="headerlink" title="接口和抽象类"></a><strong>接口和抽象类</strong></h2><p>&emsp;&emsp;区别：</p><ol><li>从设计层面来看抽象类更像是对整个类的抽象，接口则是对行为的约束</li><li>抽象类受限于类不支持多继承，而接口则可以实现多重继承</li></ol><hr><h1 id="注解"><a href="#注解" class="headerlink" title="注解"></a><strong>注解</strong></h1><p>&emsp;&emsp;注解是一种标签，告知工具一些信息，使工具可以在源码层次上操作，或处理编译器放置注解的类文件。在Java中类似修饰符，如public等，可以修饰类或成员方法属性，以及局部变量。</p><p>&emsp;&emsp;常见的注解如下：</p><ol><li>@Test 表示类或方法需要测试，并在测试后删除代码，避免在打包时和其它代码装在一起。</li><li>@Override</li></ol><p>&emsp;&emsp;注解可以包含元素，如@Test(timeout = “10000”)，可以被工具读取。</p><p>&emsp;&emsp;注解通过创建注解接口的形式创建，@interface标识注解。</p><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Retention</span>(<span class="type">RetentionPolicy</span>.<span class="type">RUNTIME</span>)</span><br><span class="line"><span class="meta">@Target</span>(&#123;<span class="type">ElementType</span>.<span class="type">METHOD</span>&#125;)<span class="comment">//@Retention和@Target是元注解，标识@Test，使其只能修饰方法，且在虚拟机加载类文件时仍可以保留下来。</span></span><br><span class="line">public <span class="meta">@interface</span> <span class="type">Test</span> &#123;</span><br><span class="line">    <span class="type">Class</span>&lt;? <span class="keyword">extends</span> <span class="type">Throwable</span>&gt; expected() <span class="keyword">default</span> <span class="type">Test</span>.<span class="type">None</span>.<span class="keyword">class</span>;</span><br><span class="line"></span><br><span class="line">    long timeout() <span class="keyword">default</span> <span class="number">0</span>L;<span class="comment">//注解可以指定的参数</span></span><br><span class="line"></span><br><span class="line">    public static <span class="class"><span class="keyword">class</span> <span class="title">None</span> <span class="keyword">extends</span> <span class="title">Throwable</span> </span>&#123;</span><br><span class="line">        <span class="keyword">private</span> static <span class="keyword">final</span> long serialVersionUID = <span class="number">1</span>L;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">private</span> <span class="type">None</span>() &#123;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="用处"><a href="#用处" class="headerlink" title="用处"></a><strong>用处</strong></h2><p>&emsp;&emsp;基本用处：</p><ol><li>附属文件的自动生成，如部署描述符或bean信息类等</li><li>测试，日志，事务语义等代码的自动生成</li></ol><p>&emsp;&emsp;如实现一个监听器，一般通过匿名内部类的方式去创建，就可以通过设计一个注解，标识某个方法，当事件方式时就调用此方法。</p><figure class="highlight aspectj"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br></pre></td><td class="code"><pre><span class="line">    Button button = <span class="keyword">new</span> Button();</span><br><span class="line">    button.addActionListener(<span class="keyword">new</span> ActionListener() &#123;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="keyword">public</span> <span class="function"><span class="keyword">void</span> <span class="title">actionPerformed</span><span class="params">(ActionEvent e)</span> </span>&#123;</span><br><span class="line">            doSomeThing();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//通过注解实现</span></span><br><span class="line">    <span class="meta">@Target</span>(ElementType.METHOD)</span><br><span class="line">    <span class="meta">@Retention</span>(RetentionPolicy.RUNTIME)</span><br><span class="line">    <span class="keyword">public</span> <span class="meta">@interface</span> ActionListenerFor &#123;</span><br><span class="line">        <span class="function">String <span class="title">source</span><span class="params">()</span></span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@ActionListenerFor</span>(source = <span class="string">"button"</span>)</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="function"><span class="keyword">void</span> <span class="title">doSomeThing</span><span class="params">()</span></span>&#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ActionListenerInstaller</span></span>&#123;</span><br><span class="line">   <span class="comment">/**</span></span><br><span class="line"><span class="comment">    * Processes all ActionListenerFor annotations in the given object.</span></span><br><span class="line"><span class="comment">    * <span class="doctag">@param</span> obj an object whose methods may have ActionListenerFor annotations</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">   <span class="keyword">public</span> <span class="keyword">static</span> <span class="function"><span class="keyword">void</span> <span class="title">processAnnotations</span><span class="params">(Object obj)</span></span>&#123;<span class="comment">//枚举出对象接收到的所有方法</span></span><br><span class="line">      <span class="keyword">try</span>&#123;</span><br><span class="line">         Class&lt;?&gt; cl = obj.getClass();</span><br><span class="line">         <span class="keyword">for</span> (Method m : cl.getDeclaredMethods())&#123;<span class="comment">//获取每个方法的ActionListenerFor注解对象，并分别处理</span></span><br><span class="line">            ActionListenerFor a = m.getAnnotation(ActionListenerFor.class);<span class="comment">//通过AnnotationElement接口所提供方法获得注解对象；方法、构造器、域、类和包都实现了此接口</span></span><br><span class="line">            <span class="keyword">if</span> (a != <span class="keyword">null</span>)&#123;</span><br><span class="line">               Field f = cl.getDeclaredField(a.source());<span class="comment">////通过source()获得源成员域，此处只针对成员域，而没有考虑成员变量</span></span><br><span class="line">               f.setAccessible(<span class="keyword">true</span>);</span><br><span class="line">               addListener(f.get(obj), obj, m);<span class="comment">//为每个方法添加一个监听器</span></span><br><span class="line">            &#125;</span><br><span class="line">         &#125;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">catch</span> (ReflectiveOperationException e)&#123;</span><br><span class="line">         e.printStackTrace();</span><br><span class="line">      &#125;</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="comment">/**</span></span><br><span class="line"><span class="comment">    * Adds an action listener that calls a given method.</span></span><br><span class="line"><span class="comment">    * <span class="doctag">@param</span> source the event source to which an action listener is added</span></span><br><span class="line"><span class="comment">    * <span class="doctag">@param</span> param the implicit parameter of the method that the listener calls</span></span><br><span class="line"><span class="comment">    * <span class="doctag">@param</span> m the method that the listener calls</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">   <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> addListener(Object source, <span class="keyword">final</span> Object param, <span class="keyword">final</span> Method m)</span><br><span class="line">         <span class="keyword">throws</span> ReflectiveOperationException&#123;</span><br><span class="line">      InvocationHandler <span class="keyword">handler</span> = <span class="keyword">new</span> InvocationHandler()&#123;<span class="comment">//构造代理，通过反射机制处理注解</span></span><br><span class="line">            <span class="keyword">public</span> <span class="function">Object <span class="title">invoke</span><span class="params">(Object proxy, Method mm, Object[] args)</span> <span class="keyword">throws</span> Throwable</span>&#123;</span><br><span class="line">               <span class="function"><span class="keyword">return</span> m.<span class="title">invoke</span><span class="params">(param)</span></span>;</span><br><span class="line">            &#125;</span><br><span class="line">         &#125;;</span><br><span class="line"></span><br><span class="line">      Object listener = Proxy.newProxyInstance(<span class="keyword">null</span>,</span><br><span class="line">            <span class="keyword">new</span> Class[] &#123; java.awt.event.ActionListener.class &#125;, <span class="keyword">handler</span>);</span><br><span class="line">      Method adder = source.getClass().getMethod(<span class="string">"addActionListener"</span>, ActionListener.class);</span><br><span class="line">      adder.invoke(source, listener);</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>&emsp;&emsp;注解没有处理机制的话和注释也没有太大的区别，实现注解一般会用到代理机制等，可以参考<a href="../2019031501.html" title="Title">代理</a></p><h2 id="注解语法"><a href="#注解语法" class="headerlink" title="注解语法"></a><strong>注解语法</strong></h2><figure class="highlight cs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//注解结构</span></span><br><span class="line">modifers @<span class="keyword">interface</span> <span class="title">AnnotationName</span>&#123;</span><br><span class="line">    elementDeclaration1</span><br><span class="line">    elementDeclaration2</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//元素声明</span></span><br><span class="line"><span class="function">type <span class="title">elementName</span>(<span class="params"></span>)</span>;</span><br><span class="line"><span class="function">type <span class="title">elementName</span>(<span class="params"></span>) <span class="keyword">default</span> <span class="keyword">value</span></span>;</span><br><span class="line"><span class="comment">//注解调用</span></span><br><span class="line">@AnnotationName(elementName1 = value1, elementName2 = value2, ...)</span><br></pre></td></tr></table></figure><p>&emsp;&emsp;elementName1名字为value时可以忽略元素名和等号直接赋值，称为单值注解。</p><p>&emsp;&emsp;所有的注解接口都隐式的扩展自java.lang.annotation.Annotation接口，其为正常接口，而非注解。所有的注解接口都无法再扩展，只能扩展自此接口。</p><p>&emsp;&emsp;注解接口和接口的一个区别就是：注解接口不用提供实现类，而是通过代理机制来生产代理类和对象。</p><blockquote><p>注解元素就是方法声明，其类型只能为：基本类型，String，Class，enum，注解类型，元素为前者的数组。</p></blockquote><blockquote><p>注解内可以含有：包，类（包括enum），接口（包括注解接口），方法，构造器，实例域（包括enum常量），局部变量，参数变量。</p></blockquote><h2 id="元注解"><a href="#元注解" class="headerlink" title="元注解"></a><strong>元注解</strong></h2><table><thead><tr><th style="text-align:center">注解接口</th><th style="text-align:left">应用场合</th><th style="text-align:left">作用</th></tr></thead><tbody><tr><td style="text-align:center"></td></tr></tbody></table><p>Deprecated|全部|将项标记为过时的<br>SuppressWarnings|除了包和注解以外的所有情况|阻止某个给定类型的警告信息<br>Override|方法|检查该方法是否覆盖了某个超类方法<br>PostConstruct|方法|被标记的方法应该在构造之后或移除之前立即被调用<br>PreDestroy||<br>Resource|类、接口、方法、域|在类或接口上：标记为在其它地方要用到的资源。在方法或域上：为”注入”标记<br>Resources|类、接口|一个资源数组<br>Generated|全部|供代码生成工具使用<br>Target|注解|指明可以应用这个注解的哪些项<br>Retention|注解|指明此注解可以保留多久<br>Documented|注解|指明此注解应该包含在注解项的文档中<br>Inherited|注解|指明当这个注解应用于一个类时，能够自动被子类继承</p><p>&emsp;&emsp;用于编译时的注解：@Deprecated、@SuppressWarnings、@Override、@Generated</p><p>&emsp;&emsp;用于管理资源的注解：@PostConstruct、@Resource</p><h2 id="源码级注解处理"><a href="#源码级注解处理" class="headerlink" title="源码级注解处理"></a><strong>源码级注解处理</strong></h2><p>&emsp;&emsp;可以通过注解来自动生成一些代码，如实现Java的Bean信息类，可以通过注解@Property来标记属性的获取器和设置器。</p><figure class="highlight aspectj"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Property</span></span><br><span class="line"><span class="function">String <span class="title">getTitle</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> title;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Property</span>(editor=<span class="string">"TitlePositionEditor"</span>)</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">setTitlePosition</span><span class="params">(<span class="keyword">int</span> p)</span></span>&#123;</span><br><span class="line">    titlePosition = p;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>&emsp;&emsp;为了能自动生成BeanClass信息类，需要完成下列任务：</p><ol><li>编写一个源文件BeanClassBeanInfo.java，继承SimpleBeanInfo，覆盖getPropertyDescriptors()方法。</li><li>对于被注解的方法，去掉get和set前缀，小写化剩余部分可以恢复属性名。</li><li>对于每个属性编写一条用于构建PropertyDescriptor的语句。</li><li>若此属性具有一个编辑器，则要编写一个方法调用setPropertyEditorClass。</li><li>编写代码返回一个包含所有属性描述符的数组。</li></ol><p>&emsp;&emsp;通过一个实例实现@Property对应的注解处理器BeanInfoAnnotationProcessor</p><figure class="highlight stata"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br></pre></td><td class="code"><pre><span class="line">@SupportedAnnotationTypes(<span class="string">"annotation.Property"</span>)</span><br><span class="line">@SupportedSourceVersion(SourceVersion.RELEASE_8)</span><br><span class="line">public <span class="keyword">class</span> BeanInfoAnnotationProcessor extends AbstractProcessor &#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 处理注解声明</span></span><br><span class="line"><span class="comment">     * @param annotations 本轮要处理的注解集</span></span><br><span class="line"><span class="comment">     * @param rounEnv 包含当前处理轮次的有关信息的RoundEnv引用</span></span><br><span class="line"><span class="comment">     * @return</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    @Override</span><br><span class="line">    public boolean process(<span class="keyword">Set</span>&lt;? extends TypeElement&gt; annotations, RoundEnvironment rounEnv) &#123;</span><br><span class="line">        <span class="keyword">for</span> (TypeElement t : annotations)&#123;<span class="comment">//迭代遍历注解过的方法</span></span><br><span class="line">            Map&lt;String,Property&gt; props = new LinkedHashMap&lt;&gt;();</span><br><span class="line">            String beanClassName = null;</span><br><span class="line">            <span class="keyword">for</span>(Element <span class="keyword">e</span> : rounEnv.getElementsAnnotatedWith(t))&#123;</span><br><span class="line">                String mname = <span class="keyword">e</span>.getSimpleName().<span class="keyword">toString</span>();</span><br><span class="line">                String[] prefixes = &#123;<span class="string">"get"</span>,<span class="string">"set"</span>,<span class="string">"is"</span>&#125;;<span class="comment">//剥离定义的前缀</span></span><br><span class="line">                boolean found = false;</span><br><span class="line">                <span class="keyword">for</span>(int i = 0; !found &amp;&amp; i &lt; prefixes.length;i++)&#123;</span><br><span class="line">                    <span class="keyword">if</span>(mname.startsWith(prefixes[i]))&#123;</span><br><span class="line">                        found = true;</span><br><span class="line">                        int start = prefixes[i].<span class="built_in">length</span>();</span><br><span class="line">                        String name = Introspector.decapitalize(mname.substring(start));<span class="comment">//转换小写，得到属性名</span></span><br><span class="line">                        props.put(name,<span class="keyword">e</span>.getAnnotation(Property.<span class="keyword">class</span>));</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span>(!found)&#123;<span class="comment">//未找到合法的注释属性</span></span><br><span class="line">                    processingEnv.getMessager().printMessage(Diagnostic.Kind.<span class="keyword">ERROR</span>,</span><br><span class="line">                            <span class="string">"@Property must be applied to getXxx, setXxx, or isXxx method"</span>,<span class="keyword">e</span>);</span><br><span class="line">                &#125;<span class="keyword">else</span> <span class="keyword">if</span>(beanClassName == null)&#123;</span><br><span class="line">                    beanClassName = ((TypeElement) <span class="keyword">e</span>.getEnclosingElement()).getQualifiedName().<span class="keyword">toString</span>();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            try &#123;</span><br><span class="line">                <span class="keyword">if</span>(beanClassName != null)&#123;</span><br><span class="line">                    writeBeanInfoFile(beanClassName,props);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;catch (IOException <span class="keyword">ex</span>)&#123;</span><br><span class="line">                <span class="keyword">ex</span>.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> true;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    private void writeBeanInfoFile(String beanClassName, Map&lt;String,Property&gt; props)throws IOException&#123;<span class="comment">//编写源文件，生成XxxBeanInfo，processingEnv可以访问各种处理服务</span></span><br><span class="line">        JavaFileObject sourceFile = processingEnv.getFiler().createSourceFile(beanClassName + <span class="string">"BeanInfo"</span>);</span><br><span class="line">        PrintWriter <span class="keyword">out</span> = new PrintWriter(sourceFile.openWriter());</span><br><span class="line">        int i = beanClassName.lastIndexOf(<span class="string">"."</span>);</span><br><span class="line">        <span class="keyword">if</span>(i &gt; 0)&#123;</span><br><span class="line">            <span class="keyword">out</span>.<span class="keyword">print</span>(<span class="string">"package "</span>);</span><br><span class="line">            <span class="keyword">out</span>.<span class="keyword">print</span>(beanClassName.substring(0,i));</span><br><span class="line">            <span class="keyword">out</span>.println(<span class="string">";"</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">out</span>.<span class="keyword">print</span>(<span class="string">"public class "</span>);</span><br><span class="line">        <span class="keyword">out</span>.<span class="keyword">print</span>(beanClassName.substring(i + 1));</span><br><span class="line">        <span class="keyword">out</span>.println(<span class="string">"BeanInfo extends java.beans.SimpleBeanInfo"</span>);</span><br><span class="line">        <span class="keyword">out</span>.println(<span class="string">"&#123;"</span>);</span><br><span class="line">        <span class="keyword">out</span>.println(<span class="string">"    public java.beans.PropertyDescriptor[] getPropertyDescriptors()&#123;"</span>);</span><br><span class="line">        <span class="keyword">out</span>.println(<span class="string">"        try&#123;"</span>);</span><br><span class="line">        <span class="keyword">for</span>(Map.Entry&lt;String,Property&gt; <span class="keyword">e</span> : props.entrySet())&#123;</span><br><span class="line">            <span class="keyword">out</span>.<span class="keyword">print</span>(<span class="string">"            java.beans.PropertyDescriptor "</span>);</span><br><span class="line">            <span class="keyword">out</span>.<span class="keyword">print</span>(<span class="keyword">e</span>.getKey());</span><br><span class="line">            <span class="keyword">out</span>.println(<span class="string">"Descriptor"</span>);</span><br><span class="line">            <span class="keyword">out</span>.<span class="keyword">print</span>(<span class="string">"            = new java.beans.PropertyDescriptor(\"</span>");</span><br><span class="line">            <span class="keyword">out</span>.<span class="keyword">print</span>(<span class="keyword">e</span>.getKey());</span><br><span class="line">            <span class="keyword">out</span>.<span class="keyword">print</span>(<span class="string">"\"</span>,");</span><br><span class="line">            <span class="keyword">out</span>.<span class="keyword">print</span>(beanClassName);</span><br><span class="line">            <span class="keyword">out</span>.println(<span class="string">".class);"</span>);</span><br><span class="line">            String <span class="keyword">ed</span> = <span class="keyword">e</span>.getValue().editor().<span class="keyword">toString</span>();</span><br><span class="line">            <span class="keyword">if</span>(!<span class="keyword">ed</span>.equals(<span class="string">""</span>))&#123;</span><br><span class="line">                <span class="keyword">out</span>.<span class="keyword">print</span>(<span class="string">"            "</span>);</span><br><span class="line">                <span class="keyword">out</span>.<span class="keyword">print</span>(<span class="keyword">e</span>.getKey());</span><br><span class="line">                <span class="keyword">out</span>.<span class="keyword">print</span>(<span class="string">"Descriptor.setPropertyEditorClass("</span>);</span><br><span class="line">                <span class="keyword">out</span>.<span class="keyword">print</span>(<span class="keyword">ed</span>);</span><br><span class="line">                <span class="keyword">out</span>.println(<span class="string">".class);"</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">out</span>.println(<span class="string">"            return new java.beans.PropertyDescriptor[]&#123;"</span>);</span><br><span class="line">        boolean first = true;</span><br><span class="line">        <span class="keyword">for</span>(String p : props.keySet())&#123;</span><br><span class="line">            <span class="keyword">if</span>(first) first = false;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">out</span>.<span class="keyword">print</span>(<span class="string">","</span>);</span><br><span class="line">            <span class="keyword">out</span>.println();</span><br><span class="line">            <span class="keyword">out</span>.<span class="keyword">print</span>(<span class="string">"            "</span>);</span><br><span class="line">            <span class="keyword">out</span>.<span class="keyword">print</span>(p);</span><br><span class="line">            <span class="keyword">out</span>.<span class="keyword">print</span>(<span class="string">"Descriptor"</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">out</span>.println();</span><br><span class="line">        <span class="keyword">out</span>.println(<span class="string">"            &#125;;"</span>);</span><br><span class="line">        <span class="keyword">out</span>.println(<span class="string">"        &#125;"</span>);</span><br><span class="line">        <span class="keyword">out</span>.println(<span class="string">"        catch (java.beans.IntrospectionException e)&#123;"</span>);</span><br><span class="line">        <span class="keyword">out</span>.println(<span class="string">"            e.printStackTrace();"</span>);</span><br><span class="line">        <span class="keyword">out</span>.println(<span class="string">"            return null;"</span>);</span><br><span class="line">        <span class="keyword">out</span>.println(<span class="string">"        &#125;"</span>);</span><br><span class="line">        <span class="keyword">out</span>.println(<span class="string">"    &#125;"</span>);</span><br><span class="line">        <span class="keyword">out</span>.println(<span class="string">"&#125;"</span>);</span><br><span class="line">        <span class="keyword">out</span>.<span class="keyword">close</span>();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>&emsp;&emsp;被注解文件ChartBean</p><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">public <span class="class"><span class="keyword">class</span> <span class="title">ChartBean</span> <span class="keyword">extends</span> <span class="title">JComponent</span></span>&#123;</span><br><span class="line">    ...</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Gets the title property.</span></span><br><span class="line"><span class="comment">     * @return the chart title.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Property</span></span><br><span class="line">    public <span class="type">String</span> getTitle()</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> title;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>&emsp;&emsp;通过编译生成对应ChartBeanBeanInfo.java等文件</p><figure class="highlight capnproto"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">&gt;javac  -encoding UTF-<span class="number">8</span> <span class="keyword">annotation</span>/BeanInfoAnnotationProcessor.java</span><br><span class="line">&gt;javac  -XprintRounds -processor <span class="keyword">annotation</span>.BeanInfoAnnotationProcessor <span class="keyword">annotation</span>/ChartBean.java</span><br><span class="line"></span><br><span class="line">循环 <span class="number">1</span>:</span><br><span class="line">        输入文件: &#123;<span class="keyword">annotation</span>.ChartBean&#125;</span><br><span class="line">        注释: [java.lang.Override, <span class="keyword">annotation</span>.Property]</span><br><span class="line">        最后一个循环: <span class="literal">false</span></span><br><span class="line">循环 <span class="number">2</span>:</span><br><span class="line">        输入文件: &#123;<span class="keyword">annotation</span>.ChartBeanBeanInfo&#125;</span><br><span class="line">        注释: []</span><br><span class="line">        最后一个循环: <span class="literal">false</span></span><br><span class="line">循环 <span class="number">3</span>:</span><br><span class="line">        输入文件: &#123;&#125;</span><br><span class="line">        注释: []</span><br><span class="line">        最后一个循环: <span class="literal">true</span></span><br></pre></td></tr></table></figure><p>&emsp;&emsp;注解会未标注的方法创建ChartBeanBeanInfo文件，并实现getPropertyDescriptors()函数</p><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> annotation;</span><br><span class="line">public <span class="class"><span class="keyword">class</span> <span class="title">ChartBeanBeanInfo</span> <span class="keyword">extends</span> <span class="title">java</span>.<span class="title">beans</span>.<span class="title">SimpleBeanInfo</span></span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">    public java.beans.<span class="type">PropertyDescriptor</span>[] getPropertyDescriptors()&#123;</span><br><span class="line">        <span class="keyword">try</span>&#123;</span><br><span class="line">            java.beans.<span class="type">PropertyDescriptor</span> titleDescriptor</span><br><span class="line">            = <span class="keyword">new</span> java.beans.<span class="type">PropertyDescriptor</span>(<span class="string">"title"</span>,annotation.<span class="type">ChartBean</span>.<span class="keyword">class</span>);</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">new</span> java.beans.<span class="type">PropertyDescriptor</span>[]&#123;</span><br><span class="line"></span><br><span class="line">            titleDescriptor</span><br><span class="line">            &#125;;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">catch</span> (java.beans.<span class="type">IntrospectionException</span> e)&#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="字节码级注解处理"><a href="#字节码级注解处理" class="headerlink" title="字节码级注解处理"></a><strong>字节码级注解处理</strong></h2><p>&emsp;&emsp;字节码级注解处理会一直存在于类文件中。</p><p>&emsp;&emsp;假如某类的hacode()方法有以下注解：</p><figure class="highlight less"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable">@Override</span></span><br><span class="line"><span class="variable">@LogEntry</span>(logger = <span class="string">"global"</span>)</span><br><span class="line">public int hashCode() &#123;</span><br><span class="line">    <span class="selector-tag">return</span> <span class="selector-tag">super</span><span class="selector-class">.hashCode</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>&emsp;&emsp;当此方法被调用时，会打印类似日志消息：<br><figure class="highlight armasm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="symbol">Aug</span> <span class="number">17</span>, <span class="number">2004</span> <span class="number">9</span>:<span class="number">32</span>:<span class="number">59</span> PM <span class="keyword">Item </span>hashCode</span><br><span class="line"><span class="symbol">FINER</span>: <span class="meta">ENTRY</span></span><br></pre></td></tr></table></figure></p><p>&emsp;&emsp;为了实现此注解功能，需要完成下列任务：</p><ol><li>加载类文件中的字节码。</li><li>定位所有的方法。</li><li>对于每个方法，检查其是不是有一个@LogEntry注解。</li><li>如果有，则在方法开始部分添加以下字节码。</li></ol><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">ldc loggerName</span><br><span class="line">invokestatic java<span class="regexp">/util/</span>logging<span class="regexp">/Logger.getLogger:(Ljava/</span>lang<span class="regexp">/String;)Ljava/u</span>til<span class="regexp">/logging/</span>Logger;</span><br><span class="line">ldc className</span><br><span class="line">ldc methodName</span><br><span class="line">invokevirtual java<span class="regexp">/util/</span>logging<span class="regexp">/Logger.entering:(Ljava/</span>lang<span class="regexp">/String;Ljava/</span>lang<span class="regexp">/String;)V</span></span><br></pre></td></tr></table></figure><p>&emsp;&emsp;BCEL即字节码工程类库，即可以处理类文件的特殊类库。ASM则是一个java字节码操纵框架，可以用来动态生成类或者增强既有类的功能。ASM 可以直接产生二进制 class 文件，也可以在类被加载入 Java 虚拟机之前动态改变类行为。</p><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">javac annotation/set/Item.java</span><br><span class="line">javac -classpath .:asm-<span class="number">6.2</span><span class="selector-class">.jar</span> annotation/bytecodeAnnotations/EntryLogger</span><br><span class="line">javap -c Item.java</span><br><span class="line">javac -classpath .:asm-<span class="number">6.2</span><span class="selector-class">.jar</span> annotation/bytecodeAnnotations/EntryLogger set.Item</span><br><span class="line"></span><br><span class="line">javac -classpath .:asm-<span class="number">6.2</span><span class="selector-class">.jar</span> annotation/bytecodeAnnotations/EntryLoggerAgent</span><br><span class="line">jar</span><br><span class="line"></span><br><span class="line">javac annotation/set/SetTest.java</span><br><span class="line">java -javaagent:annotation/bytecodeAnnotations/EntryLoggingAgent.jar=set<span class="selector-class">.Item</span> -classpath .:asm-<span class="number">6.2</span><span class="selector-class">.jar</span> set.SetTest</span><br></pre></td></tr></table></figure><h2 id="emsp-emsp-在加载时修改字节码，Java5以后可以通过代理的方式，通过监视程序运行，检验后调用类转换器修改字节码，将结果直接返回给JVM加载，即即使字节码修改。"><a href="#emsp-emsp-在加载时修改字节码，Java5以后可以通过代理的方式，通过监视程序运行，检验后调用类转换器修改字节码，将结果直接返回给JVM加载，即即使字节码修改。" class="headerlink" title="&emsp;&emsp;在加载时修改字节码，Java5以后可以通过代理的方式，通过监视程序运行，检验后调用类转换器修改字节码，将结果直接返回给JVM加载，即即使字节码修改。"></a>&emsp;&emsp;在加载时修改字节码，Java5以后可以通过代理的方式，通过监视程序运行，检验后调用类转换器修改字节码，将结果直接返回给JVM加载，即<strong>即使字节码修改</strong>。</h2><p><em>参考博客和文章书籍等：</em></p><blockquote><p>《Java语言规范》</p></blockquote><blockquote><p>《Java核心技术 卷Ⅰ》</p></blockquote><blockquote><p>《Java核心技术 卷Ⅱ》</p></blockquote><p><em>因博客主等未标明不可引用，若部分内容涉及侵权请及时告知，我会尽快修改和删除相关内容</em></p>]]></content>
    
    <summary type="html">
    
      接口，抽象类，注解
    
    </summary>
    
      <category term="技术文档" scheme="http://linyishui.top/categories/%E6%8A%80%E6%9C%AF%E6%96%87%E6%A1%A3/"/>
    
    
      <category term="java" scheme="http://linyishui.top/tags/java/"/>
    
  </entry>
  
  <entry>
    <title>算法复习 (二) 查找-篇Ⅱ</title>
    <link href="http://linyishui.top/2019042901.html"/>
    <id>http://linyishui.top/2019042901.html</id>
    <published>2019-04-29T08:50:58.000Z</published>
    <updated>2019-04-29T08:58:04.000Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script>]]></content>
    
    <summary type="html">
    
      查找篇Ⅱ包括：平衡查找树等内容
    
    </summary>
    
      <category term="技术文档" scheme="http://linyishui.top/categories/%E6%8A%80%E6%9C%AF%E6%96%87%E6%A1%A3/"/>
    
    
      <category term="algorithm" scheme="http://linyishui.top/tags/algorithm/"/>
    
  </entry>
  
  <entry>
    <title>Jpa和JDBC等批量插入比较</title>
    <link href="http://linyishui.top/2019042801.html"/>
    <id>http://linyishui.top/2019042801.html</id>
    <published>2019-04-28T09:17:59.000Z</published>
    <updated>2019-04-28T09:34:54.000Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>&emsp;&emsp;以前在写一些批量操作时感觉JPA提供的数组操作效率很差，所以就尝试用EntityManager进行批量提交来提高效率，最近有时间并将JdbcTemplate也加入对比了一下它们的执行效率。</p><p>&emsp;&emsp;pom.xml</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-data-jpa<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-jdbc<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure><p>&emsp;&emsp;application.properties配置批量大小</p><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">spring<span class="selector-class">.jpa</span><span class="selector-class">.properties</span><span class="selector-class">.hibernate</span><span class="selector-class">.jdbc</span><span class="selector-class">.batch_size</span> = <span class="number">1000</span></span><br></pre></td></tr></table></figure><p>&emsp;&emsp;第一种方法：通过EntityManager，定制批量插入</p><figure class="highlight less"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable">@Repository</span></span><br><span class="line">public class BatchOpsRepositoryImpl&lt;T&gt; implements BatchOpsRepository&lt;T&gt; &#123;</span><br><span class="line">    <span class="variable">@Qualifier</span>(<span class="string">"entityManagerFactorySqlServer"</span>)</span><br><span class="line">    <span class="variable">@Autowired</span></span><br><span class="line">    private EntityManager em;</span><br><span class="line"></span><br><span class="line">    <span class="variable">@Modifying</span></span><br><span class="line">    <span class="variable">@Transactional</span>(value = <span class="string">"transactionManagerSqlServer"</span>)</span><br><span class="line">    public void batchInsert(List&lt;T&gt; list) &#123;</span><br><span class="line">        <span class="selector-tag">for</span> (int i = <span class="number">0</span>; i &lt; list.size(); i++) &#123;</span><br><span class="line">            <span class="selector-tag">em</span><span class="selector-class">.persist</span>(list.get(i));</span><br><span class="line">            <span class="selector-tag">if</span> (i % <span class="number">1000</span> == <span class="number">0</span> || i == (list.size() - <span class="number">1</span>)) &#123;<span class="comment">//1000条执行一次，或不足1000条</span></span><br><span class="line">                <span class="selector-tag">System</span><span class="selector-class">.out</span><span class="selector-class">.println</span>(<span class="string">"1000条执行一次，或不足1000条"</span>);</span><br><span class="line">                <span class="selector-tag">em</span><span class="selector-class">.flush</span>();</span><br><span class="line">                <span class="selector-tag">em</span><span class="selector-class">.clear</span>();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @<span class="selector-tag">Modifying</span></span><br><span class="line">    @<span class="selector-tag">Transactional</span>(value = <span class="string">"transactionManagerSqlServer"</span>)</span><br><span class="line">    <span class="selector-tag">public</span> <span class="selector-tag">void</span> <span class="selector-tag">batchUpdate</span>(List&lt;T&gt; list) &#123;</span><br><span class="line">        <span class="selector-tag">for</span> (int i = <span class="number">0</span>; i &lt; list.size(); i++) &#123;</span><br><span class="line">            <span class="selector-tag">em</span><span class="selector-class">.merge</span>(list.get(i));</span><br><span class="line">            <span class="selector-tag">if</span> (i % <span class="number">1000</span> == <span class="number">0</span> || i == (list.size() - <span class="number">1</span>)) &#123;<span class="comment">//1000条执行一次，或不足1000条</span></span><br><span class="line">                <span class="selector-tag">System</span><span class="selector-class">.out</span><span class="selector-class">.println</span>(<span class="string">"1000条执行一次，或不足1000条"</span>);</span><br><span class="line">                <span class="selector-tag">em</span><span class="selector-class">.flush</span>();</span><br><span class="line">                <span class="selector-tag">em</span><span class="selector-class">.clear</span>();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>&emsp;&emsp;第二种方法，直接使用repository.saveAll();</p><p>&emsp;&emsp;第三种方法，使用jdbcTemplate.batchUpdate();</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">@Autowired</span><br><span class="line"><span class="keyword">private</span> JdbcTemplate jdbcTemplate;</span><br><span class="line"><span class="comment">//JDBC批量存储</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">batchInsertStationInfo</span><span class="params">(List&lt;StationInfo&gt; <span class="built_in">list</span>)</span></span>&#123;</span><br><span class="line">    jdbcTemplate.batchUpdate(<span class="string">"INSERT INTO T_XXXX (DM,JM,MC,CS,GS) VALUES (?,?,?,?,?);"</span>, <span class="keyword">new</span> BatchPreparedStatementSetter() &#123;</span><br><span class="line">        @Override</span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">void</span> setValues(PreparedStatement preparedStatement, <span class="keyword">int</span> i) throws SQLException &#123;</span><br><span class="line">            preparedStatement.setString(<span class="number">1</span>,<span class="built_in">list</span>.get(i).getDm());</span><br><span class="line">            preparedStatement.setString(<span class="number">2</span>,<span class="built_in">list</span>.get(i).getJm());</span><br><span class="line">            preparedStatement.setString(<span class="number">3</span>,<span class="built_in">list</span>.get(i).getMc());</span><br><span class="line">            preparedStatement.setString(<span class="number">4</span>,<span class="built_in">list</span>.get(i).getCs());</span><br><span class="line">            preparedStatement.setString(<span class="number">5</span>,<span class="built_in">list</span>.get(i).getGs());</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        @Override</span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">int</span> getBatchSize() &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="built_in">list</span>.size();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>&emsp;&emsp;执行测试，数据量大约5000。</p><figure class="highlight gauss"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//先清除原数据</span></span><br><span class="line">stationInfoRepository.deleteAllInBatch();</span><br><span class="line">long startTime=<span class="keyword">System</span>.currentTimeMillis();   <span class="comment">//获取开始时间</span></span><br><span class="line">batchOpsRepository.batchInsert(infos);</span><br><span class="line">long endTime=<span class="keyword">System</span>.currentTimeMillis(); <span class="comment">//获取结束时间</span></span><br><span class="line"></span><br><span class="line">stationInfoRepository.deleteAllInBatch();</span><br><span class="line">long startTime1=<span class="keyword">System</span>.currentTimeMillis();   <span class="comment">//获取开始时间</span></span><br><span class="line">stationInfoRepository.<span class="keyword">saveAll</span>(infos);</span><br><span class="line">long endTime1=<span class="keyword">System</span>.currentTimeMillis(); <span class="comment">//获取结束时间</span></span><br><span class="line"></span><br><span class="line">stationInfoRepository.deleteAllInBatch();</span><br><span class="line">long startTime2=<span class="keyword">System</span>.currentTimeMillis();   <span class="comment">//获取开始时间</span></span><br><span class="line">batchInsertStationInfo(infos);</span><br><span class="line">long endTime2=<span class="keyword">System</span>.currentTimeMillis(); <span class="comment">//获取结束时间</span></span><br><span class="line"><span class="keyword">System</span>.out.println(<span class="string">"batchInsert运行时间： "</span>+(endTime-startTime)+<span class="string">"ms"</span>);</span><br><span class="line"><span class="keyword">System</span>.out.println(<span class="string">"saveAll运行时间： "</span>+(endTime1-startTime1)+<span class="string">"ms"</span>);</span><br><span class="line"><span class="keyword">System</span>.out.println(<span class="string">"jdbc运行时间： "</span>+(endTime2-startTime2)+<span class="string">"ms"</span>);</span><br></pre></td></tr></table></figure><p>&emsp;&emsp;运行结果如下。</p><figure class="highlight lsl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">batchInsert运行时间： <span class="number">3236</span>ms</span><br><span class="line">saveAll运行时间： <span class="number">32288</span>ms</span><br><span class="line">jdbc运行时间： <span class="number">2179</span>ms</span><br></pre></td></tr></table></figure><p>&emsp;&emsp;调试可以发现，batchInsert每隔1000条提交一次数据库操作，saveAll则需要在新增前做查询服务，并且每次提交一条新增服务，而JDBC则是效率最高的一个。</p><p>&emsp;&emsp;batchInsert相较jdbc，效率相差不大，且代码量小，所以选择继续使用batchInsert</p>]]></content>
    
    <summary type="html">
    
      通过实例对比了Jpa和JDBC等批量插入的执行效率。
    
    </summary>
    
      <category term="技术文档" scheme="http://linyishui.top/categories/%E6%8A%80%E6%9C%AF%E6%96%87%E6%A1%A3/"/>
    
    
      <category term="Jpa" scheme="http://linyishui.top/tags/Jpa/"/>
    
      <category term="Jdbc" scheme="http://linyishui.top/tags/Jdbc/"/>
    
  </entry>
  
  <entry>
    <title>Spring Cache</title>
    <link href="http://linyishui.top/2019042502.html"/>
    <id>http://linyishui.top/2019042502.html</id>
    <published>2019-04-25T07:59:17.000Z</published>
    <updated>2019-04-28T03:42:18.000Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="数据缓存Cache"><a href="#数据缓存Cache" class="headerlink" title="数据缓存Cache"></a><strong>数据缓存Cache</strong></h1><blockquote><p><strong>为什么要使用缓存技术？</strong></p><p>&emsp;&emsp;内存的速度是远大于硬盘的，项目在运行时的瓶颈往往在数据库，当一些数据是重复且频繁使用时，需要一次一次的请求数据库或远程服务，所以如果能把这部分数据缓存起来，就可以提升一部分性能。</p></blockquote><hr><h2 id="Spring-Boot缓存支持"><a href="#Spring-Boot缓存支持" class="headerlink" title="Spring Boot缓存支持"></a><strong>Spring Boot缓存支持</strong></h2><p>&emsp;&emsp;Spring通过抽象接口CacheManager和Cache来统一不同的缓存技术。</p><p>CacheManager|描述<br>|:—:|:—|<br>SimpleCacheManager|使用简单的Collection来存储缓存，主要用来测试<br>ConcurrentCacheManager|使用ConcurrentMap来存储缓存<br>NoOpCacheManager|仅测试，并没有实际存储缓存<br>EhCacheCacheManager|使用EhCache作为缓存技术<br>GuavaCacheManager|使用Google Guava的Guava Cache作为缓存技术<br>HazelcastCacheManager|使用Hazelcast作为缓存技术<br>JCacheCacheManager|使用JCache标准的实现作为缓存技术，如Apache Commons JCS<br>RedisCacheManager|使用Redis作为缓存技术</p><p>&emsp;&emsp;Spring需要根据不同的缓存技术配置不同的CacheManager等。</p><p>&emsp;&emsp;Spring提供了四个注解来声明缓存规则。</p><p>注解|描述<br>|:—:|:—|<br>@Cacheable|在方法执行前先查看缓存中是否有数据，若有则返回缓存数据，没有则调用方法并将返回值放入缓存<br>@CachePut|无论如何都会将方法返回值放入缓存<br>@CacheEvict|将一条或多条数据从缓存中删除<br>@Caching|可以通过此注解组合多个策略在一个方法上</p><p>&emsp;&emsp;开启声明式缓存支持，只要在配置类使用@EnableCaching注解即可</p><p>&emsp;&emsp;Spring Boot则自动化了配置过程，如下所示，Spring Boot自动生成了如下文件。</p><p><img src="https://pic-1258215793.cos.ap-shanghai.myqcloud.com/content/20190316/201903160121.png" alt=""></p><p>&emsp;&emsp;Spring Boot环境下使用缓存技术只需要导入要使用的缓存技术的依赖包，然后在配置类使用@EnableCaching开启缓存支持即可，通过一个实战可以简单学习一下如何在Spring Boot中使用某个缓存技术。</p><hr><h2 id="测试代码"><a href="#测试代码" class="headerlink" title="测试代码"></a><strong>测试代码</strong></h2><p>&emsp;&emsp;pom.xml</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-cache<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>net.sf.ehcache<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>ehcache<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure><p>&emsp;&emsp;application.properties</p><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">#缓存配置</span><br><span class="line">spring<span class="selector-class">.cache</span><span class="selector-class">.type</span>=ehcache</span><br><span class="line">#程序启动时创建缓存名称</span><br><span class="line">spring<span class="selector-class">.cache</span><span class="selector-class">.cache-names</span>=testCache</span><br><span class="line">#ehcache配置文件地址</span><br><span class="line">spring<span class="selector-class">.cache</span><span class="selector-class">.ehcache</span><span class="selector-class">.config</span>=classpath:/config/ehcache.xml</span><br></pre></td></tr></table></figure><p>&emsp;&emsp;ehcache.xml</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="php"><span class="meta">&lt;?</span>xml version=<span class="string">"1.0"</span> encoding=<span class="string">"UTF-8"</span><span class="meta">?&gt;</span></span></span><br><span class="line"><span class="tag">&lt;<span class="name">ehcache</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">cache</span> <span class="attr">name</span>=<span class="string">"users"</span> <span class="attr">maxElementsInMemory</span>=<span class="string">"200"</span> /&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">ehcache</span>&gt;</span></span><br></pre></td></tr></table></figure><p>&emsp;&emsp;启动类TestprojectApplication</p><figure class="highlight less"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable">@SpringBootApplication</span></span><br><span class="line"><span class="variable">@Component</span></span><br><span class="line"><span class="variable">@EnableCaching</span> <span class="comment">//开启声明式缓存</span></span><br><span class="line">public class TestprojectApplication &#123;</span><br><span class="line">    <span class="selector-tag">public</span> <span class="selector-tag">static</span> <span class="selector-tag">void</span> <span class="selector-tag">main</span>(String[] args) &#123;</span><br><span class="line">        <span class="selector-tag">SpringApplication</span><span class="selector-class">.run</span>(TestprojectApplication.class, args);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>&emsp;&emsp;实体类UserInfo</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Data</span></span><br><span class="line"><span class="meta">@Getter</span></span><br><span class="line"><span class="meta">@Setter</span></span><br><span class="line"><span class="meta">@NoArgsConstructor</span></span><br><span class="line"><span class="meta">@AllArgsConstructor</span></span><br><span class="line"><span class="meta">@Entity</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> UserInfo &#123;</span><br><span class="line">    <span class="meta">@Id</span></span><br><span class="line">    <span class="keyword">private</span> <span class="built_in">String</span> userId;</span><br><span class="line">    <span class="keyword">private</span> <span class="built_in">String</span> userName;</span><br><span class="line">    <span class="keyword">private</span> <span class="built_in">String</span> password;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="built_in">String</span> toString()&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">"[userId : "</span> + userId + <span class="string">" userName : "</span> + userName + <span class="string">" password : "</span> + password + <span class="string">"]"</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>&emsp;&emsp;服务层UserServiceImpl，实现@CachePut，@CacheEvict，@Cacheable的对应方法。</p><figure class="highlight aspectj"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Service</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">UserServiceImpl</span> <span class="keyword">implements</span> <span class="title">UserService</span></span>&#123;</span><br><span class="line">    <span class="keyword">private</span> Logger logger = Logger.getLogger(UserServiceImpl.class);</span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    UserRepository userRepository;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="meta">@CachePut</span>(value = <span class="string">"users"</span>,key = <span class="string">"#userInfo.userId"</span>) <span class="comment">//更新数据到缓存</span></span><br><span class="line">    <span class="keyword">public</span> <span class="function">UserInfo <span class="title">save</span><span class="params">(UserInfo userInfo)</span> </span>&#123;</span><br><span class="line">        logger.info(<span class="string">"为"</span>+ userInfo.toString() + <span class="string">"做了缓存"</span>);</span><br><span class="line">        <span class="function"><span class="keyword">return</span> userRepository.<span class="title">saveAndFlush</span><span class="params">(userInfo)</span></span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="meta">@CacheEvict</span>(value = <span class="string">"users"</span>) <span class="comment">//从缓存删除数据</span></span><br><span class="line">    <span class="keyword">public</span> <span class="function"><span class="keyword">void</span> <span class="title">remove</span><span class="params">(String userId)</span> </span>&#123;</span><br><span class="line">        logger.info(<span class="string">"删除"</span>+ userId + <span class="string">"缓存数据"</span>);</span><br><span class="line">        userRepository.deleteById(userId);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="meta">@Cacheable</span>(value = <span class="string">"users"</span>,key = <span class="string">"#userInfo.userId"</span>) <span class="comment">//取缓存数据</span></span><br><span class="line">    <span class="keyword">public</span> <span class="function">UserInfo <span class="title">findOne</span><span class="params">(UserInfo userInfo)</span> </span>&#123;</span><br><span class="line">        UserInfo u = userRepository.findByUserId(userInfo.getUserId());</span><br><span class="line">        logger.info(<span class="string">"为"</span>+ u.toString() + <span class="string">"做了缓存"</span>);</span><br><span class="line">        <span class="keyword">return</span> u;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>&emsp;&emsp;控制层CacheController</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@RestController</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">CacheController</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    UserService userService;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@RequestMapping(<span class="meta-string">"/put"</span>)</span></span><br><span class="line">    <span class="keyword">public</span> UserInfo put(<span class="meta">@RequestBody</span> UserInfo userInfo)&#123;</span><br><span class="line">        <span class="keyword">return</span> userService.save(userInfo);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@RequestMapping(<span class="meta-string">"/able"</span>)</span></span><br><span class="line">    <span class="keyword">public</span> UserInfo cacheable(UserInfo userInfo)&#123;</span><br><span class="line">        <span class="keyword">return</span> userService.findOne(userInfo);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@RequestMapping(<span class="meta-string">"/evit"</span>)</span></span><br><span class="line">    <span class="keyword">public</span> String evit(String userId)&#123;</span><br><span class="line">        userService.remove(userId);</span><br><span class="line">        <span class="keyword">return</span> <span class="string">"ok"</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><h2 id="执行结果"><a href="#执行结果" class="headerlink" title="执行结果"></a><strong>执行结果</strong></h2><p>&emsp;&emsp;测试@Cacheable，查询某条数据，观察输出过程和结果。</p><blockquote><p><a href="http://localhost:8080/able?userId=0001" target="_blank" rel="noopener">http://localhost:8080/able?userId=0001</a></p></blockquote><figure class="highlight groovy"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">Hibernate:</span> select userinfo0_.userId <span class="keyword">as</span> userId1_1_, userinfo0_.password <span class="keyword">as</span> password2_1_, userinfo0_.userName <span class="keyword">as</span> userName3_1_ from UserInfo userinfo0_ where userinfo0_.userId=?</span><br><span class="line">10:<span class="number">41</span>:<span class="number">30</span>,<span class="number">207</span>  INFO <span class="string">UserServiceImpl:</span><span class="number">43</span> - 为[<span class="string">userId :</span> <span class="number">0001</span> <span class="string">userName :</span> 阿大 <span class="string">password :</span> <span class="number">123456</span>]做了缓存</span><br><span class="line"></span><br><span class="line">&#123;</span><br><span class="line">    <span class="string">"userId"</span>: <span class="string">"0001"</span>,</span><br><span class="line">    <span class="string">"userName"</span>: <span class="string">"阿大"</span>,</span><br><span class="line">    <span class="string">"password"</span>: <span class="string">"123456"</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>&emsp;&emsp;再次访问并观察</p><blockquote><p><a href="http://localhost:8080/able?userId=0001" target="_blank" rel="noopener">http://localhost:8080/able?userId=0001</a></p></blockquote><p>&emsp;&emsp;控制台没有Hibernate数据库查询，和为…做了缓存输出，表示直接从缓存中读取数据。</p><p>&emsp;&emsp;测试@CachePut，新增某条数据，观察输出过程和结果。</p><blockquote><p><a href="http://localhost:8080/put{&quot;userId&quot;" target="_blank" rel="noopener">http://localhost:8080/put{&quot;userId&quot;</a> : “0003”,”userName” : “阿三”,”password” : “123456”}</p></blockquote><figure class="highlight pf"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">10</span>:<span class="number">44</span>:<span class="number">59</span>,<span class="number">720</span>  INFO UserServiceImpl:<span class="number">28</span> - 为[<span class="keyword">user</span>Id : <span class="number">0003</span> <span class="keyword">user</span>Name : 阿三 password : <span class="number">123456</span>]做了缓存</span><br><span class="line">Hibernate: select userinfo0_.<span class="keyword">user</span>Id as <span class="keyword">user</span>Id1_1_0_, userinfo0_.password as password2_1_0_, userinfo0_.<span class="keyword">user</span>Name as <span class="keyword">user</span>Name3_1_0_ <span class="keyword">from</span> UserInfo userinfo0_ where userinfo0_.<span class="keyword">user</span>Id=?</span><br><span class="line">Hibernate: insert into UserInfo (password, <span class="keyword">user</span>Name, <span class="keyword">user</span>Id) values (?, ?, ?)</span><br><span class="line"></span><br><span class="line">&#123;</span><br><span class="line">    <span class="string">"userId"</span>: <span class="string">"36efc2fb-eb0a-4e69-a179-4ad82f4df1bc"</span>,</span><br><span class="line">    <span class="string">"userName"</span>: <span class="string">"阿三"</span>,</span><br><span class="line">    <span class="string">"password"</span>: <span class="string">"123456"</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>&emsp;&emsp;继续查询此条新增数据，发现直接从缓存中读取并返回。</p><blockquote><p><a href="http://localhost:8080/able?userId=0003" target="_blank" rel="noopener">http://localhost:8080/able?userId=0003</a></p></blockquote><p>&emsp;&emsp;测试@CacheEvict，先查询某条数据，确认其被缓存，然后测试删除。</p><figure class="highlight n1ql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">10:<span class="number">54</span>:<span class="number">07</span>,<span class="number">214</span>  INFO UserServiceImpl:<span class="number">35</span> - 删除<span class="number">0003</span>缓存数据</span><br><span class="line">Hibernate: <span class="keyword">select</span> userinfo0_.userId <span class="keyword">as</span> userId1_1_0_, userinfo0_.<span class="keyword">password</span> <span class="keyword">as</span> password2_1_0_, userinfo0_.userName <span class="keyword">as</span> userName3_1_0_ <span class="keyword">from</span> UserInfo userinfo0_ <span class="keyword">where</span> userinfo0_.userId=?</span><br><span class="line">Hibernate: <span class="keyword">delete</span> <span class="keyword">from</span> UserInfo <span class="keyword">where</span> userId=?</span><br></pre></td></tr></table></figure><p>&emsp;&emsp;再次访问发现无法查询此数据，表示缓存和数据库都已删除。</p><hr><p><em>参考博客和文章书籍等：</em></p><blockquote><p>《Spring Boot 实战》</p></blockquote><p><em>因博客主等未标明不可引用，若部分内容涉及侵权请及时告知，我会尽快修改和删除相关内容</em></p>]]></content>
    
    <summary type="html">
    
      简单介绍Spring对数据缓存的支持，通过实战用例简单的使用缓存。
    
    </summary>
    
      <category term="技术文档" scheme="http://linyishui.top/categories/%E6%8A%80%E6%9C%AF%E6%96%87%E6%A1%A3/"/>
    
    
      <category term="spring" scheme="http://linyishui.top/tags/spring/"/>
    
      <category term="cache" scheme="http://linyishui.top/tags/cache/"/>
    
  </entry>
  
  <entry>
    <title>分库分表</title>
    <link href="http://linyishui.top/2019042501.html"/>
    <id>http://linyishui.top/2019042501.html</id>
    <published>2019-04-25T06:19:41.000Z</published>
    <updated>2019-04-25T06:25:04.000Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><p><em>暂时只是阅读并整理了一下相关内容，待抽时间实践后会重构一下本博文</em></p><h1 id="分库分表"><a href="#分库分表" class="headerlink" title="分库分表"></a><strong>分库分表</strong></h1><p>&emsp;&emsp;<strong>什么是分库分表技术，为什么要分库分表？</strong></p><p>&emsp;&emsp;当项目数据不断积累，达到一定程度后，即使是通过优化索引，添加从库进行读写分离等方式进行优化可能也无法解决数据库的瓶颈问题，此时需要通过切分数据库到多个不同数据库来解决单一数据库的性能问题。</p><p>&emsp;&emsp;主要为<strong>垂直切分</strong>和<strong>水平切分</strong>，垂直切分就是模块划分，把同一个模块或者说联系紧密的表切分到一个server上，适合于因为表多而导致数据量大的场景；而水平切分则是把表按照某种规则(比如对ID进行散列)切分到不同的server上，适合单表数据过多导致数据量大的场景。</p><p>&emsp;&emsp;实际场景中往往需要综合两种切分，将原数据库切分为可无限扩充的数据库阵列。需要注意的是若综合使用时，切分策略可能会相互影响，如引入水平切分后，表间的关联关系就会受到制约，一般只允许主表(即散列的表)和其次表之间保持关联，所以就不能简单的以功能模块来划分，而是要更加细粒度的进行垂直切分，此概念类似于领域驱动设计中的”聚合”，每个划分(shard)的主表都是一个聚合中的聚合根。为了避免过度的切分，需要考虑将业务接近，数据增长速率接近的shard合并到一个数据源中，每个shard都还是独立的，不同的是他们的散列取模即节点数量需要一致。</p><h1 id="分库分表要解决的问题"><a href="#分库分表要解决的问题" class="headerlink" title="分库分表要解决的问题"></a><strong>分库分表要解决的问题</strong></h1><h2 id="1、跨节点Join的问题"><a href="#1、跨节点Join的问题" class="headerlink" title="1、跨节点Join的问题"></a><strong>1、跨节点Join的问题</strong></h2><p>&emsp;&emsp;只要是进行切分，跨节点Join的问题是不可避免的。但是良好的设计和切分却可以减少此类情况的发生。解决这一问题的普遍做法是分两次查询实现。在第一次查询的结果集中找出关联数据的id,根据这些id发起第二次请求得到关联数据。</p><h2 id="2、跨节点的count-order-by-group-by以及聚合函数问题"><a href="#2、跨节点的count-order-by-group-by以及聚合函数问题" class="headerlink" title="2、跨节点的count,order by,group by以及聚合函数问题"></a><strong>2、跨节点的count,order by,group by以及聚合函数问题</strong></h2><p>&emsp;&emsp;这些是一类问题，因为它们都需要基于全部数据集合进行计算。多数的代理都不会自动处理合并工作。解决方案：与解决跨节点join问题的类似，分别在各个节点上得到结果后在应用程序端进行合并。和join不同的是每个结点的查询可以并行执行，因此很多时候它的速度要比单一大表快很多。但如果结果集很大，对应用程序内存的消耗是一个问题。</p><h2 id="3、数据迁移，容量规划，扩容等问题"><a href="#3、数据迁移，容量规划，扩容等问题" class="headerlink" title="3、数据迁移，容量规划，扩容等问题"></a><strong>3、数据迁移，容量规划，扩容等问题</strong></h2><p>&emsp;&emsp;来自淘宝综合业务平台团队，它利用对2的倍数取余具有向前兼容的特性（如对4取余得1的数对2取余也是1）来分配数据，避免了行级别的数据迁移，但是依然需要进行表级别的迁移，同时对扩容规模和分表数量都有限制。总得来说，这些方案都不是十分的理想，多多少少都存在一些缺点，这也从一个侧面反映出了Sharding扩容的难度。</p><h2 id="4、事务"><a href="#4、事务" class="headerlink" title="4、事务"></a><strong>4、事务</strong></h2><p>&emsp;&emsp;解决事务问题目前有两种可行的方案：分布式事务和通过应用程序与数据库共同控制实现事务。</p><blockquote><p>方案一：使用分布式事务 </p><p>优点：交由数据库管理，简单有效</p><p>缺点：性能代价高，特别是shard越来越多时</p><p>方案二：由应用程序和数据库共同控制 </p><p>原理：将一个跨多个数据库的分布式事务分拆成多个仅处 于单个数据库上面的小事务，并通过应用程序来总控 各个小事务。</p><p>优点：性能上有优势</p><p>缺点：需要应用程序在事务控制上做灵活设计。如果使用 了spring的事务管理，改动起来会面临一定的困难。</p></blockquote><p>&emsp;&emsp;<strong>分布式事务</strong>，参考： <a href="http://blog.csdn.net/bluishglc/article/details/7612811" target="_blank" rel="noopener">关于分布式事务、两阶段提交、一阶段提交、Best Efforts 1PC模式和事务补偿机制的研究</a></p><p>&emsp;&emsp;优点：</p><ul><li>基于两阶段提交，最大限度地保证了跨数据库操作的“原子性”，是分布式系统下最严格的事务实现方式。</li><li>实现简单，工作量小。由于多数应用服务器以及一些独立的分布式事务协调器做了大量的封装工作，使得项目中引入分布式事务的难度和工作量基本上可以忽略不计。</li></ul><p>&emsp;&emsp;缺点：</p><ul><li>系统“水平”伸缩的死敌。基于两阶段提交的分布式事务在提交事务时需要在多个节点之间进行协调,最大限度地推后了提交事务的时间点，客观上延长了事务的执行时间，这会导致事务在访问共享资源时发生冲突和死锁的概率增高，随着数据库节点的增多，这种趋势会越来越严重，从而成为系统在数据库层面上水平伸缩的”枷锁”， 这是很多Sharding系统不采用分布式事务的主要原因。</li></ul><p>&emsp;&emsp;<strong>基于Best Efforts 1PC模式的事务</strong>，参考spring-data-neo4j的实现。鉴于Best Efforts 1PC模式的性能优势，以及相对简单的实现方式，它被大多数的sharding框架和项目采用</p><p>&emsp;&emsp;<strong>事务补偿（幂等值）</strong></p><p>&emsp;&emsp;对于那些对性能要求很高，但对一致性要求并不高的系统，往往并不苛求系统的实时一致性，只要在一个允许的时间周期内达到最终一致性即可，这使得事务补偿机制成为一种可行的方案。事务补偿机制最初被提出是在“长事务”的处理中，但是对于分布式系统确保一致性也有很好的参考意义。笼统地讲，与事务在执行中发生错误后立即回滚的方式不同，事务补偿是一种事后检查并补救的措施，它只期望在一个容许时间周期内得到最终一致的结果就可以了。事务补偿的实现与系统业务紧密相关，并没有一种标准的处理方式。一些常见的实现方式有：对数据进行对帐检查;基于日志进行比对;定期同标准数据来源进行同步，等等。</p><blockquote><p><a href="https://zhuanlan.zhihu.com/p/24036067" target="_blank" rel="noopener">https://zhuanlan.zhihu.com/p/24036067</a></p><p>事务支持：我们是将整个订单领域聚合体切分，维度一致，所以对聚合体的事务是支持的。</p><p>复杂查询：垂直切分后，就跟join说拜拜了；水平切分后，查询的条件一定要在切分的维度内，比如查询具体某个用户下的各位订单等；禁止不带切分的维度的查询，即使中间件可以支持这种查询，可以在内存中组装，但是这种需求往往不应该在在线库查询，或者可以通过其他方法转换到切分的维度来实现。</p></blockquote><h2 id="5、ID问题"><a href="#5、ID问题" class="headerlink" title="5、ID问题"></a><strong>5、ID问题</strong></h2><p>&emsp;&emsp;一旦数据库被切分到多个物理结点上，我们将不能再依赖数据库自身的主键生成机制。一方面，某个分区数据库自生成的ID无法保证在全局上是唯一的；另一方面，应用程序在插入数据之前需要先获得ID,以便进行SQL路由。</p><ol><li>利用数据库自增ID和UUID</li></ol><p>&emsp;&emsp;优点：最简单。</p><p>&emsp;&emsp;缺点：单点风险、单机性能瓶颈。</p><blockquote><p>使用UUID作主键是最简单的方案，但是缺点也是非常明显的。由于UUID非常的长，除占用大量存储空间外，最主要的问题是在索引上，在建立索引和基于索引进行查询时都存在性能问题。</p></blockquote><ol start="2"><li>结合数据库维护一个Sequence表</li></ol><p>&emsp;&emsp;此方案的思路也很简单，在数据库中建立一个Sequence表，表的结构类似于：</p><figure class="highlight n1ql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> TABLE <span class="symbol">`SEQUENCE`</span> (  </span><br><span class="line">    <span class="symbol">`table_name`</span> varchar(<span class="number">18</span>) <span class="keyword">NOT</span> <span class="literal">NULL</span>,  </span><br><span class="line">    <span class="symbol">`nextid`</span> bigint(<span class="number">20</span>) <span class="keyword">NOT</span> <span class="literal">NULL</span>,  </span><br><span class="line">    <span class="keyword">PRIMARY</span> <span class="keyword">KEY</span> (<span class="symbol">`table_name`</span>)  </span><br><span class="line">) ENGINE=InnoDB</span><br></pre></td></tr></table></figure><p>&emsp;&emsp;每当需要为某个表的新纪录生成ID时就从Sequence表中取出对应表的nextid,并将nextid的值加1后更新到数据库中以备下次使用。此方案也较简单，但缺点同样明显：由于所有插入任何都需要访问该表，该表很容易成为系统性能瓶颈，同时它也存在单点问题，一旦该表数据库失效，整个应用程序将无法工作。有人提出使用Master-Slave进行主从同步，但这也只能解决单点问题，并不能解决读写比为1:1的访问压力问题。</p><ol start="3"><li>利用数据库集群并设置相应的步长（Flickr方案）</li></ol><p>&emsp;&emsp;优点：高可用、ID较简洁。</p><p>&emsp;&emsp;缺点：需要单独的数据库集群。</p><ol start="4"><li>Twitter Snowflake</li></ol><p>&emsp;&emsp;优点：高性能高可用、易拓展。</p><p>&emsp;&emsp;缺点：需要独立的集群以及ZK。</p><blockquote><p><a href="http://blog.sina.com.cn/s/blog_6b7c2e660102vbi2.html" title="Title" target="_blank" rel="noopener">Twitter的分布式自增ID算法Snowflake</a></p><p>在分布式系统中，需要生成全局UID的场合还是比较多的，twitter的snowflake解决了这种需求，实现也还是很简单的，除去配置信息，核心代码就是毫秒级时间41位 机器ID 10位 毫秒内序列12位。</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">&gt;*</span> <span class="number">10</span><span class="bullet">---0000000000</span> <span class="number">0000000000</span> <span class="number">0000000000</span> <span class="number">0000000000</span> <span class="number">0</span> <span class="meta">---</span> <span class="number">00000</span> <span class="bullet">---00000</span> <span class="bullet">---000000000000</span></span><br><span class="line"><span class="string">&gt;</span></span><br></pre></td></tr></table></figure></blockquote><blockquote><p>在上面的字符串中，第一位为未使用（实际上也可作为long的符号位），接下来的41位为毫秒级时间，然后5位datacenter标识位，5位机器ID（并不算标识符，实际是为线程标识），然后12位该毫秒内的当前毫秒内的计数，加起来刚好64位，为一个Long型。</p><p>这样的好处是，整体上按照时间自增排序，并且整个分布式系统内不会产生ID碰撞（由datacenter和机器ID作区分），并且效率较高，经测试，snowflake每秒能够产生26万ID左右，完全满足需要。</p></blockquote><ol start="5"><li>一大波GUID、Random算法</li></ol><p>&emsp;&emsp;优点：简单。</p><p>&emsp;&emsp;缺点：生成ID较长，有重复几率。</p><blockquote><p><a href="https://zhuanlan.zhihu.com/p/24036067" target="_blank" rel="noopener">https://zhuanlan.zhihu.com/p/24036067</a> 博主团队采用的策略是：时间戳+用户标识码+随机数</p><p>优点有：</p><ul><li><p>方便、成本低。</p></li><li><p>基本无重复的可能。</p></li><li><p>自带分库规则，这里的用户标识码即为用户ID的后四位，在查询的场景下，只需要订单号就可以匹配到相应的库表而无需用户ID，只取四位是希望订</p></li><li><p>单号尽可能的短一些，并且评估下来四位已经足够。</p></li><li><p>可排序，因为时间戳在最前面。</p></li></ul><p>当然也有一些缺点，比如长度稍长，性能要比int/bigint的稍差等。</p></blockquote><h2 id="7、跨分片的排序分页"><a href="#7、跨分片的排序分页" class="headerlink" title="7、跨分片的排序分页"></a><strong>7、跨分片的排序分页</strong></h2><p>&emsp;&emsp;一般来讲，分页时需要按照指定字段进行排序。当排序字段就是分片字段的时候，我们通过分片规则可以比较容易定位到指定的分片，而当排序字段非分片字段的时候，情况就会变得比较复杂了。为了最终结果的准确性，我们需要在不同的分片节点中将数据进行排序并返回，并将不同分片返回的结果集进行汇总和再次排序，最后再返回给用户。如下图所示：</p><p><img src="https://pic-1258215793.cos.ap-shanghai.myqcloud.com/content/20190316/201903160119.png" alt=""></p><p>&emsp;&emsp;上面图中所描述的只是最简单的一种情况（取第一页数据），看起来对性能的影响并不大。但是，如果想取出第10页数据，情况又将变得复杂很多，如下图所示：</p><p><img src="https://pic-1258215793.cos.ap-shanghai.myqcloud.com/content/20190316/201903160120.png" alt=""></p><p>&emsp;&emsp;有些读者可能并不太理解，为什么不能像获取第一页数据那样简单处理（排序取出前10条再合并、排序）。其实并不难理解，因为各分片节点中的数据可能是随机的，为了排序的准确性，必须把所有分片节点的前N页数据都排序好后做合并，最后再进行整体的排序。很显然，这样的操作是比较消耗资源的，用户越往后翻页，系统性能将会越差。</p><p>&emsp;&emsp;<strong>那如何解决分库情况下的分页问题呢？有以下几种办法：</strong></p><p>&emsp;&emsp;如果是在前台应用提供分页，则限定用户只能看前面n页，这个限制在业务上也是合理的，一般看后面的分页意义不大（如果一定要看，可以要求用户缩小范围重新查询）。</p><p>&emsp;&emsp;如果是后台批处理任务要求分批获取数据，则可以加大page size，比如每次获取5000条记录，有效减少分页数（当然离线访问一般走备库，避免冲击主库）。</p><p>&emsp;&emsp;分库设计时，一般还有配套大数据平台汇总所有分库的记录，有些分页查询可以考虑走大数据平台。</p><h2 id="8、分库策略"><a href="#8、分库策略" class="headerlink" title="8、分库策略"></a><strong>8、分库策略</strong></h2><h3 id="水平切分策略"><a href="#水平切分策略" class="headerlink" title="水平切分策略"></a><strong>水平切分策略</strong></h3><ol><li>查询切分：通过一个中间库记录ID和分库的映射关系</li></ol><p>&emsp;&emsp;优点：ID和分库的映射算法可以任意修改</p><p>&emsp;&emsp;缺点：需要引入额外的单点</p><ol start="2"><li>范围切分：通过时间区间或ID区间等来划分</li></ol><p>&emsp;&emsp;优点：单表大小可控，天然水平扩展</p><p>&emsp;&emsp;缺点：无法解决集中写入瓶颈问题</p><ol start="3"><li>Hash切分：通过mod求余划分，推荐采用mod 2^n这种一致性Hash。</li></ol><p>&emsp;&emsp;比如分库分表方案为32*32，通过对ID后四位对32求余划分到32个分库中，然后把ID后四位div 32 mod 32将各分库分为32张表，总共1024张表，线上部署为8个主从集群，每个集群4个库。</p><p>&emsp;&emsp;每次达到瓶颈后都可以通过修改求余策略来扩展数据集群，易于水平扩展。</p><p>&emsp;&emsp;分库维度确定后，如何把记录分到各个库里呢?</p><p>&emsp;&emsp;一般有两种方式：</p><ul><li>根据数值范围，比如用户Id为1-9999的记录分到第一个库，10000-20000的分到第二个库，以此类推。</li><li>根据数值取模，比如用户Id mod n，余数为0的记录放到第一个库，余数为1的放到第二个库，以此类推。</li></ul><p>&emsp;&emsp;优劣比较：</p><p>&emsp;&emsp;评价指标按照范围分库按照Mod分库</p><p>&emsp;&emsp;库数量前期数目比较小，可以随用户/业务按需增长前期即根据mode因子确定库数量，数目一般比较大</p><p>&emsp;&emsp;访问性能前期库数量小，全库查询消耗资源少，单库查询性能略差前期库数量大，全库查询消耗资源多，单库查询性能略好</p><p>&emsp;&emsp;调整库数量比较容易，一般只需为新用户增加库，老库拆分也只影响单个库困难，改变mod因子导致数据在所有库之间迁移</p><p>&emsp;&emsp;数据热点新旧用户购物频率有差异，有数据热点问题新旧用户均匀到分布到各个库，无热点</p><p>&emsp;&emsp;实践中，为了处理简单，选择mod分库的比较多。同时二次分库时，为了数据迁移方便，一般是按倍数增加，比如初始4个库，二次分裂为8个，再16个。这样对于某个库的数据，一半数据移到新库，剩余不动，对比每次只增加一个库，所有数据都要大规模变动。</p><p>&emsp;&emsp;补充下，mod分库一般每个库记录数比较均匀，但也有些数据库，存在超级Id，这些Id的记录远远超过其他Id，比如在广告场景下，某个大广告主的广告数可能占总体很大比例。如果按照广告主Id取模分库，某些库的记录数会特别多，对于这些超级Id，需要提供单独库来存储记录。</p><h2 id="9、分库数量"><a href="#9、分库数量" class="headerlink" title="9、分库数量"></a><strong>9、分库数量</strong></h2><p>&emsp;&emsp;分库数量首先和单库能处理的记录数有关，一般来说，Mysql 单库超过5000万条记录，Oracle单库超过1亿条记录，DB压力就很大(当然处理能力和字段数量/访问模式/记录长度有进一步关系)。</p><p>&emsp;&emsp;在满足上述前提下，如果分库数量少，达不到分散存储和减轻DB性能压力的目的；如果分库的数量多，好处是每个库记录少，单库访问性能好，但对于跨多个库的访问，应用程序需要访问多个库，如果是并发模式，要消耗宝贵的线程资源；如果是串行模式，执行时间会急剧增加。</p><p>&emsp;&emsp;最后分库数量还直接影响硬件的投入，一般每个分库跑在单独物理机上，多一个库意味多一台设备。所以具体分多少个库，要综合评估，一般初次分库建议分4-8个库。</p><h2 id="10、路由透明"><a href="#10、路由透明" class="headerlink" title="10、路由透明"></a><strong>10、路由透明</strong></h2><p>&emsp;&emsp;分库从某种意义上来说，意味着DB schema改变了，必然影响应用，但这种改变和业务无关，所以要尽量保证分库对应用代码透明，分库逻辑尽量在数据访问层处理。当然完全做到这一点很困难，具体哪些应该由DAL负责，哪些由应用负责，这里有一些建议：</p><p>&emsp;&emsp;对于单库访问，比如查询条件指定用户Id，则该SQL只需访问特定库。此时应该由DAL层自动路由到特定库，当库二次分裂时，也只要修改mod 因子，应用代码不受影响。</p><p>&emsp;&emsp;对于简单的多库查询，DAL负责汇总各个数据库返回的记录，此时仍对上层应用透明。</p><h2 id="11、使用框架还是自主研发"><a href="#11、使用框架还是自主研发" class="headerlink" title="11、使用框架还是自主研发"></a><strong>11、使用框架还是自主研发</strong></h2><p>&emsp;&emsp;目前市面上的分库分表中间件相对较多，其中基于代理方式的有MySQL Proxy和Amoeba，基于Hibernate框架的是Hibernate Shards，基于jdbc的有当当sharding-jdbc，基于mybatis的类似maven插件式的有蘑菇街的蘑菇街TSharding，通过重写spring的ibatis template类是Cobar Client，这些框架各有各的优势与短板，架构师可以在深入调研之后结合项目的实际情况进行选择，但是总的来说，我个人对于框架的选择是持谨慎态度的。一方面多数框架缺乏成功案例的验证，其成熟性与稳定性值得怀疑。另一方面，一些从成功商业产品开源出框架（如阿里和淘宝的一些开源项目）是否适合你的项目是需要架构师深入调研分析的。当然，最终的选择一定是基于项目特点、团队状况、技术门槛和学习成本等综合因素考量确定的。</p><h1 id="实战场景-Mycat实现分库分表"><a href="#实战场景-Mycat实现分库分表" class="headerlink" title="实战场景-Mycat实现分库分表"></a><strong>实战场景-Mycat实现分库分表</strong></h1><p>&emsp;&emsp;暂无</p><hr><p><em>参考博客和文章书籍等：</em></p><blockquote><p><a href="https://www.cnblogs.com/jshen/p/7682502.html" target="_blank" rel="noopener">https://www.cnblogs.com/jshen/p/7682502.html</a></p></blockquote><blockquote><p><a href="http://www.jianshu.com/p/32b3e91aa22c" target="_blank" rel="noopener">http://www.jianshu.com/p/32b3e91aa22c</a></p></blockquote><blockquote><p><a href="https://zhuanlan.zhihu.com/p/24036067" target="_blank" rel="noopener">https://zhuanlan.zhihu.com/p/24036067</a></p></blockquote><p><em>因博客主等未标明不可引用，若部分内容涉及侵权请及时告知，我会尽快修改和删除相关内容</em></p>]]></content>
    
    <summary type="html">
    
      简单介绍分库分表技术，要解决的问题，相关策略，以及场景模拟。
    
    </summary>
    
      <category term="技术文档" scheme="http://linyishui.top/categories/%E6%8A%80%E6%9C%AF%E6%96%87%E6%A1%A3/"/>
    
    
      <category term="database" scheme="http://linyishui.top/tags/database/"/>
    
  </entry>
  
</feed>
