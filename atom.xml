<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>俺的部落格</title>
  
  <subtitle>俺寻思俺需要记点东西</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://linyishui.top/"/>
  <updated>2020-09-26T12:26:08.999Z</updated>
  <id>http://linyishui.top/</id>
  
  <author>
    <name>Speciosity</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>SqlLoader</title>
    <link href="http://linyishui.top/2020092401.html"/>
    <id>http://linyishui.top/2020092401.html</id>
    <published>2020-09-24T07:26:04.000Z</published>
    <updated>2020-09-26T12:26:08.999Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="SqlLoader"><a href="#SqlLoader" class="headerlink" title="SqlLoader"></a>SqlLoader</h1><h2 id="第一节-概述"><a href="#第一节-概述" class="headerlink" title="第一节 概述"></a>第一节 概述</h2><h3 id="1-1-常见的几种数据迁移方式"><a href="#1-1-常见的几种数据迁移方式" class="headerlink" title="1.1 常见的几种数据迁移方式"></a>1.1 常见的几种数据迁移方式</h3><p>日常开发中会经常遇到这样的需求，大批量的数据需要在不同的数据库间迁移，一般会有如下几种方式（不一定涵盖所有）：</p><ul><li>源数据库直接导出SQL文件，目标数据库执行；<ul><li>数据量大时效率很低，甚至可能会卡死客户端。</li></ul></li><li>创建数据库间的DBLink，用 <code>create table B as select * from A@dblink where ...</code> ，或 <code>insert into B select * from A@dblink where ...</code> ；</li><li>exp A 表，再 imp 到 B 表，exp 时可加查询条件；</li><li>程序实现 <code>select from A ..</code> ，然后 <code>insert into B ...</code> ，也要分批提交；</li><li>SqlLoader导入数据。</li></ul><h3 id="1-2-什么是SqlLoader"><a href="#1-2-什么是SqlLoader" class="headerlink" title="1.2 什么是SqlLoader"></a>1.2 什么是SqlLoader</h3><p>Oracle提供了 <code>sqlldr</code> 命令，参数：</p><ul><li>userid：username/password[@servicename]；</li><li>control：控制文件，可能包含表的数据；</li><li>log：记录导入时的日志文件，默认为 控制文件(去除扩展名).log；</li><li>bad：坏数据文件，默认为 控制文件(去除扩展名).bad；</li><li>data：数据文件，一般在控制文件中指定。用参数控制文件中不指定数据文件更适于自动操作；</li><li>errors：允许的错误记录数，可以用他来控制一条记录都不能错；</li><li>rows：多少条记录提交一次，默认为 64；</li><li>skip：跳过的行数，比如导出的数据文件前面几行是表头或其他描述。</li></ul><p>sqlldr是在处理大数据量的操作中建议采用的方式，它有许多性能相关的开关，能最大程度的减少 redo，undo 的生成。</p><h3 id="1-3-SqlLoader用法"><a href="#1-3-SqlLoader用法" class="headerlink" title="1.3 SqlLoader用法"></a>1.3 SqlLoader用法</h3><p>控制文件 <code>.ctl</code> 格式：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">-- 1. 控制文件标识</span></span><br><span class="line"><span class="keyword">LOAD</span> <span class="keyword">DATA</span>   </span><br><span class="line"></span><br><span class="line"><span class="comment">-- 2. 要导入的数据文件名</span></span><br><span class="line"><span class="keyword">INFILE</span> <span class="string">'xxx.txt'</span>      </span><br><span class="line"></span><br><span class="line"><span class="comment">-- 3. 将文件插入到数据库的 test 表中</span></span><br><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> <span class="keyword">TABLE</span> <span class="keyword">test</span>   </span><br><span class="line"></span><br><span class="line"><span class="comment">-- 4. 用于分割一行中各个属性值的符号（例如每个属性值用逗号分割， 那么就把 X'09' 改为','）</span></span><br><span class="line"><span class="keyword">Fields</span> <span class="keyword">terminated</span> <span class="keyword">by</span> X<span class="string">'09'</span> </span><br><span class="line"></span><br><span class="line"><span class="comment">-- 5. test表中对应的属性名</span></span><br><span class="line">(<span class="keyword">id</span>, username, passwprd, ......)</span><br></pre></td></tr></table></figure><p>操作类型有：</p><ol><li>insert：为缺省方式，在数据装载开始时要求表为空；</li><li>append：在表中追加新记录；</li><li>replace：删除旧记录(用 delete from table 语句)，替换成新装载的记录；</li><li>truncate：删除旧记录(用 truncate table 语句)，替换成新装载的记录。</li></ol><p>案例：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">load</span> <span class="keyword">data</span> </span><br><span class="line"></span><br><span class="line"><span class="comment">-- 此文件格式是.log，用文本文件的方法可以导入进去</span></span><br><span class="line"><span class="keyword">infile</span> <span class="string">'D:/xxx/xxx.log'</span> </span><br><span class="line"></span><br><span class="line"><span class="comment">-- insert为缺省方式，插入时要求表为空</span></span><br><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> <span class="keyword">table</span> database_name</span><br><span class="line"></span><br><span class="line"><span class="comment">-- 数据文件每个字段也就是属性是按照|来分割的</span></span><br><span class="line"><span class="keyword">fields</span> <span class="keyword">terminated</span> <span class="keyword">by</span> <span class="string">'|'</span>  </span><br><span class="line"></span><br><span class="line"><span class="comment">-- 数据中某些属性可能是null值 ， 如果不加入这行导入到数据库的时候就会自动跳过null值的列, 这样数据插入后就会属性和值对应不上</span></span><br><span class="line">trailing nullcols </span><br><span class="line"></span><br><span class="line"><span class="comment">-- content运用的类型是clob，当使用sqlldr加载很长的字符串(超过4000)到表中的clob类型中时会报错：数据文件的字段超出最大长度；sqlldr每次读入文件中数据流的数据类型默认为CHAR ,长度为 255 .所以只要超过255字符的段都会报这个错，所以char(10000)用来控制上限</span></span><br><span class="line">(<span class="keyword">time</span>, user_id, <span class="keyword">type</span>, longitude, latitude, height, <span class="keyword">content</span> <span class="built_in">char</span>(<span class="number">10000</span>))</span><br></pre></td></tr></table></figure><p>接下来可以直接通过 <code>sqlldr</code> 语句导入，一般项目会通过一个数据文件和一个控制文件来实现此功能，这样可以将模板和数据分离，可以重复使用：</p><ul><li>数据文件：可以是PL/SQL或Toad导出、SqlPlus的Spool格式化产出、UTL_FILE包生成。</li></ul><h2 id="第二节-实战"><a href="#第二节-实战" class="headerlink" title="第二节 实战"></a>第二节 实战</h2><h3 id="2-1-导出SQL"><a href="#2-1-导出SQL" class="headerlink" title="2.1 导出SQL"></a>2.1 导出SQL</h3><p>导出一千万条数据，耗时-5分钟，sql文件大小-1.17 GB</p><p>直接执行SQL文件，耗时54分41秒</p><h3 id="2-2-SqlLoader"><a href="#2-2-SqlLoader" class="headerlink" title="2.2 SqlLoader"></a>2.2 SqlLoader</h3><p>导出CSV格式文件，耗时，文件大小：</p><p><img src="https://pic-1258215793.cos.ap-shanghai.myqcloud.com/content/20200901/202009010157.png" alt></p><p>创建控制文件：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">OPTIONS (skip=1,rows=128) <span class="comment">-- sqlldr 命令显示的 选项可以写到这里边来,skip=1 用来跳过数据中的第一行  </span></span><br><span class="line"><span class="keyword">LOAD</span> <span class="keyword">DATA</span>  </span><br><span class="line"><span class="keyword">INFILE</span> <span class="string">"users_data.csv"</span> <span class="comment">--指定外部数据文件，可以写多 个 INFILE "another_data_file.csv" 指定多个数据文件  </span></span><br><span class="line"><span class="comment">--这里还可以使 用 BADFILE、DISCARDFILE 来指定坏数据和丢弃数据的文件，  </span></span><br><span class="line"><span class="keyword">truncate</span> <span class="comment">--操作类型，用 truncate table 来清除表中原有 记录  </span></span><br><span class="line"><span class="keyword">INTO</span> <span class="keyword">TABLE</span> <span class="keyword">users</span> <span class="comment">-- 要插入记录的表  </span></span><br><span class="line"><span class="keyword">Fields</span> <span class="keyword">terminated</span> <span class="keyword">by</span> <span class="string">","</span> <span class="comment">-- 数据中每行记录用 "," 分隔  </span></span><br><span class="line"><span class="keyword">Optionally</span> <span class="keyword">enclosed</span> <span class="keyword">by</span> <span class="string">'"'</span> <span class="comment">-- 数据中每个字段用 '"' 框起，比如字段中有 "," 分隔符时  </span></span><br><span class="line">trailing nullcols <span class="comment">--表的字段没有对应的值时允 许为空  </span></span><br><span class="line">(  </span><br><span class="line">  virtual_column FILLER, <span class="comment">--这是一个虚拟字段，用来跳 过由 PL/SQL Developer 生成的第一列序号  </span></span><br><span class="line">  user_id <span class="built_in">number</span>, <span class="comment">--字段可以指定类型，否则认 为是 CHARACTER 类型, log 文件中有显示  </span></span><br><span class="line">  user_name,  </span><br><span class="line">  login_times,  </span><br><span class="line">  last_login <span class="built_in">DATE</span> <span class="string">"YYYY-MM-DD HH24:MI:SS"</span> <span class="comment">-- 指定接受日期的格式，相当用 to_date() 函数转换  </span></span><br><span class="line">)</span><br></pre></td></tr></table></figure><p>执行命令：<code>sqlldr dbuser/dbpass@dbservice control=users.ctl</code></p><p>执行完 sqlldr 后可以留意一下生成的几个文件，如 users.log 日志文件、users.bad 坏数据文件等。特别是要看看日志文件，从中可让你更好的理解 Sql Loader，里面有对控制文件的解析、列出每个字段的类型、加载记录的统计、出错原因等信息。</p><h2 id="第三节-SqlLoader细节"><a href="#第三节-SqlLoader细节" class="headerlink" title="第三节 SqlLoader细节"></a>第三节 SqlLoader细节</h2><p>SqlLoader 的性能与并发操作：</p><ol><li><p>ROWS 的默认值为 64，可以根据实际指定更合适的 ROWS 参数来指定每次提交记录数。</p></li><li><p>常规导入可以通过使用 INSERT语句来导入数据。Direct 导入可以跳过数据库的相关逻辑(DIRECT=TRUE)，而直接将数据导入到数据文件中，可以提高导入数据的性能。当然，在很多情况下，不能使用此参数(如果主键重复的话会使索引的状态变成UNUSABLE!)。</p></li><li><p>通过指定 UNRECOVERABLE选项，可以关闭数据库的日志(是否要 alter table table1 nologging 呢?)。这个选项只能和 direct 一起使用。</p></li><li><p>对于超大数据文件的导入就要用并发操作了，即同时运行多个导入任务。</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">sqlldr userid=/ control=result1.ctl direct=true parallel=true   </span><br><span class="line">sqlldr userid=/ control=result2.ctl direct=true parallel=true   </span><br><span class="line">sqlldr userid=/ control=result2.ctl direct=true parallel=true</span><br></pre></td></tr></table></figure></li><li><p>当加载大量数据时（大约超过10GB），最好抑制日志的产生：  <code>SQL&gt;ALTER  TABLE  RESULTXT  nologging;</code> 这样不产生REDO LOG，可以提高效率。然后在 CONTROL 文件中 load data 上面加一行：unrecoverable， 此选项必须要与DIRECT共同应用。</p></li><li><p>在并发操作时，ORACLE声称可以达到每小时处理100GB数据的能力！其实，估计能到 1－10G 就算不错了，开始可用结构相同的文件，但只有少量数据，成功后开始加载大量数据，这样可以避免时间的浪费。（注意：一般只能用ASCII码形式，切记要转换编码，不然导入数据为空）</p></li></ol><p><a href="https://cloud.tencent.com/developer/article/1059843" target="_blank" rel="noopener">https://cloud.tencent.com/developer/article/1059843</a></p><hr><p>参考：</p><blockquote><p><a href="https://blog.csdn.net/shadow_zed/article/details/82661118" target="_blank" rel="noopener">oracle sqlldr 用法详解</a></p></blockquote><p><em>若内容涉及侵权请及时告知，我会尽快修改和删除相关内容</em></p>]]></content>
    
    <summary type="html">
    
      简单整理一下SqlLoader相关内容，简单使用，实战案例等。
    
    </summary>
    
      <category term="技术文档" scheme="http://linyishui.top/categories/%E6%8A%80%E6%9C%AF%E6%96%87%E6%A1%A3/"/>
    
    
      <category term="sql" scheme="http://linyishui.top/tags/sql/"/>
    
      <category term="oracle" scheme="http://linyishui.top/tags/oracle/"/>
    
  </entry>
  
  <entry>
    <title>RabbitMQ（二）客户端开发</title>
    <link href="http://linyishui.top/2020092001.html"/>
    <id>http://linyishui.top/2020092001.html</id>
    <published>2020-09-20T04:34:35.000Z</published>
    <updated>2020-09-26T11:34:11.540Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="客户端开发"><a href="#客户端开发" class="headerlink" title="客户端开发"></a><strong>客户端开发</strong></h1><h2 id="第一节-连接-RabbitMQ"><a href="#第一节-连接-RabbitMQ" class="headerlink" title="第一节 连接 RabbitMQ"></a><strong>第一节 连接 RabbitMQ</strong></h2><p>客户端给定参数（IP地址、端口号、用户名、密码等）连接RabbitMQ：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">ConnectionFactory factory = <span class="keyword">new</span> ConnectionFactory();</span><br><span class="line">factory.setUsername(USERNAME);</span><br><span class="line">factory.setPassword(PASSWORD);</span><br><span class="line">factory.setVirtualHost(virtualHost);</span><br><span class="line">factory.setHost(IP_ADDRESS);</span><br><span class="line">factory.setPort(PORT);</span><br><span class="line">Connection conn = factory.newConnection();</span><br></pre></td></tr></table></figure><p>也可以用URL的方式实现：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">ConnectionFactory factory = <span class="keyword">new</span> ConnectionFactory();</span><br><span class="line">factory.setUri(<span class="string">"amqp://userName:password@ipAddress:portNumber/virtualHost"</span>);</span><br><span class="line">Connection conn = factory.newConnection();</span><br><span class="line"><span class="comment">//Connection 接口被用来创建一个 Channel:</span></span><br><span class="line">Channel channel= conn.createChannel();</span><br><span class="line"><span class="comment">//在创建之后，Channel可以用来发送或者接收消息了</span></span><br></pre></td></tr></table></figure><p>Connection 可以用来创建多个 Channel 实例，但是 Channel 实例不能在线程问共享， 应用程序应该为每一个线程开辟一个 Channel 。多线程问共享 Channel 实例是非线程安全的。</p><p>Channel 或者 Connection 中有个 <code>isOpen</code> 方法可以用来检测其是否己处于开启状态，这个方法的返回值依赖于 <code>shutdownCause</code> ，不推荐在生产环境使用，可能会产生竞争。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isOpen</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="keyword">synchronized</span>(<span class="keyword">this</span>.monitor) &#123;</span><br><span class="line"><span class="keyword">return</span> <span class="keyword">this</span>.shutdownCause == <span class="keyword">null</span>; </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>错误地使用 <code>isOpen</code> 方法：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">brokenMethod</span><span class="params">(Channel channel)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (channel.isOpen())&#123;</span><br><span class="line">        <span class="comment">//The following code depends on the channel being in opeηstate.</span></span><br><span class="line">        <span class="comment">//However there is a possibility of the change in the channel state</span></span><br><span class="line">        <span class="comment">//between isOpen() and basicQos(l) call</span></span><br><span class="line">        ...</span><br><span class="line">        channel.basicQos(l);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>通常情况下，在调用 <code>createXXX</code> 或者 <code>newXXX</code> 方法之后，我们可以简单地认为 Connection 或者 Channel 已经成功地处于开启状态，而并不会在代码中使用 <code>isOpen</code> 这个检测方法。如果在使用 Channel 的时候其己经处于关闭状态，那么程序会抛出一个 <code>com.rabbitmq.client.ShutdownSignalException</code> ，我们只需捕获这个异常即可。当然同时也要试着捕获 <code>IOException</code> 或者 <code>SocketException</code> ，以防 Connection 意外关闭。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">validMethod</span><span class="params">(Channel channel)</span></span>&#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        ...</span><br><span class="line">channel.basicQos(l);</span><br><span class="line">&#125; <span class="keyword">catch</span> (ShutdownSignalException sse) &#123;</span><br><span class="line">        <span class="comment">//possibly check if channel was closed</span></span><br><span class="line">        <span class="comment">//by the time we started action and reasons for</span></span><br><span class="line">        <span class="comment">//closing it</span></span><br><span class="line">        ...</span><br><span class="line">&#125; <span class="keyword">catch</span> (IOException ioe) &#123;</span><br><span class="line">        <span class="comment">//check why connection was closed </span></span><br><span class="line">        ...</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><h2 id="第二节-使用交换器和队列"><a href="#第二节-使用交换器和队列" class="headerlink" title="第二节 使用交换器和队列"></a><strong>第二节 使用交换器和队列</strong></h2><p>交换器和队列是 AMQP high-level 层面的构建模块，应用程序需确保在使用它们的时候就已经存在了，在使用之前需要先声明（declare）它们。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//创建一个持久化的、非自动删除的、绑定类型为 direct 交换器</span></span><br><span class="line">channel.exchangeDeclare(exchangeName, <span class="string">"direct"</span>, <span class="keyword">true</span>);</span><br><span class="line"><span class="comment">//同时也创建一个非持久化的、排他的、自动删除的队列（此队列的名称由 RabbitMQ 自动生成）</span></span><br><span class="line">String queueName = channel.queueDeclare().getQueue();</span><br><span class="line"><span class="comment">//使用路由键将队列和交换器绑定起来</span></span><br><span class="line">channel.queueBind(queueName, exchangeName, routingKey);</span><br></pre></td></tr></table></figure><p>上面声明的队列具备如下特性：只对当前应用中同一个 Connection 层面可用，同一个 Connection 的不同 Channel 可共用，并且也会在应用连接断开时自动删除。</p><p>如果要在应用中共享一个队列，可以做如下声明：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//同上</span></span><br><span class="line">channel.exchangeDeclare(exchangeName , <span class="string">"direct"</span>, <span class="keyword">true</span>) ;</span><br><span class="line"><span class="comment">//队列被声明为持久化的 非排他的、非自动删除的，而且也被分配另一个确定的己知的名称（由客户端分配而非 RabbitMQ 自动生成）</span></span><br><span class="line">channel.queueDeclare(queueName, <span class="keyword">true</span>, <span class="keyword">false</span>, <span class="keyword">false</span>, <span class="keyword">null</span>);</span><br><span class="line">channel.queueBind(queueName , exchangeName , routingKey) ;</span><br></pre></td></tr></table></figure><p>生产者和消费者都可以声明一个交换器或者队列。</p><h3 id="2-1-exchangeDeclare"><a href="#2-1-exchangeDeclare" class="headerlink" title="2.1 exchangeDeclare()"></a><strong>2.1 exchangeDeclare()</strong></h3><p><code>exchangeDeclare()</code> 用来声明交换器，有多种重载方法：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Exchange.<span class="function">DeclareOk <span class="title">exchangeDeclare</span><span class="params">(String exchange, String type, <span class="keyword">boolean</span> durable,</span></span></span><br><span class="line"><span class="function"><span class="params"><span class="keyword">boolean</span> autoDelete, <span class="keyword">boolean</span> internal,</span></span></span><br><span class="line"><span class="function"><span class="params">Map&lt;String , Object&gt; arguments)</span> <span class="keyword">throws</span> IOException</span>;</span><br></pre></td></tr></table></figure><ul><li><code>Exchange.DeclareOk</code> ：用来标识成功声明了一个交换器。</li><li>exchange：交换器的<strong>名称</strong>。</li><li>type：交换器的<strong>类型</strong>。<ul><li>常见的如fanout，direct，topic。</li></ul></li><li>durable：设置<strong>是否持久化</strong>。<ul><li>持久化可以将交换器存盘，在服务器重启的时候不会丢失相关信息。</li></ul></li><li>autoDelete：设置<strong>是否自动删除</strong>。<ul><li>自动删除的前提是至少有一个队列或者交换器与这个交换器绑定，之后所有与这个交换器绑定的队列或者交换器都与此解绑。</li><li>注意不能错误地把这个参数理解为：当与此交换器连接的客户端都断开时， RabbitMQ 会自动删除本交换器。</li></ul></li><li>internal：设置<strong>是否是内置的的交换器</strong>。<ul><li>客户端程序无法直接发送消息到这个交换器中，只能通过交换器路由到交换器这种方式。</li></ul></li><li>argument：其他一些<strong>结构化参数</strong>，比如 <code>alternate-exchange</code> </li></ul><p>类似的方法：</p><ul><li>exchangeDeclareNoWait：无返回值，不建议使用，刚声明完交换器紧接着就使用，可能导致因交换器未创建而发生异常。</li><li>exchangeDeclarePassive：用来检测相应的交换器是否存在，不存在抛出异常 <code>404 channel exception</code> 同时关闭 Channel 。</li><li>exchangeDelete：删除交换器。</li><li>exchangeDeleteNoWait：无返回删除。</li></ul><h3 id="2-2-queueDeclare"><a href="#2-2-queueDeclare" class="headerlink" title="2.2 queueDeclare()"></a><strong>2.2 queueDeclare()</strong></h3><p><code>queueDeclare()</code> 创建一个队列：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Queue.<span class="function">DeclareOk <span class="title">queueDeclare</span><span class="params">()</span> <span class="keyword">throws</span> IOException</span>; </span><br><span class="line">Queue.<span class="function">DeclareOk <span class="title">queueDeclare</span><span class="params">(String queue, <span class="keyword">boolean</span> durable, <span class="keyword">boolean</span> exclusive, <span class="keyword">boolean</span> autoDelete, Map&lt;String, Object&gt; arguments)</span> <span class="keyword">throws</span> IOException</span>;</span><br></pre></td></tr></table></figure><ul><li>无参方法默认构建一个 RabbitMQ命名的、排他的、自动删除的、非持久化的队列。</li><li>queue：队列<strong>名称</strong></li><li>durable：设置<strong>是否持久化</strong>。<ul><li>持久化的队列会存盘，在服务器重启的时候可以保证不丢失相关信息。</li></ul></li><li>exclusive：设置<strong>是否排他</strong>。<ul><li>如果一个队列被声明为排他队列，该队列仅对首次声明它的连接可见，并在连接断开时自动删除。</li><li>这里需要注意三点：<ul><li>排他队列是基于连接（ Connection ）可见的，同一个连接的不同信道（Channel) 是可以同时访问同一连接创建的排他队列；</li><li>“首次”是指如果一个连接己经声明了一个排他队列，其他连接是不允许建立同名的排他队列的，这个与普通队列不同；</li><li>即使该队列是持久化的，一旦连接关闭或者客户端退出，该排他队列都会被自动删除，这种队列适用于一个客户端同时发送和读取消息的应用场景。</li></ul></li></ul></li><li>autoDelete：设置是否自动删除。<ul><li>自动删除的前提是：至少有一个消费者连接到这个队列，之后所有与这个队列连接的消费者都断开时，才会自动删除。不能把这个参数错误地理解为：“当连接到此队列的所有客户端断开时，这个队列自动删除”，因为生产者客户端创建这个队列，或者没有消费者客户端与这个队列连接时，都不会自动删除这个队列。</li></ul></li><li>arguments：设置队列的其他一些参数。<ul><li>如 <code>x-message-ttl</code> <code>x-expires</code> <code>x-max-length</code> <code>x-max-length-bytes</code> <code>x-dead-letter-exchange</code> <code>x-dead-letter-routing-key</code> , <code>x-max-priority</code> 等。</li></ul></li></ul><p>注意：生产者和消费者都能够使用 queueDeclare 来声明一个队列，但是如果消费者在同一个信道上订阅了另一个队列，就无法再声明队列了。必须先取消订阅，然后将信道置为“传输”模式，之后才能声明队列。</p><p>类似的方法这里不再赘述。</p><h3 id="2-3-queueBind"><a href="#2-3-queueBind" class="headerlink" title="2.3 queueBind()"></a><strong>2.3 queueBind()</strong></h3><p><code>queueBind()</code> 将队列与交换器绑定/解绑。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Queue.<span class="function">BindOk <span class="title">queueBind</span><span class="params">(String queue, String exchange, String routingKey, Map&lt;String, Object&gt; arguments)</span> <span class="keyword">throws</span> IOException</span>;</span><br><span class="line">Queue.<span class="function">UnbindOk <span class="title">queueUnbind</span><span class="params">(String queue, String exchange, String routingKey, Map&lt;String, Object&gt; arguments)</span> <span class="keyword">throws</span> IOException</span>;</span><br></pre></td></tr></table></figure><ul><li>queue：队列名称；</li><li>exchange：交换器的名称；</li><li>routingKey：用来绑定队列和交换器的路由键；</li><li>arguments：定义绑定的一些参数。</li></ul><h3 id="2-4-exchangeBind"><a href="#2-4-exchangeBind" class="headerlink" title="2.4 exchangeBind()"></a><strong>2.4 exchangeBind()</strong></h3><p><code>exchangeBind()</code> 将交换器与交换器绑定：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Exchange.<span class="function">BindOk <span class="title">exchangeBind</span><span class="params">(String destination, String source , String routingKey, Map&lt;String, Object&gt; arguments)</span> <span class="keyword">throws</span> IOException</span>;</span><br></pre></td></tr></table></figure><p>绑定之后，消息从 source 交换器转发到 destination 交换器，后者可以看作是一个队列。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//分别声明source和destination交换器</span></span><br><span class="line">channel.exchangeDeclare(<span class="string">"source"</span>, <span class="string">"direct"</span>, <span class="keyword">false</span>, <span class="keyword">true</span>, <span class="keyword">null</span>) ;</span><br><span class="line">channel.exchangeDeclare(<span class="string">"destination"</span>, <span class="string">"fanout"</span>, <span class="keyword">false</span>, <span class="keyword">true</span>, <span class="keyword">null</span>);</span><br><span class="line"><span class="comment">//绑定两者</span></span><br><span class="line">channel.exchangeBind(<span class="string">"destination"</span>, <span class="string">"source"</span>, <span class="string">"exKey"</span>);</span><br><span class="line"><span class="comment">//声明队列</span></span><br><span class="line">channel.queueDeclare(<span class="string">"queue"</span>, <span class="keyword">false</span>, <span class="keyword">false</span>, <span class="keyword">true</span>, <span class="keyword">null</span>);</span><br><span class="line"><span class="comment">//绑定destination交换器和队列</span></span><br><span class="line">channel.queueBind(<span class="string">"queue"</span>, <span class="string">"destination"</span>，<span class="string">""</span>);</span><br><span class="line"><span class="comment">//source推送消息</span></span><br><span class="line">channel.basicPublish(<span class="string">"source"</span>, <span class="string">"exKey"</span>, <span class="keyword">null</span>, <span class="string">"exToExDemo"</span>. getBytes());</span><br></pre></td></tr></table></figure><p>生产者发送消息至交换器 source 中，交换器 source 根据路由键找到与其匹配 的另一个交换器 destination 井把消息转发到 destination 中，进而存储在 destination 绑定的队列 queue 中：</p><p><img src="https://pic-1258215793.cos.ap-shanghai.myqcloud.com/content/20200901/202009010156.png" alt></p><h3 id="2-5-何时创建"><a href="#2-5-何时创建" class="headerlink" title="2.5 何时创建"></a><strong>2.5 何时创建</strong></h3><p>RabbitMQ 的<strong>消息存储在队列中</strong>，交换器的使用并不真正耗费服务器的性能，而队列会。 如果要衡量 RabbitMQ 当前的 QPS ，只需看队列的即可。<strong>在实际业务应用中，需要对所创建的队列的流量、内存占用及网卡占用有一个清晰的认知，预估其平均值和峰值</strong>，以便在固定硬件资源的情况下能够进行合理有效的分配。 </p><p>按照 RabbitMQ 官方建议，<strong>生产者和消费者都应该尝试创建（这里指声明操作）队列</strong>。这是一个很好的建议，但不适用于所有的情况。如果业务本身在架构设计之初己经充分地预估了队列的使用情况，完全可以在业务程序上线之前在服务器上创建好（<strong>比如通过页面管理、 RabbitMQ 命令或者更好的是从配置中心下发</strong>），这样业务程序也可以免去声明的过程，直接使用即可。 </p><p>预先创建好资源还有一个好处是，<strong>可以确保交换器和队列之间正确地绑定匹配</strong>。很多时候， 由于人为因素、代码缺陷等，发送消息的交换器并没有绑定任何队列，那么消息将会丢失；或者交换器绑定了某个队列，但是发送消息时的路由键无法与现存的队列匹配，那么消息也会丢失。 当然<strong>可以配合 mandatory 参数或者备份交换器来提高程序的健壮性</strong>。 </p><p>与此同时，预估好队列的使用情况非常重要，如果在后期运行过程中超过预定的阈值，可以根据实际情况对当前集群进行扩容或者将相应的队列迁移到其他集群。迁移的过程也可以对业务程序完全透明。此种方法也更有利于开发和运维分工，便于相应资源的管理。 </p><p>如果集群资源充足，而即将使用的队列所占用的资源又在可控的范围之内，为了增加业务程序的灵活性，<strong>也完全可以在业务程序中声明队列</strong>。 至于是使用预先分配创建资源的静态方式还是动态的创建方式，需要从业务逻辑本身、公司运维体系和公司硬件资源等方面考虑。</p><hr><h2 id="第三节-发送消息"><a href="#第三节-发送消息" class="headerlink" title="第三节 发送消息"></a><strong>第三节 发送消息</strong></h2><p><code>channel.basicPublish()</code> 可以用来发送消息：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//发送一条持久化的消息 hello world!</span></span><br><span class="line">String message = <span class="string">"Hello World!"</span>;</span><br><span class="line">channel.basicPublish(EXCHANGE_NAME, ROUTING_KEY, MessageProperties.PERSISTENT_TEXT_PLAIN, message.getBytes());</span><br><span class="line"></span><br><span class="line"><span class="comment">//mandatory参数可以更好的控制发送</span></span><br><span class="line">channel.basicPublish(exchangeName, routingKey, mandatory, MessageProperties.PERSISTENT_TEXT_PLAIN, messageBodyBytes) ; </span><br><span class="line"></span><br><span class="line"><span class="comment">//这条消息的投递模式（delivery mode）为2，消息会被持久化到服务器中</span></span><br><span class="line"><span class="comment">//消息的优先级设置为1，contentType为text/plain</span></span><br><span class="line">channel.basicPublish(exchangeName, routingKey, </span><br><span class="line">                           <span class="keyword">new</span> AMQPBasicProperties.Builder()</span><br><span class="line">                           .contentType(<span class="string">"text/plain"</span>)</span><br><span class="line">                           .deliveryMode(<span class="number">2</span>)</span><br><span class="line">                           .priority(<span class="number">1</span>)</span><br><span class="line">                           .userld(<span class="string">"hidden"</span>)</span><br><span class="line">                           .build()), messageBodyBytes); </span><br><span class="line"></span><br><span class="line"><span class="comment">//也可以设置消息的headers</span></span><br><span class="line">Map&lt;String, Object&gt; headers = <span class="keyword">new</span> HashMap&lt;String Object&gt;();</span><br><span class="line">headers.put(<span class="string">"localtion"</span>，<span class="string">"here"</span>);</span><br><span class="line">headers.put(<span class="string">"time"</span>, <span class="string">"today"</span>);</span><br><span class="line">channel.basicPublish(exchangeName, routingKey, </span><br><span class="line">                           <span class="keyword">new</span> AMQP.BasicProperties.Builder()</span><br><span class="line">                           .headers(headers)</span><br><span class="line">                           .build()), messageBodyBytes); </span><br><span class="line"></span><br><span class="line"><span class="comment">//还可以带过期时间</span></span><br><span class="line">channel.basicPublish(exchangeName, routingKey, </span><br><span class="line">                           <span class="keyword">new</span> AMQP.BasicProperties.Builder()</span><br><span class="line">                           .expiration(<span class="string">"60000"</span>) </span><br><span class="line">                           .build()), messageBodyBytes);</span><br></pre></td></tr></table></figure><p>包括各种重载方法，有以下具体参数：</p><ul><li>exchange：交换器的名称，指明消息需要发送到哪个交换器中，如果设置为空字符串， 则消息会被发送到 RabbitMQ 默认的交换器中。 </li><li>routingKey：路由键，交换器根据路由键将消息存储到相应的队列之中 </li><li>props：消息的基本属性集，其包含 14 个属性成员，分别有 <code>contentType</code> 、<code>contentEncoding</code> 、 <code>headers(Map&lt;String, Object&gt;)</code> 、<code>deliveryMode</code> 、<code>priority</code> 、<code>correlationId</code> 、<code>replyTo</code> 、<code>expiration</code> 、<code>messageId</code> 、<code>timestamp</code> 、<code>type</code> 、<code>userId</code> 、<code>appId</code> 、<code>clusterId</code> </li><li>byte[] body：消息体，真正要发送的消息。</li><li>mandatory：</li><li>immediate：</li></ul><hr><h2 id="第四节-消费消息"><a href="#第四节-消费消息" class="headerlink" title="第四节 消费消息"></a><strong>第四节 消费消息</strong></h2><p>两种模式：</p><ul><li>推模式：采用 <code>Basic.Consume</code> 进行消费；</li><li>拉模式：采用 <code>Basic.Get</code> 进行消费。</li></ul><h3 id="4-1-推模式"><a href="#4-1-推模式" class="headerlink" title="4.1 推模式"></a>4.1 推模式</h3><p>通过持续订阅的方式消费消息，接收消息一般通过实现 <code>Consumer</code> 接口或者继承 <code>DefaultConsumer</code> 类来实现。不同的订阅采用不同的消费者标签（ConsumerTag）来区分彼此。</p><p>主要通过方法 <code>channel.basicConsume()</code> ：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">      </span><br><span class="line">      <span class="comment">//接收到消息之后进行显式 ack 操作 channel.basicAck 对于消费者很必要，防止消息不必要的消失</span></span><br><span class="line"><span class="keyword">boolean</span> autoAck = <span class="keyword">false</span>;</span><br><span class="line">      channel.basicQos(<span class="number">64</span>); <span class="comment">//设置客户端最多接收未被 ack 的消息的个数</span></span><br><span class="line">      channel.basicConsume(QUEUE_NAME, autoAck, <span class="string">"myConsumerTag"</span>,</span><br><span class="line">              <span class="keyword">new</span> DefaultConsumer(channel) &#123;</span><br><span class="line">                  <span class="meta">@Override</span></span><br><span class="line">                  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">handleDelivery</span><span class="params">(String consumerTag,</span></span></span><br><span class="line"><span class="function"><span class="params">                                             Envelope envelope,</span></span></span><br><span class="line"><span class="function"><span class="params">                                             AMQP.BasicProperties properties,</span></span></span><br><span class="line"><span class="function"><span class="params">                                             <span class="keyword">byte</span>[] body)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">                      String routingKey = envelope.getRoutingKey();</span><br><span class="line">                      String contentType = properties.getContentType();</span><br><span class="line">                      <span class="keyword">long</span> deliveryTag = envelope.getDeliveryTag();</span><br><span class="line">                      <span class="comment">// process the message components here ...</span></span><br><span class="line">                      channel.basicAck(envelope.getDeliveryTag(), <span class="keyword">false</span>);</span><br><span class="line">                  &#125;</span><br><span class="line">              &#125;);</span><br></pre></td></tr></table></figure><p>常用参数：</p><ul><li>queue：队列的名称；</li><li>autoAck：设置是否自动确认。建议设成 false ，即不自动确认；</li><li>consumerTag：消费者标签，用来区分多个消费者；</li><li>noLocal 设置为 true 则表示不能将同一个 Connection 中生产者发送的消息传送给这个 Connection 中的消费者；</li><li>exclusive：设置是否排他 ；</li><li>arguments：设置消费者的其他参数；</li><li>callback：设置消费者的回调函数。用来处理 RabbitMQ 推送过来的消息，比如 DefaultConsumer 使用时需要客户端重写其中的方法。</li></ul><p>消费者客户端可以重写多种方法：</p><ul><li><code>handleDelivery()</code></li><li><code>handleConsumerOk()</code> ：会在其他方法之前调用，返回消费者标签。</li><li><code>handleCancelOk()</code> ：消费端可以在显式地取消订阅的时候调用。</li><li><code>handleCancel()</code> ：消费端可以在隐式地取消订阅的时候调用</li><li><code>handleShutdownSignal()</code> ：当 Channel 或者 Connection 关闭的时候会调用。</li><li><code>handleRecoverOk()</code></li></ul><p>通过 <code>channel.basicCancel()</code> 显式地取消一个消费者的订阅，先触发 <code>handleConsumerOk()</code> ，然后是 <code>handleDelivery()</code> ，最后是 <code>handleCancelOk()</code> 。</p><p>和生产者一样，消费者客户端同样需要考虑线程安全的问题。消费者客户端的这些 callback 会被分配到与 Channel 不同的线程池上，这意味着消费者客户端可以安全地调用这些阻塞方法，比如 <code>channel.queueDeclare</code> ， <code>channel.basicCancel</code> 等。 </p><p>每个 Channel 都拥有自己独立的线程。最常用的做法是一个 Channel 对应一个消费者， 也就是意味着消费者彼此之间没有任何关联。当然也可以在一个 Channel 中维持多个消费者， 但是要注意一个问题，如果 Channel 中的一个消费者一直在运行，那么其他消费者的 callback 会被“耽搁”。</p><p><img src="https://pic-1258215793.cos.ap-shanghai.myqcloud.com/content/20200901/202009010153.png" alt></p><h3 id="4-2-拉模式"><a href="#4-2-拉模式" class="headerlink" title="4.2 拉模式"></a>4.2 拉模式</h3><p>通过 <code>channel.basicGet()</code> 可以单条的获取消息，当 autoAck 设置为false，需要用 <code>channel.basicAck()</code> 来确认消息已被成功接收。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">GetResponse response = channel.basicGet(QUEUE_NAME, <span class="keyword">false</span>);</span><br><span class="line">System.out,println(<span class="keyword">new</span> String(response.getBody()));</span><br><span class="line">channel.basicAck(response.getEnvelope().getDeliveryTag(), <span class="keyword">false</span>);</span><br></pre></td></tr></table></figure><p><img src="https://pic-1258215793.cos.ap-shanghai.myqcloud.com/content/20200901/202009010158.png" alt></p><p><code>Basic.Consume</code> 将信道（Channel）置为接收模式，直到取消队列的订阅为止。在接收模式期间， RabbitMQ 会不断地推送消息给消费者，当然推送消息的个数还是会受到 <code>Basic.Qos</code> 的限制．如果只想从队列获得单条消息而不是持续订阅，建议还是使用 <code>Basic.Get</code> 进行消费．但是不能将 <code>Basic.Get</code> 放在一个循环里来代替 <code>Basic.Consume</code> ，这样做会严重影响 RabbitMQ 的性能．如果要实现高吞吐量，消费者理应使用 <code>Basic.Consume</code> 方法。</p><hr><h2 id="第五节-消费端的确认与拒绝"><a href="#第五节-消费端的确认与拒绝" class="headerlink" title="第五节 消费端的确认与拒绝"></a><strong>第五节 消费端的确认与拒绝</strong></h2><p>为了保证消息从队列可靠地达到消费者， RabbitMQ 提供了消息确认机制 （message acknowledgement）。消费者在订阅队列时，可以指定 autoAck 参数，当 autoAck 等于 false 时， RabbitMQ 会等待消费者显式地回复确认信号后才从内存（或者磁盘）中移去消息（实质上是先打上删除标记，之后再删除）。当 autoAck 等于 true 时， RabbitMQ 会自动把发送出去的消息置为确认，然后从内存（或者磁盘）中删除，而不管消费者是否真正地消费到了这些消息。</p><p>采用消息确认机制后，只要设置 autoAck 参数为 false ，消费者就有足够的时间处理消息（任务），不用担心处理消息过程中消费者进程挂掉后消息丢失的问题 因为 RabbitMQ 会一直等待持有消息直到消费者显式调 <code>Basic.Ack</code> 命令为止。</p><p>当 autoAck 参数置为 false ，对于 RabbitMQ 服务端而言，队列中的消息分成了两个部分：一部分是等待投递给消费者的消息；一部分是己经投递给消费者，但是还没有收到消费者确认信号的消息。如果 RabbitMQ 一直没有收到消费者的确认信号，并且消费此消息的消费者己经断开连接，则 RabbitMQ 会安排该消息重新进入队列，等待投递给下一个消费者，当然也有可能还是原来的那个消费者。</p><p>RabbitMQ 不会为未确认的消息设置过期时间，它判断此消息是否需要重新投递给消费者的唯一依据是消费该消息的消费者连接是否己经断开，这么设计的原因是 RabbitMQ 允许消费者消费一条消息的时间可以很久很久。 </p><p>RabbtiMQ 的 Web 管理平台上可以看到当前队列中的“Ready ”状态 和“Unacknowledged ＂状态的消息数，分别对应上文中的等待投递给消费者的消息数和己经投递给消费者但是未收到确认信号的消息数：</p><p><img src="https://pic-1258215793.cos.ap-shanghai.myqcloud.com/content/20200901/202009010159.png" alt></p><p>也可以通过相应的命令来查看上述信息：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> rabbitmqctl list_queues name message_ready messages_unacknowledged</span></span><br><span class="line">Listing queues ...</span><br><span class="line">queue         1   0</span><br><span class="line">queue_demo    0</span><br></pre></td></tr></table></figure><p>在消费者接收到消息后，如果想明确拒绝当前的消息而不是确认，那么应该怎么做呢？通过 <code>Basic.Reject</code> 这个命令，消费者客户端可以调用与其对应的 <code>channel.basicReject</code> 方法来告诉 RabbitMQ 拒绝这个消息。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">basicReject</span><span class="params">(<span class="keyword">long</span> deliveryTag, <span class="keyword">boolean</span> requeue)</span> <span class="keyword">throws</span> IOException</span>;</span><br></pre></td></tr></table></figure><ul><li>deliveryTag：消息编号，64位的长整型值。</li><li>requeue：当为true时，RabbitMQ会重新将此条消息存入队列，以便可以发送给下一个订阅的消费者；当为false时，立即将消息从队列中移除。</li></ul><p>批量拒绝消息需要 <code>Basic.Nack</code> ，客户端：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">basicNack</span><span class="params">(<span class="keyword">long</span> deliveryTag, <span class="keyword">boolean</span> multiple, <span class="keyword">boolean</span> requeue)</span> <span class="keyword">throws</span> IOException</span>;</span><br></pre></td></tr></table></figure><ul><li>multiple：为false时，表示拒绝单条消息；为true时，拒绝编号前所有未被消费者确认的消息。</li></ul><p><code>channel.basicRecover()</code> 请求RabbitMQ重新发送还未被确认的消息：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Basic.<span class="function">RecoverOk <span class="title">basicRecover</span><span class="params">(<span class="keyword">boolean</span> requeue)</span> <span class="keyword">throws</span> IOException</span>;</span><br></pre></td></tr></table></figure><ul><li>requeue：为true，未被确认的消息会被重新加入到队列，可能会被分配给另外一个消费者；为false，同一条消息会被分配给之前相同的消费者。</li></ul><hr><h2 id="第六节-关闭连接"><a href="#第六节-关闭连接" class="headerlink" title="第六节 关闭连接"></a><strong>第六节 关闭连接</strong></h2><p>在应用程序使用完之后，需要关闭连接，释放资源：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">channel.close();</span><br><span class="line">conn.close();</span><br></pre></td></tr></table></figure><p>在 Connection 关闭的时候， Channel 也会自动关闭。</p><p>Connection Channel 所具备的生命周期如下所述：</p><ul><li>Open：开启状态，代表当前对象可以使用。 </li><li>Closing：正在关闭状态。当前对象被显式地通知调用关闭方法（shutdown），这样就产生了一个关闭请求让其内部对象进行操作并等待这些关闭操作的完成。 </li><li>Closed：已经关闭状态。当前对象己经接收到所有的内部对象己完成关闭动作的通知，并且其也关闭了自身。</li></ul><p>当 Connection 或者 Channel 的状态转变为 Closed 的时候会调用  <code>ShutdownListener</code> 。而且如果将一个 <code>ShutdownListener</code> 注册到一个己经处于 Closed 状态的对象（这里特指 Connection 和 Channel 对象），会立刻调用  <code>ShutdownListener</code> 。</p><p><code>getCloseReason</code> 方法可以让你知道对象关闭的原因 <code>isOpen</code> 方法检测对象当前是否处于开启状态： <code>close(int closeCode , String closeMessage)</code> 方法显式地通知当前对象执行关闭操作。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">connection.addShutdownListener(<span class="keyword">new</span> ShutdownListener()&#123;</span><br><span class="line">       <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">shutdownCompleted</span><span class="params">(ShutdownSignalException cause)</span></span>&#123;</span><br><span class="line">           ......</span><br><span class="line">       &#125;</span><br><span class="line">   &#125;);</span><br></pre></td></tr></table></figure><p>当触发 ShutdownListener 的时候，就可以获取到 ShutdownSignalException ，这个 ShutdownSignalException 包含了关闭的原因，可以通过<code>getCloseReason</code> 方法获取。 <code>isHardError</code> 方法 可以知道是 <code>Connection</code> 的还是 <code>Channel</code> 的错误； <code>getReason</code> 方法可以获取 cause 相关的信息：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">shutdownCompleted</span><span class="params">(ShutdownSignal cause)</span></span>&#123;</span><br><span class="line">       <span class="keyword">if</span>(cause.isHardError())&#123;</span><br><span class="line">           Connection conn = (Connection) cause.getReference();</span><br><span class="line">           <span class="keyword">if</span>(!cause.isInitiatedByApplication())&#123;</span><br><span class="line">               Method reason = cause.getReason();</span><br><span class="line">               ...</span><br><span class="line">           &#125;</span><br><span class="line">           ...</span><br><span class="line">       &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">           Channel ch = (Channel) cause.getReference();</span><br><span class="line">           ...</span><br><span class="line">       &#125;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure><hr><p>参考：</p><blockquote><p>《RabbitMQ实战指南》</p></blockquote><p><em>若内容涉及侵权请及时告知，我会尽快修改和删除相关内容</em></p>]]></content>
    
    <summary type="html">
    
      学习RabbitMQ，第二章《客户端开发》，内容来自于《RabbitMQ实战指南》。
    
    </summary>
    
      <category term="技术文档" scheme="http://linyishui.top/categories/%E6%8A%80%E6%9C%AF%E6%96%87%E6%A1%A3/"/>
    
    
      <category term="distributed" scheme="http://linyishui.top/tags/distributed/"/>
    
      <category term="mom" scheme="http://linyishui.top/tags/mom/"/>
    
      <category term="rabbitmq" scheme="http://linyishui.top/tags/rabbitmq/"/>
    
  </entry>
  
  <entry>
    <title>RabbitMQ（一）简介和入门</title>
    <link href="http://linyishui.top/2020091901.html"/>
    <id>http://linyishui.top/2020091901.html</id>
    <published>2020-09-19T04:30:19.000Z</published>
    <updated>2020-09-24T07:07:48.501Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="RabbitMQ（一）简介和入门"><a href="#RabbitMQ（一）简介和入门" class="headerlink" title="RabbitMQ（一）简介和入门"></a><strong>RabbitMQ（一）简介和入门</strong></h1><h2 id="第一节-概述"><a href="#第一节-概述" class="headerlink" title="第一节 概述"></a><strong>第一节 概述</strong></h2><h3 id="1-1-什么是消息中间件"><a href="#1-1-什么是消息中间件" class="headerlink" title="1.1 什么是消息中间件"></a><strong>1.1 什么是消息中间件</strong></h3><p><strong>消息</strong>指在应用间传送的数据。可以只包含字符串、JSON等，也可以包括内嵌对象。</p><p><strong>消息队列中间件</strong>（Message Queue Middleware，即MQ）指利用高效可靠的消息传递机制进行与平台无关的数据交流，并基于数据通信来进行分布式系统的集成。<strong>通过消息传递和消息排队模型，可以在分布式环境下扩展进程间通信</strong>。</p><p>两种传递模式：</p><ul><li><strong>点对点模式</strong>（P2P）：基于队列，消息生产者发送消息到队列，消息消费者从队列接受消息。队列使消息的<strong>异步传输</strong>成为可能。</li><li><strong>发布/订阅模式</strong>（Pub/Sub）：订阅了如何向一个内容节点发布和订阅消息，内容节点被称为<strong>主题</strong>（topic），可以看作是消息传递的中介，消息发布者将消息发布到某个主题，订阅者从主题订阅消息。主题使发布者和订阅者相互独立，可以在消息的<strong>一对多广播</strong>时采用。</li></ul><p>消息中间件提供了基于存储和转发的应用程序之间的异步数据发生，即应用程序间不直接通信，而是作为中介的消息中间件通信。消息中间件封装了远程过程调用（RPC）和网络通信协议的细节。</p><h3 id="1-2-常见的消息中间件"><a href="#1-2-常见的消息中间件" class="headerlink" title="1.2 常见的消息中间件"></a><strong>1.2 常见的消息中间件</strong></h3><p>常见的几款开源消息中间件：</p><ul><li>RabbitMQ：基于AMQP协议，主流消息中间件之一，适合数据量没那么大的项目；</li><li>Kafka：诞生于LinkedIn公司，吞吐量大，可用性高，常用于大数据领域。</li><li>ActiveMQ：Apache老牌消息引擎；</li><li>RocketMQ：阿里巴巴开源产品，Java实现，参考了Kafka的设计，可用性和吞吐量很高，适合于电商和金融互联网场景。</li><li>Apollo：Apache的ActiveMQ子项目。</li></ul><h3 id="1-3-消息中间件的作用"><a href="#1-3-消息中间件的作用" class="headerlink" title="1.3 消息中间件的作用"></a><strong>1.3 消息中间件的作用</strong></h3><ul><li><strong>解耦</strong>：只要遵守同样的接口约束，我们可以独立的扩展和修改通信两端的处理过程。</li><li><strong>冗余（存储）</strong>：消息中间件可以把数据进行持久化直到被完全处理，可以规避数据丢失的风险。即消息在被从中间件删除前，需要处理系统明确的指出此消息已被处理完成。</li><li><strong>扩展性</strong>：因为解耦了应用的处理过程，所以提高消息的入队和处理效率很容易，只须增加处理过程，不需改动代码也不需调节参数。</li><li><strong>削峰</strong>：访问量剧增时，这种情况不一定是常态，如果以此为标准投入资源无疑是巨大的浪费。消息中间件可以使关键组件支撑突发访问压力，不会因为突发的超负荷请求而崩溃。</li><li><strong>可恢复性</strong>：消息中间件降低了进程间的耦合度，即使一个处理消息的进程挂掉，消息仍可以等到系统恢复后进行处理。</li><li><strong>顺序保证</strong>：大部分消息中间件支持一定程度上的数据处理的顺序性。</li><li><strong>缓冲</strong>：消息中间件通过一个缓冲层帮助任务以最高效率执行，有助于控制和优化数据流经过系统的速度。</li><li><strong>异步通信</strong>：有时应用不想也不需要立即处理消息，消息中间件提供了异步处理机制，应用可以放入一些消息但不立即处理。</li></ul><h3 id="1-4-RabbitMQ的发展历程"><a href="#1-4-RabbitMQ的发展历程" class="headerlink" title="1.4 RabbitMQ的发展历程"></a><strong>1.4 RabbitMQ的发展历程</strong></h3><p>RabbitMQ基于 Erlang 语言实现 <strong>AMQP</strong>（Advanced Message Queuing Protocol，高级消息队列协议）的消息中间件，起源于金融系统，用于在分布式系统中存储转发消息。</p><p>之前，商业的消息中间件如微软的MSMQ、IBM的WebSphere等没有创建标准来实现MQ产品的互通或允许应用自定义MQ平台。<strong>JMS</strong>（Java Message Service）应运而生，<strong>试图通过提供公共Java API的方式隐藏单独MQ产品的实际接口，来解决互通问题</strong>。<strong>ActiveMQ</strong>就是基于JMS的一种实现，但这种使用单独标准化接口来胶合不同的接口最终还是会暴露问题，所以业内需要一种新的消息通信标准化方案。</p><p>2006年6月，Cisco、Redhat、iMatix等联合制定了AMQP标准，它是应用层协议的一个开放标准，来解决众多消息中间件的需求和拓扑结构问题。<strong>面向消息的中间件设计，基于此协议的客户端和消息中间件可以传递消息，不受产品、开发语言的限制。</strong></p><p>RabbitMQ早期即实现了AMQP的一个特性：使用协议本身就可以对队列和交换器这样的资源进行配置。而商业MQ进行资源配置需要管理终端的特定工具。</p><h3 id="1-5-RabbitMQ的特点"><a href="#1-5-RabbitMQ的特点" class="headerlink" title="1.5 RabbitMQ的特点"></a><strong>1.5 RabbitMQ的特点</strong></h3><ul><li><strong>可靠性</strong>：通过如持久化、传输确认及发布确认等保障可靠性。</li><li><strong>灵活路由</strong>：消息进入队列前，通过交换器来路由消息。基本的路由功能由内置的交换器来实现，复杂的路由功能可以绑定多个路由器实现，也可以通过插件机制实现自定义的交换器。</li><li><strong>扩展性</strong>：多个RabbitMQ节点可以组成集群，可以根据实际业务情况动态扩展节点。</li><li><strong>高可用性</strong>：队列可以在集群的机器上设置镜像，在部分节点出现问题时仍能使用队列。</li><li><strong>多种协议</strong>：除了原生AMQP协议，还支持STOMP、MQTT等多种消息中间件协议。</li><li><strong>多语言客户端</strong>：支持几乎所有常用语言，如Java、Python、Ruby、PHP、C#、JavaScript等。</li><li><strong>管理界面</strong>：提供了一个易用的用户界面，可以监控和管理消息、集群中的节点等。</li><li><strong>插件机制</strong>：提供了许多插件，可以进行扩展，也可以自定义插件。</li></ul><hr><h2 id="第二节-RabbitMQ的安装和简单实用"><a href="#第二节-RabbitMQ的安装和简单实用" class="headerlink" title="第二节 RabbitMQ的安装和简单实用"></a><strong>第二节 RabbitMQ的安装和简单实用</strong></h2><h3 id="2-1-安装"><a href="#2-1-安装" class="headerlink" title="2.1 安装"></a><strong>2.1 安装</strong></h3><p>首先要安装Erlang，官网地址：<a href="http://www.erlang.org/downloads" target="_blank" rel="noopener">Erlang-Download</a> 。以下基于Linux操作系统安装。</p><h4 id="（1）安装Erlang"><a href="#（1）安装Erlang" class="headerlink" title="（1）安装Erlang"></a><strong>（1）安装Erlang</strong></h4><p>创建安装目录 <code>/opt/erlang</code> ，并下载安装包：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">[root@iZ2zeet6kto8eqx1w7sluzZ ~]# cd /opt</span><br><span class="line">[root@iZ2zeet6kto8eqx1w7sluzZ opt]# ls</span><br><span class="line">containerd  gitlab</span><br><span class="line">[root@iZ2zeet6kto8eqx1w7sluzZ opt]# mkdir /erlang</span><br><span class="line">[root@iZ2zeet6kto8eqx1w7sluzZ opt]# cd /erlang</span><br><span class="line">[root@iZ2zeet6kto8eqx1w7sluzZ erlang]# wget http://erlang.org/download/otp_src_23.0.tar.gz</span><br><span class="line">--2020-09-21 16:20:16--  http://erlang.org/download/otp_src_23.0.tar.gz</span><br><span class="line">Resolving erlang.org (erlang.org)... 192.121.151.106</span><br><span class="line">Connecting to erlang.org (erlang.org)|192.121.151.106|:80... connected.</span><br><span class="line">HTTP request sent, awaiting response... 200 OK</span><br><span class="line">Length: 88865562 (85M) [application/gzip]</span><br><span class="line">Saving to: ‘otp_src_23.0.tar.gz’</span><br><span class="line"></span><br><span class="line"><span class="meta"> 2%</span><span class="bash"> [=&gt;                                                                                                                   ] 1,907,973   6.64KB/s  eta 2h 40m</span></span><br></pre></td></tr></table></figure><p>官网下载速度太慢，访问 <a href="https://www.erlang-solutions.com/resources/download.html" target="_blank" rel="noopener">RabbitMQ - Erlang</a> 选择对应服务器，复制下载地址：</p><p><img src="https://pic-1258215793.cos.ap-shanghai.myqcloud.com/content/20200901/202009010154.png" alt></p><p>先删除未下载完成的文件，重新下载：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">[root@iZ2zeet6kto8eqx1w7sluzZ erlang]# ls</span><br><span class="line">otp_src_23.0.tar.gz</span><br><span class="line">[root@iZ2zeet6kto8eqx1w7sluzZ erlang]# rm -f otp_src_23.0.tar.gz</span><br><span class="line">[root@iZ2zeet6kto8eqx1w7sluzZ erlang]# ls</span><br><span class="line">[root@iZ2zeet6kto8eqx1w7sluzZ erlang]# wget https://packages.erlang-solutions.com/erlang/rpm/centos/7/x86_64/esl-erlang_23.0.3-1~centos~7_amd64.rpm</span><br><span class="line">--2020-09-21 16:37:11--  https://packages.erlang-solutions.com/erlang/rpm/centos/7/x86_64/esl-erlang_23.0.3-1~centos~7_amd64.rpm</span><br><span class="line">Resolving packages.erlang-solutions.com (packages.erlang-solutions.com)... 13.227.21.48, 13.227.21.118, 13.227.21.90, ...</span><br><span class="line">Connecting to packages.erlang-solutions.com (packages.erlang-solutions.com)|13.227.21.48|:443... connected.</span><br><span class="line">HTTP request sent, awaiting response... 200 OK</span><br><span class="line">Length: 43642720 (42M) [application/x-rpm]</span><br><span class="line">Saving to: ‘esl-erlang_23.0.3-1~centos~7_amd64.rpm’</span><br><span class="line"></span><br><span class="line"><span class="meta">100%</span><span class="bash">[====================================================================================================================&gt;] 43,642,720  23.1KB/s   <span class="keyword">in</span> 24m 34s</span></span><br><span class="line"></span><br><span class="line">2020-09-21 17:01:49 (28.9 KB/s) - ‘esl-erlang_23.0.3-1~centos~7_amd64.rpm’ saved [43642720/43642720]</span><br></pre></td></tr></table></figure><p>通过 <code>yum install</code> 安装程序：（会安装到默认目录）</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br></pre></td><td class="code"><pre><span class="line">[root@iZ2zeet6kto8eqx1w7sluzZ erlang]# ls</span><br><span class="line">esl-erlang_23.0.3-1~centos~7_amd64.rpm</span><br><span class="line">[root@iZ2zeet6kto8eqx1w7sluzZ erlang]# yum install esl-erlang_23.0.3-1~centos~7_amd64.rpm</span><br><span class="line">Loaded plugins: fastestmirror</span><br><span class="line">Examining esl-erlang_23.0.3-1~centos~7_amd64.rpm: esl-erlang-23.0.3-1.x86_64</span><br><span class="line">Marking esl-erlang_23.0.3-1~centos~7_amd64.rpm to be installed</span><br><span class="line">Resolving Dependencies</span><br><span class="line"><span class="meta">--&gt;</span><span class="bash"> Running transaction check</span></span><br><span class="line"><span class="meta">---&gt;</span><span class="bash"> Package esl-erlang.x86_64 0:23.0.3-1 will be installed</span></span><br><span class="line"><span class="meta">--&gt;</span><span class="bash"> Processing Dependency: libodbc.so.2()(64bit) <span class="keyword">for</span> package: esl-erlang-23.0.3-1.x86_64</span></span><br><span class="line">Determining fastest mirrors</span><br><span class="line">base                                                                                                                                   | 3.6 kB  00:00:00     </span><br><span class="line">docker-ce-stable                                                                                                                       | 3.5 kB  00:00:00     </span><br><span class="line">epel                                                                                                                                   | 4.7 kB  00:00:00</span><br><span class="line">......</span><br><span class="line">gitlab_gitlab-ee/x86_64/primary                                                                                                        | 2.6 MB  00:00:06     </span><br><span class="line">gitlab_gitlab-ee                                                                                                                                      623/623</span><br><span class="line"></span><br><span class="line">......</span><br><span class="line"></span><br><span class="line">Dependencies Resolved</span><br><span class="line"></span><br><span class="line">......</span><br><span class="line"></span><br><span class="line">Total size: 107 M</span><br><span class="line">Total download size: 462 k</span><br><span class="line">Installed size: 107 M</span><br><span class="line">Is this ok [y/d/N]: y</span><br><span class="line"></span><br><span class="line">......</span><br><span class="line"></span><br><span class="line">Complete!</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 通过rpm查看软件是否安装</span></span><br><span class="line">[root@iZ2zeet6kto8eqx1w7sluzZ erlang]# rpm -qa | grep erlang</span><br><span class="line">esl-erlang-23.0.3-1.x86_64</span><br><span class="line"><span class="meta">#</span><span class="bash"> 查看软件安装目录</span></span><br><span class="line">[root@iZ2zeet6kto8eqx1w7sluzZ erlang]# rpm -ql esl-erlang-23.0.3-1.x86_64</span><br><span class="line">/usr/bin/cpu_sup</span><br><span class="line">/usr/bin/ct_run</span><br><span class="line">/usr/bin/dialyzer</span><br><span class="line">/usr/bin/epmd</span><br><span class="line">/usr/bin/erl</span><br><span class="line">/usr/bin/erl_call</span><br><span class="line">/usr/bin/erlc</span><br><span class="line">/usr/bin/escript</span><br><span class="line">/usr/bin/etop</span><br><span class="line">/usr/bin/getop</span><br><span class="line">/usr/bin/heart</span><br><span class="line">/usr/bin/memsup</span><br><span class="line">/usr/bin/run_erl</span><br><span class="line">/usr/bin/run_test</span><br><span class="line">/usr/bin/start_erl</span><br><span class="line">/usr/bin/start_webtool</span><br><span class="line">/usr/bin/to_erl</span><br><span class="line">/usr/bin/typer</span><br><span class="line">/usr/lib/erlang/COPYRIGHT</span><br><span class="line">/usr/lib/erlang/Install</span><br><span class="line"><span class="meta">#</span><span class="bash"> 或者直接查看目录</span></span><br><span class="line">[root@iZ2zeet6kto8eqx1w7sluzZ erlang]# rpm -qal | grep erlang</span><br></pre></td></tr></table></figure><p>若出现报错：No curses library functions found 。需要安装 ncurses：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">yum install ncurses-devel</span><br></pre></td></tr></table></figure><p>若继续出现如 No XXXXX found 的提示，可以自行安装对应包，之后再次尝试安装Erlang直到提示安装完毕。</p><p>修改 <code>/etc/profile</code> 配置文件，添加如下环境变量：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">[root@iZ2zeet6kto8eqx1w7sluzZ erlang]# cd /</span><br><span class="line">[root@iZ2zeet6kto8eqx1w7sluzZ /]# vi /etc/profile</span><br><span class="line"></span><br><span class="line">export PATH=$PATH:/usr/bin</span><br></pre></td></tr></table></figure><p>修改完，执行如下命令使配置文件生效：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[root@iZ2zeet6kto8eqx1w7sluzZ /]# source /etc/profile</span><br></pre></td></tr></table></figure><p>通过 <code>erl</code> 命令验证是否安装成功：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">[root@iZ2zeet6kto8eqx1w7sluzZ erlang]# erl -version</span><br><span class="line">Erlang (SMP,ASYNC_THREADS,HIPE) (BEAM) emulator version 11.0.3</span><br></pre></td></tr></table></figure><h4 id="（2）安装RabbitMQ"><a href="#（2）安装RabbitMQ" class="headerlink" title="（2）安装RabbitMQ"></a><strong>（2）安装RabbitMQ</strong></h4><p>首先下载安装包，官网地址：<a href="http://www.rabbitmq.com/releases/rabbitmq-server/" target="_blank" rel="noopener">RabbitMQ</a> 。</p><p>然后可以将RabbitMQ和Erlang安装在同一目录（/opt）：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line">[root@iZ2zeet6kto8eqx1w7sluzZ rabbitmq]# wget https://www.rabbitmq.com/releases/rabbitmq-server/v3.6.15/rabbitmq-server-3.6.15-1.el7.noarch.rpm</span><br><span class="line">--2020-09-21 17:39:13--  https://www.rabbitmq.com/releases/rabbitmq-server/v3.6.15/rabbitmq-server-3.6.15-1.el7.noarch.rpm</span><br><span class="line">Resolving www.rabbitmq.com (www.rabbitmq.com)... 104.20.11.224, 172.67.16.25, 104.20.10.224, ...</span><br><span class="line">Connecting to www.rabbitmq.com (www.rabbitmq.com)|104.20.11.224|:443... connected.</span><br><span class="line">HTTP request sent, awaiting response... 200 OK</span><br><span class="line">Length: 5075721 (4.8M) [application/x-redhat-package-manager]</span><br><span class="line">Saving to: ‘rabbitmq-server-3.6.15-1.el7.noarch.rpm’</span><br><span class="line"></span><br><span class="line"><span class="meta">100%</span><span class="bash">[====================================================================================================================&gt;] 5,075,721   1.73MB/s   <span class="keyword">in</span> 2.8s   </span></span><br><span class="line"></span><br><span class="line">2020-09-21 17:39:18 (1.73 MB/s) - ‘rabbitmq-server-3.6.15-1.el7.noarch.rpm’ saved [5075721/5075721]</span><br><span class="line"></span><br><span class="line">......</span><br><span class="line"></span><br><span class="line">[root@iZ2zeet6kto8eqx1w7sluzZ rabbitmq]# ls</span><br><span class="line">rabbitmq-server-3.6.15-1.el7.noarch.rpm</span><br><span class="line">[root@iZ2zeet6kto8eqx1w7sluzZ rabbitmq]# yum install rabbitmq-server-3.6.15-1.el7.noarch.rpm</span><br><span class="line"></span><br><span class="line">......</span><br><span class="line"></span><br><span class="line">Complete!</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 通过rpm查看软件是否安装</span></span><br><span class="line">[root@iZ2zeet6kto8eqx1w7sluzZ rabbitmq]# rpm -qa | grep rabbitmq</span><br><span class="line">rabbitmq-server-3.6.15-1.el7.noarch</span><br><span class="line"><span class="meta">#</span><span class="bash"> 查看软件安装目录</span></span><br><span class="line">[root@iZ2zeet6kto8eqx1w7sluzZ rabbitmq]# rpm -ql rabbitmq-server-3.6.15-1.el7.noarch</span><br><span class="line">/etc/logrotate.d/rabbitmq-server</span><br><span class="line">/etc/rabbitmq</span><br><span class="line">/usr/lib/ocf/resource.d/rabbitmq/rabbitmq-server</span><br><span class="line">/usr/lib/ocf/resource.d/rabbitmq/rabbitmq-server-ha</span><br><span class="line">......</span><br><span class="line">/usr/lib/rabbitmq/lib/rabbitmq_server-3.6.15/sbin/rabbitmq-plugins</span><br><span class="line">/usr/lib/rabbitmq/lib/rabbitmq_server-3.6.15/sbin/rabbitmq-server</span><br><span class="line">/usr/lib/rabbitmq/lib/rabbitmq_server-3.6.15/sbin/rabbitmqctl</span><br><span class="line">/usr/lib/systemd/system/rabbitmq-server.service</span><br><span class="line">/usr/lib/tmpfiles.d/rabbitmq-server.conf</span><br><span class="line">/usr/sbin/rabbitmq-plugins</span><br><span class="line">/usr/sbin/rabbitmq-server</span><br><span class="line">/usr/sbin/rabbitmqctl</span><br><span class="line">......</span><br></pre></td></tr></table></figure><p>同样修改 <code>/etc/profile</code> 文件，添加如下环境变量：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">[root@iZ2zeet6kto8eqx1w7sluzZ /]# vi /etc/profile</span><br><span class="line"></span><br><span class="line">export PATH=$PATH:/usr/sbin</span><br></pre></td></tr></table></figure><p>同样使配置文件生效：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[root@iZ2zeet6kto8eqx1w7sluzZ /]# source /etc/profile</span><br></pre></td></tr></table></figure><h4 id="（3）卸载"><a href="#（3）卸载" class="headerlink" title="（3）卸载"></a><strong>（3）卸载</strong></h4><p>卸载前先停掉rabbitmq服务，执行命令</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> service rabbitmq-server stop</span></span><br></pre></td></tr></table></figure><p>查看rabbitmq安装的相关列表</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> yum list | grep rabbitmq</span></span><br></pre></td></tr></table></figure><p>卸载rabbitmq已安装的相关内容</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> yum -y remove rabbitmq-server.noarch</span></span><br></pre></td></tr></table></figure><p>查看erlang安装的相关列表</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> yum list | grep erlang</span></span><br></pre></td></tr></table></figure><p>卸载erlang已安装的相关内容</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> yum -y remove erlang-*</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> yum -y remove erlang.x86_64</span></span><br></pre></td></tr></table></figure><h3 id="2-2-运行"><a href="#2-2-运行" class="headerlink" title="2.2 运行"></a><strong>2.2 运行</strong></h3><p>任意开启Shell，运行RabbitMQ：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> detached参数使RabbitMQ以守护进程的方式在后台运行，不会因为Shell的关闭而影响服务</span></span><br><span class="line">rabbitmq-server -detached</span><br><span class="line"><span class="meta">#</span><span class="bash"> 查看RabbitMQ是否正常启动</span></span><br><span class="line">rabbitmqctl status</span><br><span class="line"><span class="meta">#</span><span class="bash"> 查看集群信息，当前只有一个节点</span></span><br><span class="line">rabbitmqctl cluster_status</span><br></pre></td></tr></table></figure><p>运行失败：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">[root@iZ2zeet6kto8eqx1w7sluzZ rabbitmq]# rabbitmq-server -detached</span><br><span class="line">Warning: PID file not written; -detached was passed.</span><br><span class="line">[root@iZ2zeet6kto8eqx1w7sluzZ rabbitmq]# rabbitmqctl status</span><br><span class="line">Status of node rabbit@iZ2zeet6kto8eqx1w7sluzZ</span><br><span class="line">Error: unable to connect to node rabbit@iZ2zeet6kto8eqx1w7sluzZ: nodedown</span><br><span class="line"></span><br><span class="line">DIAGNOSTICS</span><br><span class="line">===========</span><br><span class="line"></span><br><span class="line">attempted to contact: [rabbit@iZ2zeet6kto8eqx1w7sluzZ]</span><br><span class="line"></span><br><span class="line">rabbit@iZ2zeet6kto8eqx1w7sluzZ:</span><br><span class="line">  * connected to epmd (port 4369) on iZ2zeet6kto8eqx1w7sluzZ</span><br><span class="line">  * epmd reports: node 'rabbit' not running at all</span><br><span class="line">                  no other nodes on iZ2zeet6kto8eqx1w7sluzZ</span><br><span class="line">  * suggestion: start the node</span><br><span class="line"></span><br><span class="line">current node details:</span><br><span class="line">- node name: 'rabbitmq-cli-57@iZ2zeet6kto8eqx1w7sluzZ'</span><br><span class="line">- home dir: /var/lib/rabbitmq</span><br><span class="line">- cookie hash: 63rISb5yZX97fhoF8LdjSg==</span><br></pre></td></tr></table></figure><p>首先排除是否是防火墙的问题：（不是这个原因）</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 查看防火墙开放端口</span></span><br><span class="line">[root@iZ2zeet6kto8eqx1w7sluzZ /]# firewall-cmd --zone=public --list-ports</span><br><span class="line">8025/tcp 6725/tcp</span><br><span class="line">[root@iZ2zeet6kto8eqx1w7sluzZ /]# systemctl stop firewalld.service</span><br><span class="line">[root@iZ2zeet6kto8eqx1w7sluzZ /]# service rabbitmq-server start</span><br><span class="line">Redirecting to /bin/systemctl start rabbitmq-server.service</span><br><span class="line">Job for rabbitmq-server.service failed because the control process exited with error code. See "systemctl status rabbitmq-server.service" and "journalctl -xe" for details.</span><br></pre></td></tr></table></figure><p>删除 <code>/var/lib/rabbitmq/mnesia</code> 目录下的文件，再重启：（不是这个原因）</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">[root@iZ2zeet6kto8eqx1w7sluzZ /]# cd /var/lib/rabbitmq/mnesia</span><br><span class="line">[root@iZ2zeet6kto8eqx1w7sluzZ mnesia]# ls -AF</span><br><span class="line">rabbit@iZ2zeet6kto8eqx1w7sluzZ.pid</span><br><span class="line">[root@iZ2zeet6kto8eqx1w7sluzZ mnesia]# rm -rf rabbit@iZ2zeet6kto8eqx1w7sluzZ.pid</span><br><span class="line">[root@iZ2zeet6kto8eqx1w7sluzZ mnesia]# service rabbitmq-server start</span><br><span class="line">Redirecting to /bin/systemctl start rabbitmq-server.service</span><br><span class="line">Job for rabbitmq-server.service failed because the control process exited with error code. See "systemctl status rabbitmq-server.service" and "journalctl -xe" for details.</span><br></pre></td></tr></table></figure><p>查看详细错误信息</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br></pre></td><td class="code"><pre><span class="line">[root@iZ2zeet6kto8eqx1w7sluzZ /]# systemctl status rabbitmq-server.service</span><br><span class="line">● rabbitmq-server.service - RabbitMQ broker</span><br><span class="line">   Loaded: loaded (/usr/lib/systemd/system/rabbitmq-server.service; disabled; vendor preset: disabled)</span><br><span class="line">   Active: activating (auto-restart) (Result: exit-code) since Tue 2020-09-22 10:19:51 CST; 3s ago</span><br><span class="line">  Process: 27630 ExecStop=/bin/sh -c while ps -p $MAINPID &gt;/dev/null 2&gt;&amp;1; do sleep 1; done (code=exited, status=0/SUCCESS)</span><br><span class="line">  Process: 27488 ExecStop=/usr/sbin/rabbitmqctl stop (code=exited, status=0/SUCCESS)</span><br><span class="line"><span class="meta">  #</span><span class="bash"> rabbitmq-server启动失败</span></span><br><span class="line">  Process: 27187 ExecStart=/usr/sbin/rabbitmq-server (code=exited, status=1/FAILURE)</span><br><span class="line"> Main PID: 27187 (code=exited, status=1/FAILURE)</span><br><span class="line"></span><br><span class="line">Sep 22 10:19:51 iZ2zeet6kto8eqx1w7sluzZ systemd[1]: Failed to start RabbitMQ broker.</span><br><span class="line">Sep 22 10:19:51 iZ2zeet6kto8eqx1w7sluzZ systemd[1]: Unit rabbitmq-server.service entered failed state.</span><br><span class="line">Sep 22 10:19:51 iZ2zeet6kto8eqx1w7sluzZ systemd[1]: rabbitmq-server.service failed.</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">[root@iZ2zeet6kto8eqx1w7sluzZ mnesia]# journalctl -xe</span><br><span class="line">Sep 22 10:26:04 iZ2zeet6kto8eqx1w7sluzZ rabbitmq-server[8731]: /var/log/rabbitmq/rabbit@iZ2zeet6kto8eqx1w7sluzZ-sasl.log</span><br><span class="line">Sep 22 10:26:04 iZ2zeet6kto8eqx1w7sluzZ rabbitmq-server[8731]: Stack trace:</span><br><span class="line">Sep 22 10:26:04 iZ2zeet6kto8eqx1w7sluzZ rabbitmq-server[8731]: []</span><br><span class="line">Sep 22 10:26:05 iZ2zeet6kto8eqx1w7sluzZ rabbitmq-server[8731]: &#123;"init terminating in do_boot",noproc&#125;</span><br><span class="line">Sep 22 10:26:05 iZ2zeet6kto8eqx1w7sluzZ rabbitmq-server[8731]: init terminating in do_boot (noproc)</span><br><span class="line">Sep 22 10:26:05 iZ2zeet6kto8eqx1w7sluzZ rabbitmq-server[8731]: Crash dump is being written to: erl_crash.dump...done</span><br><span class="line">Sep 22 10:26:05 iZ2zeet6kto8eqx1w7sluzZ systemd[1]: rabbitmq-server.service: main process exited, code=exited, status=1/FAILURE</span><br><span class="line">Sep 22 10:26:06 iZ2zeet6kto8eqx1w7sluzZ rabbitmqctl[9029]: Stopping and halting node rabbit@iZ2zeet6kto8eqx1w7sluzZ</span><br><span class="line">Sep 22 10:26:06 iZ2zeet6kto8eqx1w7sluzZ rabbitmqctl[9029]: Error: unable to connect to node rabbit@iZ2zeet6kto8eqx1w7sluzZ: nodedown</span><br><span class="line">Sep 22 10:26:06 iZ2zeet6kto8eqx1w7sluzZ rabbitmqctl[9029]: DIAGNOSTICS</span><br><span class="line">Sep 22 10:26:06 iZ2zeet6kto8eqx1w7sluzZ rabbitmqctl[9029]: ===========</span><br><span class="line">Sep 22 10:26:06 iZ2zeet6kto8eqx1w7sluzZ rabbitmqctl[9029]: attempted to contact: [rabbit@iZ2zeet6kto8eqx1w7sluzZ]</span><br><span class="line">Sep 22 10:26:06 iZ2zeet6kto8eqx1w7sluzZ rabbitmqctl[9029]: rabbit@iZ2zeet6kto8eqx1w7sluzZ:</span><br><span class="line">Sep 22 10:26:06 iZ2zeet6kto8eqx1w7sluzZ rabbitmqctl[9029]: * connected to epmd (port 4369) on iZ2zeet6kto8eqx1w7sluzZ</span><br><span class="line">Sep 22 10:26:06 iZ2zeet6kto8eqx1w7sluzZ rabbitmqctl[9029]: * epmd reports: node 'rabbit' not running at all</span><br><span class="line">Sep 22 10:26:06 iZ2zeet6kto8eqx1w7sluzZ rabbitmqctl[9029]: no other nodes on iZ2zeet6kto8eqx1w7sluzZ</span><br><span class="line">Sep 22 10:26:06 iZ2zeet6kto8eqx1w7sluzZ rabbitmqctl[9029]: * suggestion: start the node</span><br><span class="line">Sep 22 10:26:06 iZ2zeet6kto8eqx1w7sluzZ rabbitmqctl[9029]: current node details:</span><br><span class="line">Sep 22 10:26:06 iZ2zeet6kto8eqx1w7sluzZ rabbitmqctl[9029]: - node name: 'rabbitmq-cli-55@iZ2zeet6kto8eqx1w7sluzZ'</span><br><span class="line">Sep 22 10:26:06 iZ2zeet6kto8eqx1w7sluzZ rabbitmqctl[9029]: - home dir: .</span><br><span class="line">Sep 22 10:26:06 iZ2zeet6kto8eqx1w7sluzZ rabbitmqctl[9029]: - cookie hash: 63rISb5yZX97fhoF8LdjSg==</span><br><span class="line">Sep 22 10:26:06 iZ2zeet6kto8eqx1w7sluzZ systemd[1]: Failed to start RabbitMQ broker.</span><br><span class="line">-- Subject: Unit rabbitmq-server.service has failed</span><br><span class="line">-- Defined-By: systemd</span><br><span class="line">-- Support: http://lists.freedesktop.org/mailman/listinfo/systemd-devel</span><br><span class="line">-- </span><br><span class="line">-- Unit rabbitmq-server.service has failed.</span><br><span class="line">-- </span><br><span class="line">-- The result is failed.</span><br><span class="line">Sep 22 10:26:06 iZ2zeet6kto8eqx1w7sluzZ systemd[1]: Unit rabbitmq-server.service entered failed state.</span><br><span class="line">Sep 22 10:26:06 iZ2zeet6kto8eqx1w7sluzZ systemd[1]: rabbitmq-server.service failed.</span><br><span class="line">lines 1389-1419/1419 (END)</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 尝试重启</span></span><br><span class="line">[root@iZ2zeet6kto8eqx1w7sluzZ sbin]# rabbitmq-server restart</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">BOOT FAILED</span><br><span class="line">===========</span><br><span class="line"></span><br><span class="line">Error description:</span><br><span class="line">   noproc</span><br><span class="line"></span><br><span class="line">Log files (may contain more information):</span><br><span class="line">   /var/log/rabbitmq/rabbit@iZ2zeet6kto8eqx1w7sluzZ.log</span><br><span class="line">   /var/log/rabbitmq/rabbit@iZ2zeet6kto8eqx1w7sluzZ-sasl.log</span><br><span class="line"></span><br><span class="line">Stack trace:</span><br><span class="line">   []</span><br><span class="line"></span><br><span class="line">=INFO REPORT==== 22-Sep-2020::20:41:05.655469 ===</span><br><span class="line">Error description:</span><br><span class="line">   noproc</span><br><span class="line"></span><br><span class="line">Log files (may contain more information):</span><br><span class="line">   /var/log/rabbitmq/rabbit@iZ2zeet6kto8eqx1w7sluzZ.log</span><br><span class="line">   /var/log/rabbitmq/rabbit@iZ2zeet6kto8eqx1w7sluzZ-sasl.log</span><br><span class="line"></span><br><span class="line">Stack trace:</span><br><span class="line">   []</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&#123;"init terminating in do_boot",noproc&#125;</span><br><span class="line">init terminating in do_boot (noproc)</span><br><span class="line"></span><br><span class="line">Crash dump is being written to: erl_crash.dump...done</span><br></pre></td></tr></table></figure><p>根据提示 <code>noproc</code> 考虑是否是版本不匹配，<a href="https://www.rabbitmq.com/which-erlang.html" target="_blank" rel="noopener">rabbitmq - erlang</a> 官网查询确认是否匹配：</p><ul><li>Erlang：23.0.3</li><li>RabbitMQ：3.6.15</li></ul><p><img src="https://pic-1258215793.cos.ap-shanghai.myqcloud.com/content/20200901/202009010155.png" alt></p><p>卸载当前RabbitMQ，再重新下载一个3.8.8版本的RabbitMQ：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">wget https://github.com/rabbitmq/rabbitmq-server/releases/download/v3.8.8/rabbitmq-server-3.8.8-1.el7.noarch.rpm</span><br></pre></td></tr></table></figure><p>阿里云服务器下载GitHub实在是太慢了，选择用Docker拉取镜像：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">[root@iZ2zeet6kto8eqx1w7sluzZ ~]# service docker restart</span><br><span class="line">Redirecting to /bin/systemctl restart docker.service</span><br><span class="line">[root@iZ2zeet6kto8eqx1w7sluzZ ~]# docker run -it --rm --name rabbitmq -p 5672:5672 -p 15672:15672 rabbitmq:3-management</span><br><span class="line">Unable to find image 'rabbitmq:3-management' locally</span><br><span class="line">3-management: Pulling from library/rabbitmq</span><br><span class="line">5d9821c94847: Downloading [=======================&gt;                           ]  12.53MB/26.7MB</span><br><span class="line">......</span><br></pre></td></tr></table></figure><p>仍然很慢，还是直接下载RPM文件，加上断点：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">wget -c https://github.com/rabbitmq/rabbitmq-server/releases/download/v3.8.8/rabbitmq-server-3.8.8-1.el7.noarch.rpm</span><br></pre></td></tr></table></figure><p>下载成功后，重新安装：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">[root@iZ2zeet6kto8eqx1w7sluzZ rabbitmq]# ls -AF</span><br><span class="line">rabbitmq-server-3.8.8-1.el7.noarch.rpm</span><br><span class="line">[root@iZ2zeet6kto8eqx1w7sluzZ rabbitmq]# yum install rabbitmq-server-3.8.8-1.el7.noarch.rpm</span><br></pre></td></tr></table></figure><p>重新启动：(终于成功)</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">[root@iZ2zeet6kto8eqx1w7sluzZ ~]# rabbitmq-server -detached</span><br><span class="line">[root@iZ2zeet6kto8eqx1w7sluzZ ~]# rabbitmqctl status</span><br><span class="line">Status of node rabbit@iZ2zeet6kto8eqx1w7sluzZ ...</span><br><span class="line">Runtime</span><br><span class="line"></span><br><span class="line">OS PID: 4074</span><br><span class="line">OS: Linux</span><br><span class="line">Uptime (seconds): 89</span><br><span class="line">Is under maintenance?: false</span><br><span class="line">RabbitMQ version: 3.8.8</span><br><span class="line">Node name: rabbit@iZ2zeet6kto8eqx1w7sluzZ</span><br><span class="line">Erlang configuration: Erlang/OTP 23 [erts-11.0.3] [source] [64-bit] [smp:2:2] [ds:2:2:10] [async-threads:64] [hipe]</span><br><span class="line">Erlang processes: 275 used, 1048576 limit</span><br><span class="line">Scheduler run queue: 1</span><br><span class="line">Cluster heartbeat timeout (net_ticktime): 60</span><br><span class="line">......</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 查看集群状态</span></span><br><span class="line">[root@iZ2zeet6kto8eqx1w7sluzZ ~]# rabbitmqctl cluster_status</span><br><span class="line">Cluster status of node rabbit@iZ2zeet6kto8eqx1w7sluzZ ...</span><br><span class="line">......</span><br></pre></td></tr></table></figure><h3 id="2-3-生产和消费消息"><a href="#2-3-生产和消费消息" class="headerlink" title="2.3 生产和消费消息"></a><strong>2.3 生产和消费消息</strong></h3><p>RabbitMQ的默认用户名和密码都是 <code>guest</code>，此账户只能本地访问，远程网络访问会受限，所以我们要首先<strong>添加一个用户</strong>，并<strong>设置访问权限</strong>。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 新增用户</span></span><br><span class="line">rabbitmqctl add_user root root</span><br><span class="line"><span class="meta">#</span><span class="bash"> 设置所有权限</span></span><br><span class="line">rabbitmqctl set_permissions -p / root ".*" ".*" ".*"</span><br><span class="line"><span class="meta">#</span><span class="bash"> 设置管理员角色</span></span><br><span class="line">rabbitmqctl set_user_tags root administrator</span><br></pre></td></tr></table></figure><p>若在使用RabbitMQ的过程中有 <code>com.rabbitmq.client.AuthenticationFailureException: ACCESS_REFUSED - Login was refused using authentication mechanism PLAIN</code> 类似报错，很可能就是账户的问题。</p><figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Exception <span class="keyword">in</span> thread <span class="string">"main"</span> com.rabbitmq.client.AuthenticationFailureException: ACCESS_REFUSED - Login was refused using authentication mechanism PLAIN. <span class="keyword">For</span> details see the broker logfile.</span><br><span class="line"></span><br><span class="line"><span class="builtin-name">ERROR</span> com.rabbitmq.client.impl.ForgivingExceptionHandler - An unexpected<span class="built_in"> connection </span>driver <span class="builtin-name">error</span> occured</span><br><span class="line">java.net.SocketException: Socket Closed</span><br></pre></td></tr></table></figure><p>在Java项目中引入RabbitMQ客户端的Maven依赖：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!-- https://mvnrepository.com/artifact/com.rabbitmq/amqp-client --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>com.rabbitmq<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>amqp-client<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>5.8.0<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure><p>创建消息生产者，发送一条消息：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">RabbitProducer</span> </span>&#123;</span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> String EXCHANGE_NAME = <span class="string">"exchange_demo"</span>;</span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> String ROUTING_KEY = <span class="string">"routingkey_demo"</span>;</span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> String QUEUE_NAME = <span class="string">"queue_demo"</span>;</span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> String IP_ADDRESS = <span class="string">"xxx.xxx.xxx.xxx"</span>;</span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> PORT = <span class="number">5672</span>;<span class="comment">//RabbitMQ 服务端默认端口号为 5672</span></span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException,</span></span><br><span class="line"><span class="function">                TimeoutException, InterruptedException </span>&#123;</span><br><span class="line">                ConnectionFactory factory = <span class="keyword">new</span> ConnectionFactory();</span><br><span class="line">                factory.setHost(IP_ADDRESS);</span><br><span class="line">                factory.setPort(PORT);</span><br><span class="line">                factory.setUsername(<span class="string">"root"</span>);</span><br><span class="line">                factory.setPassword(<span class="string">"root"</span>);</span><br><span class="line">                Connection connection = factory.newConnection(); <span class="comment">//创建连接</span></span><br><span class="line">                Channel channel = connection.createChannel(); <span class="comment">//创建信道</span></span><br><span class="line">                <span class="comment">// 创建一个 type direct 、持久化的、非自动删除的交换器</span></span><br><span class="line">                channel.exchangeDeclare(EXCHANGE_NAME, <span class="string">"direct"</span>, <span class="keyword">true</span>, <span class="keyword">false</span>, <span class="keyword">null</span>);</span><br><span class="line">                <span class="comment">//创建一个持久化、非排他的、非自动删除的队列</span></span><br><span class="line">                channel.queueDeclare(QUEUE_NAME, <span class="keyword">true</span>, <span class="keyword">false</span>, <span class="keyword">false</span>, <span class="keyword">null</span>);</span><br><span class="line">                <span class="comment">//将交换器与队列通过路由键绑定</span></span><br><span class="line">                channel.queueBind(QUEUE_NAME, EXCHANGE_NAME, ROUTING_KEY);</span><br><span class="line">                <span class="comment">//发送一条持久化的消息 hello world !</span></span><br><span class="line">                String message = <span class="string">"Hello World!"</span>;</span><br><span class="line">                channel.basicPublish(EXCHANGE_NAME, ROUTING_KEY,</span><br><span class="line">                        MessageProperties.PERSISTENT_TEXT_PLAIN,</span><br><span class="line">                        message.getBytes());</span><br><span class="line">                <span class="comment">//关闭资源</span></span><br><span class="line">                channel.close();</span><br><span class="line">                connection.close();</span><br><span class="line">        &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>然后是消费者：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">RabbitConsumer</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> String QUEUE_NAME = <span class="string">"queue_demo"</span>;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> String IP_ADDRESS = <span class="string">"xxx.xxx.xxx.xxx"</span>;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> PORT = <span class="number">5672</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException,</span></span><br><span class="line"><span class="function">            TimeoutException, InterruptedException </span>&#123;</span><br><span class="line">        Address[] addresses = <span class="keyword">new</span> Address[]&#123;</span><br><span class="line">                <span class="keyword">new</span> Address(IP_ADDRESS, PORT)</span><br><span class="line">        &#125;;</span><br><span class="line"></span><br><span class="line">        ConnectionFactory factory = <span class="keyword">new</span> ConnectionFactory();</span><br><span class="line">        factory.setUsername(<span class="string">"root"</span>);</span><br><span class="line">        factory.setPassword(<span class="string">"root"</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//这里的连接方式与生产者的 demo 略有不同，注意辨别区别</span></span><br><span class="line">        Connection connection = factory.newConnection(addresses); <span class="comment">//创建连接</span></span><br><span class="line">        <span class="keyword">final</span> Channel channel = connection.createChannel(); <span class="comment">//创建信道</span></span><br><span class="line">        channel.basicQos(<span class="number">64</span>); <span class="comment">//设置客户端最多接收未被 ack 的消息的个数</span></span><br><span class="line">        Consumer consumer = <span class="keyword">new</span> DefaultConsumer(channel) &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">handleDelivery</span><span class="params">(String consumerTag,</span></span></span><br><span class="line"><span class="function"><span class="params">                                       Envelope envelope,</span></span></span><br><span class="line"><span class="function"><span class="params">                                       AMQP.BasicProperties properties,</span></span></span><br><span class="line"><span class="function"><span class="params">                                       <span class="keyword">byte</span>[] body)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">                System.out.println(<span class="string">"recv message : "</span> + <span class="keyword">new</span> String(body));</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    TimeUnit.SECONDS.sleep(<span class="number">1</span>);</span><br><span class="line">                &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125;</span><br><span class="line">                channel.basicAck(envelope.getDeliveryTag(), <span class="keyword">false</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;;</span><br><span class="line">        channel.basicConsume(QUEUE_NAME, consumer);</span><br><span class="line">        <span class="comment">//等待回调函数执行完毕之后 关闭资源</span></span><br><span class="line">        TimeUnit.SECONDS.sleep(<span class="number">5</span>);</span><br><span class="line">        channel.close();</span><br><span class="line">        connection.close();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>控制台打印：</p><figure class="highlight ada"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">recv message : <span class="type">Hello</span> World!</span><br></pre></td></tr></table></figure><p>此处采用继承 <code>DefaultConsumer</code> 的方式来实现消费，也可以使用 <code>QueueingConsumer</code> 来实现，但会有些隐患，并且这种实现已被废弃。</p><hr><h2 id="第三节-Rabbit入门"><a href="#第三节-Rabbit入门" class="headerlink" title="第三节 Rabbit入门"></a><strong>第三节 Rabbit入门</strong></h2><p>RabbitMQ的模型架构是什么？AMQP协议是什么？两者间又有何种联系？消息从生产者发出到消费者消费的过程要经历什么？</p><h3 id="3-1-RabbitMQ基本概念"><a href="#3-1-RabbitMQ基本概念" class="headerlink" title="3.1 RabbitMQ基本概念"></a><strong>3.1 RabbitMQ基本概念</strong></h3><h4 id="（1）生产者和消费者模型"><a href="#（1）生产者和消费者模型" class="headerlink" title="（1）生产者和消费者模型"></a><strong>（1）生产者和消费者模型</strong></h4><p>RabbitMQ 整体上是一个<strong>生产者与消费者模型</strong>，主要<strong>负责接收、存储和转发消息</strong>。可以把消息传递的过程想象成当你将一个包裹送到邮局，邮局会暂存并最终将邮件通过邮递员送到收件人的手上，RabbitMQ就好比由邮局、邮箱和邮递员组成的一个系统。</p><p>从计算机术语层面来说， RabbitMQ模型更像是一种<strong>交换机模型</strong>。</p><p><img src="https://pic-1258215793.cos.ap-shanghai.myqcloud.com/content/20200901/202009010143.png" alt></p><p>消息一般包含2个部分：</p><ul><li><strong>消息体</strong>：消息体也可以称之为 payload ，在实际应用中，消息体一般是一个带有业务逻辑结构的数据，比如一个 JSON 字符串。当然可以进一步对这个消息体进行序列化操作。</li><li><strong>标签</strong>（Label）：用来表述这条消息，比如一个交换器的名称和一个路由键。</li></ul><p>大致流程：</p><ul><li><strong>生产者（Producer）</strong>将业务数据封装（序列化）成消息（指定Exchange和RoutingKey等），把消息交由RabbitMQ，即发送给Broker （AMQP协议中对应命令为Basic.Publish）。</li><li><strong>Broker （消息中间件的服务节点）</strong>，大多数情况下可以将 RabbitMQ Broker 看作一台 RabbitMQ 服务器。RabbitMQ之后会根据标签把消息发送给感兴趣的<strong>消费者（Consumer）</strong>。</li><li>消费者连接到 RabbitMQ 服务器，并订阅到队列上。当消费者消费一条消息时，<strong>只是消费消息的消息体</strong>（ payload ）。在消息路由的过程中，消息的标签会丢弃，<strong>存入到队列中的消息只有消息体</strong>，消费者也只会消费到消息体，也就<strong>不知道消息的生产者是谁</strong>，当然消费者也不需要知道。</li><li>消费者受到消息体后（AMQP协议中对应命令为Basic.Consume或Basic.Get）进行反序列化，得到对应的业务数据，并进行业务处理。</li></ul><p>消费者进行业务处理可以不和接收消息的逻辑使用同一线程，比如使用一个线程去接收消息存入内存（<code>BlockingQueue</code>），使用另一个线程从内存读取数据，这样可以进一步解耦，提高整体处理效率。 </p><p><img src="https://pic-1258215793.cos.ap-shanghai.myqcloud.com/content/20200901/202009010144.png" alt></p><h4 id="（2）队列"><a href="#（2）队列" class="headerlink" title="（2）队列"></a><strong>（2）队列</strong></h4><p><strong>队列</strong>（Queue）是 RabbitMQ 的内部对象，用来<strong>存储消息</strong>。<strong>消息只能存储在队列中</strong>，这与Kafka这种消息中间件相反（<strong>Kafka消息存储在主题topic逻辑层面</strong>），相对应的队列逻辑只是主题实际存储文件中的位移标识。</p><p><img src="https://pic-1258215793.cos.ap-shanghai.myqcloud.com/content/20200901/202009010145.png" alt></p><p>多个消费者可以订阅同一个队列，队列中的消息会被<strong>平均分摊</strong>（Round-Robin，即轮询）给多个消费者处理，<strong>不是每个消费者都收到所有的消息并处理</strong>。</p><p><img src="https://pic-1258215793.cos.ap-shanghai.myqcloud.com/content/20200901/202009010146.png" alt></p><p>RabbitMQ<strong>不支持队列层面的广播消费</strong>，如果需要只能进行二次开发。</p><h4 id="（3）交换器、路由键、绑定、交换器类型"><a href="#（3）交换器、路由键、绑定、交换器类型" class="headerlink" title="（3）交换器、路由键、绑定、交换器类型"></a><strong>（3）交换器、路由键、绑定、交换器类型</strong></h4><p>上面我们理解为生产者将消息直接投递到队列上，但其实并非如此。</p><p><img src="https://pic-1258215793.cos.ap-shanghai.myqcloud.com/content/20200901/202009010147.png" alt></p><p><strong>交换器</strong>（Exchange），生产者会先将消息发送到交换器，交换器负责将消息路由到一个或多个队列中。若路由不到，可以返回给生产者或直接丢弃。</p><p><strong>路由键</strong>（RoutingKey），生产者将消息发给交换器时，会指定一个路由键，用来指定消息的路由规则，可以决定消息流向哪里。路由键需要与<strong>交换器类型</strong>和<strong>绑定键</strong>（BindingKey）联合使用。</p><p><strong>绑定键</strong>（BindingKey），属于路由键的一种，通过绑定键将交换器和队列关联起来。<strong>某些情形下绑定键与路由键可以看作同一个东西。</strong></p><p><img src="https://pic-1258215793.cos.ap-shanghai.myqcloud.com/content/20200901/202009010148.png" alt></p><p>可以这样区别路由键和绑定键：</p><ul><li>使用绑定时，需要的路由键是 BindingKey 。<ul><li>涉及的客户端方法：<code>channel.exchangeBind</code> 、<code>channel.queueBind</code> </li><li>对应AMQP命令：<code>Exchange.Bind</code> 、<code>Queue.Bind</code> 。</li></ul></li><li>发送消息时，需要的路由键是 RoutingKey 。<ul><li>涉及的客户端方法：<code>channel.basicPublish</code> </li><li>对应AMQP命令：<code>Basic.Publish</code> </li></ul></li></ul><p><strong>交换器类型</strong>：</p><ul><li><p><strong>fanout</strong>：会把发送到该交换器的消息路由到所有绑定的队列中。</p></li><li><p><strong>direct</strong>：会把消息路由到BindingKey和RoutingKey完全匹配的队列中。</p><p>如下案例：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//路由键为warning，消息会路由到Queue1和Queue2</span></span><br><span class="line">channel.basicPublish(EXCHANGE_NAME, <span class="string">"warning"</span>, MessageProperties.PERSISTENT_TEXT_PLAIN,</span><br><span class="line">message.getBytes());</span><br></pre></td></tr></table></figure><p><img src="https://pic-1258215793.cos.ap-shanghai.myqcloud.com/content/20200901/202009010149.png" alt></p><p>若设置路由键为“info”或“debug”，消息只会路由到Queue2。</p></li><li><p><strong>topic</strong>：在匹配规则上相比direct进行了扩展，也是把消息路由到BindingKey和RoutingKey匹配的队列中，但匹配规则包括：</p><ul><li>RoutingKey和BindingKey为 <code>.</code> 分隔的字符串，如 <code>com.rabbitmq.client</code> 。</li><li>BindingKey中可以存着两个特殊字符串 <code>*</code> 和 <code>#</code> ，用于模糊匹配，<code>*</code> 用于匹配一个单词，<code>#</code> 用于匹配多规格单词。</li></ul><p>如下案例：</p><ul><li>路由键 <code>com.rabbitmq.client</code> 的消息同时路由到Queue1和Queue2；</li><li>路由键 <code>com.hidden.client</code> 的消息只路由到Queue2；</li><li>路由键 <code>com.hidden.demo</code> 的消息只路由到Queue2；</li><li>路由键 <code>java.rabbitmq.demo</code> 的消息只路由到Queue1；</li><li>路由键 <code>java.util.concurrent</code> 的消息会被丢弃或返回给生产者；</li></ul><p><img src="https://pic-1258215793.cos.ap-shanghai.myqcloud.com/content/20200901/202009010150.png" alt></p></li><li><p><strong>headers</strong>：不依赖于路由键的匹配规则来路由消息，而是根据发送的消息内容中的headers属性进行匹配。在绑定队列和交换器时会制定一组键值对，消息到交换器时也有键值对形式的headers，对比若完全匹配就路由到此队列。<strong>这一类型性能很差且不实用</strong>。</p></li></ul><h4 id="（4）RabbitMQ运转流程"><a href="#（4）RabbitMQ运转流程" class="headerlink" title="（4）RabbitMQ运转流程"></a><strong>（4）RabbitMQ运转流程</strong></h4><p>生产者发送消息（最初状态）：</p><ol><li>生产者连接到 RabbitMQ Broker 建立一个<strong>连接</strong>（Connection），开启一个<strong>信道</strong>（Channel） ；</li><li>生产者声明一个交换器，并设置相关属性，比如交换机类型、是否持久化等；</li><li>生产者声明一个队列井设置相关属性，比如是否排他、是否持久化、是否自动删除等；</li><li>生产者通过路由键将交换器和队列绑定起来；</li><li>生产者发送消息至 RabbitMQ Broker，其中包含路由键、交换器等信息；</li><li>相应的交换器根据接收到的路由键查找相匹配的队列；</li><li>如果找到，则将从生产者发送过来的消息存入相应的队列中。</li><li>如果没有找到，则根据生产者配置的属性选择丢弃还是回退给生产者。</li><li>关闭信道。</li><li>关闭连接。 </li></ol><p>消费者接收消息的过程： </p><ol><li>消费者连接到 RabbitMQ Broker ，建立一个<strong>连接</strong>（Connection），开启一个<strong>信道</strong>（Channel)；</li><li>消费者向 RabbitMQ Broker 请求消费相应队列中的消息，可能会设置相应的回调函数，以及做一些准备工作。 </li><li>等待 RabbitMQ Broker 回应并投递相应队列中的消息，消费者接收消息。</li><li>消费者确认（ack）接收到的消息。</li><li>RabbitMQ 从队列中删除相应己经被确认的消息。</li><li>关闭信道。</li><li>关闭连接。</li></ol><h4 id="（5）连接和信道"><a href="#（5）连接和信道" class="headerlink" title="（5）连接和信道"></a><strong>（5）连接和信道</strong></h4><p><strong>连接</strong>（Connection），即一条TCP连接。当TCP连接建立起来，客户端紧接着创建一个AMQP<strong>信道</strong>（Channel)，每个信道都会被指派一个唯一的ID。信道是虚拟链接，<strong>RabbitMQ处理每条AMQP指令都是通过信道完成</strong>。</p><p><img src="https://pic-1258215793.cos.ap-shanghai.myqcloud.com/content/20200901/202009010151.png" alt></p><p><strong>信道的作用？</strong></p><p>一个应用程序会有很多线程需要从MQ中消费消息或生产消息，所以要建立很多TCP连接。对于操作系统而言，<strong>建立和销毁TCP连接都需要昂贵的开销</strong>，所以 RabbitMQ 采用类似 NIO（Non-blocking I/O）的做法，选择<strong>TCP连接复用</strong>，既减少性能开销也便于管理。</p><p><strong>每个线程持有一个信道，信道复用了TCP连接，而 RabbitMQ 还可以保证每个线程的私密性和持有独立的连接一样。</strong>当单个信道流量很大时，多个信道复用一个连接就会产生性能瓶颈，此时可以开辟多个连接并进行均摊。</p><h3 id="3-2-AMQP协议"><a href="#3-2-AMQP协议" class="headerlink" title="3.2 AMQP协议"></a><strong>3.2 AMQP协议</strong></h3><p>AMQP协议的模型架构和 RabbitMQ的模型架构一样：生产者将消息发送给交换器，交换器与队列绑定，当生产者发送消息时所携带的 RoutingKey 与绑定时的 BindingKey 相匹配时，消息即被存入相应的队列之中。消费者可以订阅相应的队列来获取消息。</p><p>AMQP协议包括三层：</p><ul><li><strong>Module Layer</strong>：位于协议<strong>最高层</strong>，主要定义了一些供客户端调用的命令，客户端可以利用这些命令实现自己的业务逻辑。例如客户端可以使用 <code>Queue.Declare</code> 命令声明一个队列或者使用 <code>Basic.Consume</code> 订阅消费一个队列中的消息。 </li><li><strong>Session Layer</strong>：位于<strong>中间层</strong>，主要负责将客户端的命令发送给服务器，再将服务端的应答返回给客户端，主要为客户端与服务器之间的通信提供可靠性同步机制和错误处理。</li><li><strong>Transport Layer</strong> ：位于<strong>最底层</strong>，主要传输二进制数据流，提供帧的处理、信道复用、错误检测和数据表示等。</li></ul><p><strong>AMQP说到底还是一个通信协议，都会涉及到报文交互</strong>，从 low level 举例来说，AMQP <strong>本身是应用层的协议，其填充于 TCP 协议层的数据部分</strong>。而从 high-level 来说 AMQP 是通过协议命令进行交互的。AMQP 协议可以看作一系列结构化命令的集合，这里的命令代表一种操作，类似于 HTTP 中的方法（GET、POST、PUT、DELETE 等）。</p><h4 id="（1）AMQP生产者流转过程"><a href="#（1）AMQP生产者流转过程" class="headerlink" title="（1）AMQP生产者流转过程"></a><strong>（1）AMQP生产者流转过程</strong></h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">Connection connection = factory.newConnection(); <span class="comment">//创建连接</span></span><br><span class="line">Channel channel = connection.createChannel(); <span class="comment">//创建信道</span></span><br><span class="line"><span class="comment">// 创建一个 type direct 、持久化的、非自动删除的交换器</span></span><br><span class="line">channel.exchangeDeclare(EXCHANGE_NAME, <span class="string">"direct"</span>, <span class="keyword">true</span>, <span class="keyword">false</span>, <span class="keyword">null</span>);</span><br><span class="line"><span class="comment">//创建一个持久化、非排他的、非自动删除的队列</span></span><br><span class="line">channel.queueDeclare(QUEUE_NAME, <span class="keyword">true</span>, <span class="keyword">false</span>, <span class="keyword">false</span>, <span class="keyword">null</span>);</span><br><span class="line"><span class="comment">//将交换器与队列通过路由键绑定</span></span><br><span class="line">channel.queueBind(QUEUE_NAME, EXCHANGE_NAME, ROUTING_KEY);</span><br><span class="line"><span class="comment">//发送一条持久化的消息 hello world !</span></span><br><span class="line">String message = <span class="string">"Hello World!"</span>;</span><br><span class="line">channel.basicPublish(EXCHANGE_NAME, ROUTING_KEY,</span><br><span class="line">        MessageProperties.PERSISTENT_TEXT_PLAIN,</span><br><span class="line">        message.getBytes());</span><br><span class="line"><span class="comment">//关闭资源</span></span><br><span class="line">channel.close();</span><br><span class="line">connection.close();</span><br></pre></td></tr></table></figure><p><img src="https://pic-1258215793.cos.ap-shanghai.myqcloud.com/content/20200901/202009010152.png" alt></p><h4 id="（2）AMQP消费者者流转过程"><a href="#（2）AMQP消费者者流转过程" class="headerlink" title="（2）AMQP消费者者流转过程"></a><strong>（2）AMQP消费者者流转过程</strong></h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//这里的连接方式与生产者的 demo 略有不同，注意辨别区别</span></span><br><span class="line">        Connection connection = factory.newConnection(addresses); <span class="comment">//创建连接</span></span><br><span class="line">        <span class="keyword">final</span> Channel channel = connection.createChannel(); <span class="comment">//创建信道</span></span><br><span class="line">        channel.basicQos(<span class="number">64</span>); <span class="comment">//设置客户端最多接收未被 ack 的消息的个数</span></span><br><span class="line">        Consumer consumer = <span class="keyword">new</span> DefaultConsumer(channel) &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">handleDelivery</span><span class="params">(String consumerTag,</span></span></span><br><span class="line"><span class="function"><span class="params">                                       Envelope envelope,</span></span></span><br><span class="line"><span class="function"><span class="params">                                       AMQP.BasicProperties properties,</span></span></span><br><span class="line"><span class="function"><span class="params">                                       <span class="keyword">byte</span>[] body)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">                System.out.println(<span class="string">"recv message : "</span> + <span class="keyword">new</span> String(body));</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    TimeUnit.SECONDS.sleep(<span class="number">1</span>);</span><br><span class="line">                &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125;</span><br><span class="line">                channel.basicAck(envelope.getDeliveryTag(), <span class="keyword">false</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;;</span><br><span class="line">        channel.basicConsume(QUEUE_NAME, consumer);</span><br><span class="line">        <span class="comment">//等待回调函数执行完毕之后 关闭资源</span></span><br><span class="line">        TimeUnit.SECONDS.sleep(<span class="number">5</span>);</span><br><span class="line">        channel.close();</span><br><span class="line">        connection.close();</span><br></pre></td></tr></table></figure><p><img src="https://pic-1258215793.cos.ap-shanghai.myqcloud.com/content/20200901/202009010153.png" alt></p><h4 id="（3）AMQP命令概览"><a href="#（3）AMQP命令概览" class="headerlink" title="（3）AMQP命令概览"></a><strong>（3）AMQP命令概览</strong></h4><p>AMQP命令：</p><table><thead><tr><th>名称</th><th>是否包含内容体</th><th>对应客户端中的方法</th><th>简要描述</th></tr></thead><tbody><tr><td>Connection.Start</td><td>否</td><td>factory.newConnection</td><td>建立连接相关</td></tr><tr><td>Connection.Start-Ok</td><td>否</td><td>同上</td><td>同上</td></tr><tr><td>Connection.Tune</td><td>否</td><td>同上</td><td>同上</td></tr><tr><td>Connection.Tune-Ok</td><td>否</td><td>同上</td><td>同上</td></tr><tr><td>Connection.Open</td><td>否</td><td>同上</td><td>同上</td></tr><tr><td>Connection.Open-Ok</td><td>否</td><td>同上</td><td>同上</td></tr><tr><td>Connection.Close</td><td>否</td><td>connection.close</td><td>关闭连接</td></tr><tr><td>Connection.Close-Ok</td><td>否</td><td>同上</td><td>同上</td></tr><tr><td>Channel.Open</td><td>否</td><td>connection.openChannel</td><td>开启信道</td></tr><tr><td>Channel.Open-Ok</td><td>否</td><td>同上</td><td>同上</td></tr><tr><td>Channel.Close</td><td>否</td><td>channel.close</td><td>关闭信道</td></tr><tr><td>Channel.Close-Ok</td><td>否</td><td>同上</td><td>同上</td></tr><tr><td>Exchange.Declare</td><td>否</td><td>channel.exchangeDeclare</td><td>声明交换器</td></tr><tr><td>Exchange.Declare-Ok</td><td>否</td><td>同上</td><td>同上</td></tr><tr><td>Exchange.Delete</td><td>否</td><td>channel.exchangeDelete</td><td>删除交换器</td></tr><tr><td>Exchange.Delete-Ok</td><td>否</td><td>向上</td><td>同上</td></tr><tr><td>Exchange.Bind</td><td>否</td><td>channel.exchangeBind</td><td>交换器与交换器绑定</td></tr><tr><td>Exchange.Bind-Ok</td><td>否</td><td>同上</td><td>同上</td></tr><tr><td>Exchange.Unbind</td><td>否</td><td>channel.exchangeUnbind</td><td>交换器与交换器解绑</td></tr><tr><td>Exchange.Unbind-Ok</td><td>否</td><td>同上</td><td>同上</td></tr><tr><td>Queue.Declare</td><td>否</td><td>channel.queueDeclare</td><td>声明队列</td></tr><tr><td>Queue.Declare-Ok</td><td>否</td><td>同上</td><td>同上</td></tr><tr><td>Queue.Bind</td><td>否</td><td>channel.queueBind</td><td>队列与交换器绑定</td></tr><tr><td>Queue.Bind-Ok</td><td>否</td><td>同上</td><td>同上</td></tr><tr><td>Queue.Purge</td><td>否</td><td>channel.queuePurge</td><td>清除队列中的内容</td></tr><tr><td>Queue.Purge-Ok</td><td>否</td><td>同上</td><td>同上</td></tr><tr><td>Queue.Delete</td><td>否</td><td>channel.queueDelete</td><td>删除队列</td></tr><tr><td>Queue.Delete-Ok</td><td>否</td><td>同上</td><td>向上</td></tr><tr><td>Queue.Unbind</td><td>否</td><td>channel.queueUnbind</td><td>队列与交换器解绑</td></tr><tr><td>Queue.Unbind-Ok</td><td>否</td><td>同上</td><td>同上</td></tr><tr><td>Basic.Qos</td><td>否</td><td>channel.basicQos</td><td>设置未被确认消费的个数</td></tr><tr><td>Basic.Qos-Ok</td><td>否</td><td>同上</td><td>同上</td></tr><tr><td>Basic.Consume</td><td>否</td><td>channel.basicConsume</td><td>消费消息（推模式）</td></tr><tr><td>BasiιConsume-Ok</td><td>否</td><td>同上</td><td>同上</td></tr><tr><td>Basic.Cancel</td><td>否</td><td>channel.basicCancel</td><td>取消</td></tr><tr><td>Basic.Cancel-Ok</td><td>否</td><td>同上</td><td>同上</td></tr><tr><td>Basic.Publish</td><td>否</td><td>channel.basicPublish</td><td>发送消息</td></tr><tr><td>Basic.Return</td><td>否</td><td>无</td><td>未能成功路由的消息返回</td></tr><tr><td>Basic.Deliver</td><td>否</td><td>无</td><td>Broker 推送消息</td></tr><tr><td>Basic.Get</td><td>否</td><td>channel.basicGet</td><td>消费消息（拉模式〉</td></tr><tr><td>Basic.Get-Ok</td><td>否</td><td>同上</td><td>同上</td></tr><tr><td>Basic.Ack</td><td>否</td><td>channel.basicAck</td><td>确认</td></tr><tr><td>Basic.Reject</td><td>否</td><td>channel.basicReject</td><td>拒绝（单条拒绝）</td></tr><tr><td>Basic.Recover</td><td>否</td><td>channel.basicRecover</td><td>请求 Broker 重新发送未被确认的消息</td></tr><tr><td>Basic.Recover-Ok</td><td>否</td><td>向上</td><td>同上</td></tr><tr><td>Basic.Nack</td><td>否</td><td>channel.basicNack</td><td>拒绝（可批量拒绝〉</td></tr><tr><td>Tx.Select</td><td>否</td><td>channel.txSelect</td><td>开启事务</td></tr><tr><td>Tx.Select-Ok</td><td>否</td><td>同上</td><td>同上</td></tr><tr><td>Tx.Commit</td><td>否</td><td>channel.txCommit</td><td>事务提交</td></tr><tr><td>Tx.Commit-Ok</td><td>否</td><td>同上</td><td>同上</td></tr><tr><td>Tx.Rollback</td><td>否</td><td>channel.txRollback</td><td>事务回滚</td></tr><tr><td>Tx.Rollback-Ok</td><td>否</td><td>同上</td><td>同上</td></tr><tr><td>Confirm Select</td><td>否</td><td>channel.confinnSelect</td><td>开启发送端确认模式</td></tr><tr><td>Confirm.Select-Ok</td><td>否</td><td>同上</td><td>同上</td></tr></tbody></table><hr><p>参考：</p><blockquote><p>《RabbitMQ实战指南》</p></blockquote><p><em>若内容涉及侵权请及时告知，我会尽快修改和删除相关内容</em></p>]]></content>
    
    <summary type="html">
    
      学习RabbitMQ，第一章《简介和入门》，内容来自于《RabbitMQ实战指南》。
    
    </summary>
    
      <category term="技术文档" scheme="http://linyishui.top/categories/%E6%8A%80%E6%9C%AF%E6%96%87%E6%A1%A3/"/>
    
    
      <category term="distributed" scheme="http://linyishui.top/tags/distributed/"/>
    
      <category term="mom" scheme="http://linyishui.top/tags/mom/"/>
    
      <category term="rabbitmq" scheme="http://linyishui.top/tags/rabbitmq/"/>
    
  </entry>
  
  <entry>
    <title>分布式概览（持续更新）</title>
    <link href="http://linyishui.top/2020091201.html"/>
    <id>http://linyishui.top/2020091201.html</id>
    <published>2020-09-12T12:20:42.000Z</published>
    <updated>2020-09-18T07:02:32.501Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="分布式概览"><a href="#分布式概览" class="headerlink" title="分布式概览"></a><strong>分布式概览</strong></h1><h2 id="第一节-分布式系统"><a href="#第一节-分布式系统" class="headerlink" title="第一节 分布式系统"></a><strong>第一节 分布式系统</strong></h2><h3 id="1-1-什么是分布式系统？"><a href="#1-1-什么是分布式系统？" class="headerlink" title="1.1 什么是分布式系统？"></a><strong>1.1 什么是分布式系统？</strong></h3><p>分布式系统是一种<strong>组件分布在网络计算机上</strong>，<strong>组件之间仅仅通过消息传递来通信并协调行动</strong>的系统。</p><p>对于用户来说，他面对的只是一台服务器，但实际上这台服务器是由众多服务器组成的“一台超级计算机”。所以我们可以联想到我们日常使用的各种网站，它们背后都是一整个大型分布式系统在提供服务。</p><h3 id="1-2-分布式系统的意义？"><a href="#1-2-分布式系统的意义？" class="headerlink" title="1.2 分布式系统的意义？"></a><strong>1.2 分布式系统的意义？</strong></h3><p>为什么要从单一应用架构或垂直应用架构升级到分布式系统？</p><ul><li>升级单机处理能力的性价比越来越低</li><li>单机处理能力有瓶颈</li><li>分布式系统带来稳定性和可用性</li><li>单一应用不利于扩展和升级维护</li><li>单一应用拆分后，应用间的交互越来越复杂</li></ul><h3 id="1-3-基础知识补齐"><a href="#1-3-基础知识补齐" class="headerlink" title="1.3 基础知识补齐"></a><strong>1.3 基础知识补齐</strong></h3><h4 id="1-3-1-组成计算机的5要素"><a href="#1-3-1-组成计算机的5要素" class="headerlink" title="1.3.1 组成计算机的5要素"></a><strong>1.3.1 组成计算机的5要素</strong></h4><p>冯 · 诺依曼计算机的5个组成部分：</p><ul><li>运算器</li><li>控制器</li><li>存储器<ul><li>内存</li><li>外存：断电后仍能保存数据。</li></ul></li><li>输入设备</li><li>输出设备</li></ul><p>既然分布式系统看起来像一个超级计算机，是不是也有类似的结构呢？</p><h4 id="1-3-2-线程与进程的执行模式"><a href="#1-3-2-线程与进程的执行模式" class="headerlink" title="1.3.2 线程与进程的执行模式"></a><strong>1.3.2 线程与进程的执行模式</strong></h4><p>我们学习编程都是从单线程模式开始的，面对的都是<strong>程序的顺序、分支和循环执行</strong>。多线程（指单进程内的多线程）要处理<strong>线程间通信</strong>，要对<strong>线程并发</strong>做控制，做好<strong>线程间的协调工作</strong>。</p><p>在多核CPU的时代，程序的<strong>并发</strong>和<strong>并行</strong>很重要，决定着是否能够有效利用多核带来的性能提升。</p><p>多线程的几种交互模式：</p><ul><li><strong>互不通信的多线程模式</strong>：最简单的多线程模式，线程间无共享数据，也不需要做动作协调，就是多个独立的线程各自完成自己的任务。</li><li><strong>基于共享容器的多线程模式</strong>：多线程具有共享数据，如经典的生产者消费者问题。我们需要保证数据访问的正确性，对于存储数据的容器有线程安全或不安全之分，线程不安全的容器一般可以通过<strong>加锁（数据读写比例很高，采用读写锁而非互斥锁）或写时复制CopyOnWrite</strong>的方式来控制。</li><li><strong>通过事件协同的多线程模式</strong>：除了并发访问的控制，线程间还会有协调的需求。比如A、B两个线程，B线程需要等待某个状态或事件发生后才能继续工作，而这个改变和A线程有关，这时就需要完成线程间的协调（等待通知机制），这种情况下需要注意避免死锁。</li></ul><p>多进程模式：线程属于进程，所以一个进程内的多个线程共享了进程的内存空间，而进程之间的内存空间是独立的。所以多个进程间通过内存共享、交换数据的方式与多线程有所不同。</p><ul><li>单机多进程</li><li>多机多进程：单机OS所支持的功能需要另外实现，单个机器故障处理的好就不影响集群。</li></ul><h4 id="1-3-3-网络通信"><a href="#1-3-3-网络通信" class="headerlink" title="1.3.3 网络通信"></a><strong>1.3.3 网络通信</strong></h4><p><strong>OSI与TCP/IP网络模型</strong></p><p><img src alt></p><p><img src alt></p><p>OSI七层模型：</p><ul><li>应用层</li><li><strong>表示层</strong> ：数据压缩、加密以及数据描述，这使得应用程序不必关心在各台主机中数据内部格式不同的问题。</li><li><strong>会话层</strong> ：建立及管理会话。</li><li>运输层</li><li>网路层</li><li>数据链路层</li><li>物理层</li></ul><p>五层协议：</p><ul><li><strong>应用层</strong> ：为特定应用程序提供数据传输服务，例如 <strong>HTTP</strong>、<strong>DNS</strong> 等协议。数据单位为报文。</li><li><strong>传输层</strong> ：为进程提供通用数据传输服务。由于应用层协议很多，定义通用的传输层协议就可以支持不断增多的应用层协议。运输层包括两种协议：<ul><li>传输控制协议 <strong>TCP</strong>，提供面向连接、可靠的数据传输服务，数据单位为报文段；</li><li>用户数据报协议 <strong>UDP</strong>，提供无连接、尽最大努力的数据传输服务，数据单位为用户数据报。</li><li>TCP 主要提供完整性服务，UDP 主要提供及时性服务。</li></ul></li><li><strong>网络层</strong> ：为主机提供数据传输服务。而传输层协议是为主机中的进程提供数据传输服务。网络层把传输层传递下来的报文段或者用户数据报封装成分组。</li><li><strong>数据链路层</strong> ：网络层针对的还是主机之间的数据传输服务，而主机之间可以有很多链路，链路层协议就是为同一链路的主机提供数据传输服务。数据链路层把网络层传下来的分组封装成帧。</li><li><strong>物理层</strong> ：考虑的是怎样在传输媒体上传输数据比特流，而不是指具体的传输媒体。物理层的作用是尽可能屏蔽传输媒体和通信手段的差异，使数据链路层感觉不到这些差异。</li></ul><p>五层协议没有表示层和会话层，而是将这些功能留给应用程序开发者处理。</p><p>TCP/IP：</p><p>它只有四层，相当于五层协议中数据链路层和物理层合并为网络接口层。</p><p>TCP/IP 体系结构不严格遵循 OSI 分层概念，应用层可能会直接使用 IP 层或者网络接口层。</p><p>网络IO的实现方式：使用Socket套接字进行网络通信开发时，会使用哪些实现方式。</p><ul><li><strong>BIO</strong>：Blocking IO，阻塞式实现。一个套接字需要使用一个线程来处理，建立连接、读数据、写数据都可能会阻塞。</li><li><strong>NIO</strong>：Nonblocking IO，非阻塞式实现，基于事件驱动思想，采用 Reactor 模式。相比于BIO，NIO不用为每个套接字分配一个线程，而是一个线程处理多个套接字的相关工作。</li><li><strong>AIO</strong>：AsynchronousIO，异步IO，采用 Proactor 模式。与NIO的差异是，AIO在进行读写操作时，只需调用相应的 read/write 方法，并且传入 CompletionHandler（动作完成的处理器）；在动作完成后，会调用CompletionHandler。NIO的通知发生在动作之前，是在可写、可读的时候，Selector发现这些事件后调用 Handler 处理。</li></ul><h4 id="1-3-4-如何把应用从单机扩展到分布式"><a href="#1-3-4-如何把应用从单机扩展到分布式" class="headerlink" title="1.3.4 如何把应用从单机扩展到分布式"></a><strong>1.3.4 如何把应用从单机扩展到分布式</strong></h4><p>分布式这种“超级计算机”的五个组成部分的变化：</p><ul><li>输入设备：<ul><li>互相连接的多个节点，某个节点接受其他节点信息时，可以看作输入设备。</li><li>传统人机交互的输入设备。</li></ul></li><li>输出设备：<ul><li>互相连接的多个节点，某个节点向其他节点传递信息时，可以看作输出设备。</li><li>传统人机交互的输出设备，如屏幕。</li></ul></li><li>控制器：<ul><li>单机的控制器就是CPU中的控制器。</li><li>分布式中控制器负责协调或控制节点之间的动作和行为。如远程服务调用的场景，有几种实现方式：<ul><li><strong>硬件负载均衡</strong>：所有请求都要通过机器转发。</li><li><strong>LVS透明代理</strong>：增加了网络的开销（流量和延迟），因为多了一层转发；代理崩溃会影响所有请求。</li><li><strong>名称服务</strong>：没有代理地址，请求的发起者和处理者<strong>直接连接</strong>，只不过名称服务模块搜集处理服务器的地址信息，发起者先从本机名称服务获取地址。代码升级比较复杂。</li><li><strong>规则服务器</strong>：也是<strong>直接连接</strong>，区别是名称服务和处理者机器交互记录其地址，规则服务器则不和处理者交互，只提供规则给请求的发起者。</li><li><strong>Master+Worker</strong>：Master节点管理任务，分配给不同的Worker进行处理。</li></ul></li></ul></li><li>运算器：分布式系统运用多个节点的计算能力来协同完成整体的计算任务。<ul><li>例如我们需要日志处理服务器从应用服务器集群收集日志并处理，随着应用服务器的增多，单台日志处理服务器达到瓶颈，所以需要增加日志服务器来提升处理能力。</li><li>可以使用<strong>Master+Worker</strong>来控制日志服务器集群，当然也可以采用规则服务器等。</li></ul></li><li>存储器：<ul><li>单机中存储器分为内存和外存。</li><li>分布式中要把承担存储功能的多个节点组织在一起。</li><li>实现方式：（如KV存储服务器）<ul><li>代理服务器，根据请求的Key划分（Sharding）进行转发</li><li>名称服务，根据不同场景有两种实现：<ul><li>配合规则服务器，完成固定的Sharding策略</li><li>在消息中间件的应用场景，同等看待KV存储服务器，可以灵活的增加或减少服务器。</li></ul></li><li>规则服务器，除了对数据进行Sharding，还包括具体KV存储服务器的地址。</li><li>Master根据请求返回目标KV存储服务器地址，相比名称服务返回所有地址，Master根据请求返回对应地址；相比规则服务器把规则传给具体应用再由应用服务器解析并完成规则下的路由选择，Master自身完成了这件事情，只把结果传给应用服务器，应用服务器只须拿着地址去访问即可。</li></ul></li></ul></li></ul><h4 id="1-3-5-分布式系统的难点"><a href="#1-3-5-分布式系统的难点" class="headerlink" title="1.3.5 分布式系统的难点"></a><strong>1.3.5 分布式系统的难点</strong></h4><ul><li><strong>缺乏全局时钟</strong>：单机有机器时钟为标准，容易控制时序。分布式系统中同步本身就有时间差，很难保持所有机器的时间一致。不过我们使用时钟来区分动作间的顺序不需要准确的时间，一般会由一个单独的集群来区分动作间的顺序。</li><li><strong>面对故障独立性</strong>：分布式系统中，某个部分有问题而其他部分正常是经常发生的。</li><li><strong>处理单点故障</strong>：单点即在分布式系统中的某个功能只由单机在支持，其发生的故障即单点故障，SPoE（Single Point of Failure）。所以能扩展为集群的就尽量扩展，只能单点实现的：<ul><li>做好这个单点的备份，能够在出问题时及时恢复，最好能自动恢复、快速恢复。</li><li>降低单点故障的影响范围，尽量减少故障发生时的损失。</li></ul></li><li><strong>事务</strong>：两阶段提交（2PC）、最终一致、BASE、CAP、Paxos等</li></ul><hr><h2 id="第二节-大型网站架构演变历程"><a href="#第二节-大型网站架构演变历程" class="headerlink" title="第二节 大型网站架构演变历程"></a><strong>第二节 大型网站架构演变历程</strong></h2><h3 id="2-1-早期-用Java技术和单机来构建网站"><a href="#2-1-早期-用Java技术和单机来构建网站" class="headerlink" title="2.1 早期-用Java技术和单机来构建网站"></a><strong>2.1 早期-用Java技术和单机来构建网站</strong></h3><p><strong>熟悉的技术</strong>：LAMP、MVC框架、JSP、Servlet、JDBC、Spring、Struts、Hibernate、HTML、CSS、JavaScript、Python等。</p><p>举一个交易网站的例子，核心模块有<strong>用户、商品和交易</strong>。</p><p><img src="https://pic-1258215793.cos.ap-shanghai.myqcloud.com/content/20200901/202009010119.png" alt></p><h3 id="2-2-单机负载告警，数据库与应用分离"><a href="#2-2-单机负载告警，数据库与应用分离" class="headerlink" title="2.2 单机负载告警，数据库与应用分离"></a><strong>2.2 单机负载告警，数据库与应用分离</strong></h3><p>随着访问量增加，单台服务器负载持续增高，我们首先把数据库与应用分开到两条服务器。这种变更对系统影响很小，只须修改数据库地址即可。</p><p><img src="https://pic-1258215793.cos.ap-shanghai.myqcloud.com/content/20200901/202009010120.png" alt></p><h3 id="2-3-应用服务器负载告警，走向集群"><a href="#2-3-应用服务器负载告警，走向集群" class="headerlink" title="2.3 应用服务器负载告警，走向集群"></a><strong>2.3 应用服务器负载告警，走向集群</strong></h3><p>应用服务器压力不断增加，可以根据监测来进行针对性的优化，我们选用将应用服务器由单机转为集群的优化方式。</p><p><img src="https://pic-1258215793.cos.ap-shanghai.myqcloud.com/content/20200901/202009010121.png" alt></p><h4 id="（1）单机转为集群的两个问题"><a href="#（1）单机转为集群的两个问题" class="headerlink" title="（1）单机转为集群的两个问题"></a><strong>（1）单机转为集群的两个问题</strong></h4><p>变更为集群会带来两个要解决的问题：</p><ul><li>两个应用服务器的选择问题，我们可以通过DNS或负载均衡设备来解决。</li><li>Session问题。</li></ul><p>引入负载均衡设备后：</p><p><img src="https://pic-1258215793.cos.ap-shanghai.myqcloud.com/content/20200901/202009010122.png" alt></p><p>我们知道HTTP协议是无状态的，为了支持有状态的会话需求，我们需要Session机制，在会话开始时分配一个SessionId，通过Cookie告知浏览器，以后会话中的每次请求都会携带此SessionId来告知Web服务器此次属于哪个会话。<strong>Web服务器需要独立的存储会话信息</strong>，当Cookie禁用时会拼接到URL中。</p><p><img src="https://pic-1258215793.cos.ap-shanghai.myqcloud.com/content/20200901/202009010123.png" alt></p><p>所以当服务器变为两台时，Session就出现了问题，保存在单机上的会话，和随机访问任一服务器的会话请求产生了矛盾。</p><p><img src="https://pic-1258215793.cos.ap-shanghai.myqcloud.com/content/20200901/202009010124.png" alt></p><h4 id="（2）Session问题的解决方案"><a href="#（2）Session问题的解决方案" class="headerlink" title="（2）Session问题的解决方案"></a><strong>（2）Session问题的解决方案</strong></h4><ol><li><p><strong>Session Sticky</strong>：通过负载均衡器保证同一个会话的请求都在同一个Web服务器上处理。</p><p><img src="https://pic-1258215793.cos.ap-shanghai.myqcloud.com/content/20200901/202009010125.png" alt></p><p>最简单的方案，但也存在问题：</p><ul><li>一台服务器宕机或重启，其会话数据会丢失，对应的用户需要重新登录；</li><li>因为会话标识是应用层的信息，负载均衡器将会话请求保存在同一个Web服务器，需要进行应用层（第7层）的解析，开销会比第4层的交换大；</li><li>负载均衡器也变成了一个有状态的节点，相比无状态节点，内存消耗更大，容灾方面更麻烦。</li></ul></li><li><p><strong>Session Replication</strong>：每台Web服务器都保存相同的会话信息。需要在Web服务器间进行数据同步，保证Session数据一致。</p><p><img src="https://pic-1258215793.cos.ap-shanghai.myqcloud.com/content/20200901/202009010126.png" alt></p><p>同样也有其问题：</p><ul><li><strong>网络开销越来越大</strong>：同步Session数据导致了网络带宽的开销，只要Session数据有变化，就需要同步到所有机器，机器数越多，带来的网络开销越大；</li><li><strong>内存占用越来越大</strong>：每台服务器都要保存所有的Session数据，当整个集群的用户量很多时，保存数据所需的空间会很大。</li></ul></li><li><p><strong>Session数据集中存储</strong>：集中的存放所有的Session数据，所有Web服务器向同样地址获取Session。</p><p><img src="https://pic-1258215793.cos.ap-shanghai.myqcloud.com/content/20200901/202009010127.png" alt></p><p>此方案的问题：</p><ul><li>读写Session数据引入了网络操作，相比本机数据读取存在时延和不稳定行（内网通信好一些）；</li><li>集中存储Session的机器有问题，会影响整个应用（扩展集群）。</li></ul></li><li><p><strong>Cookie Based</strong>：把Session存放在Cookie中，Web服务器从Cookie中生成对应Session数据。</p><p><img src="https://pic-1258215793.cos.ap-shanghai.myqcloud.com/content/20200901/202009010128.png" alt></p><p>此方案的不足：</p><ul><li>Cookie有<strong>长度限制</strong>；</li><li><strong>安全性</strong>：Session数据本身是服务端数据，此方案是由客户端存放通过外部网络传输，所以要对写入Cookie的Session数据进行加密（并不绝对安全）。</li><li><strong>带宽消耗</strong>：指数据中心整体外部带宽的消耗（每次请求都增加了数据）。</li><li><strong>性能影响</strong>：每次HTTP请求和响应都带有Session数据，对Web服务器来说，响应的结果输出越少，支持的并发请求就越多。</li></ul></li></ol><p>大型网站比较适合 <strong>Session Sticky</strong> 和 <strong>Session数据集中存储</strong> ，根据具体场景做出选择和权衡。</p><h3 id="2-4-数据读压力增大，读写分离"><a href="#2-4-数据读压力增大，读写分离" class="headerlink" title="2.4 数据读压力增大，读写分离"></a><strong>2.4 数据读压力增大，读写分离</strong></h3><h4 id="（1）采用数据库作为读库"><a href="#（1）采用数据库作为读库" class="headerlink" title="（1）采用数据库作为读库"></a><strong>（1）采用数据库作为读库</strong></h4><p>对于大型网站，大部分业务是读多写少的场景，这种情况我们可以考虑<strong>读写分离</strong>的方式。</p><p>我们可以在架构中增加一个读库，它只负责读取服务。</p><p><img src="https://pic-1258215793.cos.ap-shanghai.myqcloud.com/content/20200901/202009010129.png" alt></p><p>带来问题：</p><ul><li><p><strong>数据复制问题</strong>：数据库一般会提供数据复制功能，可以直接使用。</p><ul><li>要考虑数据复制的时延问题;</li><li>复制过程中数据的源和目标之间的映射关系及过滤条件的支持问题。</li></ul><p>数据库支持：（数据库对数据复制的支持是相对有限的）</p><ul><li>MySQL：Master（主库）+ Slave（备库）的结构，5.5版本之前都是异步数据复制，会有延迟，提供完全镜像方式的复制，保证了备库和主库的数据一致性。5.5后加入了 semi-sync ，在数据安全性上更好，但从读写分离的角度看仍有复制延迟的可能。</li><li>Oracle：Data Guard方案，主要用于容灾、数据库保护以及故障恢复等场景，在实施中又分为物理备库（物理StandBy）和逻辑备库（逻辑StandBy）。</li></ul></li></ul><ul><li><strong>应用对于数据源的选择问题</strong>：写操作走主库，事务读也要走主库，还要考虑备库数据相对于主库的延迟。</li></ul><h4 id="（2）搜索引擎"><a href="#（2）搜索引擎" class="headerlink" title="（2）搜索引擎"></a><strong>（2）搜索引擎</strong></h4><p>当我们需要根据商品标题查询商品信息时，常规做法是通过数据库的 <code>like</code> 功能进行模糊查询。使用搜索引擎的倒排表方式可以大大提升检索速度。</p><p>搜索引擎首先要根据被搜索数据构建索引，数据改变索引也要改变。应用要选择什么数据走搜索引擎，什么数据走数据库。构建索引的过程也是一种数据复制的过程，只不过不是简单的复制对应数据。</p><p><img src="https://pic-1258215793.cos.ap-shanghai.myqcloud.com/content/20200901/202009010130.png" alt></p><p>可以从两个维度对搜索系统构建索引的方式进行划分：</p><ul><li>按照<strong>全量/增量</strong>划分：第一次构建索引用全量，在全量基础上采用增量方式更新索引（一般加入每日的全量作为补充）。</li><li>按照<strong>实时/非实时</strong>划分：更新时间上倾向于实时的方式，非实时主要考虑对数据源头的保护。</li></ul><h4 id="（3）缓存"><a href="#（3）缓存" class="headerlink" title="（3）缓存"></a><strong>（3）缓存</strong></h4><ol><li><p><strong>数据缓存</strong>：数据缓存的目的类似于读库，一般用来保存和查询键值对，来加速应用在响应请求时的数据读取速度。</p><p>两种方式：</p><ul><li><strong>应用主动更新缓存</strong>：应用访问缓存，数据不存在则从数据库读出并放入缓存，当缓存容量不足时清除最近不被访问的数据。</li><li><strong>数据库记录变化更新缓存</strong>：数据库发生变化，主动把数据放入缓存，这样能够及时更新缓存中的数据，不会造成读取失效。<strong>一般用于全数据缓存，要求相关代码要结合业务逻辑。</strong></li></ul><p><img src="https://pic-1258215793.cos.ap-shanghai.myqcloud.com/content/20200901/202009010131.png" alt></p></li><li><p><strong>页面缓存</strong>：缓存一些动态产生的页面或页面的一部分内容，ESI是一种针对这种情况的规范。</p><ul><li>Web服务器产生的请求响应结果返回给Apache，处理后找到ESI标签，在缓存中获取标签对应内容；若内容不存在，Apache模板通过Web服务器渲染这些内容，再把结果放回缓存，用内容替换掉ESI标签并返回给客户。</li></ul><p><img src="https://pic-1258215793.cos.ap-shanghai.myqcloud.com/content/20200901/202009010132.png" alt></p><ul><li>ESI模块总是要对响应结果进行解析，Web服务器处理时直接完成这项工作是更好的选择。所以改进为如下结构，把渲染和缓存功能放在Web服务器，这样更高效一些。</li></ul><p><img src="https://pic-1258215793.cos.ap-shanghai.myqcloud.com/content/20200901/202009010133.png" alt></p></li></ol><p>使用缓存来加速数据读取时要注意：</p><ul><li>缓存命中率：太低就导致大量请求仍要回到数据库；</li><li>数据的分布和更新策略：<ul><li>分布上要考虑<strong>避免局部热点</strong>的机制，缓存服务器的扩容和缩容要尽量平滑（考虑<strong>一致性Has</strong>h）；</li><li>更新上会有<strong>定时失效、数据变更时失效和数据变更时更新</strong>几种策略。</li></ul></li></ul><h3 id="2-5-引入分布式存储系统"><a href="#2-5-引入分布式存储系统" class="headerlink" title="2.5 引入分布式存储系统"></a><strong>2.5 引入分布式存储系统</strong></h3><p>常见的分布式存储系统：</p><ul><li>分布式文件系统：弱格式，内容格式需要自行组织，解决小文件和大文件的存储问题；</li><li>分布式Key-Value系统：提供高性能的半结构化支持；</li><li>分布式数据库：提供一个支持大数据、高并发的数据库系统。</li></ul><p>分布式存储系统通过集群提供了一个高容量、高并发访问、数据冗余容灾的支持，直接代替原先的单机主库。</p><p><img src="https://pic-1258215793.cos.ap-shanghai.myqcloud.com/content/20200901/202009010134.png" alt></p><h3 id="2-6-读写分离后，数据库又遇到瓶颈"><a href="#2-6-读写分离后，数据库又遇到瓶颈" class="headerlink" title="2.6 读写分离后，数据库又遇到瓶颈"></a><strong>2.6 读写分离后，数据库又遇到瓶颈</strong></h3><p>虽然进行了以上的优化，我们的核心功能数据（用户、商品和交易）还都在一个数据库中，随着数据量和访问量的增大，数据库的压力还在不断增加。</p><p>此时我们需要进行数据的<strong>垂直拆分</strong>和<strong>水平拆分</strong>。</p><h4 id="（1）专库专用，数据垂直拆分"><a href="#（1）专库专用，数据垂直拆分" class="headerlink" title="（1）专库专用，数据垂直拆分"></a><strong>（1）专库专用，数据垂直拆分</strong></h4><p>垂直拆分就是<strong>把数据库中不同业务数据拆分到不同的数据库</strong>，对于交易系统这个例子就是把用户、商品、交易数据分开。</p><p><img src="https://pic-1258215793.cos.ap-shanghai.myqcloud.com/content/20200901/202009010135.png" alt></p><p>带来的影响：</p><ul><li>应用配置多数据源；</li><li>单机跨业务事务要转为分布式事务；</li><li>表关联要改变实现。</li></ul><h4 id="（2）垂直拆分后的单机仍有瓶颈，数据水平拆分"><a href="#（2）垂直拆分后的单机仍有瓶颈，数据水平拆分" class="headerlink" title="（2）垂直拆分后的单机仍有瓶颈，数据水平拆分"></a><strong>（2）垂直拆分后的单机仍有瓶颈，数据水平拆分</strong></h4><p>水平拆分就是<strong>把同一个表中的数据拆分到多个数据库中</strong>。一般是因为某个业务的数据表的数据量太大，达到了单个数据库的瓶颈。</p><p><strong>水平拆分与读写分离</strong>：读写分离解决的是读压力过大的问题，对于数据量大或更新量的情况并不起作用。</p><p><strong>水平拆分与垂直拆分</strong>：垂直拆分把不同表放到不同数据库，水平拆分把同一个表拆到不同数据库。</p><p><img src="https://pic-1258215793.cos.ap-shanghai.myqcloud.com/content/20200901/202009010136.png" alt></p><p>带来的影响：（假设拆分用户表）</p><ul><li><strong>解决SQL路由问题</strong>：用户信息被切分到了两个库，在进行数据库操作时要知道操作的数据在哪个库。</li><li><strong>解决主键问题</strong>：原先可能是Oracle的 Sequence 或MySQL的自增字段，现在要保证多个库的主键不重复。</li><li><strong>修改查询</strong>：同个业务的数据被拆分到不同数据库，所以一些查询要从多个库取数据，如果还要分页就很难处理。</li></ul><p>完成水平拆分后，我们能很好的应对数据量及写入量增长的情况。</p><h3 id="2-7-单机负载告警，数据库与应用分离"><a href="#2-7-单机负载告警，数据库与应用分离" class="headerlink" title="2.7 单机负载告警，数据库与应用分离"></a><strong>2.7 单机负载告警，数据库与应用分离</strong></h3><p>解决完数据库问题后，我们来看下应用的变化。我们之前完成了应用服务器从单机到多机的扩展，但随着业务的发展，应用功能越来越多，为了控制应用的大小，我们需要把应用拆开。</p><h4 id="（1）拆分应用"><a href="#（1）拆分应用" class="headerlink" title="（1）拆分应用"></a><strong>（1）拆分应用</strong></h4><p><strong>根据业务特性拆分</strong>：交易系统中就是拆成分别以交易和商品为主的两个应用，当然两个应用都有涉及用户的地方，我们先粗糙的让系统各自完成用户工作。</p><p><img src="https://pic-1258215793.cos.ap-shanghai.myqcloud.com/content/20200901/202009010137.png" alt></p><p>通常新拆出的应用之间没有直接的相互调用，但可能会链接相同的数据库。如下，我们拆分了几个业务，它们之间没有直接的调用，都依赖底层的数据库、缓存、文件系统、搜索等。</p><p><img src="https://pic-1258215793.cos.ap-shanghai.myqcloud.com/content/20200901/202009010138.png" alt></p><h4 id="（2）服务化"><a href="#（2）服务化" class="headerlink" title="（2）服务化"></a><strong>（2）服务化</strong></h4><p>如下图，我们把应用分成了三层，最上层是Web系统，用于完成不同的业务功能；中间层是服务中心，各自提供不同的业务服务；最下层则是业务的数据库。（图中省略了缓存等基础系统）</p><p><img src="https://pic-1258215793.cos.ap-shanghai.myqcloud.com/content/20200901/202009010139.png" alt></p><p>服务化的区别：</p><ul><li><strong>方法调用</strong>：业务功能内不仅仅是单机的内部方法调用了，还<strong>需要远程服务调用</strong>（RPC）；</li><li><strong>共享代码</strong>：不再是散落在不同的应用，而是<strong>集中在各个服务中心</strong>。</li><li><strong>数据库连接</strong>：数据库交互工作在服务中心，Web应用专注于与浏览器交互的工作，不必多关注业务逻辑。服务中心不仅把散落的可共用的业务代码集中起来，还可以使其得到更好的维护。</li><li><strong>适合人员分工</strong>：每个服务都可以由固定的小团队来维护，更好的保持稳定性。</li></ul><h3 id="2-8-消息中间件"><a href="#2-8-消息中间件" class="headerlink" title="2.8 消息中间件"></a><strong>2.8 消息中间件</strong></h3><p>消息中间件（Message-oriented middleware，MOM）就是面向消息的系统，是在分布式系统中完成消息的发送和接收的基础软件。</p><p><img src="https://pic-1258215793.cos.ap-shanghai.myqcloud.com/content/20200901/202009010140.png" alt></p><p>消息中间件有两个为人熟知的优点：<strong>异步</strong>和<strong>解耦</strong>。</p><h3 id="2-9-总结"><a href="#2-9-总结" class="headerlink" title="2.9 总结"></a><strong>2.9 总结</strong></h3><p><img src="https://pic-1258215793.cos.ap-shanghai.myqcloud.com/content/20200901/202009010141.png" alt></p><hr><h2 id="第三节-Java中间件"><a href="#第三节-Java中间件" class="headerlink" title="第三节 Java中间件"></a><strong>第三节 Java中间件</strong></h2><p>在网站的演变过程中，无论是服务化、数据库的读写分离和拆分处理还是消息系统，都会用到相关的中间件。</p><p>中间件就是为软件应用提供除操作系统提供的服务以外的服务，让软件开发者更方便的处理通信、输入和输出，关注自己应用的部分。</p><p>我们这里主要了解三个领域的中间件：</p><ul><li><strong>远程过程调用和对象访问中间件</strong>：</li><li><strong>消息中间件</strong>：</li><li><strong>数据访问中间件</strong>：</li></ul><hr><h2 id="第四节-服务框架"><a href="#第四节-服务框架" class="headerlink" title="第四节 服务框架"></a><strong>第四节 服务框架</strong></h2><hr><h2 id="第五节-数据访问层"><a href="#第五节-数据访问层" class="headerlink" title="第五节 数据访问层"></a><strong>第五节 数据访问层</strong></h2><hr><h2 id="第六节-消息中间件"><a href="#第六节-消息中间件" class="headerlink" title="第六节 消息中间件"></a><strong>第六节 消息中间件</strong></h2><hr><h2 id="第七节-软负载中心与集中配置管理"><a href="#第七节-软负载中心与集中配置管理" class="headerlink" title="第七节 软负载中心与集中配置管理"></a><strong>第七节 软负载中心与集中配置管理</strong></h2><hr><h2 id="第八节-CDN"><a href="#第八节-CDN" class="headerlink" title="第八节 CDN"></a><strong>第八节 CDN</strong></h2><hr><h2 id="第九节-分布式存储"><a href="#第九节-分布式存储" class="headerlink" title="第九节 分布式存储"></a><strong>第九节 分布式存储</strong></h2><hr><h2 id="第十节-搜索系统"><a href="#第十节-搜索系统" class="headerlink" title="第十节 搜索系统"></a><strong>第十节 搜索系统</strong></h2><hr><h2 id="第十一节-其他"><a href="#第十一节-其他" class="headerlink" title="第十一节 其他"></a><strong>第十一节 其他</strong></h2><hr><p>参考：</p><blockquote><p>《大型网站系统与Java中间件实践》</p></blockquote><p><em>若内容涉及侵权请及时告知，我会尽快修改和删除相关内容</em></p>]]></content>
    
    <summary type="html">
    
      分布式相关知识内容的概览，简单整理了一下。
    
    </summary>
    
      <category term="技术文档" scheme="http://linyishui.top/categories/%E6%8A%80%E6%9C%AF%E6%96%87%E6%A1%A3/"/>
    
    
      <category term="updating" scheme="http://linyishui.top/tags/updating/"/>
    
      <category term="distributed" scheme="http://linyishui.top/tags/distributed/"/>
    
  </entry>
  
  <entry>
    <title>从零开始学习dubbo（二）注册中心和监控中心</title>
    <link href="http://linyishui.top/2020090801.html"/>
    <id>http://linyishui.top/2020090801.html</id>
    <published>2020-09-08T09:50:24.000Z</published>
    <updated>2020-09-12T15:06:02.678Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="dubbo（二）注册中心和监控中心"><a href="#dubbo（二）注册中心和监控中心" class="headerlink" title="dubbo（二）注册中心和监控中心"></a><strong>dubbo（二）注册中心和监控中心</strong></h1><h2 id="第一节-简介"><a href="#第一节-简介" class="headerlink" title="第一节 简介"></a><strong>第一节 简介</strong></h2><h3 id="1-1-dubbo支持的几种注册中心"><a href="#1-1-dubbo支持的几种注册中心" class="headerlink" title="1.1 dubbo支持的几种注册中心"></a><strong>1.1 dubbo支持的几种注册中心</strong></h3><ul><li><strong>Multicast</strong>：不需要启动任何中心节点，只要广播地址一样，就可以互相发现。</li><li><strong>Zookeeper</strong>：Apache Hadoop 的子项目，是一个树型的目录服务，支持变更推送，适合作为 Dubbo 服务的注册中心，工业强度较高，可用于生产环境，并推荐使用。</li><li><strong>Nacos</strong>：Nacos 是 Dubbo 生态系统中重要的注册中心实现，其中 <a href="https://github.com/apache/incubator-dubbo/tree/master/dubbo-registry/dubbo-registry-nacos" target="_blank" rel="noopener"><code>dubbo-registry-nacos</code></a> 则是 Dubbo 融合 Nacos 注册中心的实现。</li><li><strong>Redis</strong>：使用 Redis 的 Key/Map 结构存储数据结构，使用 Redis 的 Publish/Subscribe 事件通知数据变更。</li><li><strong>Simple</strong>：Simple 注册中心本身就是一个普通的 Dubbo 服务，可以减少第三方依赖，使整体通讯方式一致。</li></ul><h3 id="1-2-Zookeeper注册中心"><a href="#1-2-Zookeeper注册中心" class="headerlink" title="1.2 Zookeeper注册中心"></a><strong>1.2 Zookeeper注册中心</strong></h3><p>官方推荐的注册中心，是一个树型的目录服务，支持变更推送，适合作为 Dubbo 服务的注册中心，工业强度较高，可用于生产环境。如下图树型结构。</p><p><img src="http://dubbo.apache.org/docs/zh-cn/user/sources/images/zookeeper.jpg" alt></p><p>流程说明：</p><ul><li><strong>服务提供者启动时</strong>: 向 <code>/dubbo/com.foo.BarService/providers</code> 目录下写入自己的 URL 地址</li><li><strong>服务消费者启动时</strong>: 订阅 <code>/dubbo/com.foo.BarService/providers</code> 目录下的提供者 URL 地址。并向 <code>/dubbo/com.foo.BarService/consumers</code> 目录下写入自己的 URL 地址</li><li><strong>监控中心启动时</strong>: 订阅 <code>/dubbo/com.foo.BarService</code> 目录下的所有提供者和消费者 URL 地址。</li></ul><p>支持以下功能：</p><ul><li>当提供者出现断电等异常停机时，注册中心能自动删除提供者信息。</li><li>当注册中心重启时，能自动恢复注册数据，以及订阅请求。</li><li>当会话过期时，能自动恢复注册数据，以及订阅请求。</li><li>当设置 <code>&lt;dubbo:registry check=&quot;false&quot; /&gt;</code> 时，记录失败注册和订阅请求，后台定时重试。</li><li>可通过 <code>&lt;dubbo:registry username=&quot;admin&quot; password=&quot;1234&quot; /&gt;</code> 设置 zookeeper 登录信息。</li><li>可通过 <code>&lt;dubbo:registry group=&quot;dubbo&quot; /&gt;</code> 设置 zookeeper 的根节点，不配置将使用默认的根节点。</li><li>支持 <code>*</code> 号通配符 <code>&lt;dubbo:reference group=&quot;*&quot; version=&quot;*&quot; /&gt;</code>，可订阅服务的所有分组和所有版本的提供者。</li></ul><hr><h2 id="第二节-使用"><a href="#第二节-使用" class="headerlink" title="第二节 使用"></a><strong>第二节 使用</strong></h2><p>学习环境：LG笔记本 + Win10</p><h3 id="2-1-注册中心"><a href="#2-1-注册中心" class="headerlink" title="2.1 注册中心"></a><strong>2.1 注册中心</strong></h3><p>首先安装Zookeeper注册中心，下载地址：<a href="https://zookeeper.apache.org/releases.html#download" target="_blank" rel="noopener">Zookeeper - download</a></p><p>包结构：</p><ul><li>bin：二进制执行文件，如 <code>zkServer.cmd</code> 可用于Win10执行。</li><li>conf：配置文件 <code>.cfg</code> 。</li><li>contrib：</li><li>dist-maven：</li><li>docs：</li><li>lib：</li><li>recipes：</li><li>src：</li></ul><p>首次启动 <code>zkServer.cmd</code> 会出错。</p><p>找到默认配置文件，创建副本并改名为 <code>zoo.cfg</code> ：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"># The number of milliseconds of each tick</span><br><span class="line">tickTime=2000</span><br><span class="line"># The number of ticks that the initial </span><br><span class="line"># synchronization phase can take</span><br><span class="line">initLimit=10</span><br><span class="line"># The number of ticks that can pass between </span><br><span class="line"># sending a request and getting an acknowledgement</span><br><span class="line">syncLimit=5</span><br><span class="line"># the directory where the snapshot is stored.</span><br><span class="line"># do not use /tmp for storage, /tmp here is just </span><br><span class="line"># example sakes.</span><br><span class="line"># 数据存储位置</span><br><span class="line">dataDir=../data</span><br><span class="line"># the port at which the clients will connect</span><br><span class="line">clientPort=2181</span><br><span class="line"># the maximum number of client connections.</span><br><span class="line"># increase this if you need to handle more clients</span><br><span class="line">#maxClientCnxns=60</span><br><span class="line">#</span><br><span class="line"># Be sure to read the maintenance section of the </span><br><span class="line"># administrator guide before turning on autopurge.</span><br><span class="line">#</span><br><span class="line"># http://zookeeper.apache.org/doc/current/zookeeperAdmin.html#sc_maintenance</span><br><span class="line">#</span><br><span class="line"># The number of snapshots to retain in dataDir</span><br><span class="line">#autopurge.snapRetainCount=3</span><br><span class="line"># Purge task interval in hours</span><br><span class="line"># Set to &quot;0&quot; to disable auto purge feature</span><br><span class="line">#autopurge.purgeInterval=1</span><br></pre></td></tr></table></figure><p>再次启动 <code>zkServer.cmd</code> 。</p><p>启动 <code>zkCli.cmd</code> 简单使用以下Zookeeper。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 获取根目录文件</span></span><br><span class="line">[zk: localhost:2181(CONNECTED) 0] get /</span><br><span class="line"></span><br><span class="line">cZxid = 0x0</span><br><span class="line">ctime = Thu Jan 01 08:00:00 CST 1970</span><br><span class="line">mZxid = 0x0</span><br><span class="line">mtime = Thu Jan 01 08:00:00 CST 1970</span><br><span class="line">pZxid = 0x0</span><br><span class="line">cversion = -1</span><br><span class="line">dataVersion = 0</span><br><span class="line">aclVersion = 0</span><br><span class="line">ephemeralOwner = 0x0</span><br><span class="line">dataLength = 0</span><br><span class="line">numChildren = 1</span><br><span class="line"><span class="meta">#</span><span class="bash"> 查看根目录</span></span><br><span class="line">[zk: localhost:2181(CONNECTED) 1] ls /</span><br><span class="line">[zookeeper]</span><br><span class="line"><span class="meta">#</span><span class="bash"> 新建节点<span class="built_in">test</span></span></span><br><span class="line">[zk: localhost:2181(CONNECTED) 2] create -e /test 123456</span><br><span class="line">Created /test</span><br><span class="line"><span class="meta">#</span><span class="bash"> 再次查看目录</span></span><br><span class="line">[zk: localhost:2181(CONNECTED) 3] ls /</span><br><span class="line">[zookeeper, test]</span><br><span class="line"><span class="meta">#</span><span class="bash"> 获取<span class="built_in">test</span>节点</span></span><br><span class="line">[zk: localhost:2181(CONNECTED) 4] get /test</span><br><span class="line">123456</span><br><span class="line">cZxid = 0x4</span><br><span class="line">ctime = Tue Sep 08 20:10:35 CST 2020</span><br><span class="line">mZxid = 0x4</span><br><span class="line">mtime = Tue Sep 08 20:10:35 CST 2020</span><br><span class="line">pZxid = 0x4</span><br><span class="line">cversion = 0</span><br><span class="line">dataVersion = 0</span><br><span class="line">aclVersion = 0</span><br><span class="line">ephemeralOwner = 0x100061cf1510001</span><br><span class="line">dataLength = 6</span><br><span class="line">numChildren = 0</span><br></pre></td></tr></table></figure><h3 id="2-2-监控中心"><a href="#2-2-监控中心" class="headerlink" title="2.2 监控中心"></a><strong>2.2 监控中心</strong></h3><p>在GitHub找到dubbo项目：<a href="https://github.com/apache/dubbo" target="_blank" rel="noopener">apache/dubbo</a>。往下找到ecosystem，首先下载Dubbo Admin这是一个管理控制台。</p><p><img src="https://pic-1258215793.cos.ap-shanghai.myqcloud.com/content/20200901/202009010101.png" alt></p><p>查看 <code>application.properties</code> 中Zookeeper地址是否正确。</p><p>在Idea中运行或用Maven打包启动，注意运行端口。</p><p>生产环境配置：</p><ol><li><p>下载代码: <code>git clone https://github.com/apache/dubbo-admin.git</code></p></li><li><p>在 <code>dubbo-admin-server/src/main/resources/application.properties</code>中指定注册中心地址</p></li><li><p>构建</p><blockquote><ul><li><code>mvn clean package</code></li></ul></blockquote></li><li><p>启动</p><ul><li><code>mvn --projects dubbo-admin-server spring-boot:run</code><br>或者</li><li><code>cd dubbo-admin-distribution/target; java -jar dubbo-admin-0.1.jar</code></li></ul></li><li><p>访问 <code>http://localhost:8080</code></p></li></ol><p>开发环境配置：</p><ul><li>运行<code>dubbo admin server</code> <code>dubbo admin server</code>是一个标准的spring boot项目, 可以在任何java IDE中运行它</li><li>运行<code>dubbo admin ui</code> <code>dubbo admin ui</code>由npm管理和构建，在开发环境中，可以单独运行: <code>npm run dev</code></li><li>页面访问 访问 <code>http://localhost:8081</code>, 由于前后端分开部署，前端支持热加载，任何页面的修改都可以实时反馈，不需要重启应用。</li></ul><p>部署完成后，可以访问 <a href="http://localhost:8080/swagger-ui.html" target="_blank" rel="noopener">http://localhost:8080/swagger-ui.html</a> 来查看所有的restful api。</p><p>访问UI对应地址。</p><p><img src="https://pic-1258215793.cos.ap-shanghai.myqcloud.com/content/20200901/202009010102.png" alt></p><p>默认使用 root/root 登陆。</p><p><img src="https://pic-1258215793.cos.ap-shanghai.myqcloud.com/content/20200901/202009010103.png" alt></p><p>登录后可以查看Dubbon Admin提供的基础功能。</p><p><img src="https://pic-1258215793.cos.ap-shanghai.myqcloud.com/content/20200901/202009010104.png" alt></p><h3 id="2-3-实例"><a href="#2-3-实例" class="headerlink" title="2.3 实例"></a><strong>2.3 实例</strong></h3><h4 id="（1）需求"><a href="#（1）需求" class="headerlink" title="（1）需求"></a><strong>（1）需求</strong></h4><p>描述：某电商系统，其订单服务需要调用用户服务获取指定用户的所有地址。</p><p>因此我们需要构建两个服务模块：订单服务Web模块，用户服务Service模块。</p><p>实现：订单服务Web模块部署于服务器A，用户服务Service模块部署于服务器B，A可以远程调用B。</p><h4 id="（2）架构"><a href="#（2）架构" class="headerlink" title="（2）架构"></a><strong>（2）架构</strong></h4><p>根据 dubbo《<a href="http://dubbo.apache.org/zh-cn/docs/user/best-practice.html" target="_blank" rel="noopener">服务化最佳实践</a>》：</p><ol><li><p><strong>分包</strong>：建议将服务接口，服务模型，服务异常等均放在 API 包中，因为服务模型及异常也是 API 的一部分，同时，这样做也符合分包原则：<strong>重用发布等价原则</strong>(REP)，<strong>共同重用原则</strong>(CRP)。</p><p>如果需要，也可以考虑在 API 包中放置一份 spring 的引用配置，这样使用方，只需在 spring 加载过程中引用此配置即可，配置建议放在模块的包目录下，以免冲突，如：/xxx/dubbo-reference.xml。</p></li><li><p><strong>粒度</strong>：服务接口尽可能大粒度，每个服务方法应代表一个功能，而不是某功能的一个步骤，否则将面临分布式事务问题，Dubbo 暂未提供分布式事务支持。</p><p>服务接口建议以业务场景为单位划分，并对相近业务做抽象，防止接口数量爆炸。</p><p>不建议使用过于抽象的通用接口，如：Map query(Map)，这样的接口没有明确语义，会给后期维护带来不便。</p></li><li><p><strong>版本</strong>：每个接口都应定义版本号，为后续不兼容升级提供可能，如： <code>&lt;dubbo:service interface=&quot;com.xxx.XxxService&quot; version=&quot;1.0&quot; /&gt;</code>。</p><p>建议使用两位版本号，因为第三位版本号通常表示兼容升级，只有不兼容时才需要变更服务版本。</p><p>当不兼容时，先升级一半提供者为新版本，再将消费者全部升为新版本，然后将剩下的一半提供者升为新版本。</p></li><li><p><strong>兼容性</strong>：服务接口增加方法，或服务模型增加字段，可向后兼容，删除方法或删除字段，将不兼容，枚举类型新增字段也不兼容，需通过变更版本号升级。</p><p>各协议的兼容性不同，参见：<a href="http://dubbo.apache.org/zh-cn/docs/user/references/protocol/introduction.html" target="_blank" rel="noopener">服务协议</a> 。</p></li><li><p><strong>枚举值</strong>：</p><ul><li>如果是完备集，可以用 <code>Enum</code>，比如：<code>ENABLE</code>, <code>DISABLE</code>。</li><li>如果是业务种类，以后明显会有类型增加，不建议用 <code>Enum</code>，可以用 <code>String</code> 代替。</li><li>如果是在返回值中用了 <code>Enum</code>，并新增了 <code>Enum</code> 值，建议先升级服务消费方，这样服务提供方不会返回新值。</li><li>如果是在传入参数中用了 <code>Enum</code>，并新增了 <code>Enum</code> 值，建议先升级服务提供方，这样服务消费方不会传入新值。</li></ul></li><li><p><strong>序列号</strong>：</p><ul><li>服务参数及返回值建议使用 POJO 对象，即通过 <code>setter</code>, <code>getter</code> 方法表示属性的对象。</li><li>服务参数及返回值不建议使用接口，因为数据模型抽象的意义不大，并且序列化需要接口实现类的元信息，并不能起到隐藏实现的意图。</li><li>服务参数及返回值都必须是<a href="https://en.wikipedia.org/wiki/Evaluation_strategy#Call_by_value" target="_blank" rel="noopener">传值调用</a>，而不能是<a href="https://en.wikipedia.org/wiki/Evaluation_strategy#Call_by_reference" target="_blank" rel="noopener">传引用调用</a>，消费方和提供方的参数或返回值引用并不是同一个，只是值相同，Dubbo 不支持引用远程对象。</li></ul></li><li><p><strong>异常</strong>：</p><ul><li>建议使用异常汇报错误，而不是返回错误码，异常信息能携带更多信息，并且语义更友好。</li><li>如果担心性能问题，在必要时，可以通过 override 掉异常类的 <code>fillInStackTrace()</code> 方法为空方法，使其不拷贝栈信息。</li><li>查询方法不建议抛出 checked 异常，否则调用方在查询时将过多的 <code>try...catch</code>，并且不能进行有效处理。</li><li>服务提供方不应将 DAO 或 SQL 等异常抛给消费方，应在服务实现中对消费方不关心的异常进行包装，否则可能出现消费方无法反序列化相应异常。</li></ul></li><li><p><strong>调用</strong>：</p><ul><li>不要只是因为是 Dubbo 调用，而把调用 <code>try...catch</code> 起来。<code>try...catch</code> 应该加上合适的回滚边界上。</li><li>Provider 端需要对输入参数进行校验。如有性能上的考虑，服务实现者可以考虑在 API 包上加上服务 Stub 类来完成检验。</li></ul></li></ol><p>最终：</p><ul><li>gmall-order-web：订单服务Web模块。</li><li>gmall-user：用户服务Service模块</li><li>gmall-interface：公共接口层。</li></ul><h4 id="（3）编码"><a href="#（3）编码" class="headerlink" title="（3）编码"></a><strong>（3）编码</strong></h4><p>创建Maven项目gmall，并分别创建子项目：</p><ul><li>gmall-order-web：订单服务Web模块。</li><li>gmall-user：用户服务Service模块</li><li>gmall-interface：公共接口层。</li></ul><p><img src="https://pic-1258215793.cos.ap-shanghai.myqcloud.com/content/20200901/202009010105.png" alt></p><p>使用dubbo：</p><ul><li>首先引入dubbo和操作zookeeper的客户端的依赖；</li><li>创建xml，并在文件中配置服务（即官网所说的用Spring配置暴露服务）；</li><li>在启动类中加载Spring配置。</li></ul><h5 id="1-user-service-provider"><a href="#1-user-service-provider" class="headerlink" title="1.user-service-provider"></a><strong>1.user-service-provider</strong></h5><p>pom.xml，分别引入dubbo和zookeeper客户端。</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="php"><span class="meta">&lt;?</span>xml version=<span class="string">"1.0"</span> encoding=<span class="string">"UTF-8"</span><span class="meta">?&gt;</span></span></span><br><span class="line"><span class="tag">&lt;<span class="name">project</span> <span class="attr">xmlns</span>=<span class="string">"http://maven.apache.org/POM/4.0.0"</span></span></span><br><span class="line"><span class="tag">         <span class="attr">xmlns:xsi</span>=<span class="string">"http://www.w3.org/2001/XMLSchema-instance"</span></span></span><br><span class="line"><span class="tag">         <span class="attr">xsi:schemaLocation</span>=<span class="string">"http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">parent</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>gmall<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.xxx<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">version</span>&gt;</span>1.0-SNAPSHOT<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">parent</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">modelVersion</span>&gt;</span>4.0.0<span class="tag">&lt;/<span class="name">modelVersion</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.lai.gmall<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>user-service-provider<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">dependencies</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.lai.gmall<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>gmall-interface<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">version</span>&gt;</span>1.0-SNAPSHOT<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">&lt;!-- 引入dubbo --&gt;</span></span><br><span class="line">        <span class="comment">&lt;!-- https://mvnrepository.com/artifact/com.alibaba/dubbo --&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>com.alibaba<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>dubbo<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">version</span>&gt;</span>2.6.2<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="comment">&lt;!-- 注册中心使用的是zookeeper，引入操作zookeeper的客户端 --&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.apache.curator<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>curator-framework<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">version</span>&gt;</span>2.12.0<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">dependencies</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">project</span>&gt;</span></span><br></pre></td></tr></table></figure><p>provider.xml</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="php"><span class="meta">&lt;?</span>xml version=<span class="string">"1.0"</span> encoding=<span class="string">"UTF-8"</span><span class="meta">?&gt;</span></span></span><br><span class="line"><span class="tag">&lt;<span class="name">beans</span> <span class="attr">xmlns</span>=<span class="string">"http://www.springframework.org/schema/beans"</span></span></span><br><span class="line"><span class="tag"><span class="attr">xmlns:xsi</span>=<span class="string">"http://www.w3.org/2001/XMLSchema-instance"</span></span></span><br><span class="line"><span class="tag"><span class="attr">xmlns:dubbo</span>=<span class="string">"http://code.alibabatech.com/schema/dubbo"</span></span></span><br><span class="line"><span class="tag"><span class="attr">xsi:schemaLocation</span>=<span class="string">"http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd</span></span></span><br><span class="line"><span class="tag"><span class="string">http://dubbo.apache.org/schema/dubbo http://dubbo.apache.org/schema/dubbo/dubbo.xsd</span></span></span><br><span class="line"><span class="tag"><span class="string">http://code.alibabatech.com/schema/dubbo http://code.alibabatech.com/schema/dubbo/dubbo.xsd"</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">&lt;!-- 1、指定当前服务/应用的名字（同样的服务名字相同，不要和别的服务同名） --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dubbo:application</span> <span class="attr">name</span>=<span class="string">"user-service-provider"</span>&gt;</span><span class="tag">&lt;/<span class="name">dubbo:application</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">&lt;!-- 2、指定注册中心的位置 --&gt;</span></span><br><span class="line"><span class="comment">&lt;!-- &lt;dubbo:registry address="zookeeper://127.0.0.1:2181"&gt;&lt;/dubbo:registry&gt; --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dubbo:registry</span> <span class="attr">protocol</span>=<span class="string">"zookeeper"</span> <span class="attr">address</span>=<span class="string">"127.0.0.1:2181"</span>&gt;</span><span class="tag">&lt;/<span class="name">dubbo:registry</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">&lt;!-- 3、指定通信规则（通信协议？通信端口） --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dubbo:protocol</span> <span class="attr">name</span>=<span class="string">"dubbo"</span> <span class="attr">port</span>=<span class="string">"20882"</span>&gt;</span><span class="tag">&lt;/<span class="name">dubbo:protocol</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">&lt;!-- 4、暴露服务   ref：指向服务的真正的实现对象 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dubbo:service</span> <span class="attr">interface</span>=<span class="string">"gmall.service.UserService"</span></span></span><br><span class="line"><span class="tag"><span class="attr">ref</span>=<span class="string">"userServiceImpl01"</span> <span class="attr">timeout</span>=<span class="string">"1000"</span> <span class="attr">version</span>=<span class="string">"1.0.0"</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dubbo:method</span> <span class="attr">name</span>=<span class="string">"getUserAddressList"</span> <span class="attr">timeout</span>=<span class="string">"1000"</span>&gt;</span><span class="tag">&lt;/<span class="name">dubbo:method</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dubbo:service</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">&lt;!--统一设置服务提供方的规则  --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dubbo:provider</span> <span class="attr">timeout</span>=<span class="string">"1000"</span>&gt;</span><span class="tag">&lt;/<span class="name">dubbo:provider</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">&lt;!-- 服务的实现 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">"userServiceImpl01"</span> <span class="attr">class</span>=<span class="string">"gmall.service.impl.UserServiceImpl"</span>&gt;</span><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">dubbo:service</span> <span class="attr">interface</span>=<span class="string">"gmall.service.UserService"</span></span></span><br><span class="line"><span class="tag"><span class="attr">ref</span>=<span class="string">"userServiceImpl02"</span> <span class="attr">timeout</span>=<span class="string">"1000"</span> <span class="attr">version</span>=<span class="string">"2.0.0"</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dubbo:method</span> <span class="attr">name</span>=<span class="string">"getUserAddressList"</span> <span class="attr">timeout</span>=<span class="string">"1000"</span>&gt;</span><span class="tag">&lt;/<span class="name">dubbo:method</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dubbo:service</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">"userServiceImpl02"</span> <span class="attr">class</span>=<span class="string">"gmall.service.impl.UserServiceImpl2"</span>&gt;</span><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">&lt;!-- 连接监控中心 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dubbo:monitor</span> <span class="attr">protocol</span>=<span class="string">"registry"</span>&gt;</span><span class="tag">&lt;/<span class="name">dubbo:monitor</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;/<span class="name">beans</span>&gt;</span></span><br></pre></td></tr></table></figure><p>MainApplication</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> gmall;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.io.IOException;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> org.springframework.context.ApplicationContext;</span><br><span class="line"><span class="keyword">import</span> org.springframework.context.support.ClassPathXmlApplicationContext;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MainApplication</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">ClassPathXmlApplicationContext ioc = <span class="keyword">new</span> ClassPathXmlApplicationContext(<span class="string">"provider.xml"</span>);</span><br><span class="line">ioc.start();</span><br><span class="line">System.in.read();</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>UserServiceImpl</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> gmall.service.impl;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> gmall.bean.UserAddress;</span><br><span class="line"><span class="keyword">import</span> gmall.service.UserService;</span><br><span class="line"><span class="keyword">import</span> java.util.Arrays;</span><br><span class="line"><span class="keyword">import</span> java.util.List;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">UserServiceImpl</span> <span class="keyword">implements</span> <span class="title">UserService</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> List&lt;UserAddress&gt; <span class="title">getUserAddressList</span><span class="params">(String userId)</span> </span>&#123;</span><br><span class="line">System.out.println(<span class="string">"UserServiceImpl.....old..."</span>);</span><br><span class="line"><span class="comment">// TODO Auto-generated method stub</span></span><br><span class="line">UserAddress address1 = <span class="keyword">new</span> UserAddress(<span class="number">1</span>, <span class="string">"北京市昌平区宏福科技园综合楼3层"</span>, <span class="string">"1"</span>, <span class="string">"李老师"</span>, <span class="string">"010-56253825"</span>, <span class="string">"Y"</span>);</span><br><span class="line">UserAddress address2 = <span class="keyword">new</span> UserAddress(<span class="number">2</span>, <span class="string">"深圳市宝安区西部硅谷大厦B座3层（深圳分校）"</span>, <span class="string">"1"</span>, <span class="string">"王老师"</span>, <span class="string">"010-56253825"</span>, <span class="string">"N"</span>);</span><br><span class="line"><span class="comment">/*try &#123;</span></span><br><span class="line"><span class="comment">Thread.sleep(4000);</span></span><br><span class="line"><span class="comment">&#125; catch (InterruptedException e) &#123;</span></span><br><span class="line"><span class="comment">// TODO Auto-generated catch block</span></span><br><span class="line"><span class="comment">e.printStackTrace();</span></span><br><span class="line"><span class="comment">&#125;*/</span></span><br><span class="line"><span class="keyword">return</span> Arrays.asList(address1,address2);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>UserServiceImpl2</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> gmall.service.impl;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> gmall.bean.UserAddress;</span><br><span class="line"><span class="keyword">import</span> gmall.service.UserService;</span><br><span class="line"><span class="keyword">import</span> java.util.Arrays;</span><br><span class="line"><span class="keyword">import</span> java.util.List;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">UserServiceImpl2</span> <span class="keyword">implements</span> <span class="title">UserService</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> List&lt;UserAddress&gt; <span class="title">getUserAddressList</span><span class="params">(String userId)</span> </span>&#123;</span><br><span class="line">System.out.println(<span class="string">"UserServiceImpl.....new..."</span>);</span><br><span class="line"><span class="comment">// TODO Auto-generated method stub</span></span><br><span class="line">UserAddress address1 = <span class="keyword">new</span> UserAddress(<span class="number">1</span>, <span class="string">"北京市昌平区宏福科技园综合楼3层"</span>, <span class="string">"1"</span>, <span class="string">"李老师"</span>, <span class="string">"010-56253825"</span>, <span class="string">"Y"</span>);</span><br><span class="line">UserAddress address2 = <span class="keyword">new</span> UserAddress(<span class="number">2</span>, <span class="string">"深圳市宝安区西部硅谷大厦B座3层（深圳分校）"</span>, <span class="string">"1"</span>, <span class="string">"王老师"</span>, <span class="string">"010-56253825"</span>, <span class="string">"N"</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> Arrays.asList(address1,address2);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>UserServiceStub</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> gmall.service.impl;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.List;</span><br><span class="line"><span class="keyword">import</span> gmall.bean.UserAddress;</span><br><span class="line"><span class="keyword">import</span> gmall.service.UserService;</span><br><span class="line"><span class="keyword">import</span> org.springframework.util.StringUtils;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">UserServiceStub</span> <span class="keyword">implements</span> <span class="title">UserService</span> </span>&#123;</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> UserService userService;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 传入的是userService远程的代理对象</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> userService</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">UserServiceStub</span><span class="params">(UserService userService)</span> </span>&#123;</span><br><span class="line"><span class="keyword">super</span>();</span><br><span class="line"><span class="keyword">this</span>.userService = userService;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> List&lt;UserAddress&gt; <span class="title">getUserAddressList</span><span class="params">(String userId)</span> </span>&#123;</span><br><span class="line"><span class="comment">// TODO Auto-generated method stub</span></span><br><span class="line">System.out.println(<span class="string">"UserServiceStub....."</span>);</span><br><span class="line"><span class="keyword">if</span>(!StringUtils.isEmpty(userId)) &#123;</span><br><span class="line"><span class="keyword">return</span> userService.getUserAddressList(userId);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="2-order-service-consumer"><a href="#2-order-service-consumer" class="headerlink" title="2.order-service-consumer"></a><strong>2.order-service-consumer</strong></h5><p>pom.xml，也分别引入dubbo和zookeeper。</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="php"><span class="meta">&lt;?</span>xml version=<span class="string">"1.0"</span> encoding=<span class="string">"UTF-8"</span><span class="meta">?&gt;</span></span></span><br><span class="line"><span class="tag">&lt;<span class="name">project</span> <span class="attr">xmlns</span>=<span class="string">"http://maven.apache.org/POM/4.0.0"</span></span></span><br><span class="line"><span class="tag">         <span class="attr">xmlns:xsi</span>=<span class="string">"http://www.w3.org/2001/XMLSchema-instance"</span></span></span><br><span class="line"><span class="tag">         <span class="attr">xsi:schemaLocation</span>=<span class="string">"http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">parent</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>gmall<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.lai<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">version</span>&gt;</span>1.0-SNAPSHOT<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">parent</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">modelVersion</span>&gt;</span>4.0.0<span class="tag">&lt;/<span class="name">modelVersion</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.lai.gmall<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>order-service-consumer<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">dependencies</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.lai.gmall<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>gmall-interface<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">version</span>&gt;</span>1.0-SNAPSHOT<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">&lt;!-- 引入dubbo --&gt;</span></span><br><span class="line">        <span class="comment">&lt;!-- https://mvnrepository.com/artifact/com.alibaba/dubbo --&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>com.alibaba<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>dubbo<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">version</span>&gt;</span>2.6.2<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="comment">&lt;!-- 注册中心使用的是zookeeper，引入操作zookeeper的客户端端 --&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.apache.curator<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>curator-framework<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">version</span>&gt;</span>2.12.0<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">dependencies</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">project</span>&gt;</span></span><br></pre></td></tr></table></figure><p>consumer.xml</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="php"><span class="meta">&lt;?</span>xml version=<span class="string">"1.0"</span> encoding=<span class="string">"UTF-8"</span><span class="meta">?&gt;</span></span></span><br><span class="line"><span class="tag">&lt;<span class="name">beans</span> <span class="attr">xmlns</span>=<span class="string">"http://www.springframework.org/schema/beans"</span></span></span><br><span class="line"><span class="tag"><span class="attr">xmlns:xsi</span>=<span class="string">"http://www.w3.org/2001/XMLSchema-instance"</span></span></span><br><span class="line"><span class="tag"><span class="attr">xmlns:dubbo</span>=<span class="string">"http://dubbo.apache.org/schema/dubbo"</span></span></span><br><span class="line"><span class="tag"><span class="attr">xmlns:context</span>=<span class="string">"http://www.springframework.org/schema/context"</span></span></span><br><span class="line"><span class="tag"><span class="attr">xsi:schemaLocation</span>=<span class="string">"http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd</span></span></span><br><span class="line"><span class="tag"><span class="string">http://www.springframework.org/schema/context http://www.springframework.org/schema/context/spring-context-4.3.xsd</span></span></span><br><span class="line"><span class="tag"><span class="string">http://dubbo.apache.org/schema/dubbo http://dubbo.apache.org/schema/dubbo/dubbo.xsd</span></span></span><br><span class="line"><span class="tag"><span class="string">http://code.alibabatech.com/schema/dubbo http://code.alibabatech.com/schema/dubbo/dubbo.xsd"</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">context:component-scan</span> <span class="attr">base-package</span>=<span class="string">"gmall.service.impl"</span>&gt;</span><span class="tag">&lt;/<span class="name">context:component-scan</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">dubbo:application</span> <span class="attr">name</span>=<span class="string">"order-service-consumer"</span>&gt;</span><span class="tag">&lt;/<span class="name">dubbo:application</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">dubbo:registry</span> <span class="attr">address</span>=<span class="string">"zookeeper://127.0.0.1:2181"</span>&gt;</span><span class="tag">&lt;/<span class="name">dubbo:registry</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">&lt;!--  配置本地存根--&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">&lt;!--声明需要调用的远程服务的接口；生成远程服务代理  --&gt;</span></span><br><span class="line"><span class="comment">&lt;!-- </span></span><br><span class="line"><span class="comment">1）、精确优先 (方法级优先，接口级次之，全局配置再次之)</span></span><br><span class="line"><span class="comment">2）、消费者设置优先(如果级别一样，则消费方优先，提供方次之)</span></span><br><span class="line"><span class="comment">--&gt;</span></span><br><span class="line"><span class="comment">&lt;!-- timeout="0" 默认是1000ms--&gt;</span></span><br><span class="line"><span class="comment">&lt;!-- retries="":重试次数，不包含第一次调用，0代表不重试--&gt;</span></span><br><span class="line"><span class="comment">&lt;!-- 幂等（设置重试次数）【查询、删除、修改】、非幂等（不能设置重试次数）【新增】 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dubbo:reference</span> <span class="attr">interface</span>=<span class="string">"gmall.service.UserService"</span></span></span><br><span class="line"><span class="tag"><span class="attr">id</span>=<span class="string">"userService"</span> <span class="attr">timeout</span>=<span class="string">"5000"</span> <span class="attr">retries</span>=<span class="string">"3"</span> <span class="attr">version</span>=<span class="string">"*"</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!-- &lt;dubbo:method name="getUserAddressList" timeout="1000"&gt;&lt;/dubbo:method&gt; --&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dubbo:reference</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">&lt;!-- 配置当前消费者的统一规则：所有的服务都不检查 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dubbo:consumer</span> <span class="attr">check</span>=<span class="string">"false"</span> <span class="attr">timeout</span>=<span class="string">"5000"</span>&gt;</span><span class="tag">&lt;/<span class="name">dubbo:consumer</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">dubbo:monitor</span> <span class="attr">protocol</span>=<span class="string">"registry"</span>&gt;</span><span class="tag">&lt;/<span class="name">dubbo:monitor</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!-- &lt;dubbo:monitor address="127.0.0.1:7070"&gt;&lt;/dubbo:monitor&gt; --&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;/<span class="name">beans</span>&gt;</span></span><br></pre></td></tr></table></figure><p>MainApplication</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> gmall;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.io.IOException;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> gmall.service.OrderService;</span><br><span class="line"><span class="keyword">import</span> org.springframework.context.support.ClassPathXmlApplicationContext;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MainApplication</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="meta">@SuppressWarnings</span>(<span class="string">"resource"</span>)</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">ClassPathXmlApplicationContext applicationContext = <span class="keyword">new</span> ClassPathXmlApplicationContext(<span class="string">"consumer.xml"</span>);</span><br><span class="line"></span><br><span class="line">OrderService orderService = applicationContext.getBean(OrderService.class);</span><br><span class="line"></span><br><span class="line">orderService.initOrder(<span class="string">"1"</span>);</span><br><span class="line">System.out.println(<span class="string">"调用完成...."</span>);</span><br><span class="line">System.in.read();</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>OrderServiceImpl</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> gmall.service.impl;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> gmall.bean.UserAddress;</span><br><span class="line"><span class="keyword">import</span> gmall.service.OrderService;</span><br><span class="line"><span class="keyword">import</span> gmall.service.UserService;</span><br><span class="line"><span class="keyword">import</span> org.springframework.beans.factory.annotation.Autowired;</span><br><span class="line"><span class="keyword">import</span> org.springframework.stereotype.Service;</span><br><span class="line"><span class="keyword">import</span> java.util.List;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 1、将服务提供者注册到注册中心（暴露服务）</span></span><br><span class="line"><span class="comment"> * 1）、导入dubbo依赖（2.6.2）\操作zookeeper的客户端(curator)</span></span><br><span class="line"><span class="comment"> * 2）、配置服务提供者</span></span><br><span class="line"><span class="comment"> * </span></span><br><span class="line"><span class="comment"> * 2、让服务消费者去注册中心订阅服务提供者的服务地址</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> lfy</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@Service</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">OrderServiceImpl</span> <span class="keyword">implements</span> <span class="title">OrderService</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Autowired</span></span><br><span class="line">UserService userService;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> List&lt;UserAddress&gt; <span class="title">initOrder</span><span class="params">(String userId)</span> </span>&#123;</span><br><span class="line"><span class="comment">// TODO Auto-generated method stub</span></span><br><span class="line">System.out.println(<span class="string">"用户id："</span>+userId);</span><br><span class="line"><span class="comment">//1、查询用户的收货地址</span></span><br><span class="line">List&lt;UserAddress&gt; addressList = userService.getUserAddressList(userId);</span><br><span class="line"><span class="keyword">for</span> (UserAddress userAddress : addressList) &#123;</span><br><span class="line">System.out.println(userAddress.getUserAddress());</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> addressList;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="3-gmall-interface"><a href="#3-gmall-interface" class="headerlink" title="3.gmall-interface"></a><strong>3.gmall-interface</strong></h5><p>pom.xml</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="php"><span class="meta">&lt;?</span>xml version=<span class="string">"1.0"</span> encoding=<span class="string">"UTF-8"</span><span class="meta">?&gt;</span></span></span><br><span class="line"><span class="tag">&lt;<span class="name">project</span> <span class="attr">xmlns</span>=<span class="string">"http://maven.apache.org/POM/4.0.0"</span></span></span><br><span class="line"><span class="tag">         <span class="attr">xmlns:xsi</span>=<span class="string">"http://www.w3.org/2001/XMLSchema-instance"</span></span></span><br><span class="line"><span class="tag">         <span class="attr">xsi:schemaLocation</span>=<span class="string">"http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">parent</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>gmall<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.lai<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">version</span>&gt;</span>1.0-SNAPSHOT<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">parent</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">modelVersion</span>&gt;</span>4.0.0<span class="tag">&lt;/<span class="name">modelVersion</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.lai.gmall<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>gmall-interface<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">project</span>&gt;</span></span><br></pre></td></tr></table></figure><p>UserAddress</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> gmall.bean;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.io.Serializable;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 用户地址</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> lfy</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">UserAddress</span> <span class="keyword">implements</span> <span class="title">Serializable</span> </span>&#123;</span><br><span class="line"><span class="keyword">private</span> Integer id;</span><br><span class="line">    <span class="keyword">private</span> String userAddress; <span class="comment">//用户地址</span></span><br><span class="line">    <span class="keyword">private</span> String userId; <span class="comment">//用户id</span></span><br><span class="line">    <span class="keyword">private</span> String consignee; <span class="comment">//收货人</span></span><br><span class="line">    <span class="keyword">private</span> String phoneNum; <span class="comment">//电话号码</span></span><br><span class="line">    <span class="keyword">private</span> String isDefault; <span class="comment">//是否为默认地址    Y-是     N-否</span></span><br><span class="line">    </span><br><span class="line"><span class="comment">//constructor and getter and setter</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>OrderService</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> gmall.service;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> gmall.bean.UserAddress;</span><br><span class="line"><span class="keyword">import</span> java.util.List;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">OrderService</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 初始化订单</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> userId</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> List&lt;UserAddress&gt; <span class="title">initOrder</span><span class="params">(String userId)</span></span>;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>UserService</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> gmall.service;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> gmall.bean.UserAddress;</span><br><span class="line"><span class="keyword">import</span> java.util.List;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 用户服务</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> lfy</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">UserService</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 按照用户id返回所有的收货地址</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> userId</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> List&lt;UserAddress&gt; <span class="title">getUserAddressList</span><span class="params">(String userId)</span></span>;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="（4）启动"><a href="#（4）启动" class="headerlink" title="（4）启动"></a><strong>（4）启动</strong></h4><p>分别启动服务提供者和消费者，控制台输出如下内容：</p><figure class="highlight lsl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">用户id：<span class="number">1</span></span><br><span class="line">北京市昌平区宏福科技园综合楼<span class="number">3</span>层</span><br><span class="line">深圳市宝安区西部硅谷大厦B座<span class="number">3</span>层（深圳分校）</span><br><span class="line">调用完成....</span><br></pre></td></tr></table></figure><p>此时再启动dubbo-admin，使用 root / root 登录。</p><p><img src="https://pic-1258215793.cos.ap-shanghai.myqcloud.com/content/20200901/202009010106.png" alt></p><hr><h2 id="第三节-整合Spring-Boot"><a href="#第三节-整合Spring-Boot" class="headerlink" title="第三节 整合Spring Boot"></a><strong>第三节 整合Spring Boot</strong></h2><p>GitHub地址：<a href="https://github.com/apache/dubbo-spring-boot-project" target="_blank" rel="noopener">apache/dubbo-spring-boot-project</a> 。</p><p>下载项目与依赖，并跑通案例 <code>dubbo-spring-boot-samples</code> 。</p><h3 id="3-1-公共接口-sample-api"><a href="#3-1-公共接口-sample-api" class="headerlink" title="3.1 公共接口 sample-api"></a><strong>3.1 公共接口 sample-api</strong></h3><p>首先看 <code>dubbo-spring-boot-samples</code> / <code>sample-api</code> ，它是<strong>公共接口层</strong>，提供了生产者和消费者要使用的DemoService服务接口。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> org.apache.dubbo.spring.boot.sample.consumer;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">DemoService</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function">String <span class="title">sayHello</span><span class="params">(String name)</span></span>;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="3-2-自动装配-auto-configure-samples"><a href="#3-2-自动装配-auto-configure-samples" class="headerlink" title="3.2 自动装配 auto-configure-samples"></a><strong>3.2 自动装配 auto-configure-samples</strong></h3><p>再看 <code>dubbo-spring-boot-samples</code> / <code>auto-configure-samples</code> 。</p><h4 id="（1）provider"><a href="#（1）provider" class="headerlink" title="（1）provider"></a><strong>（1）provider</strong></h4><p>首先看服务提供者provider的内容，配置了应用信息、Dubbo协议信息等。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"># Spring boot application </span><br><span class="line"># 应用名</span><br><span class="line">spring.application.name=dubbo-auto-configuration-provider-demo</span><br><span class="line"># Base packages to scan Dubbo Component: @org.apache.dubbo.config.annotation.Service</span><br><span class="line"># 扫描的基础包</span><br><span class="line">dubbo.scan.base-packages=org.apache.dubbo.spring.boot.sample.provider.service</span><br><span class="line"># Dubbo Application</span><br><span class="line">## The default value of dubbo.application.name is $&#123;spring.application.name&#125;</span><br><span class="line">## dubbo.application.name=$&#123;spring.application.name&#125;</span><br><span class="line"></span><br><span class="line"># Protocol地址和端口，指定远程调用协议为dubbo，还可以为rmi、http等</span><br><span class="line"># Dubbo Protocol</span><br><span class="line">dubbo.protocol.name=dubbo</span><br><span class="line">dubbo.protocol.port=12345</span><br><span class="line">## Dubbo Registry</span><br><span class="line">## 注册中心服务器地址，N/A为默认值，表示不使用注册中心，直连客户端，地址可以是一个或多个，多个表示集群</span><br><span class="line">dubbo.registry.address=N/A</span><br></pre></td></tr></table></figure><p>provider实现了DemoService：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@DubboService</span>(version = <span class="string">"1.0.0"</span>)</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">DefaultDemoService</span> <span class="keyword">implements</span> <span class="title">DemoService</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> Logger logger = LoggerFactory.getLogger(getClass());</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> Random costTimeRandom = <span class="keyword">new</span> Random();</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * The default value of $&#123;dubbo.application.name&#125; is $&#123;spring.application.name&#125;</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Value</span>(<span class="string">"$&#123;dubbo.application.name&#125;"</span>)</span><br><span class="line">    <span class="keyword">private</span> String serviceName;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">sayHello</span><span class="params">(String name)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//先简单休眠一下</span></span><br><span class="line">        await();</span><br><span class="line">        <span class="comment">//自己添加的更直观的控制台输出</span></span><br><span class="line">        System.out.println(<span class="string">"sayHello: "</span> + name);</span><br><span class="line">        <span class="comment">//打印serviceName和实参</span></span><br><span class="line">        <span class="keyword">return</span> String.format(<span class="string">"[%s] : Hello, %s"</span>, serviceName, name);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">await</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">long</span> timeInMillisToWait = costTimeRandom.nextInt(<span class="number">500</span>);</span><br><span class="line">            Thread.sleep(timeInMillisToWait);</span><br><span class="line">            logger.info(<span class="string">"execution time : "</span> + timeInMillisToWait + <span class="string">" ms."</span>);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException(e);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>provider的启动类：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@EnableAutoConfiguration</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">DubboAutoConfigurationProviderBootstrap</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line"><span class="comment">//        new SpringApplicationBuilder(DubboAutoConfigurationProviderBootstrap.class)</span></span><br><span class="line"><span class="comment">//                .run(args);</span></span><br><span class="line">        SpringApplication.run(DubboAutoConfigurationProviderBootstrap.class,args);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="（2）consumer"><a href="#（2）consumer" class="headerlink" title="（2）consumer"></a><strong>（2）consumer</strong></h4><p>再来看服务消费者consumer，只是配置了应用名。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">spring:</span><br><span class="line">  application:</span><br><span class="line">    name: dubbo-auto-configure-consumer-sample</span><br></pre></td></tr></table></figure><p>consumer的启动类：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@EnableAutoConfiguration</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">DubboAutoConfigurationConsumerBootstrap</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> Logger logger = LoggerFactory.getLogger(getClass());</span><br><span class="line"></span><br><span class="line">    <span class="comment">//服务提供者注册的地址等信息</span></span><br><span class="line">    <span class="meta">@DubboReference</span>(</span><br><span class="line">            version = <span class="string">"1.0.0"</span>,</span><br><span class="line">            url = <span class="string">"dubbo://127.0.0.1:12345"</span>,</span><br><span class="line">            timeout = <span class="number">100</span>,</span><br><span class="line">            methods = &#123;</span><br><span class="line">                    <span class="meta">@Method</span>(name = <span class="string">"sayHello"</span>, timeout = <span class="number">300</span>)</span><br><span class="line">            &#125;</span><br><span class="line">    )</span><br><span class="line">    <span class="keyword">private</span> DemoService demoService;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        SpringApplication.run(DubboAutoConfigurationConsumerBootstrap.class).close();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> ApplicationRunner <span class="title">runner</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"runner()"</span>);</span><br><span class="line">        <span class="comment">//调用公共接口demoService，通过指定的服务实现远程调用服务</span></span><br><span class="line">        <span class="keyword">return</span> args -&gt; logger.info(demoService.sayHello(<span class="string">"mercyblitz"</span>));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>启动并观察是否正确打印出结果。</p><h3 id="3-3-外部化配置-externalized-configuration-samples"><a href="#3-3-外部化配置-externalized-configuration-samples" class="headerlink" title="3.3 外部化配置 externalized-configuration-samples"></a><strong>3.3 外部化配置 externalized-configuration-samples</strong></h3><h4 id="（1）provider-1"><a href="#（1）provider-1" class="headerlink" title="（1）provider"></a><strong>（1）provider</strong></h4><p>provider与 <code>auto-configure-samples</code> 中唯一不同的是多了服务版本的配置。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"># Spring boot application</span><br><span class="line">spring.application.name=dubbo-externalized-configuration-provider-sample</span><br><span class="line"># Base packages to scan Dubbo Component: @org.apache.dubbo.config.annotation.Service</span><br><span class="line">dubbo.scan.base-packages=org.apache.dubbo.spring.boot.sample.provider.service</span><br><span class="line"></span><br><span class="line"># Dubbo Application</span><br><span class="line">## The default value of dubbo.application.name is $&#123;spring.application.name&#125;</span><br><span class="line">## dubbo.application.name=$&#123;spring.application.name&#125;</span><br><span class="line"></span><br><span class="line"># Dubbo Protocol</span><br><span class="line">dubbo.protocol.name=dubbo</span><br><span class="line">dubbo.protocol.port=12345</span><br><span class="line"></span><br><span class="line">## Dubbo Registry</span><br><span class="line">dubbo.registry.address=N/A</span><br><span class="line"></span><br><span class="line">## DemoService version</span><br><span class="line">demo.service.version=1.0.0</span><br></pre></td></tr></table></figure><p>provider的服务实现，不同的是服务的版本号从配置文件中获取，并且没有sleep。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@DubboService</span>(version = <span class="string">"$&#123;demo.service.version&#125;"</span>)</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">DefaultDemoService</span> <span class="keyword">implements</span> <span class="title">DemoService</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * The default value of $&#123;dubbo.application.name&#125; is $&#123;spring.application.name&#125;</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Value</span>(<span class="string">"$&#123;dubbo.application.name&#125;"</span>)</span><br><span class="line">    <span class="keyword">private</span> String serviceName;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">sayHello</span><span class="params">(String name)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> String.format(<span class="string">"[%s] : Hello, %s"</span>, serviceName, name);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>provider的启动类完全一致。</p><h4 id="（2）consumer-1"><a href="#（2）consumer-1" class="headerlink" title="（2）consumer"></a><strong>（2）consumer</strong></h4><p>消费者consumer则增加了一些配置，启动了一些dubbo端点</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line">spring:</span><br><span class="line">  application:</span><br><span class="line">    name: dubbo-externalized-configuration-consumer-sample</span><br><span class="line"></span><br><span class="line">management:</span><br><span class="line">  endpoints:</span><br><span class="line">    web:</span><br><span class="line">      exposure:</span><br><span class="line">        include: &apos;*&apos;</span><br><span class="line">  endpoint:</span><br><span class="line">    dubbo:</span><br><span class="line">      enabled: true</span><br><span class="line">    dubboshutdown:</span><br><span class="line">      enabled: true</span><br><span class="line">    dubboconfigs:</span><br><span class="line">      enabled: true</span><br><span class="line">    dubboservices:</span><br><span class="line">      enabled: true</span><br><span class="line">    dubboreferences:</span><br><span class="line">      enabled: true</span><br><span class="line">    dubboproperties:</span><br><span class="line">      enabled: true</span><br><span class="line">  security:</span><br><span class="line">    ## Deprecated 2.x</span><br><span class="line">    enabled: false</span><br><span class="line"></span><br><span class="line">## For Spring Boot 1.x demo</span><br><span class="line">endpoints:</span><br><span class="line">  dubbo:</span><br><span class="line">    enabled: true</span><br><span class="line">    sensitive: false</span><br><span class="line">  dubboshutdown:</span><br><span class="line">    enabled: true</span><br><span class="line">  dubboconfigs:</span><br><span class="line">    enabled: true</span><br><span class="line">  dubboservices:</span><br><span class="line">    enabled: true</span><br><span class="line">  dubboreferences:</span><br><span class="line">    enabled: true</span><br><span class="line">  dubboproperties:</span><br><span class="line">    enabled: true</span><br><span class="line"></span><br><span class="line">demo:</span><br><span class="line">  service:</span><br><span class="line">    version: 1.0.0</span><br><span class="line">    url: dubbo://localhost:12345</span><br></pre></td></tr></table></figure><p>consumer的启动类中 <code>@DubboReference</code> 也改为从配置文件读取，并且增加了Get请求接口。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@EnableAutoConfiguration</span></span><br><span class="line"><span class="meta">@RestController</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">DubboExternalizedConfigurationConsumerBootstrap</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> Logger logger = LoggerFactory.getLogger(getClass());</span><br><span class="line"></span><br><span class="line">    <span class="meta">@DubboReference</span>(version = <span class="string">"$&#123;demo.service.version&#125;"</span>, url = <span class="string">"$&#123;demo.service.url&#125;"</span>)</span><br><span class="line">    <span class="keyword">private</span> DemoService demoService;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        SpringApplication.run(DubboExternalizedConfigurationConsumerBootstrap.class);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@RequestMapping</span>(value = <span class="string">"/say-hello"</span>, method = GET)</span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">sayHello</span><span class="params">(@RequestParam String name)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> demoService.sayHello(name);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> ApplicationRunner <span class="title">runner</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> args -&gt; logger.info(demoService.sayHello(<span class="string">"mercyblitz"</span>));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>分别启动 provider 和 consumer 并访问服务接口：</p><p><img src="https://pic-1258215793.cos.ap-shanghai.myqcloud.com/content/20200901/202009010108.png" alt></p><h3 id="3-4-注册中心-registry-samples"><a href="#3-4-注册中心-registry-samples" class="headerlink" title="3.4 注册中心 registry-samples"></a><strong>3.4 注册中心 registry-samples</strong></h3><p>这个实例提供了Dubbo最常用的两种注册中心：Zookeeper 和 Nacos 。</p><h4 id="（1）Zookeeper"><a href="#（1）Zookeeper" class="headerlink" title="（1）Zookeeper"></a><strong>（1）Zookeeper</strong></h4><p>配置文件如下，有些许变更：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"># Spring boot application</span><br><span class="line">spring.application.name=dubbo-registry-zookeeper-provider-sample</span><br><span class="line"># Base packages to scan Dubbo Component: @org.apache.dubbo.config.annotation.Service</span><br><span class="line">dubbo.scan.base-packages=org.apache.dubbo.spring.boot.sample.provider.service</span><br><span class="line"></span><br><span class="line"># Dubbo Application</span><br><span class="line">## The default value of dubbo.application.name is $&#123;spring.application.name&#125;</span><br><span class="line">## dubbo.application.name=$&#123;spring.application.name&#125;</span><br><span class="line"></span><br><span class="line"># Dubbo Protocol</span><br><span class="line">dubbo.protocol.name=dubbo</span><br><span class="line">## Random port 此处改为随机端口，会分配一个没有被占用的端口</span><br><span class="line">dubbo.protocol.port=-1</span><br><span class="line"></span><br><span class="line">## Dubbo Registry</span><br><span class="line">## 指定了注册中心地址</span><br><span class="line">dubbo.registry.address=zookeeper://127.0.0.1:2181</span><br><span class="line">## 使用文件缓存注册中心地址列表及服务提供者列表，应用重启时将基于此文件恢复，注意：两个注册中心不能使用同一文件存储</span><br><span class="line">dubbo.registry.file = $&#123;user.home&#125;/dubbo-cache/$&#123;spring.application.name&#125;/dubbo.cache</span><br><span class="line"></span><br><span class="line">## DemoService version</span><br><span class="line">demo.service.version=1.0.0</span><br></pre></td></tr></table></figure><p>服务实现没有变更：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@DubboService</span>(version = <span class="string">"$&#123;demo.service.version&#125;"</span>)</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">DefaultDemoService</span> <span class="keyword">implements</span> <span class="title">DemoService</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * The default value of $&#123;dubbo.application.name&#125; is $&#123;spring.application.name&#125;</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Value</span>(<span class="string">"$&#123;dubbo.application.name&#125;"</span>)</span><br><span class="line">    <span class="keyword">private</span> String serviceName;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">sayHello</span><span class="params">(String name)</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"sayHello : "</span> + name);</span><br><span class="line">        <span class="keyword">return</span> String.format(<span class="string">"[%s] : Hello, %s"</span>, serviceName, name);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>启动类没有变更：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@EnableAutoConfiguration</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">DubboRegistryZooKeeperProviderBootstrap</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">new</span> SpringApplicationBuilder(DubboRegistryZooKeeperProviderBootstrap.class).run(args);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>consumer中配置文件中增加了注册中心的配置：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">spring:</span><br><span class="line">  application:</span><br><span class="line">    name: dubbo-registry-zookeeper-consumer-sample</span><br><span class="line"></span><br><span class="line">demo:</span><br><span class="line">  service:</span><br><span class="line">    version: 1.0.0</span><br><span class="line"></span><br><span class="line">embedded:</span><br><span class="line">  zookeeper:</span><br><span class="line">    port: 2181</span><br><span class="line"></span><br><span class="line">dubbo:</span><br><span class="line">  registry:</span><br><span class="line">    address: zookeeper://127.0.0.1:$&#123;embedded.zookeeper.port&#125;</span><br><span class="line">    file: $&#123;user.home&#125;/dubbo-cache/$&#123;spring.application.name&#125;/dubbo.cache</span><br></pre></td></tr></table></figure><p>启动类中 <code>@DubboReference</code> 只配置了服务版本，因为之前是通过客户端直连，所以需要指定客户端地址，此时使用注册中心，只须关注服务接口即可。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@EnableAutoConfiguration</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">DubboRegistryZooKeeperConsumerBootstrap</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> Logger logger = LoggerFactory.getLogger(getClass());</span><br><span class="line"></span><br><span class="line">    <span class="meta">@DubboReference</span>(version = <span class="string">"$&#123;demo.service.version&#125;"</span>)</span><br><span class="line">    <span class="keyword">private</span> DemoService demoService;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        SpringApplication.run(DubboRegistryZooKeeperConsumerBootstrap.class).close();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> ApplicationRunner <span class="title">runner</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> args -&gt; logger.info(demoService.sayHello(<span class="string">"mercyblitz"</span>));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>启动并观察控制台。</p><h4 id="（2）Nacos"><a href="#（2）Nacos" class="headerlink" title="（2）Nacos"></a><strong>（2）Nacos</strong></h4><p>内容基本一致，暂略。</p><h3 id="3-5-服务自省-service-introspection-samples"><a href="#3-5-服务自省-service-introspection-samples" class="headerlink" title="3.5  服务自省 service-introspection-samples"></a><strong>3.5  服务自省 service-introspection-samples</strong></h3><h4 id="（1）provider-2"><a href="#（1）provider-2" class="headerlink" title="（1）provider"></a><strong>（1）provider</strong></h4><p>增加了 <code>registry-type</code> 。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"># Spring boot application</span><br><span class="line">spring.application.name=dubbo-zookeeper-service-introspection-provider-sample</span><br><span class="line"></span><br><span class="line"># Zookeeper Server Configuration</span><br><span class="line">zookeeper.server.host = 127.0.0.1</span><br><span class="line">zookeeper.server.port = 2181</span><br><span class="line"></span><br><span class="line"># Dubbo Spring Boot Externalization Configuration</span><br><span class="line">## Base packages to scan Dubbo Component: @org.apache.dubbo.config.annotation.Service</span><br><span class="line">dubbo.scan.base-packages=org.apache.dubbo.spring.boot.sample.provider.service</span><br><span class="line"></span><br><span class="line">## The default value of dubbo.application.name is $&#123;spring.application.name&#125;</span><br><span class="line">## dubbo.application.name=$&#123;spring.application.name&#125;</span><br><span class="line"></span><br><span class="line">## Dubbo Protocol</span><br><span class="line">dubbo.protocol.name=dubbo</span><br><span class="line">## Random port</span><br><span class="line">dubbo.protocol.port=-1</span><br><span class="line"></span><br><span class="line">## Dubbo Registry</span><br><span class="line">dubbo.registry.address=zookeeper://$&#123;zookeeper.server.host&#125;:$&#123;zookeeper.server.port&#125;?registry-type=service</span><br><span class="line"></span><br><span class="line">## DemoService version</span><br><span class="line">demo.service.version=1.0.0</span><br></pre></td></tr></table></figure><p>服务实现和启动类没有变化。</p><h4 id="（2）consumer-2"><a href="#（2）consumer-2" class="headerlink" title="（2）consumer"></a><strong>（2）consumer</strong></h4><p>增加了 <code>registry-type</code> 。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">spring:</span><br><span class="line">  application:</span><br><span class="line">    name: dubbo-zookeeper-service-introspection-consumer-sample</span><br><span class="line"></span><br><span class="line">demo:</span><br><span class="line">  service:</span><br><span class="line">    version: 1.0.0</span><br><span class="line"></span><br><span class="line">embedded:</span><br><span class="line">  zookeeper:</span><br><span class="line">    port: 2181</span><br><span class="line"></span><br><span class="line">dubbo:</span><br><span class="line">  registry:</span><br><span class="line">    address: zookeeper://127.0.0.1:$&#123;embedded.zookeeper.port&#125;/?registry-type=service</span><br><span class="line">    file: $&#123;user.home&#125;/dubbo-cache/$&#123;spring.application.name&#125;/dubbo.cache</span><br></pre></td></tr></table></figure><p>启动类无变更。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@EnableAutoConfiguration</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">DubboZooKeeperServiceIntrospectionConsumerBootstrap</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> Logger logger = LoggerFactory.getLogger(getClass());</span><br><span class="line"></span><br><span class="line">    <span class="meta">@DubboReference</span>(version = <span class="string">"$&#123;demo.service.version&#125;"</span>)</span><br><span class="line">    <span class="keyword">private</span> DemoService demoService;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        SpringApplication.run(DubboZooKeeperServiceIntrospectionConsumerBootstrap.class).close();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> ApplicationRunner <span class="title">runner</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> args -&gt; logger.info(demoService.sayHello(<span class="string">"mercyblitz"</span>));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="3-6-servlet容器-servlet-container-samples"><a href="#3-6-servlet容器-servlet-container-samples" class="headerlink" title="3.6 servlet容器 servlet-container-samples"></a><strong>3.6 servlet容器 servlet-container-samples</strong></h3><p>服务提供者也开放了服务的直接访问接口。</p><h4 id="（1）provider-3"><a href="#（1）provider-3" class="headerlink" title="（1）provider"></a><strong>（1）provider</strong></h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"># Spring boot application</span><br><span class="line">spring.application.name=dubbo-spring-boot-servlet-container-provider-sample</span><br><span class="line"># Base packages to scan Dubbo Component: @org.apache.dubbo.config.annotation.Service</span><br><span class="line">dubbo.scan.base-packages=org.apache.dubbo.spring.boot.sample.provider.service</span><br><span class="line"></span><br><span class="line"># Dubbo Application</span><br><span class="line"></span><br><span class="line"># Dubbo Protocol</span><br><span class="line">dubbo.protocol.name=dubbo</span><br><span class="line">dubbo.protocol.port=23456</span><br><span class="line"></span><br><span class="line">## Dubbo Registry</span><br><span class="line">dubbo.registry.address=N/A</span><br><span class="line"></span><br><span class="line">## DemoService version</span><br><span class="line">demo.service.version=1.0.0</span><br></pre></td></tr></table></figure><p>服务实现无变更。</p><p>启动类增加了服务接口，配置了 <code>WebApplicationType</code> ，表示应用是基于Servlet的Web程序。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@EnableAutoConfiguration</span></span><br><span class="line"><span class="meta">@RestController</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">DubboServletContainerProviderBootstrap</span> <span class="keyword">extends</span> <span class="title">SpringBootServletInitializer</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> DemoService demoService;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@RequestMapping</span>(<span class="string">"/say/&#123;name&#125;"</span>)</span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">say</span><span class="params">(@PathVariable String name)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> demoService.sayHello(name);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> SpringApplicationBuilder <span class="title">configure</span><span class="params">(SpringApplicationBuilder application)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> application.sources(getClass());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123; <span class="comment">// Run as the generic Spring Boot Web(Servlet) Application</span></span><br><span class="line">        SpringApplication application = <span class="keyword">new</span> SpringApplication(DubboServletContainerProviderBootstrap.class);</span><br><span class="line">        application.setWebApplicationType(WebApplicationType.SERVLET);</span><br><span class="line">        application.run(args);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="（2）consumer-3"><a href="#（2）consumer-3" class="headerlink" title="（2）consumer"></a><strong>（2）consumer</strong></h4><p>配置无变化。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">spring:</span><br><span class="line">  application:</span><br><span class="line">    name: dubbo-servlet-container-consumer-sample</span><br><span class="line"></span><br><span class="line">demo:</span><br><span class="line">  service:</span><br><span class="line">    version: 1.0.0</span><br><span class="line">    url: dubbo://127.0.0.1:23456</span><br></pre></td></tr></table></figure><p>启动类开放GET访问接口，通过读取配置文件地址直接远程调用客户端（服务提供者）服务实现，同样设置了 <code>WebApplicationType</code> 。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@EnableAutoConfiguration</span></span><br><span class="line"><span class="meta">@RestController</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">DubboServletContainerConsumerBootstrap</span> <span class="keyword">extends</span> <span class="title">SpringBootServletInitializer</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@DubboReference</span>(version = <span class="string">"$&#123;demo.service.version&#125;"</span>, url = <span class="string">"$&#123;demo.service.url&#125;"</span>)</span><br><span class="line">    <span class="keyword">private</span> DemoService demoService;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@RequestMapping</span>(value = <span class="string">"/say-hello"</span>, method = GET)</span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">sayHello</span><span class="params">(@RequestParam String name)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> demoService.sayHello(name);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> SpringApplicationBuilder <span class="title">configure</span><span class="params">(SpringApplicationBuilder application)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> application.sources(getClass());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123; <span class="comment">// Run as the generic Spring Boot Web(Servlet) Application</span></span><br><span class="line">        SpringApplication application = <span class="keyword">new</span> SpringApplication(DubboServletContainerConsumerBootstrap.class);</span><br><span class="line">        application.setWebApplicationType(WebApplicationType.SERVLET);</span><br><span class="line">        application.run(args);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><p>参考：</p><blockquote><p><a href="http://dubbo.apache.org/zh-cn/docs/user/dependencies.html" target="_blank" rel="noopener">Dubbo官网-文档</a></p></blockquote><blockquote><p>尚硅谷-dubbo</p></blockquote><p><em>若内容涉及侵权请及时告知，我会尽快修改和删除相关内容</em></p>]]></content>
    
    <summary type="html">
    
      从零开始学习Dubbo，第二章《注册中心和监控中心》，并跑了一下Dubbo Spring Boot的示例。
    
    </summary>
    
      <category term="技术文档" scheme="http://linyishui.top/categories/%E6%8A%80%E6%9C%AF%E6%96%87%E6%A1%A3/"/>
    
    
      <category term="dubbo" scheme="http://linyishui.top/tags/dubbo/"/>
    
      <category term="distributed" scheme="http://linyishui.top/tags/distributed/"/>
    
  </entry>
  
  <entry>
    <title>文档编辑器（持续更新）</title>
    <link href="http://linyishui.top/2020090601.html"/>
    <id>http://linyishui.top/2020090601.html</id>
    <published>2020-09-06T11:05:38.000Z</published>
    <updated>2020-09-06T11:53:20.815Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="文档编辑器"><a href="#文档编辑器" class="headerlink" title="文档编辑器"></a><strong>文档编辑器</strong></h1><h3 id="MarkDown工具"><a href="#MarkDown工具" class="headerlink" title="MarkDown工具"></a><strong>MarkDown工具</strong></h3><p>记录一下日常使用过的md工具，一般都是用来写博客和日记，办公反而很少用到。</p><h4 id="（1）VSCode"><a href="#（1）VSCode" class="headerlink" title="（1）VSCode"></a><strong>（1）VSCode</strong></h4><p>最开始使用VSCode来编辑MarkDown文档，优点是大部分程序员都已经有了这个工具，不用再下载。</p><p>但早期写博客时，总感觉效率上还有所欠缺，因为VSCode的定位是一个文本编辑器，而不是富文本编辑器，所以不能像一些Markdown编辑器一样，获得所见即所得的体验。</p><p>所以在文档内容比较长时，就很难快速定位到想要修改的内容。</p><h4 id="（2）Typora"><a href="#（2）Typora" class="headerlink" title="（2）Typora"></a><strong>（2）Typora</strong></h4><p>因为我要整理的文档内容越来越长，所以如何提高写作效率成为我需要考虑的一个问题。我换用了正规的Markdown编辑器——Typora，它能让我像写Word一样的直接在效果页面写作，常用的MarkDown格式也很方便生成，并且支持多种格式的导入导出。</p><p>很长一段时间，我都在使用Typora作为写作工具。</p><p>推荐插件：</p><ul><li>Typora：<ul><li>VLOOK</li></ul></li></ul><p>但最近发现Typora经常会有一些莫名其妙的BUG，并且在文档超过2MB左右就会限制无法打开，这逼迫我必须再寻找一个工具来代替Typora。</p><h4 id="（3）MarkText"><a href="#（3）MarkText" class="headerlink" title="（3）MarkText"></a><strong>（3）MarkText</strong></h4><p>虽然没有文件大小限制，但非常卡顿，切换源码格式直接卡崩溃了，弃用。</p><p>无奈，先用VSCode来处理大文件，平时还继续用Typora。</p><h4 id="（4）VSCode插件"><a href="#（4）VSCode插件" class="headerlink" title="（4）VSCode插件"></a><strong>（4）VSCode插件</strong></h4><p>推荐插件：</p><ul><li>VSCode：<ul><li>Markdown All in One</li></ul></li></ul>]]></content>
    
    <summary type="html">
    
      简单整理工作和学习时常用的文档编辑器，持续更新中。
    
    </summary>
    
      <category term="实用工具" scheme="http://linyishui.top/categories/%E5%AE%9E%E7%94%A8%E5%B7%A5%E5%85%B7/"/>
    
    
      <category term="updating" scheme="http://linyishui.top/tags/updating/"/>
    
      <category term="tools" scheme="http://linyishui.top/tags/tools/"/>
    
  </entry>
  
  <entry>
    <title>从零开始学习英语（四）第一天即开口</title>
    <link href="http://linyishui.top/2020090503.html"/>
    <id>http://linyishui.top/2020090503.html</id>
    <published>2020-09-05T13:28:52.000Z</published>
    <updated>2020-09-07T10:38:16.918Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="第一天即开口"><a href="#第一天即开口" class="headerlink" title="第一天即开口"></a><strong>第一天即开口</strong></h1><h3 id="词汇量不够怎么办"><a href="#词汇量不够怎么办" class="headerlink" title="词汇量不够怎么办"></a><strong>词汇量不够怎么办</strong></h3><p>当你作为初学者，要在第一天开口说外语时，你的第一反应是：“我还什么词都不会呢！”最初的一对一交流并不需要你说出几千个单词，可能你只需要掌握能够应对两三个问题的单词，感受一下说出这门语言是什么样子就够了。</p><h3 id="最初几小时"><a href="#最初几小时" class="headerlink" title="最初几小时"></a><strong>最初几小时</strong></h3><p>为第一次交谈做准备：</p><ul><li>选择一个正在使用目标语言的人，或是你觉得作为语言联系的搭档也许不错的人。</li><li>社交软件或邮件约一个具体时间。</li><li>通过线上方式用所学语言进行交流。</li></ul><p>几个小时的准备工作：</p><ul><li>可以看一些旅行常用语一类的书。</li><li>通过免费的资源学习一些常用语：<ul><li>How are you?</li><li>What`s your name?</li><li>My name is …</li><li>I don`t understand.</li><li>Could you repeat that / Again, please.</li><li>Can you speak slower please.</li><li>What does that/… mean?</li></ul></li><li>采用关键词记忆法来记住单词或固定词组：<ul><li>Yes、NO</li><li>Please、Thank you</li><li>Hello</li><li>Good Bye</li></ul></li></ul><h3 id="有不会的词就作个小弊"><a href="#有不会的词就作个小弊" class="headerlink" title="有不会的词就作个小弊"></a><strong>有不会的词就作个小弊</strong></h3><p>虽然你的初次对话可能只持续了10秒或20秒，但你可以回归书本或笔记，回想你想说但不会说的内容，把这些短语做成学习卡，然后学会它们。</p><p>你可以随身带一个小本子，列出你想说的内容以及还未掌握好的偏难词汇。</p><h3 id="改变措辞：让交谈简单直接"><a href="#改变措辞：让交谈简单直接" class="headerlink" title="改变措辞：让交谈简单直接"></a><strong>改变措辞：让交谈简单直接</strong></h3><p>初学者会很快学会一件事：<strong>在脑海中用母语组织好想表达的内容，然后再翻译成目标语言</strong>。但如果你想达到真正流利的水准，<strong>这个多余的步骤会把你的速度拖慢很多。</strong>当然作为初学者，这是可以容忍的。</p><p>比如你聊到未来的计划，你本来打算说:”I will travel to Spain in July for a two-week vacation.”。然而你突然意识到你不会用将来时，忘记了”travel to”（去旅行），甚至想不起”July”和”vacation”对应单词。</p><p>如果你是传统型的语言学习者，你应该会放弃了，接受自己还未“准备好”的事实。但执着于交流而不是表达准确性的人会考虑改换措辞，运用其他词汇来传达同样的意思。</p><p>为了省去动词将来时词形变化的烦恼，很多语言都有一个很便捷的特征：动词不定式跟在情态动词之后。比如”want”、”need”、”would like”、”should”、”may”、”can”这样的词的一般现在时形式与”I”连用，如”I want”、”I can”，后面就可以按词典上列出的不定式形式来使用你想用的重要动词”to travel”。想想”I want to travel”和”I will travel”的区别，虽然很重要，但对于表达意思又没那么重要了。你可能不知道”travel”这个词，但可以用”go”来代替。</p><p>所以上述句子可以转换为”I want to go to Spain this summer to be a tourist for two weeks”。</p><h3 id="最初几天"><a href="#最初几天" class="headerlink" title="最初几天"></a><strong>最初几天</strong></h3><p><strong>反馈至关重要。</strong>重复你在以前的谈话中说过的内容，每次都更加自信的说出来。准备你自己的“演讲稿”，在早期这种可预测的模板是可以接受的，当然以后的阶段就不太适用了。</p><h3 id="运用分类体系来管理学到的内容"><a href="#运用分类体系来管理学到的内容" class="headerlink" title="运用分类体系来管理学到的内容"></a><strong>运用分类体系来管理学到的内容</strong></h3><p>致力于语言交流和应试或顺畅阅读的学习者不同，前者所有的努力都指向同一个目标：在下一次会话中表现的更出色一些。</p><p>偶尔回归传统的语言课程，尤其是和一些聚焦口语的课程相比更能满足你自身学习需求的课程。在解决了“说”这个难题后，就可以尽量遵循课程建议进行学习。如果课程中的内容不适合现在的你学习，请跳过它。比如你可能要学习游客常见口语，但对于正在家中自学的你来说并不是最想学的内容，你可能只想问你的对话搭档今天做了什么。</p><h3 id="我不明白对方的回复"><a href="#我不明白对方的回复" class="headerlink" title="我不明白对方的回复"></a><strong>我不明白对方的回复</strong></h3><p>早期交流中，你听到的大部分内容似乎都是难以理解的。完全的理解整段话语内容在早期阶段并不合适，提取别人讲话中你能听懂的词汇或片段，由此推断对方在说什么。</p><p>不要抱定“我不懂”的想法不放，根据语境去猜测对方的内容，并进行合理的回复。</p><h3 id="作者的两小时波兰语经历"><a href="#作者的两小时波兰语经历" class="headerlink" title="作者的两小时波兰语经历"></a><strong>作者的两小时波兰语经历</strong></h3><p>作者曾因要做演讲而进行过一次两个小时的波兰语Skype学习：</p><ul><li>使用常用语手册学习一些初次会话的基础词汇：<ul><li>“I just started learning Polish”</li><li>“I am going to Poland soon”</li></ul></li><li>用电子词典查好交流要用的词汇。</li><li>在屏幕上打开一个文本文档，在上面记录可能记不住的词，准备几十个这样的词。</li><li>当对方说出一个你不会的词时，请他在聊天窗口打出来，复制下来并抽空学习。</li></ul><p>在这次半个小时的对话中，作者坚持一直使用波兰语，虽然很多次弄不懂对方说什么，自己也说不出一些简单的内容，这种不完美的感觉会一直伴随着学习的过程。</p><p>建议用两周的时间来学习一下世界语，有研究表明学习一年世界语再学一年法语的学生比直接学习两年法语的学生更有优势。</p><p>世界语的设计很简单，可以让你在很短的时间掌握好它，克服了第一门外语的难关后，你再次学习其他外语会简单很多。</p><h3 id="尽早开始全程目标语交流"><a href="#尽早开始全程目标语交流" class="headerlink" title="尽早开始全程目标语交流"></a><strong>尽早开始全程目标语交流</strong></h3><p>传统的学习方法会用你的母语教你这门语言怎么运作，整个学习过程你都在仔细的剖析目标语的语法和词汇。语言作为交流的手段，从一开始就应该是被使用的。</p><p><strong>你需要培养用目标语思考的习惯。</strong></p><p>在会话中使用其他语言只会拖慢你前进的步伐，关键就是要尽早下定决心，只要你能容忍较长的停顿和不断的查找单词，即使从第一天开口对话也是能做到的。</p><h3 id="对方用你的母语回复怎么办"><a href="#对方用你的母语回复怎么办" class="headerlink" title="对方用你的母语回复怎么办"></a><strong>对方用你的母语回复怎么办</strong></h3><p>好的老师或拍档应该只把母语最终手段来使用，请尽可能用一些手段来作为回报，让对方能尽量使用目标语来对话，指出你是为了学习这门语言而在努力，如果无法得到好的结果，就选择和其他人交谈吧。</p><h3 id="杰克-·-斯帕罗法则：避免因迟疑而耗费时间"><a href="#杰克-·-斯帕罗法则：避免因迟疑而耗费时间" class="headerlink" title="杰克 · 斯帕罗法则：避免因迟疑而耗费时间"></a><strong>杰克 · 斯帕罗法则：避免因迟疑而耗费时间</strong></h3><p>初学者要面临的一个问题是，你在刚开始对话时只会“嗯嗯啊啊”而不得不中止交谈，这很尴尬。早期对话中，犹豫和迟疑是不可避免的，但我们可以用一些小技巧让这些时刻变得不那么紧张和尴尬。</p><p>在《加勒比海盗》中，杰克 · 斯帕罗船长的肢体语言十分丰富，即使不说话也依然生动鲜活。这种方法可以用来保持对方的注意力，比如你想说”I want to go to the supermarket”，当你说道”go to”时你发现你忘记了超市怎么说，你需要一些时间来想想。这个时候你可以看着对方的眼睛，吸引他的全部注意，然后举起食指指向远方，并且面带沉思的凝望所指向的方向。这时你可以说你想去机场、沙漠……只要稍微练习，你可以把这些停顿运用的更加自然。</p><h3 id="碰杯法则：抛开害羞的想法"><a href="#碰杯法则：抛开害羞的想法" class="headerlink" title="碰杯法则：抛开害羞的想法"></a><strong>碰杯法则：抛开害羞的想法</strong></h3><p>碰杯法则——抛开我很害羞的想法，只要接近那个人跟他问好就是了。</p><h3 id="参与即理解"><a href="#参与即理解" class="headerlink" title="参与即理解"></a><strong>参与即理解</strong></h3><blockquote><p><strong>不闻不若闻之，闻之不若见之，见之不若知之，知之不若行之。学至于行而止矣。</strong></p><p>​                                                                                            ——中国谚语</p></blockquote><hr><p>内容来源：</p><blockquote><p>《跟各国人都聊得来-三个月外语流利术》</p></blockquote><p><em>若内容涉及侵权请及时告知，我会尽快修改和删除相关内容</em></p>]]></content>
    
    <summary type="html">
    
      从零开始学习英语，内容来自于《跟各国人都聊得来-三个月外语流利术》和自我感受。
    
    </summary>
    
      <category term="学习语言" scheme="http://linyishui.top/categories/%E5%AD%A6%E4%B9%A0%E8%AF%AD%E8%A8%80/"/>
    
    
      <category term="language" scheme="http://linyishui.top/tags/language/"/>
    
      <category term="english" scheme="http://linyishui.top/tags/english/"/>
    
  </entry>
  
  <entry>
    <title>从零开始学习英语（三）如何记单词</title>
    <link href="http://linyishui.top/2020090502.html"/>
    <id>http://linyishui.top/2020090502.html</id>
    <published>2020-09-05T10:03:08.000Z</published>
    <updated>2020-09-05T13:18:33.044Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="如何快速记住上千个单词"><a href="#如何快速记住上千个单词" class="headerlink" title="如何快速记住上千个单词"></a><strong>如何快速记住上千个单词</strong></h1><h3 id="为什么我们在学校学到的记忆方法不起作用"><a href="#为什么我们在学校学到的记忆方法不起作用" class="headerlink" title="为什么我们在学校学到的记忆方法不起作用"></a><strong>为什么我们在学校学到的记忆方法不起作用</strong></h3><p>如今我们有了越来越多的信息来源，很多人不再学习、背诵任何东西，因为随时可以Google到。这种情况很令人遗憾，因为我们没有发挥自己大脑的最大潜力。</p><p><strong>信息的重复出现让我们以为自己已经记住了它。</strong>我们在学校时，为了学会一个单词唯一的方法就是死记硬背。经过几十次甚至几百次的重复，你可能会在短期记住它，但能否运用就看运气了。</p><p><strong>与其简单的读出或识别出单词，不如尝试更有效的学习方法。</strong></p><h3 id="两种优秀的记忆方法"><a href="#两种优秀的记忆方法" class="headerlink" title="两种优秀的记忆方法"></a><strong>两种优秀的记忆方法</strong></h3><h4 id="方法一：关键字联想记忆法"><a href="#方法一：关键字联想记忆法" class="headerlink" title="方法一：关键字联想记忆法"></a><strong>方法一：关键字联想记忆法</strong></h4><p>当你要记忆一个单词或句子时，需要构建一个有趣的、栩栩如生的、令人难忘的画面或小故事。</p><p><strong>请自己从认识这个词语的第一印象开始，根据读音想象一个场景或故事。</strong></p><p>刚开始可能每个单词都要花费一两分钟来构思故事，但几天或一周后，你会变得熟练起来。而在三四次回想起故事后，你就可以牢牢记住这个词，以后就可以直接知道其含义。</p><h4 id="方法二：间隔重复记忆法"><a href="#方法二：间隔重复记忆法" class="headerlink" title="方法二：间隔重复记忆法"></a><strong>方法二：间隔重复记忆法</strong></h4><p><strong>通过单词卡和词组卡重新排列来辅助记忆。</strong>将记不住的单词排到前面，已知的单词排在后面。目前很多主流的APP都支持这种记忆法。</p><h3 id="用音乐来学习词组和整句"><a href="#用音乐来学习词组和整句" class="headerlink" title="用音乐来学习词组和整句"></a><strong>用音乐来学习词组和整句</strong></h3><p><strong>从词组和整句来开始学习语言可能效果会比从单词开始要更好。</strong>多使用如“厕所在哪里”、“这个多少钱”这样的常用句子。</p><p>记住这些句子并不容易，几百年来，人们常常通过唱歌来背诵文章。首先可以把句子和关键字记忆法结合，在短句的开头来启发记忆。其次，我们要相处适合的曲调来启发记忆，曲调要简洁，就像大本钟的钟声一样。记住想象越离奇，越有利于记忆。</p><h3 id="1分钟迷你讲话稿"><a href="#1分钟迷你讲话稿" class="headerlink" title="1分钟迷你讲话稿"></a><strong>1分钟迷你讲话稿</strong></h3><p>我们了解了怎样记住单词和词组，接下来就是更难的内容——记住整段文字。</p><p>请准备好陌生人见面的几个基本问题的答案：</p><ol><li>你是哪位？</li><li>你从哪里来？</li><li>你做什么工作？</li><li>你为什么要学这种语言？</li></ol><p>你可以用母语写好稿子，拜托一位以所学语言为母语的人帮忙准确的翻译它，或者从书上或网上找到地道的表述，请不要背电脑翻译或自己翻译的句子。</p><p>为每个问题都准备一张卡片，并用记忆法记住每个句子开头的单词和音节，再为每个句子找到一个调子或歌曲。</p><h3 id="单词就是你的武器"><a href="#单词就是你的武器" class="headerlink" title="单词就是你的武器"></a><strong>单词就是你的武器</strong></h3><blockquote><p><strong>不求与人相比，只求突破自己。</strong></p><p>​                                                ——嘉纳治五郎，柔道创始人</p></blockquote><p>学习语言的每一天，你的词汇量都在增加，同时你的沟通能力也会得到提升。</p><hr><p>内容来源：</p><blockquote><p>《跟各国人都聊得来-三个月外语流利术》</p></blockquote><p><em>若内容涉及侵权请及时告知，我会尽快修改和删除相关内容</em></p>]]></content>
    
    <summary type="html">
    
      从零开始学习英语，内容来自于《跟各国人都聊得来-三个月外语流利术》和自我感受。
    
    </summary>
    
      <category term="学习语言" scheme="http://linyishui.top/categories/%E5%AD%A6%E4%B9%A0%E8%AF%AD%E8%A8%80/"/>
    
    
      <category term="language" scheme="http://linyishui.top/tags/language/"/>
    
      <category term="english" scheme="http://linyishui.top/tags/english/"/>
    
  </entry>
  
  <entry>
    <title>从零开始学习英语（二）计划</title>
    <link href="http://linyishui.top/2020090501.html"/>
    <id>http://linyishui.top/2020090501.html</id>
    <published>2020-09-05T09:02:28.000Z</published>
    <updated>2020-09-05T13:16:28.061Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="计划"><a href="#计划" class="headerlink" title="计划"></a><strong>计划</strong></h1><h3 id="设定一个具体化的目标"><a href="#设定一个具体化的目标" class="headerlink" title="设定一个具体化的目标"></a><strong>设定一个具体化的目标</strong></h3><p><strong>如何定义“流利”这个词语？</strong>牛津字典上的定义：流利，形容词，可准确、自如地表达自己的想法。</p><p>请不要错误的把目标定位外语要达到母语的水平。欧洲几个主要的语言测试组织所使用的一套科学、成熟的语言入门标准——《欧洲共同语言参考标准》（Common European Framework of Reference for Languages，CEFRL系统）定义了三个等级：“A”表示初级水平，“B”表示中级，“C”代表高级。每个等级又分“1”（较差）和“2”（较好）两种程度。</p><p>A级水平就是常说的具有基本语言能力的游客水平，可以进行基础的对话交流。C级水平意味着已经掌握了这门语言，能够达到母语使用者的水平。</p><p><strong>我们将B2及以上的水平定位为流利，能够流利地、自然地以该种语言为母语的人经常进行交流，对于双方而言，这种交流都毫无阻碍。</strong></p><h3 id="达到流利需要多长时间"><a href="#达到流利需要多长时间" class="headerlink" title="达到流利需要多长时间"></a><strong>达到流利需要多长时间</strong></h3><p>作者推荐是3个月内先达到基本对话的水平（B1），高强度的语言学习计划需要绝对的集中和专心，即使你是全职工作，也要挤出时间，每天学几小时。<strong>如果你想要迅速的进步，每天至少两个小时的语言学习是必不可少的。</strong>如果你只能每周投入几个小时，那你没有可能在3个月就掌握流利的外语。</p><p>即使你的期限不是3个月、6个月，也请尽量将一年分成更小的、更可控的多个时间段。</p><h3 id="总是朝着更高一级的目标努力"><a href="#总是朝着更高一级的目标努力" class="headerlink" title="总是朝着更高一级的目标努力"></a><strong>总是朝着更高一级的目标努力</strong></h3><p>只要能和其他人交流，你的语言学习就不算失败。但是，<strong>注意不要用“任何一个小进步都是成功”来纵容自己的懒惰。一定要把自己推出“舒适地带”，如果你设定的目标是你百分百能达到的，说明你的目标还是太低了。</strong></p><h3 id="迷你任务：逼自己离开舒适区"><a href="#迷你任务：逼自己离开舒适区" class="headerlink" title="迷你任务：逼自己离开舒适区"></a><strong>迷你任务：逼自己离开舒适区</strong></h3><p>在语言学习的某个特定时期，你会遇到一些具体问题，“迷你任务”可以帮你尽快解决它们。</p><p>在作者刚开始学汉语时，因为语调不对，别人完全不能听懂他的话。所以他只关注语调，不去管词汇和阅读等问题。一周后，人们可以稍微听懂他的一点话了，之后才开始了基本词汇的学习。</p><p>第二周，作者最大的问题是过度依赖词汇书，所以练习自发的说话变成了迷你任务。很快他也能不看书的去说一些词汇了。</p><p>这种迷你任务可以给你一种真实的、辛苦得来的成就感和进步感，使你集中精力应对问题直到解决它们。比如作者学习汉语时没有给自己设定每周的词汇任务，而是每天看60张词汇卡片，卡片上的词汇都是关于怎样点菜的。</p><p>一个月后，作者达到了瓶颈期，可以凭借记忆进行简单的交谈，语调也还可以。但这些交谈只能持续10~15秒，不算是真正的交谈。所以他开始一个新的迷你任务——提升思维速度的“大脑融合”。“大脑融合”强迫你快速思维，根据听到的信息进行推断、搜索词汇的意思，同时根据语境来理解语言的含义。所以他约了汉语母语的朋友来进行一个小时以上的对话。</p><p>迷你任务的目的就是逼迫自己离开舒适区，从而不断升级、挺过艰难的学习阶段。</p><h3 id="倦怠是放弃语言学习的主要原因之一"><a href="#倦怠是放弃语言学习的主要原因之一" class="headerlink" title="倦怠是放弃语言学习的主要原因之一"></a><strong>倦怠是放弃语言学习的主要原因之一</strong></h3><p>如果整个学习过程都充满了“大脑融合”任务，你可能很快会倦怠。适当的休息，在这段时间忘记语言学习，可能会有效的帮助到你。</p><h3 id="制订行动计划"><a href="#制订行动计划" class="headerlink" title="制订行动计划"></a><strong>制订行动计划</strong></h3><p>没有付诸实践，任何好主意都一文不值。请记住以下几点：</p><ul><li>设定稍高的目标。</li><li>设定具体的期限。</li><li>集中学习语言时，使用迷你任务去专注解决眼前的最大问题。</li><li>如果你的全部时间都用来学习，就要保证休息，不要把自己搞得精疲力竭。</li><li>向外界展示你的学习任务，让朋友和家人监督你。</li></ul><h3 id="我的计划"><a href="#我的计划" class="headerlink" title="我的计划"></a><strong>我的计划</strong></h3><p>因为我最近刚好处于择业期，而且技术上有很多短板需要补齐，所以主要学习内容还是专业技术，语言则作为另一项同时进行的学习任务。</p><p><strong>我会把学习周期定为6个月，每天一个小时的语言学习时间。</strong>也就是明年3到4月份验收成果。</p><hr><p>内容来源：</p><blockquote><p>《跟各国人都聊得来-三个月外语流利术》</p></blockquote><p><em>若内容涉及侵权请及时告知，我会尽快修改和删除相关内容</em></p>]]></content>
    
    <summary type="html">
    
      从零开始学习英语，内容来自于《跟各国人都聊得来-三个月外语流利术》和自我感受。
    
    </summary>
    
      <category term="学习语言" scheme="http://linyishui.top/categories/%E5%AD%A6%E4%B9%A0%E8%AF%AD%E8%A8%80/"/>
    
    
      <category term="language" scheme="http://linyishui.top/tags/language/"/>
    
      <category term="english" scheme="http://linyishui.top/tags/english/"/>
    
  </entry>
  
  <entry>
    <title>职业规划</title>
    <link href="http://linyishui.top/2020090401.html"/>
    <id>http://linyishui.top/2020090401.html</id>
    <published>2020-09-04T06:28:26.000Z</published>
    <updated>2020-09-04T08:05:56.473Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="职业规划"><a href="#职业规划" class="headerlink" title="职业规划"></a><strong>职业规划</strong></h1><h2 id="岗位选择"><a href="#岗位选择" class="headerlink" title="岗位选择"></a><strong>岗位选择</strong></h2><p>目前情况：Java后端开发，2年工作经验。</p><p>一年后：Java后端 / 大数据开发 ，3年工作经验</p><h2 id="设定目标"><a href="#设定目标" class="headerlink" title="设定目标"></a><strong>设定目标</strong></h2><p>统计岗位薪酬数据：</p><table><thead><tr><th>Java</th><th>北京</th><th>上海</th><th>杭州</th></tr></thead><tbody><tr><td>1-3年年收入-10分位</td><td>79.948</td><td>76.488</td><td>71.014</td></tr><tr><td>1-3年年收入-25分位</td><td>106.167</td><td>100.479</td><td>94.989</td></tr><tr><td>1-3年年收入-50分位</td><td>146.831</td><td>137.871</td><td>130.364</td></tr><tr><td>1-3年年收入-75分位</td><td>208.853</td><td>186.494</td><td>181.281</td></tr><tr><td>1-3年年收入-90分位</td><td>287.424</td><td>251.109</td><td>247.048</td></tr><tr><td>1-3年月平均收入和人数占比</td><td>13.904/19%</td><td>12.900/22%</td><td>12.608/32%</td></tr><tr><td>3-5年月平均收入和人数占比</td><td>18.544/56%</td><td>17.661/56%</td><td>18.103/55%</td></tr><tr><td>5-10年月平均收入和人数占比</td><td>25.207/24%</td><td>24.766/21%</td><td>24.068/12%</td></tr><tr><td>人数样本</td><td>4162601</td><td>2270467</td><td>1604825</td></tr></tbody></table><p><em>数据来源：Boss直聘</em></p><p>设定岗位筛选条件：3-5年经验，20k以上。</p><h2 id="统计要求"><a href="#统计要求" class="headerlink" title="统计要求"></a><strong>统计要求</strong></h2><table><thead><tr><th>要求</th><th>子项</th><th>掌握程度</th><th>次数</th></tr></thead><tbody><tr><td>工龄</td><td>3年</td><td></td><td>12</td></tr><tr><td>学历</td><td>本科</td><td></td><td>7</td></tr><tr><td>Java</td><td>基础</td><td>基础扎实，JDK源码，多态</td><td>11</td></tr><tr><td></td><td>IO</td><td></td><td>5</td></tr><tr><td></td><td>并发/多线程</td><td></td><td>6</td></tr><tr><td></td><td>集合</td><td></td><td>4</td></tr><tr><td></td><td>JVM</td><td>了解原理</td><td>5</td></tr><tr><td></td><td>网络编程</td><td></td><td>2</td></tr><tr><td>Web框架</td><td>Web开发</td><td>深入了解底层实现</td><td>9</td></tr><tr><td></td><td>Spring</td><td></td><td>8</td></tr><tr><td></td><td>SpringMVC</td><td></td><td>2</td></tr><tr><td></td><td>SpringBoot</td><td></td><td>5</td></tr><tr><td>ORM</td><td>Mybatis</td><td>深入了解底层实现</td><td>7</td></tr><tr><td>数据库</td><td>任一</td><td>熟悉数据库优化</td><td>10</td></tr><tr><td></td><td>Mysql</td><td></td><td>8</td></tr><tr><td></td><td>Oracle</td><td></td><td>4</td></tr><tr><td></td><td>db2</td><td></td><td>2</td></tr><tr><td></td><td>sql优化</td><td></td><td>1</td></tr><tr><td>分布式系统</td><td>项目</td><td>熟悉设计和应用</td><td>6</td></tr><tr><td></td><td>监控、部署</td><td></td><td>1</td></tr><tr><td></td><td>负载均衡</td><td></td><td>1</td></tr><tr><td>分布式缓存</td><td>任一</td><td>熟练使用，优化</td><td>9</td></tr><tr><td></td><td>Redis</td><td></td><td>6</td></tr><tr><td></td><td>Memcache</td><td></td><td>2</td></tr><tr><td></td><td>MongoDB</td><td></td><td>2</td></tr><tr><td></td><td>Hbase</td><td></td><td>1</td></tr><tr><td>消息队列</td><td>任一</td><td>熟悉解决方案及应用场景</td><td>9</td></tr><tr><td></td><td>RabbitMQ</td><td></td><td>4</td></tr><tr><td></td><td>ActiveMQ</td><td></td><td>1</td></tr><tr><td></td><td>Kafka</td><td></td><td>2</td></tr><tr><td>Web服务器</td><td>Nginx</td><td>优化配置与使用</td><td>2</td></tr><tr><td></td><td>Tomcat</td><td></td><td>2</td></tr><tr><td></td><td>缓存服务器</td><td></td><td>1</td></tr><tr><td>中间件</td><td>Elasticsearch</td><td>使用和原理</td><td>1</td></tr><tr><td>UML</td><td></td><td>熟悉</td><td>1</td></tr><tr><td>设计模式</td><td></td><td>了解</td><td>1</td></tr><tr><td>微服务</td><td>任一</td><td></td><td>5</td></tr><tr><td></td><td>Dubbo</td><td></td><td>3</td></tr><tr><td></td><td>Spring Cloud</td><td></td><td>2</td></tr><tr><td>工具</td><td>Docker</td><td>熟练掌握</td><td>1</td></tr><tr><td></td><td>K8s</td><td></td><td>1</td></tr><tr><td></td><td>Linux</td><td>熟悉操作，有Linux环境下多线程、并发、网络编程经验，常用命令</td><td>2</td></tr><tr><td>脚本语言</td><td>任一</td><td>熟悉</td><td>2</td></tr><tr><td></td><td>shell</td><td></td><td>2</td></tr><tr><td></td><td>php</td><td></td><td>1</td></tr><tr><td></td><td>python</td><td></td><td>1</td></tr><tr><td>前端</td><td>JS</td><td></td><td>2</td></tr><tr><td></td><td>Jquery</td><td></td><td>2</td></tr><tr><td></td><td>VUE</td><td></td><td>2</td></tr><tr><td>网络</td><td>基础</td><td></td><td>1</td></tr><tr><td></td><td>TCP/IP</td><td>原理</td><td>1</td></tr><tr><td>开源项目</td><td></td><td>有经验</td><td>2</td></tr><tr><td>高并发、高负载、高可用</td><td></td><td>设计和开发，优先</td><td>7</td></tr><tr><td>分布式队列</td><td></td><td>优先</td><td>1</td></tr><tr><td>分布式任务分发框架</td><td></td><td>优先</td><td>1</td></tr><tr><td>全文检索及分词</td><td></td><td>优先</td><td>1</td></tr><tr><td>海量数据存储和处理</td><td></td><td>优先</td><td>4</td></tr><tr><td>分布式存储</td><td></td><td>优先</td><td>1</td></tr><tr><td>Flink、Clickhouse</td><td></td><td>优先</td><td>1</td></tr><tr><td>Java EE、SOA、OSGI、jax-rs</td><td></td><td>熟悉相关技术</td><td>1</td></tr></tbody></table><h2 id="简单规划"><a href="#简单规划" class="headerlink" title="简单规划"></a><strong>简单规划</strong></h2><p>根据岗位要求进行简单规划，先学陌生的技术，再补不足。</p><p>需要学会和精通的技术：</p><ul><li>Java、集合、多线程、并发编程、网络编程、JVM、IO、NIO</li><li>Spring、Spring MVC、Spring Boot</li><li>MyBatis、MySql、Redis、RabbitMQ、ELK</li><li>Dubbo、Zookeeper 、Spring Cloud</li><li>Linux、Docker、k8s、shell</li><li>网络、操作系统、分布式系统、海量数据处理</li></ul><p>将以上内容补充到《<a href="../2018080801.html" title="Title">Java技术栈-学习路线</a>》。</p><p>最后罗列一下学习的优先级：</p><ul><li><p>需要系统学习：Mysql -&gt; RabbitMQ -&gt; Zookeeper + Dubbo -&gt; Spring Cloud -&gt; Redis</p></li><li><p>只要实战学习：MyBatis -&gt; ELK -&gt; Linux + shell -&gt; Docker -&gt; k8s</p></li></ul>]]></content>
    
    <summary type="html">
    
      简单整理一下Java职场信息，为自己设定一个一年后的目标。
    
    </summary>
    
      <category term="笔记杂谈" scheme="http://linyishui.top/categories/%E7%AC%94%E8%AE%B0%E6%9D%82%E8%B0%88/"/>
    
    
      <category term="java" scheme="http://linyishui.top/tags/java/"/>
    
      <category term="other" scheme="http://linyishui.top/tags/other/"/>
    
  </entry>
  
  <entry>
    <title>从零开始学习dubbo（一）简介和搭建</title>
    <link href="http://linyishui.top/2020090301.html"/>
    <id>http://linyishui.top/2020090301.html</id>
    <published>2020-09-03T06:12:39.000Z</published>
    <updated>2020-09-08T09:47:43.128Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="dubbo（一）简介和搭建"><a href="#dubbo（一）简介和搭建" class="headerlink" title="dubbo（一）简介和搭建"></a><strong>dubbo（一）简介和搭建</strong></h1><h2 id="第一节-概述"><a href="#第一节-概述" class="headerlink" title="第一节 概述"></a><strong>第一节 概述</strong></h2><h3 id="1-1-背景"><a href="#1-1-背景" class="headerlink" title="1.1 背景"></a><strong>1.1 背景</strong></h3><p>网站规模的扩大，技术架构经历了从<strong>单一应用架构</strong>到<strong>垂直应用架构</strong>，最后到<strong>分布式服务架构</strong>和<strong>流动计算架构</strong>的发展历程。</p><p><img src="http://dubbo.apache.org/docs/zh-cn/user/sources/images/dubbo-architecture-roadmap.jpg" alt></p><ul><li><strong>单一应用架构</strong>：当网站流量很小时，只需一个应用，将所有功能都部署在一起，以减少部署节点和成本。此时，用于简化增删改查工作量的数据访问框架(ORM)是关键。<ul><li>适合小型网站，小型管理系统，将所有功能都部署到一个功能里，简单易用。</li><li>缺点：<ul><li>性能扩展比较难</li><li>协同开发问题</li><li>不利于升级维护</li></ul></li></ul></li><li><strong>垂直应用架构</strong>：当访问量逐渐增大，单一应用增加机器带来的加速度越来越小，将应用拆成互不相干的几个应用，以提升效率。此时，用于加速前端页面开发的Web框架(MVC)是关键。<ul><li>通过切分业务来实现各个模块独立部署，降低了维护和部署的难度，团队各司其职更易管理，性能扩展也更方便，更有针对性。</li><li>缺点： 公用模块无法重复利用，开发性的浪费。</li></ul></li><li><strong>分布式服务架构</strong>：当垂直应用越来越多，应用之间交互不可避免，将核心业务抽取出来，作为独立的服务，逐渐形成稳定的服务中心，使前端应用能更快速的响应多变的市场需求。此时，用于提高业务复用及整合的<strong>分布式服务框架</strong>(RPC)是关键。</li><li><strong>流动计算架构</strong>：当服务越来越多，容量的评估，小服务资源的浪费等问题逐渐显现，此时需增加一个调度中心基于访问压力实时管理集群容量，提高集群利用率。此时，用于<strong>提高机器利用率的资源调度和治理中心(SOA)[ Service Oriented Architecture]是关键</strong>。</li></ul><p>分布式系统中每个功能模块之间有复杂的联系，需要有一个<strong>治理系统</strong>确保架构有条不紊的演进。</p><h3 id="1-2-RPC和RMI"><a href="#1-2-RPC和RMI" class="headerlink" title="1.2 RPC和RMI"></a><strong>1.2 RPC和RMI</strong></h3><p>RPC是指Remote Procedure Call Protocol，<strong>远程过程调用协议</strong>，是一种进程间通信方式。它是一种通过网络从远程计算机程序上请求服务，而不需要了解底层网络技术的协议。</p><p>常见的开源框架包括：</p><ul><li><p>单语言：</p><ul><li><p><strong>RMI</strong>：Java RMI （Remote Method Invocation）- 远程方法调用，基于Java远程方法协议(Java Remote Method Protocol) 和java的原生序列化，能够<strong>让客户端像使用本地调用一样调用服务端 Java 虚拟机中的对象方法</strong>。RMI 是面向对象语言领域对 RPC （Remote Procedure Call）的完善，用户无需依靠 IDL 的帮助来完成分布式调用，而是通过<strong>依赖接口</strong>这种更简单自然的方式。</p></li><li><p><strong>Dubbo</strong>：阿里巴巴开发，只支持Java。</p></li><li><strong>Motan</strong>：微博开发，只支持Java。</li><li><strong>Tars</strong>：腾讯开发，只支持C++。</li><li><strong>Spring Cloud</strong>：Pivotal开发，只支持Java。</li></ul></li><li><p>跨语言：</p><ul><li><p><strong>gRPC</strong>：Google开发。</p></li><li><p><strong>Thrift</strong>：Facebook开发，它通过一个代码生成引擎联合了一个软件栈，来创建不同程度的、无缝的<a href="https://zh.wikipedia.org/wiki/跨平台" target="_blank" rel="noopener">跨平台</a>高效服务。以前是由Facebook开发的，但它现在是<a href="https://zh.wikipedia.org/wiki/Apache软件基金会" target="_blank" rel="noopener">Apache软件基金会</a>的开源项目了。</p></li><li><p><strong>Avro</strong>：一种远程过程调用和数据序列化框架，是在Apache的Hadoop项目之内开发的。它使用JSON来定义数据类型和通讯协议，使用压缩二进制格式来序列化数据。它主要用于Hadoop，它可以为持久化数据提供一种序列化格式，并为Hadoop节点间及从客户端程序到Hadoop服务的通讯提供一种电报格式。</p><p>它类似于Thrift，但当数据库模式改变时，它不要求运行代码生成程序，除非是对静态类型的语言。</p></li></ul></li></ul><h4 id="（1）RMI工作原理"><a href="#（1）RMI工作原理" class="headerlink" title="（1）RMI工作原理"></a><strong>（1）RMI工作原理</strong></h4><ol><li>服务端向 RMI 注册服务绑定自己的地址，</li><li>客户端通过 RMI 注册服务获取目标地址，</li><li>客户端调用本地的 Stub 对象上的方法，和调用本地对象上的方法一致，</li><li>本地存根对象将调用信息打包，通过网络发送到服务端，</li><li>服务端的 Skeleton 对象收到网络请求之后，将调用信息解包，</li><li>然后找到真正的服务对象发起调用，并将返回结果打包通过网络发送回客户端。</li></ol><p>服务之间的远程调用有两个关键部分：</p><ul><li>服务间通信：客户端与服务端要建立网络连接，并传递数据。所以通信效率决定着RPC框架的性能（如传递二进制流要快于XML或JSON）</li><li>对象序列化与反序列化：参数对象在网络中传递要进行序列化，接收到后要反序列化解析。所以序列化效率也决定着RPC框架的性能。</li></ul><h4 id="（2）RMI基本概念"><a href="#（2）RMI基本概念" class="headerlink" title="（2）RMI基本概念"></a><strong>（2）RMI基本概念</strong></h4><ol><li>通过<strong>接口</strong>进行远程调用：客户端需要依赖接口，而服务端需要提供该接口的实现。</li><li>通过客户端的 <strong>Stub 对象</strong>和服务端的 <strong>Skeleton 对象</strong>的帮助将远程调用伪装成本地调用：在 J2SE 1.5 版本之前需要通过 rmic 预先编译好客户端的 Stub 对象和服务端的 Skeleton 对象。在之后的版本中，不再需要事先生成 Stub 和 Skeleton 对象。</li><li>通过 <strong>RMI 注册服务</strong>完成服务的注册和发现。</li></ol><p>服务端注册方式如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 初始化服务对象实例</span></span><br><span class="line">Hello obj = <span class="keyword">new</span> HelloImpl(); </span><br><span class="line"><span class="comment">// 生成可以与服务端通讯的 Stub 对象</span></span><br><span class="line">Hello stub = (Hello) UnicastRemoteObject.exportObject(obj, <span class="number">0</span>); </span><br><span class="line"><span class="comment">// 创建一个本地的 RMI 注册服务，监听端口为 1099。该注册服务运行在服务端，也可以单独启动一个注册服务的进程</span></span><br><span class="line">Registry registry = LocateRegistry.createRegistry(<span class="number">1099</span>); </span><br><span class="line"><span class="comment">// 将 Stub 对象绑定到注册服务上，这样，客户端可以通过 *Hello* 这个名字查找到该远程对象</span></span><br><span class="line">registry.rebind(<span class="string">"Hello"</span>, stub);</span><br></pre></td></tr></table></figure><p>客户端的服务发现如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 获取注册服务实例，在本例中，由于没有传入任何参数，假定要获取的注册服务实例部署在本机，并监听在 1099 端口上</span></span><br><span class="line">Registry registry = LocateRegistry.getRegistry();</span><br><span class="line"><span class="comment">// 从注册服务中查找服务名为 *Hello* 的远程对象</span></span><br><span class="line">Hello stub = (Hello) registry.lookup(<span class="string">"Hello"</span>);</span><br><span class="line"><span class="comment">// 通过获取的 Stub 对象发起一次 RMI 调用并获得结果</span></span><br><span class="line">String response = stub.sayHello();</span><br></pre></td></tr></table></figure><h3 id="1-3-为什么需要Dubbo？"><a href="#1-3-为什么需要Dubbo？" class="headerlink" title="1.3 为什么需要Dubbo？"></a><strong>1.3 为什么需要Dubbo？</strong></h3><p>在大规模服务化之前，应用可能只是通过 RMI 或 Hessian 等工具，简单的暴露和引用远程服务，通过配置服务的URL地址进行调用，通过 F5 等硬件进行负载均衡。</p><p><strong>当服务越来越多时，服务 URL 配置管理变得非常困难，F5 硬件负载均衡器的单点压力也越来越大。</strong> 此时<strong>需要一个服务注册中心（Eureka、Zookeeper），动态地注册和发现服务，使服务的位置透明</strong>。并通过在消费方获取服务提供方地址列表，实现软负载均衡和 Failover，降低对 F5 硬件负载均衡器的依赖，也能减少部分成本。</p><p><strong>当进一步发展，服务间依赖关系变得错踪复杂，甚至分不清哪个应用要在哪个应用之前启动，架构师都不能完整的描述应用的架构关系。</strong> 这时，需要自动画出应用间的依赖关系图，以帮助架构师理清关系。</p><p><strong>接着，服务的调用量越来越大，服务的容量问题就暴露出来，这个服务需要多少机器支撑？什么时候该加机器？</strong> 为了解决这些问题，第一步，要将服务现在每天的调用量，响应时间，都统计出来，作为容量规划的参考指标。其次，要可以动态调整权重，在线上，将某台机器的权重一直加大，并在加大的过程中记录响应时间的变化，直到响应时间到达阈值，记录此时的访问量，再以此访问量乘以机器数反推总容量。</p><p><img src="http://dubbo.apache.org/docs/zh-cn/user/sources/images/dubbo-service-governance.jpg" alt></p><p>dubbo的核心特性：</p><ul><li><strong>远程方法调用</strong>：面向接口代理的高性能RPC调用，使用时只需调用接口即可。</li><li><strong>智能负载均衡</strong>：同一个服务可能有多台服务器在运行，每台服务器有不同的工作状态，负载均衡会尽量的挑选休闲的服务器。</li><li><strong>服务自动注册和发现</strong>：所有服务都要注册到中心，中心负责管理所有服务的生命周期，服务部署在哪些服务器这些信息可以在中心获取。</li><li><strong>高度可扩展</strong>：遵循微内核和插件的设计原则，核心功能如Protocol、Transport、Serialization都被设计为扩展点，同等对待内置实现和第三方实现。</li><li><strong>运行期流量调度</strong>：内置条件、脚本等路由策略，通过配置不同的路由规则，实现灰度发布、同机房优先等功能。</li><li><strong>可视化的服务治理与运维</strong>：提供丰富的服务治理、运维工具：随时查询服务元数据、服务健康状态以及调用统计，实时下发路由策略、调整配置参数。</li></ul><h3 id="1-4-技术架构"><a href="#1-4-技术架构" class="headerlink" title="1.4 技术架构"></a><strong>1.4 技术架构</strong></h3><p>如下图所示，每个节点角色之间的关系，注意只有消费者调用服务是同步，其他都是异步操作。</p><p><img src="http://dubbo.apache.org/docs/zh-cn/user/sources/images/dubbo-architecture.jpg" alt="dubbo-architucture"></p><h5 id="节点角色说明"><a href="#节点角色说明" class="headerlink" title="节点角色说明"></a>节点角色说明</h5><table><thead><tr><th>节点</th><th>角色说明</th></tr></thead><tbody><tr><td><code>Provider</code></td><td>暴露服务的<strong>服务提供方</strong></td></tr><tr><td><code>Consumer</code></td><td>调用远程服务的<strong>服务消费方</strong></td></tr><tr><td><code>Registry</code></td><td>服务注册与发现的<strong>注册中心</strong></td></tr><tr><td><code>Monitor</code></td><td>统计服务的调用次数和调用时间的<strong>监控中心</strong></td></tr><tr><td><code>Container</code></td><td><strong>服务运行容器</strong></td></tr></tbody></table><h5 id="调用关系说明"><a href="#调用关系说明" class="headerlink" title="调用关系说明"></a>调用关系说明</h5><ol><li>服务容器负责启动，加载，运行服务提供者。</li><li>服务提供者在启动时，向注册中心注册自己提供的服务。</li><li>服务消费者在启动时，向注册中心订阅自己所需的服务。</li><li>注册中心返回服务提供者地址列表给消费者，如果有变更，注册中心将基于长连接推送变更数据给消费者。</li><li>服务消费者，从提供者地址列表中，基于软负载均衡算法，选一台提供者进行调用，如果调用失败，再选另一台调用。</li><li>服务消费者和提供者，在内存中累计调用次数和调用时间，定时每分钟发送一次统计数据到监控中心。</li></ol><p>Dubbo 架构具有以下几个特点，分别是连通性、健壮性、伸缩性、以及向未来架构的升级性。</p><h5 id="连通性"><a href="#连通性" class="headerlink" title="连通性"></a>连通性</h5><ul><li>注册中心负责服务地址的注册与查找，相当于目录服务，服务提供者和消费者只在启动时与注册中心交互，注册中心不转发请求，压力较小</li><li>监控中心负责统计各服务调用次数，调用时间等，统计先在内存汇总后每分钟一次发送到监控中心服务器，并以报表展示</li><li>服务提供者向注册中心注册其提供的服务，并汇报调用时间到监控中心，此时间不包含网络开销</li><li>服务消费者向注册中心获取服务提供者地址列表，并根据负载算法直接调用提供者，同时汇报调用时间到监控中心，此时间包含网络开销</li><li>注册中心，服务提供者，服务消费者三者之间均为长连接，监控中心除外</li><li>注册中心通过长连接感知服务提供者的存在，服务提供者宕机，注册中心将立即推送事件通知消费者</li><li>注册中心和监控中心全部宕机，不影响已运行的提供者和消费者，消费者在本地缓存了提供者列表</li><li>注册中心和监控中心都是可选的，服务消费者可以直连服务提供者</li></ul><h5 id="健壮性"><a href="#健壮性" class="headerlink" title="健壮性"></a>健壮性</h5><ul><li>监控中心宕掉不影响使用，只是丢失部分采样数据</li><li>数据库宕掉后，注册中心仍能通过缓存提供服务列表查询，但不能注册新服务</li><li>注册中心对等集群，任意一台宕掉后，将自动切换到另一台</li><li>注册中心全部宕掉后，服务提供者和服务消费者仍能通过本地缓存通讯</li><li>服务提供者无状态，任意一台宕掉后，不影响使用</li><li>服务提供者全部宕掉后，服务消费者应用将无法使用，并无限次重连等待服务提供者恢复</li></ul><h5 id="伸缩性"><a href="#伸缩性" class="headerlink" title="伸缩性"></a>伸缩性</h5><ul><li>注册中心为对等集群，可动态增加机器部署实例，所有客户端将自动发现新的注册中心</li><li>服务提供者无状态，可动态增加机器部署实例，注册中心将推送新的服务提供者信息给消费者</li></ul><h5 id="升级性"><a href="#升级性" class="headerlink" title="升级性"></a>升级性</h5><p>当服务集群规模进一步扩大，带动IT治理结构进一步升级，需要实现动态部署，进行流动计算，现有分布式服务架构不会带来阻力。下图是未来可能的一种架构：</p><p><img src="http://dubbo.apache.org/docs/zh-cn/user/sources/images/dubbo-architecture-future.jpg" alt="dubbo-architucture-futures"></p><h5 id="节点角色说明-1"><a href="#节点角色说明-1" class="headerlink" title="节点角色说明"></a>节点角色说明</h5><table><thead><tr><th>节点</th><th>角色说明</th></tr></thead><tbody><tr><td><code>Deployer</code></td><td>自动部署服务的本地代理</td></tr><tr><td><code>Repository</code></td><td>仓库用于存储服务应用发布包</td></tr><tr><td><code>Scheduler</code></td><td>调度中心基于访问压力自动增减服务提供者</td></tr><tr><td><code>Admin</code></td><td>统一管理控制台</td></tr><tr><td><code>Registry</code></td><td>服务注册与发现的注册中心</td></tr><tr><td><code>Monitor</code></td><td>统计服务的调用次数和调用时间的监控中心</td></tr></tbody></table><hr><h2 id="第二节-入门"><a href="#第二节-入门" class="headerlink" title="第二节 入门"></a><strong>第二节 入门</strong></h2><p>项目地址：<a href="https://github.com/apache" target="_blank" rel="noopener">apache</a>/<strong><a href="https://github.com/apache/dubbo" target="_blank" rel="noopener">dubbo</a></strong></p><h3 id="2-1-安装"><a href="#2-1-安装" class="headerlink" title="2.1 安装"></a><strong>2.1 安装</strong></h3><p>安装：</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">git <span class="built_in">clone</span> https://github.com/apache/dubbo.git</span><br><span class="line"><span class="built_in">cd</span> dubbo/dubbo-demo/dubbo-demo-xml</span><br><span class="line">运行 dubbo-demo-xml-provider中的org.apache.dubbo.demo.provider.Application</span><br><span class="line">如果使用Intellij Idea 请加上-Djava.net.preferIPv4Stack=<span class="literal">true</span></span><br></pre></td></tr></table></figure><p>配置：</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">resources/spring/dubbo-provider.xml</span><br><span class="line">修改其中的dubbo:registry，替换成真实的注册中心地址，推荐使用zookeeper，如：</span><br><span class="line">&lt;dubbo:registry address=<span class="string">"zookeeper://127.0.0.1:2181"</span>/&gt;</span><br></pre></td></tr></table></figure><p>通过Idea打开项目，等待依赖下载完毕后按官网教程启动 <code>dubbo-demo-xml-provider</code> 。</p><p>启动失败，报错：</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">D:\Java\WorkPlace\FromGitHub\dubbo-master\dubbo-config\dubbo-config-api\src\<span class="built_in">test</span>\java\org\apache\dubbo\config\bootstrap\rest\UserService.java</span><br><span class="line">Error:(22, 50) java: 程序包org.apache.dubbo.rpc.protocol.rest.support不存在</span><br><span class="line">Error:(37, 12) java: 找不到符号</span><br><span class="line">  符号: 变量 ContentType</span><br><span class="line">Error:(37, 48) java: 找不到符号</span><br><span class="line">  符号: 变量 ContentType</span><br></pre></td></tr></table></figure><p>找到（dubbo-config-api）<code>pom.xml</code> 并注释掉所有Maven的test作用域。</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">        <span class="comment">&lt;!-- FIXME, we shouldn't rely on these modules, even in test scope --&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.apache.dubbo<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>dubbo-rpc-dubbo<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">version</span>&gt;</span>$&#123;project.parent.version&#125;<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!--            &lt;scope&gt;test&lt;/scope&gt;--&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure><p>重启，OK上述错误不再提示，但有了新的错误。</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Error:(26, 52) java: 程序包org.apache.dubbo.common.serialize.nativejava不存在</span><br><span class="line">Error:(99, 43) java: 找不到符号</span><br><span class="line">  符号:   类 NativeJavaSerialization</span><br><span class="line">  位置: 类 org.apache.dubbo.rpc.protocol.hessian.HessianProtocolTest</span><br><span class="line">Warning:(110, 59) java: org.apache.dubbo.common.serialize.ObjectInput中的readObject()已过时</span><br></pre></td></tr></table></figure><p>找到（dubbo-rpc-rest）<code>pom.xml</code> 并注释掉test作用域。</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">        <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.apache.dubbo<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>dubbo-serialization-jdk<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">version</span>&gt;</span>$&#123;project.parent.version&#125;<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!--            &lt;scope&gt;test&lt;/scope&gt;--&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure><p>再次启动，OK顺利运行。</p><h3 id="2-2-简单使用"><a href="#2-2-简单使用" class="headerlink" title="2.2 简单使用"></a><strong>2.2 简单使用</strong></h3><h4 id="（1）服务提供者"><a href="#（1）服务提供者" class="headerlink" title="（1）服务提供者"></a><strong>（1）服务提供者</strong></h4><p>找到 <code>dubbo-demo-interface</code> 子项目，其中有定义接口 <code>DemoService.java</code> </p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> org.apache.dubbo.demo;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">DemoService</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function">String <span class="title">sayHello</span><span class="params">(String name)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">default</span> CompletableFuture&lt;String&gt; <span class="title">sayHelloAsync</span><span class="params">(String name)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> CompletableFuture.completedFuture(sayHello(name));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>找到 <code>dubbo-demo-api</code> 子项目，其中有定义接口实现 <code>DemoServiceImpl.java</code> </p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> org.apache.dubbo.demo.provider;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> org.apache.dubbo.demo.DemoService;</span><br><span class="line"><span class="keyword">import</span> org.apache.dubbo.rpc.RpcContext;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> org.slf4j.Logger;</span><br><span class="line"><span class="keyword">import</span> org.slf4j.LoggerFactory;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.CompletableFuture;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">DemoServiceImpl</span> <span class="keyword">implements</span> <span class="title">DemoService</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> Logger logger = LoggerFactory.getLogger(DemoServiceImpl.class);</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">sayHello</span><span class="params">(String name)</span> </span>&#123;</span><br><span class="line">        logger.info(<span class="string">"Hello "</span> + name + <span class="string">", request from consumer: "</span> + RpcContext.getContext().getRemoteAddress());</span><br><span class="line">        <span class="keyword">return</span> <span class="string">"Hello "</span> + name + <span class="string">", response from provider: "</span> + RpcContext.getContext().getLocalAddress();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> CompletableFuture&lt;String&gt; <span class="title">sayHelloAsync</span><span class="params">(String name)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>最后通过Spring的xml配置来将服务暴露，<code>provider.xml</code> ：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="php"><span class="meta">&lt;?</span>xml version=<span class="string">"1.0"</span> encoding=<span class="string">"UTF-8"</span><span class="meta">?&gt;</span></span></span><br><span class="line"><span class="tag">&lt;<span class="name">beans</span> <span class="attr">xmlns</span>=<span class="string">"http://www.springframework.org/schema/beans"</span></span></span><br><span class="line"><span class="tag">    <span class="attr">xmlns:xsi</span>=<span class="string">"http://www.w3.org/2001/XMLSchema-instance"</span></span></span><br><span class="line"><span class="tag">    <span class="attr">xmlns:dubbo</span>=<span class="string">"http://dubbo.apache.org/schema/dubbo"</span></span></span><br><span class="line"><span class="tag">    <span class="attr">xsi:schemaLocation</span>=<span class="string">"http://www.springframework.org/schema/beans        http://www.springframework.org/schema/beans/spring-beans-4.3.xsd        http://dubbo.apache.org/schema/dubbo        http://dubbo.apache.org/schema/dubbo/dubbo.xsd"</span>&gt;</span></span><br><span class="line"> </span><br><span class="line">    <span class="comment">&lt;!-- 提供方应用信息，用于计算依赖关系 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">dubbo:application</span> <span class="attr">name</span>=<span class="string">"hello-world-app"</span>  /&gt;</span></span><br><span class="line"> </span><br><span class="line">    <span class="comment">&lt;!-- 使用multicast广播注册中心暴露服务地址 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">dubbo:registry</span> <span class="attr">address</span>=<span class="string">"multicast://224.5.6.7:1234"</span> /&gt;</span></span><br><span class="line"> </span><br><span class="line">    <span class="comment">&lt;!-- 用dubbo协议在20880端口暴露服务 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">dubbo:protocol</span> <span class="attr">name</span>=<span class="string">"dubbo"</span> <span class="attr">port</span>=<span class="string">"20880"</span> /&gt;</span></span><br><span class="line"> </span><br><span class="line">    <span class="comment">&lt;!-- 声明需要暴露的服务接口 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">dubbo:service</span> <span class="attr">interface</span>=<span class="string">"org.apache.dubbo.demo.DemoService"</span> <span class="attr">ref</span>=<span class="string">"demoService"</span> /&gt;</span></span><br><span class="line"> </span><br><span class="line">    <span class="comment">&lt;!-- 和本地bean一样实现服务 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">"demoService"</span> <span class="attr">class</span>=<span class="string">"org.apache.dubbo.demo.provider.DemoServiceImpl"</span> /&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">beans</span>&gt;</span></span><br></pre></td></tr></table></figure><p>最后在 <code>dubbo-demo-xml-provider</code> 启动类加载Spring配置：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> org.apache.dubbo.demo.provider;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> org.springframework.context.support.ClassPathXmlApplicationContext;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Application</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        ClassPathXmlApplicationContext context = <span class="keyword">new</span> ClassPathXmlApplicationContext(<span class="string">"spring/dubbo-provider.xml"</span>);</span><br><span class="line">        context.start();</span><br><span class="line">        System.in.read();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="（2）服务消费者"><a href="#（2）服务消费者" class="headerlink" title="（2）服务消费者"></a><strong>（2）服务消费者</strong></h4><p>首先通过 Spring 配置引用远程服务 dubbo-consumer.xml：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><span class="line"><span class="php"><span class="meta">&lt;?</span>xml version=<span class="string">"1.0"</span> encoding=<span class="string">"UTF-8"</span><span class="meta">?&gt;</span></span></span><br><span class="line"><span class="tag">&lt;<span class="name">beans</span> <span class="attr">xmlns</span>=<span class="string">"http://www.springframework.org/schema/beans"</span></span></span><br><span class="line"><span class="tag">    <span class="attr">xmlns:xsi</span>=<span class="string">"http://www.w3.org/2001/XMLSchema-instance"</span></span></span><br><span class="line"><span class="tag">    <span class="attr">xmlns:dubbo</span>=<span class="string">"http://dubbo.apache.org/schema/dubbo"</span></span></span><br><span class="line"><span class="tag">    <span class="attr">xsi:schemaLocation</span>=<span class="string">"http://www.springframework.org/schema/beans        http://www.springframework.org/schema/beans/spring-beans-4.3.xsd        http://dubbo.apache.org/schema/dubbo        http://dubbo.apache.org/schema/dubbo/dubbo.xsd"</span>&gt;</span></span><br><span class="line"> </span><br><span class="line">    <span class="comment">&lt;!-- 消费方应用名，用于计算依赖关系，不是匹配条件，不要与提供方一样 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">dubbo:application</span> <span class="attr">name</span>=<span class="string">"consumer-of-helloworld-app"</span>  /&gt;</span></span><br><span class="line"> </span><br><span class="line">    <span class="comment">&lt;!-- 使用multicast广播注册中心暴露发现服务地址 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">dubbo:registry</span> <span class="attr">address</span>=<span class="string">"multicast://224.5.6.7:1234"</span> /&gt;</span></span><br><span class="line"> </span><br><span class="line">    <span class="comment">&lt;!-- 生成远程服务代理，可以和本地bean一样使用demoService --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">dubbo:reference</span> <span class="attr">id</span>=<span class="string">"demoService"</span> <span class="attr">interface</span>=<span class="string">"org.apache.dubbo.demo.DemoService"</span> /&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">beans</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="php"><span class="meta">&lt;?</span>xml version=<span class="string">"1.0"</span> encoding=<span class="string">"UTF-8"</span><span class="meta">?&gt;</span></span></span><br><span class="line"><span class="comment">&lt;!--</span></span><br><span class="line"><span class="comment">  Licensed to the Apache Software Foundation (ASF) under one or more</span></span><br><span class="line"><span class="comment">  contributor license agreements.  See the NOTICE file distributed with</span></span><br><span class="line"><span class="comment">  this work for additional information regarding copyright ownership.</span></span><br><span class="line"><span class="comment">  The ASF licenses this file to You under the Apache License, Version 2.0</span></span><br><span class="line"><span class="comment">  (the "License"); you may not use this file except in compliance with</span></span><br><span class="line"><span class="comment">  the License.  You may obtain a copy of the License at</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">      http://www.apache.org/licenses/LICENSE-2.0</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">  Unless required by applicable law or agreed to in writing, software</span></span><br><span class="line"><span class="comment">  distributed under the License is distributed on an "AS IS" BASIS,</span></span><br><span class="line"><span class="comment">  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.</span></span><br><span class="line"><span class="comment">  See the License for the specific language governing permissions and</span></span><br><span class="line"><span class="comment">  limitations under the License.</span></span><br><span class="line"><span class="comment">  --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">beans</span> <span class="attr">xmlns:xsi</span>=<span class="string">"http://www.w3.org/2001/XMLSchema-instance"</span></span></span><br><span class="line"><span class="tag">       <span class="attr">xmlns:dubbo</span>=<span class="string">"http://dubbo.apache.org/schema/dubbo"</span></span></span><br><span class="line"><span class="tag">       <span class="attr">xmlns</span>=<span class="string">"http://www.springframework.org/schema/beans"</span></span></span><br><span class="line"><span class="tag">       <span class="attr">xsi:schemaLocation</span>=<span class="string">"http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans-4.3.xsd</span></span></span><br><span class="line"><span class="tag"><span class="string">       http://dubbo.apache.org/schema/dubbo http://dubbo.apache.org/schema/dubbo/dubbo.xsd"</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">dubbo:application</span> <span class="attr">name</span>=<span class="string">"demo-consumer"</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">dubbo:parameter</span> <span class="attr">key</span>=<span class="string">"mapping-type"</span> <span class="attr">value</span>=<span class="string">"metadata"</span>/&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">dubbo:parameter</span> <span class="attr">key</span>=<span class="string">"enable-auto-migration"</span> <span class="attr">value</span>=<span class="string">"true"</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">dubbo:application</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">&lt;!--    &lt;dubbo:metadata-report address="zookeeper://127.0.0.1:2181"/&gt;--&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">dubbo:registry</span> <span class="attr">address</span>=<span class="string">"zookeeper://127.0.0.1:2181"</span>/&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">dubbo:reference</span> <span class="attr">provided-by</span>=<span class="string">"demo-provider"</span> <span class="attr">id</span>=<span class="string">"demoService"</span> <span class="attr">check</span>=<span class="string">"false"</span></span></span><br><span class="line"><span class="tag">                     <span class="attr">interface</span>=<span class="string">"org.apache.dubbo.demo.DemoService"</span>/&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">dubbo:reference</span> <span class="attr">provided-by</span>=<span class="string">"demo-provider"</span> <span class="attr">version</span>=<span class="string">"1.0.0"</span> <span class="attr">group</span>=<span class="string">"greeting"</span> <span class="attr">id</span>=<span class="string">"greetingService"</span> <span class="attr">check</span>=<span class="string">"false"</span></span></span><br><span class="line"><span class="tag">                     <span class="attr">interface</span>=<span class="string">"org.apache.dubbo.demo.GreetingService"</span>/&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;/<span class="name">beans</span>&gt;</span></span><br></pre></td></tr></table></figure><p>然后加载Spring配置，并调用远程服务Consumer.java </p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> org.springframework.context.support.ClassPathXmlApplicationContext;</span><br><span class="line"><span class="keyword">import</span> org.apache.dubbo.demo.DemoService;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Consumer</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">       ClassPathXmlApplicationContext context = <span class="keyword">new</span> ClassPathXmlApplicationContext(<span class="keyword">new</span> String[] &#123;<span class="string">"META-INF/spring/dubbo-demo-consumer.xml"</span>&#125;);</span><br><span class="line">        context.start();</span><br><span class="line">        DemoService demoService = (DemoService)context.getBean(<span class="string">"demoService"</span>); <span class="comment">// 获取远程服务代理</span></span><br><span class="line">        String hello = demoService.sayHello(<span class="string">"world"</span>); <span class="comment">// 执行远程方法</span></span><br><span class="line">        System.out.println( hello ); <span class="comment">// 显示调用结果</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">package</span> org.apache.dubbo.demo.consumer;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> org.apache.dubbo.demo.DemoService;</span><br><span class="line"><span class="keyword">import</span> org.apache.dubbo.demo.GreetingService;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> org.springframework.context.support.ClassPathXmlApplicationContext;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.CompletableFuture;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Application</span> </span>&#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * In order to make sure multicast registry works, need to specify '-Djava.net.preferIPv4Stack=true' before</span></span><br><span class="line"><span class="comment">     * launch the application</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        ClassPathXmlApplicationContext context = <span class="keyword">new</span> ClassPathXmlApplicationContext(<span class="string">"spring/dubbo-consumer.xml"</span>);</span><br><span class="line">        context.start();</span><br><span class="line">        DemoService demoService = context.getBean(<span class="string">"demoService"</span>, DemoService.class);</span><br><span class="line">        GreetingService greetingService = context.getBean(<span class="string">"greetingService"</span>, GreetingService.class);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">new</span> Thread(() -&gt; &#123;</span><br><span class="line">            <span class="keyword">while</span> (<span class="keyword">true</span>) &#123;</span><br><span class="line">                String greetings = greetingService.hello();</span><br><span class="line">                System.out.println(greetings + <span class="string">" from separated thread."</span>);</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    Thread.sleep(<span class="number">100</span>);</span><br><span class="line">                &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;).start();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span> (<span class="keyword">true</span>) &#123;</span><br><span class="line">            CompletableFuture&lt;String&gt; hello = demoService.sayHelloAsync(<span class="string">"world"</span>);</span><br><span class="line">            System.out.println(<span class="string">"result: "</span> + hello.get());</span><br><span class="line"></span><br><span class="line">            String greetings = greetingService.hello();</span><br><span class="line">            System.out.println(<span class="string">"result: "</span> + greetings);</span><br><span class="line"></span><br><span class="line">            Thread.sleep(<span class="number">500</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><ol><li>该接口需单独打包，在服务提供方和消费方共享 <a href="http://dubbo.apache.org/zh-cn/docs/user/quick-start.html#fnref1" target="_blank" rel="noopener">↩︎</a></li><li>对服务消费方隐藏实现 <a href="http://dubbo.apache.org/zh-cn/docs/user/quick-start.html#fnref2" target="_blank" rel="noopener">↩︎</a></li><li>也可以使用 IoC 注入 <a href="http://dubbo.apache.org/zh-cn/docs/user/quick-start.html#fnref3" target="_blank" rel="noopener">↩︎</a></li></ol><hr><p>参考：</p><blockquote><p><a href="http://dubbo.apache.org/zh-cn/docs/user/dependencies.html" target="_blank" rel="noopener">Dubbo官网-文档</a></p></blockquote><blockquote><p><a href="http://jm.taobao.org/2018/06/13/%E5%BA%94%E7%94%A8/" target="_blank" rel="noopener">第一个 Dubbo 应用</a></p></blockquote><p><em>若内容涉及侵权请及时告知，我会尽快修改和删除相关内容</em></p>]]></content>
    
    <summary type="html">
    
      从零开始学习Dubbo，第一章《简介和搭建》
    
    </summary>
    
      <category term="技术文档" scheme="http://linyishui.top/categories/%E6%8A%80%E6%9C%AF%E6%96%87%E6%A1%A3/"/>
    
    
      <category term="dubbo" scheme="http://linyishui.top/tags/dubbo/"/>
    
      <category term="distributed" scheme="http://linyishui.top/tags/distributed/"/>
    
  </entry>
  
  <entry>
    <title>从零开始学习英语（一）启程</title>
    <link href="http://linyishui.top/2020090101.html"/>
    <id>http://linyishui.top/2020090101.html</id>
    <published>2020-09-01T10:14:30.000Z</published>
    <updated>2020-09-05T13:17:13.453Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="启程"><a href="#启程" class="headerlink" title="启程"></a><strong>启程</strong></h1><h3 id="为什么要学习英语？"><a href="#为什么要学习英语？" class="headerlink" title="为什么要学习英语？"></a><strong>为什么要学习英语？</strong></h3><p>今天，当我终于下定决心要开始学习英语时，我发现最开始想要学习一门外语到现在已经过去了将近5年的时间。大部分人应该和我一样虽然会觉得自己应该至少学习一门外语，但在思考这个问题时，<strong>总是会想在一个更合适的时间开始学习</strong>。</p><p>在逃避学习的这段时间里，我有时忙于玩乐，有时忙于工作，一直在焦虑和麻木的状态中生活。时间来到这个月，我处于人生中的第二个求职阶段，面试的不顺利和内心的不甘心，让我突然发现，<strong>人生中的大部分时间我都是在被迫学习</strong>：少年时因为要考试而去学习；成年后进入大学，又为了奖学金而短暂学习过；工作后为了更好的岗位和薪水而去强迫自己学习。<strong>我还从来没有因为想要学一个东西而去认真的实现这个想法，这让我意识到不管明天会怎样，我都要从今天开始我的学习计划了</strong>。</p><p>我为自己想了几个学习英语的目的：</p><ul><li>为了和英语世界的人交流，认识更多的朋友。</li><li>不局限于中文环境，去见识和了解到更大范围的世界。</li><li>无障碍的看懂美剧而不用盯着字幕，可以听懂英文歌曲。</li><li>将来有更多的工作机会，以及在其他环境生活的机会。</li><li>增强自信心，提高我对自己的自我评价。</li></ul><p>我首先选择了一本在大学时就收藏的书籍《跟各国人都聊得来-三个月外语流利术》，在开启英语学习之路上，先汲取一下在同样事情上成功的人的经验。</p><hr><h3 id="学习语言的错误观点"><a href="#学习语言的错误观点" class="headerlink" title="学习语言的错误观点"></a><strong>学习语言的错误观点</strong></h3><p><strong>我们为学不会一种语言找的借口往往是对自我的错误认知。</strong></p><h4 id="观点1：年纪太大，不利于学习语言"><a href="#观点1：年纪太大，不利于学习语言" class="headerlink" title="观点1：年纪太大，不利于学习语言"></a>观点1：年纪太大，不利于学习语言</h4><p>这种观点从来没有理论或科学研究的支持，实际上无论学习什么东西，成年人都要比小孩子更有优势，因为我们成年人不是从零开始学习第一语音。根据研究，93%的情感交流都不是通过语言完成的，比如笑也是一种信息的传递方式，成年人不用再花大量时间去学习如何与人交流。</p><p><strong>相比于孩子，成年人要学习的内容更少。</strong>成年人有更多的学习经验应用到学习语言上面，成年人比孩子更有分析力。相反，成年人应该学习孩子不害怕犯错误这一点，享受学习的过程，不要害怕尴尬。</p><h4 id="观点2：我没有学习语言的天赋"><a href="#观点2：我没有学习语言的天赋" class="headerlink" title="观点2：我没有学习语言的天赋"></a>观点2：我没有学习语言的天赋</h4><p>事实上，所有人都有学习语言的天赋，在一些多语种的国家，人们都能在很多语言之间自由的切换，比如卢森堡的学生在毕业时能流利的使用法语、德语、卢森堡语。</p><p>我们在学习刚开始就要抛开这种自我怀疑。</p><h4 id="观点3：我没有时间"><a href="#观点3：我没有时间" class="headerlink" title="观点3：我没有时间"></a>观点3：我没有时间</h4><p>大部分人都有工作要做，这是一个很好的接口。但事实上，大部分学习语言很成功的人都有正式的工作，或是操持家务、照顾家人。</p><p>只要真正的抽出时间去学习，你就能取得进步。比如看电视、浏览各种APP、打游戏等等，这些活动占用了我们大量的时间，甚至还有一些是无意义的活动，还有如等电梯、坐公交车、地铁等。即使是几分钟的时间，用来学习几个单词或日常用语也是足够的。</p><p><strong>当你真正想要学习一门语言时，每一分钟都是可以利用的。</strong></p><p>当然，花几个月的时间去做一件事很不错，但如果没有这个条件，请尽量把能用的时间利用起来，虽然周期会长一些，但你总能达到目标的。</p><h4 id="观点4：学语言是有钱人的专利"><a href="#观点4：学语言是有钱人的专利" class="headerlink" title="观点4：学语言是有钱人的专利"></a>观点4：学语言是有钱人的专利</h4><p>昂贵的课程和学习产品并不比网上的免费工具、博客、以及和外国朋友聊天更有帮助。</p><h4 id="观点5：我在等待完美的语言课程"><a href="#观点5：我在等待完美的语言课程" class="headerlink" title="观点5：我在等待完美的语言课程"></a>观点5：我在等待完美的语言课程</h4><p>没有完美的课程，即使是优秀的语言课程能教给你的东西也是有限的，而且它<strong>并不比你努力学习更有效果</strong>。</p><h4 id="观点6：如果我使用了错误的学习方法，那我还没开始就注定要失败"><a href="#观点6：如果我使用了错误的学习方法，那我还没开始就注定要失败" class="headerlink" title="观点6：如果我使用了错误的学习方法，那我还没开始就注定要失败"></a>观点6：如果我使用了错误的学习方法，那我还没开始就注定要失败</h4><p><strong>最重要的事情是你终于开始学习了</strong>，而早期的错误并没有什么关系。遇到挫折，果断的去解决它，振作精神，重新开始，只要再坚持一下就可以了。</p><p><strong>不要把精力投入到研究哪种学习方法更好，而是把精力投入到学习和使用语言上面。</strong></p><h4 id="观点7：只有学到一定程度，我才能开始练习对话"><a href="#观点7：只有学到一定程度，我才能开始练习对话" class="headerlink" title="观点7：只有学到一定程度，我才能开始练习对话"></a>观点7：只有学到一定程度，我才能开始练习对话</h4><p>事实上，<strong>从学习的第一天开始，你就要尝试去说</strong>。这和传统认知并不相符，<strong>因为你永远不会有准备好的那一天</strong>，哪怕你已经掌握了一门语言，你还是能证明自己没有准备好，单词是永远也学不完的，语法也有很多的学习空间，发音也要更多的练习。</p><p><strong>要从现在就开始尽量去使用自己所学的语言，而不是等待很多年。</strong></p><h4 id="观点8：我不能集中精力"><a href="#观点8：我不能集中精力" class="headerlink" title="观点8：我不能集中精力"></a>观点8：我不能集中精力</h4><p><strong>只专注于眼前的任务，不管有多大的诱惑。</strong>一些优秀的人才也只是把各种兴趣爱好安排好，按照次序一一完成，而不是同时去做很多事情。他们也只是有耐心的、有条理的去做。</p><h4 id="观点9：有些语言太难了"><a href="#观点9：有些语言太难了" class="headerlink" title="观点9：有些语言太难了"></a>观点9：有些语言太难了</h4><p>没有人能在这种无意义的比较中获益，事实上即使是公认的难学习的语种也有很多人在使用它来交流。如果你正在学习一门语言，请忘掉其他学过的语言，集中热情在它上面吧！</p><h4 id="观点10：瓶颈期不可避免"><a href="#观点10：瓶颈期不可避免" class="headerlink" title="观点10：瓶颈期不可避免"></a>观点10：瓶颈期不可避免</h4><p>学习中确实难免遇到瓶颈期，初学者不会遇到此问题，直到有所进步后，比如能够交流后就停滞在那里了。这很可能是我们过往的学习方法在此阶段不再适合了，<strong>“愚蠢”的行为就是一直重复用同样的方法做事，却期望得到不同的结果</strong>。</p><p>不要怕，大胆的改变，改变练习的频率，改变对话的对象。</p><h4 id="观点11：完全掌握是不可能的任务"><a href="#观点11：完全掌握是不可能的任务" class="headerlink" title="观点11：完全掌握是不可能的任务"></a>观点11：完全掌握是不可能的任务</h4><p>如果说学一门语言，就是要用它来辩论各种哲学思想，并且不带一丝口音和停顿的话，那么这确实会花费上数十年。</p><p>但请仔细想想，<strong>你对自己的母语有掌握到什么样的程度，再想想为什么要对一门外语有这样的高要求？</strong></p><p>请把目标放在简单对话，再朝着流利的方向努力。</p><h4 id="观点12：学习过程很枯燥"><a href="#观点12：学习过程很枯燥" class="headerlink" title="观点12：学习过程很枯燥"></a>观点12：学习过程很枯燥</h4><p><strong>语言学习并不枯燥，也许只是你的方法枯燥而已。</strong>比如试试听音乐、看动画片、看电影、读杂志、看笑话。找一个互相帮助的伙伴，或者任何能调动你积极性的方式。</p><h4 id="观点13：当地人不会理我"><a href="#观点13：当地人不会理我" class="headerlink" title="观点13：当地人不会理我"></a>观点13：当地人不会理我</h4><p><strong>请记住，你永远也不会准备好，永远都有要学的东西，所以你可以一直给自己找借口。</strong>这种恶性循环导致很多人学了很多年也不敢开口说话。</p><p>现实中，大家往往会鼓励你、帮助你，会很有耐心和包容。比如你是那个本地人，当你遇到一个尝试努力学习你的母语的外人时，你会有怎样的感受？</p><h4 id="观点14：我总是有口音"><a href="#观点14：我总是有口音" class="headerlink" title="观点14：我总是有口音"></a>观点14：我总是有口音</h4><p>实际上有点口音是好事，这并不影响交流。即使是母语也存在很多发音问题，他们也有各种各样的口音。</p><h4 id="观点15：我的家人朋友不支持我"><a href="#观点15：我的家人朋友不支持我" class="headerlink" title="观点15：我的家人朋友不支持我"></a>观点15：我的家人朋友不支持我</h4><p>这个问题没有很好的解决方法，但你可以尽量的阐述自己很喜欢这门语言，表示出你认真的态度，如果对方能理解也许他们会支持你。</p><p>如果你得不到他们的支持，请相信在这个世界上有很多和你一样怀抱相同梦想的人，你会找到支持和理解的。</p><h4 id="观点16：每个人都说英语-汉语"><a href="#观点16：每个人都说英语-汉语" class="headerlink" title="观点16：每个人都说英语/汉语"></a>观点16：每个人都说英语/汉语</h4><p>学会一门新的语言，并不仅仅意味着你收获了这些知识，它会为你带来新的机会和体验。</p><h4 id="观点17：我跟不上比人的脚步"><a href="#观点17：我跟不上比人的脚步" class="headerlink" title="观点17：我跟不上比人的脚步"></a>观点17：我跟不上比人的脚步</h4><p>把自己和别人作比较这种行为本身就很有问题，但这是人的本性。但你要明白，你看到的只是别人展示给你的一面，他们分享经历时，只会说遇到的各种困难，已显示出其高大的形象。</p><p>遇到困难时，请抛弃“成功的人不会面对这样的问题，我还是放弃吧”这样的想法。而应该问自己“成功的人会怎么解决这个困难呢？”。</p><h4 id="观点18：以前失败，现在还会失败"><a href="#观点18：以前失败，现在还会失败" class="headerlink" title="观点18：以前失败，现在还会失败"></a>观点18：以前失败，现在还会失败</h4><p>如果你以前尝试过学习语言，但最终失败了。你可能会觉得自己不擅长学习语言，但请相信这只能说明过去的方法并不适合你。</p><p><strong>没有一种方法是完美适合每一个语言学习者的。</strong>如果你尝试着某种方法，但根本不起作用，请果断的放弃，并试着换另一种方法。</p><p><strong>请明白失败的并不是你这个人，而是你在用的方法。</strong>请在遇到问题时，多和别人交流，书本并不能解决所有的问题。有可能解决方案在你的已知的知识世界以外，而一个学过的人可以帮你轻松的跨过这个难关。</p><h4 id="观点19：一旦忘了某种语言，我就不可能再重新学会它了"><a href="#观点19：一旦忘了某种语言，我就不可能再重新学会它了" class="headerlink" title="观点19：一旦忘了某种语言，我就不可能再重新学会它了"></a>观点19：一旦忘了某种语言，我就不可能再重新学会它了</h4><p>我们小时候学过的语言，后面没有再学，所以总觉得错过了学习它的最佳机会。但其实只要重新开始努力，你会比初次更顺利的学好这门语言。</p><h4 id="观点20：残障人士学语言比正常人更难"><a href="#观点20：残障人士学语言比正常人更难" class="headerlink" title="观点20：残障人士学语言比正常人更难"></a>观点20：残障人士学语言比正常人更难</h4><p>我们会觉得自己有某种缺陷，在学习语言时会和别人不同。但现实中，很多残疾人士都能很好的克服身体上的缺陷，这些问题在你因为它而止步不前时是难以克服的难关，但请相信在你开始不断尝试之后，总会找到出路的。</p><hr><h3 id="感受"><a href="#感受" class="headerlink" title="感受"></a><strong>感受</strong></h3><blockquote><p><strong>不管你觉得自己行或不行，你都是对的。</strong></p><p>​                                                                ——亨利 · 福特</p></blockquote><p>语言学习需要面对挑战，需要付出努力，如果我们确信自己不行，那我们也失去了信心和热情，悲观主义情绪已经占了上风，我们也就注定学不好这种语言了。请大胆的承认失败，不要给自己找没有学好的借口。不管你遇到什么困难，别人都可能遇到过，并且克服过这个困难。</p><p>Benny Lewis的观点很能说动现在的我，好像每个问题都是我曾用来逃避的理由，但还好我现在比起以前有了些许的改变，也许迈出第一步之后，就是焕然一新的自己。</p><p>不仅仅是语言学习，这些常识性的问题在大多数学习场景都是雷同的，我们要克服的是自己的懦弱和懒惰。如果你是一个自命不凡的人，或者只是对现在的自己不够满意，就请不要再浪费时间在准备阶段了，尝试的去做吧。</p><hr><p>内容来源：</p><blockquote><p>《跟各国人都聊得来-三个月外语流利术》</p></blockquote><p><em>若内容涉及侵权请及时告知，我会尽快修改和删除相关内容</em></p>]]></content>
    
    <summary type="html">
    
      从零开始学习英语，内容来自于《跟各国人都聊得来-三个月外语流利术》和自我感受。
    
    </summary>
    
      <category term="学习语言" scheme="http://linyishui.top/categories/%E5%AD%A6%E4%B9%A0%E8%AF%AD%E8%A8%80/"/>
    
    
      <category term="language" scheme="http://linyishui.top/tags/language/"/>
    
      <category term="english" scheme="http://linyishui.top/tags/english/"/>
    
  </entry>
  
  <entry>
    <title>大数据量表的优化思路</title>
    <link href="http://linyishui.top/2020082201.html"/>
    <id>http://linyishui.top/2020082201.html</id>
    <published>2020-09-01T05:32:46.000Z</published>
    <updated>2020-09-02T07:19:13.718Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="大数据量表的优化思路"><a href="#大数据量表的优化思路" class="headerlink" title="大数据量表的优化思路"></a><strong>大数据量表的优化思路</strong></h1><h2 id="第一节-问题描述"><a href="#第一节-问题描述" class="headerlink" title="第一节 问题描述"></a><strong>第一节 问题描述</strong></h2><h2 id="1-1-常见问题"><a href="#1-1-常见问题" class="headerlink" title="1.1 常见问题"></a><strong>1.1 常见问题</strong></h2><ol><li>单表数据量达到千万级别后，查询操作耗时过久。</li><li>针对海量的数据表进行修改操作。</li></ol><h2 id="1-2-MySql模拟"><a href="#1-2-MySql模拟" class="headerlink" title="1.2 MySql模拟"></a><strong>1.2 MySql模拟</strong></h2><p>创建千万条模拟数据，</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line">#创建MyISAM模式表方便批量跑数据</span><br><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> <span class="string">`logs1`</span> (</span><br><span class="line">  <span class="string">`id`</span> <span class="built_in">int</span>(<span class="number">11</span>) <span class="keyword">NOT</span> <span class="literal">NULL</span> AUTO_INCREMENT,</span><br><span class="line">  <span class="string">`logtype`</span> <span class="built_in">varchar</span>(<span class="number">255</span>) <span class="keyword">DEFAULT</span> <span class="literal">NULL</span>,</span><br><span class="line">  <span class="string">`logurl`</span> <span class="built_in">varchar</span>(<span class="number">255</span>) <span class="keyword">DEFAULT</span> <span class="literal">NULL</span>,</span><br><span class="line">  <span class="string">`logip`</span> <span class="built_in">varchar</span>(<span class="number">255</span>) <span class="keyword">DEFAULT</span> <span class="literal">NULL</span>,</span><br><span class="line">  <span class="string">`logdz`</span> <span class="built_in">varchar</span>(<span class="number">255</span>) <span class="keyword">DEFAULT</span> <span class="literal">NULL</span>,</span><br><span class="line">  <span class="string">`ladduser`</span> <span class="built_in">varchar</span>(<span class="number">255</span>) <span class="keyword">DEFAULT</span> <span class="literal">NULL</span>,</span><br><span class="line">  <span class="string">`lfadduser`</span> <span class="built_in">varchar</span>(<span class="number">255</span>) <span class="keyword">DEFAULT</span> <span class="literal">NULL</span>,</span><br><span class="line">  <span class="string">`laddtime`</span> datetime <span class="keyword">DEFAULT</span> <span class="literal">NULL</span>,</span><br><span class="line">  <span class="string">`htmlname`</span> <span class="built_in">varchar</span>(<span class="number">255</span>) <span class="keyword">DEFAULT</span> <span class="literal">NULL</span>,</span><br><span class="line">  PRIMARY <span class="keyword">KEY</span> (<span class="string">`id`</span>)</span><br><span class="line">) <span class="keyword">ENGINE</span>=MyISAM  AUTO_INCREMENT=<span class="number">1811</span> <span class="keyword">DEFAULT</span> <span class="keyword">CHARSET</span>=utf8 <span class="keyword">COMMENT</span>=<span class="string">'日志表'</span>;</span><br><span class="line"> </span><br><span class="line"> </span><br><span class="line">#创建存储过程</span><br><span class="line"><span class="keyword">DROP</span> <span class="keyword">PROCEDURE</span> <span class="keyword">IF</span> <span class="keyword">EXISTS</span> my_insert;</span><br><span class="line"><span class="keyword">CREATE</span> <span class="keyword">PROCEDURE</span> my_insert()</span><br><span class="line"><span class="keyword">BEGIN</span></span><br><span class="line">   <span class="keyword">DECLARE</span> n <span class="built_in">int</span> <span class="keyword">DEFAULT</span> <span class="number">1</span>;</span><br><span class="line">   <span class="keyword">DECLARE</span> in_dateTime <span class="keyword">TIMESTAMP</span> <span class="keyword">DEFAULT</span> <span class="string">'2020-01-01 00:00:00'</span>;</span><br><span class="line">        while n &lt;= 10000000 do</span><br><span class="line">            <span class="keyword">INSERT</span> <span class="keyword">INTO</span> <span class="string">`logs1`</span>(<span class="string">`logtype`</span>,<span class="string">`logurl`</span>,<span class="string">`logip`</span>,<span class="string">`logdz`</span>,<span class="string">`ladduser`</span> ,<span class="string">`lfadduser`</span>,<span class="string">`laddtime`</span>,<span class="string">`htmlname`</span>) <span class="keyword">VALUES</span> (<span class="keyword">FLOOR</span>(<span class="number">1</span> + (<span class="keyword">RAND</span>() * <span class="number">2</span>)), <span class="string">'/index'</span>, <span class="string">'0:0:0:0:0:0:0:1'</span>, <span class="literal">null</span>, <span class="literal">null</span>, <span class="string">'null'</span>, in_dateTime, <span class="string">'首页'</span>);</span><br><span class="line">            <span class="keyword">set</span> in_dateTime = in_dateTime + <span class="built_in">interval</span> <span class="number">1</span> MINUTE_SECOND;</span><br><span class="line">            <span class="keyword">SET</span> n = n + <span class="number">1</span>;</span><br><span class="line"><span class="keyword">end</span> <span class="keyword">while</span>;</span><br><span class="line"><span class="keyword">END</span>;</span><br><span class="line"> </span><br><span class="line">#执行存储过程</span><br><span class="line"><span class="keyword">CALL</span> my_insert();</span><br><span class="line"> </span><br><span class="line"> </span><br><span class="line">#数据插入成功后修改表模式InnoDB 时间稍微久点</span><br><span class="line"> <span class="keyword">alter</span> <span class="keyword">table</span> <span class="string">`logs1`</span> <span class="keyword">engine</span>=<span class="keyword">InnoDB</span>;</span><br></pre></td></tr></table></figure><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">#查询表中行数，用时2.6s左右</span><br><span class="line"><span class="keyword">select</span> <span class="keyword">count</span>(*) <span class="keyword">FROM</span> logs1;</span><br><span class="line"></span><br><span class="line">#分页查询，id从1811开始，查询第6001条到6010条数据，用时0.025s</span><br><span class="line"><span class="keyword">select</span> * <span class="keyword">from</span> logs1 <span class="keyword">limit</span> <span class="number">6000</span>,<span class="number">10</span>;</span><br><span class="line"></span><br><span class="line">#用时0.048s</span><br><span class="line"><span class="keyword">select</span> * <span class="keyword">from</span> logs1 <span class="keyword">limit</span> <span class="number">60000</span>,<span class="number">10</span>;</span><br><span class="line"></span><br><span class="line">#用时0.256s</span><br><span class="line"><span class="keyword">select</span> * <span class="keyword">from</span> logs1 <span class="keyword">limit</span> <span class="number">600000</span>,<span class="number">10</span>;</span><br><span class="line"></span><br><span class="line">#用时4.372s</span><br><span class="line"><span class="keyword">select</span> * <span class="keyword">from</span> logs1 <span class="keyword">limit</span> <span class="number">9000000</span>,<span class="number">10</span>;</span><br></pre></td></tr></table></figure><p><strong>分页查询方式会从数据库第一条记录开始扫描，所以越往后，查询速度越慢，而且查询的数据越多，也会拖慢总查询速度。</strong></p><hr><h2 id="第二节-解决流程"><a href="#第二节-解决流程" class="headerlink" title="第二节 解决流程"></a><strong>第二节 解决流程</strong></h2><h2 id="2-1-索引"><a href="#2-1-索引" class="headerlink" title="2.1 索引"></a><strong>2.1 索引</strong></h2><p>explain得知查询并未走索引，首先增加索引。</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"># type=all全表查询，先创建索引</span><br><span class="line"><span class="keyword">explain</span> <span class="keyword">select</span> <span class="keyword">COUNT</span>(*) <span class="keyword">FROM</span> logs1 <span class="keyword">where</span> logtype = <span class="number">2</span>;</span><br><span class="line"></span><br><span class="line">#增加唯一索引和普通索引</span><br><span class="line"><span class="keyword">ALTER</span> <span class="keyword">TABLE</span> logs1 <span class="keyword">ADD</span> <span class="keyword">UNIQUE</span> index_id (<span class="keyword">id</span>)</span><br><span class="line"><span class="keyword">ALTER</span> <span class="keyword">TABLE</span> logs1 <span class="keyword">ADD</span> <span class="keyword">INDEX</span> index_logtype (logtype)</span><br><span class="line"><span class="keyword">ALTER</span> <span class="keyword">TABLE</span> logs1 <span class="keyword">ADD</span> <span class="keyword">INDEX</span> index_laddtime (laddtime)</span><br><span class="line"><span class="keyword">ALTER</span> <span class="keyword">TABLE</span> logs1 <span class="keyword">DROP</span> <span class="keyword">INDEX</span> index_logtype</span><br><span class="line"><span class="keyword">ALTER</span> <span class="keyword">TABLE</span> logs1 <span class="keyword">DROP</span> <span class="keyword">INDEX</span> index_laddtime</span><br><span class="line"></span><br><span class="line">#<span class="keyword">type</span>是选择性低的属性，而<span class="keyword">time</span>则不是，所以索引的影响也不同</span><br><span class="line">#全表查询 <span class="number">5.073</span>-&gt;索引 <span class="number">4.226</span></span><br><span class="line"><span class="keyword">explain</span> <span class="keyword">select</span> logtype <span class="keyword">from</span> logs1 <span class="keyword">where</span> logtype &gt; <span class="number">1</span>;</span><br><span class="line">#ALL 3.566-&gt;range 0.426</span><br><span class="line"><span class="keyword">explain</span> <span class="keyword">select</span> laddtime <span class="keyword">from</span> logs1 <span class="keyword">where</span> laddtime &gt;= <span class="string">'2020-04-14 04:00:00'</span>;</span><br></pre></td></tr></table></figure><p>索引并非万能的，如果我们查询的属性列是多个。</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">#index 4.572</span><br><span class="line"><span class="keyword">explain</span> <span class="keyword">select</span> <span class="keyword">id</span>,logtype,laddtime <span class="keyword">from</span> logs1 <span class="keyword">where</span> laddtime &gt;= <span class="string">'2020-04-14 04:00:00'</span>;</span><br><span class="line"></span><br><span class="line">#增加where后判断条件</span><br><span class="line">#0.966-&gt;0.853</span><br><span class="line"><span class="keyword">explain</span> <span class="keyword">select</span> <span class="keyword">id</span>,logtype,laddtime <span class="keyword">from</span> logs1 <span class="keyword">where</span> laddtime &gt;= <span class="string">'2020-04-14 04:00:00'</span> <span class="keyword">and</span> <span class="keyword">id</span> &gt; <span class="string">'9001812'</span> <span class="keyword">and</span> logtype = <span class="number">2</span>;</span><br><span class="line"></span><br><span class="line">#创建组合索引</span><br><span class="line"><span class="keyword">ALTER</span> <span class="keyword">TABLE</span> logs1 <span class="keyword">ADD</span> <span class="keyword">INDEX</span> index_union (<span class="keyword">id</span>,logtype,laddtime)</span><br></pre></td></tr></table></figure><h2 id="2-2-优化SQL"><a href="#2-2-优化SQL" class="headerlink" title="2.2 优化SQL"></a><strong>2.2 优化SQL</strong></h2><p>避免select *，将需要查找的字段列出来</p><p>使用连接(join)来代替子查询</p><p>拆分大的delete或insert语句</p><p>通过开启慢查询日志来找出较慢的SQL</p><p>不做列运算：SELECT id WHERE age + 1 = 10，任何对列的操作都将导致表扫描，它包括数据库教程函数、计算表达式等等，查询时要尽可能将操作移至等号右边</p><p>sql语句尽可能简单：一条sql只能在一个cpu运算;大语句拆小语句，减少锁时间;一条大sql可以堵死整个库</p><p>OR改写成IN：OR的效率是n级别，IN的效率是log(n)级别，in的个数建议控制在200以内</p><p>避免%xxx式查询</p><p>尽量避免在WHERE子句中使用!=或&lt;&gt;操作符，否则将引擎放弃使用索引而进行全表扫描</p><p>对于连续数值，使用BETWEEN不用IN：SELECT id FROM t WHERE num BETWEEN 1 AND 5</p><p>列表数据不要拿全表，要使用LIMIT来分页，每页数量也不要太大</p><h2 id="2-3-分区"><a href="#2-3-分区" class="headerlink" title="2.3 分区"></a><strong>2.3 分区</strong></h2><p>MySql 5.1版本引入，用户需要在建表的时候加上分区参数。分区表是一个独立的逻辑表，但是底层由多个物理子表组成，实现分区的代码实际上是通过对一组底层表的对象封装，但对SQL层来说是一个完全封装底层的黑盒子。MySQL实现分区的方式也意味着索引也是按照分区的子表定义，没有全局索引。</p><p><strong>分区的好处是：</strong></p><ol><li>可以让单表存储更多的数据</li><li>分区表的数据更容易维护，可以通过清楚整个分区批量删除大量数据，也可以增加新的分区来支持新插入的数据。另外，还可以对一个独立分区进行优化、检查、修复等操作</li><li>部分查询能够从查询条件确定只落在少数分区上，速度会很快</li><li>分区表的数据还可以分布在不同的物理设备上，从而搞笑利用多个硬件设备</li><li>可以使用分区表赖避免某些特殊瓶颈，例如InnoDB单个索引的互斥访问、ext3文件系统的inode锁竞争</li><li>可以备份和恢复单个分区</li></ol><p><strong>分区的限制和缺点：</strong></p><ol><li>一个表最多只能有1024个分区</li><li>如果分区字段中有主键或者唯一索引的列，那么所有主键列和唯一索引列都必须包含进来</li><li>分区表无法使用外键约束</li><li>NULL值会使分区过滤无效</li><li>所有分区必须使用相同的存储引擎</li></ol><p><strong>分区的类型：</strong></p><ol><li>RANGE分区：基于属于一个给定连续区间的列值，把多行分配给分区</li><li>LIST分区：类似于按RANGE分区，区别在于LIST分区是基于列值匹配一个离散值集合中的某个值来进行选择</li><li>HASH分区：基于用户定义的表达式的返回值来进行选择的分区，该表达式使用将要插入到表中的这些行的列值进行计算。这个函数可以包含MySQL中有效的、产生非负整数值的任何表达式</li><li>KEY分区：类似于按HASH分区，区别在于KEY分区只支持计算一列或多列，且MySQL服务器提供其自身的哈希函数。必须有一列或多列包含整数值</li><li>具体关于mysql分区的概念请自行google或查询官方文档，我这里只是抛砖引玉了。</li></ol><h2 id="2-4-分表"><a href="#2-4-分表" class="headerlink" title="2.4 分表"></a><strong>2.4 分表</strong></h2><p>分表就是把一张大表，按照如上过程都优化了，还是查询卡死，那就把这个表分成多张表，把一次查询分成多次查询，然后把结果组合返回给用户。</p><p>分表分为垂直拆分和水平拆分，通常以某个字段做拆分项。比如以id字段拆分为100张表： 表名为 tableName_id%100</p><p>但：分表需要修改源程序代码，会给开发带来大量工作，极大的增加了开发成本，故：只适合在开发初期就考虑到了大量数据存在，做好了分表处理，不适合应用上线了再做修改，成本太高!!!而且选择这个方案，都不如选择我提供的第二第三个方案的成本低!故不建议采用。</p><h2 id="2-5-分库"><a href="#2-5-分库" class="headerlink" title="2.5 分库"></a><strong>2.5 分库</strong></h2><p>把一个数据库分成多个，建议做个读写分离就行了，真正的做分库也会带来大量的开发成本，得不偿失!不推荐使用。</p><h2 id="2-5-升级数据库"><a href="#2-5-升级数据库" class="headerlink" title="2.5 升级数据库"></a><strong>2.5 升级数据库</strong></h2><p>选用一款兼容MySql的高性能数据库。</p><h2 id="2-6-换大数据引擎处理数据"><a href="#2-6-换大数据引擎处理数据" class="headerlink" title="2.6 换大数据引擎处理数据"></a><strong>2.6 换大数据引擎处理数据</strong></h2><p>当数据量过亿，可能实现无法支撑，只能更换Hadoop等大数据引擎来代替传统数据库。</p><p>或者购买专业的大数据云解决方案，比较便宜省人力。</p><hr><p><em>参考内容：</em></p><blockquote><p><a href="https://database.51cto.com/art/201902/592522.htm" target="_blank" rel="noopener">记录一次MySQL两千万数据的大表优化解决过程，提供三种解决方案</a></p></blockquote><p><em>若内容涉及侵权请及时告知，我会尽快修改和删除相关内容</em></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;link rel=&quot;stylesheet&quot; class=&quot;aplayer-secondary-style-marker&quot; href=&quot;\assets\css\APlayer.min.css&quot;&gt;&lt;script src=&quot;\assets\js\APlayer.min.js&quot; cla
      
    
    </summary>
    
      <category term="技术文档" scheme="http://linyishui.top/categories/%E6%8A%80%E6%9C%AF%E6%96%87%E6%A1%A3/"/>
    
    
      <category term="mysql" scheme="http://linyishui.top/tags/mysql/"/>
    
      <category term="sql" scheme="http://linyishui.top/tags/sql/"/>
    
  </entry>
  
  <entry>
    <title>ConcurrentSkipListMap</title>
    <link href="http://linyishui.top/2020070801.html"/>
    <id>http://linyishui.top/2020070801.html</id>
    <published>2020-07-08T08:56:37.000Z</published>
    <updated>2020-08-25T05:23:27.535Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="ConcurrentSkipListMap"><a href="#ConcurrentSkipListMap" class="headerlink" title="ConcurrentSkipListMap"></a><strong>ConcurrentSkipListMap</strong></h1><h2 id="第一节-概述"><a href="#第一节-概述" class="headerlink" title="第一节 概述"></a><strong>第一节 概述</strong></h2><h3 id="1-1-什么是ConcurrentSkipListMap"><a href="#1-1-什么是ConcurrentSkipListMap" class="headerlink" title="1.1 什么是ConcurrentSkipListMap"></a><strong>1.1 什么是ConcurrentSkipListMap</strong></h3><p>ConcurrentSkipListMap是由并发包提供的一种线程安全的并发容器，（优点）使我们能够<strong>以无锁方式实现线程安全</strong>，<strong>底层是通过跳表来实现</strong>的能够保证<strong>元素有序</strong>。</p><p>跳表是一个链表，但是通过使用<strong>“跳跃式”</strong>查找的方式使得插入、读取数据时复杂度变成了 <strong>O(logn)</strong> 。注意：<code>size()</code> 由于多个线程可以同时对映射进行操作，所以需要遍历整个映射才能返回元素个数，这是个 <strong>O(logn)</strong> 的操作。</p><h3 id="1-2-简单使用"><a href="#1-2-简单使用" class="headerlink" title="1.2 简单使用"></a><strong>1.2 简单使用</strong></h3><p>一个简单的实例如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span>&#123;</span><br><span class="line">    ConcurrentSkipListMap&lt;Integer, String&gt; map = <span class="keyword">new</span> ConcurrentSkipListMap&lt;&gt;(</span><br><span class="line">            Comparator.comparingInt(v -&gt; v));</span><br><span class="line"></span><br><span class="line">    <span class="comment">//通过put添加</span></span><br><span class="line">    map.put(<span class="number">1</span>, <span class="string">"a"</span>);</span><br><span class="line">    map.put(<span class="number">2</span>, <span class="string">"b"</span>);</span><br><span class="line">    map.put(<span class="number">3</span>, <span class="string">"c"</span>);</span><br><span class="line">    map.put(-<span class="number">1</span>, <span class="string">"a"</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//线程集合</span></span><br><span class="line">    List&lt;Thread&gt; ts = <span class="keyword">new</span> ArrayList&lt;Thread&gt;(<span class="number">600</span>);</span><br><span class="line">    <span class="comment">//开始时间</span></span><br><span class="line">    <span class="keyword">long</span> start = System.currentTimeMillis();</span><br><span class="line">    <span class="comment">//遍历线程集合，构建每个线程，每个线程都分别调用线程安全和不安全的计数器</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; <span class="number">100</span>; j++) &#123;</span><br><span class="line">        Thread t = <span class="keyword">new</span> Thread(<span class="keyword">new</span> Runnable() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">                <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">100</span>; i++) &#123;<span class="comment">//分别调用安全和不安全的计数器</span></span><br><span class="line">                    map.put(i, i + <span class="string">""</span>);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">        ts.add(t);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//遍历执行所有线程</span></span><br><span class="line">    <span class="keyword">for</span> (Thread t : ts) &#123;</span><br><span class="line">        t.start();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//等待所有线程执行完成</span></span><br><span class="line">    <span class="keyword">for</span> (Thread t : ts) &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            t.join();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//打印最终结果</span></span><br><span class="line">    map.forEach((k,v) -&gt; &#123;System.out.println(<span class="string">"k: "</span> + k + <span class="string">" v: "</span> + v);&#125;);</span><br><span class="line">    System.out.println(System.currentTimeMillis() - start);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>运行结果如下：</p><figure class="highlight groovy"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">k:</span> <span class="number">-1</span> <span class="string">v:</span> a</span><br><span class="line"><span class="string">k:</span> <span class="number">0</span> <span class="string">v:</span> <span class="number">0</span></span><br><span class="line"><span class="string">k:</span> <span class="number">1</span> <span class="string">v:</span> <span class="number">1</span></span><br><span class="line"><span class="string">k:</span> <span class="number">2</span> <span class="string">v:</span> <span class="number">2</span></span><br><span class="line">...</span><br><span class="line"><span class="string">k:</span> <span class="number">98</span> <span class="string">v:</span> <span class="number">98</span></span><br><span class="line"><span class="string">k:</span> <span class="number">99</span> <span class="string">v:</span> <span class="number">99</span></span><br><span class="line"><span class="number">82</span></span><br></pre></td></tr></table></figure><p>把 ConcurrentSkipListMap 替换为 TreeMap 。</p><figure class="highlight groovy"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">k:</span> <span class="number">-1</span> <span class="string">v:</span> a</span><br><span class="line"><span class="string">k:</span> <span class="number">0</span> <span class="string">v:</span> <span class="number">0</span></span><br><span class="line"><span class="string">k:</span> <span class="number">1</span> <span class="string">v:</span> <span class="number">1</span></span><br><span class="line"><span class="string">k:</span> <span class="number">2</span> <span class="string">v:</span> <span class="number">2</span></span><br><span class="line"><span class="string">k:</span> <span class="number">3</span> <span class="string">v:</span> <span class="number">3</span></span><br><span class="line"><span class="string">k:</span> <span class="number">4</span> <span class="string">v:</span> <span class="number">4</span></span><br><span class="line"><span class="string">k:</span> <span class="number">5</span> <span class="string">v:</span> <span class="number">5</span></span><br><span class="line"><span class="string">k:</span> <span class="number">6</span> <span class="string">v:</span> <span class="number">6</span></span><br><span class="line"><span class="string">k:</span> <span class="number">7</span> <span class="string">v:</span> <span class="number">7</span></span><br><span class="line"><span class="string">k:</span> <span class="number">12</span> <span class="string">v:</span> <span class="number">12</span></span><br><span class="line"><span class="string">k:</span> <span class="number">8</span> <span class="string">v:</span> <span class="number">8</span></span><br><span class="line"><span class="string">k:</span> <span class="number">9</span> <span class="string">v:</span> <span class="number">9</span></span><br><span class="line"><span class="string">k:</span> <span class="number">10</span> <span class="string">v:</span> <span class="number">10</span></span><br><span class="line"><span class="string">k:</span> <span class="number">11</span> <span class="string">v:</span> <span class="number">11</span></span><br><span class="line"><span class="string">k:</span> <span class="number">12</span> <span class="string">v:</span> <span class="number">12</span></span><br><span class="line">...</span><br><span class="line"><span class="string">k:</span> <span class="number">50</span> <span class="string">v:</span> <span class="number">50</span></span><br><span class="line"><span class="string">k:</span> <span class="number">51</span> <span class="string">v:</span> <span class="number">51</span></span><br><span class="line"><span class="string">k:</span> <span class="number">52</span> <span class="string">v:</span> <span class="number">52</span></span><br><span class="line"><span class="string">k:</span> <span class="number">53</span> <span class="string">v:</span> <span class="number">53</span></span><br><span class="line"><span class="string">k:</span> <span class="number">54</span> <span class="string">v:</span> <span class="number">54</span></span><br><span class="line"><span class="string">k:</span> <span class="number">55</span> <span class="string">v:</span> <span class="number">55</span></span><br><span class="line"><span class="string">k:</span> <span class="number">57</span> <span class="string">v:</span> <span class="number">57</span></span><br><span class="line"><span class="string">k:</span> <span class="number">56</span> <span class="string">v:</span> <span class="number">56</span></span><br><span class="line"><span class="string">k:</span> <span class="number">57</span> <span class="string">v:</span> <span class="number">57</span></span><br><span class="line"><span class="string">k:</span> <span class="number">58</span> <span class="string">v:</span> <span class="number">58</span></span><br><span class="line"><span class="string">k:</span> <span class="number">59</span> <span class="string">v:</span> <span class="number">59</span></span><br><span class="line">...</span><br><span class="line"><span class="string">k:</span> <span class="number">99</span> <span class="string">v:</span> <span class="number">99</span></span><br><span class="line"><span class="number">46</span></span><br></pre></td></tr></table></figure><p>可以得到一个初印象：TreeMap 多线程环境下非线程安全，但单线程的有序映射有较好的性能，而 ConcurrentSkipListMap 则可以在相同需求的多线程场景作为替代品。  </p><hr><h2 id="第二节-跳表"><a href="#第二节-跳表" class="headerlink" title="第二节 跳表"></a><strong>第二节 跳表</strong></h2><h3 id="2-1-概述"><a href="#2-1-概述" class="headerlink" title="2.1 概述"></a><strong>2.1 概述</strong></h3><p> 跳表（SkipList）：是一种优秀的数据结构，<strong>使得包含n个元素的有序序列的查找和插入操作的平均时间复杂度都是 O(logn) ，要优于数组的 O(n) </strong>。</p><p>快速的查询效果是<strong>通过维护一个多层次的链表实现的</strong>，且与前一层（下面一层）链表元素的数量相比，每一层链表中的元素的数量更少（见下图）。一开始时，算法在最稀疏的层次进行搜索，直至需要查找的元素在该层两个相邻的元素中间。这时，算法将跳转到下一个层次，重复刚才的搜索，直到找到需要查找的元素为止。跳过的元素的方法可以是随机性选择或确定性选择，其中前者更为常见。</p><p><img src="https://pic-1258215793.cos.ap-shanghai.myqcloud.com/content/20200701/202007010118.png" alt></p><p><em>一张跳跃列表的示意图。每个带有箭头的框表示一个指针, 而每行是一个稀疏子序列的链表；底部的编号框（黄色）表示有序的数据序列。查找从顶部最稀疏的子序列向下进行, 直至需要查找的元素在该层两个相邻的元素中间。</em></p><h3 id="2-2-算法"><a href="#2-2-算法" class="headerlink" title="2.2 算法"></a><strong>2.2 算法</strong></h3><p>跳跃列表是按层建造的。<strong>底层是一个普通的有序链表</strong>。每个更高层都充当下面列表的<strong>“快速通道”</strong>，这里在第 i 层中的元素按某个固定的概率 p（通常为 1/2 或 1/4 ）出现在第 i+1 层中。每个元素平均出现在 1 / 1-p 个列表中，而最高层的元素（通常是在跳跃列表前端的一个特殊的头元素）在 log~1/p~n 个列表中出现。</p><p>在查找目标元素时，从顶层列表、头元素起步。算法沿着每层链表搜索，直至找到一个大于或等于目标的元素，或者到达当前层列表末尾。如果该元素等于目标元素，则表明该元素已被找到；如果该元素大于目标元素或已到达链表末尾，则退回到当前层的上一个元素，然后转入下一层进行搜索。每层链表中预期的查找步数最多为 1/p ，而层数为 log~1/p~n ，所以查找的总体步数为 -log~p~n / p，由于 p 是常数，查找操作总体的时间复杂度为 O(log n) 。而通过选择不同 p 值，就可以在查找代价和存储代价之间获取平衡。</p><p>跳跃列表不像平衡树等数据结构那样提供对最坏情况的性能保证：由于用来建造跳跃列表采用随机选取元素进入更高层的方法，在小概率情况下会生成一个不平衡的跳跃列表（最坏情况例如最底层仅有一个元素进入了更高层，此时跳跃列表的查找与普通列表一致）。但是在实际中它通常工作良好，随机化平衡方案也比平衡二叉查找树等数据结构中使用的确定性平衡方案容易实现。跳跃列表在并行计算中也很有用：插入可以在跳跃列表不同的部分并行地进行，而不用对数据结构进行全局的重新平衡。</p><h3 id="2-3-实现细节"><a href="#2-3-实现细节" class="headerlink" title="2.3 实现细节"></a><strong>2.3 实现细节</strong></h3><p>因为跳跃列表中的元素可以在多个列表中，所以每个元素可以有多于一个指针。</p><p>跳跃列表的插入和删除的实现与普通的链表操作类似，但高层元素必须在进行多个链表中进行插入或删除。</p><p>跳跃列表的最坏时间性能具有一定随机性，但是可以通过时间复杂度为 O(n) 的遍历操作（例如在打印列表全部内容时）以无随机的算法重整列表的结构，从而使跳跃列表的实际查找时间复杂度尽量符合理论平均值 O(log n) 。</p><h4 id="（1）插入操作"><a href="#（1）插入操作" class="headerlink" title="（1）插入操作"></a><strong>（1）插入操作</strong></h4><p>往跳跃列表中插入一个元素，如图：</p><p><img src="https://pic-1258215793.cos.ap-shanghai.myqcloud.com/content/20200701/Skip_list_add_element-en.gif" alt></p><ol><li>新节点和各层索引节点逐一比较，确定原链表的插入位置，O(log n)。</li><li>把索引插入到原链表，O(1)。</li><li>利用抛硬币的随机方式，决定新节点是否提升为上一级索引。结果为“正”则提升并继续抛硬币，结果为“负”则停止，O(log n)。</li></ol><p>总体上，跳跃表插入操作的时间复杂度是 O(log n) ，而这种数据结构所占空间是2N，既空间复杂度是 O(n) 。</p><h4 id="（2）删除操作"><a href="#（2）删除操作" class="headerlink" title="（2）删除操作"></a><strong>（2）删除操作</strong></h4><p>在索引层找到要删除的节点，依次删除每层相同节点即可。若某层索引在删除后只剩下一个节点，可以删除此层。</p><ol><li>自上而下，查找第一次出现节点的索引，并逐层找到每一层对应的节点，O(log n) 。</li><li>删除每一层查找到的节点，如果该层只剩下1个节点，删除整个一层（原链表除外），O(log n) 。</li></ol><p>总体上，跳跃表删除操作的时间复杂度是 O(log n) 。</p><h3 id="2-4-跳跃表和二叉树的区别"><a href="#2-4-跳跃表和二叉树的区别" class="headerlink" title="2.4 跳跃表和二叉树的区别"></a><strong>2.4 跳跃表和二叉树的区别</strong></h3><ul><li>跳表维持结构平衡的成本较低，完全依靠随机；二叉树则在多次插入删除后，通过再平衡操作来重新调整结构平衡。</li><li>跳表非树结构，分索引节点和底层链表节点，索引节点只有右边和下边两条索引，链表节点则只有下个节点索引，而二叉树节点则有左右子结点。</li></ul><p>补充：Redis通过跳跃表的优化实现Sorted-set维护有序集合，而关系型数据库则采用B+树。</p><hr><h2 id="第三节-源码解析"><a href="#第三节-源码解析" class="headerlink" title="第三节 源码解析"></a><strong>第三节 源码解析</strong></h2><h3 id="1-1-基本结构"><a href="#1-1-基本结构" class="headerlink" title="1.1 基本结构"></a><strong>1.1 基本结构</strong></h3><p><a href="https://docs.oracle.com/javase/8/docs/api/java/util/concurrent/ConcurrentSkipListMap.html" target="_blank" rel="noopener">ConcurrentSkipListMap</a> 中包括 Node 和 Index 两种节点，其中 Node 即普通链表节点，而 Index 则是索引节点。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ConcurrentSkipListMap</span>&lt;<span class="title">K</span>,<span class="title">V</span>&gt; <span class="keyword">extends</span> <span class="title">AbstractMap</span>&lt;<span class="title">K</span>,<span class="title">V</span>&gt;</span></span><br><span class="line"><span class="class">    <span class="keyword">implements</span> <span class="title">ConcurrentNavigableMap</span>&lt;<span class="title">K</span>,<span class="title">V</span>&gt;, <span class="title">Cloneable</span>, <span class="title">Serializable</span> </span>&#123;</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 跳表的最高头索引</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">transient</span> <span class="keyword">volatile</span> HeadIndex&lt;K,V&gt; head;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 维护映射内元素顺序的比较器，可以为空表示自然顺序</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">final</span> Comparator&lt;? <span class="keyword">super</span> K&gt; comparator;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/** 延迟初始化的键集 */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">transient</span> KeySet&lt;K&gt; keySet;</span><br><span class="line">    <span class="comment">/** 延迟初始化的条目集 */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">transient</span> EntrySet&lt;K,V&gt; entrySet;</span><br><span class="line">    <span class="comment">/** 延迟初始化的值集合 */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">transient</span> Values&lt;V&gt; values;</span><br><span class="line">    <span class="comment">/** 延迟初始化的降序键集 */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">transient</span> ConcurrentNavigableMap&lt;K,V&gt; descendingMap;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//链表节点</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">Node</span>&lt;<span class="title">K</span>,<span class="title">V</span>&gt; </span>&#123;</span><br><span class="line">        <span class="keyword">final</span> K key;</span><br><span class="line">        <span class="keyword">volatile</span> Object value;</span><br><span class="line">        <span class="keyword">volatile</span> Node&lt;K,V&gt; next;</span><br><span class="line"></span><br><span class="line">        Node(K key, Object value, Node&lt;K,V&gt; next) &#123;</span><br><span class="line">            <span class="keyword">this</span>.key = key;</span><br><span class="line">            <span class="keyword">this</span>.value = value;</span><br><span class="line">            <span class="keyword">this</span>.next = next;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">         * 创建一个新的标记节点. 标记的区别在于其值字段指向自身。标记节点也具有空键，这一事实在一些地方得到了利用，但这并不能将标记与也具有空键的基本级别标头节点（head.node）区分开。</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        Node(Node&lt;K,V&gt; next) &#123;</span><br><span class="line">            <span class="keyword">this</span>.key = <span class="keyword">null</span>;</span><br><span class="line">            <span class="keyword">this</span>.value = <span class="keyword">this</span>;</span><br><span class="line">            <span class="keyword">this</span>.next = next;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//比较并设置value字段</span></span><br><span class="line">        <span class="function"><span class="keyword">boolean</span> <span class="title">casValue</span><span class="params">(Object cmp, Object val)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">return</span> UNSAFE.compareAndSwapObject(<span class="keyword">this</span>, valueOffset, cmp, val);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//比较并设置next字段</span></span><br><span class="line">        <span class="function"><span class="keyword">boolean</span> <span class="title">casNext</span><span class="params">(Node&lt;K,V&gt; cmp, Node&lt;K,V&gt; val)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">return</span> UNSAFE.compareAndSwapObject(<span class="keyword">this</span>, nextOffset, cmp, val);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">void</span> <span class="title">helpDelete</span><span class="params">(Node&lt;K,V&gt; b, Node&lt;K,V&gt; f)</span> </span>&#123;</span><br><span class="line">            <span class="comment">//重新检查链接，然后在每个调用中仅执行一个help-out阶段，这样可以最大程度地减少帮助线程之间的CAS干扰</span></span><br><span class="line">            <span class="comment">//如果f是此节点的下个节点，b是此节点的前个节点</span></span><br><span class="line">            <span class="keyword">if</span> (f == next &amp;&amp; <span class="keyword">this</span> == b.next) &#123;</span><br><span class="line">                <span class="comment">//如果f为空或f的value字段不等于f，则尝试CAS将新Node节点插入f前</span></span><br><span class="line">                <span class="keyword">if</span> (f == <span class="keyword">null</span> || f.value != f) <span class="comment">// not already marked</span></span><br><span class="line">                    casNext(f, <span class="keyword">new</span> Node&lt;K,V&gt;(f));</span><br><span class="line">                <span class="comment">//否则，用f的下个节点覆盖f</span></span><br><span class="line">                <span class="keyword">else</span></span><br><span class="line">                    b.casNext(<span class="keyword">this</span>, f.next);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Index</span>&lt;<span class="title">K</span>,<span class="title">V</span>&gt; </span>&#123;</span><br><span class="line">        <span class="keyword">final</span> Node&lt;K,V&gt; node;<span class="comment">//对应链表节点，即value</span></span><br><span class="line">        <span class="keyword">final</span> Index&lt;K,V&gt; down;<span class="comment">//下层索引节点</span></span><br><span class="line">        <span class="keyword">volatile</span> Index&lt;K,V&gt; right;<span class="comment">//右边索引节点</span></span><br><span class="line">        </span><br><span class="line">        ...</span><br><span class="line"></span><br><span class="line">        <span class="comment">//比较并设置right字段，CAS set right value</span></span><br><span class="line">        <span class="function"><span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">casRight</span><span class="params">(Index&lt;K,V&gt; cmp, Index&lt;K,V&gt; val)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">return</span> UNSAFE.compareAndSwapObject(<span class="keyword">this</span>, rightOffset, cmp, val);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//是否已删除此索引的节点</span></span><br><span class="line">        <span class="function"><span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">indexesDeletedNode</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            <span class="keyword">return</span> node.value == <span class="keyword">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//尝试CAS索引节点newSucc作为当前节点的新右边节点（插入），并将原右边节点succ右移一位</span></span><br><span class="line">        <span class="function"><span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">link</span><span class="params">(Index&lt;K,V&gt; succ, Index&lt;K,V&gt; newSucc)</span> </span>&#123;</span><br><span class="line">            Node&lt;K,V&gt; n = node;</span><br><span class="line">            newSucc.right = succ;</span><br><span class="line">            <span class="keyword">return</span> n.value != <span class="keyword">null</span> &amp;&amp; casRight(succ, newSucc);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//尝试CAS覆盖当前节点的右边节点succ。如果已知已删除此节点，则失败(强制调用者进行遍历) </span></span><br><span class="line">        <span class="function"><span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">unlink</span><span class="params">(Index&lt;K,V&gt; succ)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">return</span> node.value != <span class="keyword">null</span> &amp;&amp; casRight(succ, succ.right);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// Unsafe mechanics</span></span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> sun.misc.Unsafe UNSAFE;</span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">long</span> rightOffset;</span><br><span class="line">        <span class="keyword">static</span> &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                UNSAFE = sun.misc.Unsafe.getUnsafe();</span><br><span class="line">                Class&lt;?&gt; k = Index.class;</span><br><span class="line">                rightOffset = UNSAFE.objectFieldOffset</span><br><span class="line">                    (k.getDeclaredField(<span class="string">"right"</span>));</span><br><span class="line">            &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> Error(e);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><h3 id="1-2-get"><a href="#1-2-get" class="headerlink" title="1.2 get"></a><strong>1.2 get</strong></h3><p>通过 <code>get()</code> 获取键值对。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> V <span class="title">get</span><span class="params">(Object key)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> doGet(key);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> V <span class="title">doGet</span><span class="params">(Object key)</span> </span>&#123;</span><br><span class="line">    <span class="comment">//键不允许为null</span></span><br><span class="line">    <span class="keyword">if</span> (key == <span class="keyword">null</span>)</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> NullPointerException();</span><br><span class="line">    Comparator&lt;? <span class="keyword">super</span> K&gt; cmp = comparator;</span><br><span class="line">    <span class="comment">//outer配合break，外层循环</span></span><br><span class="line">    outer: <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">        <span class="comment">//内层循环，找到所给键的前驱节点b，并找到键对应节点n</span></span><br><span class="line">        <span class="keyword">for</span> (Node&lt;K,V&gt; b = findPredecessor(key, cmp), n = b.next;;) &#123;</span><br><span class="line">            Object v; <span class="keyword">int</span> c;</span><br><span class="line">            <span class="comment">//找到节点已为null，跳出outer</span></span><br><span class="line">            <span class="keyword">if</span> (n == <span class="keyword">null</span>)</span><br><span class="line">                <span class="keyword">break</span> outer;</span><br><span class="line">            Node&lt;K,V&gt; f = n.next;</span><br><span class="line">            <span class="comment">//若此时数据已发生改变，跳出内层循环，重新查找</span></span><br><span class="line">            <span class="keyword">if</span> (n != b.next)                <span class="comment">// inconsistent read</span></span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="comment">//n节点的值已为null，说明已被删除，调用helpDelete删掉此节点，跳出内层循环，重新查找</span></span><br><span class="line">            <span class="keyword">if</span> ((v = n.value) == <span class="keyword">null</span>) &#123;    <span class="comment">// n is deleted</span></span><br><span class="line">                n.helpDelete(b, f);</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//b已被删除，跳出内层循环，重新查找</span></span><br><span class="line">            <span class="keyword">if</span> (b.value == <span class="keyword">null</span> || v == n)  <span class="comment">// b is deleted</span></span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="comment">//若命中，则返回value</span></span><br><span class="line">            <span class="keyword">if</span> ((c = cpr(cmp, key, n.key)) == <span class="number">0</span>) &#123;</span><br><span class="line">                <span class="meta">@SuppressWarnings</span>(<span class="string">"unchecked"</span>) V vv = (V)v;</span><br><span class="line">                <span class="keyword">return</span> vv;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//所给键小于找到的n节点键，跳出outer</span></span><br><span class="line">            <span class="keyword">if</span> (c &lt; <span class="number">0</span>)</span><br><span class="line">                <span class="keyword">break</span> outer;</span><br><span class="line">            <span class="comment">//否则右移，继续循环判断</span></span><br><span class="line">            b = n;</span><br><span class="line">            n = f;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="1-3-put"><a href="#1-3-put" class="headerlink" title="1.3 put"></a><strong>1.3 put</strong></h3><p>通过 <code>put()</code> 放置键值对，前面和 <code>get()</code> 流程类似，当新增节点时。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> V <span class="title">put</span><span class="params">(K key, V value)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (value == <span class="keyword">null</span>)</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> NullPointerException();</span><br><span class="line">    <span class="keyword">return</span> doPut(key, value, <span class="keyword">false</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> V <span class="title">doPut</span><span class="params">(K key, V value, <span class="keyword">boolean</span> onlyIfAbsent)</span> </span>&#123;</span><br><span class="line">    Node&lt;K,V&gt; z;             <span class="comment">// added node</span></span><br><span class="line">    <span class="keyword">if</span> (key == <span class="keyword">null</span>)</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> NullPointerException();</span><br><span class="line">    Comparator&lt;? <span class="keyword">super</span> K&gt; cmp = comparator;</span><br><span class="line">    outer: <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">        <span class="keyword">for</span> (Node&lt;K,V&gt; b = findPredecessor(key, cmp), n = b.next;;) &#123;</span><br><span class="line">            <span class="keyword">if</span> (n != <span class="keyword">null</span>) &#123;</span><br><span class="line">                Object v; <span class="keyword">int</span> c;</span><br><span class="line">                Node&lt;K,V&gt; f = n.next;</span><br><span class="line">                <span class="keyword">if</span> (n != b.next)               <span class="comment">// inconsistent read</span></span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                <span class="keyword">if</span> ((v = n.value) == <span class="keyword">null</span>) &#123;   <span class="comment">// n is deleted</span></span><br><span class="line">                    n.helpDelete(b, f);</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span> (b.value == <span class="keyword">null</span> || v == n) <span class="comment">// b is deleted</span></span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                <span class="keyword">if</span> ((c = cpr(cmp, key, n.key)) &gt; <span class="number">0</span>) &#123;</span><br><span class="line">                    b = n;</span><br><span class="line">                    n = f;</span><br><span class="line">                    <span class="keyword">continue</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span> (c == <span class="number">0</span>) &#123;</span><br><span class="line">                    <span class="keyword">if</span> (onlyIfAbsent || n.casValue(v, value)) &#123;</span><br><span class="line">                        <span class="meta">@SuppressWarnings</span>(<span class="string">"unchecked"</span>) V vv = (V)v;</span><br><span class="line">                        <span class="keyword">return</span> vv;</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="keyword">break</span>; <span class="comment">// restart if lost race to replace value</span></span><br><span class="line">                &#125;</span><br><span class="line">                <span class="comment">// else c &lt; 0; fall through</span></span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            z = <span class="keyword">new</span> Node&lt;K,V&gt;(key, value, n);</span><br><span class="line">            <span class="keyword">if</span> (!b.casNext(n, z))</span><br><span class="line">                <span class="keyword">break</span>;         <span class="comment">// restart if lost race to append to b</span></span><br><span class="line">            <span class="keyword">break</span> outer;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//非只覆盖value，新增了节点，通过随机数维持平衡</span></span><br><span class="line">    <span class="keyword">int</span> rnd = ThreadLocalRandom.nextSecondarySeed();</span><br><span class="line">    <span class="keyword">if</span> ((rnd &amp; <span class="number">0x80000001</span>) == <span class="number">0</span>) &#123; <span class="comment">// test highest and lowest bits</span></span><br><span class="line">        <span class="keyword">int</span> level = <span class="number">1</span>, max;</span><br><span class="line">        <span class="keyword">while</span> (((rnd &gt;&gt;&gt;= <span class="number">1</span>) &amp; <span class="number">1</span>) != <span class="number">0</span>)</span><br><span class="line">            ++level;</span><br><span class="line">        Index&lt;K,V&gt; idx = <span class="keyword">null</span>;</span><br><span class="line">        HeadIndex&lt;K,V&gt; h = head;</span><br><span class="line">        <span class="keyword">if</span> (level &lt;= (max = h.level)) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= level; ++i)</span><br><span class="line">                idx = <span class="keyword">new</span> Index&lt;K,V&gt;(z, idx, <span class="keyword">null</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> &#123; <span class="comment">// try to grow by one level</span></span><br><span class="line">            level = max + <span class="number">1</span>; <span class="comment">// hold in array and later pick the one to use</span></span><br><span class="line">            <span class="meta">@SuppressWarnings</span>(<span class="string">"unchecked"</span>)Index&lt;K,V&gt;[] idxs =</span><br><span class="line">                (Index&lt;K,V&gt;[])<span class="keyword">new</span> Index&lt;?,?&gt;[level+<span class="number">1</span>];</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= level; ++i)</span><br><span class="line">                idxs[i] = idx = <span class="keyword">new</span> Index&lt;K,V&gt;(z, idx, <span class="keyword">null</span>);</span><br><span class="line">            <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">                h = head;</span><br><span class="line">                <span class="keyword">int</span> oldLevel = h.level;</span><br><span class="line">                <span class="keyword">if</span> (level &lt;= oldLevel) <span class="comment">// lost race to add level</span></span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                HeadIndex&lt;K,V&gt; newh = h;</span><br><span class="line">                Node&lt;K,V&gt; oldbase = h.node;</span><br><span class="line">                <span class="keyword">for</span> (<span class="keyword">int</span> j = oldLevel+<span class="number">1</span>; j &lt;= level; ++j)</span><br><span class="line">                    newh = <span class="keyword">new</span> HeadIndex&lt;K,V&gt;(oldbase, newh, idxs[j], j);</span><br><span class="line">                <span class="keyword">if</span> (casHead(h, newh)) &#123;</span><br><span class="line">                    h = newh;</span><br><span class="line">                    idx = idxs[level = oldLevel];</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// find insertion points and splice in</span></span><br><span class="line">        splice: <span class="keyword">for</span> (<span class="keyword">int</span> insertionLevel = level;;) &#123;</span><br><span class="line">            <span class="keyword">int</span> j = h.level;</span><br><span class="line">            <span class="keyword">for</span> (Index&lt;K,V&gt; q = h, r = q.right, t = idx;;) &#123;</span><br><span class="line">                <span class="keyword">if</span> (q == <span class="keyword">null</span> || t == <span class="keyword">null</span>)</span><br><span class="line">                    <span class="keyword">break</span> splice;</span><br><span class="line">                <span class="keyword">if</span> (r != <span class="keyword">null</span>) &#123;</span><br><span class="line">                    Node&lt;K,V&gt; n = r.node;</span><br><span class="line">                    <span class="comment">// compare before deletion check avoids needing recheck</span></span><br><span class="line">                    <span class="keyword">int</span> c = cpr(cmp, key, n.key);</span><br><span class="line">                    <span class="keyword">if</span> (n.value == <span class="keyword">null</span>) &#123;</span><br><span class="line">                        <span class="keyword">if</span> (!q.unlink(r))</span><br><span class="line">                            <span class="keyword">break</span>;</span><br><span class="line">                        r = q.right;</span><br><span class="line">                        <span class="keyword">continue</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="keyword">if</span> (c &gt; <span class="number">0</span>) &#123;</span><br><span class="line">                        q = r;</span><br><span class="line">                        r = r.right;</span><br><span class="line">                        <span class="keyword">continue</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                <span class="keyword">if</span> (j == insertionLevel) &#123;</span><br><span class="line">                    <span class="keyword">if</span> (!q.link(r, t))</span><br><span class="line">                        <span class="keyword">break</span>; <span class="comment">// restart</span></span><br><span class="line">                    <span class="keyword">if</span> (t.node.value == <span class="keyword">null</span>) &#123;</span><br><span class="line">                        findNode(key);</span><br><span class="line">                        <span class="keyword">break</span> splice;</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="keyword">if</span> (--insertionLevel == <span class="number">0</span>)</span><br><span class="line">                        <span class="keyword">break</span> splice;</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                <span class="keyword">if</span> (--j &gt;= insertionLevel &amp;&amp; j &lt; level)</span><br><span class="line">                    t = t.down;</span><br><span class="line">                q = q.down;</span><br><span class="line">                r = q.right;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="1-4-remove"><a href="#1-4-remove" class="headerlink" title="1.4 remove"></a><strong>1.4 remove</strong></h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> V <span class="title">remove</span><span class="params">(Object key)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> doRemove(key, <span class="keyword">null</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">final</span> V <span class="title">doRemove</span><span class="params">(Object key, Object value)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (key == <span class="keyword">null</span>)</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> NullPointerException();</span><br><span class="line">    Comparator&lt;? <span class="keyword">super</span> K&gt; cmp = comparator;</span><br><span class="line">    outer: <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">        <span class="keyword">for</span> (Node&lt;K,V&gt; b = findPredecessor(key, cmp), n = b.next;;) &#123;</span><br><span class="line">            Object v; <span class="keyword">int</span> c;</span><br><span class="line">            <span class="keyword">if</span> (n == <span class="keyword">null</span>)</span><br><span class="line">                <span class="keyword">break</span> outer;</span><br><span class="line">            Node&lt;K,V&gt; f = n.next;</span><br><span class="line">            <span class="keyword">if</span> (n != b.next)                    <span class="comment">// inconsistent read</span></span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">if</span> ((v = n.value) == <span class="keyword">null</span>) &#123;        <span class="comment">// n is deleted</span></span><br><span class="line">                n.helpDelete(b, f);</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (b.value == <span class="keyword">null</span> || v == n)      <span class="comment">// b is deleted</span></span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">if</span> ((c = cpr(cmp, key, n.key)) &lt; <span class="number">0</span>)</span><br><span class="line">                <span class="keyword">break</span> outer;</span><br><span class="line">            <span class="keyword">if</span> (c &gt; <span class="number">0</span>) &#123;</span><br><span class="line">                b = n;</span><br><span class="line">                n = f;</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (value != <span class="keyword">null</span> &amp;&amp; !value.equals(v))</span><br><span class="line">                <span class="keyword">break</span> outer;</span><br><span class="line">            <span class="keyword">if</span> (!n.casValue(v, <span class="keyword">null</span>))</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">if</span> (!n.appendMarker(f) || !b.casNext(n, f))</span><br><span class="line">                findNode(key);                  <span class="comment">// retry via findNode</span></span><br><span class="line">            <span class="keyword">else</span> &#123;</span><br><span class="line">                findPredecessor(key, cmp);      <span class="comment">// clean index</span></span><br><span class="line">                <span class="keyword">if</span> (head.right == <span class="keyword">null</span>)</span><br><span class="line">                    tryReduceLevel();</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="meta">@SuppressWarnings</span>(<span class="string">"unchecked"</span>) V vv = (V)v;</span><br><span class="line">            <span class="keyword">return</span> vv;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="1-5-findPredecessor"><a href="#1-5-findPredecessor" class="headerlink" title="1.5 findPredecessor"></a><strong>1.5 findPredecessor</strong></h3><p>通过 <code>findPredecessor()</code> 查找给定键和比较器的前驱节点（小）。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 返回一个其键严格小于给定键的base-level节点，如果没有这样的节点，则返回base-level header。</span></span><br><span class="line"><span class="comment"> * 通过不断右移和下移索引，找到对应链表节点，过程中会unlink发现到的已删除节点。</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> Node&lt;K,V&gt; <span class="title">findPredecessor</span><span class="params">(Object key, Comparator&lt;? <span class="keyword">super</span> K&gt; cmp)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (key == <span class="keyword">null</span>)</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> NullPointerException(); <span class="comment">// don't postpone errors</span></span><br><span class="line">    <span class="comment">//外层循环</span></span><br><span class="line">    <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">        <span class="comment">//内层循环，从头索引开始</span></span><br><span class="line">        <span class="keyword">for</span> (Index&lt;K,V&gt; q = head, r = q.right, d;;) &#123;</span><br><span class="line">            <span class="comment">//右边还有节点</span></span><br><span class="line">            <span class="keyword">if</span> (r != <span class="keyword">null</span>) &#123;</span><br><span class="line">                Node&lt;K,V&gt; n = r.node;</span><br><span class="line">                K k = n.key;</span><br><span class="line">                <span class="comment">//右边索引对应Node所存值为空，则删掉它，进入下一次循环</span></span><br><span class="line">                <span class="keyword">if</span> (n.value == <span class="keyword">null</span>) &#123;</span><br><span class="line">                    <span class="keyword">if</span> (!q.unlink(r)) <span class="comment">//删掉右边索引节点</span></span><br><span class="line">                        <span class="keyword">break</span>;           <span class="comment">// restart</span></span><br><span class="line">                    r = q.right;         <span class="comment">// 更新右边索引节点（原右边节点的右边节点）</span></span><br><span class="line">                    <span class="keyword">continue</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="comment">//若所给键大于右边节点的键，则指针右移，进入下一次循环</span></span><br><span class="line">                <span class="keyword">if</span> (cpr(cmp, key, k) &gt; <span class="number">0</span>) &#123;</span><br><span class="line">                    q = r;</span><br><span class="line">                    r = r.right;</span><br><span class="line">                    <span class="keyword">continue</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//当前索引节点没有下层索引，直接返回其Node节点</span></span><br><span class="line">            <span class="keyword">if</span> ((d = q.down) == <span class="keyword">null</span>)</span><br><span class="line">                <span class="keyword">return</span> q.node;</span><br><span class="line">            <span class="comment">//否则指针q下移到下层索引，同时更新d</span></span><br><span class="line">            q = d;</span><br><span class="line">            r = d.right;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="1-6-findNode"><a href="#1-6-findNode" class="headerlink" title="1.6 findNode"></a><strong>1.6 findNode</strong></h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Returns node holding key or null if no such, clearing out any</span></span><br><span class="line"><span class="comment"> * deleted nodes seen along the way.  Repeatedly traverses at</span></span><br><span class="line"><span class="comment"> * base-level looking for key starting at predecessor returned</span></span><br><span class="line"><span class="comment"> * from findPredecessor, processing base-level deletions as</span></span><br><span class="line"><span class="comment"> * encountered. Some callers rely on this side-effect of clearing</span></span><br><span class="line"><span class="comment"> * deleted nodes.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * Restarts occur, at traversal step centered on node n, if:</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> *   (1) After reading n's next field, n is no longer assumed</span></span><br><span class="line"><span class="comment"> *       predecessor b's current successor, which means that</span></span><br><span class="line"><span class="comment"> *       we don't have a consistent 3-node snapshot and so cannot</span></span><br><span class="line"><span class="comment"> *       unlink any subsequent deleted nodes encountered.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> *   (2) n's value field is null, indicating n is deleted, in</span></span><br><span class="line"><span class="comment"> *       which case we help out an ongoing structural deletion</span></span><br><span class="line"><span class="comment"> *       before retrying.  Even though there are cases where such</span></span><br><span class="line"><span class="comment"> *       unlinking doesn't require restart, they aren't sorted out</span></span><br><span class="line"><span class="comment"> *       here because doing so would not usually outweigh cost of</span></span><br><span class="line"><span class="comment"> *       restarting.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> *   (3) n is a marker or n's predecessor's value field is null,</span></span><br><span class="line"><span class="comment"> *       indicating (among other possibilities) that</span></span><br><span class="line"><span class="comment"> *       findPredecessor returned a deleted node. We can't unlink</span></span><br><span class="line"><span class="comment"> *       the node because we don't know its predecessor, so rely</span></span><br><span class="line"><span class="comment"> *       on another call to findPredecessor to notice and return</span></span><br><span class="line"><span class="comment"> *       some earlier predecessor, which it will do. This check is</span></span><br><span class="line"><span class="comment"> *       only strictly needed at beginning of loop, (and the</span></span><br><span class="line"><span class="comment"> *       b.value check isn't strictly needed at all) but is done</span></span><br><span class="line"><span class="comment"> *       each iteration to help avoid contention with other</span></span><br><span class="line"><span class="comment"> *       threads by callers that will fail to be able to change</span></span><br><span class="line"><span class="comment"> *       links, and so will retry anyway.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * The traversal loops in doPut, doRemove, and findNear all</span></span><br><span class="line"><span class="comment"> * include the same three kinds of checks. And specialized</span></span><br><span class="line"><span class="comment"> * versions appear in findFirst, and findLast and their</span></span><br><span class="line"><span class="comment"> * variants. They can't easily share code because each uses the</span></span><br><span class="line"><span class="comment"> * reads of fields held in locals occurring in the orders they</span></span><br><span class="line"><span class="comment"> * were performed.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> key the key</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> node holding key, or null if no such</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> Node&lt;K,V&gt; <span class="title">findNode</span><span class="params">(Object key)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (key == <span class="keyword">null</span>)</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> NullPointerException(); <span class="comment">// don't postpone errors</span></span><br><span class="line">    Comparator&lt;? <span class="keyword">super</span> K&gt; cmp = comparator;</span><br><span class="line">    outer: <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">        <span class="keyword">for</span> (Node&lt;K,V&gt; b = findPredecessor(key, cmp), n = b.next;;) &#123;</span><br><span class="line">            Object v; <span class="keyword">int</span> c;</span><br><span class="line">            <span class="keyword">if</span> (n == <span class="keyword">null</span>)</span><br><span class="line">                <span class="keyword">break</span> outer;</span><br><span class="line">            Node&lt;K,V&gt; f = n.next;</span><br><span class="line">            <span class="keyword">if</span> (n != b.next)                <span class="comment">// inconsistent read</span></span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">if</span> ((v = n.value) == <span class="keyword">null</span>) &#123;    <span class="comment">// n is deleted</span></span><br><span class="line">                n.helpDelete(b, f);</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (b.value == <span class="keyword">null</span> || v == n)  <span class="comment">// b is deleted</span></span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">if</span> ((c = cpr(cmp, key, n.key)) == <span class="number">0</span>)</span><br><span class="line">                <span class="keyword">return</span> n;</span><br><span class="line">            <span class="keyword">if</span> (c &lt; <span class="number">0</span>)</span><br><span class="line">                <span class="keyword">break</span> outer;</span><br><span class="line">            b = n;</span><br><span class="line">            n = f;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><p><em>参考博客和文章书籍等：</em></p><blockquote><p><a href="https://zh.wikipedia.org/wiki/%E8%B7%B3%E8%B7%83%E5%88%97%E8%A1%A8" target="_blank" rel="noopener">跳跃列表</a></p></blockquote><blockquote><p><a href="https://www.baeldung.com/java-concurrent-skip-list-map" target="_blank" rel="noopener">Guide to the ConcurrentSkipListMap</a></p></blockquote><p><em>因博客主等未标明不可引用，若部分内容涉及侵权请及时告知，我会尽快修改和删除相关内容</em></p>]]></content>
    
    <summary type="html">
    
      简单整理了下Java中ConcurrentSkipListMap的实现原理，包括：概述，跳表，源码解析等内容。
    
    </summary>
    
      <category term="技术文档" scheme="http://linyishui.top/categories/%E6%8A%80%E6%9C%AF%E6%96%87%E6%A1%A3/"/>
    
    
      <category term="java" scheme="http://linyishui.top/tags/java/"/>
    
      <category term="lock" scheme="http://linyishui.top/tags/lock/"/>
    
  </entry>
  
  <entry>
    <title>算法复习 (二) 查找-散列表</title>
    <link href="http://linyishui.top/2020070501.html"/>
    <id>http://linyishui.top/2020070501.html</id>
    <published>2020-07-05T09:35:09.000Z</published>
    <updated>2020-08-06T16:34:57.518Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="散列表"><a href="#散列表" class="headerlink" title="散列表"></a><strong>散列表</strong></h1><h2 id="第一节-概述"><a href="#第一节-概述" class="headerlink" title="第一节 概述"></a><strong>第一节 概述</strong></h2><h3 id="1-1-什么是散列表"><a href="#1-1-什么是散列表" class="headerlink" title="1.1 什么是散列表"></a><strong>1.1 什么是散列表</strong></h3><p><strong>散列表</strong>（<strong>Hash table</strong>，也叫<strong>哈希表</strong>），是根据<strong>键</strong>（Key）而直接访问在内存储存位置的数据结构。也就是说，它通过计算一个关于键值的函数，将所需查询的数据映射到表中一个位置来访问记录，这加快了查找速度。这个映射函数称做<strong>散列函数</strong>，存放记录的数组称做<strong>散列表</strong>。</p><p>通过散列表我们可以在一般应用中拥有（均摊后）<strong>常数级别</strong>的查找和插入操作。</p><p>散列表的查找分为两步：</p><ol><li>通过<strong>散列函数</strong>将被查找的键转化为数组的一个索引。</li><li>处理<strong>碰撞冲突</strong>的情况。</li></ol><h3 id="1-2-散列函数"><a href="#1-2-散列函数" class="headerlink" title="1.2 散列函数"></a><strong>1.2 散列函数</strong></h3><p>散列函数的计算过程将键转化为数组的索引：如果我们有一个能保持M个键值对的数组，就需要一个能够将任意键转化为该数组范围内的索引（[0,M-1]）的<strong>散列函数</strong>。</p><p>严格来说，<strong>对于每种类型的键都需要一个与之对应的散列函数</strong>。</p><ul><li>正整数：常用<strong>除留余数法</strong>，数组大小为素数M，任意整数k除以M获得余数。选用素数的原因是避免无法均匀的散列。</li><li>浮点数：0到1间的实数，可以乘以M并四舍五入得到一个0至M-1间的索引值。但这种方法使键的高位占更大作用，低位则没什么影响，Java中采用的修正方法是<strong>将键表示为二进制再使用除留余数法</strong>。</li><li>字符串：也可以使用<strong>除留余数法</strong>，Java中有 <code>charAt()</code> 函数能返回一个char值，即一个非负16位整数。把字符串当作一个N位的R进制值，除以M并取余。Java默认使用类似 <code>Horner</code> 方法的算法，用N次乘法、加法和取余计算一个字符串的散列值。</li><li>组合键：键类型包含多种类型，如多个整型变量组合，比如Date类型，可以通过 <code>int hash = (((day * R + month) % M ) * R + year) % M</code> 来计算散列值。只要R足够小，就可以得到一个0至M-1间的散列值。</li></ul><p>Java为很多常用的数据类型重写了 <code>hashcode()</code> 方法（如String、Integer、Double、File和URL）。</p><h3 id="1-3-哈希碰撞"><a href="#1-3-哈希碰撞" class="headerlink" title="1.3 哈希碰撞"></a><strong>1.3 哈希碰撞</strong></h3><p>对不同的关键字可能得到同一散列地址，即 k~1~ != k~2~ ，而 f(k~1~) == f(k~2~) ，这种现象称为<strong>冲突</strong>（英语：Collision），也叫哈希冲突/碰撞。</p><p>两种处理哈希碰撞的方法：</p><ul><li><strong>开放地址法</strong>：当遇到哈希冲突时，依照增量规则向后取地址直到有未被占用地址为止。实例公式：<code>Hash(key) = (Hash(key) + di) mod TableSize</code> ，di表示增量序列，di不同的增长可分为：<ul><li><strong>线性探测法</strong>：di = i++ [1,2,3……，TableSize-1] ，即依次按地址后取，当一个键散列值被占用时，直接检查散列表的下一个位置（索引值加1），弊端是元素积聚，没有均匀的分布元素，导致性能降低，多查询了越来越多的无关项。</li><li><strong>二次探测法</strong>：di = (i++)^2^ * (di  / |di|) [1,-1,4,-4,9,-9……] ，弊端是当剩余空间较少时，在还有空间的情况下会极有可能插入失败。</li><li><strong>双散列探测法</strong>：di = (i++) * Hash2(key) [1H,2H,3H……] ，<code>Hash2(key) = p – (key mod p)</code> ，<code>Hash2(key) = (key % 97) + 1</code> ，其中p为小于表长的任意素数。通过另外一个散列函数来减少积聚问题，第二个函数需要排出散列值为0的情况，计算的散列值要和表长互素。</li></ul></li><li><strong>链地址法/拉链法</strong>：即将散列表每一个地址都对应一个链表，似乎链表会占用更多的空间，但实际使用中，因为装填因子的存在所以链地址法可能会更节省空间。通常情况下哈希表都非常高效，插入或查询都是O(1)，最差情况是集中映射到少量地址上，就会退化为链表查询，若被人通过Hash攻击的方式产生大量的碰撞，会导致本来高效的服务处理变得异常缓慢，可以通过限制表单提交长度等方法来防止此类攻击。</li></ul><hr><h2 id="第二节-实现"><a href="#第二节-实现" class="headerlink" title="第二节 实现"></a><strong>第二节 实现</strong></h2><h3 id="2-1-基于拉链法的散列表"><a href="#2-1-基于拉链法的散列表" class="headerlink" title="2.1 基于拉链法的散列表"></a><strong>2.1 基于拉链法的散列表</strong></h3><p>下面这个简单的符号表维护了一条链表数组，通过散列函数来为每个键选择链表。创建 <code>st[]</code> 时需要进行类型转换，因为 Java 不允许泛型的数组。默认构造器会使用997条链表，此段简单的代码已经可以在已知符号表大小时得到不错的性能，当然还可以添加<strong>动态调整链表数组的大小</strong>（rehash-再散列）的功能，从而能在任意大小都能保证链表的短小。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SeparateChainingHashST</span>&lt;<span class="title">Key</span>, <span class="title">Value</span>&gt; </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> N;<span class="comment">//键值对总数</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> M;<span class="comment">//散列表大小</span></span><br><span class="line">    <span class="keyword">private</span> SequentialSearchST&lt;Key, Value&gt;[] st;<span class="comment">//存放链表对象的数组</span></span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">SeparateChainingHashST</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">this</span>(<span class="number">997</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">SeparateChainingHashST</span><span class="params">(<span class="keyword">int</span> M)</span></span>&#123;</span><br><span class="line">        <span class="comment">//创建M条链表</span></span><br><span class="line">        <span class="keyword">this</span>.M = M;</span><br><span class="line">        st = (SequentialSearchST&lt;Key, Value&gt;[]) <span class="keyword">new</span> SequentialSearchST[M];</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>;i &lt; M;i++)</span><br><span class="line">            st[i] = <span class="keyword">new</span> SequentialSearchST();</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">int</span> <span class="title">hash</span><span class="params">(Key key)</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> (key.hashCode() &amp; <span class="number">0x7fffffff</span>) % M;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> Value <span class="title">get</span><span class="params">(Key key)</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> (Value) st[hash(key)].get(key);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">put</span><span class="params">(Key key, Value val)</span></span>&#123;</span><br><span class="line">        st[hash(key)].put(key, val);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="2-2-基于线性探测法的散列表"><a href="#2-2-基于线性探测法的散列表" class="headerlink" title="2.2 基于线性探测法的散列表"></a><strong>2.2 基于线性探测法的散列表</strong></h3><p>线性探测表<strong>通过空（null）来表示一簇键的结束</strong>，对于删除操作来说，直接将对应元素值设置为 <code>null</code> 是不行的，会导致此位置之后的元素无法被查找。正确的做法是将右侧所有键重新插入散列表。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">LinearProbingHashST</span>&lt;<span class="title">Key</span>, <span class="title">Value</span>&gt; </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> N;<span class="comment">//键值对总数</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> M = <span class="number">16</span>;<span class="comment">//线性探测表大小</span></span><br><span class="line">    <span class="keyword">private</span> key[] keys;<span class="comment">//键数组</span></span><br><span class="line">    <span class="keyword">private</span> value[] vals;<span class="comment">//值数组</span></span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">LinearProbingHashST</span><span class="params">()</span></span>&#123;</span><br><span class="line">        keys = (key[]) <span class="keyword">new</span> Object[M];</span><br><span class="line">        vals = (value[]) <span class="keyword">new</span> Object[M];</span><br><span class="line">    &#125;    </span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">int</span> <span class="title">hash</span><span class="params">(Key key)</span></span>&#123;<span class="comment">//散列函数</span></span><br><span class="line">        <span class="keyword">return</span> (key.hashCode() &amp; <span class="number">0x7fffffff</span>) % M;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">resize</span><span class="params">(<span class="keyword">int</span> cap)</span></span>&#123;<span class="comment">//再散列</span></span><br><span class="line">        <span class="comment">//实例化新的线性探测表</span></span><br><span class="line">        LinearProbingHashST&lt;Key, Value&gt; t;</span><br><span class="line">        t = <span class="keyword">new</span> LinearProbingHashST&lt;Key, Value&gt;(cap);</span><br><span class="line">        <span class="comment">//循环遍历拷贝旧表元素</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>;i &lt; M;i++)</span><br><span class="line">        <span class="keyword">if</span>(keys[i] != <span class="keyword">null</span>)</span><br><span class="line">                t.put(keys[i], vals[i]);</span><br><span class="line">        <span class="comment">//更新当前引用，t为局部变量</span></span><br><span class="line">        keys = t.keys;</span><br><span class="line">        vals = t.vals;</span><br><span class="line">        M = t.M;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">put</span><span class="params">(Key key, Value val)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(N &gt;= M/<span class="number">2</span>) resize(M*<span class="number">2</span>); <span class="comment">//M加倍扩容散列表</span></span><br><span class="line">        <span class="keyword">int</span> i;</span><br><span class="line">        <span class="comment">//i散列得到索引，若键相等则替换值，否则检查下一个位置，直到对应key为空</span></span><br><span class="line">        <span class="keyword">for</span>(i = hash(key);keys[i] != <span class="keyword">null</span>;i = (i + <span class="number">1</span>) % M)</span><br><span class="line">            <span class="keyword">if</span>(keys[i].equals(key))&#123;</span><br><span class="line">                vals[i] = val;</span><br><span class="line">                <span class="keyword">return</span>;</span><br><span class="line">            &#125;</span><br><span class="line"><span class="comment">//将键值放入当前i</span></span><br><span class="line">        keys[i] = key;</span><br><span class="line">        vals[i] = val;</span><br><span class="line">        N++;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> Value <span class="title">get</span><span class="params">(Key key)</span></span>&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = hash(key);keys[i] != <span class="keyword">null</span>;i = (i + <span class="number">1</span>) % M)</span><br><span class="line">            <span class="keyword">if</span>(keys[i].equals(key))</span><br><span class="line">                <span class="keyword">return</span> vals[i];</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">delete</span><span class="params">(Key key)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(!contains(key)) <span class="keyword">return</span>;</span><br><span class="line">        <span class="keyword">int</span> i = hash(key);</span><br><span class="line">        <span class="comment">//遍历键簇直到找到对应key</span></span><br><span class="line">        <span class="keyword">while</span>(!key.equals(key[i]))</span><br><span class="line">            i = (i + <span class="number">1</span>) % M;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">//先将对应索引置空</span></span><br><span class="line">        keys[i] = <span class="keyword">null</span>;</span><br><span class="line">        vals[i] = <span class="keyword">null</span>;</span><br><span class="line">        <span class="comment">//更新i到下一个位置</span></span><br><span class="line">        i = (i + <span class="number">1</span>) % M;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">//循环将后面元素重新加入散列表，直到遍历到下一个空</span></span><br><span class="line">        <span class="keyword">while</span>(keys[i] != <span class="keyword">null</span>)&#123;</span><br><span class="line">            Key keyToRedo = keys[i];</span><br><span class="line">            Value valueToRedo = vals[i];</span><br><span class="line">        keys[i] = <span class="keyword">null</span>;</span><br><span class="line">        vals[i] = <span class="keyword">null</span>;</span><br><span class="line">            N--;</span><br><span class="line">            put(keyToRedo, valueToRedo);</span><br><span class="line">            i = (i + <span class="number">1</span>) % M;</span><br><span class="line">        &#125;</span><br><span class="line">        N--;</span><br><span class="line">        <span class="comment">//若此时键值对总数达到1/8表大小，则再散列缩小</span></span><br><span class="line">        <span class="keyword">if</span>(N &gt; <span class="number">0</span> &amp;&amp; N == M/<span class="number">8</span>) </span><br><span class="line">            resize(M/<span class="number">2</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><h2 id="第三节-查找总结"><a href="#第三节-查找总结" class="headerlink" title="第三节 查找总结"></a><strong>第三节 查找总结</strong></h2><h3 id="3-1-各种符号表渐进性能的总结"><a href="#3-1-各种符号表渐进性能的总结" class="headerlink" title="3.1 各种符号表渐进性能的总结"></a><strong>3.1 各种符号表渐进性能的总结</strong></h3><p><img src="https://pic-1258215793.cos.ap-shanghai.myqcloud.com/content/20200701/202007010117.jpg" alt></p><hr><p><em>参考博客和文章书籍等：</em></p><blockquote><p>《算法 第4版》</p></blockquote><p><em>因博客主等未标明不可引用，若部分内容涉及侵权请及时告知，我会尽快修改和删除相关内容</em></p>]]></content>
    
    <summary type="html">
    
      简单整理了散列表的相关内容，内容包括：概述（什么是散列表、散列函数、哈希碰撞），实现（基于拉链法的散列表、基于线性探测法的散列表），查找总结。
    
    </summary>
    
      <category term="技术文档" scheme="http://linyishui.top/categories/%E6%8A%80%E6%9C%AF%E6%96%87%E6%A1%A3/"/>
    
    
      <category term="hash" scheme="http://linyishui.top/tags/hash/"/>
    
      <category term="algorithm" scheme="http://linyishui.top/tags/algorithm/"/>
    
  </entry>
  
  <entry>
    <title>B树和B+树</title>
    <link href="http://linyishui.top/2020070201.html"/>
    <id>http://linyishui.top/2020070201.html</id>
    <published>2020-07-02T08:40:04.000Z</published>
    <updated>2020-08-05T16:11:59.571Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="B树和B-树"><a href="#B树和B-树" class="headerlink" title="B树和B+树"></a><strong>B树和B+树</strong></h1><h2 id="第一节-B树"><a href="#第一节-B树" class="headerlink" title="第一节 B树"></a><strong>第一节 B树</strong></h2><h3 id="1-1-什么是B树"><a href="#1-1-什么是B树" class="headerlink" title="1.1 什么是B树"></a><strong>1.1 什么是B树</strong></h3><p>B树是一种<strong>自平衡</strong>的树，能够保持数据<strong>有序</strong>。保证查找数据、顺序访问、插入数据、删除等操作都能在<strong>对数时间</strong>内完成。</p><p>B树也属于二叉查找树，<strong>一个节点允许拥有两个以上的子节点</strong>。与平衡二叉树不同的是，B树适用于读写相对较大的数据块的存储系统，如磁盘。</p><p>B树减少定位记录时所经历的中间过程，从而加快存取速度。</p><p><strong>2-3树、红黑树都是常见的B树</strong>。</p><h3 id="1-2-应用场景"><a href="#1-2-应用场景" class="headerlink" title="1.2 应用场景"></a><strong>1.2 应用场景</strong></h3><p>B树这种数据结构可以用来描述外部存储。常被应用在<strong>数据库</strong>和<strong>文件系统</strong>的实现上。</p><h3 id="1-3-描述"><a href="#1-3-描述" class="headerlink" title="1.3 描述"></a><strong>1.3 描述</strong></h3><p>几个定义：</p><ul><li><strong>内部节点</strong>：内部节点是除叶子节点和根节点之外的所有节点。它们通常被表示为一组有序的元素和指向子节点的指针。</li><li><strong>根节点</strong>：根节点拥有的子节点数量的上限和内部节点相同，但是没有下限。</li><li><strong>叶子节点</strong>：叶子节点对元素的数量有相同的限制，但是没有子节点，也没有指向子节点的指针。</li></ul><p>B树的内部结点（非叶子）可以拥有可变数量的子结点。因为子结点可变数量这一特性，B树不需要像其他平衡二叉树那样频繁的进行重新保持平衡的操作，但相应的也造成了空间浪费（以空间换时间）。</p><p><img src="https://pic-1258215793.cos.ap-shanghai.myqcloud.com/content/20200601/400px-B-tree.svg.png" alt></p><p>子节点数量的上界和下界依特定的实现而设置。例如，在一个2-3 B树（通常简称<a href="https://zh.wikipedia.org/wiki/2-3树" target="_blank" rel="noopener">2-3树</a>），每一个内部节点只能有2或3个子节点。</p><h3 id="1-4-操作"><a href="#1-4-操作" class="headerlink" title="1.4 操作"></a><strong>1.4 操作</strong></h3><h4 id="（1）搜索"><a href="#（1）搜索" class="headerlink" title="（1）搜索"></a><strong>（1）搜索</strong></h4><p>B树的搜索和二叉搜索树类似：从根节点开始，从上到下<strong>递归的遍历树</strong>。在每一层上，搜索的范围被减小到包含了搜索值的子树中（左小右大）。子树值的范围被它的父节点的键确定。</p><h4 id="（2）插入"><a href="#（2）插入" class="headerlink" title="（2）插入"></a><strong>（2）插入</strong></h4><p><img src="https://pic-1258215793.cos.ap-shanghai.myqcloud.com/content/20200601/B_tree_insertion_example.png" alt></p><p>所有的插入都从根节点开始。要插入一个新的元素，首先搜索这棵树找到新元素应该被添加到的对应节点。将新元素插入到这一节点中的步骤如下：</p><ol><li>如果节点拥有的元素数量小于最大值，那么有空间容纳新的元素。将新元素插入到这一节点，且保持节点中元素有序。</li><li>否则的话这一节点已经满了，将它平均地分裂成两个节点：<ol><li>从该节点的原有元素和新的元素中选择出中位数。</li><li>小于这一中位数的元素放入左边节点，大于这一中位数的元素放入右边节点，中位数作为分隔值。</li><li>分隔值被插入到父节点中，这可能会造成父节点分裂，分裂父节点时可能又会使它的父节点分裂，以此类推。如果没有父节点（这一节点是根节点），就创建一个新的根节点（增加了树的高度）。</li></ol></li></ol><h4 id="（3）删除叶子节点中的元素"><a href="#（3）删除叶子节点中的元素" class="headerlink" title="（3）删除叶子节点中的元素"></a><strong>（3）删除叶子节点中的元素</strong></h4><ol><li>搜索要删除的元素。</li><li>如果它在叶子节点，将它从中删除。</li><li>如果发生了下溢出，按照后面<strong>删除后重新平衡</strong>部分的描述重新调整树。</li></ol><h4 id="（4）删除内部节点中的元素"><a href="#（4）删除内部节点中的元素" class="headerlink" title="（4）删除内部节点中的元素"></a><strong>（4）删除内部节点中的元素</strong></h4><p>内部节点中的每一个元素都作为分隔两颗子树的分隔值，因此我们需要重新划分。值得注意的是左子树中最大的元素仍然小于分隔值。同样的，右子树中最小的元素仍然大于分隔值。这两个元素都在叶子节点中，并且任何一个都可以作为两颗子树的新分隔值。算法的描述如下：</p><ol><li>选择一个新的分隔符（左子树中最大的元素或右子树中最小的元素），将它从叶子节点中移除，替换掉被删除的元素作为新的分隔值。</li><li>前一步删除了一个叶子节点中的元素。如果这个叶子节点拥有的元素数量小于最低要求，那么从这一叶子节点开始重新进行平衡。</li></ol><h4 id="（5）删除后的重新平衡"><a href="#（5）删除后的重新平衡" class="headerlink" title="（5）删除后的重新平衡"></a><strong>（5）删除后的重新平衡</strong></h4><p>重新平衡从叶子节点开始向根节点进行，直到树重新平衡（自底向上）。如果删除节点中的一个元素使该节点的元素数量低于最小值，那么一些元素必须被重新分配。通常，移动一个元素数量大于最小值的兄弟节点中的元素。如果兄弟节点都没有多余的元素，那么缺少元素的节点就必须要和他的兄弟节点<strong>合并</strong>。合并可能导致父节点失去了分隔值，所以父节点可能缺少元素并需要重新平衡。合并和重新平衡可能一直进行到根节点，根节点变成惟一缺少元素的节点。重新平衡树的算法如下：</p><ul><li>如果缺少元素节点的右兄弟存在且拥有多余的元素，那么向左旋转：<ol><li>将父节点的分隔值复制到缺少元素节点的最后（分隔值被移下来；缺少元素的节点现在有最小数量的元素）。</li><li>将父节点的分隔值替换为右兄弟的第一个元素（右兄弟失去了一个节点但仍然拥有最小数量的元素）。</li><li>树又重新平衡。</li></ol></li><li>否则，如果缺少元素节点的左兄弟存在且拥有多余的元素，那么向右旋转：<ol><li>将父节点的分隔值复制到缺少元素节点的第一个节点（分隔值被移下来；缺少元素的节点现在有最小数量的元素）。</li><li>将父节点的分隔值替换为左兄弟的最后一个元素（左兄弟失去了一个节点但仍然拥有最小数量的元素）。</li><li>树又重新平衡。</li></ol></li><li>否则，如果它的两个直接兄弟节点都只有最小数量的元素，那么将它与一个直接兄弟节点以及父节点中它们的分隔值合并：<ol><li>将分隔值复制到左边的节点（左边的节点可以是缺少元素的节点或者拥有最小数量元素的兄弟节点）。</li><li>将右边节点中所有的元素移动到左边节点（左边节点现在拥有最大数量的元素，右边节点为空）。</li><li>将父节点中的分隔值和空的右子树移除（父节点失去了一个元素）。<ul><li>如果父节点是根节点并且没有元素了，那么释放它并且让合并之后的节点成为新的根节点（树的深度减小）。</li><li>否则，如果父节点的元素数量小于最小值，重新平衡父节点。</li></ul></li></ol></li></ul><h3 id="1-5-变体"><a href="#1-5-变体" class="headerlink" title="1.5 变体"></a><strong>1.5 变体</strong></h3><p>B树在内部结点上存储键值，但不需要在叶子结点上存储这些键值的记录。</p><ul><li><strong>B+树</strong>：<ul><li>这些键值的拷贝被存储在内部结点；</li><li>键值和记录存储在叶子结点；</li><li>一个叶子结点可以包含一个指针，指向另一个叶子结点以加速顺序存取。</li></ul></li><li><strong>B*树</strong>：分支出更多的内部邻居节点以保持内部节点更密集地填充。此变体要求非根节点至少2/3填充，而不是1/2。为了维持这样的结构，当一个节点填满之后将不会再立即分割节点，而是将它的键值与下一个节点共享。当两个节点都填满之后，分割成3个节点。</li><li>计数B树存储，每一树都带有一个指针和其指向子树的节点数目。这就允许了以键值为序快速查找第N笔记录，或是统计2笔记录之间的记录数目，还有其他很多相关的操作。</li></ul><h3 id="1-6-B树与平衡二叉树的区别"><a href="#1-6-B树与平衡二叉树的区别" class="headerlink" title="1.6 B树与平衡二叉树的区别"></a><strong>1.6 B树与平衡二叉树的区别</strong></h3><p>平衡二叉树通常是指查找路径只有两种（即只有二叉），而B树则不仅仅二叉，所以也叫<strong>平衡多路查找树</strong>。</p><p>B树相比平衡二叉树在每个结点所包含的内容更多，在应用到数据库中的时候，充分利用了磁盘块的原理（磁盘数据存储是采用块的形式存储的，每个块的大小为4K，每次IO进行数据读取时，同一个磁盘块的数据可以一次性读取出来）把结点大小限制和充分使用在磁盘块大小范围。所以树的结点能包含更多的内容后，树的层级比原来的二叉树少了，就可以减少数据查找的次数和复杂度。</p><hr><h2 id="第二节-B-树"><a href="#第二节-B-树" class="headerlink" title="第二节 B+树"></a><strong>第二节 B+树</strong></h2><h3 id="2-1-什么是B-树"><a href="#2-1-什么是B-树" class="headerlink" title="2.1 什么是B+树"></a><strong>2.1 什么是B+树</strong></h3><p><strong>B+ 树</strong>是一种树数据结构，通常用于数据库和操作系统的文件系统中。B+ 树的特点是<strong>能够保持数据稳定有序</strong>，其<strong>插入与修改拥有较稳定的对数时间复杂度</strong>。B+ 树元素<strong>自底向上插入</strong>，这与二叉树恰好相反。</p><p>B+ 树在节点访问时间远远超过节点内部访问时间的时候，比其他可作为替代的实现有着实在的优势。这通常在多数节点在次级存储比如硬盘中的时候出现。<strong>通过最大化在每个内部节点内的子节点的数目减少树的高度，平衡操作不经常发生，而且效率增加了</strong>。通常需要每个节点在次级存储中占据完整的磁盘块或近似的大小。</p><p>B+ 背后的设计思想是<strong>内部节点可以有在预定范围内的可变量目的子节点</strong>。因此，B+ 树不需要像其他自平衡二叉查找树那样经常的重新平衡。对于特定的实现在子节点数目上的低和高边界是固定的。</p><p>B+ 树的创造者 <code>Rudolf Bayer</code> 没有解释 <code>B</code> 代表什么。最常见的观点是 <code>B</code> 代表<strong>平衡</strong>(balanced)，因为所有的叶子节点在树中都在相同的级别上。<code>B</code> 也可能代表 <code>Bayer</code>，或者是<a href="https://zh.wikipedia.org/wiki/波音" target="_blank" rel="noopener">波音</a>（Boeing），因为他曾经工作于<em>波音科学研究实验室</em>。</p><p>如下图，把键 <code>1-7</code> 连接到值 <code>d1-d7</code> 的B+树。链表（红色）用于快速顺序遍历叶子节点。树的分叉因子 <code>b=4</code> 。</p><p><img src="https://pic-1258215793.cos.ap-shanghai.myqcloud.com/content/20200601/400px-Bplustree.png" alt></p><h3 id="2-2-节点结构"><a href="#2-2-节点结构" class="headerlink" title="2.2 节点结构"></a><strong>2.2 节点结构</strong></h3><p>在B+树中的节点通常被表示为一组有序的元素和子指针。如果此B+树的阶数是 <code>m</code> ，则除了根之外的每个节点都包含最少 <code>m/2</code> 个元素最多 <code>m-1</code> 个元素，对于任意的结点有最多 <code>m</code> 个子指针。对于所有内部节点，子指针的数目总是比元素的数目多一个。所有叶子都在相同的高度上，叶结点本身按关键字大小从小到大链接。</p><p>如下图所示，非叶子结点的关键字不保存数据，只用来索引，所有数据都保存在叶子节点。所有的叶子结点中包含了全部关键字的信息，及指向含这些关键字记录的指针，且叶子结点本身依关键字的大小自小而大顺序链接。</p><p><img src="https://pic-1258215793.cos.ap-shanghai.myqcloud.com/content/20200701/202007010115.png" alt></p><h3 id="2-3-算法"><a href="#2-3-算法" class="headerlink" title="2.3 算法"></a><strong>2.3 算法</strong></h3><h4 id="2-3-1-查找"><a href="#2-3-1-查找" class="headerlink" title="2.3.1 查找"></a><strong>2.3.1 查找</strong></h4><p>查找以典型的方式进行，类似于<a href="https://zh.wikipedia.org/wiki/二叉查找树" target="_blank" rel="noopener">二叉查找树</a>。起始于根节点，自顶向下遍历树，选择其分离值在要查找值的任意一边的子指针。在节点内部典型的使用是<a href="https://zh.wikipedia.org/wiki/二分查找" target="_blank" rel="noopener">二分查找</a>来确定这个位置。</p><h4 id="2-3-2-插入"><a href="#2-3-2-插入" class="headerlink" title="2.3.2 插入"></a><strong>2.3.2 插入</strong></h4><p>节点要处于违规状态，它必须包含在可接受范围之外数目的元素。</p><ol><li>首先，查找要插入其中的节点的位置。接着把值插入这个节点中。</li><li>如果没有节点处于违规状态则处理结束。</li><li>如果某个节点有过多元素，则把它分裂为两个节点，每个都有最小数目的元素。在树上递归向上继续这个处理直到到达根节点，如果根节点被分裂，则创建一个新根节点。为了使它工作，元素的最小和最大数目典型的必须选择为使最小数不小于最大数的一半。</li></ol><h4 id="2-3-3-删除"><a href="#2-3-3-删除" class="headerlink" title="2.3.3 删除"></a><strong>2.3.3 删除</strong></h4><ol><li>首先，查找要删除的值。接着从包含它的节点中删除这个值。</li><li>如果没有节点处于违规状态则处理结束。</li><li>如果节点处于违规状态则有两种可能情况：<ol><li>它的兄弟节点，就是同一个父节点的子节点，可以把一个或多个它的子节点转移到当前节点，而把它返回为合法状态。如果是这样，在更改父节点和两个兄弟节点的分离值之后处理结束。</li><li>它的兄弟节点由于处在低边界上而没有额外的子节点。在这种情况下把两个兄弟节点合并到一个单一的节点中，而且我们递归到父节点上，因为它被删除了一个子节点。持续这个处理直到当前节点是合法状态或者到达根节点，在其上根节点的子节点被合并而且合并后的节点成为新的根节点。</li></ol></li></ol><h3 id="2-4-实例说明"><a href="#2-4-实例说明" class="headerlink" title="2.4 实例说明"></a><strong>2.4 实例说明</strong></h3><p>假设B+树结点最多容纳存放3个键和4个指针， <code>m = 3</code> 为奇数，<code>d = 1</code> ，叶子结点至少2个条目（d + 1），非叶子结点至少2个指针（d + 1），1个条目。</p><p><img src="https://pic-1258215793.cos.ap-shanghai.myqcloud.com/content/20200701/202007010101.png" alt></p><p>首先插入1：判断根结点为空直接放入。</p><p><img src="https://pic-1258215793.cos.ap-shanghai.myqcloud.com/content/20200701/202007010102.png" alt></p><p>接着连续插入3、5：根结点未满，连续放入。</p><p><img src="https://pic-1258215793.cos.ap-shanghai.myqcloud.com/content/20200701/202007010103.png" alt></p><p>接着插入7：此时根结点达到max，判断需要分裂：<strong>当节点元素数量大于m-1的时候，从中间元素分裂成左右两部分，中间元素分裂到父节点当做索引存储，当然本身中间元素还是分裂右边这一部分的，保证左小右大的规则</strong>。所以分裂成两个子结点，1和3下沉到左边，5和7下沉到右边，内部结点只保存索引，最底层叶子结点连成有序链表。</p><p><img src="https://pic-1258215793.cos.ap-shanghai.myqcloud.com/content/20200701/202007010104.png" alt></p><p>接着插入9：找到位置，还有空间，直接放入。</p><p><img src="https://pic-1258215793.cos.ap-shanghai.myqcloud.com/content/20200701/202007010105.png" alt></p><p>接着插入2：如上放入。</p><p><img src="https://pic-1258215793.cos.ap-shanghai.myqcloud.com/content/20200701/202007010106.png" alt></p><p>接着插入4：此时对应叶子结点已放满，需要再度分裂成两个结点，1和2保留在左结点，3和4则移到新结点，并将新结点首个元素指向父结点（此时父结点仍有空间）。</p><p><img src="https://pic-1258215793.cos.ap-shanghai.myqcloud.com/content/20200701/202007010107.png" alt></p><p>接着插入6：对应叶子结点同样已满，继续相同分裂操作，并将新结点首个元素指向父结点。</p><p><img src="https://pic-1258215793.cos.ap-shanghai.myqcloud.com/content/20200701/202007010108.png" alt></p><p>接着插入8：仍有空间，直接放入。</p><p><img src="https://pic-1258215793.cos.ap-shanghai.myqcloud.com/content/20200701/202007010109.png" alt></p><p>接着插入10：此时对应叶子结点已满，所以先分裂开，7和8保留，9和10生成新叶子结点，将新叶子结点首个元素指向父结点，此时父结点超过上限（已是根结点，递归向上分裂，直到根结点分裂，增加高度），所以根结点分裂，中间元素7成为新的根结点，左小右大，新的结构仍是稳定的。</p><p><img src="https://pic-1258215793.cos.ap-shanghai.myqcloud.com/content/20200701/202007010110.png" alt></p><p>接下来我们看B+树的删除操作：</p><p><img src="https://pic-1258215793.cos.ap-shanghai.myqcloud.com/content/20200701/202007010111.png" alt></p><p>首先删除9：查找9所在结点，把它删除，然后判断此时树状态，发现叶子结点违规：叶子结点至少2个条目（d + 1），非叶子结点至少2个指针（d + 1），1个条目。合并兄弟结点，10、11和12合并，此时父结点因为少了一个子结点违规，所以需要继续处理。（此处为何为9还未搞懂）</p><p><img src="https://pic-1258215793.cos.ap-shanghai.myqcloud.com/content/20200701/202007010112.png" alt></p><p>接着删除7：</p><p><img src="https://pic-1258215793.cos.ap-shanghai.myqcloud.com/content/20200701/202007010113.png" alt></p><p>接着删除8：</p><p><img src="https://pic-1258215793.cos.ap-shanghai.myqcloud.com/content/20200701/202007010114.png" alt></p><h3 id="2-5-B-树的特点"><a href="#2-5-B-树的特点" class="headerlink" title="2.5 B+树的特点"></a><strong>2.5 B+树的特点</strong></h3><ol><li>B+树的非叶子结点不保存关键字记录的指针，只进行数据索引，这样可以使B+树每个非叶子结点所能保存的关键字数大大增加。</li><li>B+树叶子结点保存了父结点的所有关键字记录的指针，所有数据地址必须到叶子结点才能获取到，所以每次数据查询的次数都相同。</li><li>B+树叶子结点的关键字从小到大有序排列，左边结尾数据都会保存右边节点开始数据的指针。</li><li><strong>非叶子节点的子节点数</strong> = <strong>关键字数</strong>，或者<strong>非叶节点的关键字数</strong> = <strong>子节点数</strong> - 1，虽然他们数据排列结构不一样，但其原理还是一样的，Mysql 的B+树是用第一种方式实现。</li></ol><h3 id="2-6-B-树与B树的区别"><a href="#2-6-B-树与B树的区别" class="headerlink" title="2.6 B+树与B树的区别"></a><strong>2.6 B+树与B树的区别</strong></h3><ol><li>B+树的<strong>层级更少</strong>：相较于B树，B+树的每个<strong>非叶子</strong>节点存储的关键字数更多，树的层级更少所以查询数据更快；</li><li>B+树<strong>查询速度更稳定</strong>：B+所有关键字数据地址都存在<strong>叶子</strong>节点上，所以每次查找的次数都相同所以查询速度要比B树更稳定;</li><li>B+树<strong>天然具备排序功能：</strong>B+树所有的<strong>叶子</strong>节点数据构成了一个有序链表，在查询大小区间的数据时候更方便，数据紧密性很高，缓存的命中率也会比B树高。</li><li>B+<strong>树全节点遍历更快：</strong>B+树遍历整棵树只需要遍历所有的<strong>叶子</strong>节点即可，而不需要像B树一样需要对每一层进行遍历，这有利于数据库做全表扫描。</li></ol><p><strong>B树</strong>相对于<strong>B+树</strong>的优点是，如果经常访问的数据离根节点很近，而<strong>B树</strong>的<strong>非叶子</strong>节点本身存有关键字其数据的地址，所以这种数据检索的时候会要比<strong>B+树</strong>快。</p><table><thead><tr><th style="text-align:center">S.NO</th><th style="text-align:center">B TREE</th><th style="text-align:center">B+ TREE</th></tr></thead><tbody><tr><td style="text-align:center">1.</td><td style="text-align:center">所有的内部和叶子结点都有数据指针</td><td style="text-align:center">只有叶子结点有数据指针</td></tr><tr><td style="text-align:center">2.</td><td style="text-align:center">由于叶子结点上的所有键都不可用，所以搜索通常更费时</td><td style="text-align:center">所有键都在叶节点上，因此搜索更快，更准确</td></tr><tr><td style="text-align:center">3.</td><td style="text-align:center">树中没有重复的键</td><td style="text-align:center">允许重复的键，并且所有结点都存在于叶子上</td></tr><tr><td style="text-align:center">4.</td><td style="text-align:center">插入会花费更多时间，有时无法预测</td><td style="text-align:center">插入更容易，结果始终相同</td></tr><tr><td style="text-align:center">5.</td><td style="text-align:center">内部结点的删除非常复杂，并且树必须进行大量转换</td><td style="text-align:center">删除任何节点都很容易，因为所有结点都可以在叶子上找到</td></tr><tr><td style="text-align:center">6.</td><td style="text-align:center">叶子结点不存储为结构链表</td><td style="text-align:center">叶子结点存储为结构链表</td></tr><tr><td style="text-align:center">7.</td><td style="text-align:center">没有多余的搜索键</td><td style="text-align:center">可能存在多余的搜索键</td></tr></tbody></table><h3 id="2-7-B-树与B-树的区别"><a href="#2-7-B-树与B-树的区别" class="headerlink" title="2.7 B+树与B*树的区别"></a><strong>2.7 B+树与B*树的区别</strong></h3><p>B*树是B+树的变种，相对于B+树他们的不同之处如下：</p><ol><li><p>首先是关键字个数限制问题，B+树初始化的关键字初始化个数是 <code>cei(m/2)</code> ，<code>b*</code> 树的初始化个数为<code>cei(2/3*m)</code> 。</p></li><li><p>B+树节点满时就会分裂，而B<em>树节点满时会检查兄弟节点是否满（因为每个节点都有指向兄弟的指针），如果兄弟节点未满则向兄弟节点转移关键字，如果兄弟节点已满，则从当前节点和兄弟节点各拿出1/3的数据创建一个新的节点出来；</em></p></li><li>在B+树的基础上因其初始化的容量变大，使得节点空间使用率更高，而又存有兄弟节点的指针，可以向兄弟节点转移关键字的特性使得B*树额分解次数变得更少；</li></ol><hr><p><em>参考博客和文章书籍等：</em></p><blockquote><p><a href="https://zh.wikipedia.org/wiki/B树" target="_blank" rel="noopener">B树-维基百科</a></p></blockquote><blockquote><p><a href="https://zh.wikipedia.org/wiki/B%2B%E6%A0%91" target="_blank" rel="noopener">B+树-维基百科</a></p></blockquote><blockquote><p>《算法 第4版》</p></blockquote><p><em>因博客主等未标明不可引用，若部分内容涉及侵权请及时告知，我会尽快修改和删除相关内容</em></p>]]></content>
    
    <summary type="html">
    
      简单整理了B树和B+树的相关内容。
    
    </summary>
    
      <category term="技术文档" scheme="http://linyishui.top/categories/%E6%8A%80%E6%9C%AF%E6%96%87%E6%A1%A3/"/>
    
    
      <category term="algorithm" scheme="http://linyishui.top/tags/algorithm/"/>
    
  </entry>
  
  <entry>
    <title>Redis底层数据结构</title>
    <link href="http://linyishui.top/2020070101.html"/>
    <id>http://linyishui.top/2020070101.html</id>
    <published>2020-07-01T09:28:50.000Z</published>
    <updated>2020-08-06T09:30:27.464Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="Redis底层数据结构"><a href="#Redis底层数据结构" class="headerlink" title="Redis底层数据结构"></a><strong>Redis底层数据结构</strong></h1><p><img src="https://user-gold-cdn.xitu.io/2019/9/15/16d32e80bc35b4da?imageView2/0/w/1280/h/960/format/webp/ignore-error/1" alt="image"></p><h2 id="第一节-动态字符串-SDS"><a href="#第一节-动态字符串-SDS" class="headerlink" title="第一节 动态字符串-SDS"></a><strong>第一节 动态字符串-SDS</strong></h2><h3 id="1-1-概述"><a href="#1-1-概述" class="headerlink" title="1.1 概述"></a><strong>1.1 概述</strong></h3><p>Redis 是由 <strong>C 语言</strong>作为底层编程语言实现的，而 <strong>C 语言中的字符串是一个以空字符结尾的字符数组</strong>，这种结构对于 Redis 而言过于简单了，主要缺点如下：</p><ol><li><strong>C 字符串不记录自身长度信息，为了获取字符串长度必须遍历整个字符串，时间复杂度为 O(n)</strong>。</li><li>由于 C 字符串不记录自身长度，<strong>稍有不小心就会造成缓冲区溢出</strong>。</li><li>对于 Redis 这种缓存类型数据库，对于缓存的 Value 是有可能经常的更改的。但是 <strong>C 字符串每次的增长或是缩小都需要一次内存的重分配操作</strong>。</li><li>Redis 数据库中缓存的内容不是特定的，有可能会是图片、音频等等文件的二进制数据，但是 <strong>C 字符串中的字符必须符合某种编码，且字符串中不能包含空格</strong>，这些限制也导致了 Redis 不能使用 C 字符串来作为自身字符串的实现。</li></ol><p>于是 Redis 实现了 SDS 这种简单动态字符串结构，它其实和 Java 中 ArrayList 的实现是很类似的。</p><p>Redis 源代码中 <code>sds.h</code> 文件下，有五种 <code>sdshdr</code> ，它们分别是：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> __<span class="title">attribute__</span> ((__<span class="title">packed__</span>)) <span class="title">sdshdr5</span> &#123;</span></span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">char</span> flags; <span class="comment">/* 3 lsb of type, and 5 msb of string length */</span></span><br><span class="line">    <span class="keyword">char</span> buf[];</span><br><span class="line">&#125;;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> __<span class="title">attribute__</span> ((__<span class="title">packed__</span>)) <span class="title">sdshdr8</span> &#123;</span></span><br><span class="line">    <span class="keyword">uint8_t</span> len; <span class="comment">/* used */</span></span><br><span class="line">    <span class="keyword">uint8_t</span> alloc; <span class="comment">/* excluding the header and null terminator */</span></span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">char</span> flags; <span class="comment">/* 3 lsb of type, 5 unused bits */</span></span><br><span class="line">    <span class="keyword">char</span> buf[];</span><br><span class="line">&#125;;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> __<span class="title">attribute__</span> ((__<span class="title">packed__</span>)) <span class="title">sdshdr16</span> &#123;</span></span><br><span class="line">    <span class="keyword">uint16_t</span> len; <span class="comment">/* used */</span></span><br><span class="line">    <span class="keyword">uint16_t</span> alloc; <span class="comment">/* excluding the header and null terminator */</span></span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">char</span> flags; <span class="comment">/* 3 lsb of type, 5 unused bits */</span></span><br><span class="line">    <span class="keyword">char</span> buf[];</span><br><span class="line">&#125;;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> __<span class="title">attribute__</span> ((__<span class="title">packed__</span>)) <span class="title">sdshdr32</span> &#123;</span></span><br><span class="line">    <span class="keyword">uint32_t</span> len; <span class="comment">/* used */</span></span><br><span class="line">    <span class="keyword">uint32_t</span> alloc; <span class="comment">/* excluding the header and null terminator */</span></span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">char</span> flags; <span class="comment">/* 3 lsb of type, 5 unused bits */</span></span><br><span class="line">    <span class="keyword">char</span> buf[];</span><br><span class="line">&#125;;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> __<span class="title">attribute__</span> ((__<span class="title">packed__</span>)) <span class="title">sdshdr64</span> &#123;</span></span><br><span class="line">    <span class="keyword">uint64_t</span> len; <span class="comment">/* used */</span></span><br><span class="line">    <span class="keyword">uint64_t</span> alloc; <span class="comment">/* excluding the header and null terminator */</span></span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">char</span> flags; <span class="comment">/* 3 lsb of type, 5 unused bits */</span></span><br><span class="line">    <span class="keyword">char</span> buf[];</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>其中，sdshdr5 的注释表明，<strong>sdshdr5  is never used</strong>。sdshdr5 这种数据结构一般用于存储长度小于 32 个字符的字符串，但现在也已经不再使用这种结构了，再小长度的字符串也建议使用 sdshdr8 进行存储，因为 sdshdr5 少了两个关键字段，因此不具备动态扩容操作，一旦预分配的内存空间使用完，就需要重新分配内存并完成数据的复制迁移，在实际的生产环境中对于性能的影响还是很大的，所以进行了一个抛弃，但其实有些比较小的键依然会采用这种结构存储。</p><p>关于 sdshdr5 我们不再多说，我们看其他四种结构的各个字段，len 字段表示当前字符串总长度，也即当前字符串已使用内存大小，alloc 表示为当前字符串分配的总内存大小（不包括len以及flags字段本身分配的内存），因为每一个结构在预分配的时候都会多分配一段内存空间，主要是为了方便以后的扩容。flags 的低三位表示当前 sds 的类型，高五位无用。低三位取值如下：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> SDS_TYPE_5  0</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> SDS_TYPE_8  1</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> SDS_TYPE_16 2</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> SDS_TYPE_32 3</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> SDS_TYPE_64 4</span></span><br></pre></td></tr></table></figure><p>实际上，redis 对 sdshdr 内存分配是禁用内存对齐的，也就是说每个字段分配的内存地址是紧紧排列在一起的， 所以 redis 中字符串参数的传递直接使用 <strong>char*</strong> 指针。</p><p>可能有人会疑问，仅仅通过一个 <strong>char</strong> 指针如何确定当前字符串的类型，其实由于 sdshdr 内存分配禁止内存对齐，所以 sds[-1] 其实指向的就是 flags 字段的内存地址，通过 flags 字段又可以得到当前 sds 属于哪种类型，进而可以读取头部字段确定 sds 的相关属性。</p><p>接下来我们讲讲 sdshdr 相对于传统的 C 语言字符串，性能的提升在哪，以及具有哪些便捷的点。</p><p><strong>首先</strong>，对于传统的 C 字符串，我想要获取字符串的长度，至少需要 O(n) 遍历一遍数组才行，而我们 sds 只需要 O(1) 的取 len 字段的值即可。</p><p><strong>其次</strong>，也是非常重要的一个设计，如果我们初始分配了一个字符串对象，那么如果我要在这个字符串后面追加内容的话，限制于数组的长度一经初始化是不能修改的，我们至少需要分配一个足够大的数组，然后将原先的字符串进行一个拷贝。</p><p><strong>sdshdr 每次为一个 sds 分配内存的时候都会额外分配一部分暂不使用的内存空间，一般额外的内存会等同于当前字符串占用的内存大小，如果超过 1MB，那么额外空间的内存大小就是 1MB</strong>。每当执行 sdscat 这种方法的时候，程序会用 alloc-len 比较下剩下的空余内存是否足够分配追加的内容，如果不够自然触发内存重分配，而如果剩余未使用内存空间足够放下，那么将直接进行分配，无需内存重分配。</p><p><strong>通过这种预分配策略， SDS 将连续增长 N 次字符串所需的内存重分配次数从必定 N 次降低为最多 N 次</strong>。</p><p><strong>最后</strong>，对于常规的 C 语言字符串，它通过判断当前字符是否是空字符来决定字符串的结尾，所以就要求你的字符串中不能包含甚至一个空字符，否则空字符后面的字符都不能作为有效字符被读取。而对于某些具有特殊格式要求的，需要使用空字符进行分隔作用的，那么传统的 C 字符串就无法存储了，而我们的 <strong>sds 不是通过空字符判断字符串结尾，而是通过 len 字段的值判断字符串的结尾</strong>，所以说，sds 还具备<strong>二进制安全</strong>这个特性，即它可以安全的存储具备特殊格式要求的二进制数据。</p><p>关于 sds 我们就简单说到这，它是一种改良版的 C 字符串，兼容 C 语言中既有的函数 API，也通过一些手段提升了某些操作的性能，值得大家借鉴。</p><hr><h2 id="第二节-链表"><a href="#第二节-链表" class="headerlink" title="第二节 链表"></a><strong>第二节 链表</strong></h2><p>链表这种数据结构相信大家也不陌生，有很多类型，比如单向链表，双向链表，循环链表等，链表相对于数组来说，<strong>一是不需要连续的内存块地址，二是删除和插入的时间复杂度是 O(1) 级别的</strong>，非常的高效，但<strong>比不上数组的随机访问查询方式</strong>。</p><p>一样的那句话，没有最好的数据结构，只有恰到好处的数据结构，比如我们后面要介绍的更高层次的数据结构，字典，它的底层其实就依赖的链表规避哈希冲突，具体的我们后面再说。</p><p>redis 中借助 C 语言实现了一个双向链表结构：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">listNode</span> &#123;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">listNode</span> *<span class="title">prev</span>;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">listNode</span> *<span class="title">next</span>;</span></span><br><span class="line">    <span class="keyword">void</span> *value;</span><br><span class="line">&#125; listNode;</span><br></pre></td></tr></table></figure><p>pre 指针指向前一个节点，next 指针指向后一个节点，value 指向当前节点对应的数据对象。盗一张图描述整个串联起来的链表结构：</p><p><img src="https://user-gold-cdn.xitu.io/2019/9/15/16d32e80c4f8982b?imageView2/0/w/1280/h/960/format/webp/ignore-error/1" alt="image"></p><p>虽然通过链表的第一个头节点就可以遍历整个链表，但在 <strong>redis 向上封装了一层结构，专门用于表示一个链表结构</strong>：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">list</span> &#123;</span></span><br><span class="line">    listNode *head;</span><br><span class="line">    listNode *tail;</span><br><span class="line">    <span class="keyword">void</span> *(*dup)(<span class="keyword">void</span> *ptr);</span><br><span class="line">    <span class="keyword">void</span> (*<span class="built_in">free</span>)(<span class="keyword">void</span> *ptr);</span><br><span class="line">    <span class="keyword">int</span> (*match)(<span class="keyword">void</span> *ptr, <span class="keyword">void</span> *key);</span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">long</span> len;</span><br><span class="line">&#125; <span class="built_in">list</span>;</span><br></pre></td></tr></table></figure><ul><li>head 指向链表的头节点</li><li>tail 指向链表的尾节点</li><li>dup 函数用于链表转移复制时对节点 value 拷贝的一个实现，一般来说用等于号足以，但某些特殊情况下可能会用到节点转移函数，默认可以给这个函数赋值 NULL 即表示使用等于号进行节点转移。</li><li>free 函数用于释放一个节点所占用的内存空间，默认赋值 NULL 的话，即使用 redis 自带的 zfree 函数进行内存空间释放，我们也可以来看一下这个 zfree 函数。</li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">zfree</span><span class="params">(<span class="keyword">void</span> *ptr)</span> </span>&#123;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifndef</span> HAVE_MALLOC_SIZE</span></span><br><span class="line">    <span class="keyword">void</span> *realptr;</span><br><span class="line">    <span class="keyword">size_t</span> oldsize;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (ptr == <span class="literal">NULL</span>) <span class="keyword">return</span>;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> HAVE_MALLOC_SIZE</span></span><br><span class="line">    update_zmalloc_stat_free(zmalloc_size(ptr));</span><br><span class="line">    <span class="built_in">free</span>(ptr);</span><br><span class="line"><span class="meta">#<span class="meta-keyword">else</span></span></span><br><span class="line">    realptr = (<span class="keyword">char</span>*)ptr-PREFIX_SIZE;</span><br><span class="line">    oldsize = *((<span class="keyword">size_t</span>*)realptr);</span><br><span class="line">    update_zmalloc_stat_free(oldsize+PREFIX_SIZE);</span><br><span class="line">    <span class="built_in">free</span>(realptr);</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里会涉及到一个<strong>内存对齐</strong>的概念，就比如一个 64 位的操作系统，一次内存 IO 会固定取出 8 个字节的内存数据出来，如果某个变量横跨了两个八字节段，那么 CPU 需要进行两次的 IO 才能完整取出该变量的数据，引入内存对齐，是为了保证任意变量的内存分配不会出现上述的横跨情况，具体的操作手法就是填充无用的内存位，当然这必然会造成内存碎片，不过这也是一种以空间换时间的策略，你也可以禁用它。</p><p>函数的上半部分是做一些判断，如果确定了该指针指向的数据结构占用的总内存，则直接调用 free 函数进行内存的释放，否则需要进行一个计算。redis 中的 zmalloc 在每一次内存数据分配的时候都会追加一个 PREFIX_SIZE 的头部数据块，它的值等于当前系统的最大寻址空间，比如 64 CPU的话，PREFIX_SIZE 就会占用到 8 个字节，并且这 8 个字节内部存储的是当前数据实际占用内存大小。</p><p>所以这里的话，ptr 指针向低位移动就是指向头部 PREFIX_SIZE 字段首地址，然后取出里面保存的值，也就是当前数据结构实际占用的内存大小，最后加上它自身传入 update_zmalloc_stat_free 函数中修改 used_memory 内存记录指针的值，并在最后调用 free 函数释放内存，包括头部的部分。</p><p>其实我们扯远了，继续看数据结构，这里如果还不是很明白的话，没关系，后面我们还会继续讲的。</p><p>match 函数依然是一个多态的实现，只给出了定义，具体实现由你来决定，你也可以选择不实现，它用于比较两个链表节点的 value 值是否相等。返回 0 表示不相等，返回 1 表示相等。</p><p>最后一个 len 字段描述的是，整个链表中所包含的节点数量。以上就是 redis 中链表的一个基本的定义，加上 list，最终链表结构在 redis 中呈现的抽象图大概是这样的，依然盗的图：</p><p><img src="https://user-gold-cdn.xitu.io/2019/9/15/16d32e80bc798df0?imageView2/0/w/1280/h/960/format/webp/ignore-error/1" alt="image"></p><p>综上，我们介绍了 redis 中链表的一个基本实现情况，总结一下，它是一个双端链表，也就是查找某个节点的前后节点的时间复杂度都在 O(1)，也是一个无环并具有首尾节点指针的链表，初次之外，还具有三个多态函数，用于节点间的复制、比较以及内存释放，需要使用者自行实现。</p><hr><h2 id="第三节-字典"><a href="#第三节-字典" class="headerlink" title="第三节 字典"></a><strong>第三节 字典</strong></h2><p>字典相对于数组，链表来说，是一种较高层次的数据结构，像我们的汉语字典一样，可以通过拼音或偏旁唯一确定一个汉字，在程序里我们管<strong>每一个映射关系叫做一个键值对</strong>，<strong>很多个键值对放在一起就构成了我们的字典结构</strong>。</p><p>有很多高级的字典结构实现，例如我们 <strong>Java 中的 HashMap 底层实现，根据键的 Hash 值均匀的将键值对分散到数组中，并在遇到哈希冲突时，冲突的键值对通过单向链表串联，并在链表结构超过八个节点裂变成红黑树</strong>。</p><p>那么 redis 中是怎么实现的呢？我们一起来看一看。</p><h3 id="一、字典结构定义"><a href="#一、字典结构定义" class="headerlink" title="一、字典结构定义"></a>一、字典结构定义</h3><p>Redis 中的字典相关结构都定义在 dict.h 文件中，dict 表示一个字典结构：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">dict</span> &#123;</span></span><br><span class="line">    dictType *type;</span><br><span class="line">    <span class="keyword">void</span> *privdata;</span><br><span class="line">    dictht ht[<span class="number">2</span>];</span><br><span class="line">    <span class="keyword">long</span> rehashidx; </span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">long</span> iterators;</span><br><span class="line">&#125; dict;</span><br></pre></td></tr></table></figure><ul><li>type 字段指向 dictType 结构，这个结构中定义几个多态方法。</li><li>privdata 指针存储了字典结构一些附属额外信息。</li><li>ht 是一个 dictht 结构的数组，dictht 就是一个哈希表结构。</li><li>rehashidx 字段用于 rehash 过程中记录正在转移的键。</li><li>iterators 字段记录了当前字典正在进行中的迭代器。</li></ul><p><img src="https://pic-1258215793.cos.ap-shanghai.myqcloud.com/content/20200701/202007010116.png" alt></p><p>dictType 具体如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">dictType</span> &#123;</span></span><br><span class="line">    <span class="keyword">uint64_t</span> (*hashFunction)(<span class="keyword">const</span> <span class="keyword">void</span> *key);</span><br><span class="line">    <span class="keyword">void</span> *(*keyDup)(<span class="keyword">void</span> *privdata, <span class="keyword">const</span> <span class="keyword">void</span> *key);</span><br><span class="line">    <span class="keyword">void</span> *(*valDup)(<span class="keyword">void</span> *privdata, <span class="keyword">const</span> <span class="keyword">void</span> *obj);</span><br><span class="line">    <span class="keyword">int</span> (*keyCompare)(<span class="keyword">void</span> *privdata, <span class="keyword">const</span> <span class="keyword">void</span> *key1, <span class="keyword">const</span> <span class="keyword">void</span> *key2);</span><br><span class="line">    <span class="keyword">void</span> (*keyDestructor)(<span class="keyword">void</span> *privdata, <span class="keyword">void</span> *key);</span><br><span class="line">    <span class="keyword">void</span> (*valDestructor)(<span class="keyword">void</span> *privdata, <span class="keyword">void</span> *obj);</span><br><span class="line">&#125; dictType;</span><br></pre></td></tr></table></figure><ul><li>hashFunction 哈希函数指针，当我们通过 set 命令往字典中存储数据时，会先用键值对的键作为参数传入哈希函数，得到一个较为散列均匀的值，然后才会实际的进行数据的存储。这里就会用到哈希函数，如果你需要为你的字典结构提供不同的散列方式，在初始化字典的时候为 dictType 中哈希函数进行一个实现就好。</li><li>keyDup 是一个键的复制函数。</li><li>valDup是一个键值对的值的复制函数。</li><li>keyCompare 是一个键的比较大小的函数。</li><li>keyDestructor 销毁一个键。</li><li>valDestructor 销毁一个键值对的值。都是一个多态的呈现，具体实现需要使用者自行提供。</li></ul><p>接着看 dict 结构，具体的再看。</p><p>dictht 就是我们的哈希表结构，</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">dictht</span> &#123;</span></span><br><span class="line">    dictEntry **table;</span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">long</span> size;</span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">long</span> sizemask;</span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">long</span> used;</span><br><span class="line">&#125; dictht;</span><br></pre></td></tr></table></figure><p>table 是一个指向 dictEntry 的二维数组，每个 dictEntry 其实就表述一个键值对，为什么是一个二维的结构呢？</p><p>其实正常情况下，我们的字典是这样保存数据的：</p><p><img src="https://user-gold-cdn.xitu.io/2019/9/22/16d5800ede0c3b2e?imageView2/0/w/1280/h/960/format/webp/ignore-error/1" alt="image"></p><p>每个 dictEntry 内部会保存一个 key/value 的键值对，然后我们通过 table 指针可以遍历所有的键值对，但是如果某个键值对的键进行哈希之后并计算得到应该存储的位置被别的节点捷足先登了，也就是我们常说的哈希冲突了，怎么办？</p><p>redis 中的做法，甚至于大部分字典结构实现都是选择将冲突的节点串联成链表，于是字典结构就变成这样了。</p><p><img src="https://user-gold-cdn.xitu.io/2019/9/22/16d5800ecf48bcfe?imageView2/0/w/1280/h/960/format/webp/ignore-error/1" alt="image"></p><p><strong>同一条链表上的节点键的哈希值必定是相同的，也正是因为相同才会被串在一起</strong>，从逻辑上看，字典结构如上图所展示的那样，但抽象到我们的代码层，就是一个二维数组的结构，第一维放的就是节点指针的指针，第二维指向的就是指向我们键值对结构的指针，每一个 dictEntry 结构都会有一个 next 指针，在遇到哈希冲突的时候可以串联所有冲突节点。</p><p>除此之外，dictht 中的 size 属性用于描述整个哈希字典表最大可寻址大小，也就是二维数组中第一维度的最大长度，sizemask 属性始终等于 size-1 表述的是一种大小掩码的概念，用于确定节点最初在数组中的位置，used 记录了整张哈希表中已经存储的键值对节点数量。</p><p>其中，dict 字典结构中 ht 是一个只有两个元素的数组，<strong>正常情况下我们使用 ht[0] 字典表，ht[1] 用在我们渐进 rehash 过程中转移 ht[0] 中所有节点中</strong>。</p><p>最后，我们再来看这个 dictEntry 键值对结构：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">dictEntry</span> &#123;</span></span><br><span class="line">    <span class="keyword">void</span> *key;</span><br><span class="line">    <span class="keyword">union</span> &#123;</span><br><span class="line">        <span class="keyword">void</span> *val;</span><br><span class="line">        <span class="keyword">uint64_t</span> u64;</span><br><span class="line">        <span class="keyword">int64_t</span> s64;</span><br><span class="line">        <span class="keyword">double</span> d;</span><br><span class="line">    &#125; v;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">dictEntry</span> *<span class="title">next</span>;</span></span><br><span class="line">&#125; dictEntry;</span><br></pre></td></tr></table></figure><p>key 是一个指向任意结构的指针，代表我们的 key 可以使用我们 redis 中任意对象类型，v 是一个 union 类型，它可以是一个指针，也可以是 uint64_t 或 int64_t 类型，也可以是一个 double 类型。根据实际使用中，value 的不同值，使用不同的字段属性。</p><p>next 指针指向另一个 dictEntry 结构，用于发生哈希冲突时，链接下一个键值对节点。</p><p>以上就是 redis 中字典结构主要结构类型，从里至外封装了三层，dict 描述一个字典，其中的 dictht 描述哈希表，其中的 dictEntry 描述键值对结构。迭代器回头我们单独说说。</p><h3 id="二、渐进式-rehash-迁移数据"><a href="#二、渐进式-rehash-迁移数据" class="headerlink" title="二、渐进式 rehash 迁移数据"></a>二、渐进式 rehash 迁移数据</h3><p>redis 的 rehash 和 Java 以及其他哈希的实现稍微可能有点不同，由于 redis 是单线程的，不需要写大量的并发语句来保证数据一致性，但是单线程处理也会导致一次 rehash 过程会非常缓慢，客户端阻塞太久。那么 redis 具体是怎么做的呢？</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">dictRehash</span><span class="params">(dict *d, <span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> empty_visits = n*<span class="number">10</span>; <span class="comment">/* Max number of empty buckets to visit. */</span></span><br><span class="line">    <span class="keyword">if</span> (!dictIsRehashing(d)) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span>(n-- &amp;&amp; d-&gt;ht[<span class="number">0</span>].used != <span class="number">0</span>) &#123;</span><br><span class="line">        dictEntry *de, *nextde;</span><br><span class="line"></span><br><span class="line">        <span class="comment">/* Note that rehashidx can't overflow as we are sure there are more</span></span><br><span class="line"><span class="comment">         * elements because ht[0].used != 0 */</span></span><br><span class="line">        assert(d-&gt;ht[<span class="number">0</span>].size &gt; (<span class="keyword">unsigned</span> <span class="keyword">long</span>)d-&gt;rehashidx);</span><br><span class="line">        <span class="keyword">while</span>(d-&gt;ht[<span class="number">0</span>].table[d-&gt;rehashidx] == <span class="literal">NULL</span>) &#123;</span><br><span class="line">            d-&gt;rehashidx++;</span><br><span class="line">            <span class="keyword">if</span> (--empty_visits == <span class="number">0</span>) <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        de = d-&gt;ht[<span class="number">0</span>].table[d-&gt;rehashidx];</span><br><span class="line">        <span class="comment">/* Move all the keys in this bucket from the old to the new hash HT */</span></span><br><span class="line">        <span class="keyword">while</span>(de) &#123;</span><br><span class="line">            <span class="keyword">uint64_t</span> h;</span><br><span class="line"></span><br><span class="line">            nextde = de-&gt;next;</span><br><span class="line">            <span class="comment">/* Get the index in the new hash table */</span></span><br><span class="line">            h = dictHashKey(d, de-&gt;key) &amp; d-&gt;ht[<span class="number">1</span>].sizemask;</span><br><span class="line">            de-&gt;next = d-&gt;ht[<span class="number">1</span>].table[h];</span><br><span class="line">            d-&gt;ht[<span class="number">1</span>].table[h] = de;</span><br><span class="line">            d-&gt;ht[<span class="number">0</span>].used--;</span><br><span class="line">            d-&gt;ht[<span class="number">1</span>].used++;</span><br><span class="line">            de = nextde;</span><br><span class="line">        &#125;</span><br><span class="line">        d-&gt;ht[<span class="number">0</span>].table[d-&gt;rehashidx] = <span class="literal">NULL</span>;</span><br><span class="line">        d-&gt;rehashidx++;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Check if we already rehashed the whole table... */</span></span><br><span class="line">    <span class="keyword">if</span> (d-&gt;ht[<span class="number">0</span>].used == <span class="number">0</span>) &#123;</span><br><span class="line">        zfree(d-&gt;ht[<span class="number">0</span>].table);</span><br><span class="line">        d-&gt;ht[<span class="number">0</span>] = d-&gt;ht[<span class="number">1</span>];</span><br><span class="line">        _dictReset(&amp;d-&gt;ht[<span class="number">1</span>]);</span><br><span class="line">        d-&gt;rehashidx = <span class="number">-1</span>;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* More to rehash... */</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>rehashidx 的值默认为 -1，表示当前字典未处于 rehash 阶段，其他场合该字段的值等于当前正在转移桶的索引。</p><p>新版本的 dictRehash 需要多传一个参数 n，这个参数用于控制单次最多转移空桶数量。什么意思呢，具体我们看一张图：</p><p><img src="https://user-gold-cdn.xitu.io/2019/9/22/16d5800edea0e859?imageView2/0/w/1280/h/960/format/webp/ignore-error/1" alt="image"></p><p>有这么一个字典结构，其中索引值为 2 和 3 的两个桶是空的，即里面没有放我们的键值对节点。正常情况下，一次 rehash 只会转移一个桶，但如果上一次转移了索引为 1 的那个桶，下一次来会遍历后面一个桶，如果继续为空就继续向后遍历，直到找到一个存储了我们节点的非空桶，极端情况下，如果字典表中只有最后一个桶有节点，那么一次的 rehash 就要遍历所有的桶，时间复杂度 O(n)，这会导致客户端等待过长时间，所以新版本中额外传一个参数 n 用于控制最多遍历的空桶数。</p><p>相关代码段如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">while</span>(d-&gt;ht[<span class="number">0</span>].table[d-&gt;rehashidx] == <span class="literal">NULL</span>) &#123;</span><br><span class="line">    d-&gt;rehashidx++;</span><br><span class="line">    <span class="keyword">if</span> (--empty_visits == <span class="number">0</span>) <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>方法的尾部会进行一个校验，如果当前桶转移结束后，当前字典的 rehash 过程完全结束，那么修改 ht[0] 指针引用，让他指向新的字典表 ht[1]，并设置 rehashidx 为 -1，标记整个字典 rehash 结束。</p><p>以上就是 redis 中 rehash 的全过程，还是比较简单的，那为什么说它是渐进式的呢，我们看一下添加和查询键值对的方法。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">dictEntry *<span class="title">dictAddRaw</span><span class="params">(dict *d, <span class="keyword">void</span> *key, dictEntry **existing)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> index;</span><br><span class="line">    dictEntry *entry;</span><br><span class="line">    dictht *ht;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (dictIsRehashing(d)) _dictRehashStep(d);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> ((index = _dictKeyIndex(d, key, dictHashKey(d,key), existing)) == <span class="number">-1</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">    ht = dictIsRehashing(d) ? &amp;d-&gt;ht[<span class="number">1</span>] : &amp;d-&gt;ht[<span class="number">0</span>];</span><br><span class="line">    entry = zmalloc(<span class="keyword">sizeof</span>(*entry));</span><br><span class="line">    entry-&gt;next = ht-&gt;table[index];</span><br><span class="line">    ht-&gt;table[index] = entry;</span><br><span class="line">    ht-&gt;used++;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Set the hash entry fields. */</span></span><br><span class="line">    dictSetKey(d, entry, key);</span><br><span class="line">    <span class="keyword">return</span> entry;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这就是我们调用 set 命令，底层为我们添加键值对的方法，函数的最开头逻辑就是调用 dictIsRehashing 方法判断当前的字典表是否处于 rehash 状态，也即判断 rehashidx 是否不等于 -1 了。_dictRehashStep 方法实现：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">void</span> _dictRehashStep(dict *d) &#123;</span><br><span class="line">    <span class="keyword">if</span> (d-&gt;iterators == <span class="number">0</span>) dictRehash(d,<span class="number">1</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>默认情况下，一次 rehash 过程，redis 允许最多 10 空桶的访问就要返回，不得逗留。<strong>值得注意的是，方法的后续逻辑会判断当前字典如果正在进行 rehash，那么新的键值对将不再向 ht[0] 中添加，而直接转而添加到 ht[1] 中</strong>。</p><p>我们再看看查询键值对的 get 命令底层 API 调用，底层会调用 dictFind 方法。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">dictEntry *<span class="title">dictFind</span><span class="params">(dict *d, <span class="keyword">const</span> <span class="keyword">void</span> *key)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    dictEntry *he;</span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">int</span> h, idx, table;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (d-&gt;ht[<span class="number">0</span>].used + d-&gt;ht[<span class="number">1</span>].used == <span class="number">0</span>) <span class="keyword">return</span> <span class="literal">NULL</span>; </span><br><span class="line">    <span class="keyword">if</span> (dictIsRehashing(d)) _dictRehashStep(d);</span><br><span class="line">    h = dictHashKey(d, key);</span><br><span class="line">    <span class="keyword">for</span> (table = <span class="number">0</span>; table &lt;= <span class="number">1</span>; table++) &#123;</span><br><span class="line">        idx = h &amp; d-&gt;ht[table].sizemask;</span><br><span class="line">        he = d-&gt;ht[table].table[idx];</span><br><span class="line">        <span class="keyword">while</span>(he) &#123;</span><br><span class="line">            <span class="keyword">if</span> (key==he-&gt;key || dictCompareKeys(d, key, he-&gt;key))</span><br><span class="line">                <span class="keyword">return</span> he;</span><br><span class="line">            he = he-&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (!dictIsRehashing(d)) <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可以看到，同样也是有 dictIsRehashing 方法的判断，如果字典处于 rehash 状态，即需要去完成一个桶的转移，然后才能返回。<strong>值得注意的是，方法的中间逻辑是嵌套在一个 for 循环中的，供两次循环，第一次从 ht[0] 中搜索我们给定 key 的键值对，如果没有找到，第二次循环将从 ht[1] 中搜索我们要查询的键值对。</strong></p><p>之所以说 redis 的 rehash 是渐进式的，就是因为即便它处于 rehash 状态下，所有节点的插入、查询甚至于删除都是不受影响的，直至整个 rehash 结束，redis 释放原先 ht[0] 占用无用内存。</p><p><em>ps：redis 中的字典实现相对于 Java 中的实现要简单不少，主要还是因为 redis 是单线程调用的，不需要使用额外的并发语句控制。</em></p><h3 id="三、字典迭代器"><a href="#三、字典迭代器" class="headerlink" title="三、字典迭代器"></a>三、字典迭代器</h3><p>迭代器是用于迭代遍历字典中所有的节点的一个工具，有两种，一种是安全迭代器，一种是不安全迭代器。安全迭代器就是指，你在迭代的过程中，允许你对字典结构进行修改，也即允许你添加、删除、修改字典中的键值对节点。不安全迭代器即不允许对字典中任何节点进行修改。</p><p>dictIterator 结构的定义如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">dictIterator</span> &#123;</span></span><br><span class="line">    dict *d;</span><br><span class="line">    <span class="keyword">long</span> index;</span><br><span class="line">    <span class="keyword">int</span> table, safe;</span><br><span class="line">    dictEntry *entry, *nextEntry;</span><br><span class="line">    <span class="comment">/* unsafe iterator fingerprint for misuse detection. */</span></span><br><span class="line">    <span class="keyword">long</span> <span class="keyword">long</span> fingerprint;</span><br><span class="line">&#125; dictIterator;</span><br></pre></td></tr></table></figure><p>字段 d 指向一个即将被迭代的字典结构，index 记录了当前迭代到字典中的桶索引，table 取值为 0 或 1，表示当前迭代的是字典中哪个哈希表，safe 标记当前迭代器是安全的或是不安全的。 entry 记录的是当前迭代的节点，nextEntry 的值等于 entry 的 next 指针，用于防止当前节点接受删除操作后续节点丢失情况。fingerprint 保存了 dictFingerprint 函数根据当前字典的基本信息计算的一个指纹信息，稍有一丁点变动，指纹信息就会发生变化，用于不安全迭代器检验。</p><p>安全迭代器获取方式：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">dictIterator *<span class="title">dictGetIterator</span><span class="params">(dict *d)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    dictIterator *iter = zmalloc(<span class="keyword">sizeof</span>(*iter));</span><br><span class="line"></span><br><span class="line">    iter-&gt;d = d;</span><br><span class="line">    iter-&gt;table = <span class="number">0</span>;</span><br><span class="line">    iter-&gt;index = <span class="number">-1</span>;</span><br><span class="line">    iter-&gt;safe = <span class="number">0</span>;</span><br><span class="line">    iter-&gt;entry = <span class="literal">NULL</span>;</span><br><span class="line">    iter-&gt;nextEntry = <span class="literal">NULL</span>;</span><br><span class="line">    <span class="keyword">return</span> iter;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>不安全迭代器获取方式：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">dictIterator *<span class="title">dictGetSafeIterator</span><span class="params">(dict *d)</span> </span>&#123;</span><br><span class="line">    dictIterator *i = dictGetIterator(d);</span><br><span class="line"></span><br><span class="line">    i-&gt;safe = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">return</span> i;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>下面我们看看迭代器的核心方法，dictNext 用于获取字典中下一个节点。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">dictEntry *<span class="title">dictNext</span><span class="params">(dictIterator *iter)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">while</span> (<span class="number">1</span>) &#123;</span><br><span class="line">        <span class="comment">//如果迭代器初次工作，entry 必定为 null</span></span><br><span class="line">        <span class="keyword">if</span> (iter-&gt;entry == <span class="literal">NULL</span>) &#123;</span><br><span class="line">            <span class="comment">//拿到迭代器 d 字段保存的字典</span></span><br><span class="line">            dictht *ht = &amp;iter-&gt;d-&gt;ht[iter-&gt;table];</span><br><span class="line">            <span class="keyword">if</span> (iter-&gt;index == <span class="number">-1</span> &amp;&amp; iter-&gt;table == <span class="number">0</span>) &#123;</span><br><span class="line">                <span class="keyword">if</span> (iter-&gt;safe)</span><br><span class="line">                    <span class="comment">//给字典的 iterators 字段自增，禁止 rehash操作</span></span><br><span class="line">                    iter-&gt;d-&gt;iterators++;</span><br><span class="line">                <span class="keyword">else</span></span><br><span class="line">                    <span class="comment">//计算并保存指纹信息</span></span><br><span class="line">                    iter-&gt;fingerprint = dictFingerprint(iter-&gt;d);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//迭代器开始工作，指向 0 号桶</span></span><br><span class="line">            iter-&gt;index++;</span><br><span class="line">            <span class="comment">//如果 index 大于等于 size，即最后一个桶迭代结束</span></span><br><span class="line">            <span class="keyword">if</span> (iter-&gt;index &gt;= (<span class="keyword">long</span>) ht-&gt;size) &#123;</span><br><span class="line">                <span class="keyword">if</span> (dictIsRehashing(iter-&gt;d) &amp;&amp; iter-&gt;table == <span class="number">0</span>) &#123;</span><br><span class="line">                    <span class="comment">//当前字典结构正在 rehash 且 ht[0] 已经遍历结束</span></span><br><span class="line">                    <span class="comment">//继续遍历 ht[1]</span></span><br><span class="line">                    iter-&gt;table++;</span><br><span class="line">                    iter-&gt;index = <span class="number">0</span>;</span><br><span class="line">                    ht = &amp;iter-&gt;d-&gt;ht[<span class="number">1</span>];</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    <span class="comment">//否则表示迭代工作确实全部结束</span></span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//根据 index 取出节点</span></span><br><span class="line">            iter-&gt;entry = ht-&gt;table[iter-&gt;index];</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">//如果 entry 不等于 null，尝试遍历它的后续节点</span></span><br><span class="line">            iter-&gt;entry = iter-&gt;nextEntry;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//到这里，迭代器已经拿到下一个节点了</span></span><br><span class="line">        <span class="keyword">if</span> (iter-&gt;entry) &#123;</span><br><span class="line">            <span class="comment">//记录 nextEntry 节点的值</span></span><br><span class="line">            iter-&gt;nextEntry = iter-&gt;entry-&gt;next;</span><br><span class="line">            <span class="keyword">return</span> iter-&gt;entry;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>大部分逻辑都已经注释上了，整个方法是一个死循环，如果 entry 等于 null，要么是迭代器初次工作，要么是迭代到一个桶的最后节点处了。如果是后者，会进入 if 逻辑中，判断是否整个字典全部迭代结束，如果不是取下一个桶。</p><p>如果字典未处于 rehash 状态，自增 iterators 属性的操作会禁止后续节点操作触发 rehash，如果已经处于 rehash 过程了，也不慌，当前 ht[0] 迭代结束后，再去迭代早于迭代器工作前已经被转移到 ht[1] 的那些节点。因为如果你是安全迭代器的话，iterators 一自增之后，后续节点就不会触发 rehash 迁移节点，所以不会重复迭代数据。</p><p>迭代器迭代结束之后需要释放关闭释放迭代器，redis 中对应方法：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">dictReleaseIterator</span><span class="params">(dictIterator *iter)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (!(iter-&gt;index == <span class="number">-1</span> &amp;&amp; iter-&gt;table == <span class="number">0</span>)) &#123;</span><br><span class="line">        <span class="keyword">if</span> (iter-&gt;safe)</span><br><span class="line">            iter-&gt;d-&gt;iterators--;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            assert(iter-&gt;fingerprint == dictFingerprint(iter-&gt;d));</span><br><span class="line">    &#125;</span><br><span class="line">    zfree(iter);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如果是安全的迭代器，自减 iterators，不安全迭代器会重新计算指纹并与迭代器最开始工作时计算的指纹比较，并通过 assert 断言判断指纹是否一致，如果不一致则说明你在不安全的迭代器中执行了修改字典结构的方法，程序报错并退出。</p><p>以上就是 redis 字典中基础的两个安全与非安全迭代器用法及其原理，终究是不允许边 rehash 边遍历的，其实 redis 中还有一种高级遍历方式，大家叫它 scan 遍历，它允许边 rehash 边迭代，比较高级，我们后续会分析它的源码，敬请期待！</p><hr><h2 id="第四节-跳跃表"><a href="#第四节-跳跃表" class="headerlink" title="第四节 跳跃表"></a><strong>第四节 跳跃表</strong></h2><p>我们都知道单链表有一个致命的弱点，查找任一节点都至少 O(n) 的时间复杂度，它需要遍历一遍整个链表，那么有没有办法提升链表的搜索效率？</p><p>跳跃表（SkipList）这种数据结构使用空间换时间的策略，通过给链表建立多层索引来加快搜索效率，我们先介绍跳跃表的基本理论，再来看看 redis 中的实现情况。</p><h3 id="一、跳跃表（SkipList）"><a href="#一、跳跃表（SkipList）" class="headerlink" title="一、跳跃表（SkipList）"></a>一、跳跃表（SkipList）</h3><p><img src="https://user-gold-cdn.xitu.io/2019/10/12/16dbffe59b8e16ad?imageView2/0/w/1280/h/960/format/webp/ignore-error/1" alt="image"></p><p>这是一条带哨兵的双端链表，大部分场景下的链表都是这种结构，它的好处是，无论是头插法还是尾插法，插入操作都是常量级别的时间复杂度，删除也是一样。但缺点就是，如果想要查询某个节点，则需要 O(n)。</p><p>那如果我们给链表加一层索引呢？当然前提是最底层的链表是有序的，不然索引也没有意义了。</p><p><img src="https://user-gold-cdn.xitu.io/2019/10/12/16dbffe5a1111a7c?imageView2/0/w/1280/h/960/format/webp/ignore-error/1" alt="image"></p><p>让 HEAD 头指针指向最高索引，我抽出来一层索引，这样即便你查找节点 2222 三次比较。</p><p>第一次：与 2019 节点比较，发现大于 2019，往后继续</p><p>第二次：与 2100 节点比较，发现依然大于，往后继续</p><p>第三次：本层索引到头了，指向低层索引的下一个节点，继续比较，找到节点</p><p>而无索引的链表需要四次，效率看起来不是很明显，但是随着链表节点数量增多，索引层级增多，效率差距会很明显。图就不自己画了，取自极客时间王争老师的一张图。</p><p><img src="data:image/svg+xml;utf8,&lt;?xml version=&quot;1.0&quot;?&gt;&lt;svg xmlns=&quot;&quot; version=&quot;1.1&quot; width=&quot;1142&quot; height=&quot;636&quot;&gt;&lt;/svg" alt="image"></p><p>你看，原本需要 62 次比较操作，通过五层索引，只需要 4 次比较，跳跃表的效率可见一瞥。</p><p>想要知道具体跳跃表与链表差距多少，我们接下来进行它们各个操作的时间复杂度分析对比。</p><p><strong>1、插入节点操作</strong></p><p>双端链表（以下我们简称链表）的原本插入操作是 O(1) 的时间复杂度，但是这里我们讨论的是有序链表，所以插入一个节点至少还要找到它该插入的位置，然后才能执行插入操作，所以链表的插入效率是 O(n)。</p><p>跳跃表（以下我们简称跳表）也依然是需要两个步骤才能完成插入操作，先找到该插入的位置，再进行插入操作。我们设定一个具有 N 个节点的链表，它建有 K 层索引并假设每两个节点间隔就向上分裂一层索引。</p><p>k 层两个节点，k-1 层 4 个节点，k-2 层 8 个节点 … 第一层 n 个节点，</p><figure class="highlight lsl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">1</span>：n</span><br><span class="line"><span class="number">2</span>：<span class="number">1</span>/<span class="number">2</span> * n</span><br><span class="line"><span class="number">3</span>：<span class="number">1</span>/<span class="number">2</span>^<span class="number">2</span> * n</span><br><span class="line">.....</span><br><span class="line">.....</span><br><span class="line">k：<span class="number">1</span>/<span class="number">2</span>^(k<span class="number">-1</span>) * n</span><br></pre></td></tr></table></figure><p>1/2^(k-1) <em> n 表示第 k 层节点数，1/2^(k-1) </em> n=2 可以得到，k 等于 logn，也就是说 ，N 个节点构建跳表将需要 logn 层索引，包括自身那层链表层。</p><p>而当我们要搜索某个节点时，需要从最高层索引开始，按照我们的构建方式，某个节点必然位于两个索引节点之间，所以每一层都最多访问三个节点。这一点你可能需要理解理解，因为每一层索引的搜索都是基于上一层索引的，从上一层索引下来，要么是大于（小于）当前的索引节点，但不会大于（小于）其往后两个位置的节点，也就是当前索引节点的上一层后一索引节点，所以它最多访问三个节点。</p><p>有了这一结论，我们向跳表中插入一个元素的时间复杂度就为：O(logn)。这个时间复杂度等于二分查找的时间复杂度，所有有时我们又称跳表是实现了二分查找的链表。</p><p>很明显，插入操作，跳表完胜链表。</p><p><strong>2、修改删除查询</strong></p><p>这三个节点操作其实没什么可比性，修改删除操作，链表等效于跳表。而查询，我们上面也说了，链表至少 O(n)，跳表在 O(logn)。</p><p>除此之外，我们都知道红黑树在每次插入节点后会自旋来进行树的平衡，那么跳表其实也会有这么一个问题，就是不断的插入，会导致底层链表节点疯狂增长，而索引层依然那么多，极端情况所有节点都新增到最后一级索引节点的右边，进而使跳表退化成链表。</p><p>简单一句话来说，就是大量的节点插入之后，而不更新索引的话，跳表将无法一如既往的保证效率。解决办法也很简单，就是每一次节点的插入，触发索引节点的更新，我们具体来看一下更新策略。</p><p>一般跳表会使用一个随机函数，这个随机函数会在跳表新增了一个节点后，根据跳表的目前结构生成一个随机数，这个数值当然要小于最大的索引层值，假定这个值等于 m，那么跳表会生成从 1 到 m 层的索引。所以这个随机函数的选择或者说实现就显得很重要了，关于它我们这里不做讨论，大家可以看看各种跳表的实现中是如何实现这个随机函数的，典型的就是 Java 中 ConcurrentSkipListMap 内部实现的 SkipList 结构，当然还有我们马上要介绍的 redis 中的实现。</p><p>以上就是跳表这种数据结构的基本理论内容，接下来我们看 redis 中的实现情况。</p><h3 id="二、Redis-中的跳跃表"><a href="#二、Redis-中的跳跃表" class="headerlink" title="二、Redis 中的跳跃表"></a>二、Redis 中的跳跃表</h3><p>说在前面的是，redis 自己实现了跳表，但目的是为它的有序集合等高层抽象数据结构提供服务，所以等下我们分析源代码的时候其中必然会涉及到一些看似无用的结构和代码逻辑，但那些也是非常重要的，我们也会提及有序集合相关的内容，但不会拆分细致，重点还是看跳表的实现。</p><p>跳表的数据结构定义如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">zskiplist</span> &#123;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">zskiplistNode</span> *<span class="title">header</span>, *<span class="title">tail</span>;</span></span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">long</span> length;</span><br><span class="line">    <span class="keyword">int</span> level;</span><br><span class="line">&#125; zskiplist;</span><br></pre></td></tr></table></figure><p>跳表中的每个节点用数据结构 zskiplistNode 表示，head 和 tail 分别指向最底层链表的头尾节点。length 表示当前跳表最底层链表有多少个节点，level 记录当前跳表最高索引层数。</p><p>zskiplistNode 结构如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">zskiplistNode</span> &#123;</span></span><br><span class="line">    sds ele;</span><br><span class="line">    <span class="keyword">double</span> score;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">zskiplistNode</span> *<span class="title">backward</span>;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">zskiplistLevel</span> &#123;</span></span><br><span class="line">        <span class="class"><span class="keyword">struct</span> <span class="title">zskiplistNode</span> *<span class="title">forward</span>;</span></span><br><span class="line">        <span class="keyword">unsigned</span> <span class="keyword">int</span> span;</span><br><span class="line">    &#125; level[];</span><br><span class="line">&#125; zskiplistNode;</span><br></pre></td></tr></table></figure><p>我这里摘取的 redis 源码是 4.0 版本的，以前版本 ele 属性是一个 RedisObject 类型，现在是一个字符串类型，也即表示跳表现在只用于存储字符串数据。</p><p>score 记录当前节点的一个分值，最底层的链表就是按照分值大小有序的串联的，并且我们查询一个节点，一般也会传入该节点的 score 值，毕竟数值类型比较起来方便。</p><p>backward 指针指向前一个节点，为什么是倒着往前，我们待会会说。</p><p>level 是比较关键的一个点，这里面是一个 level 数组，而每个元素又都是一个 zskiplistLevel 类型的结构，zskiplistLevel 类型包括一个 forward 前向指针，一个 span 跨度值，具体是什么意思，我们一点点说。</p><p>跳表理论上在最底层是一条双端链表，然后基于此建立了多层索引节点以实现的，但在实际的代码实现上，这种结构是不好表述的，所以你要打破既有的惯性思维，然后才能好理解 redis 中的实现。实际上正如我们上述介绍的 zskiplistNode 结构一样，<strong>每个节点除了存储节点自身的数据外，还通过 level 数组保存了该节点在整个跳表各个索引层的节点引用</strong>，具体结构就是这样的：</p><p><img src="data:image/svg+xml;utf8,&lt;?xml version=&quot;1.0&quot;?&gt;&lt;svg xmlns=&quot;http://www.w3.org/2000/svg&quot; version=&quot;1.1&quot; width=&quot;216&quot; height=&quot;367&quot;&gt;&lt;/svg" alt="image"></p><p>而整张跳表基本就是这样的结构：</p><p><img src="data:image/svg+xml;utf8,&lt;?xml version=&quot;1.0&quot;?&gt;&lt;svg xmlns=&quot;http://www.w3.org/2000/svg&quot; version=&quot;1.1&quot; width=&quot;800&quot; height=&quot;554&quot;&gt;&lt;/svg" alt="image"></p><p>每一个节点的 backward 指针指向自己前面的一个节点，而每个节点中的 level 数组记录的就是当前节点在跳表的哪些索引层出现，并通过其 forward 指针顺序串联这一层索引的各个节点，0 表示第一层，1 表示第二层，等等以此类推。span 表示的是当前节点与后面一个节点的跨度，我们等下还会在代码里说到，暂时不理解也没关系。</p><p>基本上跳表就是这样一个结构，上面那张图还是很重要的，包括我们等下介绍源码实现，也对你理解有很大帮助的。（毕竟我画了半天。。）</p><p>这里多插一句，与跳表相关结构定义在一起的还有一个有序集合结构，很多人会说 redis 中的有序集合是跳表实现的，这句话不错，但有失偏驳。</p><figure class="highlight mipsasm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">typedef struct zset &#123;</span><br><span class="line">    <span class="keyword">dict </span>*<span class="keyword">dict;</span></span><br><span class="line"><span class="keyword"> </span>   zskiplist *zsl<span class="comment">;</span></span><br><span class="line">&#125; zset<span class="comment">;</span></span><br></pre></td></tr></table></figure><p>准确来说，redis 中的有序集合是由我们之前介绍过的字典加上跳表实现的，字典中保存的数据和分数 score 的映射关系，每次插入数据会从字典中查询，如果已经存在了，就不再插入，有序集合中是不允许重复数据。</p><p>下面我们看看 redis 中跳表的相关代码的实现情况。</p><p><strong>1、跳表初始化</strong></p><p>redis 中初始化一个跳表的代码如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">zskiplistNode *<span class="title">zslCreateNode</span><span class="params">(<span class="keyword">int</span> level, <span class="keyword">double</span> score, sds ele)</span> </span>&#123;</span><br><span class="line">    zskiplistNode *zn =</span><br><span class="line">        zmalloc(<span class="keyword">sizeof</span>(*zn)+level*<span class="keyword">sizeof</span>(struct zskiplistLevel));</span><br><span class="line">    zn-&gt;score = score;</span><br><span class="line">    zn-&gt;ele = ele;</span><br><span class="line">    <span class="keyword">return</span> zn;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* Create a new skiplist. */</span></span><br><span class="line"><span class="function">zskiplist *<span class="title">zslCreate</span><span class="params">(<span class="keyword">void</span>)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> j;</span><br><span class="line">    zskiplist *zsl;</span><br><span class="line">    <span class="comment">//分配内存空间</span></span><br><span class="line">    zsl = zmalloc(<span class="keyword">sizeof</span>(*zsl));</span><br><span class="line">    <span class="comment">//默认只有一层索引</span></span><br><span class="line">    zsl-&gt;level = <span class="number">1</span>;</span><br><span class="line">    <span class="comment">//0 个节点</span></span><br><span class="line">    zsl-&gt;length = <span class="number">0</span>;</span><br><span class="line">    <span class="comment">//1、创建一个 node 节点，这是个哨兵节点</span></span><br><span class="line">    <span class="comment">//2、为 level 数组分配 ZSKIPLIST_MAXLEVEL=32 内存大小</span></span><br><span class="line">    <span class="comment">//3、也即 redis 中支持索引最大 32 层</span></span><br><span class="line">    zsl-&gt;header = zslCreateNode(ZSKIPLIST_MAXLEVEL,<span class="number">0</span>,<span class="literal">NULL</span>);</span><br><span class="line">    <span class="comment">//为哨兵节点的 level 初始化</span></span><br><span class="line">    <span class="keyword">for</span> (j = <span class="number">0</span>; j &lt; ZSKIPLIST_MAXLEVEL; j++) &#123;</span><br><span class="line">        zsl-&gt;header-&gt;level[j].forward = <span class="literal">NULL</span>;</span><br><span class="line">        zsl-&gt;header-&gt;level[j].span = <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    zsl-&gt;header-&gt;backward = <span class="literal">NULL</span>;</span><br><span class="line">    zsl-&gt;tail = <span class="literal">NULL</span>;</span><br><span class="line">    <span class="keyword">return</span> zsl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>zslCreate 用于初始化一个跳表，比较简单，我也给出了基本的注释，这里不再赘述了，强调一点的是，redis 中实现的跳表最高允许 32 层索引，这么做也是一种性能与内存之间的衡量，过多的索引层必然占用更多的内存空间，32 是一个比较合适值。</p><p><strong>2、插入一个节点</strong></p><p>插入一个节点的代码比较多，也稍微有点复杂，希望你也有耐心和我一起来分析。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">zskiplistNode *<span class="title">zslInsert</span><span class="params">(zskiplist *zsl, <span class="keyword">double</span> score, sds ele)</span> </span>&#123;</span><br><span class="line">    <span class="comment">//update数组将用于记录新节点在每一层索引的目标插入位置</span></span><br><span class="line">    zskiplistNode *update[ZSKIPLIST_MAXLEVEL], *x;</span><br><span class="line">    <span class="comment">//rank数组记录目标节点每一层的排名</span></span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">int</span> rank[ZSKIPLIST_MAXLEVEL];</span><br><span class="line">    <span class="keyword">int</span> i, level;</span><br><span class="line"></span><br><span class="line">    serverAssert(!isnan(score));</span><br><span class="line">    <span class="comment">//指向哨兵节点</span></span><br><span class="line">    x = zsl-&gt;header;</span><br><span class="line">    <span class="comment">//这一段就是遍历每一层索引，找到最后一个小于当前给定score值的节点</span></span><br><span class="line">    <span class="comment">//从高层索引向底层索引遍历</span></span><br><span class="line">    <span class="keyword">for</span> (i = zsl-&gt;level<span class="number">-1</span>; i &gt;= <span class="number">0</span>; i--) &#123;</span><br><span class="line">        <span class="comment">//rank记录的是节点的排名，正常情况下给它初始值等于上一层目标节点的排名</span></span><br><span class="line">        <span class="comment">//如果当前正在遍历最高层索引，那么这个初始值暂时给0</span></span><br><span class="line">        rank[i] = i == (zsl-&gt;level<span class="number">-1</span>) ? <span class="number">0</span> : rank[i+<span class="number">1</span>];</span><br><span class="line">        <span class="keyword">while</span> (x-&gt;level[i].forward &amp;&amp;</span><br><span class="line">                (x-&gt;level[i].forward-&gt;score &lt; score ||</span><br><span class="line">                    (x-&gt;level[i].forward-&gt;score == score &amp;&amp;</span><br><span class="line">                    sdscmp(x-&gt;level[i].forward-&gt;ele,ele) &lt; <span class="number">0</span>)))</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">//我们说过level结构中，span表示的是与后面一个节点的跨度</span></span><br><span class="line">            <span class="comment">//rank[i]最终会得到我们要找的目标节点的排名，也就是它前面有多少个节点</span></span><br><span class="line">            rank[i] += x-&gt;level[i].span;</span><br><span class="line">            <span class="comment">//挪动指针</span></span><br><span class="line">            x = x-&gt;level[i].forward;</span><br><span class="line">        &#125;</span><br><span class="line">        update[i] = x;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//至此，update数组中已经记录好，每一层最后一个小于给定score值的节点</span></span><br><span class="line">    <span class="comment">//我们的新节点只需要插在他们后即可</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">//random算法获取一个平衡跳表的level值，标志着我们的新节点将要在哪些索引出现</span></span><br><span class="line">    <span class="comment">//具体算法这里不做分析，你也可以私下找我讨论</span></span><br><span class="line">    level = zslRandomLevel();</span><br><span class="line">    <span class="comment">//如果产生值大于当前跳表最高索引</span></span><br><span class="line">    <span class="keyword">if</span> (level &gt; zsl-&gt;level) &#123;</span><br><span class="line">        <span class="comment">//为高出来的索引层赋初始值，update[i]指向哨兵节点</span></span><br><span class="line">        <span class="keyword">for</span> (i = zsl-&gt;level; i &lt; level; i++) &#123;</span><br><span class="line">            rank[i] = <span class="number">0</span>;</span><br><span class="line">            update[i] = zsl-&gt;header;</span><br><span class="line">            update[i]-&gt;level[i].span = zsl-&gt;length;</span><br><span class="line">        &#125;</span><br><span class="line">        zsl-&gt;level = level;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//根据score和ele创建节点</span></span><br><span class="line">    x = zslCreateNode(level,score,ele);</span><br><span class="line">    <span class="comment">//每一索引层得进行新节点插入，建议对照我之前给出的跳表示意图</span></span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; level; i++) &#123;</span><br><span class="line">        <span class="comment">//断开指针，插入新节点</span></span><br><span class="line">        x-&gt;level[i].forward = update[i]-&gt;level[i].forward;</span><br><span class="line">        update[i]-&gt;level[i].forward = x;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//rank[0]等于新节点再最底层链表的排名，就是它前面有多少个节点</span></span><br><span class="line">        <span class="comment">//update[i]-&gt;level[i].span记录的是目标节点与后一个索引节点之间的跨度，即跨越了多少个节点</span></span><br><span class="line">        <span class="comment">//得到新插入节点与后一个索引节点之间的跨度</span></span><br><span class="line">        x-&gt;level[i].span = update[i]-&gt;level[i].span - (rank[<span class="number">0</span>] - rank[i]);</span><br><span class="line">        <span class="comment">//修改目标节点的span值</span></span><br><span class="line">        update[i]-&gt;level[i].span = (rank[<span class="number">0</span>] - rank[i]) + <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//如果上面产生的平衡level大于跳表最高使用索引，我们上面说会为高出部分做初始化</span></span><br><span class="line">    <span class="comment">//这里是自增他们的span值，因为新插入了一个节点，跨度自然要增加</span></span><br><span class="line">    <span class="keyword">for</span> (i = level; i &lt; zsl-&gt;level; i++) &#123;</span><br><span class="line">        update[i]-&gt;level[i].span++;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//修改 backward 指针与 tail 指针</span></span><br><span class="line">    x-&gt;backward = (update[<span class="number">0</span>] == zsl-&gt;header) ? <span class="literal">NULL</span> : update[<span class="number">0</span>];</span><br><span class="line">    <span class="keyword">if</span> (x-&gt;level[<span class="number">0</span>].forward)</span><br><span class="line">        x-&gt;level[<span class="number">0</span>].forward-&gt;backward = x;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        zsl-&gt;tail = x;</span><br><span class="line">    zsl-&gt;length++;</span><br><span class="line">    <span class="keyword">return</span> x;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>整个方法我都已经给出了注释，具体的不再细说，欢迎你与我交流讨论，整体的逻辑分为三个步骤。</p><ol><li>从最高索引层开始遍历，根据 score 找到它的前驱节点，用 update 数组进行保存</li><li>每一层得进行节点的插入，并计算更新 span 值</li><li>修改 backward 指针与 tail 指针</li></ol><p>删除节点也是类似的，首先需要根据 score 值找到目标节点，然后断开前后节点的连接，完成节点删除。</p><p><strong>3、特殊的查询操作</strong></p><p>因为 redis 的跳表实现中，增设了 span 这个跨度字段，它记录了与当前节点与后一个节点之间的跨度，所以就具有以下一些查询方法。</p><p><strong>a、zslGetRank</strong></p><p>返回包含给定成员和分值的节点在跳跃表中的排位。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">unsigned</span> <span class="keyword">long</span> <span class="title">zslGetRank</span><span class="params">(zskiplist *zsl, <span class="keyword">double</span> score, sds ele)</span> </span>&#123;</span><br><span class="line">    zskiplistNode *x;</span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">long</span> rank = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> i;</span><br><span class="line"></span><br><span class="line">    x = zsl-&gt;header;</span><br><span class="line">    <span class="keyword">for</span> (i = zsl-&gt;level<span class="number">-1</span>; i &gt;= <span class="number">0</span>; i--) &#123;</span><br><span class="line">        <span class="keyword">while</span> (x-&gt;level[i].forward &amp;&amp;</span><br><span class="line">            (x-&gt;level[i].forward-&gt;score &lt; score ||</span><br><span class="line">                (x-&gt;level[i].forward-&gt;score == score &amp;&amp;</span><br><span class="line">                sdscmp(x-&gt;level[i].forward-&gt;ele,ele) &lt;= <span class="number">0</span>))) &#123;</span><br><span class="line">            rank += x-&gt;level[i].span;</span><br><span class="line">            x = x-&gt;level[i].forward;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">/* x might be equal to zsl-&gt;header, so test if obj is non-NULL */</span></span><br><span class="line">        <span class="keyword">if</span> (x-&gt;ele &amp;&amp; sdscmp(x-&gt;ele,ele) == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> rank;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>你会发现，这个方法的核心代码其实就是我们插入节点方法的一个部分，通过累计 span 得到目标节点的一个排名值。</p><p><strong>b、zslGetElementByRank</strong></p><p>通过给定排名查询元素。这个方法就更简单了。</p><p><strong>c、zslIsInRange</strong></p><p>给定一个分值范围（range）， 比如 0 到 10， 如果给定的分值范围包含在跳跃表的分值范围之内， 那么返回 1 ，否则返回 0 。</p><p><strong>d、zslFirstInRange</strong></p><p>给定一个分值范围， 返回跳跃表中第一个符合这个范围的节点。</p><p><strong>e、zslDeleteRangeByScore</strong></p><p>给定一个分值范围， 删除跳跃表中所有在这个范围之内的节点。</p><p><strong>f、zslDeleteRangeByRank</strong></p><p>给定一个排名范围， 删除跳跃表中所有在这个范围之内的节点。</p><p>其实，后面列出来的那些根据排名，甚至一个范围查询删除节点的方法，都仰仗的是 span 这个字段，这也是为什么 insert 方法中需要通过那么复杂的计算逻辑对 span 字段进行计算的一个原因。</p><p>总结一下，跳表是为有序集合服务的，通过多层索引把链表的搜索效率提升到 O(logn)级别，但修改删除依然是 O(1)，是一个较为优秀的数据结构，而 redis 中的实现把每个节点实现成类似楼房一样的结构，也即我们的索引层，非常的巧妙。</p><hr><h2 id="第五节-整数集合"><a href="#第五节-整数集合" class="headerlink" title="第五节 整数集合"></a><strong>第五节 整数集合</strong></h2><p>当一个集合中只包含整数，并且元素的个数不是很多的话，redis 会用整数集合作为底层存储，它的一个优点就是可以节省很多内存，虽然字典结构的效率很高，但是它的实现结构相对复杂并且会分配较多的内存空间。</p><p>而我们的整数集合（intset）可以做到使用较少的内存空间却达到和字典一样效率的实现，但也是前提的，集合中只能包含整型数据并且数量不能太多。整数集合最多能存多少个元素在 redis 中也是有体现的。</p><blockquote><p>OBJ_SET_MAX_INTSET_ENTRIES 512</p></blockquote><p>也就是超过 512 个元素，或者向集合中添加了字符串或其他数据结构，redis 会将整数集合向字典结构进行转换。</p><h3 id="一、基本的数据结构"><a href="#一、基本的数据结构" class="headerlink" title="一、基本的数据结构"></a>一、基本的数据结构</h3><p>intset 的结构定义很简单，有以下成员构成：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">intset</span> &#123;</span></span><br><span class="line">    <span class="keyword">uint32_t</span> encoding;</span><br><span class="line">    <span class="keyword">uint32_t</span> length;</span><br><span class="line">    <span class="keyword">int8_t</span> contents [];</span><br><span class="line">&#125; intset;</span><br></pre></td></tr></table></figure><p>encoding 记录当前 intset 使用编码，有三个取值：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> INTSET_ENC_INT16 (sizeof(int16_t))</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> INTSET_ENC_INT32 (sizeof(int32_t))</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> INTSET_ENC_INT64 (sizeof(int64_t))</span></span><br></pre></td></tr></table></figure><p>length 记录整数集合中目前存储了多少个元素，contents 记录我们实际的数据集合，虽然我们看到结构体中给数组元素的类型定死成 int8_t，但实际上这个 int8_t 定义的毫无意义，因为这里的处理方式非常规的数组操作，content 字段虽然被定义成指向一个 int8_t 类型数据的指针，但实际上 redis 无论是读取数组元素还是新增元素进去都依赖 encoding 和 length 两个字段直接操作的内存。</p><p>基本数据结构还是非常的简单的，下面我们来看看它的一些核心方法。</p><h3 id="二、核心-API-实现"><a href="#二、核心-API-实现" class="headerlink" title="二、核心 API 实现"></a>二、核心 API 实现</h3><p><strong>1、初始化一个 intset</strong></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">intset *<span class="title">intsetNew</span><span class="params">(<span class="keyword">void</span>)</span> </span>&#123;</span><br><span class="line">    intset *is = zmalloc(<span class="keyword">sizeof</span>(intset));</span><br><span class="line">    is-&gt;encoding = intrev32ifbe(INTSET_ENC_INT16);</span><br><span class="line">    is-&gt;length = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">return</span> is;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可见，默认的 inset 配置是使用 INTSET_ENC_INT16 作为数据存储大小，并且不会为 content 数组初始化。常规的数组需要先预先确定数组长度，然后分配内存，继而通过 contents[x] 可以访问数组中任一元素。</p><p>但是，inset 这里是非常规式操作数组，encoding 字段定义了数组中每个元素实际类型，lenth 字段定义了数组中实际的元素个数，那么 contents[x] 是失效的，这种方式只会按照 int8_t 进行内存偏移，这种方式是拿不到正确的数据的，所以 redis 中通过 memcpy 按照 encoding 字段的值暴力直接偏移地址操作内存读取数据。</p><p>所以，这也是为什么 intset 初始化时不初始化 content 数组的原因所在，因为没有必要。而每当新增一个元素的时候都会去动态扩容原数组的长度以盛放下新插入进来的元素，扩容不会扩容很多，刚好一个新元素所占用的内存即可。具体的细节，我们接着看。</p><p><strong>2、添加新元素</strong></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">intset *<span class="title">intsetAdd</span><span class="params">(intset *is, <span class="keyword">int64_t</span> value, <span class="keyword">uint8_t</span> *success)</span> </span>&#123;</span><br><span class="line">    <span class="comment">//计算得到新插入的元素的编码</span></span><br><span class="line">    <span class="keyword">uint8_t</span> valenc = _intsetValueEncoding(value);</span><br><span class="line">    <span class="keyword">uint32_t</span> pos;</span><br><span class="line">    <span class="keyword">if</span> (success) *success = <span class="number">1</span>;</span><br><span class="line">    <span class="comment">//如果大于 intset 目前存储元素的编码大小</span></span><br><span class="line">    <span class="keyword">if</span> (valenc &gt; intrev32ifbe(is-&gt;encoding)) &#123;</span><br><span class="line">        <span class="comment">//触发 intset 升级</span></span><br><span class="line">        <span class="keyword">return</span> intsetUpgradeAndAdd(is,value);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">//二分搜索当前元素，如果元素已经存在会直接返回</span></span><br><span class="line">        <span class="comment">//如果没找到元素，pos 的值就是该元素的位置索引</span></span><br><span class="line">        <span class="keyword">if</span> (intsetSearch(is,value,&amp;pos)) &#123;</span><br><span class="line">            <span class="keyword">if</span> (success) *success = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">return</span> is;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//resize 集合，扩容一个元素的内存空间</span></span><br><span class="line">        is = intsetResize(is,intrev32ifbe(is-&gt;length)+<span class="number">1</span>);</span><br><span class="line">        <span class="comment">//移动 pos 后面的元素，以插入我们的新元素</span></span><br><span class="line">        <span class="keyword">if</span> (pos &lt; intrev32ifbe(is-&gt;length)) intsetMoveTail(is,pos,pos+<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//赋值</span></span><br><span class="line">    _intsetSet(is,pos,value);</span><br><span class="line">    is-&gt;length = intrev32ifbe(intrev32ifbe(is-&gt;length)+<span class="number">1</span>);</span><br><span class="line">    <span class="keyword">return</span> is;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>由此，我们应该知道为什么 intset 内的数据是有序且无重复的了，二分查找 O(logN)，但是 intset 插入一个元素却不是 O(logN)，因为有些情况会触发升级操作，或者极端情况下，会移动所有元素，时间复杂度达到 O(N)。</p><p><strong>3、升级</strong></p><p>我们先看示意图的变化，然后再分析源码，假设原 intset 使用 16 位的编码存储数据，先来了一个 32 位的数据，触发了我们的编码升级。</p><p>原 intset 结构如下：</p><p><img src="data:image/svg+xml;utf8,&lt;?xml version=&quot;1.0&quot;?&gt;&lt;svg xmlns=&quot;http://www.w3.org/2000/svg&quot; version=&quot;1.1&quot; width=&quot;472&quot; height=&quot;187&quot;&gt;&lt;/svg" alt="image"></p><p>新 intset 结构会扩容成这样：</p><p><img src="data:image/svg+xml;utf8,&lt;?xml version=&quot;1.0&quot;?&gt;&lt;svg xmlns=&quot;http://www.w3.org/2000/svg&quot; version=&quot;1.1&quot; width=&quot;537&quot; height=&quot;173&quot;&gt;&lt;/svg" alt="image"></p><p>虽然数据占用的内存已经分配好了，但是还需要做的是迁移每个元素占用的比特位。 做法是这样的，假设我们的新元素是 int_32 类型的数值 65536，那么首先我们会将这个 65536 放到[128-159]比特位区间，然后将 78 放到[96-127]比特位区间，并向前以此类推，最后我们会得到升级完成之后 intset。</p><p>下面我们看 redis 中代码的实现：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> intset *<span class="title">intsetUpgradeAndAdd</span><span class="params">(intset *is, <span class="keyword">int64_t</span> value)</span> </span>&#123;</span><br><span class="line">    <span class="comment">//intset目前的编码</span></span><br><span class="line">    <span class="keyword">uint8_t</span> curenc = intrev32ifbe(is-&gt;encoding);</span><br><span class="line">    <span class="comment">//intset即将扩展到的编码</span></span><br><span class="line">    <span class="keyword">uint8_t</span> newenc = _intsetValueEncoding(value);</span><br><span class="line">    <span class="keyword">int</span> length = intrev32ifbe(is-&gt;length);</span><br><span class="line">    <span class="keyword">int</span> prepend = value &lt; <span class="number">0</span> ? <span class="number">1</span> : <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//根据新的元素内存大小重新分配 intset 内存大小</span></span><br><span class="line">    is-&gt;encoding = intrev32ifbe(newenc);</span><br><span class="line">    is = intsetResize(is,intrev32ifbe(is-&gt;length)+<span class="number">1</span>);</span><br><span class="line">    <span class="comment">//这个地方我先标记一下 @1，下面详细分析</span></span><br><span class="line">    <span class="comment">//总体上你可以理解，就是我们上图画的那样，从原集合的最后一个元素</span></span><br><span class="line">    <span class="comment">//开始扩大它占用的比特位</span></span><br><span class="line">    <span class="keyword">while</span>(length--)</span><br><span class="line">        _intsetSet(is,length+prepend,_intsetGetEncoded(is,length,curenc));</span><br><span class="line"></span><br><span class="line">    <span class="comment">//将新元素放进 intset 中</span></span><br><span class="line">    <span class="keyword">if</span> (prepend)</span><br><span class="line">        _intsetSet(is,<span class="number">0</span>,value);</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        _intsetSet(is,intrev32ifbe(is-&gt;length),value);</span><br><span class="line">    is-&gt;length = intrev32ifbe(intrev32ifbe(is-&gt;length)+<span class="number">1</span>);</span><br><span class="line">    <span class="keyword">return</span> is;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>别的不再解释，我重点解释一下我做标记的 @1，这个循环其实是这个方法的核心点，它完成了将旧元素扩充比特位这么一个操作。</p><p>首先明确的一点是，升级操作只有两种情况会触发，一种是新插入一个较大的数值，另一种是新插入一个负很大的值，这两种情况都会导致类型不够存储，需要扩大数据位。</p><p>_intsetGetEncoded 这个方法可以根据给定了 length，也就是元素在数组中的下标取出旧数组中对应的元素，很显然，这里是从后往前倒着来的。</p><p>因为我们的 intsetResize 方法已经完成了扩容内存的操作，也就是说新元素的内存已经分配完毕，那么 _intsetSet 方法就会将 _intsetGetEncoded 取出的元素重新的向数组中赋值。循环结束时，就是所有元素重新归位的时候，最后再将新元素赋值进入数组最后的位置。</p><p>但其实细心的同学会发现，_intsetSet 方法在传下标索引的时候实际传的是 length+prepend，这其实就是我们说，如果 value 是小于零的，length+prepend 最终会导致所有的旧元素往后挪了一个偏移量，然后新的元素会被赋值的索引为零的位置。也就是说，如果新插入的数值是负数，它会被头插进数组的第一个位置。</p><p>核心的几个 API 我们都已经介绍了，其他的一些 API 你可以自行参阅源码，相信对你不难。</p><p>总结一下，整数集合(intset)使用了非常简洁的数据结构，可以更少的占用内存存储一些整数，但终究是基于数组的，也就避免不了不能存储大量数据的缺点。总体来说，插入一个元素，最好情况 O(logN)，最坏的情况是 O(N)，摊还时间复杂度为 O(N)，查找一个元素，根据索引下标时间复杂度在 O(1)。当 intset 中的元素超过 512 个，或者向其中添加了字符串，redis 会将 intset 转换成字典。</p><hr><h2 id="第六节-压缩列表"><a href="#第六节-压缩列表" class="headerlink" title="第六节 压缩列表"></a><strong>第六节 压缩列表</strong></h2><p>上一篇我们介绍了 redis 中的整数集合这种数据结构的实现，也谈到了，引入这种数据结构的一个很大的原因就是，在某些仅有少量整数元素的集合场景，通过整数集合既可以达到字典的效率，也能使用远少于字典的内存达到同样的效果。</p><p>我们本篇介绍的压缩列表，相信你从他的名字里应该也能看出来，又是一个为了节约内存而设计的数据结构，它的数据结构相对于整数集合来说会复杂了很多，但是整数集合只能允许存储少量的整型数据，而我们的压缩列表可以允许存储少量的整型数据或字符串。</p><p>这是他们之间的一个区别，下面我们来看看这种数据结构。</p><h3 id="一、基本的结构定义"><a href="#一、基本的结构定义" class="headerlink" title="一、基本的结构定义"></a>一、基本的结构定义</h3><p><img src="https://user-gold-cdn.xitu.io/2019/11/13/16e64a764ad1fcd3?imageView2/0/w/1280/h/960/format/webp/ignore-error/1" alt="image"></p><ul><li>ZIPLIST_BYTES：四个字节，记录了整个压缩列表总共占用了多少字节数</li><li>ZIPLIST_TAIL_OFFSET：四个字节，记录了整个压缩列表第一个节点到最后一个节点跨越了多少个字节，通故这个字段可以迅速定位到列表最后一个节点位置</li><li>ZIPLIST_LENGTH：两个字节，记录了整个压缩列表中总共包含几个 zlentry 节点</li><li>zlentry：非固定字节，记录的是单个节点，这是一个复合结构，我们等下再说</li><li>0xFF：一个字节，十进制的值为 255，标志压缩列表的结尾</li></ul><p>其中，zlentry 在 redis 中确实有着这样的结构体定义，但实际上这个结构定义了一堆类似于 length 这样的字段，记录前一个节点和自身节点占用的字节数等等信息，用处不多，而我们更倾向于使用这样的逻辑结构来描述 zlentry 节点。</p><p><img src="https://user-gold-cdn.xitu.io/2019/11/13/16e64a764b42d99f?imageView2/0/w/1280/h/960/format/webp/ignore-error/1" alt="image"></p><p>这种结构在 redis 中是没有具体结构体定义的，请知悉，网上的很多博客文章都直接描述 zlentry 节点是这样的一种结构，其实是不准确的。</p><p>简单解释一下这三个字段的含义：</p><ul><li>previous_entry_length：每个节点会使用一个或者五个字节来描述前一个节点占用的总字节数，如果前一个节点占用的总字节数小于 254，那么就用一个字节存储，反之如果前一个节点占用的总字节数超过了 254，那么一个字节就不够存储了，这里会用五个字节存储并将第一个字节的值存储为固定值 254 用于区分。</li><li>encoding：压缩列表可以存储 16位、32位、64位的整数以及字符串，encoding 就是用来区分后面的 content 字段中存储于的到底是哪种内容，分别占多少字节，这个我们等下细说。</li><li>content：没什么特别的，存储的就是具体的二进制内容，整数或者字符串。</li></ul><p>下面我们细说一个 encoding 具体是怎么存储的。</p><p>主要分为两种，一种是字符串的存储格式：</p><table><thead><tr><th>编码</th><th>编码长度</th><th>content类型</th></tr></thead><tbody><tr><td>00xxxxxx</td><td>一个字节</td><td>长度小于 63 的字符串</td></tr><tr><td>01xxxxxx xxxxxxxx</td><td>两个字节</td><td>长度小于 16383 的字符串</td></tr><tr><td>10xxxxxx xxxxxxxx xxxxxxxx xxxxxxxx xxxxxxxx</td><td>五个字节</td><td>长度小于 4294967295 的字符串</td></tr></tbody></table><p>content 的具体长度，由编码除去高两位剩余的二进制位表示。</p><table><thead><tr><th>编码</th><th>编码长度</th><th>content类型</th></tr></thead><tbody><tr><td>11000000</td><td>一个字节</td><td>int16_t 类型的整数</td></tr><tr><td>11010000</td><td>一个字节</td><td>int32_t 类型的整数</td></tr><tr><td>11100000</td><td>一个字节</td><td>int64_t 类型的整数</td></tr><tr><td>11110000</td><td>一个字节</td><td>24 位有符号整数</td></tr><tr><td>11111110</td><td>一个字节</td><td>8 位有符号整数</td></tr></tbody></table><p>注意，整型数据的编码是固定 11 开头的八位二进制，而字符串类型的编码都是非固定的，因为它还需要通过后面的二进制位得到字符串的长度，稍有区别。</p><p>这就是压缩列表的基本的结构定义情况，下面我们通过节点的增删改查方法源码实现来看看 redis 中具体的实现情况。</p><h3 id="二、redis-的具体源码实现"><a href="#二、redis-的具体源码实现" class="headerlink" title="二、redis 的具体源码实现"></a>二、redis 的具体源码实现</h3><p><strong>1、ziplistNew</strong></p><p>我们先来看看压缩列表初始化的方法实现：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">unsigned</span> <span class="keyword">char</span> *<span class="title">ziplistNew</span><span class="params">(<span class="keyword">void</span>)</span> </span>&#123;</span><br><span class="line">    <span class="comment">//bytes=2*4+2</span></span><br><span class="line">    <span class="comment">//分配压缩列表结构所需要的字节数</span></span><br><span class="line">    <span class="comment">//ZIPLIST_BYTES + ZIPLIST_TAIL_OFFSET + ZIPLIST_LENGTH</span></span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">int</span> bytes = ZIPLIST_HEADER_SIZE+<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">char</span> *zl = zmalloc(bytes);</span><br><span class="line">    <span class="comment">//初始化 ZIPLIST_BYTES 字段</span></span><br><span class="line">    ZIPLIST_BYTES(zl) = intrev32ifbe(bytes);</span><br><span class="line">    <span class="comment">//初始化 ZIPLIST_TAIL_OFFSET</span></span><br><span class="line">    ZIPLIST_TAIL_OFFSET(zl) = intrev32ifbe(ZIPLIST_HEADER_SIZE);</span><br><span class="line">    <span class="comment">//初始化 ZIPLIST_LENGTH 字段</span></span><br><span class="line">    ZIPLIST_LENGTH(zl) = <span class="number">0</span>;</span><br><span class="line">    <span class="comment">//为压缩列表最后一个字节赋值 255</span></span><br><span class="line">    zl[bytes<span class="number">-1</span>] = ZIP_END;</span><br><span class="line">    <span class="keyword">return</span> zl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>2、ziplistPush</strong></p><p>接着我们看新增节点的源码实现：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">unsigned</span> <span class="keyword">char</span> *<span class="title">ziplistPush</span><span class="params">(<span class="keyword">unsigned</span> <span class="keyword">char</span> *zl, <span class="keyword">unsigned</span> <span class="keyword">char</span> *s</span></span></span><br><span class="line"><span class="function"><span class="params">        ,<span class="keyword">unsigned</span> <span class="keyword">int</span> slen, <span class="keyword">int</span> where)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">char</span> *p;</span><br><span class="line">    <span class="comment">//找到待插入的位置，头部或者尾部</span></span><br><span class="line">    p = (where == ZIPLIST_HEAD) ? ZIPLIST_ENTRY_HEAD(zl) : ZIPLIST_ENTRY_END(zl);</span><br><span class="line">    <span class="keyword">return</span> __ziplistInsert(zl,p,s,slen);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>解释一下 ziplistPush 的几个入参的含义。</p><p>zl 指向一个压缩列表的首地址，s 指向一个字符串首地址），slen 指向字符串的长度（如果节点存储的值是整型，存储的就是整型值），where 指明新节点的插入方式，头插亦或尾插。</p><p>ziplistPush 方法的核心是 __ziplistInsert：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">unsigned</span> <span class="keyword">char</span> *__ziplistInsert(<span class="keyword">unsigned</span> <span class="keyword">char</span> *zl, <span class="keyword">unsigned</span> <span class="keyword">char</span> *p, <span class="keyword">unsigned</span> <span class="keyword">char</span> *s, <span class="keyword">unsigned</span> <span class="keyword">int</span> slen) &#123;</span><br><span class="line">    <span class="keyword">size_t</span> curlen = intrev32ifbe(ZIPLIST_BYTES(zl)), reqlen;</span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">int</span> prevlensize, prevlen = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">size_t</span> offset;</span><br><span class="line">    <span class="keyword">int</span> nextdiff = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">char</span> encoding = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">long</span> <span class="keyword">long</span> value = <span class="number">123456789</span>; </span><br><span class="line">    zlentry tail;</span><br><span class="line">    <span class="comment">//prevlensize 存储前一个节点长度，本节点使用了几个字节 1 or 5</span></span><br><span class="line">    <span class="comment">//prelen  存储前一个节点实际占用了几个字节</span></span><br><span class="line">    <span class="keyword">if</span> (p[<span class="number">0</span>] != ZIP_END) &#123;</span><br><span class="line">        ZIP_DECODE_PREVLEN(p, prevlensize, prevlen);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">unsigned</span> <span class="keyword">char</span> *ptail = ZIPLIST_ENTRY_TAIL(zl);</span><br><span class="line">        <span class="keyword">if</span> (ptail[<span class="number">0</span>] != ZIP_END) &#123;</span><br><span class="line">            prevlen = zipRawEntryLength(ptail);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (zipTryEncoding(s,slen,&amp;value,&amp;encoding)) &#123;</span><br><span class="line">        <span class="comment">//s 指针指向一个整数，尝试进行一个转换并得到存储这个整数占用了几个字节</span></span><br><span class="line">        reqlen = zipIntSize(encoding);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">//s 指针指向一个字符串（字符数组），slen 就是他占用的字节数</span></span><br><span class="line">        reqlen = slen;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//当前节点存储数据占用 reqlen 个字节，加上存储前一个节点长度占用的字节数</span></span><br><span class="line">    reqlen += zipStorePrevEntryLength(<span class="literal">NULL</span>,prevlen);</span><br><span class="line">    <span class="comment">//encoding 字段存储实际占用字节数</span></span><br><span class="line">    reqlen += zipStoreEntryEncoding(<span class="literal">NULL</span>,encoding,slen);</span><br><span class="line">    <span class="comment">//至此，reqlen 保存了存储当前节点数据占用字节数和 encoding 编码占用的字节数总和</span></span><br><span class="line">    <span class="keyword">int</span> forcelarge = <span class="number">0</span>;</span><br><span class="line">    <span class="comment">//当前节点占用的总字节减去存储前一个节点字段占用的字节</span></span><br><span class="line">    <span class="comment">//记录的是这一个节点的插入会引起下一个节点占用字节的变化量</span></span><br><span class="line">    nextdiff = (p[<span class="number">0</span>] != ZIP_END) ? zipPrevLenByteDiff(p,reqlen) : <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">if</span> (nextdiff == <span class="number">-4</span> &amp;&amp; reqlen &lt; <span class="number">4</span>) &#123;</span><br><span class="line">        nextdiff = <span class="number">0</span>;</span><br><span class="line">        forcelarge = <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//扩容有可能导致 zl 的起始位置偏移，故记录 p 与 zl 首地址的相对偏差数，事后还原 p 指针指向</span></span><br><span class="line">    offset = p-zl;</span><br><span class="line">    zl = ziplistResize(zl,curlen+reqlen+nextdiff);</span><br><span class="line">    p = zl+offset;</span><br><span class="line">    <span class="keyword">if</span> (p[<span class="number">0</span>] != ZIP_END) &#123;</span><br><span class="line">        memmove(p+reqlen,p-nextdiff,curlen-offset<span class="number">-1</span>+nextdiff);</span><br><span class="line">        <span class="comment">//把当前节点占用的字节数存储到下一个节点的头部字段</span></span><br><span class="line">        <span class="keyword">if</span> (forcelarge)</span><br><span class="line">            zipStorePrevEntryLengthLarge(p+reqlen,reqlen);</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            zipStorePrevEntryLength(p+reqlen,reqlen);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//更新 tail_offset 字段，让他保存从头节点到尾节点之间的距离</span></span><br><span class="line">        ZIPLIST_TAIL_OFFSET(zl) =</span><br><span class="line">            intrev32ifbe(intrev32ifbe(ZIPLIST_TAIL_OFFSET(zl))+reqlen);</span><br><span class="line">        zipEntry(p+reqlen, &amp;tail);</span><br><span class="line">        <span class="keyword">if</span> (p[reqlen+tail.headersize+tail.len] != ZIP_END) &#123;</span><br><span class="line">            ZIPLIST_TAIL_OFFSET(zl) =</span><br><span class="line">                intrev32ifbe(intrev32ifbe(ZIPLIST_TAIL_OFFSET(zl))+nextdiff);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        ZIPLIST_TAIL_OFFSET(zl) = intrev32ifbe(p-zl);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//是否触发连锁更新</span></span><br><span class="line">    <span class="keyword">if</span> (nextdiff != <span class="number">0</span>) &#123;</span><br><span class="line">        offset = p-zl;</span><br><span class="line">        zl = __ziplistCascadeUpdate(zl,p+reqlen);</span><br><span class="line">        p = zl+offset;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//将节点写入指定位置</span></span><br><span class="line">    p += zipStorePrevEntryLength(p,prevlen);</span><br><span class="line">    p += zipStoreEntryEncoding(p,encoding,slen);</span><br><span class="line">    <span class="keyword">if</span> (ZIP_IS_STR(encoding)) &#123;</span><br><span class="line">        <span class="built_in">memcpy</span>(p,s,slen);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        zipSaveInteger(p,value,encoding);</span><br><span class="line">    &#125;</span><br><span class="line">    ZIPLIST_INCR_LENGTH(zl,<span class="number">1</span>);</span><br><span class="line">    <span class="keyword">return</span> zl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>具体细节我不再赘述，总结一下整个插入节点的步骤。</p><ol><li>计算并得到前一个节点的总长度，并判断得到当前待插入节点保存前一个节点长度的 previous_entry_length 占用字节数</li><li>根据传入的 s 和 slen，计算并保存 encoding 字段内容</li><li>构建节点并将数据写入节点添加到压缩列表中</li></ol><p><em>ps：重点要去理解压缩列表节点的数据结构定义，previous_entry_length、encoding、content 字段，这样才能比较容易理解节点新增操作的实现。</em></p><h3 id="三、连锁更新"><a href="#三、连锁更新" class="headerlink" title="三、连锁更新"></a>三、连锁更新</h3><p>谈到 redis 的压缩列表，就必然会谈到他的连锁更新，我们先引一张图：</p><p><img src="https://user-gold-cdn.xitu.io/2019/11/13/16e64a76497a20d5?imageView2/0/w/1280/h/960/format/webp/ignore-error/1" alt="image"></p><p>假设原本 entry1 节点占用字节数为 211（小于 254），那么 entry2 的 previous_entry_length 会使用一个字节存储 211，现在我们新插入一个节点 NEWEntry，这个节点比较大，占用了 512 个字节。</p><p>那么，我们知道，NEWEntry 节点插入后，entry2 的 previous_entry_length 存储不了 512，那么 redis 就会重分配内存，增加 entry2 的内存分配，并分配给 previous_entry_length 五个字节存储 NEWEntry 节点长度。</p><p>看似没什么问题，但是如果极端情况下，entry2 扩容四个字节后，导致自身占用字节数超过 254，就会又触发后一个节点的内存占用空间扩大，非常极端情况下，会导致所有的节点都扩容，这就是连锁更新，一次更新导致大量甚至全部节点都更新内存的分配。</p><p>如果连锁更新发生的概率很高的话，压缩列表无疑就会是一个低效的数据结构，但实际上连锁更新发生的条件是非常苛刻的，其一是需要大量节点长度小于 254 连续串联连接，其二是我们更新的节点位置恰好也导致后一个节点内存扩充更新。</p><p>基于这两点，且少量的连锁更新对性能是影响不大的，所以这里的连锁更新对压缩列表的性能是没有多大的影响的，可以忽略，但需要知晓。</p><hr><p><em>参考博客和文章书籍等：</em></p><blockquote><p>《Redis开发与运维》</p></blockquote><blockquote><p><a href="https://juejin.im/post/5d7dac02518825297023fb35" target="_blank" rel="noopener">Redis 的底层数据结构（SDS和链表）</a></p></blockquote><blockquote><p><a href="https://juejin.im/post/5d872b41f265da03ec2ea091" target="_blank" rel="noopener">Redis 的底层数据结构（字典）</a></p></blockquote><blockquote><p><a href="https://juejin.im/post/5da1ca58e51d4577fc7b1c5a" target="_blank" rel="noopener">Redis 的底层数据结构（跳跃表）</a></p></blockquote><blockquote><p><a href="https://juejin.im/post/5dac52a96fb9a04e2d36c9ec" target="_blank" rel="noopener">Redis 的底层数据结构（整数集合）</a></p></blockquote><blockquote><p><a href="https://juejin.im/post/5dcbf185f265da3072427647" target="_blank" rel="noopener">Redis 的底层数据结构（压缩列表）</a></p></blockquote><p><em>因博客主等未标明不可引用，若部分内容涉及侵权请及时告知，我会尽快修改和删除相关内容</em></p>]]></content>
    
    <summary type="html">
    
      简单整理Redis中的几种常见的底层数据结构，内容包括：等。
    
    </summary>
    
      <category term="技术文档" scheme="http://linyishui.top/categories/%E6%8A%80%E6%9C%AF%E6%96%87%E6%A1%A3/"/>
    
    
      <category term="redis" scheme="http://linyishui.top/tags/redis/"/>
    
  </entry>
  
  <entry>
    <title>时间复杂度</title>
    <link href="http://linyishui.top/2020061801.html"/>
    <id>http://linyishui.top/2020061801.html</id>
    <published>2020-06-18T11:03:47.000Z</published>
    <updated>2020-08-04T06:33:02.912Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="时间复杂度"><a href="#时间复杂度" class="headerlink" title="时间复杂度"></a><strong>时间复杂度</strong></h1><h2 id="第一节-概述"><a href="#第一节-概述" class="headerlink" title="第一节 概述"></a><strong>第一节 概述</strong></h2><p><strong>时间复杂度</strong>是一个函数，用于描述算法的运行时间。常用大O符号表示，如 <code>O(n)</code> 。时间复杂度可以被称为是<strong>渐进的</strong>，即考察输入值趋近于无穷时的情况，如一个算法对于任意数量n的输入，需要 5n^3^ + 3n 的时间运行完毕，则其渐进时间复杂度为 O(n^3^) 。</p><p>即使相同数目大小的不同输入值仍可能导致算法的运行时间不同，所以<strong>通常使用算法的最坏情况复杂度</strong>，即 <code>T(n)</code> 。</p><h3 id="1-1-常见时间复杂度"><a href="#1-1-常见时间复杂度" class="headerlink" title="1.1 常见时间复杂度"></a><strong>1.1 常见时间复杂度</strong></h3><ul><li>O(n^3^)：矩阵乘法的基础实现。</li><li>O(n^2^)：冒泡排序、插入排序。</li><li>O(loglogn)：有界优先队列的单个操作。</li><li>O(nlogn)：最快的比较排序。</li><li>O(logn)：二分搜索。</li><li>O(n)：无序数组的搜索。</li><li>O(1)：奇偶判断。</li></ul><p>对于时间复杂度中的对数表达式，一般默认底数为2（计算机偏爱2?），所以 logn 即 log~2~n。</p><h2 id="第二节-计算时间复杂度"><a href="#第二节-计算时间复杂度" class="headerlink" title="第二节 计算时间复杂度"></a><strong>第二节 计算时间复杂度</strong></h2><h3 id="2-1-步骤"><a href="#2-1-步骤" class="headerlink" title="2.1 步骤"></a><strong>2.1 步骤</strong></h3><ol><li>找出算法中的基本语句。<ul><li>基本语句即执行次数最多的语句，通常指最内层循环。</li></ul></li><li>计算基本语句的执行次数的数量级。<ul><li>可忽略所有的低次幂和高次幂的系数。</li></ul></li><li>用大O记号表示算法的时间性能。</li></ol><h3 id="2-2-实例"><a href="#2-2-实例" class="headerlink" title="2.2 实例"></a><strong>2.2 实例</strong></h3><h4 id="（1）单层和双层循环"><a href="#（1）单层和双层循环" class="headerlink" title="（1）单层和双层循环"></a><strong>（1）单层和双层循环</strong></h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>;i &lt; n;i++)</span><br><span class="line">       x++;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>;i &lt; n;i++)</span><br><span class="line">   <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">0</span>;j &lt; n;j++)</span><br><span class="line">       x++;</span><br></pre></td></tr></table></figure><p>两种基本语句都是最内层循环 <code>x++;</code> 。</p><p>单层循环执行了 n 次，双层循环执行了 n^2^ 次。</p><p>所以二者的时间复杂度分别为 O(n) 和 O(N^2^) 。</p><h4 id="（2）循环乘2"><a href="#（2）循环乘2" class="headerlink" title="（2）循环乘2"></a><strong>（2）循环乘2</strong></h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">i = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">while</span>(i &lt;= n)</span><br><span class="line">       i = i * <span class="number">2</span>;</span><br></pre></td></tr></table></figure><p>基本语句 <code>i = i * 2;</code> ，设y为其执行次数，则 2^y^ &lt;= n ，即 y &lt;= log~2~n 。</p><p>所以 T(n) = O(log~2~n) 。</p><h4 id="（3）冒泡排序"><a href="#（3）冒泡排序" class="headerlink" title="（3）冒泡排序"></a><strong>（3）冒泡排序</strong></h4><p>代码实现如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">BubbleSort</span> <span class="keyword">implements</span> <span class="title">IArraySort</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">int</span>[] sort(<span class="keyword">int</span>[] sourceArray) <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        <span class="comment">// 对 arr 进行拷贝，不改变参数内容</span></span><br><span class="line">        <span class="keyword">int</span>[] arr = Arrays.copyOf(sourceArray, sourceArray.length);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; arr.length; i++) &#123;</span><br><span class="line">            <span class="comment">// 设定一个标记，若为true，则表示此次循环没有进行交换，也就是待排序列已经有序，排序已经完成。</span></span><br><span class="line">            <span class="keyword">boolean</span> flag = <span class="keyword">true</span>;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; arr.length - i; j++) &#123;</span><br><span class="line">                <span class="comment">// 比较两个元素大小，若前大于后则交换</span></span><br><span class="line">                <span class="keyword">if</span> (arr[j] &gt; arr[j + <span class="number">1</span>]) &#123;</span><br><span class="line">                    <span class="keyword">int</span> tmp = arr[j];</span><br><span class="line">                    arr[j] = arr[j + <span class="number">1</span>];</span><br><span class="line">                    arr[j + <span class="number">1</span>] = tmp;</span><br><span class="line"></span><br><span class="line">                    flag = <span class="keyword">false</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (flag) &#123;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> arr;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>基本语句即比较操作 <code>arr[j] &gt; arr[j + 1]</code> ，其运行次数为 (n - 1) + (n - 2) + … + 2 + 1  = n (n - 1) / 2 = n^2^ / 2 。所以时间复杂度为 O(n^2^) 。</p><h4 id="（4）选择排序"><a href="#（4）选择排序" class="headerlink" title="（4）选择排序"></a><strong>（4）选择排序</strong></h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">sort</span><span class="params">(Comparable[] a)</span></span>&#123;<span class="comment">//将数组a按升序排序</span></span><br><span class="line">    <span class="keyword">int</span> N = a.length;<span class="comment">//记录数组长度</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>;i &lt; N;i++)&#123;<span class="comment">//将a[i]与a[i+1...N]最小元素交换</span></span><br><span class="line">        <span class="keyword">int</span> min = i;</span><br><span class="line">        <span class="comment">//循环遍历找到当前最小元素</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j = i+<span class="number">1</span>;j &lt; N;j++)</span><br><span class="line">            <span class="keyword">if</span>(less(a[j],a[min])) min = j;</span><br><span class="line">        <span class="comment">//将第i小元素交换至位置i</span></span><br><span class="line">        exch(a,i,min);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>基本语句 <code>min = j;</code> ，其运行次数为 (n - 1) + (n - 2) + … + 2 + 1 = n (n - 1) / 2 = n^2^ / 2 。</p><p>所以时间复杂度为 O(n^2^) 。</p><h4 id="（5）插入排序"><a href="#（5）插入排序" class="headerlink" title="（5）插入排序"></a><strong>（5）插入排序</strong></h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">sort</span><span class="params">(Comparable[] a)</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> N = a.length;</span><br><span class="line">    <span class="comment">// 从第二个元素开始遍历数组</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>;i &lt; N;i++)&#123;</span><br><span class="line">    <span class="comment">// 第二层游标j从游标i开始，逆向遍历，不断和比其小的元素交换位置，直到移动到0位置</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j = i;j &gt; <span class="number">0</span> &amp;&amp; less(a[j],a[j-<span class="number">1</span>]);j--)</span><br><span class="line">            exch(a, j, j-<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>基本语句 <code>less(a[j],a[j-1])</code> ，其运行次数为 1 + 2 + … + (n - 2) +  (n - 1) = n (n - 1) / 2 = n^2^ / 2 。</p><p>所以时间复杂度为 O(n^2^) 。</p><h4 id="（6）希尔排序"><a href="#（6）希尔排序" class="headerlink" title="（6）希尔排序"></a><strong>（6）希尔排序</strong></h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">sort</span><span class="params">(Comparable[] a)</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> N = a.length;</span><br><span class="line">    <span class="keyword">int</span> H = <span class="number">1</span>;</span><br><span class="line">    <span class="comment">// 根据元素数目初始化H：1、4、13、40、121...</span></span><br><span class="line">    <span class="keyword">while</span> (H &lt; N/<span class="number">3</span>)</span><br><span class="line">        H = <span class="number">3</span>*H + <span class="number">1</span>;</span><br><span class="line">    <span class="comment">//同插入排序，但游标不是相邻移动，而是间隔H，将a[i]插入到a[i-H],a[i-2H]...之中</span></span><br><span class="line">    <span class="keyword">while</span> (H &gt;= <span class="number">1</span>) &#123;</span><br><span class="line">    <span class="comment">// 游标i从H开始遍历数组</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = H;i &lt; N;i++)&#123;</span><br><span class="line">        <span class="comment">// 游标j仍从游标i开始，逆向隔H遍历，</span></span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j = i; j &gt;=H &amp;&amp; less(a[j],a[j-H]);j-=H)<span class="comment">//</span></span><br><span class="line">                exch(a,j,j-H);</span><br><span class="line">        &#125;</span><br><span class="line">        H = H/<span class="number">3</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>基本语句 <code>less(a[j],a[j-H])</code> ，希尔排序的性能论证十分复杂，目前的结论是其运行时间达不到平方级别，运行次数本人目前浅陋的数学水平无法归纳，根据书本和互联网获得的答案是<strong>平均时间复杂度为 O(nlogn) </strong>，<strong>最坏情况大概与 N^(3/2)^ 成正比</strong>，相比插入排序一点微小的改变就突破了平方的屏障，这正是算法设计的目标。</p><p>所以时间复杂度为 O(nlogn) 。</p><h4 id="（7）归并排序"><a href="#（7）归并排序" class="headerlink" title="（7）归并排序"></a><strong>（7）归并排序</strong></h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Merge</span> <span class="keyword">extends</span> <span class="title">SortExample</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span>&#123;</span><br><span class="line">        Integer[] a = RandomUtil.getRandomIndex(<span class="number">10000</span>);</span><br><span class="line">        Stopwatch stopwatch = <span class="keyword">new</span> Stopwatch();</span><br><span class="line">        sort(a);</span><br><span class="line">        System.out.println(stopwatch.elapseTime());</span><br><span class="line">        show(a);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 原地归并的抽象方法</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">merge</span><span class="params">(Comparable[] a, <span class="keyword">int</span> lo, <span class="keyword">int</span> mid, <span class="keyword">int</span> hi)</span></span>&#123;</span><br><span class="line">        <span class="comment">//将a[lo,mid]与a[mid+1,hi]归并，两个数组是有序的</span></span><br><span class="line">        <span class="keyword">int</span> i = lo,j = mid+<span class="number">1</span>;</span><br><span class="line">        <span class="comment">//先将所有元素复制到aux[]中，再归并到a[]中</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> k = lo;k &lt;= hi;k++)</span><br><span class="line">            aux[k] = a[k];</span><br><span class="line">        <span class="comment">//用i,j指针分别游离于两数组</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> k = lo;k &lt;= hi;k++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(i &gt; mid) a[k] = aux[j++]; <span class="comment">//左边下标已结束</span></span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span>(j &gt; hi) a[k] = aux[i++];<span class="comment">//右边下标已结束</span></span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span>(less(aux[j],aux[i])) a[k] = aux[j++];<span class="comment">//两数组的指针比较当前大小，前者较小</span></span><br><span class="line">            <span class="keyword">else</span> a[k] = aux[i++];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 自顶向下的归并排序</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> Comparable[] aux; <span class="comment">//归并所需的辅助数组</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">sort</span><span class="params">(Comparable[] a)</span></span>&#123;</span><br><span class="line">        aux = <span class="keyword">new</span> Comparable[a.length];<span class="comment">//一次性分配空间</span></span><br><span class="line">        sort(a,<span class="number">0</span>,a.length-<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//将数组a排序，递归排序，sort的作用为以正确的顺序调用merge方法</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">sort</span><span class="params">(Comparable[] a,<span class="keyword">int</span> lo,<span class="keyword">int</span> hi)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(hi &lt;= lo) <span class="keyword">return</span>;</span><br><span class="line">        <span class="keyword">int</span> mid = lo + (hi - lo)/<span class="number">2</span>;</span><br><span class="line">        sort(a,lo,mid);      <span class="comment">// 将左半边排序</span></span><br><span class="line">        sort(a,mid+<span class="number">1</span>,hi);    <span class="comment">// 将右半边排序</span></span><br><span class="line">        merge(a,lo,mid,hi);  <span class="comment">// 归并结果</span></span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 自底向上的归并排序</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">sortBottomUp</span><span class="params">(Comparable[] a)</span></span>&#123;</span><br><span class="line">        <span class="comment">// 进行lgN次两两归并</span></span><br><span class="line">        <span class="keyword">int</span> N = a.length;</span><br><span class="line">        aux = <span class="keyword">new</span> Comparable[N];</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> sz = <span class="number">1</span>; sz &lt; N ;sz = sz + sz) <span class="comment">//sz-子数组大小</span></span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> lo = <span class="number">0</span>; lo &lt; N-sz;lo+=sz+sz) <span class="comment">//子数组索引</span></span><br><span class="line">                merge(a,lo,lo+sz-<span class="number">1</span>,Math.min(lo+sz+sz-<span class="number">1</span>,N-<span class="number">1</span>));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>对于长度为N的任意数组，自顶向下的归并排序需要 <code>1/2NlgN</code> 至 <code>NlgN</code> 次比较，并且最多需要访问数组 <code>6NlgN</code> 次</strong>。</p><p><strong>归并排序所需时间与 <code>NlgN</code> 成正比</strong>，这相比前几个排序要快很多（指数级），只需要比遍历整个数组多个对数因子的时间就可以将一个庞大的数组排序。</p><p><strong>对于长度为N的任意数组，自底向上的归并排序需要 <code>1/2NlgN</code> 至 <code>NlgN</code> 次比较，最多访问数组 <code>6NlgN</code> 次</strong>。</p><p>所以时间复杂度为 O(nlogn) 。</p><h4 id="（8）快速排序"><a href="#（8）快速排序" class="headerlink" title="（8）快速排序"></a><strong>（8）快速排序</strong></h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Quick</span> </span>&#123;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">sort</span><span class="params">(Comparable[] a)</span></span>&#123;</span><br><span class="line">        <span class="comment">//消除对输入的依赖，需要在这里把元素随机分布一下</span></span><br><span class="line">        StdRandom.shuffle(a);</span><br><span class="line">        sort(a,<span class="number">0</span>,a.length-<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 递归排序</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">sort</span><span class="params">(Comparable[] a,<span class="keyword">int</span> lo,<span class="keyword">int</span> hi)</span></span>&#123;</span><br><span class="line">        <span class="comment">//当左右游标相等，表示已对最小数组排序，结束递归</span></span><br><span class="line">        <span class="keyword">if</span>(hi &lt;= lo) <span class="keyword">return</span>;</span><br><span class="line">        <span class="comment">//切分</span></span><br><span class="line">        <span class="keyword">int</span> j = partition(a,lo,hi);</span><br><span class="line">        <span class="comment">//将左半部分排序</span></span><br><span class="line">        sort(a,lo,j-<span class="number">1</span>);</span><br><span class="line">        <span class="comment">//将右半部分排序</span></span><br><span class="line">        sort(a,j+<span class="number">1</span>,hi);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 切分数组</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">partition</span><span class="params">(Comparable[] a,<span class="keyword">int</span> lo,<span class="keyword">int</span> hi)</span></span>&#123;</span><br><span class="line">        <span class="comment">//左右扫描指针</span></span><br><span class="line">        <span class="keyword">int</span> i = lo,j = hi + <span class="number">1</span>; </span><br><span class="line">        <span class="comment">//切分元素</span></span><br><span class="line">        Comparable v = a[lo];  </span><br><span class="line">        <span class="comment">//扫描左右，检查扫描是否结束并交换元素，遍历结束后数组被切分为两部分，一边小于切分元素，一边大于切分元素</span></span><br><span class="line">        <span class="keyword">while</span>(<span class="keyword">true</span>)&#123;</span><br><span class="line">            <span class="comment">//循环遍历直到找到大于v元素或游标到底</span></span><br><span class="line">            <span class="keyword">while</span>(less(a[++i],v))</span><br><span class="line">                <span class="keyword">if</span>(i == hi) <span class="keyword">break</span>;</span><br><span class="line">            <span class="comment">//循环遍历直到找到小于v元素或游标到头</span></span><br><span class="line">            <span class="keyword">while</span>(less(v,a[--j]))</span><br><span class="line">                <span class="keyword">if</span>(j == lo) <span class="keyword">break</span>;</span><br><span class="line">            <span class="comment">//若游标交叉则表示以遍历所有元素，结束</span></span><br><span class="line">            <span class="keyword">if</span>(i &gt;= j) <span class="keyword">break</span>;</span><br><span class="line">            <span class="comment">//交换两边元素</span></span><br><span class="line">            exch(a,i,j);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//将v=a[j]放入正确位置</span></span><br><span class="line">        exch(a,lo,j); </span><br><span class="line">        <span class="comment">//a[lo...j-1] &lt;= a[j] &lt;= a[j+1...hi] 达成</span></span><br><span class="line">        <span class="keyword">return</span> j;    </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>所以时间复杂度为 O(nlogn) 。</p><p>T(n) = O(n^2^)</p><blockquote><p>命题：<strong>将长度为N的无重复元素数组排序，快速排序平均需要 ~ <code>2NlnN</code> 次比较，以及 <code>1/6</code> 的交换</strong>。</p><p>证明：<code>CN</code> 为将N个不同元素排序平均所需的比较次数。很明显 <code>C0</code> = <code>C1</code> = 0，对于 <code>N &gt; 1</code> ，由递归程序可以得到以下归纳关系：</p><p> CN = N + 1 + (C0 + C1 + … + C(N-2) + C(N-1)) / N + (C(N-1) + C(N-2) + … + C0) / N</p><p>第一项是切分的成本（总是N+1），第二项是将左子数组排序的平均成本，第三项是将右子数组（长度和左子数组相同）排序的平均成本。将等式左右两边乘以N并整理各项得到：</p><p> NCN = N (N + 1) + 2(C0 + C1 + … + C(N-2) + C(N-1))</p><p>将该等式减去 <code>N - 1</code> 时的相同等式可得：</p><p> NCN - (N - 1)C(N - 1) = 2N + 2C(N - 1)</p><p>整理等式并将两边除以 <code>N(N + 1)</code> 可得：</p><p> CN / (N + 1) = C(N - 1) / N + 2 / (N + 1)</p><p>归纳法推导可得：</p><p> CN ~ 2(N + 1)(1/3 + 1/4 + … + 1 / (N + 1))</p><p>括号内的量是曲线 <code>2 / x</code> 下从3到N的离散近似面积加一，积分得到 <code>CN ~ 2NlnN</code> 。注意 <code>2NlnN</code> ≈ <code>1.39NlgN</code> ，也就是说平均比较次数只比最好情况多39%。</p></blockquote><blockquote><p>命题：<strong>快速排序最多需要 <code>N^2/2</code> 次比较，但随机打乱数组能够预防这种情况。</strong></p><p>证明：在每次切分后两个子数组之一总是空的情况下，比较次数为：</p><p> N + (N - 1) + … + (N - 2) + 2 + 1 = (N + 1) N / 2</p><p>这说明了算法所需时间为平方级别，所需空间是线性的，而这对于大数组来说是不可接受的。比较次数的标准差为0.65N，因此随着N的增大，运行时间会趋于平均数，且不可能与平均数偏差太大。</p></blockquote><h4 id="（9）堆排序"><a href="#（9）堆排序" class="headerlink" title="（9）堆排序"></a><strong>（9）堆排序</strong></h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 堆排序</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Set</span> <span class="keyword">extends</span> <span class="title">SortExample</span> </span>&#123;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> Comparable[] sort(Comparable[] c)&#123;</span><br><span class="line">        Comparable[] a = <span class="keyword">new</span> Comparable[c.length+<span class="number">1</span>];</span><br><span class="line">        <span class="keyword">int</span> N = c.length;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>;i &lt; N;i++)</span><br><span class="line">            a[i+<span class="number">1</span>] = c[i];</span><br><span class="line">        <span class="comment">// for循环构造堆，sink方法将a从1到N排序</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> k = N/<span class="number">2</span>; k &gt;= <span class="number">1</span>; k--)</span><br><span class="line">            sink(a,k,N);</span><br><span class="line">        show(a);</span><br><span class="line">        <span class="comment">// while循环将最大元素a[1]和a[N]交换，并修复堆</span></span><br><span class="line">        <span class="keyword">while</span> (N &gt; <span class="number">1</span>)&#123;</span><br><span class="line">            exch(a,<span class="number">1</span>,N--);</span><br><span class="line">            sink(a,<span class="number">1</span>,N);</span><br><span class="line">            show(a);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> a;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">swim</span><span class="params">(Comparable[] a,<span class="keyword">int</span> k)</span></span>&#123;</span><br><span class="line">        <span class="keyword">while</span> (k &gt; <span class="number">1</span> &amp;&amp; less(k/<span class="number">2</span>,k))&#123;<span class="comment">//循环判断条件，k&gt;1,父结点的值比当前小</span></span><br><span class="line">            <span class="comment">//交换当前结点和父结点的值，以及当前游标所指下标</span></span><br><span class="line">            exch(a,k/<span class="number">2</span>,k);</span><br><span class="line">            k = k/<span class="number">2</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">sink</span><span class="params">(Comparable[] a,<span class="keyword">int</span> k,<span class="keyword">int</span> N)</span></span>&#123;</span><br><span class="line">        <span class="keyword">while</span> (<span class="number">2</span>*k &lt;= N)&#123;<span class="comment">//循环判断条件，当前游标所指有子结点存在</span></span><br><span class="line">            <span class="keyword">int</span> j = <span class="number">2</span>*k;</span><br><span class="line">            <span class="comment">//当子结点不是最后结点，且子结点小于右子结点，指较大的那个子结点</span></span><br><span class="line">            <span class="keyword">if</span>(j &lt; N &amp;&amp; less(a[j],a[j+<span class="number">1</span>]))</span><br><span class="line">                j++;</span><br><span class="line">            <span class="comment">//如果当前结点比子结点大就跳出循环</span></span><br><span class="line">            <span class="keyword">if</span>(!less(a[k],a[j]))</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="comment">//交换，更新游标</span></span><br><span class="line">            exch(a,k,j);</span><br><span class="line">            k = j;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">exch</span><span class="params">(Comparable[] a,<span class="keyword">int</span> i, <span class="keyword">int</span> j)</span></span>&#123;</span><br><span class="line">        Comparable t = a[i];</span><br><span class="line">        a[i] = a[j];</span><br><span class="line">        a[j] = t;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span>&#123;</span><br><span class="line">        <span class="comment">// Integer[] a = RandomUtil.getRandomIndex(10000);</span></span><br><span class="line">        Comparable[] a = &#123;<span class="string">'S'</span>,<span class="string">'O'</span>,<span class="string">'R'</span>,<span class="string">'T'</span>,<span class="string">'E'</span>,<span class="string">'X'</span>,<span class="string">'A'</span>,<span class="string">'M'</span>,<span class="string">'P'</span>,<span class="string">'L'</span>,<span class="string">'E'</span>&#125;;</span><br><span class="line">        Stopwatch stopwatch = <span class="keyword">new</span> Stopwatch();</span><br><span class="line">        a = sort(a);</span><br><span class="line">        System.out.println(stopwatch.elapseTime());</span><br><span class="line">        show(a);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>将N个元素排序，堆排序只需要少于 <code>2NlgN + 2N</code> 次比较，以及一半次数的交换</strong>。</p><p>所以时间复杂度为 O(nlogn) 。</p><hr><p><em>参考博客和文章书籍等：</em></p><blockquote><p><a href="https://zh.wikipedia.org/zh-hans/%E6%97%B6%E9%97%B4%E5%A4%8D%E6%9D%82%E5%BA%A6" target="_blank" rel="noopener">时间复杂度- 维基百科</a></p></blockquote><blockquote><p><a href="https://www.zhihu.com/question/21387264" target="_blank" rel="noopener">如何理解算法时间复杂度的表示法，例如 O(n²)、O(n)、O(1)、O(nlogn) 等</a></p></blockquote><p><em>因博客主等未标明不可引用，若部分内容涉及侵权请及时告知，我会尽快修改和删除相关内容</em></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;link rel=&quot;stylesheet&quot; class=&quot;aplayer-secondary-style-marker&quot; href=&quot;\assets\css\APlayer.min.css&quot;&gt;&lt;script src=&quot;\assets\js\APlayer.min.js&quot; cla
      
    
    </summary>
    
      <category term="技术文档" scheme="http://linyishui.top/categories/%E6%8A%80%E6%9C%AF%E6%96%87%E6%A1%A3/"/>
    
    
      <category term="algorithm" scheme="http://linyishui.top/tags/algorithm/"/>
    
  </entry>
  
  <entry>
    <title>BlockingQueue（未完成）</title>
    <link href="http://linyishui.top/2020061401.html"/>
    <id>http://linyishui.top/2020061401.html</id>
    <published>2020-06-14T13:41:26.000Z</published>
    <updated>2020-07-26T14:53:33.249Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="BlockingQueue"><a href="#BlockingQueue" class="headerlink" title="BlockingQueue"></a><strong>BlockingQueue</strong></h1><h2 id="第一节-概述"><a href="#第一节-概述" class="headerlink" title="第一节 概述"></a><strong>第一节 概述</strong></h2><p>并发包 <code>java.util.concurrent</code> 提供了阻塞队列系列，顶层接口 <code>BlockingQueue</code> ，相关实现类：</p><ul><li>ArrayBlockingQueue：基于数组的有界阻塞队列。</li><li>LinkedBlockingQueue：基于链表的阻塞队列。</li><li>DelayQueue：延迟队列。</li><li>SynchronousQueue：同步队列。</li><li>PriorityBlockingQueue：优先阻塞队列。</li></ul>]]></content>
    
    <summary type="html">
    
      简单整理Java并发包中阻塞队列BlockingQueue相关内容，包括：概述，API，ArrayBlockingQueue，LinkedBlockingQueue等。
    
    </summary>
    
      <category term="技术文档" scheme="http://linyishui.top/categories/%E6%8A%80%E6%9C%AF%E6%96%87%E6%A1%A3/"/>
    
    
      <category term="java" scheme="http://linyishui.top/tags/java/"/>
    
      <category term="lock" scheme="http://linyishui.top/tags/lock/"/>
    
      <category term="unfinished" scheme="http://linyishui.top/tags/unfinished/"/>
    
  </entry>
  
  <entry>
    <title>CopyOnWriteArrayList的实现原理</title>
    <link href="http://linyishui.top/2020060501.html"/>
    <id>http://linyishui.top/2020060501.html</id>
    <published>2020-06-05T14:27:02.000Z</published>
    <updated>2020-07-23T09:09:32.847Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="CopyOnWriteArrayList"><a href="#CopyOnWriteArrayList" class="headerlink" title="CopyOnWriteArrayList"></a><strong>CopyOnWriteArrayList</strong></h1><h2 id="第一节-概述"><a href="#第一节-概述" class="headerlink" title="第一节 概述"></a><strong>第一节 概述</strong></h2><h3 id="1-1-为什么需要CopyOnWriteArrayList？"><a href="#1-1-为什么需要CopyOnWriteArrayList？" class="headerlink" title="1.1 为什么需要CopyOnWriteArrayList？"></a><strong>1.1 为什么需要CopyOnWriteArrayList？</strong></h3><p><strong>多读场景需要高效的并发数组</strong>。</p><p>常用的 <code>ArrayList</code> 不是一个线程安全的集合，基于快速失败机制，多线程操作会抛出 <code>ConcurrentModificationException</code> ，而线程安全的  <code>Vector</code> 又因为低效的设计而被弃用，又或者 <code>Collections.synchronizedList()</code> 来获取一个包装的线程安全类，与前者一样使用 <code>synchronized</code> 来保证的线程安全。</p><p> <code>synchronized</code> 这种独占锁在同一时刻只能有一个线程拥有对象监视器，对于大部分<strong>读多写少的业务场景</strong>并不适用。针对这种场景而设计的读写锁 <code>ReentrantReadWriteLock</code> 是一个合适的选择。</p><p>如果只是在 <code>List</code> 上封装一层读写锁，读数据仍会被其他操作阻塞，所以需要并发包提供的 <code>CopyOnWriteArrayList</code> 。</p><h3 id="1-2-什么是CopyOnWrite？"><a href="#1-2-什么是CopyOnWrite？" class="headerlink" title="1.2 什么是CopyOnWrite？"></a><strong>1.2 什么是CopyOnWrite？</strong></h3><p><code>CopyOnWrite</code>（COW）即<strong>写时复制</strong>，通过延迟更新的策略来实现数据一致性，并且能保证线程间不阻塞。</p><p>通俗的讲就是在向容器添加元素时，并非直接向容器内添加，而是先将当前容器进行Copy，复制出一个新容器，然后向新容器添加元素，完成后再将指向旧容器的引用指向新容器。</p><p>这一过程的优势就是在进行并发的读操作时不用加锁，因为旧容器并不改变，所以<strong>写时复制也是一种读写分离的思想</strong>，通过放弃数据的实时性来达到数据一致性，获得的是提高并发性。</p><h3 id="1-3-写时复制和读写锁的区别？"><a href="#1-3-写时复制和读写锁的区别？" class="headerlink" title="1.3 写时复制和读写锁的区别？"></a><strong>1.3 写时复制和读写锁的区别？</strong></h3><ul><li><p>相同点：两者都是通过读写分离思想实现，都实现了读线程间互不阻塞。</p></li><li><p>不同点：使用读写锁依然会存在线程阻塞等待的情况，而COW则牺牲了数据实时性，保证读线程不会存在等待。</p></li></ul><p>读写锁中，读线程为了实现数据实时性，在写锁被获取时，读线程会等待。而写时复制中虽然写线程最终的修改结果可以被读线程感知，但有一定延迟。</p><h2 id="第二节-实现原理"><a href="#第二节-实现原理" class="headerlink" title="第二节 实现原理"></a><strong>第二节 实现原理</strong></h2><h3 id="2-1-基本结构"><a href="#2-1-基本结构" class="headerlink" title="2.1 基本结构"></a><strong>2.1 基本结构</strong></h3><p>根据其接口实现 <code>RandomAccess</code> 就可得知，其底层为数组。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">CopyOnWriteArrayList</span>&lt;<span class="title">E</span>&gt;</span></span><br><span class="line"><span class="class">    <span class="keyword">implements</span> <span class="title">List</span>&lt;<span class="title">E</span>&gt;, <span class="title">RandomAccess</span>, <span class="title">Cloneable</span>, <span class="title">java</span>.<span class="title">io</span>.<span class="title">Serializable</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">long</span> serialVersionUID = <span class="number">8673264195747942595L</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/** The lock protecting all mutators */</span></span><br><span class="line">    <span class="keyword">final</span> <span class="keyword">transient</span> ReentrantLock lock = <span class="keyword">new</span> ReentrantLock();</span><br><span class="line"></span><br><span class="line">    <span class="comment">/** The array, accessed only via getArray/setArray. */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">transient</span> <span class="keyword">volatile</span> Object[] array;</span><br><span class="line"> </span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>通过可重入锁 <code>ReentrantLock</code> 来保证线程安全，通过 <code>volatile</code> 修饰底层数组来保证可见性。 </p><h3 id="2-2-get"><a href="#2-2-get" class="headerlink" title="2.2 get"></a><strong>2.2 get</strong></h3><p><code>get()</code> 方法源码如下，读操作不需要考虑并发安全，直接通过数组索引获取元素。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * &#123;<span class="doctag">@inheritDoc</span>&#125;</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@throws</span> IndexOutOfBoundsException &#123;<span class="doctag">@inheritDoc</span>&#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> E <span class="title">get</span><span class="params">(<span class="keyword">int</span> index)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> get(getArray(), index);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Positional Access Operations</span></span><br><span class="line"><span class="meta">@SuppressWarnings</span>(<span class="string">"unchecked"</span>)</span><br><span class="line"><span class="function"><span class="keyword">private</span> E <span class="title">get</span><span class="params">(Object[] a, <span class="keyword">int</span> index)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> (E) a[index];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Gets the array.  Non-private so as to also be accessible</span></span><br><span class="line"><span class="comment"> * from CopyOnWriteArraySet class.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">final</span> Object[] getArray() &#123;</span><br><span class="line">    <span class="keyword">return</span> array;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="2-3-add"><a href="#2-3-add" class="headerlink" title="2.3 add"></a><strong>2.3 add</strong></h3><p><code>add()</code> 方法源码如下，写线程需要阻塞。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Appends the specified element to the end of this list.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> e element to be appended to this list</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> &#123;<span class="doctag">@code</span> true&#125; (as specified by &#123;<span class="doctag">@link</span> Collection#add&#125;)</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">add</span><span class="params">(E e)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 1.首先获取Lock，保证写操作线程安全</span></span><br><span class="line">    <span class="keyword">final</span> ReentrantLock lock = <span class="keyword">this</span>.lock;</span><br><span class="line">    lock.lock();</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="comment">// 2.获取旧数组</span></span><br><span class="line">        Object[] elements = getArray();</span><br><span class="line">        <span class="keyword">int</span> len = elements.length;</span><br><span class="line">        <span class="comment">// 3.通过Arrays.copyOf进行数组浅复制扩容，底层是通过调用System.arraycopy()进行数组的浅拷贝</span></span><br><span class="line">        Object[] newElements = Arrays.copyOf(elements, len + <span class="number">1</span>);</span><br><span class="line">        <span class="comment">// 4.将新元素添加到新数组的末尾</span></span><br><span class="line">        newElements[len] = e;</span><br><span class="line">        <span class="comment">// 5.指向新数组</span></span><br><span class="line">        setArray(newElements);</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        lock.unlock();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Sets the array.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">final</span> <span class="keyword">void</span> <span class="title">setArray</span><span class="params">(Object[] a)</span> </span>&#123;</span><br><span class="line">    array = a;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>实现核心主要是：</p><ol><li>通过 <code>ReentrantLock</code> 保证同一时刻只有一个写线程在进行数组的复制，否则会导致内存中存在多份复制数组。</li><li><code>volatile</code> 修饰的底层数组，根据 <code>happens-before</code> 规则，写线程对数组引用的修改对读线程是可见的。</li></ol><p><code>add()</code> 还有重载方法，指定位置添加元素：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Inserts the specified element at the specified position in this</span></span><br><span class="line"><span class="comment"> * list. Shifts the element currently at that position (if any) and</span></span><br><span class="line"><span class="comment"> * any subsequent elements to the right (adds one to their indices).</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@throws</span> IndexOutOfBoundsException &#123;<span class="doctag">@inheritDoc</span>&#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">add</span><span class="params">(<span class="keyword">int</span> index, E element)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">final</span> ReentrantLock lock = <span class="keyword">this</span>.lock;</span><br><span class="line">    lock.lock();</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        Object[] elements = getArray();</span><br><span class="line">        <span class="keyword">int</span> len = elements.length;</span><br><span class="line">        <span class="keyword">if</span> (index &gt; len || index &lt; <span class="number">0</span>)</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> IndexOutOfBoundsException(<span class="string">"Index: "</span>+index+</span><br><span class="line">                                                <span class="string">", Size: "</span>+len);</span><br><span class="line">        Object[] newElements;</span><br><span class="line">        <span class="keyword">int</span> numMoved = len - index;</span><br><span class="line">        <span class="keyword">if</span> (numMoved == <span class="number">0</span>)</span><br><span class="line">            <span class="comment">// 末尾添加，直接拷贝生成新数组</span></span><br><span class="line">            newElements = Arrays.copyOf(elements, len + <span class="number">1</span>);</span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">// 非末尾，先构建新数组，再通过System.arraycopy错位复制</span></span><br><span class="line">            newElements = <span class="keyword">new</span> Object[len + <span class="number">1</span>];</span><br><span class="line">            <span class="comment">// 第一次复制源数组下标0-index的元素</span></span><br><span class="line">            System.arraycopy(elements, <span class="number">0</span>, newElements, <span class="number">0</span>, index);</span><br><span class="line">            <span class="comment">// 第二次复制源数组index-end的元素，错位复制到新数组，此步完成后index元素重复一次</span></span><br><span class="line">            System.arraycopy(elements, index, newElements, index + <span class="number">1</span>,</span><br><span class="line">                             numMoved);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 更新元素</span></span><br><span class="line">        newElements[index] = element;</span><br><span class="line">        <span class="comment">// 更新引用</span></span><br><span class="line">        setArray(newElements);</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        lock.unlock();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>核心就是通过 <code>System.arraycopy()</code> 进行错位复制。</p><h3 id="2-4-set"><a href="#2-4-set" class="headerlink" title="2.4 set"></a><strong>2.4 set</strong></h3><p><code>set()</code> 方法源码如下，写线程需要阻塞。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Replaces the element at the specified position in this list with the</span></span><br><span class="line"><span class="comment"> * specified element.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@throws</span> IndexOutOfBoundsException &#123;<span class="doctag">@inheritDoc</span>&#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> E <span class="title">set</span><span class="params">(<span class="keyword">int</span> index, E element)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">final</span> ReentrantLock lock = <span class="keyword">this</span>.lock;</span><br><span class="line">    lock.lock();</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        Object[] elements = getArray();</span><br><span class="line">        <span class="comment">// 先获取旧值</span></span><br><span class="line">        E oldValue = get(elements, index);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (oldValue != element) &#123;</span><br><span class="line">            <span class="comment">// 仍通过浅复制进行替换</span></span><br><span class="line">            <span class="keyword">int</span> len = elements.length;</span><br><span class="line">            Object[] newElements = Arrays.copyOf(elements, len);</span><br><span class="line">            newElements[index] = element;</span><br><span class="line">            setArray(newElements);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">// 旧值等价于新值，不需要替换，此处只更新一下引用</span></span><br><span class="line">            <span class="comment">// Not quite a no-op; ensures volatile write semantics</span></span><br><span class="line">            setArray(elements);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> oldValue;</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        lock.unlock();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="2-5-remove"><a href="#2-5-remove" class="headerlink" title="2.5 remove"></a><strong>2.5 remove</strong></h3><p><code>remove()</code> 方法源码如下，写线程需要阻塞。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Removes the element at the specified position in this list.</span></span><br><span class="line"><span class="comment"> * Shifts any subsequent elements to the left (subtracts one from their</span></span><br><span class="line"><span class="comment"> * indices).  Returns the element that was removed from the list.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@throws</span> IndexOutOfBoundsException &#123;<span class="doctag">@inheritDoc</span>&#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> E <span class="title">remove</span><span class="params">(<span class="keyword">int</span> index)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">final</span> ReentrantLock lock = <span class="keyword">this</span>.lock;</span><br><span class="line">    lock.lock();</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        Object[] elements = getArray();</span><br><span class="line">        <span class="keyword">int</span> len = elements.length;</span><br><span class="line">        E oldValue = get(elements, index);</span><br><span class="line">        <span class="keyword">int</span> numMoved = len - index - <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">if</span> (numMoved == <span class="number">0</span>)</span><br><span class="line">            setArray(Arrays.copyOf(elements, len - <span class="number">1</span>));</span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            Object[] newElements = <span class="keyword">new</span> Object[len - <span class="number">1</span>];</span><br><span class="line">            System.arraycopy(elements, <span class="number">0</span>, newElements, <span class="number">0</span>, index);</span><br><span class="line">            System.arraycopy(elements, index + <span class="number">1</span>, newElements, index,</span><br><span class="line">                             numMoved);</span><br><span class="line">            setArray(newElements);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> oldValue;</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        lock.unlock();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Removes the first occurrence of the specified element from this list,</span></span><br><span class="line"><span class="comment"> * if it is present.  If this list does not contain the element, it is</span></span><br><span class="line"><span class="comment"> * unchanged.  More formally, removes the element with the lowest index</span></span><br><span class="line"><span class="comment"> * &#123;<span class="doctag">@code</span> i&#125; such that</span></span><br><span class="line"><span class="comment"> * &lt;tt&gt;(o==null&amp;nbsp;?&amp;nbsp;get(i)==null&amp;nbsp;:&amp;nbsp;o.equals(get(i)))&lt;/tt&gt;</span></span><br><span class="line"><span class="comment"> * (if such an element exists).  Returns &#123;<span class="doctag">@code</span> true&#125; if this list</span></span><br><span class="line"><span class="comment"> * contained the specified element (or equivalently, if this list</span></span><br><span class="line"><span class="comment"> * changed as a result of the call).</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> o element to be removed from this list, if present</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> &#123;<span class="doctag">@code</span> true&#125; if this list contained the specified element</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">remove</span><span class="params">(Object o)</span> </span>&#123;</span><br><span class="line">    Object[] snapshot = getArray();</span><br><span class="line">    <span class="keyword">int</span> index = indexOf(o, snapshot, <span class="number">0</span>, snapshot.length);</span><br><span class="line">    <span class="keyword">return</span> (index &lt; <span class="number">0</span>) ? <span class="keyword">false</span> : remove(o, snapshot, index);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * A version of remove(Object) using the strong hint that given</span></span><br><span class="line"><span class="comment"> * recent snapshot contains o at the given index.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">boolean</span> <span class="title">remove</span><span class="params">(Object o, Object[] snapshot, <span class="keyword">int</span> index)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">final</span> ReentrantLock lock = <span class="keyword">this</span>.lock;</span><br><span class="line">    lock.lock();</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        Object[] current = getArray();</span><br><span class="line">        <span class="keyword">int</span> len = current.length;</span><br><span class="line">        <span class="keyword">if</span> (snapshot != current) findIndex: &#123;</span><br><span class="line">            <span class="keyword">int</span> prefix = Math.min(index, len);</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; prefix; i++) &#123;</span><br><span class="line">                <span class="keyword">if</span> (current[i] != snapshot[i] &amp;&amp; eq(o, current[i])) &#123;</span><br><span class="line">                    index = i;</span><br><span class="line">                    <span class="keyword">break</span> findIndex;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (index &gt;= len)</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">            <span class="keyword">if</span> (current[index] == o)</span><br><span class="line">                <span class="keyword">break</span> findIndex;</span><br><span class="line">            index = indexOf(o, current, index, len);</span><br><span class="line">            <span class="keyword">if</span> (index &lt; <span class="number">0</span>)</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        Object[] newElements = <span class="keyword">new</span> Object[len - <span class="number">1</span>];</span><br><span class="line">        System.arraycopy(current, <span class="number">0</span>, newElements, <span class="number">0</span>, index);</span><br><span class="line">        System.arraycopy(current, index + <span class="number">1</span>,</span><br><span class="line">                         newElements, index,</span><br><span class="line">                         len - index - <span class="number">1</span>);</span><br><span class="line">        setArray(newElements);</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        lock.unlock();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Removes from this list all of the elements whose index is between</span></span><br><span class="line"><span class="comment"> * &#123;<span class="doctag">@code</span> fromIndex&#125;, inclusive, and &#123;<span class="doctag">@code</span> toIndex&#125;, exclusive.</span></span><br><span class="line"><span class="comment"> * Shifts any succeeding elements to the left (reduces their index).</span></span><br><span class="line"><span class="comment"> * This call shortens the list by &#123;<span class="doctag">@code</span> (toIndex - fromIndex)&#125; elements.</span></span><br><span class="line"><span class="comment"> * (If &#123;<span class="doctag">@code</span> toIndex==fromIndex&#125;, this operation has no effect.)</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> fromIndex index of first element to be removed</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> toIndex index after last element to be removed</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@throws</span> IndexOutOfBoundsException if fromIndex or toIndex out of range</span></span><br><span class="line"><span class="comment"> *         (&#123;<span class="doctag">@code</span> fromIndex &lt; 0 || toIndex &gt; size() || toIndex &lt; fromIndex&#125;)</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">removeRange</span><span class="params">(<span class="keyword">int</span> fromIndex, <span class="keyword">int</span> toIndex)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">final</span> ReentrantLock lock = <span class="keyword">this</span>.lock;</span><br><span class="line">    lock.lock();</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        Object[] elements = getArray();</span><br><span class="line">        <span class="keyword">int</span> len = elements.length;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (fromIndex &lt; <span class="number">0</span> || toIndex &gt; len || toIndex &lt; fromIndex)</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> IndexOutOfBoundsException();</span><br><span class="line">        <span class="keyword">int</span> newlen = len - (toIndex - fromIndex);</span><br><span class="line">        <span class="keyword">int</span> numMoved = len - toIndex;</span><br><span class="line">        <span class="keyword">if</span> (numMoved == <span class="number">0</span>)</span><br><span class="line">            setArray(Arrays.copyOf(elements, newlen));</span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            Object[] newElements = <span class="keyword">new</span> Object[newlen];</span><br><span class="line">            System.arraycopy(elements, <span class="number">0</span>, newElements, <span class="number">0</span>, fromIndex);</span><br><span class="line">            System.arraycopy(elements, toIndex, newElements,</span><br><span class="line">                             fromIndex, numMoved);</span><br><span class="line">            setArray(newElements);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        lock.unlock();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>和 <code>set()</code> 、<code>add()</code> 等方法一样，<code>remove()</code> 仍通过数组浅复制进行删除操作，主要是错位复制。</p><hr><p><em>参考博客和文章书籍等：</em></p><blockquote><p>《Java并发编程的艺术》</p></blockquote><blockquote><p><a href="https://juejin.im/post/5aeeb55f5188256715478c21#heading-4" target="_blank" rel="noopener">并发容器之CopyOnWriteArrayList</a></p></blockquote><p><em>因博客主等未标明不可引用，若部分内容涉及侵权请及时告知，我会尽快修改和删除相关内容</em></p>]]></content>
    
    <summary type="html">
    
      简单整理了一下CopyOnWriteArrayList的相关内容，主要内容包括：概述（为什么需要CopyOnWriteArrayList、什么是CopyOnWrite、写时复制和读写锁的区别），实现原理（基本结构、get、add、set、remove）等。
    
    </summary>
    
      <category term="技术文档" scheme="http://linyishui.top/categories/%E6%8A%80%E6%9C%AF%E6%96%87%E6%A1%A3/"/>
    
    
      <category term="java" scheme="http://linyishui.top/tags/java/"/>
    
      <category term="lock" scheme="http://linyishui.top/tags/lock/"/>
    
      <category term="list" scheme="http://linyishui.top/tags/list/"/>
    
  </entry>
  
</feed>
