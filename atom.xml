<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>沂水博客</title>
  
  <subtitle>编程和心历记录</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://linyishui.top/"/>
  <updated>2020-01-10T08:02:16.997Z</updated>
  <id>http://linyishui.top/</id>
  
  <author>
    <name>沂水</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>Java EE简介</title>
    <link href="http://linyishui.top/2019121501.html"/>
    <id>http://linyishui.top/2019121501.html</id>
    <published>2019-12-15T03:10:15.000Z</published>
    <updated>2020-01-10T08:02:16.997Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="Java-EE简介"><a href="#Java-EE简介" class="headerlink" title="Java EE简介"></a><strong>Java EE简介</strong></h1><h2 id="第一节-背景"><a href="#第一节-背景" class="headerlink" title="第一节 背景"></a><strong>第一节 背景</strong></h2><p>&emsp;&emsp;从1997年的1.1版本开始，Java平台被称为JDK，但到了版本1.2，很明显JDK和平台不再是同一样技术。从1998 年底的1.2版本开始，Java技术栈被分割为以下关键部分：</p><blockquote><ul><li>Java是一门包含了严格和强类型语法的语言，你现在已经熟悉它了。 </li><li>Java2平台标准版本，也被称为<strong>J2SE</strong>，指的是平台以及java.lang和java.io包中包含的类。它是构建Java应用程序的基础。</li><li>Java虚拟机或JVM是一个可以运行编译后Java代码的软件虚拟机。因为被编译过的Java代码只是字节码，JVM将在运行代码之前，把字节码编译成机器码(通常被称作即时编译器或JIT编译器)。JVM还负责管理内存，从而实现了应用程序代码的简化。</li><li>Java开发工具包或JDK曾经并且现在也仍然是Java开发者创建应用程序所需的软件。它包含了Java语言编译器、文档生成器、与本地代码协作的工具和用于调试平台类的Java源代码。 </li><li>Java运行时环境或JRE曾经并且现在也仍然是终端用户用于运行编译后Java应用程序的软件。它包含了JVM但不含任何JDK中的开发工具。不过JDK中确实也包含了一个JRE。 </li></ul></blockquote><p>&emsp;&emsp;这5个组件曾经都只是规范，而不是实现，任何公司都可以创建自己的Java技术栈实现。尽管Sun提供了Java、J2SE、JVM、JDK和JRE的标准实现，但IBM、Oracle和Apple仍然创建了包含不同特性的实现。随着多年的发展，许多语言都可以被编译为Java字节码(在某些情况下可以被编译为机器码)，并运行在JVM上。其中最引人注目的有Clojure(Lisp方言)、Groovy、JRuby(基于Java的Ruby实现)、Jython(基于Java的Python实现)、Rhino和Scala。</p><p>&emsp;&emsp;随着Internet的发展和Web应用程序的流行，Sun公司已经意识到应用程序开发对高级开发工具的需求。1998年，就在J2SE 1.2发布之前，Sun宣布它正在开发一个称为Java专业版本或JPE的产品。同时它还研发了一门称为Servlet的技术，这是一个能够处理HTTP请求的小型应用程序。在1997年，Java Servlets 1.0与Java Web Server一起发布，因为该服务器缺少许多Java社区需要的特性，所以它并未流行起来。 </p><p>&emsp;&emsp;Servlet和JPE在经历过几次内部迭代过程之后，Sun于1999年12月12日发布了Java 2平台的企业版(或<strong>J2EE</strong>)，版本为1.2。版本号对应着当时的Java和J2SE版本，该规范包括： </p><blockquote><ul><li>Servlets 2.2 </li><li>JDBC Extension API 2.0 </li><li>Java Naming and Directory Interface (JNDI) 1.0 </li><li>JavaServer Pages (JSP) 1.2 </li><li>Enterprise JavaBeans (EJB) 1.1 </li><li>Java Message Service (JMS) 1.0 </li><li>Java Transaction API (JTA) 1.0 </li><li>JavaMail API 1.1 </li><li>JavaBeans Activation Framework (JAF) 1.0. </li></ul></blockquote><p>&emsp;&emsp;J2EE 1.3在2001年9月发布，Java和J2SE 1.3的发布稍晚一点，但在Java/J2SE 1.4发布之前。它的大多数组件都进行了小的升级，并且也添加了一些新的特性。下面的技术也加入了J2EE规范，并且它们的实现也得到了扩展和升级： </p><blockquote><ul><li>Java API for XML Processing (JAXP) 1.1 </li><li>JavaServer Pages Standard Tag Library (JSTL) 1.0 </li><li>J2EE Connector Architecture 1.0 </li><li>Java Authentication and Authorization Service (JAAS) 1.0 </li></ul></blockquote><p>&emsp;&emsp;J2EE 1.4代表着Java平台企业版的一次极大飞跃。在2003年11月发布时(大约在Java/J2SE 5.0 发布一年之前，Java/J2SE 1.4发布两年之后)，它包含了Servlets 2.4和JSP 2.0。在该版本中，JDBC Extension API、JNDI和JAAS规范被移除了，因为它们被认为是Java的必需部分，被移入Java/J2SE 1.4。该版本还代表着J2EE组件被分割成了几个更高级别的分类： </p><blockquote><ul><li>Web服务技术：包括JAXP 1.2和J2EE 1.1中的新Web服务、Java API for XML-based RPC (JAX-RPC) 1.1、Java API for XML Registries (JAXR) 1.0 </li><li>Web应用程序技术: 包括Servlet、JSP和JSTL 1.1组件，还有新的Java Server Faces (JSF) 1.1 </li><li>企业级应用程序技术：包括EJB 2.1、Connector Architecture 1.5、JMS 1.1、JTA、JavaMail 1.3和JAF </li><li>管理和安全技术：包括Java Authorization Service Provider Contract for Containers (JACC) 1.0、Java Management Extensions (JMX) 1.2、Enterprise Edition Management API 1.0和Enterprise Edition Deployment API 1.1 </li></ul></blockquote><p>&emsp;&emsp;2004年，Sun公司决定使用Java平台标准版取代Java 2平台标准版，使用全新的缩写名字Java SE。2006年发布的Java SE 6开始正式使用该名称，直到今天名字和版本的命名方式都未再改变。Java SE 6实际对应着1.6，Java SE 7实际对应着1.7，Java SE 8实际对应着1.8。J2EE也采用了新的命名和版本约定，现在使用的名字为Java SE。</p><p>&emsp;&emsp;2006年5月发布的Java EE 5再次发生了变化，它包含了众多修改和改进，直到今天它仍然是应用程序最广泛的一 个Java EE版本。它包括以下修改和补充： </p><blockquote><ul><li>JAXP和JMX被移到了J2SE 5.0 中，不再包含在Java EE 5中。 </li><li>Java API for XML-based Web Services (JAX-WS) 2.0、 Java Architecture for XML Binding (JAXB) 2.0、Web Service Metadata for the Java Platform 2.0、SOAP with Attachments API for Java (SAAJ) 1.2以及Streaming API for XML (StAX) 1.0被添加到了Web服务技术中。 </li><li>Java Persistence API (JPA) 1.0和Common Annotations API 1.0被添加到了企业级应用程序技术中。</li></ul></blockquote><p>&emsp;&emsp;2006年12月Java SE 6的发布标志着Java SE持续了大概5年的发展停滞期。在这段时期内，许多Java社区都感到沮丧甚至是生气。Sun公司继续承诺在Java SE 7中添加新的语言特性和API，但计划推迟了一年又一年。与此同时其他技术，例如C#语言和.NET平台，赶上并超越了Java语言的特性和平台API，许多人都猜测Java是否已经到了生命的终结。更糟的是，Java EE也进入了发展停滞期直到2009年，距离Java EE 5发布已经过去了三年多的时间。不过，这并不是终结。Java EE 6的开发在2009年初重新开始，并在2009年12月发布，距离Java EE 5的发布已经过去了3年零7个月，距离Java SE 6的发布几乎接近3年。<br>&emsp;&emsp;此时，Java企业版已经变得极其庞大： </p><blockquote><ul><li>SAAJ、StAX和JAF被移到了Java SE 6中。 </li><li>Java API for RESTful Web Services (JAX-RS) 1.1和Java APIs for XML Messaging (JAXM) 1.3规范被添加到 Web服务技术中。 </li><li>Java Unified Expression Language (JUEL或称为EL) 2.0被添加到Web应用程序技术中。 </li><li>Management and Security Technologies中添加了Java Authentication Service Provider Interface for Containers (JASPIC) 1.0。 </li><li>企业级应用程序技术增加了大量的新特性，包括Contexts and Dependency Injection for Java (CDI) 1.0、Dependency Injection for Java 1.0、Bean Validation 1.0、Managed Beans 1.0和 Interceptors 1.1，还对它所有其他的组件做了更新。  </li></ul></blockquote><p>&emsp;&emsp;Java EE 6 还代表着 Java EE架构在两个技术上的重大转折点： </p><blockquote><ul><li>该版本引入了基于注解的配置和编程式应用程序配置，是对已经使用超过10年的传统XML配置的补充。 </li><li>该版本标志着Java EE Web Profile的引入。 </li></ul></blockquote><p>&emsp;&emsp;由于Java EE已经变得如此庞大(维护和更新公认的实现变得相当困难)，Web Profile验证程序为认证只包含完整Java EE平台一个子集的Java EE实现提供了机会。该子集包含了对于大量应用程序都十分关键的特性，排除了一些只被少数应用程序使用的规范。对于Java EE 6来说： </p><blockquote><ul><li>所有的Web服务或者管理和安全组件都不是Java EE Web Profile的一部分。 </li><li>该Web Profile包含了Web应用程序技术和企业级应用程序技术的所有内容，除了Java EE Connector Architecture、JMS和JavaMail。 </li></ul></blockquote><p>&emsp;&emsp;就在这5年的发展停滞期中，Oracle公司于2010年1月收购了Sun公司。除了Java SE发展的停滞，该事件为Java社区带来了新的担忧。Oracle并不愿意或积极与开源项目合作，许多人担心购买了Sun的Oracle会关闭Java。不过，事实并不是这样的。在初期，Oracle开始重组Java团队，创建与开源社区的沟通渠道，并发布了未来Java SE和EE版本的规划蓝图，这比Sun的承诺要更加实际。首先完成的是Java SE 7，Oracle在2011年6月按时发布，距离Java SE 6的发布几乎已经过去了5年。第二个Java EE发展停滞期在2013年6月结束，此时发布了Java EE 7，距离Java EE 6的发布已经过去了3年零7个月。Oracle现在表示Java的发展已经步入正轨，以后每两年将会同时发布两个平台的新版本(轮流发布)，让我们拭目以待。 </p><h3 id="1-1-Java-SE-7的新特性"><a href="#1-1-Java-SE-7的新特性" class="headerlink" title="1.1 Java SE 7的新特性"></a><strong>1.1 Java SE 7的新特性</strong></h3><p>&emsp;&emsp;Java SE 7增加了对<strong>动态语言</strong>和<strong>64位压缩指针</strong>(用于改善64位JVM的性能)的支持。它还添加了几种新的语言特性，可以使开发Java应用程序更容易。可能<strong>菱形操作符</strong>(&lt;&gt;)就是其中最有用的改进之一——泛型实例化的简写。</p><p>&emsp;&emsp;在Java 7之前，泛型类型的变量声明和变量赋值都必须包含泛型参数。例如，下面是一个非常复杂的 java.util.Map变量的声明和赋值： </p><figure class="highlight lasso"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">Map</span>&lt;<span class="built_in">String</span>, <span class="built_in">Map</span>&lt;<span class="built_in">String</span>, <span class="built_in">Map</span>&lt;<span class="built_in">Integer</span>, <span class="built_in">List</span>&lt;MyBean&gt;&gt;&gt;&gt; <span class="built_in">map</span> = newHashtable&lt;<span class="built_in">String</span>, <span class="built_in">Map</span>&lt;<span class="built_in">String</span>, <span class="built_in">Map</span>&lt;<span class="built_in">Integer</span>, <span class="built_in">List</span>&lt;MyBean&gt;&gt;&gt;&gt;();</span><br></pre></td></tr></table></figure><p>&emsp;&emsp;当然，该声明语句中包含了大量的冗余信息。将任何不是Map&lt;String, Map&lt;String, Map&lt;Integer, List<mybean>&gt;&gt;&gt;类型的对象赋给该变量都是非法的，那么为什么还需要再次指定所有的类型参数呢？使用了Java 7菱形操作符之后，上述声明和赋值语句将变得非常简单。编译器将会为实例化生成的java.util.Hashtable推断出它的类型参数。</mybean></p><figure class="highlight lasso"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">Map</span>&lt;<span class="built_in">String</span>, <span class="built_in">Map</span>&lt;<span class="built_in">String</span>, <span class="built_in">Map</span>&lt;<span class="built_in">Integer</span>, <span class="built_in">List</span>&lt;MyBean&gt;&gt;&gt;&gt; <span class="built_in">map</span> = <span class="literal">new</span> Hashtable&lt;&gt;();</span><br></pre></td></tr></table></figure><p>&emsp;&emsp;在Java 7之前Java中的另一个常见问题是：使用try-catch-finally块管理可关闭的资源。尤其是下面这样有点讨厌的JDBC代码： </p><figure class="highlight golo"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line">Connection connection = <span class="literal">null</span>; </span><br><span class="line">PreparedStatement statement = <span class="literal">null</span>; </span><br><span class="line">ResultSetresultSet = <span class="literal">null</span>; </span><br><span class="line"><span class="keyword">try</span> &#123; </span><br><span class="line">    connection = dataSource.getConnection(); </span><br><span class="line">    statement = connection.prepareStatement(...); </span><br><span class="line">    //<span class="keyword">set</span> up statement </span><br><span class="line">    resultSet = statement.executeQuery(); </span><br><span class="line">    // do something <span class="keyword">with</span> result <span class="keyword">set</span>  </span><br><span class="line">&#125; <span class="keyword">catch</span>(SQLException e) &#123; </span><br><span class="line">    // do something <span class="keyword">with</span> exception </span><br><span class="line">&#125; <span class="keyword">finally</span> &#123; </span><br><span class="line">    <span class="keyword">if</span>(resultSet != <span class="literal">null</span>) &#123; </span><br><span class="line">        <span class="keyword">try</span> &#123; </span><br><span class="line">            resultSet.close(); </span><br><span class="line">        &#125;<span class="keyword">catch</span>(SQLException ignore) &#123; </span><br><span class="line"></span><br><span class="line">        &#125; </span><br><span class="line">    &#125; </span><br><span class="line">    <span class="keyword">if</span>(statement != <span class="literal">null</span>) &#123; </span><br><span class="line">        <span class="keyword">try</span> &#123; </span><br><span class="line">            statement.close(); </span><br><span class="line">        &#125;<span class="keyword">catch</span>(SQLException ignore) &#123; </span><br><span class="line"></span><br><span class="line">        &#125; </span><br><span class="line">    &#125; </span><br><span class="line">    <span class="keyword">if</span>(connection != <span class="literal">null</span> &amp;&amp; !connection.isClosed()) &#123; </span><br><span class="line">        <span class="keyword">try</span> &#123; </span><br><span class="line">            connection.close(); </span><br><span class="line">        &#125;<span class="keyword">catch</span>(SQLException ignore) &#123; </span><br><span class="line"></span><br><span class="line">        &#125; </span><br><span class="line">    &#125; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>&emsp;&emsp;Java 7的try-with-resource极大地简化了这个任务。任何实现了java.lang.AutoCloseable的类都可用于try-with-resources结构中。JDBC Connection、PreparedStatement和ResultSet接口都继承了这个接口。下面的例子使用了try-with-resources结构，在try关键字后面的圆括号中声明的资源，将会在隐式的finally块中自动关闭。任何在这段清理过程中抛出的异常将被添加到现有异常的抑制异常中，或者如果之前未有任何异常发生，那么该异常将在所有的资源都关闭后抛出。</p><figure class="highlight coq"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">try</span>(Connection connection = dataSource.getConnection(); </span><br><span class="line">    PreparedStatement statement = connection.prepareStatement(...)) &#123; </span><br><span class="line">    //<span class="built_in">set</span> up statement </span><br><span class="line">    <span class="built_in">try</span>(ResultSetresultSet = statement.executeQuery()) &#123; </span><br><span class="line">        //<span class="built_in">do</span> something <span class="built_in">with</span> resul <span class="built_in">set</span> </span><br><span class="line">    &#125; </span><br><span class="line">&#125; catch(SQLException e) &#123; </span><br><span class="line">    //<span class="built_in">do</span> something <span class="built_in">with</span> exception </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>&emsp;&emsp;对于try-catch-finally的另一处改进是添加了multi-catch(捕捉多个异常)。在Java 7中可以在单个catch块中同时捕捉多个异常，使用单个竖线隔开异常类型即可。 </p><figure class="highlight actionscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">try</span> &#123; </span><br><span class="line">    <span class="comment">//do something </span></span><br><span class="line">&#125; <span class="keyword">catch</span>(MyException | YourException e) &#123; </span><br><span class="line">    <span class="comment">//handle these exceptions the same way </span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>&emsp;&emsp;需要注意的是，不能同时捕捉多个相互之间有继承关系的异常。例如，下面的代码是不可行的，因为FileNotFoundException继承了IOException： </p><figure class="highlight actionscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">try</span> &#123; </span><br><span class="line">    <span class="comment">//do something </span></span><br><span class="line">&#125; <span class="keyword">catch</span>(IOException | FileNotFoundException e) &#123;</span><br><span class="line">    <span class="comment">//handle these exceptions the same way </span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>&emsp;&emsp;当然，这可以被认为是一个常识性的问题。在这种情况下，只需要捕捉IOException即可，这样两种异常类型都可以被捕捉到。 </p><p>&emsp;&emsp;Java 7的一些其他语言特性包括字节码/整数的<strong>二进制字面量</strong>(可以将字面量1928写作0b11110001000)以及在<strong>数字字面量中使用下划线</strong>(如果愿意的话，可将相同的字面量1928写作1_928和ob111_1000_1000)。另外，终于可以<strong>将字符串用作switch的参数</strong>了。 </p><h3 id="1-3-Java-EE-7的新特性"><a href="#1-3-Java-EE-7的新特性" class="headerlink" title="1.3 Java EE 7的新特性"></a><strong>1.3 Java EE 7的新特性</strong></h3><p>&emsp;&emsp;Java EE 7在2013年6月12日发布，它包含许多变动和新特性。Java EE 7中的变动有： </p><blockquote><ul><li>JAXB被添加到了Java SE 7 中，并且不再包含在Java EE中。 </li><li>Batch Applications for the Java Platform 1.0和Concurrency Utilities for Java EE 1.0被添加到了企业级应用程序技术中。</li><li>Web应用程序技术中添加了Java API for WebSockets 1.0和Java API for JSON Processing 1.0。</li><li>Java Unified Expression Language得到了极大的扩展，其中包括lambda表达式和对Java SE 8 Collections Stream API的模拟。 </li><li>Web Profile得到了少许扩展，其中添加了在通用Web应用程序中使用较多的一些规范：JAX-RS、Java API for WebSockets和 Java API for JSON Processing。 </li></ul></blockquote><h3 id="1-2-Java-SE-8的新特性"><a href="#1-2-Java-SE-8的新特性" class="headerlink" title="1.2 Java SE 8的新特性"></a><strong>1.2 Java SE 8的新特性</strong></h3><p>&emsp;&emsp;<a href="../2019091901.html" title="Title">Java8的新特性</a></p><hr><h2 id="第二节-基本的Web应用程序结构"><a href="#第二节-基本的Web应用程序结构" class="headerlink" title="第二节 基本的Web应用程序结构"></a><strong>第二节 基本的Web应用程序结构</strong></h2><h3 id="2-1-Servlet、过滤器、监听器和JSP"><a href="#2-1-Servlet、过滤器、监听器和JSP" class="headerlink" title="2.1 Servlet、过滤器、监听器和JSP"></a><strong>2.1 Servlet、过滤器、监听器和JSP</strong></h3><p>&emsp;&emsp;Servlet是用于接受和响应HTTP请求的Java类。几乎发送到应用程序中的所有请求都将经过某种类型Servlet的处理，除了错误的或被其他组件拦截的请求。</p><p>&emsp;&emsp;过滤器就是这样一种组件，可以拦截发送给Servlet的请求。通过使用过滤器可以满足各种需求，包括数据格式化、对返回的数据进行压缩、认证和授权。</p><p>&emsp;&emsp;Java EE Web应用程序支持各种不同类型的监听器。这些监听器可以通知代码多种事件，例如应用程序启动、应用程序关闭、HTTP会话创建和会话销毁。</p><p>&emsp;&emsp;Java EE工具中最强大的一个就是JavaServer Pages技术或JSP。通过使用JSP可以为Web应用程序创建动态的、基于HTML的图形用户界面，不需要手动向OutputStream或PrintWriter中输入HTML的字符串。JSP技术包含了许多不同的内容，包括JavaServer Pages Standard Tag Library、Java Unified Expression Language、自定义标签、国际化和本地化。</p><blockquote><p>为什么不建议深入学习JSP？</p><ul><li>前后端职能分离，各司其职，界面不应再由后端工程师去协助实现</li><li>JSP作为一个后端渲染技术，会使动静资源耦合，无法做到有效的动静分离</li><li>JSP依赖于支持Java的Web服务器</li><li>JSP效率很低，在前端的发展潮流中已被淘汰</li></ul><p>&emsp;&emsp;虽然JSP已经不再流行，但其技术原理还是需要我们学习掌握的，当然其重要性就没那么高了，可以往自己的学习队列末尾移动。</p></blockquote><h3 id="2-2-目录结构和WAR文件"><a href="#2-2-目录结构和WAR文件" class="headerlink" title="2.2 目录结构和WAR文件"></a><strong>2.2 目录结构和WAR文件</strong></h3><p>&emsp;&emsp;标准Java EE Web应用程序将作为<strong>WAR文件</strong>或<strong>未归档的Web应用程序目录</strong>进行部署。JAR文件只是一个简单的ZIP格式归档文件，其中包含了可被JVM识别的标准目录结构。没有专门的JAR文件格式，任何ZIP归档应用程序都可以创建和读取JAR文件。Web应用程序归档或WAR是Java EE Web应用程序对应的归档文件。 </p><p>&emsp;&emsp;无论是归档文件还是未归档文件，它们的目录结构约定都是相同的。如同JAR文件一样，该结构包含了类和其他应用程序资源，但这些类并未像JAR文件一样存储在应用程序根目录的相对路径上。相反，<strong>类文件都存储在/WEB-INF/classes中</strong>。<strong>WEB-INF目录存储了一些包含了信息和指令的文件</strong>，Java EE Web应用程序服务器使用它们决定如何部署和运行应用程序。它的classes目录被用作包的根目录。所有编译后的应用程序类文件和其他资源都被存储在该目录中。 </p><p>&emsp;&emsp;不同于标准的JAR文件，<strong>WAR文件可以包含应用程序所依赖的JAR文件</strong>，它们被存储在/WEB-INF/lib中。JAR文件中所有在该目录中的类对于在应用程序类路径上的应用程序都是可用的。目录/WEB-INF/tags和/WEB-INF/tld分别用于存储 JSP标签文件和标签库描述符。</p><h3 id="2-3-部署描述符"><a href="#2-3-部署描述符" class="headerlink" title="2.3 部署描述符"></a><strong>2.3 部署描述符</strong></h3><p>&emsp;&emsp;部署描述符是<strong>用于描述Web应用程序的元数据</strong>，并为Java EE Web应用程序服务器部署和运行Web应用程序提供指令。从传统上来说，所有元数据都来自于部署描述符文件/WEB-INF/web.xml。该文件通常包含Servlet、监听器和过滤器的定义，以及HTTP会话、JSP和应用程序的配置选项。</p><h3 id="2-4-类加载器架构"><a href="#2-4-类加载器架构" class="headerlink" title="2.4 类加载器架构"></a><strong>2.4 类加载器架构</strong></h3><p>&emsp;&emsp;在使用Java EE Web应用程序时，有必要理解类加载器(ClassLoader)架构，因为它不同于你所熟悉的标准Java SE应用程序。在典型的应用程序中，Java SE平台中的java.*类将被加载到特定的<strong>根类加载器</strong>中，并且不能被覆盖。这是一种安全的方式，它阻止了恶意代码的执行，例如恶意代码可能会替换String类，或者重定义Boolean.TRUE和Boolean.FALSE。 </p><p>&emsp;&emsp;在根类加载器之后是<strong>扩展类加载器</strong>，它将加载JRE安装目录中的扩展JAR。最后，应用程序Class Loader将加载应用程序中的所有其他类。这组成了类加载器的层次，根类加载器是所有类加载器最早的祖先。当低级别类加载器申请加载一个类时，它总是首先将该任务委托给它的父类加载器。继续向上委托直至根类加载器确认成功。<strong>如果它的父类加载器未能找到该类，那么当前的类加载器将尝试从自己的JAR文件和目录中加载该类</strong>。 </p><p>&emsp;&emsp;这种类加载的方法被称为<strong>双亲优先类加载委托模式</strong>，尽管这种方法适用于许多类型的应用程序，但它并不完全适用于Java EE Web应用程序。运行Java EE Web应用程序的服务器通常相当复杂，许多供应商都可以提供其实现。服务器可能使用了与个人应用程序使用的相同的第三方库，但它们的版本可能相互冲突。另外，不同的Web应用程序也可能使用了同一第三方库的冲突版本，导致更多的问题为了解决这些问题，就需要使用<strong>子女优先类加载委托模式</strong>。 </p><p>&emsp;&emsp;在Java EE Web应用程序服务器中，每个Web应用程序都被分配了一个自由的相互隔离的类加载器，它们都继承自公共的服务器类加载器。通过隔离不同的应用程序，它们不能访问相互的类。这不仅消除了类冲突的风险，还是一种阻止Web应用程序被其他Web应用程序干扰或伤害的安全方式。另外，Web应用程序类加载器通常会在自己无法加载某个类的时候，请求它的父类加载器帮助加载。通过这种方式，<strong>类加载的任务会在最后而不是首先委托给它的父类</strong>，Web应用程序中的类和库会被优先使用，而不是服务器提供的版本优先使用。为了维持绑定的Java SE类的安全状态，Web应用程序类加载器仍然会在尝试加载任何类之前与根类加载器确认。尽管几乎在所有的情况下，这种委托模式都更适用于Web应用程序，但仍然有它不适用的情况。出于这个原因，兼容Java EE的服务器通常会提供修改委托模式的方法，从父类最后改为父类首先。 </p><hr><p><em>参考博客和文章书籍等：</em></p><blockquote><p>《JavaWeb高级编程-涵盖WebSockets+Spring+Framework+JPA+Hibernate和Spring-Security》</p></blockquote><p><em>因博客主等未标明不可引用，若部分内容涉及侵权请及时告知，我会尽快修改和删除相关内容</em></p>]]></content>
    
    <summary type="html">
    
      Java EE简介，内容包括：背景（Java SE 7的新特性、Java EE 7的新特性、Java SE 8的新特性），基本的Web应用程序结构（Servlet、过滤器、监听器和JSP、目录结构和WAR文件、部署描述符、类加载器架构）等。
    
    </summary>
    
      <category term="技术文档" scheme="http://linyishui.top/categories/%E6%8A%80%E6%9C%AF%E6%96%87%E6%A1%A3/"/>
    
    
      <category term="java" scheme="http://linyishui.top/tags/java/"/>
    
  </entry>
  
  <entry>
    <title>字节码执行引擎-方法调用</title>
    <link href="http://linyishui.top/2019121201.html"/>
    <id>http://linyishui.top/2019121201.html</id>
    <published>2019-12-12T10:28:27.000Z</published>
    <updated>2020-01-10T03:11:17.481Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="字节码执行引擎-方法调用"><a href="#字节码执行引擎-方法调用" class="headerlink" title="字节码执行引擎-方法调用"></a><strong>字节码执行引擎-方法调用</strong></h1><h2 id="第三节-方法调用"><a href="#第三节-方法调用" class="headerlink" title="第三节 方法调用"></a><strong>第三节 方法调用</strong></h2><p>&emsp;&emsp;方法调用并不等同于方法执行，方法调用阶段唯一的任务就是确定被调用方法的版本（即调用哪一个方法），暂时还不涉及方法内部的具体运行过程。在程序运行时，进行方法调用是最普遍、最频繁的操作，但前面已经讲过，Class文件的编译过程中不包含传统编译中的连接步骤，一切方法调用在Class文件里面存储的都只是符号引用，而不是方法在实际运行时内存布局中的入口地址（相当于之前说的直接引用）。这个特性给Java带来了更强大的动态扩展能力，但也使得Java方法调用过程变得相对复杂起来，需要在类加载期间，甚至到运行期间才能确定目标方法的直接引用。</p><h3 id="3-1-解析"><a href="#3-1-解析" class="headerlink" title="3.1 解析"></a><strong>3.1 解析</strong></h3><p>　<br>&emsp;&emsp;继续前面关于方法调用的话题，所有方法调用中的目标方法在Class文件里面都是一个常量池中的符号引用，在类加载的解析阶段，会将其中的一部分符号引用转化为直接引用，这种解析能成立的前提是:方法在程序真正运行之前就有一个可确定的调用版本，并且这个方法的调用版本在运行期是不可改变的。换句话说，调用目标在程序代码写好、编译器进行编译时就必须确定下来。这类方法的调用称为解析（Resolution）。</p><p>&emsp;&emsp;在Java语言中符合“编译期可知，运行期不可变”这个要求的方法，主要包括静态方法和私有方法两大类，前者与类型直接关联，后者在外部不可被访问，这两种方法各自的特点决定了它们都不可能通过继承或别的方式重写其他版本，因此它们都适合在类加载阶段进行解析。</p><p>&emsp;&emsp;与之相对应的是，在Java虚拟机里面提供了5条方法调用字节码指令，分别如下。</p><blockquote><ul><li>invokestatic: 调用静态方法。</li><li>invokespecial: 调用实例构造器＜init＞方法、私有方法和父类方法。invokevirtual:调用所有的虚方法。</li><li>invokeinterface: 调用接口方法，会在运行时再确定一个实现此接口的对象。</li><li>invokedynamic: 先在运行时动态解析出调用点限定符所引用的方法，然后再执行该方法，在此之前的4条调用指令，分派逻辑是固化在Java虚拟机内部的，而&gt;* invokedynamic指令的分派逻辑是由用户所设定的引导方法决定的。</li></ul></blockquote><p>&emsp;&emsp;只要能被invokestatic和invokespecial指令调用的方法，都可以在解析阶段中确定唯一的调用版本，符合这个条件的有静态方法、私有方法、实例构造器、父类方法4类，它们在类加载的时候就会把符号引用解析为该方法的直接引用。这些方法可以称为非虚方法，与之相反，其他方法称为虚方法（除去final方法，后文会提到）。代码清单8-5演示了一个最常见的解析调用的例子，此样例中，静态方法sayHello()只可能属于类型StaticResolution，没有任何手段可以覆盖或隐藏这个方法。</p><figure class="highlight cs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">代码清单<span class="number">8</span><span class="number">-5</span>　方法静态解析演示</span><br><span class="line"><span class="comment">/** </span></span><br><span class="line"><span class="comment"> *方法静态解析演示 </span></span><br><span class="line"><span class="comment"> * </span></span><br><span class="line"><span class="comment"> *@author zzm </span></span><br><span class="line"><span class="comment"> */</span> </span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">StaticResolution</span> &#123; </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">sayHello</span>(<span class="params"></span>) </span>&#123; </span><br><span class="line">        System.<span class="keyword">out</span>.println(<span class="string">"hello world"</span>); </span><br><span class="line">    &#125; </span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span>(<span class="params">String[] args</span>) </span>&#123; </span><br><span class="line">        StaticResolution.sayHello(); </span><br><span class="line">    &#125; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>&emsp;&emsp;使用javap命令查看这段程序的字节码，会发现的确是通过invokestatic命令来调用sayHello()方法的。</p><figure class="highlight arduino"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">D:\Develop\&gt;javap-verbose StaticResolution </span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> main(java.lang.<span class="keyword">String</span>[]); </span><br><span class="line">    Code: </span><br><span class="line">        Stack  =  <span class="number">0</span>，Locals  =  <span class="number">1</span>，Args_size  =  <span class="number">1</span> </span><br><span class="line">        <span class="number">0</span>:    invokestatic#<span class="number">31</span>;    <span class="comment">//Method sayHello:()V </span></span><br><span class="line">        <span class="number">3</span>:    <span class="built_in">return</span> </span><br><span class="line">    </span><br><span class="line">    LineNumberTable: </span><br><span class="line">        <span class="built_in">line</span> <span class="number">15</span>:<span class="number">0</span> </span><br><span class="line">        <span class="built_in">line</span> <span class="number">16</span>:<span class="number">3</span></span><br></pre></td></tr></table></figure><p>&emsp;&emsp;Java中的非虚方法除了使用invokestatic、invokespecial调用的方法之外还有一种，就是被final修饰的方法。虽然final方法是使用invokevirtual指令来调用的，但是由于它无法被覆盖，没有其他版本，所以也无须对方法接收者进行多态选择，又或者说多态选择的结果肯定是唯一的。在Java语言规范中明确说明了final方法是一种非虚方法。</p><p>&emsp;&emsp;解析调用一定是个静态的过程，在编译期间就完全确定，在类装载的解析阶段就会把涉及的符号引用全部转变为可确定的直接引用，不会延迟到运行期再去完成。而分派（Dispatch）调用则可能是静态的也可能是动态的，根据分派依据的宗量数[1]可分为单分派和多分派。这两类分派方式的两两组合就构成了静态单分派、静态多分派、动态单分派、动态多分派4种分派组合情况，下面我们再看看虚拟机中的方法分派是如何进行的。</p><h3 id="3-2-分派"><a href="#3-2-分派" class="headerlink" title="3.2 分派"></a><strong>3.2 分派</strong></h3><p>&emsp;&emsp;众所周知，Java是一门面向对象的程序语言，因为Java具备面向对象的3个基本特征:继承、封装和多态。本节讲解的分派调用过程将会揭示多态性特征的一些最基本的体现，如“重载”和“重写”在Java虚拟机之中是如何实现的，这里的实现当然不是语法上该如何写，我们关心的依然是虚拟机如何确定正确的目标方法。</p><h4 id="3-2-1-静态分派"><a href="#3-2-1-静态分派" class="headerlink" title="3.2.1 静态分派"></a><strong>3.2.1 静态分派</strong></h4><p>&emsp;&emsp;在开始讲解静态分派[1]前，作者准备了一段经常出现在面试题中的程序代码，读者不妨先看一遍，想一下程序的输出结果是什么。后面我们的话题将围绕这个类的方法来重载（Overload）代码，以分析虚拟机和编译器确定方法版本的过程。方法静态分派如代码清单8-6所示。</p><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//代码清单8-6　方法静态分派演示</span></span><br><span class="line"><span class="keyword">package</span> org.fenixsoft.polymorphic; </span><br><span class="line"></span><br><span class="line"><span class="comment">/** </span></span><br><span class="line"><span class="comment"> *方法静态分派演示 </span></span><br><span class="line"><span class="comment"> *@author zzm </span></span><br><span class="line"><span class="comment"> */</span> </span><br><span class="line">public <span class="class"><span class="keyword">class</span> <span class="title">StaticDispatch</span></span>&#123; </span><br><span class="line">    static <span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">Human</span></span>&#123; </span><br><span class="line"></span><br><span class="line">    &#125; </span><br><span class="line">    </span><br><span class="line">    static <span class="class"><span class="keyword">class</span> <span class="title">Man</span> <span class="keyword">extends</span> <span class="title">Human</span></span>&#123; </span><br><span class="line"></span><br><span class="line">    &#125; </span><br><span class="line">    </span><br><span class="line">    static <span class="class"><span class="keyword">class</span> <span class="title">Woman</span> <span class="keyword">extends</span> <span class="title">Human</span></span>&#123; </span><br><span class="line"></span><br><span class="line">    &#125; </span><br><span class="line">    </span><br><span class="line">    public void sayHello(<span class="type">Human</span> guy)&#123; </span><br><span class="line">        <span class="type">System</span>.out.println(<span class="string">"hello,guy!"</span>); </span><br><span class="line">    &#125; </span><br><span class="line">    </span><br><span class="line">    public void sayHello(<span class="type">Man</span> guy)&#123; </span><br><span class="line">        <span class="type">System</span>.out.println(<span class="string">"hello,gentleman!"</span>); </span><br><span class="line">    &#125; </span><br><span class="line">    </span><br><span class="line">    public void sayHello(<span class="type">Woman</span> guy)&#123; </span><br><span class="line">        <span class="type">System</span>.out.println(<span class="string">"hello,lady!"</span>); </span><br><span class="line">    &#125; </span><br><span class="line">    </span><br><span class="line">    public static void main(<span class="type">String</span>[] args)&#123; </span><br><span class="line">        <span class="type">Human</span> man = <span class="keyword">new</span> <span class="type">Man</span>(); </span><br><span class="line">        <span class="type">Human</span> woman = <span class="keyword">new</span> <span class="type">Woman</span>(); </span><br><span class="line">        <span class="type">StaticDispatch</span> sr = <span class="keyword">new</span> <span class="type">StaticDispatch</span>(); </span><br><span class="line">        sr.sayHello(man); </span><br><span class="line">        sr.sayHello(woman); </span><br><span class="line">    &#125; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>&emsp;&emsp;运行结果:</p><figure class="highlight autohotkey"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">hello,</span>guy!</span><br><span class="line"><span class="built_in">hello,</span>guy!</span><br></pre></td></tr></table></figure><p>&emsp;&emsp;代码清单8-6中的代码实际上是在考验阅读者对重载的理解程度，相信对Java编程稍有经验的程序员看完程序后都能得出正确的运行结果，但为什么会选择执行参数类型为Human的重载呢？在解决这个问题之前，我们先按如下代码定义两个重要的概念。</p><figure class="highlight ebnf"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="attribute">Human man</span> = new Man();</span><br></pre></td></tr></table></figure><p>&emsp;&emsp;我们把上面代码中的“Human”称为变量的静态类型（Static Type），或者叫做的外观类型（Apparent Type），后面的“Man”则称为变量的实际类型（Actual Type），静态类型和实际类型在程序中都可以发生一些变化，区别是静态类型的变化仅仅在使用时发生，变量本身的静态类型不会被改变，并且最终的静态类型是在编译期可知的；而实际类型变化的结果在运行期才可确定，编译器在编译程序的时候并不知道一个对象的实际类型是什么。例如下面的代码:</p><figure class="highlight inform7"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">//实际类型变化 </span><br><span class="line">Human <span class="keyword">man</span> = new <span class="keyword">Man</span>(); </span><br><span class="line"><span class="keyword">man</span> = new <span class="keyword">Woman</span>(); </span><br><span class="line">//静态类型变化 </span><br><span class="line">sr.sayHello((<span class="keyword">Man</span>) <span class="keyword">man</span>) </span><br><span class="line">sr.sayHello((<span class="keyword">Woman</span>) <span class="keyword">man</span>)</span><br></pre></td></tr></table></figure><p>&emsp;&emsp;解释了这两个概念，再回到代码清单8-6的样例代码中。main()里面的两次sayHello()方法调用，在方法接收者已经确定是对象“sr”的前提下，使用哪个重载版本，就完全取决于传入参数的数量和数据类型。代码中刻意地定义了两个静态类型相同但实际类型不同的变量，但虚拟机（准确地说是编译器）在重载时是通过参数的静态类型而不是实际类型作为判定依据的。并且静态类型是编译期可知的，因此，在编译阶段，Javac编译器会根据参数的静态类型决定使用哪个重载版本，所以选择了sayHello（Human）作为调用目标，并把这个方法的符号引用写到main()方法里的两条invokevirtual指令的参数中。</p><p>&emsp;&emsp;所有依赖静态类型来定位方法执行版本的分派动作称为静态分派。静态分派的典型应用是方法重载。静态分派发生在编译阶段，因此确定静态分派的动作实际上不是由虚拟机来执行的。另外，编译器虽然能确定出方法的重载版本，但在很多情况下这个重载版本并不是“唯一的”，往往只能确定一个“更加合适的”版本。这种模糊的结论在由0和1构成的计算机世界中算是比较“稀罕”的事情，产生这种模糊结论的主要原因是字面量不需要定义，所以字面量没有显式的静态类型，它的静态类型只能通过语言上的规则去理解和推断。代码清单87演示了何为“更加合适的”版本。</p><figure class="highlight cs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//代码清单8-7　重载方法匹配优先级</span></span><br><span class="line">package org.fenixsoft.polymorphic; </span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">Overload</span>&#123; </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">sayHello</span>(<span class="params">Object arg</span>)</span>&#123; </span><br><span class="line">        System.<span class="keyword">out</span>.println(<span class="string">"hello Object"</span>); </span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">sayHello</span>(<span class="params"><span class="keyword">int</span> arg</span>)</span>&#123; </span><br><span class="line">        System.<span class="keyword">out</span>.println(<span class="string">"hello int"</span>); </span><br><span class="line">    &#125; </span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">sayHello</span>(<span class="params"><span class="keyword">long</span> arg</span>)</span>&#123; </span><br><span class="line">        System.<span class="keyword">out</span>.println(<span class="string">"hello long"</span>); </span><br><span class="line">    &#125; </span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">sayHello</span>(<span class="params">Character arg</span>)</span>&#123; </span><br><span class="line">        System.<span class="keyword">out</span>.println(<span class="string">"hello Character"</span>); </span><br><span class="line">    &#125; </span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">sayHello</span>(<span class="params"><span class="keyword">char</span> arg</span>)</span>&#123; </span><br><span class="line">        System.<span class="keyword">out</span>.println(<span class="string">"hello char"</span>); </span><br><span class="line">    &#125; </span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">sayHello</span>(<span class="params"><span class="keyword">char</span>... arg</span>)</span>&#123; </span><br><span class="line">        System.<span class="keyword">out</span>.println(<span class="string">"hello char ..."</span>); </span><br><span class="line">    &#125; </span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">sayHello</span>(<span class="params">Serializable arg</span>)</span>&#123; </span><br><span class="line">        System.<span class="keyword">out</span>.println(<span class="string">"hello Serializable"</span>); </span><br><span class="line">    &#125; </span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span>(<span class="params">String[] args</span>)</span>&#123; </span><br><span class="line">        sayHello(<span class="string">'a'</span>); </span><br><span class="line">    &#125; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>&emsp;&emsp;上面的代码运行后会输出:</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">hello <span class="keyword">char</span></span><br></pre></td></tr></table></figure><p>&emsp;&emsp;这很好理解，’a’是一个char类型的数据，自然会寻找参数类型为char的重载方法，如果注释掉sayHello（char arg）方法，那输出会变为:</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">hello <span class="keyword">int</span></span><br></pre></td></tr></table></figure><p>&emsp;&emsp;这时发生了一次自动类型转换，’a’除了可以代表一个字符串，还可以代表数字97（字符’a’的Unicode数值为十进制数字97），因此参数类型为int的重载也是合适的。我们继续注释掉sayHello(int arg)方法，那输出会变为:</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">hello <span class="keyword">long</span></span><br></pre></td></tr></table></figure><p>&emsp;&emsp;这时发生了两次自动类型转换，’a’转型为整数97之后，进一步转型为长整数97L，匹配了参数类型为long的重载。作者在代码中没有写其他的类型如float、double等的重载，不过实际上自动转型还能继续发生多次，按照char-&gt;int-&gt;long-&gt;float-&gt;double的顺序转型进行匹配。但不会匹配到byte和short类型的重载，因为char到byte或short的转型是不安全的。我们继续注释掉sayHello(long arg)方法，那输出会变为:</p><figure class="highlight ebnf"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="attribute">hello Character</span></span><br></pre></td></tr></table></figure><p>&emsp;&emsp;这时发生了一次自动装箱，’a’被包装为它的封装类型java.lang.Character，所以匹配到了参数类型为Character的重载，继续注释掉sayHello(Character arg)方法，那输出会变为:</p><figure class="highlight ebnf"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="attribute">hello Serializable</span></span><br></pre></td></tr></table></figure><p>&emsp;&emsp;这个输出可能会让人感觉摸不着头脑，一个字符或数字与序列化有什么关系？出现helloSerializable，是因为java.lang.Serializable是java.lang.Character类实现的一个接口，当自动装箱之后发现还是找不到装箱类，但是找到了装箱类实现了的接口类型，所以紧接着又发生一次自动转型。char可以转型成int，但是Character是绝对不会转型为Integer的，它只能安全地转型为它实现的接口或父类。Character还实现了另外一个接口java.lang.Comparable＜Character＞，如果同时出现两个参数分别为Serializable和Comparable＜Character＞的重载方法，那它们在此时的优先级是一样的。编译器无法确定要自动转型为哪种类型，会提示类型模糊，拒绝编译。程序必须在调用时显式地指定字面量的静态类型，如:sayHello（（Comparable＜Character＞）’a’），才能编译通过。下面继续注释掉sayHello（Serializable arg）方法，输出会变为:</p><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">hello <span class="built_in">Object</span></span><br></pre></td></tr></table></figure><p>&emsp;&emsp;这时是char装箱后转型为父类了，如果有多个父类，那将在继承关系中从下往上开始搜索，越接近上层的优先级越低。即使方法调用传入的参数值为null时，这个规则仍然适用。我们把sayHello（Object arg）也注释掉，输出将会变为:</p><figure class="highlight gams"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="title">hello</span></span> char ...</span><br></pre></td></tr></table></figure><p>&emsp;&emsp;7个重载方法已经被注释得只剩一个了，可见变长参数的重载优先级是最低的，这时候字符’a’被当做了一个数组元素。作者使用的是char类型的变长参数，读者在验证时还可以选择int类型、Character类型、Object类型等的变长参数重载来把上面的过程重新演示一遍。但要注意的是，有一些在单个参数中能成立的自动转型，如char转型为int，在变长参数中是不成立的[2]。</p><p>&emsp;&emsp;代码清单8-7演示了编译期间选择静态分派目标的过程，这个过程也是Java语言实现方法重载的本质。演示所用的这段程序属于很极端的例子，除了用做面试题为难求职者以外，在实际工作中几乎不可能有实际用途。作者拿来做演示仅仅是用于讲解重载时目标方法选择的<br>过程，大部分情况下进行这样极端的重载都可算是真正的“关于茴香豆的茴有几种写法的研究”。无论对重载的认识有多么深刻，一个合格的程序员都不应该在实际应用中写出如此极端的重载代码。</p><p>&emsp;&emsp;另外还有一点读者可能比较容易混淆:作者讲述的解析与分派这两者之间的关系并不是二选一的排他关系，它们是在不同层次上去筛选、确定目标方法的过程。例如，前面说过，静态方法会在类加载期就进行解析，而静态方法显然也是可以拥有重载版本的，选择重载版本的过程也是通过静态分派完成的。</p><h4 id="3-2-2-动态分派"><a href="#3-2-2-动态分派" class="headerlink" title="3.2.2 动态分派"></a><strong>3.2.2 动态分派</strong></h4><p>&emsp;&emsp;了解了静态分派，我们接下来看一下动态分派的过程，它和多态性的另外一个重要体现[3]——重写（Override）有着很密切的关联。我们还是用前面的Man和Woman一起sayHello的例子来讲解动态分派，请看代码清单8-8中所示的代码。</p><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//代码清单8-8　方法动态分派演示</span></span><br><span class="line"><span class="keyword">package</span> org.fenixsoft.polymorphic; </span><br><span class="line"><span class="comment">/** </span></span><br><span class="line"><span class="comment"> *方法动态分派演示 </span></span><br><span class="line"><span class="comment"> *@author zzm </span></span><br><span class="line"><span class="comment"> */</span> </span><br><span class="line">public <span class="class"><span class="keyword">class</span> <span class="title">DynamicDispatch</span></span>&#123; </span><br><span class="line">    static <span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">Human</span></span>&#123; </span><br><span class="line">        <span class="keyword">protected</span> <span class="keyword">abstract</span> void sayHello(); </span><br><span class="line">    &#125; </span><br><span class="line">    </span><br><span class="line">    static <span class="class"><span class="keyword">class</span> <span class="title">Man</span> <span class="keyword">extends</span> <span class="title">Human</span></span>&#123; </span><br><span class="line">        <span class="meta">@Override</span> </span><br><span class="line">        <span class="keyword">protected</span> void sayHello()&#123; </span><br><span class="line">            <span class="type">System</span>.out.println(<span class="string">"man say hello"</span>); </span><br><span class="line">        &#125; </span><br><span class="line">    &#125; </span><br><span class="line">    </span><br><span class="line">    static <span class="class"><span class="keyword">class</span> <span class="title">Woman</span> <span class="keyword">extends</span> <span class="title">Human</span></span>&#123; </span><br><span class="line">        <span class="meta">@Override</span> </span><br><span class="line">        <span class="keyword">protected</span> void sayHello()&#123; </span><br><span class="line">            <span class="type">System</span>.out.println(<span class="string">"woman say hello"</span>); </span><br><span class="line">        &#125; </span><br><span class="line">    &#125; </span><br><span class="line">    </span><br><span class="line">    public static void main(<span class="type">String</span>[] args)&#123; </span><br><span class="line">        <span class="type">Human</span> man = <span class="keyword">new</span> <span class="type">Man</span>(); </span><br><span class="line">        <span class="type">Human</span> woman = <span class="keyword">new</span> <span class="type">Woman</span>(); </span><br><span class="line">        man.sayHello(); </span><br><span class="line">        woman.sayHello(); </span><br><span class="line">        man = <span class="keyword">new</span> <span class="type">Woman</span>(); </span><br><span class="line">        man.sayHello(); </span><br><span class="line">    &#125; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>&emsp;&emsp;运行结果:</p><figure class="highlight inform7"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">man</span> <span class="keyword">say</span> hello </span><br><span class="line"><span class="keyword">woman</span> <span class="keyword">say</span> hello </span><br><span class="line"><span class="keyword">woman</span> <span class="keyword">say</span> hello</span><br></pre></td></tr></table></figure><p>&emsp;&emsp;这个运行结果相信不会出乎任何人的意料，对于习惯了面向对象思维的Java程序员会觉得这是完全理所当然的。现在的问题还是和前面的一样，虚拟机是如何知道要调用哪个方法的？</p><p>&emsp;&emsp;显然这里不可能再根据静态类型来决定，因为静态类型同样都是Human的两个变量man和woman在调用sayHello()方法时执行了不同的行为，并且变量man在两次调用中执行了不同的方法。导致这个现象的原因很明显，是这两个变量的实际类型不同，Java虚拟机是如何根据实际类型来分派方法执行版本的呢？我们使用javap命令输出这段代码的字节码，尝试从中寻找答案，输出结果如代码清单8-9所示。</p><figure class="highlight scss"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//代码清单8-9　main()方法的字节码</span></span><br><span class="line">public static void main(java<span class="selector-class">.lang</span><span class="selector-class">.String</span><span class="selector-attr">[]</span>); </span><br><span class="line">    <span class="selector-tag">Code</span>: </span><br><span class="line">        Stack = <span class="number">2</span>，Locals = <span class="number">3</span>，Args_size = <span class="number">1</span> </span><br><span class="line">        <span class="number">0</span>:    new    <span class="number">#16</span>;              <span class="comment">//class org/fenixsoft/polymorphic/DynamicDispatch $Man </span></span><br><span class="line">        3:    dup </span><br><span class="line">        <span class="number">4</span>:    invokespecial    <span class="number">#18</span>;    <span class="comment">//Method org/fenixsoft/polymorphic/DynamicDispatch $Man."＜init＞":()V </span></span><br><span class="line">        7:    astore_1 </span><br><span class="line">        <span class="number">8</span>:    new<span class="number">#19</span>;                  <span class="comment">//class org/fenixsoft/polymorphic/DynamicDispatch $Woman </span></span><br><span class="line">        11:   dup </span><br><span class="line">        <span class="number">12</span>:   invokespecial    <span class="number">#21</span>;    <span class="comment">//Method org/fenixsoft/polymorphic/DynamicDispa tch $Woman."＜init＞":()V </span></span><br><span class="line">        15:   astore_2 </span><br><span class="line">        <span class="number">16</span>:   aload_1 </span><br><span class="line">        <span class="number">17</span>:   invokevirtual    <span class="number">#22</span>;    <span class="comment">//Method org/fenixsoft/polymorphic/DynamicDispatch $Human.sayHello:()V </span></span><br><span class="line">        20:   aload_2 </span><br><span class="line">        <span class="number">21</span>:   invokevirtual    <span class="number">#22</span>;    <span class="comment">//Method org/fenixsoft/polymorphic/DynamicDispatch $Human.sayHello:()V </span></span><br><span class="line">        24:   new<span class="number">#19</span>;                  <span class="comment">//class org/fenixsoft/polymorphic/DynamicDispatch $Woman </span></span><br><span class="line">        27:   dup </span><br><span class="line">        <span class="number">28</span>:   invokespecial    <span class="number">#21</span>;    <span class="comment">//Method org/fenixsoft/polymorphic/Dynam icDispatch $Woman."＜init＞":()V </span></span><br><span class="line">        31:   astore_1 </span><br><span class="line">        <span class="number">32</span>:   aload_1 </span><br><span class="line">        <span class="number">33</span>:   invokevirtual    <span class="number">#22</span>;    <span class="comment">//Method org/fenixsoft/polymorphic/ DynamicDispatch $Human.sayHello:()V </span></span><br><span class="line">        36:   return</span><br></pre></td></tr></table></figure><p>&emsp;&emsp;0～15行的字节码是准备动作，作用是建立man和woman的内存空间、调用Man和Woman类型的实例构造器，将这两个实例的引用存放在第1、2个局部变量表Slot之中，这个动作也就对应了代码中的这两句:</p><figure class="highlight ebnf"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="attribute">Human man</span> = new Man(); </span><br><span class="line"><span class="attribute">Human woman</span> = new Woman();</span><br></pre></td></tr></table></figure><p>&emsp;&emsp;接下来的16～21句是关键部分，16、20两句分别把刚刚创建的两个对象的引用压到栈顶，这两个对象是将要执行的sayHello()方法的所有者，称为接收者（Receiver）；17和21句是方法调用指令，这两条调用指令单从字节码角度来看，无论是指令（都是invokevirtual）还是参数（都是常量池中第22项的常量，注释显示了这个常量是Human.sayHello()的符号引用）完全一样的，但是这两句指令最终执行的目标方法并不相同。原因就需要从invokevirtual指令的多态查找过程开始说起，invokevirtual指令的运行时解析过程大致分为以下几个步骤:</p><blockquote><ol><li>找到操作数栈顶的第一个元素所指向的对象的实际类型，记作C。</li><li>如果在类型C中找到与常量中的描述符和简单名称都相符的方法，则进行访问权限校验，如果通过则返回这个方法的直接引用，查找过程结束；如果不通过，则返回java.lang.IllegalAccessError异常。</li><li>否则，按照继承关系从下往上依次对C的各个父类进行第2步的搜索和验证过程。</li><li>如果始终没有找到合适的方法，则抛出java.lang.AbstractMethodError异常。</li></ol></blockquote><p>&emsp;&emsp;由于invokevirtual指令执行的第一步就是在运行期确定接收者的实际类型，所以两次调用中的invokevirtual指令把常量池中的类方法符号引用解析到了不同的直接引用上，这个过程就是Java语言中方法重写的本质。我们把这种在运行期根据实际类型确定方法执行版本的分派过程称为动态分派。</p><h4 id="3-2-3-单分派与多分派"><a href="#3-2-3-单分派与多分派" class="headerlink" title="3.2.3 单分派与多分派"></a><strong>3.2.3 单分派与多分派</strong></h4><p>&emsp;&emsp;方法的接收者与方法的参数统称为方法的宗量，这个定义最早应该来源于《Java与模式》一书。根据分派基于多少种宗量，可以将分派划分为单分派和多分派两种。单分派是根据一个宗量对目标方法进行选择，多分派则是根据多于一个宗量对目标方法进行选择。</p><p>&emsp;&emsp;单分派和多分派的定义读起来拗口，从字面上看也比较抽象，不过对照着实例看就不难理解了。代码清单8-10中列举了一个Father和Son一起来做出“一个艰难的决定”的例子。</p><figure class="highlight cs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//代码清单8-10　单分派和多分派</span></span><br><span class="line"><span class="comment">/** </span></span><br><span class="line"><span class="comment"> *单分派、多分派演示 </span></span><br><span class="line"><span class="comment"> *@author zzm </span></span><br><span class="line"><span class="comment"> */</span> </span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">Dispatch</span>&#123; </span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">class</span> <span class="title">QQ</span>&#123;&#125; </span><br><span class="line">    <span class="keyword">static</span> class_360&#123;&#125; </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">class</span> <span class="title">Father</span>&#123; </span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">hardChoice</span>(<span class="params">QQ arg</span>)</span>&#123;</span><br><span class="line">            System.<span class="keyword">out</span>.println(<span class="string">"father choose qq"</span>); </span><br><span class="line">        &#125; </span><br><span class="line">        </span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">hardChoice</span>(<span class="params">_360 arg</span>)</span>&#123; </span><br><span class="line">            System.<span class="keyword">out</span>.println(<span class="string">"father choose 360"</span>); </span><br><span class="line">        &#125; </span><br><span class="line">    &#125; </span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">class</span> <span class="title">Son</span> <span class="title">extends</span> <span class="title">Father</span>&#123; </span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">hardChoice</span>(<span class="params">QQ arg</span>)</span>&#123; </span><br><span class="line">            System.<span class="keyword">out</span>.println(<span class="string">"son choose qq"</span>); </span><br><span class="line">        &#125; </span><br><span class="line">        </span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">hardChoice</span>(<span class="params">_360 arg</span>)</span>&#123; </span><br><span class="line">            System.<span class="keyword">out</span>.println(<span class="string">"son choose 360"</span>); </span><br><span class="line">        &#125; </span><br><span class="line">    &#125; </span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span>(<span class="params">String[] args</span>)</span>&#123; </span><br><span class="line">        Father father = <span class="keyword">new</span> Father(); </span><br><span class="line">        Father son = <span class="keyword">new</span> Son(); </span><br><span class="line">        father.hardChoice(new_360()); </span><br><span class="line">        son.hardChoice(<span class="keyword">new</span> QQ()); </span><br><span class="line">    &#125; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>&emsp;&emsp;运行结果:</p><figure class="highlight excel"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">father <span class="built_in">choose</span> <span class="number">360</span> </span><br><span class="line">son <span class="built_in">choose</span> qq</span><br></pre></td></tr></table></figure><p>&emsp;&emsp;在main函数中调用了两次hardChoice()方法，这两次hardChoice()方法的选择结果在程序输出中已经显示得很清楚了。</p><p>&emsp;&emsp;我们来看看编译阶段编译器的选择过程，也就是静态分派的过程。这时选择目标方法的依据有两点:一是静态类型是Father还是Son，二是方法参数是QQ还是360。这次选择结果的最终产物是产生了两条invokevirtual指令，两条指令的参数分别为常量池中指向Father.hardChoice(360)及Father.hardChoice(QQ)方法的符号引用。因为是根据两个宗量进行选择，所以Java语言的静态分派属于多分派类型。</p><p>&emsp;&emsp;再看看运行阶段虚拟机的选择，也就是动态分派的过程。在执行“son.hardChoice(new QQ())”这句代码时，更准确地说，是在执行这句代码所对应的invokevirtual指令时，由于编译期已经决定目标方法的签名必须为hardChoice(QQ)，虚拟机此时不会关心传递过来的参数“QQ”到底是“腾讯QQ”还是“奇瑞QQ”，因为这时参数的静态类型、实际类型都对方法的选择不会构成任何影响，唯一可以影响虚拟机选择的因素只有此方法的接受者的实际类型是Father还是Son。因为只有一个宗量作为选择依据，所以Java语言的动态分派属于单分派类型。</p><p>&emsp;&emsp;根据上述论证的结果，我们可以总结一句:今天（直至还未发布的Java 1.8）的Java语言是一门静态多分派、动态单分派的语言。强调“今天的Java语言”是因为这个结论未必会恒久不变，C#在3.0及之前的版本与Java一样是动态单分派语言，但在C#4.0中引入了dynamic类型后，就可以很方便地实现动态多分派。</p><p>&emsp;&emsp;按照目前Java语言的发展趋势，它并没有直接变为动态语言的迹象，而是通过内置动态语言（如JavaScript）执行引擎的方式来满足动态性的需求。但是Java虚拟机层面上则不是如此，在JDK 1.7中实现的JSR-292[4]里面就已经开始提供对动态语言的支持了，JDK1.7中新增的invokedynamic指令也成为了最复杂的一条方法调用的字节码指令，稍后作者将专门讲解这个JDK1.7的新特性。</p><h4 id="3-2-4-虚拟机动态分派的实现"><a href="#3-2-4-虚拟机动态分派的实现" class="headerlink" title="3.2.4 虚拟机动态分派的实现"></a><strong>3.2.4 虚拟机动态分派的实现</strong></h4><p>&emsp;&emsp;前面介绍的分派过程，作为对虚拟机概念模型的解析基本上已经足够了，它已经解决了虚拟机在分派中“会做什么”这个问题。但是虚拟机“具体是如何做到的”，可能各种虚拟机的实现都会有些差别。</p><p>&emsp;&emsp;由于动态分派是非常频繁的动作，而且动态分派的方法版本选择过程需要运行时在类的方法元数据中搜索合适的目标方法，因此在虚拟机的实际实现中基于性能的考虑，大部分实现都不会真正地进行如此频繁的搜索。面对这种情况，最常用的“稳定优化”手段就是为类在方法区中建立一个虚方法表（Vritual Method Table，也称为vtable，与此对应的，在invokeinterface执行时也会用到接口方法表——Inteface Method Table，简称itable），使用虚方法表索引来代替元数据查找以提高性能。我们先看看代码清单8-10所对应的虚方法表结构示例，如图8-3所示。</p><p><img src="https://pic-1258215793.cos.ap-shanghai.myqcloud.com/content/20191201/201912010163.png" alt="方法表结构"></p><p>&emsp;&emsp;虚方法表中存放着各个方法的实际入口地址。如果某个方法在子类中没有被重写，那子类的虚方法表里面的地址入口和父类相同方法的地址入口是一致的，都指向父类的实现入口。如果子类中重写了这个方法，子类方法表中的地址将会替换为指向子类实现版本的入口地址。图8-3中，Son重写了来自Father的全部方法，因此Son的方法表没有指向Father类型数据的箭头。但是Son和Father都没有重写来自Object的方法，所以它们的方法表中所有从Object继承来的方法都指向了Object的数据类型。</p><p>&emsp;&emsp;为了程序实现上的方便，具有相同签名的方法，在父类、子类的虚方法表中都应当具有一样的索引序号，这样当类型变换时，仅需要变更查找的方法表，就可以从不同的虚方法表中按索引转换出所需的入口地址。</p><p>&emsp;&emsp;方法表一般在类加载的连接阶段进行初始化，准备了类的变量初始值后，虚拟机会把该类的方法表也初始化完毕。</p><p>&emsp;&emsp;上文中作者说方法表是分派调用的“稳定优化”手段，虚拟机除了使用方法表之外，在条件允许的情况下，还会使用内联缓存（Inline Cache）和基于“类型继承关系分析”（Class Hierarchy Analysis,CHA）技术的守护内联（Guarded Inlining）两种非稳定的“激进优化”手段来获得更高的性能，关于这两种优化技术的原理和运作过程，读者可以参考本书第11章中的相关内容。</p><h3 id="3-3-动态类型语言支持"><a href="#3-3-动态类型语言支持" class="headerlink" title="3.3 动态类型语言支持"></a><strong>3.3 动态类型语言支持</strong></h3><p>&emsp;&emsp;Java虚拟机的字节码指令集的数量从Sun公司的第一款Java虚拟机问世至JDK7来临之前的十余年时间里，一直没有发生任何变化。随着JDK7的发布，字节码指令集终于迎来了第一位新成员——invokedynamic指令。这条新增加的指令是JDK7实现“动态类型语言”（Dynamically Typed Language）支持而进行的改进之一，也是为JDK 8可以顺利实现Lambda表达式做技术准备。在本节中，我们将详细讲解JDK7这项新特性出现的前因后果和它的深远意义。</p><h4 id="3-3-1-动态类型语言"><a href="#3-3-1-动态类型语言" class="headerlink" title="3.3.1 动态类型语言"></a><strong>3.3.1 动态类型语言</strong></h4><p>&emsp;&emsp;在介绍Java虚拟机的动态类型语言支持之前，我们要先弄明白动态类型语言是什么？它与Java语言、Java虚拟机有什么关系？了解JDK 1.7提供动态类型语言支持的技术背景，对理解这个语言特性是很有必要的。</p><p>&emsp;&emsp;什么是动态类型语言[1]？动态类型语言的关键特征是它的类型检查的主体过程是在运行期而不是编译期，满足这个特征的语言有很多，常用的包括:APL、Clojure、Erlang、Groovy、JavaScript、Jython、Lisp、Lua、PHP、Prolog、Python、Ruby、Smalltalk和Tcl等。相对的，在编译期就进行类型检查过程的语言（如C++和Java等）就是最常用的静态类型语言。</p><p>&emsp;&emsp;觉得上面定义过于概念化？那我们不妨通过两个例子以最浅显的方式来说明什么是“在编译期/运行期进行”和什么是“类型检查”。首先看下面这段简单的Java代码，它是否能正常编译和运行？</p><figure class="highlight smali"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">public<span class="keyword"> static</span> void main(String[] args)&#123; </span><br><span class="line">    int[][][]<span class="built_in"> array </span>=<span class="built_in"> new </span>int[1][0][-1]; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>&emsp;&emsp;这段代码能够正常编译，但运行的时候会报NegativeArraySizeException异常。在Java虚拟机规范中明确规定了NegativeArraySizeException是一个运行时异常，通俗一点来说，运行时异常就是只要代码不运行到这一行就不会有问题。与运行时异常相对应的是连接时异常，例如很常见的NoClassDefFoundError便属于连接时异常，即使会导致连接时异常的代码放在一条无法执行到的分支路径上，类加载时（Java的连接过程不在编译阶段，而在类加载阶段）也照样会抛出异常。</p><p>&emsp;&emsp;不过，在C语言中，含义相同的代码会在编译期报错:</p><figure class="highlight smali"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">int main(void)&#123; </span><br><span class="line">   <span class="built_in"> int </span>i[1][0][-1];//GCC拒绝编译，报“size of<span class="built_in"> array </span>is negative” </span><br><span class="line">   <span class="built_in"> return </span>0; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>&emsp;&emsp;由此看来，一门语言的哪一种检查行为要在运行期进行，哪一种检查要在编译期进行并没有必然的因果逻辑关系，关键是语言规范中人为规定的。再举一个例子来解释“类型检查”，例如下面这一句非常简单的代码:</p><figure class="highlight abnf"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">obj.println(<span class="string">"hello world"</span>)<span class="comment">;</span></span><br></pre></td></tr></table></figure><p>&emsp;&emsp;虽然每个人都能看懂这行代码要做什么，但对于计算机来说，这一行代码“没头没尾”是无法执行的，它需要一个具体的上下文才有讨论的意义。</p><p>&emsp;&emsp;现在假设这行代码是在Java语言中，并且变量obj的静态类型为java.io.PrintStream，那变量obj的实际类型就必须是PrintStream的子类（实现了PrintStream接口的类）才是合法的。否则，哪怕obj属于一个确实有用println(String)方法，但与PrintStream接口没有继承关系，代码依然不可能运行——因为类型检查不合法。</p><p>&emsp;&emsp;但是相同的代码在ECMAScript（JavaScript）中情况则不一样，无论obj具体是何种类型，只要这种类型的定义中确实包含有println(String)方法，那方法调用便可成功。</p><p>&emsp;&emsp;这种差别产生的原因是Java语言在编译期间已将println(String)方法完整的符号引用（本例中为一个CONSTANT_InterfaceMethodref_info常量）生成出来，作为方法调用指令的参数存储到Class文件中，例如下面这段代码:</p><figure class="highlight 1c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">invokevirtual    <span class="meta">#4;    <span class="comment">//Method java/io/PrintStream.println:(Ljava/lang/String;)V</span></span></span><br></pre></td></tr></table></figure><p>&emsp;&emsp;这个符号引用包含了此方法定义在哪个具体类型之中、方法的名字以及参数顺序、参数类型和方法返回值等信息，通过这个符号引用，虚拟机可以翻译出这个方法的直接引用。而在ECMAScript等动态类型语言中，变量obj本身是没有类型的，变量obj的值才具有类型，编译时最多只能确定方法名称、参数、返回值这些信息，而不会去确定方法所在的具体类型（即方法接收者不固定）。“变量无类型而变量值才有类型”这个特点也是动态类型语言的一个重要特征。</p><p>&emsp;&emsp;了解了动态和静态类型语言的区别后，也许读者的下一个问题就是动态、静态类型语言两者谁更好，或者谁更加先进？这种比较不会有确切答案，因为它们都有自己的优点，选择哪种语言是需要经过权衡的。静态类型语言在编译期确定类型，最显著的好处是编译器可以提供严谨的类型检查，这样与类型相关的问题能在编码的时候就及时发现，利于稳定性及代码达到更大规模。而动态类型语言在运行期确定类型，这可以为开发人员提供更大的灵活性，某些在静态类型语言中需用大量“臃肿”代码来实现的功能，由动态类型语言来实现可能会更加清晰和简洁，清晰和简洁通常也就意味着开发效率的提升。</p><h4 id="3-3-2-JDK-1-7与动态类型"><a href="#3-3-2-JDK-1-7与动态类型" class="headerlink" title="3.3.2 JDK 1.7与动态类型"></a><strong>3.3.2 JDK 1.7与动态类型</strong></h4><p>&emsp;&emsp;回到本节的主题，来看看Java语言、虚拟机与动态类型语言之间有什么关系。Java虚拟机毫无疑问是Java语言的运行平台，但它的使命并不仅限于此，早在1997年出版的《Java虚拟机规范》中就规划了这样一个愿景:“在未来，我们会对Java虚拟机进行适当的扩展，以便更好地支持其他语言运行于Java虚拟机之上”。而目前确实已经有许多动态类型语言运行于Java虚拟机之上了，如Clojure、Groovy、Jython和JRuby等，能够在同一个虚拟机上可以达到静态类型语言的严谨性与动态类型语言的灵活性，这是一件很美妙的事情。</p><p>&emsp;&emsp;但遗憾的是，Java虚拟机层面对动态类型语言的支持一直都有所欠缺，主要表现在方法调用方面:JDK 1.7以前的字节码指令集中，4条方法调用指令（invokevirtual、invokespecial、invokestatic、invokeinterface）的第一个参数都是被调用的方法的符号引用（CONSTANT_Methodref_info或者CONSTANT_InterfaceMethodref_info常量），前面已经提到过，方法的符号引用在编译时产生，而动态类型语言只有在运行期才能确定接收者类型。这样，在Java虚拟机上实现的动态类型语言就不得不使用其他方式（如编译时留个占位符类型，运行时动态生成字节码实现具体类型到占位符类型的适配）来实现，这样势必让动态类型语言实现的复杂度增加，也可能带来额外的性能或者内存开销。尽管可以利用一些办法（如Call Site Caching）让这些开销尽量变小，但这种底层问题终归是应当在虚拟机层次上去解决才最合适，因此在Java虚拟机层面上提供动态类型的直接支持就成为了Java平台的发展趋势之一，这就是JDK 1.7（JSR-292）中invokedynamic指令以及java.lang.invoke包出现的技术背景。</p><h4 id="3-3-3-java-lang-invoke包"><a href="#3-3-3-java-lang-invoke包" class="headerlink" title="3.3.3 java.lang.invoke包"></a><strong>3.3.3 java.lang.invoke包</strong></h4><p>&emsp;&emsp;JDK1.7实现了JSR-292，新加入的java.lang.invoke包[2]就是JSR-292的一个重要组成部分，这个包的主要目的是在之前单纯依靠符号引用来确定调用的目标方法这种方式以外，提供一种新的动态确定目标方法的机制，称为MethodHandle。这种表达方式也许不太好懂？那不妨把MethodHandle与C/C++中的Function Pointer，或者C#里面的Delegate类比一下。举个例子，如果我们要实现一个带谓词的排序函数，在C/C++中常用的做法是把谓词定义为函数，用函数指针把谓词传递到排序方法，如下:</p><figure class="highlight processing"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">void</span> <span class="built_in">sort</span>(<span class="built_in">int</span> list[], <span class="keyword">const</span> <span class="built_in">int</span> <span class="built_in">size</span>, <span class="built_in">int</span>(*compare)(<span class="built_in">int</span>, <span class="built_in">int</span>))</span><br></pre></td></tr></table></figure><p>&emsp;&emsp;但Java语言做不到这一点，即没有办法单独地把一个函数作为参数进行传递。普遍的做法是设计一个带有compare()方法的Comparator接口，以实现了这个接口的对象作为参数，例如Collections.sort()就是这样定义的:</p><figure class="highlight lasso"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="literal">void</span> sort(<span class="built_in">List</span> <span class="built_in">list</span>, Comparator c)</span><br></pre></td></tr></table></figure><p>&emsp;&emsp;不过，在拥有Method Handle之后，Java语言也可以拥有类似于函数指针或者委托的方法别名的工具了。代码清单8-11演示了MethodHandle的基本用途，无论obj是何种类型（临时定义的ClassA抑或是实现PrintStream接口的实现类System.out），都可以正确地调用到println()方法。</p><figure class="highlight groovy"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//代码清单8-11　MethodHandle演示</span></span><br><span class="line"><span class="keyword">import</span> <span class="keyword">static</span> java.lang.invoke.MethodHandles.lookup; </span><br><span class="line"><span class="keyword">import</span> java.lang.invoke.MethodHandle; </span><br><span class="line"><span class="keyword">import</span> java.lang.invoke.MethodType; </span><br><span class="line"></span><br><span class="line"><span class="comment">/** </span></span><br><span class="line"><span class="comment"> *JSR-292 Method Handle基础用法演示 </span></span><br><span class="line"><span class="comment"> *<span class="doctag">@author</span> zzm </span></span><br><span class="line"><span class="comment"> */</span> </span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MethodHandleTest</span>&#123;</span> </span><br><span class="line">    <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">ClassA</span>&#123;</span> </span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">void</span> println(String s)&#123; </span><br><span class="line">            System.out.println(s); </span><br><span class="line">        &#125; </span><br><span class="line">    &#125; </span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> main(String[] args)<span class="keyword">throws</span> Throwable&#123; </span><br><span class="line">        Object obj = System.currentTimeMillis()%<span class="number">2</span> == <span class="number">0</span> ? System.out:<span class="keyword">new</span> ClassA(); </span><br><span class="line">        <span class="comment">// 无论obj最终是哪个实现类，下面这句都能正确调用到println方法 </span></span><br><span class="line">        getPrintlnMH(obj).invokeExact(<span class="string">"icyfenix"</span>); </span><br><span class="line">    &#125; </span><br><span class="line">    </span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> MethodHandle getPrintlnMH(Object reveiver) <span class="keyword">throws</span> Throwable&#123; </span><br><span class="line">        <span class="comment">/*MethodType:代表“方法类型”，包含了方法的返回值(methodType()的第一个参数)和具体参数(methodType()第二个及以后的参数)*/</span> </span><br><span class="line">        MethodType mt = MethodType.methodType(<span class="keyword">void</span>.<span class="keyword">class</span>, String.<span class="keyword">class</span>); </span><br><span class="line"></span><br><span class="line">        <span class="comment">/*lookup()方法来自于MethodHandles.lookup，这句的作用是在指定类中查找符合给定的方法名称、方法类型，并且符合调用权限的方法句柄*/</span> </span><br><span class="line">        <span class="comment">/*因为这里调用的是一个虚方法，按照Java语言的规则，方法第一个参数是隐式的，代表该方法的接收者，也即是this指向的对象，这个参数以前是放在参数列表中进行传递的，而现在提供了bindTo()方法来完成这件事情*/</span></span><br><span class="line">        <span class="keyword">return</span> lookup().findVirtual(reveiver.getClass(), <span class="string">"println"</span>, mt).bindTo(reveiver); </span><br><span class="line">    &#125; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>&emsp;&emsp;实际上，方法getPrintlnMH()中模拟了invokevirtual指令的执行过程，只不过它的分派逻辑并非固化在Class文件的字节码上，而是通过一个具体方法来实现。而这个方法本身的返回值（MethodHandle对象），可以视为对最终调用方法的一个“引用”。以此为基础，有了MethodHandle就可以写出类似于下面这样的函数声明:</p><figure class="highlight stata"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">void <span class="keyword">sort</span>(<span class="keyword">List</span> <span class="keyword">list</span>, MethodHandle <span class="keyword">compare</span>)</span><br></pre></td></tr></table></figure><p>&emsp;&emsp;从上面的例子可以看出，使用MethodHandle并没有什么困难，不过看完它的用法之后，读者大概就会产生疑问，相同的事情，用反射不是早就可以实现了吗？</p><p>&emsp;&emsp;确实，仅站在Java语言的角度来看，MethodHandle的使用方法和效果与Reflection有众多相似之处，不过，它们还是有以下这些区别:</p><p>&emsp;&emsp;从本质上讲，Reflection和MethodHandle机制都是在模拟方法调用，但Reflection是在模拟Java代码层次的方法调用，而MethodHandle是在模拟字节码层次的方法调用。在MethodHandles.lookup中的3个方法——findStatic()、findVirtual()、findSpecial()正是为了对应于invokestatic、invokevirtual＆invokeinterface和invokespecial这几条字节码指令的执行权限校验行为，而这些底层细节在使用Reflection API时是不需要关心的。</p><p>&emsp;&emsp;Reflection中的java.lang.reflect.Method对象远比MethodHandle机制中的java.lang.invoke.MethodHandle对象所包含的信息多。前者是方法在Java一端的全面映像，包含了方法的签名、描述符以及方法属性表中各种属性的Java端表示方式，还包含执行权限等的运行期信息。而后者仅仅包含与执行该方法相关的信息。用通俗的话来讲，Reflection是重量级，而MethodHandle是轻量级。</p><p>&emsp;&emsp;由于MethodHandle是对字节码的方法指令调用的模拟，所以理论上虚拟机在这方面做的各种优化（如方法内联），在MethodHandle上也应当可以采用类似思路去支持（但目前实现还不完善）。而通过反射去调用方法则不行。</p><p>&emsp;&emsp;MethodHandle与Reflection除了上面列举的区别外，最关键的一点还在于去掉前面讨论施加的前提“仅站在Java语言的角度来看”:ReflectionAPI的设计目标是只为Java语言服务的，而MethodHandle则设计成可服务于所有Java虚拟机之上的语言，其中也包括Java语言。</p><h4 id="3-3-4-invokedynamic指令"><a href="#3-3-4-invokedynamic指令" class="headerlink" title="3.3.4 invokedynamic指令"></a><strong>3.3.4 invokedynamic指令</strong></h4><p>&emsp;&emsp;本节一开始就提到了JDK1.7为了更好地支持动态类型语言，引入了第5条方法调用的字节码指令invokedynamic，之后一直没有再提到它，甚至把代码清单8-11中使用MethodHandle的示例代码反编译后也不会看见invokedynamic的身影，它的应用之处在哪里呢？</p><p>&emsp;&emsp;在某种程度上，invokedynamic指令与MethodHandle机制的作用是一样的，都是为了解决原有4条“invoke*”指令方法分派规则固化在虚拟机之中的问题，把如何查找目标方法的决定权从虚拟机转嫁到具体用户代码之中，让用户（包含其他语言的设计者）有更高的自由度。而且，它们两者的思路也是可类比的，可以把它们想象成为了达成同一个目的，一个采用上层Java代码和API来实现，另一个用字节码和Class中其他属性、常量来完成。因此，如果理解了前面的MethodHandle例子，那么理解invokedynamic指令也并不困难。</p><p>&emsp;&emsp;每一处含有invokedynamic指令的位置都称做“动态调用点”（Dynamic Call Site），这条指令的第一个参数不再是代表方法符号引用的CONSTANT_Methodref_info常量，而是变为JDK 1.7新加入的CONSTANT_InvokeDynamic_info常量，从这个新常量中可以得到3项信息:引导方法（BootstrapMethod，此方法存放在新增的BootstrapMethods属性中）、方法类型（MethodType）和名称。引导方法是有固定的参数，并且返回值是java.lang.invoke.CallSite对象，这个代表真正要执行的目标方法调用。根据CONSTANT_InvokeDynamic_info常量中提供的信息，虚拟机可以找到并且执行引导方法，从而获得一个CallSite对象，最终调用要执行的目标方法。我们还是举一个实际的例子来解释这个过程，如代码清单8-12所示。</p><figure class="highlight aspectj"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//代码清单8-12　invokedynamic指令演示</span></span><br><span class="line"><span class="keyword">import</span> <span class="keyword">static</span> java.lang.invoke.MethodHandles.lookup; </span><br><span class="line"><span class="keyword">import</span> java.lang.invoke.CallSite; </span><br><span class="line"><span class="keyword">import</span> java.lang.invoke.ConstantCallSite; </span><br><span class="line"><span class="keyword">import</span> java.lang.invoke.MethodHandle; </span><br><span class="line"><span class="keyword">import</span> java.lang.invoke.MethodHandles; </span><br><span class="line"><span class="keyword">import</span> java.lang.invoke.MethodType; </span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">InvokeDynamicTest</span></span>&#123; </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="function"><span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Throwable</span>&#123; </span><br><span class="line">        INDY_BootstrapMethod().invokeExact(<span class="string">"icyfenix"</span>); </span><br><span class="line">    &#125; </span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="function"><span class="keyword">void</span> <span class="title">testMethod</span><span class="params">(String s)</span></span>&#123; </span><br><span class="line">        System.out.println(<span class="string">"hello String:"</span>+s); </span><br><span class="line">    &#125; </span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="function">CallSite <span class="title">BootstrapMethod</span><span class="params">(MethodHandles.Lookup lookup, String name, MethodType mt)</span> <span class="keyword">throws</span> Throwable</span>&#123; </span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> ConstantCallSite(lookup.findStatic(InvokeDynamicTest.class,name,mt)); </span><br><span class="line">    &#125; </span><br><span class="line">    </span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="function">MethodType <span class="title">MT_BootstrapMethod</span><span class="params">()</span></span>&#123; </span><br><span class="line">        <span class="keyword">return</span> MethodType </span><br><span class="line">                .fromMethodDescriptorString(</span><br><span class="line">                    <span class="string">"(Ljava/lang/invoke/MethodHandles$Lookup;Ljava/lang/String;Ljava/lang/invoke/MethodType;)Ljava/lang/invoke/CallSite;"</span>,  <span class="keyword">null</span>); </span><br><span class="line">    &#125; </span><br><span class="line">    </span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="function">MethodHandle <span class="title">MH_BootstrapMethod</span><span class="params">()</span> <span class="keyword">throws</span> Throwable</span>&#123; </span><br><span class="line">        <span class="keyword">return</span> lookup().findStatic(InvokeDynamicTest.class, <span class="string">"BootstrapMethod"</span>, MT_BootstrapMethod()); </span><br><span class="line">    &#125; </span><br><span class="line">    </span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="function">MethodHandle <span class="title">INDY_BootstrapMethod</span><span class="params">()</span> <span class="keyword">throws</span> Throwable</span>&#123; </span><br><span class="line">        CallSite cs = (CallSite)MH_BootstrapMethod().invokeWithArguments(lookup(), <span class="string">"testMethod"</span>, MethodType.fromMethodDescriptorString(<span class="string">"(Ljava/lang/String;)V"</span>, <span class="keyword">null</span>)); </span><br><span class="line">        <span class="function"><span class="keyword">return</span> cs.<span class="title">dynamicInvoker</span><span class="params">()</span></span>; </span><br><span class="line">    &#125; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>&emsp;&emsp;这段代码与前面MethodHandleTest的作用基本上是一样的，虽然作者没有加以注释，但是阅读起来应当不困难。本书前面提到过，由于invokedynamic指令所面向的使用者并非Java语言，而是其他Java虚拟机之上的动态语言，因此仅依靠Java语言的编译器Javac没有办法生成带有invokedynamic指令的字节码（曾经有一个java.dyn.InvokeDynamic的语法糖可以实现，但后来被取消了），所以要使用Java语言来演示invokedynamic指令只能用一些变通的办法。John Rose（DaVinci Machine Project的Leader）编写了一个把程序的字节码转换为使用invokedynamic的简单工具INDY[3]来完成这件事情，我们要使用这个工具来产生最终要的字节码，因此这个示例代码中的方法名称不能随意改动，更不能把几个方法合并到一起写，因为它们是要被INDY工具读取的。</p><p>&emsp;&emsp;把上面代码编译、再使用INDY转换后重新生成的字节码如代码清单8-13所示（结果使用javap输出，因版面原因，精简了许多无关的内容）。</p><figure class="highlight gauss"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//代码清单8-13　invokedynamic指令演示(2)</span></span><br><span class="line">Constant pool: </span><br><span class="line">    <span class="meta">#121 = NameAndType      #33:#30    <span class="comment">//testMethod:(Ljava/lang/String;)V </span></span></span><br><span class="line">    <span class="meta">#123 = InvokeDynamic    #0:#121    <span class="comment">//#0:testMethod:(Ljava/lang/String;)V </span></span></span><br><span class="line"></span><br><span class="line">public static void main(java.lang.<span class="keyword">String</span>[]) throws java.lang.Throwable; </span><br><span class="line">    <span class="built_in">Code</span>: </span><br><span class="line">        stack = <span class="number">2</span>，locals = <span class="number">1</span>，args_size = <span class="number">1</span> </span><br><span class="line">            <span class="number">0</span>: ldc            <span class="meta">#23        <span class="comment">//String abc </span></span></span><br><span class="line">            <span class="number">2</span>: invokedynamic  <span class="meta">#123, 0    <span class="comment">//InvokeDynamic#0:testMethod:(Ljava/lang/String;)V </span></span></span><br><span class="line">            <span class="number">7</span>: nop </span><br><span class="line">            <span class="number">8</span>: <span class="keyword">return</span> </span><br><span class="line"></span><br><span class="line">public static java.lang.invoke.CallSite BootstrapMethod(java.lang.invoke.MethodHandles $Lookup,java.lang.<span class="keyword">String</span>,java.lang.invoke.MethodType) throws java.lang.Throwable; </span><br><span class="line">    <span class="built_in">Code</span>: </span><br><span class="line">        stack = <span class="number">6</span>，locals = <span class="number">3</span>，args_size = <span class="number">3</span> </span><br><span class="line">            <span class="number">0</span>: <span class="keyword">new</span>            <span class="meta">#63        <span class="comment">//class java/lang/invoke/ConstantCallSite </span></span></span><br><span class="line">            <span class="number">3</span>: dup </span><br><span class="line">            <span class="number">4</span>: aload_0 </span><br><span class="line">            <span class="number">5</span>: ldc            <span class="meta">#1         <span class="comment">//class org/fenixsoft/InvokeDynamicTest </span></span></span><br><span class="line">            <span class="number">7</span>: aload_1 </span><br><span class="line">            <span class="number">8</span>: aload_2 </span><br><span class="line">            <span class="number">9</span>: invokevirtual  <span class="meta">#65        <span class="comment">//Method java/lang/invoke/MethodHandles$Lookup.findStatic:(Ljava/lang/Class;Ljava/lang/String;Ljava/lang/invoke/MethodType;)Ljava/lang/invoke/MethodHandle; </span></span></span><br><span class="line">            <span class="number">12</span>: invokespecial <span class="meta">#71        <span class="comment">//Method java/lang/invoke/ConstantCallSite."＜init＞":(Ljava/lang/invoke/MethodHandle;)V </span></span></span><br><span class="line">            <span class="number">15</span>: areturn</span><br></pre></td></tr></table></figure><p>&emsp;&emsp;从main()方法的字节码可见，原本的方法调用指令已经替换为invokedynamic，它的参数为第123项常量（第二个值为0的参数在HotSpot中用不到，与invokeinterface指令那个值为0的参数一样都是占位的）。</p><figure class="highlight less"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="attribute">2</span>: invokedynamic  <span class="number">#123</span>, <span class="number">0</span>    <span class="comment">// InvokeDynamic #0:testMethod:(Ljava/lang/String;)V</span></span><br></pre></td></tr></table></figure><p>&emsp;&emsp;从常量池中可见，第123项常量显示“#123 = InvokeDynamic#0:#121”说明它是一项CONSTANT_InvokeDynamic_info类型常量，常量值中前面的“#0”代表引导方法取BootstrapMethods属性表的第0项（javap没有列出属性表的具体内容，不过示例中仅有一个引导方法，即BootstrapMethod()），而后面的“#121”代表引用第121项类型为CONSTANT_NameAndType_info的常量，从这个常量中可以获取方法名称和描述符，即后面输出的“testMethod:（Ljava/lang/String；）V”。</p><p>&emsp;&emsp;再看一下BootstrapMethod()，这个方法Java源码中没有，是INDY产生的，但是它的字节码很容易读懂，所有逻辑就是调用MethodHandles $Lookup的findStatic()方法，产生testMethod()方法的MethodHandle，然后用它创建一个ConstantCallSite对象。最后，这个对象返回给invokedynamic指令实现对testMethod()方法的调用，invokedynamic指令的调用过程到此就宣告完成了。</p><h4 id="3-3-5-掌控方法分派规则"><a href="#3-3-5-掌控方法分派规则" class="headerlink" title="3.3.5 掌控方法分派规则"></a><strong>3.3.5 掌控方法分派规则</strong></h4><p>&emsp;&emsp;invokedynamic指令与前面4条“invoke*”指令的最大差别就是它的分派逻辑不是由虚拟机决定的，而是由程序员决定。在介绍Java虚拟机动态语言支持的最后一个小结中，作者通过一个简单例子（如代码清单8-14所示），帮助读者理解程序员在可以掌控方法分派规则之后，能做什么以前无法做到的事情。</p><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//代码清单8-14　方法调用问题</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">GrandFather</span></span>&#123; </span><br><span class="line">    void thinking()&#123; </span><br><span class="line">        <span class="type">System</span>.out.println(<span class="string">"i am grandfather"</span>); </span><br><span class="line">    &#125; </span><br><span class="line">&#125; </span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Father</span> <span class="keyword">extends</span> <span class="title">GrandFather</span></span>&#123; </span><br><span class="line">    void thinking()&#123; </span><br><span class="line">        <span class="type">System</span>.out.println(<span class="string">"i am father"</span>); </span><br><span class="line">    &#125; </span><br><span class="line">&#125; </span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Son</span> <span class="keyword">extends</span> <span class="title">Father</span></span>&#123; </span><br><span class="line">    void thinking()&#123; </span><br><span class="line">        <span class="comment">//请读者在这里填入适当的代码(不能修改其他地方的代码) </span></span><br><span class="line">        <span class="comment">//实现调用祖父类的thinking()方法，打印"i am grandfather" </span></span><br><span class="line">    &#125; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>&emsp;&emsp;在Java程序中，可以通过“super”关键字很方便地调用到父类中的方法，但如果要访问祖类的方法呢？读者在阅读本书下面提供的解决方案之前，不妨自己思考一下，在JDK 1.7之前有没有办法解决这个问题。</p><p>&emsp;&emsp;在JDK 1.7之前，使用纯粹的Java语言很难处理这个问题（直接生成字节码就很简单，如使用ASM等字节码工具），原因是在Son类的thinking()方法中无法获取一个实际类型是GrandFather的对象引用，而invokevirtual指令的分派逻辑就是按照方法接收者的实际类型进行分派，这个逻辑是固化在虚拟机中的，程序员无法改变。在JDK1.7中，可以使用代码清单815中的程序来解决这个问题。</p><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//代码清单8-15　使用MethodHandle来解决相关问题</span></span><br><span class="line"><span class="keyword">import</span> static java.lang.invoke.<span class="type">MethodHandles</span>.lookup; </span><br><span class="line"><span class="keyword">import</span> java.lang.invoke.<span class="type">MethodHandle</span>; </span><br><span class="line"><span class="keyword">import</span> java.lang.invoke.<span class="type">MethodType</span>; </span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Test</span></span>&#123; </span><br><span class="line">    <span class="class"><span class="keyword">class</span> <span class="title">GrandFather</span></span>&#123; </span><br><span class="line">        void thinking()&#123; </span><br><span class="line">            <span class="type">System</span>.out.println(<span class="string">"i am grandfather"</span>); </span><br><span class="line">        &#125; </span><br><span class="line">    &#125; </span><br><span class="line">    </span><br><span class="line">    <span class="class"><span class="keyword">class</span> <span class="title">Father</span> <span class="keyword">extends</span> <span class="title">GrandFather</span></span>&#123;</span><br><span class="line">        void thinking()&#123; </span><br><span class="line">            <span class="type">System</span>.out.println(<span class="string">"i am father"</span>); </span><br><span class="line">        &#125; </span><br><span class="line">    &#125; </span><br><span class="line">    </span><br><span class="line">    <span class="class"><span class="keyword">class</span> <span class="title">Son</span> <span class="keyword">extends</span> <span class="title">Father</span></span>&#123; </span><br><span class="line">        void thinking()&#123; </span><br><span class="line">            <span class="keyword">try</span>&#123; </span><br><span class="line">                <span class="type">MethodType</span> mt = <span class="type">MethodType</span>.methodType(void.<span class="keyword">class</span>); </span><br><span class="line">                <span class="type">MethodHandle</span> mh = lookup().findSpecial(<span class="type">GrandFather</span>.<span class="keyword">class</span>, <span class="string">"thinking"</span>, mt,getClass()); </span><br><span class="line">                mh.invoke(<span class="keyword">this</span>); </span><br><span class="line">            &#125; <span class="keyword">catch</span> (<span class="type">Throwable</span> e)&#123; </span><br><span class="line">            &#125; </span><br><span class="line">        &#125; </span><br><span class="line">    &#125; </span><br><span class="line">    </span><br><span class="line">    public static void main(<span class="type">String</span>[] args)&#123; </span><br><span class="line">        (<span class="keyword">new</span> <span class="type">Test</span>().<span class="keyword">new</span> <span class="type">Son</span>()).thinking(); </span><br><span class="line">    &#125; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>&emsp;&emsp;运行结果:</p><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-tag">i</span> am grandfather</span><br></pre></td></tr></table></figure><hr><p><em>参考博客和文章书籍等:</em></p><blockquote><p>《深入理解Java虚拟机》</p></blockquote><p><em>因博客主等未标明不可引用，若部分内容涉及侵权请及时告知，我会尽快修改和删除相关内容</em></p>]]></content>
    
    <summary type="html">
    
      简单介绍Java虚拟机中的字节码执行引擎-方法调用，包括：解析，分派（静态分派、动态分派、单分派与多分派、虚拟机动态分派的实现），动态类型语言支持（动态类型语言、JDK 1.7与动态类型、java.lang.invoke包、invokedynamic指令、掌控方法分派规则、）等内容。
    
    </summary>
    
      <category term="技术文档" scheme="http://linyishui.top/categories/%E6%8A%80%E6%9C%AF%E6%96%87%E6%A1%A3/"/>
    
    
      <category term="java" scheme="http://linyishui.top/tags/java/"/>
    
      <category term="jvm" scheme="http://linyishui.top/tags/jvm/"/>
    
  </entry>
  
  <entry>
    <title>字节码执行引擎-运行时栈帧结构</title>
    <link href="http://linyishui.top/2019121101.html"/>
    <id>http://linyishui.top/2019121101.html</id>
    <published>2019-12-11T10:28:22.000Z</published>
    <updated>2020-01-10T03:11:48.144Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="字节码执行引擎-运行时栈帧结构"><a href="#字节码执行引擎-运行时栈帧结构" class="headerlink" title="字节码执行引擎-运行时栈帧结构"></a><strong>字节码执行引擎-运行时栈帧结构</strong></h1><h2 id="第二节-运行时栈帧结构"><a href="#第二节-运行时栈帧结构" class="headerlink" title="第二节 运行时栈帧结构"></a><strong>第二节 运行时栈帧结构</strong></h2><p>&emsp;&emsp;栈帧（Stack Frame）是用于支持虚拟机进行方法调用和方法执行的数据结构，它是虚拟机运行时数据区中的虚拟机栈（Virtual Machine Stack）[1]的栈元素。栈帧存储了方法的局部变量表、操作数栈、动态连接和方法返回地址等信息。每一个方法从调用开始至执行完成的过程，都对应着一个栈帧在虚拟机栈里面从入栈到出栈的过程。</p><p>&emsp;&emsp;每一个栈帧都包括了局部变量表、操作数栈、动态连接、方法返回地址和一些额外的附加信息。在编译程序代码的时候，栈帧中需要多大的局部变量表，多深的操作数栈都已经完全确定了，并且写入到方法表的Code属性之中[2]，因此一个栈帧需要分配多少内存，不会受到程序运行期变量数据的影响，而仅仅取决于具体的虚拟机实现。</p><p>&emsp;&emsp;一个线程中的方法调用链可能会很长，很多方法都同时处于执行状态。对于执行引擎来说，在活动线程中，只有位于栈顶的栈帧才是有效的，称为当前栈帧（Current Stack Frame），与这个栈帧相关联的方法称为当前方法（Current Method）。执行引擎运行的所有字节码指令都只针对当前栈帧进行操作，在概念模型上，典型的栈帧结构如图8-1所示。</p><p><img src="https://pic-1258215793.cos.ap-shanghai.myqcloud.com/content/20191201/201912010161.png" alt="栈帧的概念结构"></p><p>&emsp;&emsp;接下来详细讲解一下栈帧中的局部变量表、操作数栈、动态连接、方法返回地址等各个部分的作用和数据结构。</p><h3 id="2-1-局部变量表"><a href="#2-1-局部变量表" class="headerlink" title="2.1 局部变量表"></a><strong>2.1 局部变量表</strong></h3><p>&emsp;&emsp;局部变量表（Local Variable Table）是一组变量值存储空间，用于存放方法参数和方法内部定义的局部变量。在Java程序编译为Class文件时，就在方法的Code属性的max_locals数据项中确定了该方法所需要分配的局部变量表的最大容量。</p><p>&emsp;&emsp;局部变量表的容量以变量槽（Variable Slot，下称Slot）为最小单位，虚拟机规范中并没有明确指明一个Slot应占用的内存空间大小，只是很有导向性地说到每个Slot都应该能存放一个boolean、byte、char、short、int、float、reference或returnAddress类型的数据，这8种数据类型，都可以使用32位或更小的物理内存来存放，但这种描述与明确指出“每个Slot占用32位长度的内存空间”是有一些差别的，它允许Slot的长度可以随着处理器、操作系统或虚拟机的不同而发生变化。只要保证即使在64位虚拟机中使用了64位的物理内存空间去实现一个Slot，虚拟机仍要使用对齐和补白的手段让Slot在外观上看起来与32位虚拟机中的一致。</p><p>&emsp;&emsp;既然前面提到了Java虚拟机的数据类型，在此再简单介绍一下它们。一个Slot可以存放一个32位以内的数据类型，Java中占用32位以内的数据类型有boolean、byte、char、short、int、float、reference[3]和returnAddress8种类型。前面6种不需要多加解释，读者可以按照Java语言中对应数据类型的概念去理解它们（仅是这样理解而已，Java语言与Java虚拟机中的基本数据类型是存在本质差别的），而第7种reference类型表示对一个对象实例的引用，虚拟机规范既没有说明它的长度，也没有明确指出这种引用应有怎样的结构。但一般来说，虚拟机实现至少都应当能通过这个引用做到两点，一是从此引用中直接或间接地查找到对象在Java堆中的数据存放的起始地址索引，二是此引用中直接或间接地查找到对象所属数据类型在方法区中的存储的类型信息，否则无法实现Java语言规范中定义的语法约束约束[4]。第8种即returnAddress类型目前已经很少见了，它是为字节码指令jsr、jsr_w和ret服务的，指向了一条字节码指令的地址，很古老的Java虚拟机曾经使用这几条指令来实现异常处理，现在已经由异常表代替。</p><p>&emsp;&emsp;对于64位的数据类型，虚拟机会以高位对齐的方式为其分配两个连续的Slot空间。Java语言中明确的（reference类型则可能是32位也可能是64位）64位的数据类型只有long和double两种。值得一提的是，这里把long和double数据类型分割存储的做法与“long和double的非原子性协定”中把一次long和double数据类型读写分割为两次32位读写的做法有些类似，读者阅读到Java内存模型时可以互相对比一下。不过，由于局部变量表建立在线程的堆栈上，是线程私有的数据，无论读写两个连续的Slot是否为原子操作，都不会引起数据安全问题[5]。</p><p>&emsp;&emsp;虚拟机通过索引定位的方式使用局部变量表，索引值的范围是从0开始至局部变量表最大的Slot数量。如果访问的是32位数据类型的变量，索引n就代表了使用第n个Slot，如果是64位数据类型的变量，则说明会同时使用n和n+1两个Slot。对于两个相邻的共同存放一个64位数据的两个Slot，不允许采用任何方式单独访问其中的某一个，Java虚拟机规范中明确要求了如果遇到进行这种操作的字节码序列，虚拟机应该在类加载的校验阶段抛出异常。</p><p>&emsp;&emsp;在方法执行时，虚拟机是使用局部变量表完成参数值到参数变量列表的传递过程的，如果执行的是实例方法（非static的方法），那局部变量表中第0位索引的Slot默认是用于传递方法所属对象实例的引用，在方法中可以通过关键字“this”来访问到这个隐含的参数。其余参<br>数则按照参数表顺序排列，占用从1开始的局部变量Slot，参数表分配完毕后，再根据方法体内部定义的变量顺序和作用域分配其余的Slot。</p><p>&emsp;&emsp;为了尽可能节省栈帧空间，局部变量表中的Slot是可以重用的，方法体中定义的变量，其作用域并不一定会覆盖整个方法体，如果当前字节码PC计数器的值已经超出了某个变量的作用域，那这个变量对应的Slot就可以交给其他变量使用。不过，这样的设计除了节省栈帧空间以外，还会伴随一些额外的副作用，例如，在某些情况下，Slot的复用会直接影响到系统的垃圾收集行为，请看代码清单8-1～代码清单8-3的3个演示。</p><figure class="highlight arduino"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//代码清单8-1　局部变量表Slot复用对垃圾收集的影响之一</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> main(<span class="keyword">String</span>[] args)&#123; </span><br><span class="line">    <span class="keyword">byte</span>[] placeholder = <span class="keyword">new</span> <span class="keyword">byte</span>[<span class="number">64</span>*<span class="number">1024</span>*<span class="number">1024</span>];</span><br><span class="line">    System.gc(); </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>&emsp;&emsp;代码清单8-1中的代码很简单，即向内存填充了64MB的数据，然后通知虚拟机进行垃圾收集。我们在虚拟机运行参数中加上“-verbose：gc”来看看垃圾收集的过程，发现在System.gc()运行后并没有回收这64MB的内存，下面是运行的结果：</p><figure class="highlight lsl"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[GC <span class="number">66846</span>K-&gt;<span class="number">65824</span>K(<span class="number">125632</span>K)，<span class="number">0.0032678</span> secs] [Full GC <span class="number">65824</span>K-&gt;<span class="number">65746</span>K(<span class="number">125632</span>K)，<span class="number">0.0064131</span> secs]</span><br></pre></td></tr></table></figure><p>&emsp;&emsp;没有回收placeholder所占的内存能说得过去，因为在执行System.gc()时，变量placeholder还处于作用域之内，虚拟机自然不敢回收placeholder的内存。那我们把代码修改一下，变成代码清单8-2中的样子。</p><figure class="highlight arduino"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//代码清单8-2　局部变量表Slot复用对垃圾收集的影响之二</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> main(<span class="keyword">String</span>[] args) () &#123; </span><br><span class="line">    &#123; </span><br><span class="line">        <span class="keyword">byte</span>[]placeholder=<span class="keyword">new</span> <span class="keyword">byte</span>[<span class="number">64</span>*<span class="number">1024</span>*<span class="number">1024</span>]; </span><br><span class="line">    &#125; </span><br><span class="line">    System.gc(); </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>&emsp;&emsp;加入了花括号之后，placeholder的作用域被限制在花括号之内，从代码逻辑上讲，在执行System.gc()的时候，placeholder已经不可能再被访问了，但执行一下这段程序，会发现运行结果如下，还是有64MB的内存没有被回收，这又是为什么呢？</p><figure class="highlight lsl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">[GC <span class="number">66846</span>K-&gt;<span class="number">65888</span>K(<span class="number">125632</span>K)，<span class="number">0.0009397</span> secs] </span><br><span class="line">[Full GC <span class="number">65888</span>K-&gt;<span class="number">65746</span>K(<span class="number">125632</span>K)，<span class="number">0.0051574</span> secs]</span><br></pre></td></tr></table></figure><p>&emsp;&emsp;在解释为什么之前，我们先对这段代码进行第二次修改，在调用System.gc()之前加入一行“int a=0；”，变成代码清单8-3的样子。</p><figure class="highlight arduino"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//代码清单8-3　局部变量表Slot复用对垃圾收集的影响之三</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> main(<span class="keyword">String</span>[] args) () &#123; </span><br><span class="line">    &#123; </span><br><span class="line">        <span class="keyword">byte</span>[] placeholder = <span class="keyword">new</span> <span class="keyword">byte</span>[<span class="number">64</span>*<span class="number">1024</span>*<span class="number">1024</span>]; </span><br><span class="line">    &#125; </span><br><span class="line">    <span class="keyword">int</span> a=<span class="number">0</span>; </span><br><span class="line">    System.gc(); </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>&emsp;&emsp;这个修改看起来很莫名其妙，但运行一下程序，却发现这次内存真的被正确回收了。</p><figure class="highlight lsl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">[GC <span class="number">66401</span>K-&gt;<span class="number">65778</span>K(<span class="number">125632</span>K)，<span class="number">0.0035471</span> secs] </span><br><span class="line">[Full GC <span class="number">65778</span>K-&gt;<span class="number">218</span>K(<span class="number">125632</span>K)，<span class="number">0.0140596</span> secs]</span><br></pre></td></tr></table></figure><p>&emsp;&emsp;在代码清单8-1～代码清单8-3中，placeholder能否被回收的根本原因是：局部变量表中的Slot是否还存有关于placeholder数组对象的引用。第一次修改中，代码虽然已经离开了placeholder的作用域，但在此之后，没有任何对局部变量表的读写操作，placeholder原本所占用的Slot还没有被其他变量所复用，所以作为GCRoots一部分的局部变量表仍然保持着对它的关联。这种关联没有被及时打断，在绝大部分情况下影响都很轻微。但如果遇到一个方法，其后面的代码有一些耗时很长的操作，而前面又定义了占用了大量内存、实际上已经不会再使用的变量，手动将其设置为null值（用来代替那句int a = 0，把变量对应的局部变量表Slot清空）便不见得是一个绝对无意义的操作，这种操作可以作为一种在极特殊情形（对象占用内存大、此方法的栈帧长时间不能被回收、方法调用次数达不到JIT的编译条件）下的“奇技”来使用。Java语言的一本非常著名的书籍《Practical Java》中把“不使用的对象应手动赋值为null”作为一条推荐的编码规则，但是并没有解释具体的原因，很长时间之内都有读者对这条规则感到疑惑。</p><p>&emsp;&emsp;虽然代码清单8-1～代码清单8-3的代码示例说明了赋null值的操作在某些情况下确实是有用的，但作者的观点是不应当对赋null值的操作有过多的依赖，更没有必要把它当做一个普遍的编码规则来推广。原因有两点，从编码角度讲，以恰当的变量作用域来控制变量回收时间才是最优雅的解决方法，如代码清单8-3那样的场景并不多见。更关键的是，从执行角度讲，使用赋null值的操作来优化内存回收是建立在对字节码执行引擎概念模型的理解之上的，在第6章介绍完字节码后，作者专门增加了一个6.5节“公有设计、私有实现”来强调概念模型与实际执行过程是外部看起来等效，内部看上去则可以完全不同。在虚拟机使用解释器执行时，通常与概念模型还比较接近，但经过JIT编译器后，才是虚拟机执行代码的主要方式，赋null值的操作在经过JIT编译优化后就会被消除掉，这时候将变量设置为null就是没有意义的。字节码被编译为本地代码后，对GCRoots的枚举也与解释执行时期有巨大差别，以前面例子来看，代码清单8-2在经过JIT编译后，System.gc()执行时就可以正确地回收掉内存，无须写成代码清单8-3的样子。</p><p>&emsp;&emsp;关于局部变量表，还有一点可能会对实际开发产生影响，就是局部变量不像前面介绍的类变量那样存在“准备阶段”。通过第7章的讲解，我们已经知道类变量有两次赋初始值的过程，一次在准备阶段，赋予系统初始值；另外一次在初始化阶段，赋予程序员定义的初始值。因此，即使在初始化阶段程序员没有为类变量赋值也没有关系，类变量仍然具有一个确定的初始值。但局部变量就不一样，如果一个局部变量定义了但没有赋初始值是不能使用的，不要认为Java中任何情况下都存在诸如整型变量默认为0，布尔型变量默认为false等这样的默认值。如代码清单8-4所示，这段代码其实并不能运行，还好编译器能在编译期间就检查到并提示这一点，即便编译能通过或者手动生成字节码的方式制造出下面代码的效果，字节码校验的时候也会被虚拟机发现而导致类加载失败。</p><figure class="highlight arduino"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//代码清单8-4　未赋值的局部变量</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> main(<span class="keyword">String</span>[] args)&#123; </span><br><span class="line">    <span class="keyword">int</span> a; </span><br><span class="line">    System.out.<span class="built_in">println</span>(a); </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="2-2-操作数栈"><a href="#2-2-操作数栈" class="headerlink" title="2.2 操作数栈"></a><strong>2.2 操作数栈</strong></h3><p>&emsp;&emsp;操作数栈（Operand Stack）也常称为操作栈，它是一个后入先出（Last In First Out,LIFO）栈。同局部变量表一样，操作数栈的最大深度也在编译的时候写入到Code属性的max_stacks数据项中。操作数栈的每一个元素可以是任意的Java数据类型，包括long和double。32位数据类型所占的栈容量为1，64位数据类型所占的栈容量为2。在方法执行的任何时候，操作数栈的深度都不会超过在max_stacks数据项中设定的最大值。</p><p>&emsp;&emsp;当一个方法刚刚开始执行的时候，这个方法的操作数栈是空的，在方法的执行过程中，会有各种字节码指令往操作数栈中写入和提取内容，也就是出栈/入栈操作。例如，在做算术运算的时候是通过操作数栈来进行的，又或者在调用其他方法的时候是通过操作数栈来进行参数传递的。</p><p>&emsp;&emsp;举个例子，整数加法的字节码指令iadd在运行的时候操作数栈中最接近栈顶的两个元素已经存入了两个int型的数值，当执行这个指令时，会将这两个int值出栈并相加，然后将相加的结果入栈。</p><p>&emsp;&emsp;操作数栈中元素的数据类型必须与字节码指令的序列严格匹配，在编译程序代码的时候，编译器要严格保证这一点，在类校验阶段的数据流分析中还要再次验证这一点。再以上面的iadd指令为例，这个指令用于整型数加法，它在执行时，最接近栈顶的两个元素的数据类型必须为int型，不能出现一个long和一个float使用iadd命令相加的情况。</p><p>&emsp;&emsp;另外，在概念模型中，两个栈帧作为虚拟机栈的元素，是完全相互独立的。但在大多虚拟机的实现里都会做一些优化处理，令两个栈帧出现一部分重叠。让下面栈帧的部分操作数栈与上面栈帧的部分局部变量表重叠在一起，这样在进行方法调用时就可以共用一部分数据，无须进行额外的参数复制传递，重叠的过程如图8-2所示。</p><p><img src="https://pic-1258215793.cos.ap-shanghai.myqcloud.com/content/20191201/201912010162.png" alt="两个栈帧之间的数据共享"></p><p>&emsp;&emsp;Java虚拟机的解释执行引擎称为“基于栈的执行引擎”，其中所指的“栈”就是操作数栈。本章稍后会对基于栈的代码过程进行更详细的讲解。</p><h3 id="2-3-动态连接"><a href="#2-3-动态连接" class="headerlink" title="2.3 动态连接"></a><strong>2.3 动态连接</strong></h3><p>&emsp;&emsp;每个栈帧都包含一个指向运行时常量池[1]中该栈帧所属方法的引用，持有这个引用是为了支持方法调用过程中的动态连接（Dynamic Linking）。通过第6章的讲解，我们知道Class文件的常量池中存有大量的符号引用，字节码中的方法调用指令就以常量池中指向方法的符号引用作为参数。这些符号引用一部分会在类加载阶段或者第一次使用的时候就转化为直接引用，这种转化称为静态解析。另外一部分将在每一次运行期间转化为直接引用，这部分称为动态连接。关于这两个转化过程的详细信息，将在8.3节中详细讲解。</p><p>&emsp;&emsp;运行时常量池可参考第2章。</p><h3 id="2-4-方法返回地址"><a href="#2-4-方法返回地址" class="headerlink" title="2.4 方法返回地址"></a><strong>2.4 方法返回地址</strong></h3><p>&emsp;&emsp;当一个方法开始执行后，只有两种方式可以退出这个方法。第一种方式是执行引擎遇到任意一个方法返回的字节码指令，这时候可能会有返回值传递给上层的方法调用者（调用当前方法的方法称为调用者），是否有返回值和返回值的类型将根据遇到何种方法返回指令来决定，这种退出方法的方式称为正常完成出口（Normal Method Invocation Completion）。</p><p>&emsp;&emsp;另外一种退出方式是，在方法执行过程中遇到了异常，并且这个异常没有在方法体内得到处理，无论是Java虚拟机内部产生的异常，还是代码中使用athrow字节码指令产生的异常，只要在本方法的异常表中没有搜索到匹配的异常处理器，就会导致方法退出，这种退出方法的方式称为异常完成出口（Abrupt Method Invocation Completion）。一个方法使用异常完成出口的方式退出，是不会给它的上层调用者产生任何返回值的。</p><p>&emsp;&emsp;无论采用何种退出方式，在方法退出之后，都需要返回到方法被调用的位置，程序才能继续执行，方法返回时可能需要在栈帧中保存一些信息，用来帮助恢复它的上层方法的执行状态。一般来说，方法正常退出时，调用者的PC计数器的值可以作为返回地址，栈帧中很可能会保存这个计数器值。而方法异常退出时，返回地址是要通过异常处理器表来确定的，栈帧中一般不会保存这部分信息。</p><p>&emsp;&emsp;方法退出的过程实际上就等同于把当前栈帧出栈，因此退出时可能执行的操作有：恢复上层方法的局部变量表和操作数栈，把返回值（如果有的话）压入调用者栈帧的操作数栈中，调整PC计数器的值以指向方法调用指令后面的一条指令等。</p><h3 id="2-5-附加信息"><a href="#2-5-附加信息" class="headerlink" title="2.5 附加信息"></a><strong>2.5 附加信息</strong></h3><p>&emsp;&emsp;虚拟机规范允许具体的虚拟机实现增加一些规范里没有描述的信息到栈帧之中，例如与调试相关的信息，这部分信息完全取决于具体的虚拟机实现，这里不再详述。在实际开发中，一般会把动态连接、方法返回地址与其他附加信息全部归为一类，称为栈帧信息。</p><hr><p><em>参考博客和文章书籍等：</em></p><blockquote><p>《深入理解Java虚拟机》</p></blockquote><p><em>因博客主等未标明不可引用，若部分内容涉及侵权请及时告知，我会尽快修改和删除相关内容</em></p>]]></content>
    
    <summary type="html">
    
      简单介绍Java虚拟机中的字节码执行引擎-运行时栈帧结构，包括：局部变量表，操作数栈，动态连接，方法返回地址，附加信息等内容。
    
    </summary>
    
      <category term="技术文档" scheme="http://linyishui.top/categories/%E6%8A%80%E6%9C%AF%E6%96%87%E6%A1%A3/"/>
    
    
      <category term="java" scheme="http://linyishui.top/tags/java/"/>
    
      <category term="jvm" scheme="http://linyishui.top/tags/jvm/"/>
    
  </entry>
  
  <entry>
    <title>字节码执行引擎</title>
    <link href="http://linyishui.top/2019121001.html"/>
    <id>http://linyishui.top/2019121001.html</id>
    <published>2019-12-10T10:28:14.000Z</published>
    <updated>2020-01-10T03:11:59.129Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="虚拟机字节码执行引擎"><a href="#虚拟机字节码执行引擎" class="headerlink" title="虚拟机字节码执行引擎 "></a><strong>虚拟机字节码执行引擎 </strong></h1><h2 id="第一节-概述"><a href="#第一节-概述" class="headerlink" title="第一节 概述"></a><strong>第一节 概述</strong></h2><p>&emsp;&emsp;代码编译的结果从本地机器码转变为字节码，是存储格式发展的一小步，却是编程语言发展的一大步。</p><p>&emsp;&emsp;执行引擎是Java虚拟机最核心的组成部分之一。“虚拟机”是一个相对于“物理机”的概念，这两种机器都有代码执行能力，其区别是物理机的执行引擎是直接建立在处理器、硬件、指令集和操作系统层面上的，而虚拟机的执行引擎则是由自己实现的，因此可以自行制定指令集与执行引擎的结构体系，并且能够执行那些不被硬件直接支持的指令集格式。</p><p>&emsp;&emsp;在Java虚拟机规范中制定了虚拟机字节码执行引擎的概念模型，这个概念模型成为各种虚拟机执行引擎的统一外观（Facade）。在不同的虚拟机实现里面，执行引擎在执行Java代码的时候可能会有解释执行（通过解释器执行）和编译执行（通过即时编译器产生本地代码执行）两种选择[1]，也可能两者兼备，甚至还可能会包含几个不同级别的编译器执行引擎。但从外观上看起来，所有的Java虚拟机的执行引擎都是一致的：输入的是字节码文件，处理过程是字节码解析的等效过程，输出的是执行结果，本章将主要从概念模型的角度来讲解虚拟机的方法调用和字节码执行。</p><hr><h2 id="第二节-运行时栈帧结构"><a href="#第二节-运行时栈帧结构" class="headerlink" title="第二节 运行时栈帧结构"></a><strong>第二节 运行时栈帧结构</strong></h2><p>&emsp;&emsp;<a href="../2019121101.html" title="Title">字节码执行引擎-运行时栈帧结构</a></p><hr><h2 id="第三节-方法调用"><a href="#第三节-方法调用" class="headerlink" title="第三节 方法调用"></a><strong>第三节 方法调用</strong></h2><p>&emsp;&emsp;<a href="../2019121201.html" title="Title">字节码执行引擎-方法调用</a></p><hr><h2 id="第四节-基于栈的字节码解释执行引擎"><a href="#第四节-基于栈的字节码解释执行引擎" class="headerlink" title="第四节 基于栈的字节码解释执行引擎"></a><strong>第四节 基于栈的字节码解释执行引擎</strong></h2><p>&emsp;&emsp;虚拟机是如何调用方法的内容已经讲解完毕，从本节开始，我们来探讨虚拟机是如何执行方法中的字节码指令的。上文中提到过，许多Java虚拟机的执行引擎在执行Java代码的时候都有解释执行（通过解释器执行）和编译执行（通过即时编译器产生本地代码执行）两种选择，在本章中，我们先来探讨一下在解释执行时，虚拟机执行引擎是如何工作的。</p><h3 id="4-1-解释执行"><a href="#4-1-解释执行" class="headerlink" title="4.1 解释执行"></a><strong>4.1 解释执行</strong></h3><p>&emsp;&emsp;Java语言经常被人们定位为“解释执行”的语言，在Java初生的JDK 1.0时代，这种定义还算是比较准确的，但当主流的虚拟机中都包含了即时编译器后，Class文件中的代码到底会被解释执行还是编译执行，就成了只有虚拟机自己才能准确判断的事情。再后来，Java也发展出了可以直接生成本地代码的编译器[如GCJ[1]（GNU Compiler for the Java）]，而C/C++语言也出现了通过解释器执行的版本（如CINT[2]），这时候再笼统地说“解释执行”，对于整个Java语言来说就成了几乎是没有意义的概念，只有确定了谈论对象是某种具体的Java实现版本和执行引擎运行模式时，谈解释执行还是编译执行才会比较确切。</p><p>&emsp;&emsp;不论是解释还是编译，也不论是物理机还是虚拟机，对于应用程序，机器都不可能如人那样阅读、理解，然后就获得了执行能力。大部分的程序代码到物理机的目标代码或虚拟机能执行的指令集之前，都需要经过图8-4中的各个步骤。如果读者对编译原理的相关课程还有印象的话，很容易就会发现图8-4中下面那条分支，就是传统编译原理中程序代码到目标机器代码的生成过程，而中间的那条分支，自然就是解释执行的过程。</p><p>&emsp;&emsp;如今，基于物理机、Java虚拟机，或者非Java的其他高级语言虚拟机（HLLVM）的语言，大多都会遵循这种基于现代经典编译原理的思路，在执行前先对程序源码进行词法分析和语法分析处理，把源码转化为抽象语法树（Abstract Syntax Tree,AST）。对于一门具体语言的实现来说，词法分析、语法分析以至后面的优化器和目标代码生成器都可以选择独立于执行引擎，形成一个完整意义的编译器去实现，这类代表是C/C++语言。也可以选择把其中一部分步骤（如生成抽象语法树之前的步骤）实现为一个半独立的编译器，这类代表是Java语言。又或者把这些步骤和执行引擎全部集中封装在一个封闭的黑匣子之中，如大多数的JavaScript执行器。</p><p><img src="https://pic-1258215793.cos.ap-shanghai.myqcloud.com/content/20191201/201912010164.png" alt="编译过程"></p><p>&emsp;&emsp;Java语言中，Javac编译器完成了程序代码经过词法分析、语法分析到抽象语法树，再遍历语法树生成线性的字节码指令流的过程。因为这一部分动作是在Java虚拟机之外进行的，而解释器在虚拟机的内部，所以Java程序的编译就是半独立的实现。</p><h3 id="4-2-基于栈的指令集与基于寄存器的指令集"><a href="#4-2-基于栈的指令集与基于寄存器的指令集" class="headerlink" title="4.2 基于栈的指令集与基于寄存器的指令集"></a><strong>4.2 基于栈的指令集与基于寄存器的指令集</strong></h3><p>&emsp;&emsp;Java编译器输出的指令流，基本上[1]是一种基于栈的指令集架构（Instruction Set Architecture,ISA），指令流中的指令大部分都是零地址指令，它们依赖操作数栈进行工作。与之相对的另外一套常用的指令集架构是基于寄存器的指令集，最典型的就是x86的二地址指令集，说得通俗一些，就是现在我们主流PC机中直接支持的指令集架构，这些指令依赖寄存器进行工作。那么，基于栈的指令集与基于寄存器的指令集这两者之间有什么不同呢？</p><p>&emsp;&emsp;举个最简单的例子，分别使用这两种指令集计算“1+1”的结果，基于栈的指令集会是这样子的：</p><figure class="highlight gcode"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">ico<span class="symbol">nst_1</span> </span><br><span class="line">ico<span class="symbol">nst_1</span> </span><br><span class="line">iadd </span><br><span class="line">istore_<span class="number">0</span></span><br></pre></td></tr></table></figure><p>&emsp;&emsp;两条iconst_1指令连续把两个常量1压入栈后，iadd指令把栈顶的两个值出栈、相加，然后把结果放回栈顶，最后istore_0把栈顶的值放到局部变量表的第0个Slot中。</p><p>&emsp;&emsp;如果基于寄存器，那程序可能会是这个样子：</p><figure class="highlight x86asm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">mov</span> <span class="built_in">eax</span>, <span class="number">1</span> </span><br><span class="line"><span class="keyword">add</span> <span class="built_in">eax</span>，<span class="number">1</span></span><br></pre></td></tr></table></figure><p>&emsp;&emsp;mov指令把EAX寄存器的值设为1，然后add指令再把这个值加1，结果就保存在EAX寄存器里面。</p><p>&emsp;&emsp;了解了基于栈的指令集与基于寄存器的指令集的区别后，读者可能会有进一步的疑问，这两套指令集谁更好一些呢？</p><p>&emsp;&emsp;应该这么说，既然两套指令集会同时并存和发展，那肯定是各有优势的，如果有一套指令集全面优于另外一套的话，就不会存在选择的问题了。</p><p>&emsp;&emsp;基于栈的指令集主要的优点就是可移植，寄存器由硬件直接提供[2]，程序直接依赖这些硬件寄存器则不可避免地要受到硬件的约束。例如，现在32位80x86体系的处理器中提供了8个32位的寄存器，而ARM体系的CPU（在当前的手机、PDA中相当流行的一种处理器）则提供了16个32位的通用寄存器。如果使用栈架构的指令集，用户程序不会直接使用这些寄存器，就可以由虚拟机实现来自行决定把一些访问最频繁的数据（程序计数器、栈顶缓存等）放到寄存器中以获取尽量好的性能，这样实现起来也更加简单一些。栈架构的指令集还有一些其他的优点，如代码相对更加紧凑（字节码中每个字节就对应一条指令，而多地址指令集中还需要存放参数）、编译器实现更加简单（不需要考虑空间分配的问题，所需空间都在栈上操作）等。</p><p>&emsp;&emsp;栈架构指令集的主要缺点是执行速度相对来说会稍慢一些。所有主流物理机的指令集都是寄存器架构也从侧面印证了这一点。</p><p>&emsp;&emsp;虽然栈架构指令集的代码非常紧凑，但是完成相同功能所需的指令数量一般会比寄存器架构多，因为出栈、入栈操作本身就产生了相当多的指令数量。更重要的是，栈实现在内存之中，频繁的栈访问也就意味着频繁的内存访问，相对于处理器来说，内存始终是执行速度的瓶颈。尽管虚拟机可以采取栈顶缓存的手段，把最常用的操作映射到寄存器中避免直接内存访问，但这也只能是优化措施而不是解决本质问题的方法。由于指令数量和内存访问的原因，所以导致了栈架构指令集的执行速度会相对较慢。</p><h3 id="4-3-基于栈的解释器执行过程"><a href="#4-3-基于栈的解释器执行过程" class="headerlink" title="4.3 基于栈的解释器执行过程"></a><strong>4.3 基于栈的解释器执行过程</strong></h3><p>&emsp;&emsp;初步的理论知识已经讲解过了，本节准备了一段Java代码，看看在虚拟机中实际是如何执行的。前面曾经举过一个计算“1+1”的例子，这样的算术题目显然太过简单了，作者准备了四则运算的例子，请看代码清单8-16。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//代码清单8-16　一段简单的算术代码</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">calc</span><span class="params">()</span></span>&#123; </span><br><span class="line">    <span class="keyword">int</span> a = <span class="number">100</span>; </span><br><span class="line">    <span class="keyword">int</span> b = <span class="number">200</span>; </span><br><span class="line">    <span class="keyword">int</span> c = <span class="number">300</span>; </span><br><span class="line">    <span class="keyword">return</span> (a + b) * c; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>&emsp;&emsp;从Java语言的角度来看，这段代码没有任何解释的必要，可以直接使用javap命令看看它的字节码指令，如代码清单8-17所示。</p><figure class="highlight lsl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//代码清单8-17　一段简单的算术代码的字节码表示</span></span><br><span class="line">public int calc(); </span><br><span class="line">    Code： </span><br><span class="line">        Stack = <span class="number">2</span>，Locals = <span class="number">4</span>，Args_size = <span class="number">1</span> </span><br><span class="line">        <span class="number">0</span>：bipush <span class="number">100</span> </span><br><span class="line">        <span class="number">2</span>：istore_1 </span><br><span class="line">        <span class="number">3</span>：sipush <span class="number">200</span> </span><br><span class="line">        <span class="number">6</span>：istore_2 </span><br><span class="line">        <span class="number">7</span>：sipush <span class="number">300</span> </span><br><span class="line">        <span class="number">10</span>：istore_3 </span><br><span class="line">        <span class="number">11</span>：iload_1 </span><br><span class="line">        <span class="number">12</span>：iload_2 </span><br><span class="line">        <span class="number">13</span>：iadd </span><br><span class="line">        <span class="number">14</span>：iload_3 </span><br><span class="line">        <span class="number">15</span>：imul </span><br><span class="line">        <span class="number">16</span>：ireturn </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>&emsp;&emsp;javap提示这段代码需要深度为2的操作数栈和4个Slot的局部变量空间，作者根据这些信息画了图8-5～图8-11共7张图，用它们来描述代码清单8-17执行过程中的代码、操作数栈和局部变量表的变化情况。</p><p><img src="https://pic-1258215793.cos.ap-shanghai.myqcloud.com/content/20191201/201912010165.png" alt="执行偏移地址为0的指令的情况"></p><p><img src="https://pic-1258215793.cos.ap-shanghai.myqcloud.com/content/20191201/201912010166.png" alt="执行偏移地址为1的指令的情况"></p><p><img src="https://pic-1258215793.cos.ap-shanghai.myqcloud.com/content/20191201/201912010167.png" alt="执行偏移地址为11的指令的情况"></p><p><img src="https://pic-1258215793.cos.ap-shanghai.myqcloud.com/content/20191201/201912010168.png" alt="执行偏移地址为12的指令的情况"></p><p><img src="https://pic-1258215793.cos.ap-shanghai.myqcloud.com/content/20191201/201912010169.png" alt="执行偏移地址为13的指令的情况"></p><p><img src="https://pic-1258215793.cos.ap-shanghai.myqcloud.com/content/20191201/201912010170.png" alt="执行偏移地址为14的指令的情况"></p><p><img src="https://pic-1258215793.cos.ap-shanghai.myqcloud.com/content/20191201/201912010171.png" alt="执行偏移地址为16的指令的情况"></p><p>&emsp;&emsp;上面的执行过程仅仅是一种概念模型，虚拟机最终会对执行过程做一些优化来提高性能，实际的运作过程不一定完全符合概念模型的描述……更准确地说，实际情况会和上面描述的概念模型差距非常大，这种差距产生的原因是虚拟机中解析器和即时编译器都会对输入的字节码进行优化，例如，在HotSpot虚拟机中，有很多以“fast_”开头的非标准字节码指令用于合并、替换输入的字节码以提升解释执行性能，而即时编译器的优化手段更加花样繁多[1]。</p><p>&emsp;&emsp;不过，我们从这段程序的执行中也可以看出栈结构指令集的一般运行过程，整个运算过程的中间变量都以操作数栈的出栈、入栈为信息交换途径，符合我们在前面分析的特点。</p><hr><h2 id="第五节-总结"><a href="#第五节-总结" class="headerlink" title="第五节 总结"></a><strong>第五节 总结</strong></h2><p>&emsp;&emsp;本章中，我们分析了虚拟机在执行代码时，如何找到正确的方法、如何执行方法内的字节码，以及执行代码时涉及的内存结构。在第6、7、8三章中，我们针对Java程序是如何存储的、如何载入（创建）的，以及如何执行的问题把相关知识进行了讲解，第9章我们将一起看看这些理论知识在具体开发之中的经典应用。</p><hr><p><em>参考博客和文章书籍等：</em></p><blockquote><p>《深入理解Java虚拟机》</p></blockquote><p><em>因博客主等未标明不可引用，若部分内容涉及侵权请及时告知，我会尽快修改和删除相关内容</em></p>]]></content>
    
    <summary type="html">
    
      简单介绍Java虚拟机中的字节码执行引擎，包括：概述，运行时栈帧结构，方法调用，基于栈的字节码解释执行引擎（解释执行、基于栈的指令集与基于寄存器的指令集、基于栈的解释器执行过程），总结等内容。
    
    </summary>
    
      <category term="技术文档" scheme="http://linyishui.top/categories/%E6%8A%80%E6%9C%AF%E6%96%87%E6%A1%A3/"/>
    
    
      <category term="java" scheme="http://linyishui.top/tags/java/"/>
    
      <category term="jvm" scheme="http://linyishui.top/tags/jvm/"/>
    
  </entry>
  
  <entry>
    <title>虚拟机类加载机制-类加载过程</title>
    <link href="http://linyishui.top/2019120801.html"/>
    <id>http://linyishui.top/2019120801.html</id>
    <published>2019-12-08T10:06:32.000Z</published>
    <updated>2020-01-10T03:11:38.330Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="虚拟机类加载机制-类加载过程"><a href="#虚拟机类加载机制-类加载过程" class="headerlink" title="虚拟机类加载机制-类加载过程"></a><strong>虚拟机类加载机制-类加载过程</strong></h1><h2 id="第三节-类加载的过程"><a href="#第三节-类加载的过程" class="headerlink" title="第三节 类加载的过程"></a><strong>第三节 类加载的过程</strong></h2><p>&emsp;&emsp;接下来我们详细讲解一下Java虚拟机中类加载的全过程，也就是加载、验证、准备、解析和初始化这5个阶段所执行的具体动作。 </p><h3 id="3-1-加载"><a href="#3-1-加载" class="headerlink" title="3.1 加载"></a><strong>3.1 加载</strong></h3><p>&emsp;&emsp;<strong>加载</strong>是<strong>类加载</strong>（Class Loading）过程的一个阶段，希望读者没有混淆这两个看起来很相似的名词。在加载阶段，虚拟机需要完成以下3件事情： </p><blockquote><ol><li>通过一个类的全限定名来<strong>获取</strong>定义此类的<strong>二进制字节流</strong>。 </li><li>将这个字节流所代表的<strong>静态存储结构</strong>转化为方法区的<strong>运行时数据结构</strong>。</li><li>在内存中<strong>生成</strong>一个代表这个类的<strong>java.lang.Class对象</strong>，作为方法区这个类的各种数据的访问入口。 </li></ol></blockquote><p>&emsp;&emsp;虚拟机规范的这3点要求其实并不算具体，因此虚拟机实现与具体应用的灵活度都是相当大的。例如“通过一个类的全限定名来获取定义此类的二进制字节流”这条，它没有指明二进制字节流要从一个Class文件中获取，准确地说是根本没有指明要从哪里获取、怎样获取。虚拟机设计团队在加载阶段搭建了一个相当开放的、广阔的“舞台”，Java发展历程中，充满创造力的开发人员则在这个“舞台”上玩出了各种花样，许多举足轻重的Java技术都建立在这一基础之上，例如：</p><blockquote><ul><li><strong>从ZIP包中读取</strong>，这很常见，最终成为日后JAR、EAR、WAR格式的基础。</li><li><strong>从网络中获取</strong>，这种场景最典型的应用就是Applet。 </li><li><strong>运行时计算生成</strong>，这种场景使用得最多的就是动态代理技术，在java.lang.reflect.Proxy中，就是用了ProxyGenerator.generateProxyClass来为特定接口生成形式为“*$Proxy”的代理类的二进制字节流。 </li><li><strong>由其他文件生成</strong>，典型场景是JSP应用，即由JSP文件生成对应的Class类。 </li><li><strong>从数据库中读取</strong>，这种场景相对少见些，例如有些中间件服务器（如SAP Netweaver）可以选择把程序安装到数据库中来完成程序代码在集群间的分发。</li><li>……</li></ul></blockquote><p>&emsp;&emsp;相对于类加载过程的其他阶段，一个非数组类的加载阶段（准确地说，是加载阶段中<strong>获取类的二进制字节流的动作</strong>）是开发人员可控性最强的，因为加载阶段既可以使用系统提供的引导类加载器来完成，也可以由用户自定义的类加载器去完成，开发人员可以通过定义自己的类加载器去控制字节流的获取方式（即重写一个类加载器的loadClass()方法）。 </p><p>&emsp;&emsp;对于数组类而言，情况就有所不同，<strong>数组类本身不通过类加载器创建</strong>，它是<strong>由Java虚拟机直接创建</strong>的。但数组类与类加载器仍然有很密切的关系，因为数组类的元素类型（ElementType，指的是数组去掉所有维度的类型）最终是要靠类加载器去创建，一个数组类（下面简称为C）创建过程就遵循以下规则：</p><blockquote><ul><li>如果数组的组件类型（Component Type，指的是数组去掉一个维度的类型）是引用类型，那就递归采用本节中定义的加载过程去加载这个组件类型，数组C将在加载该组件类型的类加载器的类名称空间上被标识（这点很重要，在第四节会介绍到，<strong>一个类必须与类加载器一起确定唯一性</strong>）。 </li><li>如果数组的组件类型不是引用类型（例如int[]数组），Java虚拟机将会把数组C标记为与引导类加载器关联。 </li><li>数组类的可见性与它的组件类型的可见性一致，如果组件类型不是引用类型，那数组类的可见性将默认为public。 </li></ul></blockquote><p>&emsp;&emsp;加载阶段完成后，虚拟机外部的二进制字节流就按照虚拟机所需的格式存储在方法区之中，方法区中的数据存储格式由虚拟机实现自行定义，虚拟机规范未规定此区域的具体数据结构。然后在内存中实例化一个java.lang.Class类的对象（并没有明确规定是在Java堆中，对于HotSpot虚拟机而言，<strong>Class对象比较特殊，它虽然是对象，但是存放在方法区里面</strong>），这个对象将<strong>作为程序访问方法区中的这些类型数据的外部接口</strong>。 </p><p>&emsp;&emsp;加载阶段与连接阶段的部分内容（如一部分字节码文件格式验证动作）是交叉进行的，加载阶段尚未完成，连接阶段可能已经开始，但这些夹在加载阶段之中进行的动作，仍然属于连接阶段的内容，这两个阶段的开始时间仍然保持着固定的先后顺序。</p><h3 id="3-2-验证"><a href="#3-2-验证" class="headerlink" title="3.2 验证"></a><strong>3.2 验证</strong></h3><p>&emsp;&emsp;验证是连接阶段的第一步，这一阶段的目的是为了<strong>确保Class文件的字节流中包含的信息符合当前虚拟机的要求，并且不会危害虚拟机自身的安全</strong>。 </p><p>&emsp;&emsp;Java语言本身是相对安全的语言（依然是相对于C/C++来说），使用纯粹的Java代码无法做到诸如访问数组边界以外的数据、将一个对象转型为它并未实现的类型、跳转到不存在的代码行之类的事情，如果这样做了，编译器将拒绝编译。但前面已经说过，Class文件并不一定要求用Java源码编译而来，可以使用任何途径产生，甚至包括用十六进制编辑器直接编写来产生Class文件。在字节码语言层面上，上述Java代码无法做到的事情都是可以实现的，至少语义上是可以表达出来的。虚拟机如果不检查输入的字节流，对其完全信任的话，很可能会因为载入了有害的字节流而导致系统崩溃，所以验证是虚拟机对自身保护的一项重要工作。 </p><p>&emsp;&emsp;验证阶段是非常重要的，这个阶段是否严谨，直接决定了Java虚拟机是否能承受恶意代码的攻击，从执行性能的角度上讲，验证阶段的工作量在虚拟机的类加载子系统中又占了相当大的一部分。《Java虚拟机规范（第2版）》对这个阶段的限制、指导还是比较笼统的，规范中列举了一些Class文件格式中的静态和结构化约束，如果验证到输入的字节流不符合Class文件格式的约束，虚拟机就应抛出一个java.lang.VerifyError异常或其子类异常，但具体应当检查哪些方面，如何检查，何时检查，都没有足够具体的要求和明确的说明。直到2011年发布的《Java虚拟机规范（Java SE 7版）》，大幅增加了描述验证过程的篇幅（从不到10页增加到130页），这时约束和验证规则才变得具体起来。受篇幅所限无法逐条规则去讲解，但从整体上看，验证阶段大致上会完成下面4个阶段的检验动作：文件格式验证、元数据验证、字节码验证、符号引用验证。 </p><h4 id="3-2-1-文件格式验证"><a href="#3-2-1-文件格式验证" class="headerlink" title="3.2.1 文件格式验证"></a><strong>3.2.1 文件格式验证</strong></h4><p>&emsp;&emsp;第一阶段要<strong>验证字节流是否符合Class文件格式的规范，并且能被当前版本的虚拟机处理</strong>。这一阶段可能包括下面这些验证点： </p><blockquote><ul><li>是否以魔数0xCAFEBABE开头。 </li><li>主、次版本号是否在当前虚拟机处理范围之内。 </li><li>常量池的常量中是否有不被支持的常量类型（检查常量tag标志）。 </li><li>指向常量的各种索引值中是否有指向不存在的常量或不符合类型的常量。 </li><li>CONSTANT_Utf8_info型的常量中是否有不符合UTF8编码的数据。</li><li>Class文件中各个部分及文件本身是否有被删除的或附加的其他信息。 </li><li>……</li></ul></blockquote><p>&emsp;&emsp;实际上，第一阶段的验证点还远不止这些，上面这些只是从HotSpot虚拟机源码中摘抄的一小部分内容，该验证阶段的主要目的是<strong>保证输入的字节流能正确地解析并存储于方法区之内，格式上符合描述一个Java类型信息的要求</strong>。这阶段的验证是基于二进制字节流进行的，只有通过了这个阶段的验证后，字节流才会进入内存的方法区中进行存储，所以<strong>后面的3个验证阶段全部是基于方法区的存储结构进行的，不会再直接操作字节流</strong>。</p><h4 id="3-2-2-元数据验证"><a href="#3-2-2-元数据验证" class="headerlink" title="3.2.2 元数据验证"></a><strong>3.2.2 元数据验证</strong></h4><p>&emsp;&emsp;第二阶段是<strong>对字节码描述的信息进行语义分析，以保证其描述的信息符合Java语言规范的要求</strong>，这个阶段可能包括的验证点如下：</p><blockquote><ul><li>这个类是否有父类（除了java.lang.Object之外，所有的类都应当有父类）。 </li><li>这个类的父类是否继承了不允许被继承的类（被final修饰的类）。 </li><li>如果这个类不是抽象类，是否实现了其父类或接口之中要求实现的所有方法。 </li><li>类中的字段、方法是否与父类产生矛盾（例如覆盖了父类的final字段，或者出现不符合规则的方法重载，例如方法参数都一致，但返回值类型却不同等）。 </li><li>……</li></ul></blockquote><p>&emsp;&emsp;第二阶段的主要目的是<strong>对类的元数据信息进行语义校验，保证不存在不符合Java语言规范的元数据信息</strong>。 </p><h4 id="3-2-3-字节码验证"><a href="#3-2-3-字节码验证" class="headerlink" title="3.2.3 字节码验证"></a><strong>3.2.3 字节码验证</strong></h4><p>&emsp;&emsp;第三阶段是整个验证过程中最复杂的一个阶段，主要目的是<strong>通过数据流和控制流分析，确定程序语义是合法的、符合逻辑的</strong>。在第二阶段对元数据信息中的数据类型做完校验后，这个阶段将对类的方法体进行校验分析，保证被校验类的方法在运行时不会做出危害虚拟机安全的事件，例如： </p><blockquote><ul><li>保证任意时刻操作数栈的数据类型与指令代码序列都能配合工作，例如不会出现类似这样的情况：在操作栈放置了一个int类型的数据，使用时却按long类型来加载入本地变量表中。 </li><li>保证跳转指令不会跳转到方法体以外的字节码指令上。 </li><li>保证方法体中的类型转换是有效的，例如可以把一个子类对象赋值给父类数据类型，这是安全的，但是把父类对象赋值给子类数据类型，甚至把对象赋值给与它毫无继承关系、完全不相干的一个数据类型，则是危险和不合法的。 </li><li>……</li></ul></blockquote><p>&emsp;&emsp;如果一个类方法体的字节码没有通过字节码验证，那肯定是有问题的；但如果一个方法体通过了字节码验证，也不能说明其一定就是安全的。即使字节码验证之中进行了大量的检查，也不能保证这一点。这里涉及了离散数学中一个很著名的问题“Halting Problem”：通俗一点的说法就是，通过程序去校验程序逻辑是无法做到绝对准确的——不能通过程序准确地检查出程序是否能在有限的时间之内结束运行。</p><p>&emsp;&emsp;由于数据流验证的高复杂性，虚拟机设计团队为了避免过多的时间消耗在字节码验证阶段，在JDK 1.6之后的Javac编译器和Java虚拟机中进行了一项优化，给方法体的Code属性的属性表中增加了一项名为“StackMapTable”的属性，这项属性描述了方法体中所有的基本块（Basic Block，按照控制流拆分的代码块）开始时本地变量表和操作栈应有的状态，在字节码验证期间，就不需要根据程序推导这些状态的合法性，只需要检查StackMapTable属性中的记录是否合法即可。这样<strong>将字节码验证的类型推导转变为类型检查从而节省一些时间</strong>。 </p><p>&emsp;&emsp;理论上StackMapTable属性也存在错误或被篡改的可能，所以是否有可能在恶意篡改了Code属性的同时，也生成相应的StackMapTable属性来骗过虚拟机的类型校验则是虚拟机设计者值得思考的问题。 </p><p>&emsp;&emsp;在JDK 1.6的HotSpot虚拟机中提供了-XX:-UseSplitVerifier选项来关闭这项优化，或者使用参数-XX:+FailOverToOldVerifier要求在类型校验失败的时候退回到旧的类型推导方式进行校验。而在JDK 1.7之后，对于主版本号大于50的Class文件，<strong>使用类型检查来完成数据流分析校验则是唯一的选择，不允许再退回到类型推导的校验方式</strong>。 </p><h4 id="3-2-4-符号引用验证"><a href="#3-2-4-符号引用验证" class="headerlink" title="3.2.4 符号引用验证"></a><strong>3.2.4 符号引用验证</strong></h4><p>&emsp;&emsp;最后一个阶段的校验发生<strong>在虚拟机将符号引用转化为直接引用的时候</strong>，这个转化动作将在连接的第三阶段——<strong>解析阶段</strong>中发生。符号引用验证可以看做是对类自身以外（常量池中的各种符号引用）的信息进行匹配性校验，通常需要校验下列内容： </p><blockquote><ul><li>符号引用中通过字符串描述的全限定名是否能找到对应的类。 </li><li>在指定类中是否存在符合方法的字段描述符以及简单名称所描述的方法和字段。 </li><li>符号引用中的类、字段、方法的访问性（private、protected、public、default）是否可被当前类访问。 </li><li>……</li></ul></blockquote><p>&emsp;&emsp;符号引用验证的目的是确保解析动作能正常执行，如果无法通过符号引用验证，那么将会抛出一个java.lang.IncompatibleClassChangeError异常的子类，如java.lang.IllegalAccessError、java.lang.NoSuchFieldError、java.lang.NoSuchMethodError等。 </p><p>&emsp;&emsp;对于虚拟机的类加载机制来说，验证阶段是一个非常重要的、但<strong>不是一定必要</strong>（因为对程序运行期没有影响）的阶段。如果所运行的全部代码（包括自己编写的及第三方包中的代码）都已经被反复使用和验证过，那么<strong>在实施阶段就可以考虑使用-Xverify:none参数来关闭大部分的类验证措施，以缩短虚拟机类加载的时间</strong>。</p><h3 id="3-3-准备"><a href="#3-3-准备" class="headerlink" title="3.3 准备"></a><strong>3.3 准备</strong></h3><p>&emsp;&emsp;准备阶段是<strong>正式为类变量分配内存并设置类变量初始值的阶段</strong>，这些<strong>变量所使用的内存都将在方法区中进行分配</strong>。这个阶段中有两个容易产生混淆的概念需要强调一下，首先，这时候进行内存分配的<strong>仅包括类变量</strong>（被static修饰的变量），而不包括实例变量，<strong>实例变量将会在对象实例化时随着对象一起分配在Java堆中</strong>。其次，这里所说的初始值“通常情况”下是<strong>数据类型的零值</strong>，假设一个类变量的定义为：</p><figure class="highlight cs"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="keyword">value</span> = <span class="number">123</span>;</span><br></pre></td></tr></table></figure><p>&emsp;&emsp;那变量value在准备阶段过后的初始值为0而不是123，因为这时候尚未开始执行任何Java方法，而把value赋值为123的putstatic指令是程序被编译后，存放于类构造器＜clinit＞()方法之中，所以把value赋值为123的动作将在初始化阶段才会执行。表7-1列出了Java中所有基本数据类型的零值。</p><p><img src="https://pic-1258215793.cos.ap-shanghai.myqcloud.com/content/20191201/1111111111.png" alt="基本数据类型的零值"></p><p>&emsp;&emsp;上面提到，在“通常情况”下初始值是零值，那相对的会有一些“特殊情况”：如果类字段的字段属性表中存在ConstantValue属性，那在准备阶段变量value就会被初始化为ConstantValue属性所指定的值，假设上面类变量value的定义变为：</p><figure class="highlight aspectj"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> value = <span class="number">123</span>;</span><br></pre></td></tr></table></figure><p>&emsp;&emsp;编译时Javac将会为value生成ConstantValue属性，在准备阶段虚拟机就会根据ConstantValue的设置将value赋值为123。</p><h3 id="3-4-解析"><a href="#3-4-解析" class="headerlink" title="3.4 解析"></a><strong>3.4 解析</strong></h3><p>&emsp;&emsp;解析阶段是虚拟机<strong>将常量池内的符号引用替换为直接引用的过程</strong>，符号引用在前一章讲解Class文件格式的时候已经出现过多次，在Class文件中它以CONSTANT_Class_info、CONSTANT_Fieldref_info、CONSTANT_Methodref_info等类型的常量出现，那解析阶段中所说的直接引用与符号引用又有什么关联呢？ </p><p>&emsp;&emsp;符号引用（Symbolic References）：<strong>符号引用以一组符号来描述所引用的目标，符号可以是任何形式的字面量，只要使用时能无歧义地定位到目标即可</strong>。符号引用与虚拟机实现的内存布局无关，引用的目标并不一定已经加载到内存中。各种虚拟机实现的内存布局可以各不相同，但是它们能接受的符号引用必须都是一致的，因为符号引用的字面量形式明确定义在Java虚拟机规范的Class文件格式中。 </p><p>&emsp;&emsp;直接引用（Direct References）：<strong>直接引用可以是直接指向目标的指针、相对偏移量或是一个能间接定位到目标的句柄</strong>。直接引用是和虚拟机实现的内存布局相关的，同一个符号引用在不同虚拟机实例上翻译出来的直接引用一般不会相同。如果有了直接引用，那引用的目标必定已经在内存中存在。 </p><p>&emsp;&emsp;虚拟机规范之中并未规定解析阶段发生的具体时间，只要求了在执行anewarray、checkcast、getfield、getstatic、instanceof、invokedynamic、invokeinterface、invokespecial、 invokestatic、invokevirtual、ldc、ldc_w、multianewarray、new、putfield和putstatic这16个<strong>用于操作符号引用的字节码指令之前，先对它们所使用的符号引用进行解析</strong>。所以虚拟机实现可以根据需要来判断到底是在类被加载器加载时就对常量池中的符号引用进行解析，还是等到一个符号引用将要被使用前才去解析它。 </p><p>&emsp;&emsp;对同一个符号引用进行多次解析请求是很常见的事情，除invokedynamic指令以外，虚拟机实现可以对第一次解析的结果进行缓存（在运行时常量池中记录直接引用，并把常量标识为已解析状态）从而避免解析动作重复进行。无论是否真正执行了多次解析动作，虚拟机<strong>需要保证的是在同一个实体中，如果一个符号引用之前已经被成功解析过，那么后续的引用解析请求就应当一直成功</strong>；同样的，如果第一次解析失败了，那么其他指令对这个符号的解析请求也应该收到相同的异常。 </p><p>&emsp;&emsp;对于<strong>invokedynamic指令</strong>，上面规则则不成立。当碰到某个前面已经由invokedynamic指令触发过解析的符号引用时，并不意味着这个解析结果对于其他invokedynamic指令也同样生效。因为invokedynamic指令的目的本来就是用于动态语言支持（目前仅使用Java语言不会生成这条字节码指令），它所对应的引用称为“动态调用点限定符”（Dynamic Call Site Specifier），这里“动态”的含义就是<strong>必须等到程序实际运行到这条指令的时候，解析动作才能进行</strong>。相对的，其余可触发解析的指令都是“静态”的，可以在刚刚完成加载阶段，还没有开始执行代码时就进行解析。 </p><p>&emsp;&emsp;解析动作主要针对类或接口、字段、类方法、接口方法、方法类型、方法句柄和调用点限定符7类符号引用进行，分别对应于常量池的CONSTANT_Class_info、CONSTANT_Fieldref_info、CONSTANT_Methodref_info、CONSTANT_InterfaceMethodref_info、CONSTANT_MethodType_info、 CONSTANT_MethodHandle_info和CONSTANT_InvokeDynamic_info 7种常量类型。下面将讲解前面4种引用的解析过程，对于后面3种，与JDK 1.7新增的动态语言支持息息相关，由于Java语言是一门静态类型语言，因此在没有介绍invokedynamic指令的语义之前，没有办法将它们和现在的Java语言对应上，作者将在<a href="../2019121001.html" title="Title">字节码执行引擎</a>介绍动态语言调用时一起分析讲解。 </p><h4 id="3-4-1-类或接口的解析"><a href="#3-4-1-类或接口的解析" class="headerlink" title="3.4.1 类或接口的解析"></a><strong>3.4.1 类或接口的解析</strong></h4><p>&emsp;&emsp;假设当前代码所处的类为D，如果要把一个从未解析过的符号引用N解析为一个类或接口C的直接引用，那虚拟机完成整个解析的过程需要以下3个步骤： </p><blockquote><ol><li>如果C不是一个数组类型，那虚拟机将会把代表N的全限定名传递给D的类加载器去加载这个类C。在加载过程中，由于元数据验证、字节码验证的需要，又可能触发其他相关 类的加载动作，例如加载这个类的父类或实现的接口。一旦这个加载过程出现了任何异常，解析过程就宣告失败。 </li><li>如果C是一个数组类型，并且数组的元素类型为对象，也就是N的描述符会是类似“[Ljava/lang/Integer”的形式，那将会按照第1点的规则加载数组元素类型。如果N的描述符如前面所假设的形式，需要加载的元素类型就是“java.lang.Integer”，接着由虚拟机生成一个代表此数组维度和元素的数组对象。 </li><li>如果上面的步骤没有出现任何异常，那么C在虚拟机中实际上已经成为一个有效的类或接口了，但在解析完成之前还要进行符号引用验证，确认D是否具备对C的访问权限。如果发现不具备访问权限，将抛出java.lang.IllegalAccessError异常。 </li></ol></blockquote><h4 id="3-4-2-字段解析"><a href="#3-4-2-字段解析" class="headerlink" title="3.4.2 字段解析"></a><strong>3.4.2 字段解析</strong></h4><p>&emsp;&emsp;要解析一个未被解析过的字段符号引用，首先将会对字段表内class_index项中索引的CONSTANT_Class_info符号引用进行解析，也就是字段所属的类或接口的符号引用。如果在解析这个类或接口符号引用的过程中出现了任何异常，都会导致字段符号引用解析的失败。如果解析成功完成，那将这个字段所属的类或接口用C表示，虚拟机规范要求按照如下步骤对C进行后续字段的搜索。 </p><blockquote><ol><li>如果C本身就包含了简单名称和字段描述符都与目标相匹配的字段，则返回这个字段的直接引用，查找结束。 </li><li>否则，如果在C中实现了接口，将会按照继承关系从下往上递归搜索各个接口和它的 父接口，如果接口中包含了简单名称和字段描述符都与目标相匹配的字段，则返回这个字段的直接引用，查找结束。 </li><li>否则，如果C不是java.lang.Object的话，将会按照继承关系从下往上递归搜索其父类，如果在父类中包含了简单名称和字段描述符都与目标相匹配的字段，则返回这个字段的直接引用，查找结束。 </li><li>否则，查找失败，抛出java.lang.NoSuchFieldError异常。</li></ol></blockquote><p>&emsp;&emsp;如果查找过程成功返回了引用，将会对这个字段进行权限验证，如果发现不具备对字段的访问权限，将抛出java.lang.IllegalAccessError异常。 </p><p>&emsp;&emsp;在实际应用中，虚拟机的编译器实现可能会比上述规范要求得更加严格一些，如果有一个同名字段同时出现在C的接口和父类中，或者同时在自己或父类的多个接口中出现，那编译器将可能拒绝编译。在代码清单7-4中，如果注释了Sub类中的“public static int A = 4;”，接口与父类同时存在字段A，那编译器将提示“The field Sub.A is ambiguous”，并且拒绝编译这段代码。 </p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//代码清单7-4　字段解析</span></span><br><span class="line"><span class="keyword">package</span> org.fenixsoft.classloading; </span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">FieldResolution</span> </span>&#123; </span><br><span class="line">    <span class="class"><span class="keyword">interface</span> <span class="title">Interface0</span> </span>&#123; </span><br><span class="line">        <span class="keyword">int</span> A = <span class="number">0</span>; </span><br><span class="line">    &#125; </span><br><span class="line">    </span><br><span class="line">    <span class="class"><span class="keyword">interface</span> <span class="title">Interface1</span> <span class="keyword">extends</span> <span class="title">Interface0</span> </span>&#123; </span><br><span class="line">        <span class="keyword">int</span> A = <span class="number">1</span>; </span><br><span class="line">    &#125; </span><br><span class="line">    </span><br><span class="line">    <span class="class"><span class="keyword">interface</span> <span class="title">Interface2</span> </span>&#123; </span><br><span class="line">        <span class="keyword">int</span> A = <span class="number">2</span>; </span><br><span class="line">    &#125; </span><br><span class="line">    </span><br><span class="line">    <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Parent</span> <span class="keyword">implements</span> <span class="title">Interface1</span> </span>&#123; </span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> A = <span class="number">3</span>; </span><br><span class="line">    &#125; </span><br><span class="line">    </span><br><span class="line">    <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Sub</span> <span class="keyword">extends</span> <span class="title">Parent</span> <span class="keyword">implements</span> <span class="title">Interface2</span> </span>&#123; </span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> A = <span class="number">4</span>; </span><br><span class="line">    &#125; </span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[]args)</span> </span>&#123; </span><br><span class="line">        System.out.println(Sub.A); </span><br><span class="line">    &#125; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="3-4-3-类方法解析"><a href="#3-4-3-类方法解析" class="headerlink" title="3.4.3 类方法解析"></a><strong>3.4.3 类方法解析</strong></h4><p>&emsp;&emsp;类方法解析的第一个步骤与字段解析一样，也需要先解析出类方法表的class_index项中索引的方法所属的类或接口的符号引用，如果解析成功，我们依然用C表示这个类，接下来虚拟机将会按照如下步骤进行后续的类方法搜索。 </p><blockquote><ol><li>类方法和接口方法符号引用的常量类型定义是分开的，如果在类方法表中发现class_index中索引的C是个接口，那就直接抛出java.lang.IncompatibleClassChangeError异常。 </li><li>如果通过了第1步，在类C中查找是否有简单名称和描述符都与目标相匹配的方法，如果有则返回这个方法的直接引用，查找结束。 </li><li>否则，在类C的父类中递归查找是否有简单名称和描述符都与目标相匹配的方法，如果有则返回这个方法的直接引用，查找结束。 </li><li>否则，在类C实现的接口列表及它们的父接口之中递归查找是否有简单名称和描述符都与目标相匹配的方法，如果存在匹配的方法，说明类C是一个抽象类，这时查找结束，抛出java.lang.AbstractMethodError异常。 </li><li>否则，宣告方法查找失败，抛出java.lang.NoSuchMethodError。 </li></ol></blockquote><p>&emsp;&emsp;最后，如果查找过程成功返回了直接引用，将会对这个方法进行权限验证，如果发现不具备对此方法的访问权限，将抛出java.lang.IllegalAccessError异常。 </p><h4 id="3-4-4-接口方法解析"><a href="#3-4-4-接口方法解析" class="headerlink" title="3.4.4 接口方法解析"></a><strong>3.4.4 接口方法解析</strong></h4><p>&emsp;&emsp;接口方法也需要先解析出接口方法表的class_index项中索引的方法所属的类或接口的符号引用，如果解析成功，依然用C表示这个接口，接下来虚拟机将会按照如下步骤进行后续的接口方法搜索。</p><blockquote><ol><li>与类方法解析不同，如果在接口方法表中发现class_index中的索引C是个类而不是接口，那就直接抛出java.lang.IncompatibleClassChangeError异常。 </li><li>否则，在接口C中查找是否有简单名称和描述符都与目标相匹配的方法，如果有则返回这个方法的直接引用，查找结束。 </li><li>否则，在接口C的父接口中递归查找，直到java.lang.Object类（查找范围会包括Object类）为止，看是否有简单名称和描述符都与目标相匹配的方法，如果有则返回这个方法的直接引用，查找结束。 </li><li>否则，宣告方法查找失败，抛出java.lang.NoSuchMethodError异常。</li></ol></blockquote><p>&emsp;&emsp;由于接口中的所有方法默认都是public的，所以不存在访问权限的问题，因此接口方法的符号解析应当不会抛出java.lang.IllegalAccessError异常。 </p><h3 id="3-5-初始化"><a href="#3-5-初始化" class="headerlink" title="3.5 初始化"></a><strong>3.5 初始化</strong></h3><p>&emsp;&emsp;类初始化阶段是类加载过程的最后一步，前面的类加载过程中，除了在加载阶段用户应用程序可以通过自定义类加载器参与之外，其余动作完全由虚拟机主导和控制。<strong>到了初始化阶段，才真正开始执行类中定义的Java程序代码</strong>（或者说是字节码）。 </p><p>&emsp;&emsp;在准备阶段，变量已经赋过一次系统要求的初始值，而在初始化阶段，则根据程序员通过程序制定的主观计划去初始化类变量和其他资源，或者可以从另外一个角度来表达：初始化阶段是执行类构造器＜clinit＞()方法的过程。我们在下文会讲解＜clinit＞()方法是怎么生成的，在这里，我们先看一下＜clinit＞()方法执行过程中一些可能会影响程序运行行为的特点和细节，这部分相对更贴近于普通的程序开发人员。 </p><p>&emsp;&emsp;＜clinit＞()方法是由编译器自动收集类中的所有类变量的赋值动作和静态语句块（static{}块）中的语句合并产生的，<strong>编译器收集的顺序是由语句在源文件中出现的顺序所决定的</strong>，<strong>静态语句块中只能访问到定义在静态语句块之前的变量，定义在它之后的变量，在前面的静态语句块可以赋值，但是不能访问</strong>，如代码清单7-5中的例子所示。 </p><figure class="highlight cs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//代码清单7-5　非法向前引用变量</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">Test</span> &#123; </span><br><span class="line">    <span class="keyword">static</span> &#123; </span><br><span class="line">        i = <span class="number">0</span>; <span class="comment">//给变量赋值可以正常编译通过 </span></span><br><span class="line">        System.<span class="keyword">out</span>.print（i）; <span class="comment">//这句编译器会提示"非法向前引用" </span></span><br><span class="line">    &#125; </span><br><span class="line">    </span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">int</span> i = <span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>&emsp;&emsp;＜clinit＞()方法与类的构造函数（或者说实例构造器＜init＞()方法）不同，它不需要显式地调用父类构造器，虚拟机会保证在子类的＜clinit＞()方法执行之前，父类的＜clinit＞()方法已经执行完毕。因此在<strong>虚拟机中第一个被执行的＜clinit＞()方法的类肯定是java.lang.Object</strong>。 </p><p>&emsp;&emsp;由于父类的＜clinit＞()方法先执行，也就意味着<strong>父类中定义的静态语句块要优先于子类的变量赋值操作</strong>，如在代码清单7-6中，字段B的值将会是2而不是1。 </p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//代码清单7-6＜clinit＞()方法执行顺序</span></span><br><span class="line"><span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Parent</span> </span>&#123; </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> A = <span class="number">1</span>; </span><br><span class="line">    </span><br><span class="line">    <span class="keyword">static</span>&#123; </span><br><span class="line">        A = <span class="number">2</span>; </span><br><span class="line">    &#125; </span><br><span class="line">&#125; </span><br><span class="line"></span><br><span class="line"><span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Sub</span> <span class="keyword">extends</span> <span class="title">Parent</span> </span>&#123; </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> B = A; </span><br><span class="line">&#125; </span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123; </span><br><span class="line">    System.out.println(Sub.B); </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>&emsp;&emsp;＜clinit＞()方法对于类或接口来说并不是必需的，如果一个类中没有静态语句块，也没有对变量的赋值操作，那么编译器可以不为这个类生成＜clinit＞()方法。 </p><p>&emsp;&emsp;接口中不能使用静态语句块，但仍然有变量初始化的赋值操作，因此接口与类一样都会生成＜clinit＞()方法。但接口与类不同的是，执行接口的＜clinit＞()方法不需要先执行父接口的＜clinit＞()方法。<strong>只有当父接口中定义的变量使用时，父接口才会初始化</strong>。另外，接口的实现类在初始化时也一样不会执行接口的＜clinit＞()方法。</p><p>&emsp;&emsp;虚拟机会保证一个类的＜clinit＞()方法在多线程环境中被正确地加锁、同步，如果多个线程同时去初始化一个类，那么只会有一个线程去执行这个类的＜clinit＞()方法，其他线程都需要阻塞等待，直到活动线程执行＜clinit＞()方法完毕。如果在一个类的＜clinit＞ ()方法中有耗时很长的操作，就可能造成多个进程阻塞，在实际应用中这种阻塞往往是很隐蔽的。代码清单7-7演示了这种场景。 </p><figure class="highlight cs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//代码清单7-7　字段解析</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">class</span> <span class="title">DeadLoopClass</span> &#123; </span><br><span class="line">    <span class="keyword">static</span> &#123; </span><br><span class="line">        <span class="comment">/*如果不加上这个if语句，编译器将提示"Initializer does not complete normally"并拒绝编译 */</span> </span><br><span class="line">        <span class="keyword">if</span>(<span class="literal">true</span>) &#123; </span><br><span class="line">            System.<span class="keyword">out</span>.println(Thread.currentThread() + <span class="string">"init DeadLoopClass"</span>);</span><br><span class="line">            <span class="keyword">while</span>(<span class="literal">true</span>) &#123; </span><br><span class="line"></span><br><span class="line">            &#125; </span><br><span class="line">        &#125; </span><br><span class="line">    &#125; </span><br><span class="line">&#125; </span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span>(<span class="params">String[] args</span>) </span>&#123; </span><br><span class="line">    Runnable script=<span class="keyword">new</span> Runnable() &#123; </span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span>(<span class="params"></span>) </span>&#123; </span><br><span class="line">            System.<span class="keyword">out</span>.println(Thread.currentThread() + <span class="string">"start"</span>)；</span><br><span class="line">            DeadLoopClass dlc = <span class="keyword">new</span> DeadLoopClass();</span><br><span class="line">            System.<span class="keyword">out</span>.println(Thread.currentThread() + <span class="string">"run over"</span>);</span><br><span class="line">        &#125; </span><br><span class="line">    &#125;;</span><br><span class="line">    </span><br><span class="line">    Thread thread1 = <span class="keyword">new</span> Thread(script);</span><br><span class="line">    Thread thread2 = <span class="keyword">new</span> Thread(script);</span><br><span class="line">    thread1.start();</span><br><span class="line">    thread2.start();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>&emsp;&emsp;运行结果如下，即一条线程在死循环以模拟长时间操作，另外一条线程在阻塞等待。</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Thread[Thread-0, 5, main]<span class="keyword">start</span> </span><br><span class="line"><span class="keyword">Thread</span>[<span class="keyword">Thread</span><span class="number">-1</span>, <span class="number">5</span>, <span class="keyword">main</span>]<span class="keyword">start</span> </span><br><span class="line"><span class="keyword">Thread</span>[<span class="keyword">Thread</span><span class="number">-0</span>, <span class="number">5</span>, <span class="keyword">main</span>]init DeadLoopClass</span><br></pre></td></tr></table></figure><hr><p><em>参考博客和文章书籍等：</em></p><blockquote><p>《深入理解Java虚拟机》</p></blockquote><p><em>因博客主等未标明不可引用，若部分内容涉及侵权请及时告知，我会尽快修改和删除相关内容</em></p>]]></content>
    
    <summary type="html">
    
      简单介绍Java虚拟机中的虚拟机类加载机制-类加载过程，包括：加载，验证（文件格式验证、元数据验证、字节码验证、符号引用验证），准备，解析（类或接口的解析、字段解析、类方法解析、接口方法解析），初始化等内容。
    
    </summary>
    
      <category term="技术文档" scheme="http://linyishui.top/categories/%E6%8A%80%E6%9C%AF%E6%96%87%E6%A1%A3/"/>
    
    
      <category term="java" scheme="http://linyishui.top/tags/java/"/>
    
      <category term="jvm" scheme="http://linyishui.top/tags/jvm/"/>
    
  </entry>
  
  <entry>
    <title>虚拟机类加载机制</title>
    <link href="http://linyishui.top/2019120701.html"/>
    <id>http://linyishui.top/2019120701.html</id>
    <published>2019-12-07T10:04:08.000Z</published>
    <updated>2020-01-10T03:11:53.993Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="类文件结构"><a href="#类文件结构" class="headerlink" title="类文件结构"></a><strong>类文件结构</strong></h1><h2 id="第一节-概述"><a href="#第一节-概述" class="headerlink" title="第一节 概述"></a><strong>第一节 概述</strong></h2><p>&emsp;&emsp;代码编译的结果从本地机器码转变为字节码，是存储格式发展的一小步，却是编程语言发展的一大步。</p><p>&emsp;&emsp;<a href="../2019120301.html" title="Title">类文件结构</a>我们了解了Class文件存储格式的具体细节，在Class文件中描述的各种信息，最终都需要加载到虚拟机中之后才能运行和使用。而虚拟机如何加载这些Class文件？Class文件中的信息进入到虚拟机后会发生什么变化？这些都是本章将要讲解的内容。 </p><p>&emsp;&emsp;<strong>虚拟机把描述类的数据从Class文件加载到内存，并对数据进行校验、转换解析和初始化，最终形成可以被虚拟机直接使用的Java类型，这就是虚拟机的类加载机制</strong>。 </p><p>&emsp;&emsp;与那些在编译时需要进行连接工作的语言不同，在Java语言里面，类型的加载、连接和初始化过程都是在程序运行期间完成的，这种策略虽然会令类加载时稍微增加一些性能开销，但是会为Java应用程序提供高度的灵活性，Java里天生可以动态扩展的语言特性就是依赖运行期动态加载和动态连接这个特点实现的。例如，如果编写一个面向接口的应用程序，可以等到运行时再指定其实际的实现类；用户可以通过Java预定义的和自定义类加载器，让一个本地的应用程序可以在运行时从网络或其他地方加载一个二进制流作为程序代码的一部分，这种组装应用程序的方式目前已广泛应用于Java程序之中。从最基础的Applet、JSP到相对复杂的OSGi技术，都使用了<strong>Java语言运行期类加载的特性</strong>。 </p><p>&emsp;&emsp;为了避免语言表达中可能产生的偏差，在本章正式开始之前，作者先设立两个语言上的约定：第一，在实际情况中，每个Class文件都有可能代表着Java语言中的一个类或接口，后文中直接对“类”的描述都包括了类和接口的可能性，而对于类和接口需要分开描述的场景会特别指明；第二，与前面介绍Class文件格式时的约定一致，作者本章所提到的“Class文件”并非特指某个存在于具体磁盘中的文件，这里所说的“Class文件”应当是一串二进制的字节流，无论以何种形式存在都可以。</p><hr><h2 id="第二节-类加载的时机"><a href="#第二节-类加载的时机" class="headerlink" title="第二节 类加载的时机"></a><strong>第二节 类加载的时机</strong></h2><p>&emsp;&emsp;类从被加载到虚拟机内存中开始，到卸载出内存为止，它的整个生命周期包括：<strong>加载</strong>（Loading）、<strong>验证</strong>（Verification）、<strong>准备</strong>（Preparation）、<strong>解析</strong>（Resolution）、<strong>初始化</strong>（Initialization）、<strong>使用</strong>（Using）和<strong>卸载</strong>（Unloading）7个阶段。其中验证、准备、解析3个 部分统称为<strong>连接</strong>（Linking），这7个阶段的发生顺序如图7-1所示。</p><p><img src="https://pic-1258215793.cos.ap-shanghai.myqcloud.com/content/20191201/201912010160.png" alt="类的生命周期"></p><p>&emsp;&emsp;图7-1中，<strong>加载、验证、准备、初始化和卸载这5个阶段的顺序是确定的</strong>，<strong>类的加载过程必须按照这种顺序按部就班地开始</strong>，而<strong>解析阶段则不一定</strong>：它在某些情况下可以在初始化阶段之后再开始，这是为了支持Java语言的<strong>运行时绑定</strong>（也称为动态绑定或晚期绑定）。注意，这里作者写的是按部就班地“开始”，而不是按部就班地“进行”或“完成”，强调这点是因为这些阶段通常都是互相交叉地混合式进行的，通常会在一个阶段执行的过程中调用、激活另外一个阶段。 </p><p>&emsp;&emsp;什么情况下需要开始类加载过程的第一个阶段：加载？Java虚拟机规范中并没有进行强制约束，这点可以交给虚拟机的具体实现来自由把握。但是对于初始化阶段，虚拟机规范则是严格规定了有且只有5种情况必须立即对类进行“初始化”（而加载、验证、准备自然需要在此之前开始）： </p><blockquote><ol><li>遇到new、getstatic、putstatic或invokestatic这4条字节码指令时，如果类没有进行过初始化，则需要先触发其初始化。生成这4条指令的最常见的Java代码场景是：使用new关键字实例化对象的时候、读取或设置一个类的静态字段（被final修饰、已在编译期把结果放入常量池的静态字段除外）的时候，以及调用一个类的静态方法的时候。 </li><li>使用java.lang.reflect包的方法对类进行反射调用的时候，如果类没有进行过初始化，则需要先触发其初始化。 </li><li>当初始化一个类的时候，如果发现其父类还没有进行过初始化，则需要先触发其父类的初始化。 </li><li>当虚拟机启动时，用户需要指定一个要执行的主类（包含main()方法的那个类），虚拟机会先初始化这个主类。 </li><li>当使用JDK 1.7的动态语言支持时，如果一个java.lang.invoke.MethodHandle实例最后的解析结果REF_getStatic、REF_putStatic、REF_invokeStatic的方法句柄，并且这个方法句柄所对应的类没有进行过初始化，则需要先触发其初始化。 </li></ol></blockquote><p>&emsp;&emsp;对于这5种会触发类进行初始化的场景，虚拟机规范中使用了一个很强烈的限定语：“有且只有”，这5种场景中的行为称为对一个类进行主动引用。除此之外，所有引用类的方式都不会触发初始化，称为<strong>被动引用</strong>。下面举3个例子来说明何为被动引用，分别见代码清单7-1～代码清单7-3。 </p><figure class="highlight cs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//代码清单7-1　被动引用的例子之一</span></span><br><span class="line">package org.fenixsoft.classloading; </span><br><span class="line"></span><br><span class="line"><span class="comment">/** </span></span><br><span class="line"><span class="comment"> * 被动使用类字段演示一： </span></span><br><span class="line"><span class="comment"> *    通过子类引用父类的静态字段，不会导致子类初始化 </span></span><br><span class="line"><span class="comment"> **/</span> </span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">SuperClass</span> &#123; </span><br><span class="line">    <span class="keyword">static</span> &#123; </span><br><span class="line">        System.<span class="keyword">out</span>.println(<span class="string">"SuperClass init!"</span>); </span><br><span class="line">    &#125; </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="keyword">value</span> = <span class="number">123</span>; </span><br><span class="line">&#125; </span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">SubClass</span> <span class="title">extends</span> <span class="title">SuperClass</span> &#123; </span><br><span class="line">    <span class="keyword">static</span> &#123; </span><br><span class="line">        System.<span class="keyword">out</span>.println(<span class="string">"SubClass init!"</span>); </span><br><span class="line">    &#125; </span><br><span class="line">&#125; </span><br><span class="line"></span><br><span class="line"><span class="comment">/** </span></span><br><span class="line"><span class="comment"> * 非主动使用类字段演示 </span></span><br><span class="line"><span class="comment"> **/</span> </span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">NotInitialization</span> &#123; </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span>(<span class="params">String[] args</span>)</span>&#123; </span><br><span class="line">        System.<span class="keyword">out</span>.println(SubClass.<span class="keyword">value</span>); </span><br><span class="line">    &#125; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>&emsp;&emsp;上述代码运行之后，只会输出“SuperClass init!”，而不会输出“SubClass init!”。对于静态字段，只有直接定义这个字段的类才会被初始化，因此通过其子类来引用父类中定义的静态字段，只会触发父类的初始化而不会触发子类的初始化。至于是否要触发子类的加载和验证，在虚拟机规范中并未明确规定，这点取决于虚拟机的具体实现。对于Sun HotSpot虚拟机来说，可通过-XX:+TraceClassLoading参数观察到此操作会导致子类的加载。 </p><figure class="highlight haxe"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//代码清单7-2　被动引用的例子之二</span></span><br><span class="line"><span class="keyword">package</span> org.fenixsoft.classloading; </span><br><span class="line"></span><br><span class="line"><span class="comment">/** </span></span><br><span class="line"><span class="comment"> *被动使用类字段演示二： </span></span><br><span class="line"><span class="comment"> *   通过数组定义来引用类，不会触发此类的初始化 </span></span><br><span class="line"><span class="comment"> **/</span> </span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">NotInitialization</span></span>&#123; </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> void main (<span class="keyword">String</span>[] args)&#123; </span><br><span class="line">        SuperClass[] sca = <span class="keyword">new</span> <span class="type">SuperClass</span>[<span class="number">10</span>]; </span><br><span class="line">    &#125; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>&emsp;&emsp;为了节省版面，这段代码复用了代码清单7-1中的SuperClass，运行之后发现没有输出“SuperClass init!”，说明并没有触发类org.fenixsoft.classloading.SuperClass的初始化阶段。但是这段代码里面触发了另外一个名为“[Lorg.fenixsoft.classloading.SuperClass”的类的初始化阶段，对于用户代码来说，这并不是一个合法的类名称，它是一个由虚拟机自动生成的、直接继承于java.lang.Object的子类，创建动作由字节码指令newarray触发。 </p><p>&emsp;&emsp;这个类代表了一个元素类型为org.fenixsoft.classloading.SuperClass的一维数组，数组中应有的属性和方法（用户可直接使用的只有被修饰为public的length属性和clone()方法）都实现在这个类里。Java语言中对数组的访问比C/C++相对安全是因为这个类封装了数组元素的访问方法（准确的说越界检查不是封装在数组元素访问的类中，而是封装在数组访问的xaload、xastore字节码指令中），而C/C++直接翻译为对数组指针的移动。在Java语言中，当检查到发生数组越界时会抛出java.lang.ArrayIndexOutOfBoundsException异常。</p><figure class="highlight cs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//代码清单7-3　被动引用的例子之三</span></span><br><span class="line">package org.fenixsoft.classloading; </span><br><span class="line"></span><br><span class="line"><span class="comment">/** </span></span><br><span class="line"><span class="comment"> * 被动使用类字段演示三： </span></span><br><span class="line"><span class="comment"> *    常量在编译阶段会存入调用类的常量池中，本质上并没有直接引用到定义常量的类，因此不会触发定义常量的类的初始化。 </span></span><br><span class="line"><span class="comment"> **/</span> </span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">ConstClass</span> &#123; </span><br><span class="line">    <span class="keyword">static</span> &#123; </span><br><span class="line">        System.<span class="keyword">out</span>.println(<span class="string">"ConstClass init!"</span>); </span><br><span class="line">    &#125; </span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> final String HELLOWORLD = <span class="string">"hello world"</span>; </span><br><span class="line">&#125; </span><br><span class="line"></span><br><span class="line"><span class="comment">/** </span></span><br><span class="line"><span class="comment"> * 非主动使用类字段演示 </span></span><br><span class="line"><span class="comment"> **/</span> </span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">NotInitialization</span> &#123; </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span>(<span class="params">String[] args</span>) </span>&#123; </span><br><span class="line">        System.<span class="keyword">out</span>.println(ConstClass.HELLOWORLD); </span><br><span class="line">    &#125; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>&emsp;&emsp;上述代码运行之后，也没有输出“ConstClass init!”，这是因为虽然在Java源码中引用了ConstClass类中的常量HELLOWORLD，但其实在编译阶段通过常量传播优化，已经将此常量的值“hello world”存储到了NotInitialization类的常量池中，以后NotInitialization对常量ConstClass.HELLOWORLD的引用实际都被转化为NotInitialization类对自身常量池的引用了。也就是说，实际上NotInitialization的Class文件之中并没有ConstClass类的符号引用入口，这两个类在编译成Class之后就不存在任何联系了。</p><p>&emsp;&emsp;接口的加载过程与类加载过程稍有一些不同，针对接口需要做一些特殊说明：<strong>接口也有初始化过程</strong>，这点与类是一致的，上面的代码都是用静态语句块“static{}”来输出初始化信息的，而接口中不能使用“static{}”语句块，但编译器仍然会为接口生成“＜clinit＞()”类构造器，用于初始化接口中所定义的成员变量。接口与类真正有所区别的是前面讲述的5种“有且仅有”需要开始初始化场景中的第3种：<strong>当一个类在初始化时，要求其父类全部都已经初始化过了，但是一个接口在初始化时，并不要求其父接口全部都完成了初始化，只有在真正使用到父接口的时候（如引用接口中定义的常量）才会初始化</strong>。 </p><hr><h2 id="第三节-类加载的过程"><a href="#第三节-类加载的过程" class="headerlink" title="第三节 类加载的过程"></a><strong>第三节 类加载的过程</strong></h2><p>&emsp;&emsp;<a href="../2019120801.html" title="Title">类加载机制-类加载过程</a></p><hr><h2 id="第四节-类加载器"><a href="#第四节-类加载器" class="headerlink" title="第四节 类加载器"></a><strong>第四节 类加载器</strong></h2><p>&emsp;&emsp;虚拟机设计团队把类加载阶段中的<strong>通过一个类的全限定名来获取描述此类的二进制字节流</strong>这个动作放到Java虚拟机外部去实现，以便让应用程序自己决定如何去获取所需要的类。实现这个动作的代码模块称为“类加载器”。</p><p>&emsp;&emsp;类加载器可以说是Java语言的一项创新，也是Java语言流行的重要原因之一，它最初是为了满足Java Applet的需求而开发出来的。虽然目前Java Applet技术基本上已经“死掉”，但类加载器却在<strong>类层次划分</strong>、<strong>OSGi</strong>（Open Service Gateway Initiative，开放服务网关协议技术是Java动态化模块化系统的一系列规范）、<strong>热部署</strong>、<strong>代码加密</strong>等领域大放异彩，成为了Java技术体系中一块重要的基石，可谓是失之桑榆，收之东隅。</p><h3 id="4-1-类与类加载器"><a href="#4-1-类与类加载器" class="headerlink" title="4.1 类与类加载器"></a><strong>4.1 类与类加载器</strong></h3><p>&emsp;&emsp;类加载器虽然只用于实现类的加载动作，但它在Java程序中起到的作用却远远不限于类加载阶段。对于任意一个类，都需要由加载它的类加载器和这个类本身一同确立其在Java虚拟机中的唯一性，每一个类加载器，都拥有一个独立的类名称空间。这句话可以表达得更通俗一些：比较两个类是否“相等”，只有在这两个类是由同一个类加载器加载的前提下才有意义，否则，即使这两个类来源于同一个Class文件，被同一个虚拟机加载，只要加载它们的类加载器不同，那这两个类就必定不相等。</p><p>&emsp;&emsp;这里所指的“相等”，包括代表类的Class对象的equals（）方法、isAssignableFrom（）方法、isInstance（）方法的返回结果，也包括使用instanceof关键字做对象所属关系判定等情况。如果没有注意到类加载器的影响，在某些情况下可能会产生具有迷惑性的结果，代码清单7-8中演示了不同的类加载器对instanceof关键字运算的结果的影响。</p><figure class="highlight processing"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">代码清单<span class="number">7</span><span class="number">-8</span>　不同的类加载器对<span class="keyword">instanceof</span>关键字运算的结果的影响</span><br><span class="line"><span class="comment">/** *类加载器与instanceof关键字演示 * *@author zzm */</span> <span class="keyword">public</span> class ClassLoaderTest&#123; <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> main（<span class="keyword">String</span>[]args）<span class="keyword">throws</span> Exception&#123; ClassLoader myLoader=<span class="keyword">new</span> ClassLoader（）&#123; @Override <span class="keyword">public</span> Class＜?＞loadClass（<span class="keyword">String</span> name）<span class="keyword">throws</span> ClassNotFoundException&#123; <span class="keyword">try</span>&#123; <span class="keyword">String</span> fileName=name.substring（name.lastIndexOf（<span class="string">"."</span>）+<span class="number">1</span>）+<span class="string">".class"</span>； InputStream is=getClass（）.getResourceAsStream（fileName）； <span class="keyword">if</span>（is==<span class="keyword">null</span>）&#123; <span class="keyword">return</span> <span class="keyword">super</span>.loadClass（name）； &#125; <span class="built_in">byte</span>[]b=<span class="keyword">new</span> <span class="built_in">byte</span>[is.available（）]； is.read（b）； <span class="keyword">return</span> defineClass（name,b，<span class="number">0</span>，b.length）； &#125;<span class="keyword">catch</span>（IOException e）&#123; <span class="keyword">throw</span> <span class="keyword">new</span> ClassNotFoundException（name）； &#125; &#125; &#125;； <span class="keyword">Object</span> obj=myLoader.loadClass（<span class="string">"org.fenixsoft.classloading.ClassLoaderTest"</span>）.newInstance（）； System.out.<span class="built_in">println</span>（obj.getClass（））； System.out.<span class="built_in">println</span>（obj <span class="keyword">instanceof</span> org.fenixsoft.classloading.ClassLoaderTest）； &#125; &#125;</span><br></pre></td></tr></table></figure><p>&emsp;&emsp;运行结果：</p><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">class org<span class="selector-class">.fenixsoft</span><span class="selector-class">.classloading</span><span class="selector-class">.ClassLoaderTest</span> false</span><br></pre></td></tr></table></figure><p>&emsp;&emsp;代码清单7-8中构造了一个简单的类加载器，尽管很简单，但是对于这个演示来说还是够用了。它可以加载与自己在同一路径下的Class文件。我们使用这个类加载器去加载了一个名为“org.fenixsoft.classloading.ClassLoaderTest”的类，并实例化了这个类的对象。两行输出结果中，从第一句可以看出，这个对象确实是类org.fenixsoft.classloading.ClassLoaderTest实例化出来的对象，但从第二句可以发现，这个对象与类org.fenixsoft.classloading.ClassLoaderTest做所属类型检查的时候却返回了false，这是因为虚拟机中存在了两个ClassLoaderTest类，一个是由系统应用程序类加载器加载的，另外一个是由我们自定义的类加载器加载的，虽然都来自同一个Class文件，但依然是两个独立的类，做对象所属类型检查时结果自然为false。</p><h3 id="4-2-双亲委派模型"><a href="#4-2-双亲委派模型" class="headerlink" title="4.2 双亲委派模型"></a><strong>4.2 双亲委派模型</strong></h3><p>&emsp;&emsp;从Java虚拟机的角度来讲，只存在两种不同的类加载器：一种是启动类加载器（Bootstrap ClassLoader），这个类加载器使用C++语言实现[1]，是虚拟机自身的一部分；另一种就是所有其他的类加载器，这些类加载器都由Java语言实现，独立于虚拟机外部，并且全都继承自抽象类java.lang.ClassLoader。</p><p>&emsp;&emsp;从Java开发人员的角度来看，类加载器还可以划分得更细致一些，绝大部分Java程序都会使用到以下3种系统提供的类加载器。</p><p>&emsp;&emsp;启动类加载器（Bootstrap ClassLoader）：前面已经介绍过，这个类将器负责将存放在＜JAVA_HOME＞\lib目录中的，或者被-Xbootclasspath参数所指定的路径中的，并且是虚拟机识别的（仅按照文件名识别，如rt.jar，名字不符合的类库即使放在lib目录中也不会被加载）类库加载到虚拟机内存中。启动类加载器无法被Java程序直接引用，用户在编写自定义类加载器时，如果需要把加载请求委派给引导类加载器，那直接使用null代替即可，如代码清单7-9所示为java.lang.ClassLoader.getClassLoader（）方法的代码片段。</p><figure class="highlight vim"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">代码清单<span class="number">7</span>-<span class="number">9</span>　ClassLoader.getClassLoader（）方法的代码片段</span><br><span class="line">/** Returns the class loader <span class="keyword">for</span> the class.Some implementations may use null <span class="keyword">to</span> represent the bootstrap class loader.This method will <span class="keyword">return</span> null in such implementations <span class="keyword">if</span> this class was loaded by the bootstrap class loader. */ public ClassLoader getClassLoader（）&#123; ClassLoader <span class="keyword">cl</span>=getClassLoader0（）； <span class="keyword">if</span>（<span class="keyword">cl</span>==null） <span class="keyword">return</span> null； SecurityManager <span class="keyword">sm</span>=System.getSecurityManager（）； <span class="keyword">if</span>（<span class="keyword">sm</span>！=null）&#123; ClassLoader <span class="keyword">ccl</span>=ClassLoader.getCallerClassLoader（）； <span class="keyword">if</span>（<span class="keyword">ccl</span>！=null＆＆<span class="keyword">ccl</span>！=<span class="keyword">cl</span>＆＆！<span class="keyword">cl</span>.isAncestor（<span class="keyword">ccl</span>））&#123; <span class="keyword">sm</span>.checkPermission（SecurityConstants.GET_CLASSLOADER_PERMISSION）； &#125; &#125; <span class="keyword">return</span> <span class="keyword">cl</span>； &#125;</span><br></pre></td></tr></table></figure><p>&emsp;&emsp;扩展类加载器（Extension ClassLoader）：这个加载器由sun.misc.Launcher $ExtClassLoader实现，它负责加载＜JAVA_HOME＞\lib\ext目录中的，或者被java.ext.dirs系统变量所指定的路径中的所有类库，开发者可以直接使用扩展类加载器。</p><p>&emsp;&emsp;应用程序类加载器（Application ClassLoader）：这个类加载器由sun.misc.Launcher $AppClassLoader实现。由于这个类加载器是ClassLoader中的getSystemClassLoader（）方法的返回值，所以一般也称它为系统类加载器。它负责加载用户类路径（ClassPath）上所指定的类库，开发者可以直接使用这个类加载器，如果应用程序中没有自定义过自己的类加载器，一般情况下这个就是程序中默认的类加载器。</p><p>&emsp;&emsp;我们的应用程序都是由这3种类加载器互相配合进行加载的，如果有必要，还可以加入自己定义的类加载器。这些类加载器之间的关系一般如图7-2所示。</p><p><img src="https://pic-1258215793.cos.ap-shanghai.myqcloud.com/content/20191201/1111111111.png" alt="类加载器双亲委派模型 "></p><p>&emsp;&emsp;图7-2中展示的类加载器之间的这种层次关系，称为类加载器的双亲委派模型（Parents Delegation Model）。双亲委派模型要求除了顶层的启动类加载器外，其余的类加载器都应当有自己的父类加载器。这里类加载器之间的父子关系一般不会以继承（Inheritance）的关系来实现，而是都使用组合（Composition）关系来复用父加载器的代码。</p><p>&emsp;&emsp;类加载器的双亲委派模型在JDK1.2期间被引入并被广泛应用于之后几乎所有的Java程序中，但它并不是一个强制性的约束模型，而是Java设计者推荐给开发者的一种类加载器实现方式。</p><p>&emsp;&emsp;双亲委派模型的工作过程是：如果一个类加载器收到了类加载的请求，它首先不会自己去尝试加载这个类，而是把这个请求委派给父类加载器去完成，每一个层次的类加载器都是如此，因此所有的加载请求最终都应该传送到顶层的启动类加载器中，只有当父加载器反馈自己无法完成这个加载请求（它的搜索范围中没有找到所需的类）时，子加载器才会尝试自己去加载。</p><p>&emsp;&emsp;使用双亲委派模型来组织类加载器之间的关系，有一个显而易见的好处就是Java类随着它的类加载器一起具备了一种带有优先级的层次关系。例如类java.lang.Object，它存放在rt.jar之中，无论哪一个类加载器要加载这个类，最终都是委派给处于模型最顶端的启动类加载器进行加载，因此Object类在程序的各种类加载器环境中都是同一个类。相反，如果没有使用双亲委派模型，由各个类加载器自行去加载的话，如果用户自己编写了一个称为java.lang.Object的类，并放在程序的ClassPath中，那系统中将会出现多个不同的Object类，Java类型体系中最基础的行为也就无法保证，应用程序也将会变得一片混乱。如果读者有兴趣的话，可以尝试去编写一个与rt.jar类库中已有类重名的Java类，将会发现可以正常编译，但永远无法被加载运行[2]。</p><p>&emsp;&emsp;双亲委派模型对于保证Java程序的稳定运作很重要，但它的实现却非常简单，实现双亲委派的代码都集中在java.lang.ClassLoader的loadClass（）方法之中，如代码清单7-10所示，逻辑清晰易懂：先检查是否已经被加载过，若没有加载则调用父加载器的loadClass（）方法，若父加载器为空则默认使用启动类加载器作为父加载器。如果父类加载失败，抛出ClassNotFoundException异常后，再调用自己的findClass（）方法进行加载。</p><figure class="highlight fortran"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">代码清单<span class="number">7</span>-<span class="number">10</span>　双亲委派模型的实现</span><br><span class="line"><span class="keyword">protected</span> synchronized <span class="keyword">Class</span>＜?＞loadClass（String <span class="keyword">name</span>,boolean resolve）throws ClassNotFoundException &#123; //首先，检查请求的类是否已经被加载过了 <span class="keyword">Class</span> c=findLoadedClass（<span class="keyword">name</span>）； <span class="keyword">if</span>（c==null）&#123; try&#123; <span class="keyword">if</span>（parent！=null）&#123; c=parent.loadClass（<span class="keyword">name</span>,false）； &#125;<span class="keyword">else</span>&#123; c=findBootstrapClassOrNull（<span class="keyword">name</span>）； &#125; &#125;catch（ClassNotFoundException e）&#123; //如果父类加载器抛出ClassNotFoundException //说明父类加载器无法完成加载请求 &#125; <span class="keyword">if</span>（c==null）&#123; //在父类加载器无法加载的时候 //再调用本身的findClass方法来进行类加载 c=findClass（<span class="keyword">name</span>）； &#125; &#125; <span class="keyword">if</span>（resolve）&#123; resolveClass（c）； &#125; <span class="keyword">return</span> c； &#125;</span><br></pre></td></tr></table></figure><h3 id="4-3-破坏双亲委派模型"><a href="#4-3-破坏双亲委派模型" class="headerlink" title="4.3 破坏双亲委派模型"></a><strong>4.3 破坏双亲委派模型</strong></h3><p>&emsp;&emsp;上文提到过双亲委派模型并不是一个强制性的约束模型，而是Java设计者推荐给开发者的类加载器实现方式。在Java的世界中大部分的类加载器都遵循这个模型，但也有例外，到目前为止，双亲委派模型主要出现过3较大规模的“被破坏”情况。</p><p>&emsp;&emsp;双亲委派模型的第一次“被破坏”其实发生在双亲委派模型出现之前——即JDK1.2发布之前。由于双亲委派模型在JDK1.2之后才被引入，而类加载器和抽象类java.lang.ClassLoader则在JDK1.0时代就已经存在，面对已经存在的用户自定义类加载器的实现代码，Java设计者引入双亲委派模型时不得不做出一些妥协。为了向前兼容，JDK1.2之后的java.lang.ClassLoader添加了一个新的protected方法findClass（），在此之前，用户去继承java.lang.ClassLoader的唯一目的就是为了重写loadClass（）方法，因为虚拟机在进行类加载的时候会调用加载器的私有方法loadClassInternal（），而这个方法的唯一逻辑就是去调用自己的loadClass（）。</p><p>&emsp;&emsp;上一节我们已经看过loadClass（）方法的代码，双亲委派的具体逻辑就实现在这个方法之中，JDK1.2之后已不提倡用户再去覆盖loadClass（）方法，而应当把自己的类加载逻辑写到findClass（）方法中，在loadClass（）方法的逻辑里如果父类加载失败，则会调用自己的findClass（）方法来完成加载，这样就可以保证新写出来的类加载器是符合双亲委派规则的。</p><p>&emsp;&emsp;双亲委派模型的第二次“被破坏”是由这个模型自身的缺陷所导致的，双亲委派很好地解决了各个类加载器的基础类的统一问题（越基础的类由越上层的加载器进行加载），基础类之所以称为“基础”，是因为它们总是作为被用户代码调用的API，但世事往往没有绝对的完美，如果基础类又要调用回用户的代码，那该怎么办？</p><p>&emsp;&emsp;这并非是不可能的事情，一个典型的例子便是JNDI服务，JNDI现在已经是Java的标准服务，它的代码由启动类加载器去加载（在JDK1.3时放进去的rt.jar），但JNDI的目的就是对资源进行集中管理和查找，它需要调用由独立厂商实现并部署在应用程序的ClassPath下的JNDI接口提供者（SPI,Service Provider Interface）的代码，但启动类加载器不可能“认识”这些代码啊！那该怎么办？</p><p>&emsp;&emsp;为了解决这个问题，Java设计团队只好引入了一个不太优雅的设计：线程上下文类加载器（Thread Context ClassLoader）。这个类加载器可以通过java.lang.Thread类的setContextClassLoaser（）方法进行设置，如果创建线程时还未设置，它将会从父线程中继承一个，如果在应用程序的全局范围内都没有设置过的话，那这个类加载器默认就是应用程序类加载器。</p><p>&emsp;&emsp;有了线程上下文类加载器，就可以做一些“舞弊”的事情了，JNDI服务使用这个线程上下文类加载器去加载所需要的SPI代码，也就是父类加载器请求子类加载器去完成类加载的动作，这种行为实际上就是打通了双亲委派模型的层次结构来逆向使用类加载器，实际上已经违背了双亲委派模型的一般性原则，但这也是无可奈何的事情。Java中所有涉及SPI的加载动作基本上都采用这种方式，例如JNDI、JDBC、JCE、JAXB和JBI等。</p><p>&emsp;&emsp;双亲委派模型的第三次“被破坏”是由于用户对程序动态性的追求而导致的，这里所说的“动态性”指的是当前一些非常“热门”的名词：代码热替换（HotSwap）、模块热部署（HotDeployment）等，说白了就是希望应用程序能像我们的计算机外设那样，接上鼠标、U盘，<br>不用重启机器就能立即使用，鼠标有问题或要升级就换个鼠标，不用停机也不用重启。对于个人计算机来说，重启一次其实没有什么大不了的，但对于一些生产系统来说，关机重启一次可能就要被列为生产事故，这种情况下热部署就对软件开发者，尤其是企业级软件开发者具有很大的吸引力。</p><p>&emsp;&emsp;Sun公司所提出的JSR-294[1]、JSR-277[2]规范在与JCP组织的模块化规范之争中落败给JSR291（即OSGi R4.2），虽然Sun不甘失去Java模块化的主导权，独立在发展Jigsaw项目，但目前OSGi已经成为了业界“事实上”的Java模块化标准[3]，而OSGi实现模块化热部署的关键则是它自定义的类加载器机制的实现。每一个程序模块（OSGi中称为Bundle）都有一个自己的类加载器，当需要更换一个Bundle时，就把Bundle连同类加载器一起换掉以实现代码的热替换。</p><p>&emsp;&emsp;在OSGi环境下，类加载器不再是双亲委派模型中的树状结构，而是进一步发展为更加复杂的网状结构，当收到类加载请求时，OSGi将按照下面的顺序进行类搜索：</p><blockquote><ol><li>将以java.*开头的类委派给父类加载器加载。</li><li>否则，将委派列表名单内的类委派给父类加载器加载。</li><li>否则，将Import列表中的类委派给Export这个类的Bundle的类加载器加载。</li><li>否则，查找当前Bundle的ClassPath，使用自己的类加载器加载。</li><li>否则，查找类是否在自己的Fragment Bundle中，如果在，则委派给Fragment Bundle的类加载器加载。</li><li>否则，查找Dynamic Import列表的Bundle，委派给对应Bundle的类加载器加载。</li><li>否则，类查找失败。</li></ol></blockquote><p>&emsp;&emsp;上面的查找顺序中只有开头两点仍然符合双亲委派规则，其余的类查找都是在平级的类加载器中进行的。</p><p>&emsp;&emsp;作者虽然使用了“被破坏”这个词来形容上述不符合双亲委派模型原则的行为，但这里“被破坏”并不带有贬义的感情色彩。只要有足够意义和理由，突破已有的原则就可认为是一种创新。正如OSGi中的类加载器并不符合传统的双亲委派的类加载器，并且业界对其为了实现热部署而带来的额外的高复杂度还存在不少争议，但在Java程序员中基本有一个共识：OSGi中对类加载器的使用是很值得学习的，弄懂了OSGi的实现，就可以算是掌握了类加载器的精髓。</p><hr><h2 id="第五节-总结"><a href="#第五节-总结" class="headerlink" title="第五节 总结"></a><strong>第五节 总结</strong></h2><p>&emsp;&emsp;本章介绍了类加载过程的“加载”、“验证”、“准备”、“解析”和“初始化”5个阶段中虚拟机进行了哪些动作，还介绍了类加载器的工作原理及其对虚拟机的意义。</p><p>&emsp;&emsp;经过第6和第7两章的讲解，相信读者已经对如何在Class文件中定义类，如何将类加载到虚拟机中这两个问题有了比较系统的了解，第8章我们将一起来看看虚拟机如何执行定义在Class文件里的字节码。</p><hr><p><em>参考博客和文章书籍等：</em></p><blockquote><p>《深入理解Java虚拟机》</p></blockquote><p><em>因博客主等未标明不可引用，若部分内容涉及侵权请及时告知，我会尽快修改和删除相关内容</em></p>]]></content>
    
    <summary type="html">
    
      简单介绍Java虚拟机中的虚拟机类加载机制，包括：概述，类加载的时机，类加载的过程，类加载器（类与类加载器、双亲委派模型、破坏双亲委派模型），总结等内容。
    
    </summary>
    
      <category term="技术文档" scheme="http://linyishui.top/categories/%E6%8A%80%E6%9C%AF%E6%96%87%E6%A1%A3/"/>
    
    
      <category term="java" scheme="http://linyishui.top/tags/java/"/>
    
      <category term="jvm" scheme="http://linyishui.top/tags/jvm/"/>
    
  </entry>
  
  <entry>
    <title>类文件结构-字节码指令简介</title>
    <link href="http://linyishui.top/2019120501.html"/>
    <id>http://linyishui.top/2019120501.html</id>
    <published>2019-12-05T09:59:50.000Z</published>
    <updated>2020-01-10T03:12:04.276Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="类文件结构-字节码指令简介"><a href="#类文件结构-字节码指令简介" class="headerlink" title="类文件结构-字节码指令简介"></a><strong>类文件结构-字节码指令简介</strong></h1><h2 id="第四节-字节码指令简介"><a href="#第四节-字节码指令简介" class="headerlink" title="第四节 字节码指令简介"></a><strong>第四节 字节码指令简介</strong></h2><p>&emsp;&emsp;Java虚拟机的指令由一个字节长度的、代表着某种特定操作含义的数字（称为<strong>操作码</strong>，Opcode）以及跟随其后的零至多个代表此操作所需参数（称为<strong>操作数</strong>，Operands）而构成。由于Java虚拟机采用面向操作数栈而不是寄存器的架构（这两种架构的区别和影响将在<a href="../2019121001.html" title="Title">字节码执行引擎</a>中探讨），所以<strong>大多数的指令都不包含操作数，只有一个操作码</strong>。 </p><p>&emsp;&emsp;字节码指令集是一种具有鲜明特点、优劣势都很突出的指令集架构，由于限制了Java虚拟机<strong>操作码的长度为一个字节</strong>（即0～255），这意味着指令集的操作码总数不可能超过256条；又由于Class文件格式放弃了编译后代码的操作数长度对齐，这就意味着虚拟机处理那些超过一个字节数据的时候，不得不在运行时从字节中重建出具体数据的结构，如果要将一个16位长度的无符号整数使用两个无符号字节存储起来（将它们命名为byte1和byte2），那它们的值应该是这样的：</p><figure class="highlight 1c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">( byte1 &lt;&lt; <span class="number">8</span> ) <span class="string">| byte2</span></span><br></pre></td></tr></table></figure><p>&emsp;&emsp;这种操作在某种程度上会导致解释执行字节码时损失一些性能。但这样做的优势也非常明显，放弃了操作数长度对齐，就意味着可以省略很多填充和间隔符号；用一个字节来代表操作码，也是为了尽可能获得短小精干的编译代码。这种追求尽可能小数据量、高传输效率的设计是由Java语言设计之初面向网络、智能家电的技术背景所决定的，并一直沿用至今。 </p><p>&emsp;&emsp;如果不考虑异常处理的话，那么Java虚拟机的解释器可以使用下面这个伪代码当做最基本的执行模型来理解，这个执行模型虽然很简单，但依然可以有效地工作：</p><figure class="highlight gcode"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">do</span> &#123; </span><br><span class="line">    自动计算PC寄存器的值加<span class="number">1</span>;</span><br><span class="line">    根据PC寄存器的指示位置, 从字节码流中取出操作码; </span><br><span class="line">    <span class="keyword">if</span><span class="comment">(字节码存在操作数)</span> 从字节码流中取出操作数; </span><br><span class="line">    执行操作码所定义的操作; </span><br><span class="line">&#125; <span class="keyword">while</span> <span class="comment">(字节码流长度 &gt; 0)</span>;</span><br></pre></td></tr></table></figure><h3 id="4-1-字节码与数据类型"><a href="#4-1-字节码与数据类型" class="headerlink" title="4.1 字节码与数据类型"></a><strong>4.1 字节码与数据类型</strong></h3><p>&emsp;&emsp;在Java虚拟机的指令集中，<strong>大多数的指令都包含了其操作所对应的数据类型信息</strong>。例如，iload指令用于从局部变量表中加载int型的数据到操作数栈中，而fload指令加载的则是float类型的数据。这两条指令的操作在虚拟机内部可能会是由同一段代码来实现的，但在Class文件中它们必须拥有各自独立的操作码。</p><p>&emsp;&emsp;对于大部分与数据类型相关的字节码指令，它们的操作码助记符中都有特殊的字符来表明专门为哪种数据类型服务：i代表对int类型的数据操作，l代表long，s代表short，b代表byte，c代表char，f代表float，d代表double，a代表reference。也有一些指令的助记符中没有明确地指明操作类型的字母，如arraylength指令，它没有代表数据类型的特殊字符，但操作数永远只能是一个数组类型的对象。还有另外一些指令，如无条件跳转指令goto则是与数据类型无关的。</p><p>&emsp;&emsp;由于Java虚拟机的操作码长度只有一个字节，所以包含了数据类型的操作码就为指令集的设计带来了很大的压力：如果每一种与数据类型相关的指令都支持Java虚拟机所有运行时数据类型的话，那指令的数量恐怕就会超出一个字节所能表示的数量范围了。因此，Java虚拟机的指令集对于特定的操作只提供了有限的类型相关指令去支持它，换句话说，指令集将会故意被设计成非完全独立的（Java虚拟机规范中把这种特性称为“Not Orthogonal”，即并非每种数据类型和每一种操作都有对应的指令）。有一些单独的指令可以在必要的时候用来将一些不支持的类型转换为可被支持的类型。 </p><p>&emsp;&emsp;表6-31列举了Java虚拟机所支持的与数据类型相关的字节码指令，通过使用数据类型列所代表的特殊字符替换opcode列的指令模板中的T，就可以得到一个具体的字节码指令。如果在表中指令模板与数据类型两列共同确定的格为空，则说明虚拟机不支持对这种数据类型执行这项操作。例如，load指令有操作int类型的iload，但是没有操作byte类型的同类指令。 </p><p>&emsp;&emsp;注意，从表6-31中可以看出，大部分的指令都没有支持整数类型byte、char和short，甚至没有任何指令支持boolean类型。<strong>编译器会在编译期或运行期将byte和short类型的数据带符号扩展（Sign-Extend）为相应的int类型数据</strong>，<strong>将boolean和char类型数据零位扩展（ZeroExtend）为相应的int类型数据</strong>。与之类似，在处理boolean、byte、short和char类型的数组时，也会转换为使用对应的int类型的字节码指令来处理。因此，<strong>大多数对于boolean、byte、short和char类型数据的操作，实际上都是使用相应的int类型作为运算类型</strong>（Computational Type）。</p><p><img src="https://pic-1258215793.cos.ap-shanghai.myqcloud.com/content/20191201/201912010157.png" alt="Java虚拟机指令集所支持的数据类型"></p><p><img src="https://pic-1258215793.cos.ap-shanghai.myqcloud.com/content/20191201/201912010158.png" alt="Java虚拟机指令集所支持的数据类型"></p><p>&emsp;&emsp;在本章中，受篇幅所限，无法对字节码指令集中每条指令进行逐一讲解，但阅读字节码作为了解Java虚拟机的基础技能，是一项应当熟练掌握的能力。作者将字节码操作按用途大致分为9类，按照分类来为读者概略介绍一下这些指令的用法。</p><h3 id="4-2-加载和存储指令"><a href="#4-2-加载和存储指令" class="headerlink" title="4.2 加载和存储指令"></a><strong>4.2 加载和存储指令</strong></h3><p>&emsp;&emsp;加载和存储指令用于<strong>将数据在栈帧中的局部变量表和操作数栈之间来回传输</strong>，这类指令包括如下内容。 </p><blockquote><ul><li>将一个局部变量加载到操作栈：iload、iload_＜n＞、lload、lload_＜n＞、fload、fload_ ＜n＞、dload、dload_＜n＞、aload、aload_＜n＞。 </li><li>将一个数值从操作数栈存储到局部变量表：istore、istore_＜n＞、lstore、lstore_＜n＞、 fstore、fstore_＜n＞、dstore、dstore_＜n＞、astore、astore_＜n＞。 </li><li>将一个常量加载到操作数栈：bipush、sipush、ldc、ldc_w、ldc2_w、aconst_null、 iconst_m1、iconst_＜i＞、lconst_＜l＞、fconst_＜f＞、dconst_＜d＞。 </li><li>扩充局部变量表的访问索引的指令：wide。 </li></ul></blockquote><p>&emsp;&emsp;存储数据的操作数栈和局部变量表主要就是由加载和存储指令进行操作，除此之外，还有少量指令，如访问对象的字段或数组元素的指令也会向操作数栈传输数据。 </p><p>&emsp;&emsp;上面所列举的指令助记符中，有一部分是以尖括号结尾的（例如iload_＜n＞），这些指令助记符实际上是代表了一组指令（例如iload_＜n＞，它代表了iload_0、iload_1、iload_2和iload_3这几条指令）。这几组指令都是某个带有一个操作数的通用指令（例如iload）的特殊形式，对于这若干组特殊指令来说，它们省略掉了显式的操作数，不需要进行取操作数的动作，实际上操作数就隐含在指令中。除了这点之外，它们的语义与原生的通用指令完全一致（例如iload_0的语义与操作数为0时的iload指令语义完全一致）。这种指令表示方法在本书以及《Java虚拟机规范》中都是通用的。</p><h3 id="4-3-运算指令"><a href="#4-3-运算指令" class="headerlink" title="4.3 运算指令"></a><strong>4.3 运算指令</strong></h3><p>&emsp;&emsp;运算或算术指令用于<strong>对两个操作数栈上的值进行某种特定运算，并把结果重新存入到操作栈顶</strong>。大体上算术指令可以分为两种：对整型数据进行运算的指令与对浮点型数据进行运算的指令，无论是哪种算术指令，都使用Java虚拟机的数据类型，由于没有直接支持byte、short、char和boolean类型的算术指令，对于这类数据的运算，应使用操作int类型的指令代替。整数与浮点数的算术指令在溢出和被零除的时候也有各自不同的行为表现，所有的算术指令如下。 </p><blockquote><ul><li>加法指令：iadd、ladd、fadd、dadd。 </li><li>减法指令：isub、lsub、fsub、dsub。 </li><li>乘法指令：imul、lmul、fmul、dmul。 </li><li>除法指令：idiv、ldiv、fdiv、ddiv。 </li><li>求余指令：irem、lrem、frem、drem。 </li><li>取反指令：ineg、lneg、fneg、dneg。 </li><li>位移指令：ishl、ishr、iushr、lshl、lshr、lushr。</li><li>按位或指令：ior、lor。 </li><li>按位与指令：iand、land。 </li><li>按位异或指令：ixor、lxor。 </li><li>局部变量自增指令：iinc。 </li><li>比较指令：dcmpg、dcmpl、fcmpg、fcmpl、lcmp。 </li></ul></blockquote><p>&emsp;&emsp;Java虚拟机的指令集直接支持了在《Java语言规范》中描述的各种对整数及浮点数操作（参见《Java语言规范（第3版）》中的4.2.2节和4.2.4节）的语义。数据运算可能会导致溢出，例如两个很大的正整数相加，结果可能会是一个负数，这种数学上不可能出现的溢出现象，对于程序员来说是很容易理解的，但其实Java虚拟机规范没有明确定义过整型数据溢出的具体运算结果，仅规定了在处理整型数据时，只有除法指令（idiv和ldiv）以及求余指令（irem和lrem）中当出现除数为零时会导致虚拟机抛出ArithmeticException异常，其余任何整型数运算场景都不应该抛出运行时异常。 </p><p>&emsp;&emsp;Java虚拟机规范要求虚拟机实现在处理浮点数时，必须严格遵循IEEE 754规范中所规定的行为和限制。也就是说，Java虚拟机必须完全支持IEEE 754中定义的非正规浮点数值（Denormalized Floating-Point Numbers）和逐级下溢（Gradual Underflow）的运算规则。这些特征将会使某些数值算法处理起来变得相对容易一些。</p><p>&emsp;&emsp;Java虚拟机要求在进行浮点数运算时，所有的运算结果都必须舍入到适当的精度，非精确的结果必须舍入为可被表示的最接近的精确值，如果有两种可表示的形式与该值一样接近，将优先选择最低有效位为零的。这种舍入模式也是IEEE 754规范中的默认舍入模式，称为<strong>向最接近数舍入模式</strong>。</p><p>&emsp;&emsp;在把浮点数转换为整数时，Java虚拟机使用IEEE 754标准中的<strong>向零舍入模式</strong>，这种模式的舍入结果会导致数字被截断，所有小数部分的有效字节都会被丢弃掉。向零舍入模式将在目标数值类型中选择一个最接近但是不大于原值的数字来作为最精确的舍入结果。</p><p>&emsp;&emsp;另外，Java虚拟机在处理浮点数运算时，不会抛出任何运行时异常（这里所讲的是Java语言中的异常，请读者勿与IEEE 754规范中的浮点异常互相混淆，IEEE 754的浮点异常是一种运算信号），当一个操作产生溢出时，将会使用有符号的无穷大来表示，如果某个操作结果没有明确的数学定义的话，将会使用NaN值来表示。所有使用NaN值作为操作数的算术操作，结果都会返回NaN。</p><p>&emsp;&emsp;在对long类型数值进行比较时，虚拟机采用带符号的比较方式，而对浮点数值进行比较时（dcmpg、dcmpl、fcmpg、fcmpl），虚拟机会采用IEEE 754规范所定义的无信号比较（Nonsignaling Comparisons）方式。</p><h3 id="4-4-类型转换指令"><a href="#4-4-类型转换指令" class="headerlink" title="4.4 类型转换指令"></a><strong>4.4 类型转换指令</strong></h3><p>&emsp;&emsp;类型转换指令可以<strong>将两种不同的数值类型进行相互转换</strong>，这些转换操作一般用于实现用户代码中的显式类型转换操作，或者用来处理本节开篇所提到的字节码指令集中数据类型相关指令无法与数据类型一一对应的问题。</p><p>&emsp;&emsp;Java虚拟机直接支持（即转换时无需显式的转换指令）以下数值类型的<strong>宽化类型转换</strong>（Widening Numeric Conversions，即小范围类型向大范围类型的安全转换）： </p><blockquote><ul><li>int类型到long、float或者double类型。 </li><li>long类型到float、double类型。 </li><li>float类型到double类型。</li></ul></blockquote><p>&emsp;&emsp;相对的，处理<strong>窄化类型转换</strong>（Narrowing Numeric Conversions）时，必须显式地使用转换指令来完成，这些转换指令包括：i2b、i2c、i2s、l2i、f2i、f2l、d2i、d2l和d2f。窄化类型转换可能会导致转换结果产生不同的正负号、不同的数量级的情况，转换过程很可能会导致数值的精度丢失。 </p><p>&emsp;&emsp;在将int或long类型窄化转换为整数类型T的时候，转换过程仅仅是简单地丢弃除最低位N个字节以外的内容，N是类型T的数据类型长度，这将可能导致转换结果与输入值有不同的正负号。这点很容易理解，因为原来符号位处于数值的最高位，高位被丢弃之后，转换结果的符号就取决于低N个字节的首位了。 </p><p>&emsp;&emsp;在将一个浮点值窄化转换为整数类型T（T限于int或long类型之一）的时候，将遵循以下转换规则： </p><blockquote><ul><li>如果浮点值是NaN，那转换结果就是int或long类型的0。 </li><li>如果浮点值不是无穷大的话，浮点值使用IEEE 754的向零舍入模式取整，获得整数值v，如果v在目标类型T（int或long）的表示范围之内，那转换结果就是v。 </li><li>否则，将根据v的符号，转换为T所能表示的最大或者最小正数。 </li></ul></blockquote><p>&emsp;&emsp;从double类型到float类型的窄化转换过程与IEEE 754中定义的一致，通过IEEE 754向最接近数舍入模式舍入得到一个可以使用float类型表示的数字。如果转换结果的绝对值太小而无法使用float来表示的话，将返回float类型的正负零。如果转换结果的绝对值太大而无法使用float来表示的话，将返回float类型的正负无穷大，对于double类型的NaN值将按规定转换为float类型的NaN值。 </p><p>&emsp;&emsp;尽管数据类型窄化转换可能会发生上限溢出、下限溢出和精度丢失等情况，但是Java虚拟机规范中明确规定数值类型的窄化转换指令永远不可能导致虚拟机抛出运行时异常。</p><h3 id="4-5-对象创建与访问指令"><a href="#4-5-对象创建与访问指令" class="headerlink" title="4.5 对象创建与访问指令"></a><strong>4.5 对象创建与访问指令</strong></h3><p>&emsp;&emsp;虽然类实例和数组都是对象，但Java虚拟机对类实例和数组的创建与操作使用了不同的字节码指令（在第7章会讲到数组和普通类的类型创建过程是不同的）。对象创建后，就可以通过对象访问指令获取对象实例或者数组实例中的字段或者数组元素，这些指令如下。 </p><blockquote><ul><li>创建类实例的指令：new。</li><li>创建数组的指令：newarray、anewarray、multianewarray。 </li><li>访问类字段（static字段，或者称为类变量）和实例字段（非static字段，或者称为实例变量）的指令：getfield、putfield、getstatic、putstatic。 </li><li>把一个数组元素加载到操作数栈的指令：baload、caload、saload、iaload、laload、 faload、daload、aaload。 </li><li>将一个操作数栈的值存储到数组元素中的指令：bastore、castore、sastore、iastore、 fastore、dastore、aastore。 </li><li>取数组长度的指令：arraylength。</li><li>检查类实例类型的指令：instanceof、checkcast。</li></ul></blockquote><h3 id="4-6-操作数栈管理指令"><a href="#4-6-操作数栈管理指令" class="headerlink" title="4.6 操作数栈管理指令"></a><strong>4.6 操作数栈管理指令</strong></h3><p>&emsp;&emsp;如同操作一个普通数据结构中的堆栈那样，Java虚拟机提供了一些用于直接操作操作数栈的指令，包括： </p><blockquote><ul><li>将操作数栈的栈顶一个或两个元素出栈：pop、pop2。</li><li>复制栈顶一个或两个数值并将复制值或双份的复制值重新压入栈顶：dup、dup2、 dup_x1、dup2_x1、dup_x2、dup2_x2。</li><li>将栈最顶端的两个数值互换：swap。</li></ul></blockquote><h3 id="4-7-控制转移指令"><a href="#4-7-控制转移指令" class="headerlink" title="4.7 控制转移指令"></a><strong>4.7 控制转移指令</strong></h3><p>&emsp;&emsp;控制转移指令可以让Java虚拟机有条件或无条件地从指定的位置指令而不是控制转移指令的下一条指令继续执行程序，从概念模型上理解，可以认为控制转移指令就是在有条件或无条件地修改PC寄存器的值。控制转移指令如下。 </p><blockquote><ul><li>条件分支：ifeq、iflt、ifle、ifne、ifgt、ifge、ifnull、ifnonnull、if_icmpeq、if_icmpne、 if_icmplt、if_icmpgt、if_icmple、if_icmpge、if_acmpeq和if_acmpne。 </li><li>复合条件分支：tableswitch、lookupswitch。 </li><li>无条件分支：goto、goto_w、jsr、jsr_w、ret。</li></ul></blockquote><p>&emsp;&emsp;在Java虚拟机中有专门的指令集用来处理int和reference类型的条件分支比较操作，为了可以无须明显标识一个实体值是否null，也有专门的指令用来检测null值。 </p><p>&emsp;&emsp;与前面算术运算时的规则一致，对于boolean类型、byte类型、char类型和short类型的条件分支比较操作，都是使用int类型的比较指令来完成，而对于long类型、float类型和double类型的条件分支比较操作，则会先执行相应类型的比较运算指令（dcmpg、dcmpl、fcmpg、fcmpl、lcmp，见4.3节），运算指令会返回一个整型值到操作数栈中，随后再执行int类型的条件分支比较操作来完成整个分支跳转。由于各种类型的比较最终都会转化为int类型的比较操作，int类型比较是否方便完善就显得尤为重要，所以Java虚拟机提供的int类型的条件分支指令是最为丰富和强大的。</p><h3 id="4-8-方法调用和返回指令"><a href="#4-8-方法调用和返回指令" class="headerlink" title="4.8 方法调用和返回指令"></a><strong>4.8 方法调用和返回指令</strong></h3><p>&emsp;&emsp;方法调用（分派、执行过程）将在<a href="../2019121001.html" title="Title">字节码执行引擎</a>具体讲解，这里仅列举以下5条用于方法调用的指令。 </p><blockquote><ul><li>invokevirtual指令用于调用对象的实例方法，根据对象的实际类型进行分派（虚方法分派），这也是Java语言中最常见的方法分派方式。</li><li>invokeinterface指令用于调用接口方法，它会在运行时搜索一个实现了这个接口方法的对象，找出适合的方法进行调用。 </li><li>invokespecial指令用于调用一些需要特殊处理的实例方法，包括实例初始化方法、私有方法和父类方法。 </li><li>invokestatic指令用于调用类方法（static方法）。 </li><li>invokedynamic指令用于在运行时动态解析出调用点限定符所引用的方法，并执行该方法，前面4条调用指令的分派逻辑都固化在Java虚拟机内部，而invokedynamic指令的分派逻辑是由用户所设定的引导方法决定的。</li></ul></blockquote><p>&emsp;&emsp;方法调用指令与数据类型无关，而方法返回指令是根据返回值的类型区分的，包括ireturn（当返回值是boolean、byte、char、short和int类型时使用）、lreturn、freturn、dreturn和areturn，另外还有一条return指令供声明为void的方法、实例初始化方法以及类和接口的类初始化方法使用。</p><h3 id="4-9-异常处理指令"><a href="#4-9-异常处理指令" class="headerlink" title="4.9 异常处理指令"></a><strong>4.9 异常处理指令</strong></h3><p>&emsp;&emsp;在Java程序中显式抛出异常的操作（throw语句）都由athrow指令来实现，除了用throw语句显式抛出异常情况之外，Java虚拟机规范还规定了许多运行时异常会在其他Java虚拟机指令检测到异常状况时自动抛出。例如，在前面介绍的整数运算中，当除数为零时，虚拟机会在idiv或ldiv指令中抛出ArithmeticException异常。 </p><p>&emsp;&emsp;而在Java虚拟机中，处理异常（catch语句）不是由字节码指令来实现的（很久之前曾经使用jsr和ret指令来实现，现在已经不用了），而是采用异常表来完成的。</p><h3 id="4-10-同步指令"><a href="#4-10-同步指令" class="headerlink" title="4.10 同步指令"></a><strong>4.10 同步指令</strong></h3><p>&emsp;&emsp;Java虚拟机可以支持方法级的同步和方法内部一段指令序列的同步，这两种同步结构都是使用<strong>管程</strong>（Monitor）来支持的。 </p><p>&emsp;&emsp;<strong>方法级的同步是隐式的</strong>，即<strong>无须通过字节码指令来控制</strong>，它实现在方法调用和返回操作之中。虚拟机可以从方法常量池的方法表结构中的ACC_SYNCHRONIZED访问标志得知一个方法是否声明为同步方法。当方法调用时，调用指令将会检查方法的ACC_SYNCHRONIZED访问标志是否被设置，如果设置了，执行线程就要求先成功持有管程，然后才能执行方法，最后当方法完成（无论是正常完成还是非正常完成）时释放管程。在方法执行期间，执行线程持有了管程，其他任何线程都无法再获取到同一个管程。如果一个同步方法执行期间抛出了异常，并且在方法内部无法处理此异常，那么这个同步方法所持有的管程将在异常抛到同步方法之外时自动释放。 </p><p>&emsp;&emsp;同步一段指令集序列通常是由Java语言中的synchronized语句块来表示的，Java虚拟机的指令集中有monitorenter和monitorexit两条指令来支持synchronized关键字的语义，正确实现synchronized关键字需要Javac编译器与Java虚拟机两者共同协作支持，譬如代码清单6-6中所示的代码。</p><figure class="highlight aspectj"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//代码清单6-6　代码同步演示</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">onlyMe</span> <span class="params">(Foo f)</span> </span>&#123; </span><br><span class="line"></span><br><span class="line">    <span class="keyword">synchronized</span> (f) &#123; </span><br><span class="line">        doSomething(); </span><br><span class="line">    &#125; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>&emsp;&emsp;编译后，这段代码生成的字节码序列如下：</p><figure class="highlight gauss"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">Method void onlyMe (Foo) </span><br><span class="line"><span class="number">0</span> aload_1                            <span class="comment">//将对象f入栈 </span></span><br><span class="line"><span class="number">1</span> dup                                <span class="comment">//复制栈顶元素（即f的引用） </span></span><br><span class="line"><span class="number">2</span> astore_2                           <span class="comment">//将栈顶元素存储到局部变量表Slot 2中 </span></span><br><span class="line"><span class="number">3</span> monitorenter                       <span class="comment">//以栈顶元素（即f）作为锁，开始同步 </span></span><br><span class="line"><span class="number">4</span> aload_0                            <span class="comment">//将局部变量Slot 0（即this指针）的元素入栈 </span></span><br><span class="line"><span class="number">5</span> invokevirtual <span class="meta">#5                   <span class="comment">//调用doSomething（）方法 </span></span></span><br><span class="line"><span class="number">8</span> aload_2                            <span class="comment">//将局部变量Slow 2的元素（即f）入栈 </span></span><br><span class="line"><span class="number">9</span> monitorexit                        <span class="comment">//退出同步 </span></span><br><span class="line"><span class="number">10</span> <span class="keyword">goto</span> <span class="number">18</span>                           <span class="comment">//方法正常结束，跳转到18返回 </span></span><br><span class="line"><span class="number">13</span> astore_3                          <span class="comment">//从这步开始是异常路径，见下面异常表的Taget 13 </span></span><br><span class="line"><span class="number">14</span> aload_2                           <span class="comment">//将局部变量Slow 2的元素（即f）入栈 </span></span><br><span class="line"><span class="number">15</span> monitorexit                       <span class="comment">//退出同步 </span></span><br><span class="line"><span class="number">16</span> aload_3                           <span class="comment">//将局部变量Slow 3的元素（即异常对象）入栈 </span></span><br><span class="line"><span class="number">17</span> athrow                            <span class="comment">//把异常对象重新抛出给onlyMe（）方法的调用者 </span></span><br><span class="line"><span class="number">18</span> <span class="keyword">return</span>                            <span class="comment">//方法正常返回 </span></span><br><span class="line"></span><br><span class="line">Exception table: </span><br><span class="line">FromTo Target <span class="built_in">Type</span> </span><br><span class="line"><span class="number">4</span>      <span class="number">10</span>     <span class="number">13</span> any </span><br><span class="line"><span class="number">13</span>     <span class="number">16</span>     <span class="number">13</span> any</span><br></pre></td></tr></table></figure><p>&emsp;&emsp;编译器必须确保无论方法通过何种方式完成，方法中调用过的每条monitorenter指令都必须执行其对应的monitorexit指令，而无论这个方法是正常结束还是异常结束。</p><p>&emsp;&emsp;从代码清单6-6的字节码序列中可以看到，为了保证在方法异常完成时monitorenter和monitorexit指令依然可以正确配对执行，编译器会自动产生一个异常处理器，这个异常处理器声明可处理所有的异常，它的目的就是用来执行monitorexit指令。</p><hr><p><em>参考博客和文章书籍等：</em></p><blockquote><p>《深入理解Java虚拟机》</p></blockquote><p><em>因博客主等未标明不可引用，若部分内容涉及侵权请及时告知，我会尽快修改和删除相关内容</em></p>]]></content>
    
    <summary type="html">
    
      简单介绍Java虚拟机中的类文件结构-字节码指令简介，包括：字节码与数据类型，加载和存储指令，运算指令，类型转换指令，对象创建与访问指令，操作数栈管理指令，控制转移指令，方法调用和返回指令，异常处理指令，同步指令等内容。
    
    </summary>
    
      <category term="技术文档" scheme="http://linyishui.top/categories/%E6%8A%80%E6%9C%AF%E6%96%87%E6%A1%A3/"/>
    
    
      <category term="java" scheme="http://linyishui.top/tags/java/"/>
    
      <category term="jvm" scheme="http://linyishui.top/tags/jvm/"/>
    
  </entry>
  
  <entry>
    <title>类文件结构-Class类文件的结构</title>
    <link href="http://linyishui.top/2019120401.html"/>
    <id>http://linyishui.top/2019120401.html</id>
    <published>2019-12-04T09:59:44.000Z</published>
    <updated>2020-01-10T03:12:08.802Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="类文件结构-Class类文件的结构"><a href="#类文件结构-Class类文件的结构" class="headerlink" title="类文件结构-Class类文件的结构"></a><strong>类文件结构-Class类文件的结构</strong></h1><h2 id="第三节-Class类文件的结构"><a href="#第三节-Class类文件的结构" class="headerlink" title="第三节 Class类文件的结构"></a><strong>第三节 Class类文件的结构</strong></h2><p>&emsp;&emsp;解析Class文件的数据结构是本章的最主要内容。Class文件是一组以<strong>8位字节</strong>为基础单位的二进制流，各个数据项目严格按照顺序紧凑地排列在Class文件之中，中间<strong>没有添加任何分隔符</strong>，这使得整个Class文件中存储的内容几乎全部都是程序运行的必要数据，没有空隙存在。当遇到需要占用8位字节以上空间的数据项时，则会按照高位在前的方式分割成若干个8位字节进行存储。</p><p>&emsp;&emsp;根据Java虚拟机规范的规定，Class文件格式采用一种类似于C语言结构体的伪结构来存储，这种伪结构中只有两种数据类型：<strong>无符号数</strong>和<strong>表</strong>，后面的解析都要以这两种数据类型为基础，所以这里要先讲明白这两个概念。</p><p>&emsp;&emsp;无符号数属于基本的数据类型，以<strong>u1、u2、u4、u8</strong>来分别代表1个字节、2个字节、 4个字节和8个字节的无符号数，无符号数可以用来描述数字、索引引用、数量值，或者按照UTF-8编码构成字符串值。</p><p>&emsp;&emsp;表是<strong>由多个无符号数或其他表作为数据项构成</strong>的复合数据类型，所有表都习惯性地以“_info”结尾。表用于描述有层次关系的复合结构的数据，整个Class文件本质上就是一张表，它由表6-1所示的数据项构成。</p><p><img src="https://pic-1258215793.cos.ap-shanghai.myqcloud.com/content/20191201/201912010115.png" alt="Class文件格式"></p><p>&emsp;&emsp;无论是无符号数还是表，当需要描述同一类型但数量不定的多个数据时，经常会使用一个前置的<strong>容量计数器</strong>加若干个连续的数据项的形式，这时候称这一系列连续的某一类型的数据为<strong>某一类型的集合</strong>。</p><p>&emsp;&emsp;Class的结构不像XML等描述语言，由于它没有任何分隔符号，所以在表6-1中的数据项，无论是顺序还是数量，都是被严格限定的，哪个字节代表什么含义，长度是多少，先后顺序如何，都不允许改变。接下来我们将一起看看这个表中各个数据项的具体含义。</p><h3 id="3-1-魔数与Class文件的版本"><a href="#3-1-魔数与Class文件的版本" class="headerlink" title="3.1 魔数与Class文件的版本"></a><strong>3.1 魔数与Class文件的版本</strong></h3><p>&emsp;&emsp;每个Class文件的头4个字节称为<strong>魔数</strong>（Magic Number），它的唯一作用是<strong>用于确定这个文件是否为一个能被虚拟机接受的Class文件</strong>。很多文件存储标准中都使用魔数来进行身份识别，譬如图片格式，如gif或jpeg等在文件头中都存有魔数。使用魔数而不是扩展名来进行识别主要是基于安全考虑，因为文件扩展名可以很随意地被改动。文件格式的制定者可以自由地选择魔数值，只要这个魔数值还没有被广泛采用过而且不会引起混淆即可。Class文件的魔数的获得很有“浪漫气息”，值为：0xCAFEBABE（咖啡宝贝？），这个魔数值在Java还被称做“Oak”语言的时候（大约是1991年前后）就已经确定下来了。它还有一段很有趣的历史，据Java开发小组最初的关键成员Patrick Naughton所说：“我们一直在寻找一些好玩的、容易记忆的东西，选择0xCAFEBABE是因为它象征着著名咖啡品牌Peet’s Coffee中深受欢迎的Baristas咖啡”，这个魔数似乎也预示着日后“Java”这个名称的出现。</p><p>&emsp;&emsp;紧接着魔数的4个字节存储的是Class文件的版本号：第5和第6个字节是<strong>次版本号</strong>（Minor Version），第7个和第8个字节是<strong>主版本号</strong>（Major Version）。Java的版本号是从45开始的，JDK 1.1之后的每个JDK大版本发布主版本号向上加1（JDK 1.0～1.1使用了45.0～45.3的版本号），高版本的JDK能向下兼容以前版本的Class文件，但不能运行以后版本的Class文件，即使文件格式并未发生变化。JDK1.1能支持版本号为45.0～45.65535的Class，无法执行版本号为46.0以上的 Class，而JDK 1.2则能支持45.0～46.65535的Class文件。现在，最新的JDK版本为1.7，可生成的Class文件主版本号的最大值为51.0。</p><p>&emsp;&emsp;为了讲解方便，作者准备了一段最简单的Java代码（如代码清单6-1所示）本章后面的讲解都将以这段小程序使用JDK 1.6编译输出的Class文件为基础来讲解。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> org.fenixsoft.clazz; </span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TestClass</span></span>&#123; </span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> m; </span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">inc</span><span class="params">()</span> </span>&#123; </span><br><span class="line">        <span class="keyword">return</span> m + <span class="number">1</span>; </span><br><span class="line">    &#125; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>&emsp;&emsp;图6-2显示的是使用十六进制编辑器WinHex打开这个Class文件的结果，可以清楚地看见开头4个字节的十六进制表示是0xCAFEBABE，代表次版本号的第5个和第6个字节值为0x0000，而主版本号的值为0x0032，也即是十进制的50，该版本号说明这个文件是可以被JDK 1.6或以上版本虚拟机执行的Class文件。</p><p><img src="https://pic-1258215793.cos.ap-shanghai.myqcloud.com/content/20191201/201912010116.png" alt="Java Class文件的结构"></p><p>&emsp;&emsp;表6-2列出了从JDK 1.1到JDK 1.7，主流JDK版本编译器输出的默认和可支持的Class文件版本号。</p><p><img src="https://pic-1258215793.cos.ap-shanghai.myqcloud.com/content/20191201/201912010117.png" alt="Class文件版本号"></p><h3 id="3-2-常量池"><a href="#3-2-常量池" class="headerlink" title="3.2 常量池"></a><strong>3.2 常量池</strong></h3><p>&emsp;&emsp;紧接着主次版本号之后的是<strong>常量池入口</strong>，常量池可以理解为<strong>Class文件之中的资源仓库</strong>，它是<strong>Class文件结构中与其他项目关联最多的数据类型</strong>，也是<strong>占用Class文件空间最大的数据项目之一</strong>，同时它还是在<strong>Class文件中第一个出现的表类型数据项目</strong>。</p><p>&emsp;&emsp;由于常量池中常量的数量是不固定的，所以在常量池的入口需要放置一项u2类型的数据，代表<strong>常量池容量计数值</strong>（constant_pool_count）。与Java中语言习惯不一样的是，<strong>这个容量计数是从1而不是0开始的</strong>，如图6-3所示，常量池容量（偏移地址：0x00000008）为十六进制数0x0016，即十进制的22，这就代表常量池中有21项常量，索引值范围为1～21。在Class文件格式规范制定之时，<strong>设计者将第0项常量空出来是有特殊考虑的，这样做的目的在于满足后面某些指向常量池的索引值的数据在特定情况下需要表达“不引用任何一个常量池项目”的含义，这种情况就可以把索引值置为0来表示</strong>。Class文件结构中只有常量池的容量计数是从1开始，对于其他集合类型，包括接口索引集合、字段表集合、方法表集合等的容量计数都与一般习惯相同，是从0开始的。</p><p><img src="https://pic-1258215793.cos.ap-shanghai.myqcloud.com/content/20191201/201912010118.png" alt="常量池结构"></p><p>&emsp;&emsp;常量池中主要存放两大类常量：<strong>字面量</strong>（Literal）和<strong>符号引用</strong>（Symbolic References）。字面量比较<strong>接近于Java语言层面的常量概念</strong>，如文本字符串、声明为final的常量值等。而符号引用则<strong>属于编译原理方面的概念</strong>，包括了下面三类常量： </p><blockquote><ul><li>类和接口的全限定名（Fully Qualified Name） </li><li>字段的名称和描述符（Descriptor） </li><li>方法的名称和描述符</li></ul></blockquote><p>&emsp;&emsp;Java代码在进行Javac编译的时候，并不像C和C++那样有“连接”这一步骤，而是在虚拟机加载Class文件的时候进行动态连接。也就是说，<strong>在Class文件中不会保存各个方法、字段的最终内存布局信息</strong>，因此<strong>这些字段、方法的符号引用不经过运行期转换的话无法得到真正的内存入口地址，也就无法直接被虚拟机使用</strong>。<strong>当虚拟机运行时，需要从常量池获得对应的符号引用，再在类创建时或运行时解析、翻译到具体的内存地址之中</strong>。关于类的创建和动态连接的内容，在下一章介绍虚拟机类加载过程时再进行详细讲解。 </p><p>&emsp;&emsp;常量池中每一项常量都是一个表，在JDK 1.7之前共有11种结构各不相同的表结构数据，在JDK 1.7中为了更好地支持动态语言调用，又额外增加了3种（CONSTANT_MethodHandle_info、CONSTANT_MethodType_info和CONSTANT_InvokeDynamic_info，本章不会涉及这3种新增的类型，在<a href="../2019121001.html" title="Title">字节码执行引擎</a>介绍字节码执行和方法调用时，将会详细讲解）。 </p><p>&emsp;&emsp;这14种表都有一个共同的特点，就是<strong>表开始的第一位是一个u1类型的标志位</strong>（tag，取值见表6-3中标志列），<strong>代表当前这个常量属于哪种常量类型</strong>。这14种常量类型所代表的具体含义见表6-3。</p><p><img src="https://pic-1258215793.cos.ap-shanghai.myqcloud.com/content/20191201/201912010119.png" alt="常量池的项目类型"></p><p>&emsp;&emsp;之所以说常量池是最烦琐的数据，是因为这14种常量类型各自均有自己的结构。回头看看图6-3中常量池的第一项常量，它的标志位（偏移地址：0x0000000A）是0x07，查表6-3的标志列发现这个常量属于CONSTANT_Class_info类型，此类型的常量代表一个类或者接口的符号引用。CONSTANT_Class_info的结构比较简单，见表6-4。</p><p><img src="https://pic-1258215793.cos.ap-shanghai.myqcloud.com/content/20191201/201912010120.png" alt="CONSTANT_Class_info的结构"></p><p>&emsp;&emsp;tag是标志位，上面已经讲过了，它用于区分常量类型；<strong>name_index是一个索引值，它指向常量池中一个CONSTANT_Utf8_info类型常量，此常量代表了这个类（或者接口）的全限定名</strong>，这里name_index值（偏移地址：0x0000000B）为0x0002，也即是指向了常量池中的第二项常量。继续从图6-3中查找第二项常量，它的标志位（地址：0x0000000D）是0x01，查表6-3可知确实是一个CONSTANT_Utf8_info类型的常量。CONSTANT_Utf8_info类型的结构见表6-5。</p><p><img src="https://pic-1258215793.cos.ap-shanghai.myqcloud.com/content/20191201/201912010121.png" alt="CONSTANT_Utf8_info型常量的结构"></p><p>&emsp;&emsp;length值说明了这个UTF-8编码的字符串长度是多少字节，它后面紧跟着的长度为length字节的连续数据是一个使用UTF-8缩略编码表示的字符串。UTF-8缩略编码与普通UTF-8编码的区别是：<strong>从’\u0001’到’\u007f’之间的字符（相当于1～127的ASCII码）的缩略编码使用一个字节表示，从’\u0080’到’\u07ff’之间的所有字符的缩略编码用两个字节表示，从’\u0800’到’\uffff’之间的所有字符的缩略编码就按照普通UTF-8编码规则使用三个字节表示</strong>。 </p><p>&emsp;&emsp;顺便提一下，<strong>由于Class文件中方法、字段等都需要引用CONSTANT_Utf8_info型常量来描述名称，所以CONSTANT_Utf8_info型常量的最大长度也就是Java中方法、字段名的最大长度</strong>。而这里的<strong>最大长度就是length的最大值，既u2类型能表达的最大值65535</strong>。<strong>所以Java程序中如果定义了超过64KB英文字符的变量或方法名，将会无法编译</strong>。 </p><p>&emsp;&emsp;本例中这个字符串的length值（偏移地址：0x0000000E）为0x001D，也就是长29字节，往后29字节正好都在1～127的ASCII码范围以内，内容为“org/fenixsoft/clazz/TestClass”，有兴趣的读者可以自己逐个字节换算一下，换算结果如图6-4选中的部分所示。</p><p><img src="https://pic-1258215793.cos.ap-shanghai.myqcloud.com/content/20191201/201912010122.png" alt="常量池UTF-8字符串结构"></p><figure class="highlight lsl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">--以上分析过程</span><br><span class="line"><span class="number">0</span>  <span class="number">1</span>  <span class="number">2</span>  <span class="number">3</span>  <span class="number">4</span>  <span class="number">5</span>  <span class="number">6</span>  <span class="number">7</span>  <span class="number">8</span>  <span class="number">9</span>  A  B  C  D  E  F</span><br><span class="line">CA FE BA BE <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">32</span> <span class="number">00</span> <span class="number">16</span> <span class="number">07</span> <span class="number">00</span> <span class="number">02</span> <span class="number">01</span> <span class="number">00</span> <span class="number">1</span>D</span><br><span class="line"><span class="number">6</span>F <span class="number">72</span> <span class="number">67</span> <span class="number">2</span>F <span class="number">66</span> <span class="number">65</span> <span class="number">6</span>E <span class="number">69</span> <span class="number">78</span> <span class="number">73</span> <span class="number">6</span>F <span class="number">66</span> <span class="number">74</span> <span class="number">2</span>F <span class="number">63</span> <span class="number">6</span>C</span><br><span class="line"><span class="number">61</span> <span class="number">7</span>A <span class="number">7</span>A <span class="number">2</span>F <span class="number">54</span> <span class="number">65</span> <span class="number">73</span> <span class="number">74</span> <span class="number">43</span> <span class="number">6</span>C <span class="number">61</span> <span class="number">73</span> <span class="number">73</span> <span class="number">07</span> <span class="number">00</span> <span class="number">04</span></span><br><span class="line">...</span><br><span class="line"></span><br><span class="line">cp_info</span><br><span class="line"><span class="number">07</span> tag=CONSTANT_Class_info</span><br><span class="line"><span class="number">00</span> <span class="number">02</span> name_index=<span class="number">0x0000000D</span>指向了常量池中的第二项常量<span class="number">01</span></span><br><span class="line"><span class="number">01</span> tag=CONSTANT_Utf8_info</span><br><span class="line"><span class="number">00</span> <span class="number">1</span>D length=<span class="number">29</span></span><br><span class="line"><span class="number">6</span>F <span class="number">72</span> <span class="number">67</span> <span class="number">2</span>F <span class="number">66</span> <span class="number">65</span> <span class="number">6</span>E <span class="number">69</span> <span class="number">78</span> <span class="number">73</span> <span class="number">6</span>F <span class="number">66</span> <span class="number">74</span> <span class="number">2</span>F <span class="number">63</span> <span class="number">6</span>C</span><br><span class="line"><span class="number">61</span> <span class="number">7</span>A <span class="number">7</span>A <span class="number">2</span>F <span class="number">54</span> <span class="number">65</span> <span class="number">73</span> <span class="number">74</span> <span class="number">43</span> <span class="number">6</span>C <span class="number">61</span> <span class="number">73</span> bytes=org/fenixsoft/clazz/TestClass</span><br></pre></td></tr></table></figure><p>&emsp;&emsp;到此为止，我们分析了TestClass.class常量池中21个常量中的两个，其余的19个常量都可以通过类似的方法计算出来。为了避免计算过程占用过多的版面，后续的19个常量的计算过程可以借助计算机来帮我们完成。在JDK的bin目录中，Oracle公司已经为我们准备好一个专门用于分析Class文件字节码的工具：<strong>javap</strong>，代码清单6-2中列出了使用javap工具的-verbose参数输出的TestClass.class文件字节码内容（此清单中省略了常量池以外的信息）。前面我们曾经提到过，Class文件中还有很多数据项都要引用常量池中的常量，所以代码清单6-2中的内容在后续的讲解过程中还要经常使用到。</p><figure class="highlight livescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">代码清单<span class="number">6</span>-<span class="number">2</span>　使用Javap命令输出常量表</span><br><span class="line">C：<span class="string">\&gt;javap-verbose</span> TestClass </span><br><span class="line">Compiled <span class="keyword">from</span><span class="string">"TestClass.java"</span> </span><br><span class="line">public <span class="class"><span class="keyword">class</span> <span class="title">org</span>.<span class="title">fenixsoft</span>.<span class="title">clazz</span>.<span class="title">TestClass</span> <span class="keyword">extends</span> <span class="title">java</span>.<span class="title">lang</span>.<span class="title">Object</span> </span></span><br><span class="line">        SourceFile:<span class="string">"TestClass.java"</span> </span><br><span class="line">        minor version:<span class="number">0</span></span><br><span class="line">        major version:<span class="number">50</span> </span><br><span class="line">        Constant pool: </span><br><span class="line">    <span class="keyword">const</span><span class="comment">#1 = class           #2;           //org/fenixsoft/clazz/TestClass </span></span><br><span class="line">    <span class="keyword">const</span><span class="comment">#2 = Asciz           org/fenixsoft/clazz/TestClass; </span></span><br><span class="line">    <span class="keyword">const</span><span class="comment">#3 = class           #4;           //java/lang/Object </span></span><br><span class="line">    <span class="keyword">const</span><span class="comment">#4 = Asciz           java/lang/Object; </span></span><br><span class="line">    <span class="keyword">const</span><span class="comment">#5 = Asciz           m; </span></span><br><span class="line">    <span class="keyword">const</span><span class="comment">#6 = Asciz           I; </span></span><br><span class="line">    <span class="keyword">const</span><span class="comment">#7 = Asciz           &lt;init&gt;; </span></span><br><span class="line">    <span class="keyword">const</span><span class="comment">#8 = Asciz           ()V; </span></span><br><span class="line">    <span class="keyword">const</span><span class="comment">#9 = Asciz           Code; </span></span><br><span class="line">    <span class="keyword">const</span><span class="comment">#10 = Method         #3.#11;       //java/lang/Object."&lt;init&gt;":()V </span></span><br><span class="line">    <span class="keyword">const</span><span class="comment">#11 = NameAndType    #7:#8;       //"&lt;init&gt;":()V </span></span><br><span class="line">    <span class="keyword">const</span><span class="comment">#12 = Asciz          LineNumberTable; </span></span><br><span class="line">    <span class="keyword">const</span><span class="comment">#13 = Asciz          LocalVariableTable; </span></span><br><span class="line">    <span class="keyword">const</span><span class="comment">#14 = Asciz          this; </span></span><br><span class="line">    <span class="keyword">const</span><span class="comment">#15 = Asciz          Lorg/fenixsoft/clazz/TestClass; </span></span><br><span class="line">    <span class="keyword">const</span><span class="comment">#16 = Asciz          inc; </span></span><br><span class="line">    <span class="keyword">const</span><span class="comment">#17 = Asciz          ()I; </span></span><br><span class="line">    <span class="keyword">const</span><span class="comment">#18 = Field          #1.#19;       //org/fenixsoft/clazz/TestClass.m:I </span></span><br><span class="line">    <span class="keyword">const</span><span class="comment">#19 = NameAndType    #5:#6;       //m:I </span></span><br><span class="line">    <span class="keyword">const</span><span class="comment">#20 = Asciz          SourceFile; </span></span><br><span class="line">    <span class="keyword">const</span><span class="comment">#21 = Asciz          TestClass.java;</span></span><br></pre></td></tr></table></figure><p>&emsp;&emsp;从代码清单6-2中可以看出，计算机已经帮我们把整个常量池的21项常量都计算了出来，并且第1、2项常量的计算结果与我们手工计算的结果一致。仔细看一下会发现，其中有一些常量似乎从来没有在代码中出现过，如“I”、“V”、“＜init＞”、“LineNumberTable”、 “LocalVariableTable”等，这些看起来在代码任何一处都没有出现过的常量是哪里来的呢？ </p><p>&emsp;&emsp;这部分自动生成的常量的确没有在Java代码里面直接出现过，但它们会被后面即将讲到的<strong>字段表</strong>（field_info）、<strong>方法表</strong>（method_info）、<strong>属性表</strong>（attribute_info）引用到，它们会用来描述一些不方便使用“固定字节”进行表达的内容。譬如描述方法的返回值是什么？有几个参数？每个参数的类型是什么？因为Java中的“类”是无穷无尽的，无法通过简单的无符号字节来描述一个方法用到了什么类，因此在描述方法的这些信息时，需要引用常量表中的符号引用进行表达。这部分内容将在后面进一步阐述。最后，作者将这14种常量项的结构定义总结为表6-6以供读者参考。</p><p><img src="https://pic-1258215793.cos.ap-shanghai.myqcloud.com/content/20191201/201912010123.png" alt="常量池中的11种数据类型的结构总表"></p><p><img src="https://pic-1258215793.cos.ap-shanghai.myqcloud.com/content/20191201/201912010124.png" alt="常量池中的11种数据类型的结构总表-续"></p><p><img src="https://pic-1258215793.cos.ap-shanghai.myqcloud.com/content/20191201/201912010159.png" alt="常量池中的11种数据类型的结构总表-续"></p><h3 id="3-3-访问标志"><a href="#3-3-访问标志" class="headerlink" title="3.3 访问标志"></a><strong>3.3 访问标志</strong></h3><p>&emsp;&emsp;在常量池结束之后，紧接着的2个字节代表<strong>访问标志</strong>（access_flags），这个标志<strong>用于识别一些类或接口层次的访问信息</strong>，包括：</p><blockquote><ul><li>这个Class是类还是接口；</li><li>是否定义为public类型；</li><li>是否定义为abstract类型；</li><li>如果是类的话，是否被声明为final，等等。</li></ul></blockquote><p>&emsp;&emsp;具体的标志位及标志的含义见表6-7。</p><p><img src="https://pic-1258215793.cos.ap-shanghai.myqcloud.com/content/20191201/201912010125.png" alt="访问标志"></p><p>&emsp;&emsp;access_flags中一共有16个标志位可以使用，当前只定义了其中8个，没有使用到的标志位要求一律为0。以代码清单6-1中的代码为例，TestClass是一个普通Java类，不是接口、枚举或者注解，被public关键字修饰但没有被声明为final和abstract，并且它使用了JDK 1.2之后的编译器进行编译，因此它的ACC_PUBLIC、ACC_SUPER标志应当为真，而ACC_FINAL、ACC_INTERFACE、ACC_ABSTRACT、ACC_SYNTHETIC、ACC_ANNOTATION、ACC_ENUM这6个标志应当为假，因此它的access_flags的值应为：0x0001|0x0020=0x0021。从图6-5中可以看出，access_flags标志（偏移地址：0x000000EF）的确为0x0021。</p><p><img src="https://pic-1258215793.cos.ap-shanghai.myqcloud.com/content/20191201/201912010126.png" alt="access_flags标志"></p><h3 id="3-4-类索引、父类索引与接口索引集合"><a href="#3-4-类索引、父类索引与接口索引集合" class="headerlink" title="3.4 类索引、父类索引与接口索引集合"></a><strong>3.4 类索引、父类索引与接口索引集合</strong></h3><p>&emsp;&emsp;<strong>类索引</strong>（this_class）和<strong>父类索引</strong>（super_class）都是一个u2类型的数据，而<strong>接口索引集合</strong>（interfaces）是一组u2类型的数据的集合，Class文件中由这三项数据来<strong>确定这个类的继承关系</strong>。<strong>类索引用于确定这个类的全限定名</strong>，<strong>父类索引用于确定这个类的父类的全限定名</strong>。由于Java语言不允许多重继承，所以父类索引只有一个，除了java.lang.Object之外，所有的Java类都有父类，因此除了java.lang.Object外，所有Java类的父类索引都不为0。<strong>接口索引集合就用来描述这个类实现了哪些接口</strong>，这些被实现的接口将按implements语句（如果这个类本身是一个接口，则应当是extends语句）后的接口顺序从左到右排列在接口索引集合中。 </p><p>&emsp;&emsp;类索引、父类索引和接口索引集合都按顺序排列在访问标志之后，类索引和父类索引用两个u2类型的索引值表示，它们各自指向一个类型为CONSTANT_Class_info的类描述符常量，通过CONSTANT_Class_info类型的常量中的索引值可以找到定义在CONSTANT_Utf8_info类型的常量中的全限定名字符串。图6-6演示了代码清单6-1的代码的类索引查找过程。 </p><p><img src="https://pic-1258215793.cos.ap-shanghai.myqcloud.com/content/20191201/201912010127.png" alt="类索引查找全限定名的过程"></p><p>&emsp;&emsp;对于接口索引集合，入口的第一项——u2类型的数据为<strong>接口计数器</strong>（interfaces_count），表示索引表的容量。如果该类没有实现任何接口，则该计数器值为0，后面接口的索引表不再占用任何字节。代码清单6-1中的代码的类索引、父类索引与接口表索引的内容如图6-7所示。</p><p><img src="https://pic-1258215793.cos.ap-shanghai.myqcloud.com/content/20191201/201912010128.png" alt="类索引、父类索引、接口索引集合"></p><p>&emsp;&emsp;从偏移地址0x000000F1开始的3个u2类型的值分别为0x0001、0x0003、0x0000，也就是类索引为1，父类索引为3，接口索引集合大小为0，查询前面代码清单6-2中javap命令计算出来的常量池，找出对应的类和父类的常量，结果如代码清单6-3所示。 </p><figure class="highlight delphi"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">代码清单<span class="number">6</span>-<span class="number">3</span>　部分常量池内容</span><br><span class="line"><span class="keyword">const</span> <span class="string">#1</span> = <span class="keyword">class</span>      <span class="string">#2</span>；        <span class="comment">//org/fenixsoft/clazz/TestClass </span></span><br><span class="line"><span class="keyword">const</span> <span class="string">#2</span> = Asciz      org/fenixsoft/clazz/TestClass； </span><br><span class="line"><span class="keyword">const</span> <span class="string">#3</span> = <span class="keyword">class</span>      <span class="string">#4</span>；        <span class="comment">//java/lang/Object </span></span><br><span class="line"><span class="keyword">const</span> <span class="string">#4</span> = Asciz      java/lang/<span class="keyword">Object</span>；</span><br></pre></td></tr></table></figure><h3 id="3-5-字段表集合"><a href="#3-5-字段表集合" class="headerlink" title="3.5 字段表集合"></a><strong>3.5 字段表集合</strong></h3><p>&emsp;&emsp;字段表（field_info）用于<strong>描述接口或者类中声明的变量</strong>。字段（field）包括<strong>类级变量</strong>以及<strong>实例级变量</strong>，但<strong>不包括在方法内部声明的局部变量</strong>。我们可以想一想在Java中描述一个字段可以包含什么信息？可以包括的信息有：</p><blockquote><ul><li><strong>字段的作用域</strong>（public、private、protected修饰符）</li><li><strong>是实例变量还是类变量</strong>（static修饰符）</li><li><strong>可变性</strong>（final）</li><li><strong>并发可见性</strong>（volatile修饰符，是否强制从主内存读写）</li><li><strong>可否被序列化</strong>（transient修饰符）</li><li><strong>字段数据类型</strong>（基本类型、对象、数组）</li><li><strong>字段名称</strong></li></ul></blockquote><p>&emsp;&emsp;上述这些信息中，各个修饰符都是布尔值，要么有某个修饰符，要么没有，很适合使用标志位来表示。而字段叫什么名字、字段被定义为什么数据类型，这些都是无法固定的，只能引用常量池中的常量来描述。表6-8中列出了字段表的最终格式。</p><p><img src="https://pic-1258215793.cos.ap-shanghai.myqcloud.com/content/20191201/201912010129.png" alt="字段表结构"></p><p>&emsp;&emsp;字段修饰符放在access_flags项目中，它与类中的access_flags项目是非常类似的，都是一个u2的数据类型，其中可以设置的标志位和含义如表6-9所示。</p><p><img src="https://pic-1258215793.cos.ap-shanghai.myqcloud.com/content/20191201/201912010130.png" alt="字段访问标志"></p><p>&emsp;&emsp;很明显，在实际情况中，ACC_PUBLIC、ACC_PRIVATE、ACC_PROTECTED三个标志最多只能选择其一，ACC_FINAL、ACC_VOLATILE不能同时选择。接口之中的字段必须有ACC_PUBLIC、ACC_STATIC、ACC_FINAL标志，这些都是由Java本身的语言规则所决定的。 </p><p>&emsp;&emsp;跟随access_flags标志的是两项索引值：name_index和descriptor_index。它们都是对常量池的引用，分别代表着字段的简单名称以及字段和方法的描述符。现在需要解释一下“简单名称”、“描述符”以及前面出现过多次的“全限定名”这三种特殊字符串的概念。 </p><p>&emsp;&emsp;<strong>全限定名</strong>和<strong>简单名称</strong>很好理解，以代码清单6-1中的代码为例，“org/fenixsoft/clazz/TestClass”是这个类的全限定名，仅仅是把类全名中的“.”替换成了“/”而已，为了使连续的多个全限定名之间不产生混淆，在使用时最后一般会加入一个“;”表示全限定名结束。简单名称是指没有类型和参数修饰的方法或者字段名称，这个类中的inc()方法和m字段的简单名称分别是“inc”和“m”。 </p><p>&emsp;&emsp;相对于全限定名和简单名称来说，方法和字段的描述符就要复杂一些。<strong>描述符</strong>的作用是用来描述字段的数据类型、方法的参数列表（包括数量、类型以及顺序）和返回值。根据描述符规则，基本数据类型（byte、char、double、float、int、long、short、boolean）以及代表无返回值的void类型都用一个大写字符来表示，而对象类型则用字符L加对象的全限定名来表示，详见表6-10。</p><p><img src="https://pic-1258215793.cos.ap-shanghai.myqcloud.com/content/20191201/201912010131.png" alt="描述符标识字符含义"></p><p>&emsp;&emsp;对于数组类型，每一维度将使用一个前置的“[”字符来描述，如一个定义为“java.lang.String[][]”类型的二维数组，将被记录为：“[[Ljava/lang/String;”，一个整型数组“int[]”将被记录为“[I”。 </p><p>&emsp;&emsp;用描述符来描述方法时，按照先参数列表，后返回值的顺序描述，参数列表按照参数的严格顺序放在一组小括号“()”之内。如方法void inc()的描述符为“()V”，方法java.lang.String toString()的描述符为“()Ljava/lang/String;”，方法int indexOf(char[]source, int sourceOffset, int sourceCount, char[] target, int targetOffset, int targetCount, int fromIndex）的描述符为“([CII[CIII）I”。 </p><p>&emsp;&emsp;对于代码清单6-1中的TestClass.class文件来说，字段表集合从地址0x000000F8开始，第一个u2类型的数据为容量计数器fields_count，如图6-8所示，其值为0x0001，说明这个类只有一个字段表数据。接下来紧跟着容量计数器的是access_flags标志，值为0x0002，代表private修饰符的ACC_PRIVATE标志位为真（ACC_PRIVATE标志的值为0x0002），其他修饰符为假。代表字段名称的name_index的值为0x0005，从代码清单6-2列出的常量表中可查得第5项常量是一个CONSTANT_Utf8_info类型的字符串，其值为“m”，代表字段描述符的descriptor_index的值为0x0006，指向常量池的字符串“I”，根据这些信息，我们可以推断出原代码定义的字段为：“private int m;”。</p><p>&emsp;&emsp;字段表都包含的固定数据项目到descriptor_index为止就结束了，不过在descriptor_index之后跟随着一个属性表集合用于存储一些额外的信息，字段都可以在属性表中描述零至多项的额外信息。对于本例中的字段m，它的属性表计数器为0，也就是没有需要额外描述的信息，但是，如果将字段m的声明改为“final static int m=123;”，那就可能会存在一项名称为ConstantValue的属性，其值指向常量123。关于attribute_info的其他内容，将在6.3.7节介绍属性表的数据项目时再进一步讲解。</p><p><img src="https://pic-1258215793.cos.ap-shanghai.myqcloud.com/content/20191201/201912010132.png" alt="字段表结构实例"></p><p>&emsp;&emsp;字段表集合中不会列出从超类或者父接口中继承而来的字段，但有可能列出原本Java代码之中不存在的字段，譬如在内部类中为了保持对外部类的访问性，会自动添加指向外部类实例的字段。另外，在Java语言中字段是无法重载的，两个字段的数据类型、修饰符不管是否相同，都必须使用不一样的名称，但是对于字节码来讲，如果两个字段的描述符不一致，那字段重名就是合法的。 </p><h3 id="3-6-方法表集合"><a href="#3-6-方法表集合" class="headerlink" title="3.6 方法表集合"></a><strong>3.6 方法表集合</strong></h3><p>&emsp;&emsp;如果理解了上一节关于字段表的内容，那本节关于方法表的内容将会变得很简单。Class文件存储格式中对方法的描述与对字段的描述几乎采用了完全一致的方式，方法表的结构如同字段表一样，依次包括了访问标志（access_flags）、名称索引（name_index）、描述符索引（descriptor_index）、属性表集合（attributes）几项，见表6-11。这些数据项目的含义也非常类似，仅在访问标志和属性表集合的可选项中有所区别。</p><p><img src="https://pic-1258215793.cos.ap-shanghai.myqcloud.com/content/20191201/201912010133.png" alt="方法表结构"></p><p>&emsp;&emsp;因为volatile关键字和transient关键字不能修饰方法，所以方法表的访问标志中没有了ACC_VOLATILE标志和ACC_TRANSIENT标志。与之相对的，synchronized、native、strictfp和abstract关键字可以修饰方法，所以方法表的访问标志中增加了ACC_SYNCHRONIZED、ACC_NATIVE、ACC_STRICTFP和ACC_ABSTRACT标志。对于方法表，所有标志位及其取值可参见表6-12。</p><p><img src="https://pic-1258215793.cos.ap-shanghai.myqcloud.com/content/20191201/201912010134.png" alt="方法访问标志"></p><p>&emsp;&emsp;行文至此，也许有的读者会产生疑问，方法的定义可以通过访问标志、名称索引、描述符索引表达清楚，但方法里面的代码去哪里了？方法里的Java代码，经过编译器编译成字节码指令后，存放在方法属性表集合中一个名为“Code”的属性里面，属性表作为Class文件格式中最具扩展性的一种数据项目，将在3.7节中详细讲解。</p><p>&emsp;&emsp;我们继续以代码清单6-1中的Class文件为例对方法表集合进行分析，如图6-9所示，方法表集合的入口地址为：0x00000101，第一个u2类型的数据（即是计数器容量）的值为0x0002，代表集合中有两个方法（这两个方法为编译器添加的实例构造器＜init＞和源码中 的方法inc()）。第一个方法的访问标志值为0x001，也就是只有ACC_PUBLIC标志为真， 名称索引值为0x0007，查代码清单6-2的常量池得方法名为“＜init＞”，描述符索引值为 0x0008，对应常量为“()V”，属性表计数器attributes_count的值为0x0001就表示此方法的属 性表集合有一项属性，属性名称索引为0x0009，对应常量为“Code”，说明此属性是方法的字 节码描述。</p><p><img src="https://pic-1258215793.cos.ap-shanghai.myqcloud.com/content/20191201/201912010135.png" alt="方法表结构实例"></p><p>&emsp;&emsp;与字段表集合相对应的，如果父类方法在子类中没有被重写（Override），方法表集合中就不会出现来自父类的方法信息。但同样的，有可能会出现由编译器自动添加的方法，最典型的便是类构造器“＜clinit＞”方法和实例构造器“＜init＞”方法。 </p><p>&emsp;&emsp;在Java语言中，要重载（Overload）一个方法，除了要与原方法具有相同的简单名称之外，还要求必须拥有一个与原方法不同的<strong>特征签名</strong>（Java代码的方法特征签名只包括了方法名称、参数顺序及参数类型，而字节码的特征签名还包括方法返回值以及受查异常表），特征签名就是一个方法中各个参数在常量池中的字段符号引用的集合，也就是因为返回值不会包含在特征签名中，因此Java语言里面是无法仅仅依靠返回值的不同来对一个已有方法进行重载的。但是在Class文件格式中，特征签名的范围更大一些，只要描述符不是完全一致的两个方法也可以共存。也就是说，如果两个方法有相同的名称和特征签名，但返回值不同，那么也是可以合法共存于同一个Class文件中的。 </p><h3 id="3-6-属性表集合"><a href="#3-6-属性表集合" class="headerlink" title="3.6 属性表集合"></a><strong>3.6 属性表集合</strong></h3><p>&emsp;&emsp;属性表（attribute_info）在前面的讲解之中已经出现过数次，在Class文件、字段表、方法表都可以携带自己的属性表集合，以用于描述某些场景专有的信息。 </p><p>&emsp;&emsp;与Class文件中其他的数据项目要求严格的顺序、长度和内容不同，属性表集合的限制稍微宽松了一些，不再要求各个属性表具有严格顺序，并且只要不与已有属性名重复，任何人实现的编译器都可以向属性表中写入自己定义的属性信息，Java虚拟机运行时会忽略掉它不认识的属性。为了能正确解析Class文件，《Java虚拟机规范（第2版）》中预定义了9项虚拟机实现应当能识别的属性，而在最新的《Java虚拟机规范（Java SE 7）》版中，预定义属性已经增加到21项，具体内容见表6-13。下文中将对其中一些属性中的关键常用的部分进行讲解。</p><p><img src="https://pic-1258215793.cos.ap-shanghai.myqcloud.com/content/20191201/201912010136.png" alt="虚拟机规范预定义额属性"></p><p><img src="https://pic-1258215793.cos.ap-shanghai.myqcloud.com/content/20191201/201912010137.png" alt="虚拟机规范预定义额属性"></p><p><img src="https://pic-1258215793.cos.ap-shanghai.myqcloud.com/content/20191201/201912010138.png" alt="虚拟机规范预定义额属性"></p><p>&emsp;&emsp;对于每个属性，它的名称需要从常量池中引用一个CONSTANT_Utf8_info类型的常量来表示，而属性值的结构则是完全自定义的，只需要通过一个u4的长度属性去说明属性值所占用的位数即可。一个符合规则的属性表应该满足表6-14中所定义的结构。</p><p><img src="https://pic-1258215793.cos.ap-shanghai.myqcloud.com/content/20191201/201912010139.png" alt="属性表结构"></p><h4 id="3-6-1-Code属性"><a href="#3-6-1-Code属性" class="headerlink" title="3.6.1 Code属性"></a><strong>3.6.1 Code属性</strong></h4><p>&emsp;&emsp;Java程序方法体中的代码经过Javac编译器处理后，最终变为字节码指令存储在Code属性内。Code属性出现在方法表的属性集合之中，但并非所有的方法表都必须存在这个属性，譬如接口或者抽象类中的方法就不存在Code属性，如果方法表有Code属性存在，那么它的结构将如表6-15所示。</p><p><img src="https://pic-1258215793.cos.ap-shanghai.myqcloud.com/content/20191201/201912010140.png" alt="Code属性表结构"></p><p>&emsp;&emsp;attribute_name_index是一项<strong>指向CONSTANT_Utf8_info型常量的索引</strong>，常量值固定为“Code”，它代表了该属性的属性名称，attribute_length指示了属性值的长度，由于属性名称索引与属性长度一共为6字节，所以属性值的长度固定为整个属性表长度减去6个字节。 </p><p>&emsp;&emsp;max_stack代表了<strong>操作数栈（Operand Stacks）深度的最大值</strong>。在方法执行的任意时刻，操作数栈都不会超过这个深度。虚拟机运行的时候需要根据这个值来分配栈帧（Stack Frame）中的操作栈深度。 </p><p>&emsp;&emsp;max_locals代表了局部变量表所需的存储空间。在这里，max_locals的单位是Slot，Slot是虚拟机为局部变量分配内存所使用的最小单位。对于byte、char、float、int、short、boolean和returnAddress等长度不超过32位的数据类型，每个局部变量占用1个Slot，而double和long这两种64位的数据类型则需要两个Slot来存放。</p><p>&emsp;&emsp;方法参数（包括实例方法中的隐藏参 数“this”）、显式异常处理器的参数（Exception Handler Parameter，就是try-catch语句中catch 块所定义的异常）、方法体中定义的局部变量都需要使用局部变量表来存放。另外，并不是在方法中用到了多少个局部变量，就把这些局部变量所占Slot之和作为max_locals的值，原因是局部变量表中的Slot可以重用，当代码执行超出一个局部变量的作用域时，这个局部变量所占的Slot可以被其他局部变量所使用，Javac编译器会根据变量的作用域来分配Slot给各个变量使用，然后计算出max_locals的大小。 </p><p>&emsp;&emsp;code_length和code用来存储Java源程序编译后生成的字节码指令。code_length代表字节码长度，code是用于存储字节码指令的一系列字节流。既然叫字节码指令，那么每个指令就是一个u1类型的单字节，当虚拟机读取到code中的一个字节码时，就可以对应找出这个字节码代表的是什么指令，并且可以知道这条指令后面是否需要跟随参数，以及参数应当如何理解。我们知道一个u1数据类型的取值范围为0x00～0xFF，对应十进制的0～255，也就是一共可以表达256条指令，目前，Java虚拟机规范已经定义了其中约200条编码值对应的指令含义，编码与指令之间的对应关系可查阅本书的附录B“虚拟机字节码指令表”。 </p><p>&emsp;&emsp;关于code_length，有一件值得注意的事情，虽然它是一个u4类型的长度值，理论上最大值可以达到(2^32)-1，但是虚拟机规范中明确限制了一个方法不允许超过65535条字节码指令，即它实际只使用了u2的长度，如果超过这个限制，Javac编译器也会拒绝编译。一般来讲，编写Java代码时只要不是刻意去编写一个超长的方法来为难编译器，是不太可能超过这个最大值的限制。但是，某些特殊情况，例如在编译一个很复杂的JSP文件时，某些JSP编译器会把JSP内容和页面输出的信息归并于一个方法之中，就可能因为方法生成字节码超长的原因而导致编译失败。 </p><p>&emsp;&emsp;Code属性是Class文件中最重要的一个属性，如果把一个Java程序中的信息分为代码（Code，方法体里面的Java代码）和元数据（Metadata，包括类、字段、方法定义及其他信息）两部分，那么在整个Class文件中，Code属性用于描述代码，所有的其他数据项目都用于描述元数据。了解Code属性是学习后面关于字节码执行引擎内容的必要基础，能直接阅读字节码也是工作中分析Java代码语义问题的必要工具和基本技能，因此作者准备了一个比较详细的实例来讲解虚拟机是如何使用这个属性的。 </p><p>&emsp;&emsp;继续以代码清单6-1的TestClass.class文件为例，如图6-10所示，这是上一节分析过的实例构造器“＜init＞”方法的Code属性。它的操作数栈的最大深度和本地变量表的容量都为0x0001，字节码区域所占空间的长度为0x0005。虚拟机读取到字节码区域的长度后，按照顺序依次读入紧随的5个字节，并根据字节码指令表翻译出所对应的字节码指令。翻译“2A B7 00 0A B1”的过程为： </p><blockquote><ol><li>读入2A，查表得0x2A对应的指令为aload_0，这个指令的含义是将第0个Slot中为reference类型的本地变量推送到操作数栈顶。 </li><li>读入B7，查表得0xB7对应的指令为invokespecial，这条指令的作用是以栈顶的reference类型的数据所指向的对象作为方法接收者，调用此对象的实例构造器方法、private方法或者它的父类的方法。这个方法有一个u2类型的参数说明具体调用哪一个方法，它指向常量池中的一个CONSTANT_Methodref_info类型常量，即此方法的方法符号引用。</li><li>读入00 0A，这是invokespecial的参数，查常量池得0x000A对应的常量为实例构造器“＜init＞”方法的符号引用。 </li><li>读入B1，查表得0xB1对应的指令为return，含义是返回此方法，并且返回值为void。这条指令执行后，当前方法结束。</li></ol></blockquote><p><img src="https://pic-1258215793.cos.ap-shanghai.myqcloud.com/content/20191201/201912010141.png" alt="Code属性结构实例"></p><p>&emsp;&emsp;这段字节码虽然很短，但是至少可以看出它的执行过程中的数据交换、方法调用等操作都是基于栈（操作栈）的。我们可以初步猜测：<strong>Java虚拟机执行字节码是基于栈的体系结构</strong>。但是与一般基于堆栈的零字节指令又不太一样，某些指令（如invokespecial）后面还会带有参数，关于虚拟机字节码执行的讲解是后面两章的重点，我们不妨把这里的疑问放到<a href="../2019121001.html" title="Title">字节码执行引擎</a>去解决。 </p><p>&emsp;&emsp;我们再次使用javap命令把此Class文件中的另外一个方法的字节码指令也计算出来，结果如代码清单6-4所示。 </p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line">代码清单<span class="number">6</span><span class="number">-4</span>　用javap命令计算字节码指令</span><br><span class="line"></span><br><span class="line"><span class="comment">//原始Java代码 </span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TestClass</span>&#123;</span> </span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> m;  </span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">inc</span><span class="params">()</span> </span>&#123; </span><br><span class="line">        <span class="keyword">return</span> m + <span class="number">1</span>;  </span><br><span class="line">    &#125; </span><br><span class="line">&#125; </span><br><span class="line"></span><br><span class="line">C: \&gt; javap-verbose TestClass </span><br><span class="line"><span class="comment">//常量表部分的输出见代码清单6-1, 因版面原因这里省略掉 </span></span><br><span class="line">&#123; </span><br><span class="line">  <span class="keyword">public</span> org.fenixsoft.clazz.TestClass();  </span><br><span class="line">    Code:  </span><br><span class="line">        Stack=<span class="number">1</span>, Locals=<span class="number">1</span>, Args_size=<span class="number">1</span> </span><br><span class="line">        <span class="number">0</span>: aload_0 </span><br><span class="line">        <span class="number">1</span>: invokespecial  #<span class="number">10</span>;   <span class="comment">//Method java/lang/Object."&lt;init&gt;": ()V </span></span><br><span class="line">        <span class="number">4</span>: <span class="keyword">return</span> </span><br><span class="line">    LineNumberTable:  </span><br><span class="line">        line <span class="number">3</span>: <span class="number">0</span> </span><br><span class="line">    </span><br><span class="line">    LocalVariableTable:  </span><br><span class="line">        Start Length Slot Name Signature </span><br><span class="line">        <span class="number">0</span>     <span class="number">5</span>      <span class="number">0</span>    <span class="keyword">this</span> Lorg/fenixsoft/clazz/TestClass;  </span><br><span class="line">        </span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">inc</span><span class="params">()</span></span>;  </span><br><span class="line">    Code:  </span><br><span class="line">        Stack=<span class="number">2</span>, Locals=<span class="number">1</span>, Args_size=<span class="number">1</span> </span><br><span class="line">        <span class="number">0</span>: aload_0 </span><br><span class="line">        <span class="number">1</span>: getfield#<span class="number">18</span>; <span class="comment">//Field m: I </span></span><br><span class="line">        <span class="number">4</span>: iconst_1 </span><br><span class="line">        <span class="number">5</span>: iadd </span><br><span class="line">        <span class="number">6</span>: ireturn </span><br><span class="line">    </span><br><span class="line">    LineNumberTable:  </span><br><span class="line">        line <span class="number">8</span>: <span class="number">0</span> </span><br><span class="line">    </span><br><span class="line">    LocalVariableTable:  </span><br><span class="line">        Start Length Slot Name Signature </span><br><span class="line">        <span class="number">0</span>     <span class="number">7</span>      <span class="number">0</span>    <span class="keyword">this</span> Lorg/fenixsoft/clazz/TestClass; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>&emsp;&emsp;如果大家注意到javap中输出的“Args_size”的值，可能会有疑问：这个类有两个方法——实例构造器＜init＞()和inc()，这两个方法很明显都是没有参数的，为什么Args_size会为1？而且无论是在参数列表里还是方法体内，都没有定义任何局部变量，那Locals又为什么会等于1？如果有这样的疑问，大家可能是忽略了一点：在任何实例方法里面，都可以通过“this”关键字访问到此方法所属的对象。这个访问机制对Java程序的编写很重要，而它的实现却非常简单，仅仅是通过Javac编译器编译的时候把对this关键字的访问转变为对一个普通方法参数的访问，然后在虚拟机调用实例方法时自动传入此参数而已。因此<strong>在实例方法的局部变量表中至少会存在一个指向当前对象实例的局部变量</strong>，<strong>局部变量表中也会预留出第一个Slot位来存放对象实例的引用</strong>，方法参数值从1开始计算。这个处理只对实例方法有效，如果代码清单6-1中的inc()方法声明为static，那Args_size就不会等于1而是等于0了。 </p><p>&emsp;&emsp;在字节码指令之后的是这个方法的显式异常处理表（下文简称异常表）集合，异常表对于Code属性来说并不是必须存在的，如代码清单6-4中就没有异常表生成。 </p><p>&emsp;&emsp;异常表的格式如表6-16所示，它包含4个字段，这些字段的含义为：如果当字节码在第start_pc行（行并非指Java源码的行号，而是字节码相对于方法体开始的偏移量）到第end_pc行之间（不含第end_pc行）出现了类型为catch_type或者其子类的异常（catch_type为指向一个CONSTANT_Class_info型常量的索引），则转到第handler_pc行继续处理。当catch_type的值为0时，代表任意异常情况都需要转向到handler_pc处进行处理。</p><p><img src="https://pic-1258215793.cos.ap-shanghai.myqcloud.com/content/20191201/201912010142.png" alt="属性表结构"></p><p>&emsp;&emsp;异常表实际上是Java代码的一部分，编译器使用异常表而不是简单的跳转命令来实现Java异常及finally处理机制（JDK 1.4.2之前Javac编译器采用jsr和ret指令实现finally语句，但之后已经改为编译器自动在每段可能的分支路径之后都将finally语句块内容冗余生成一遍，在JDK 1.7中已完全禁止了Class文件中出现jsr和ret语句，会在类加载的字节码校验阶段抛出异常）。 </p><p>&emsp;&emsp;代码清单6-5是一段演示异常表如何运作的例子，这段代码主要演示了在字节码层面中try-catch-finally是如何实现的。在阅读字节码之前，大家不妨先看看下面的Java源码，想一下这段代码的返回值在出现异常和不出现异常的情况下分别应该是多少？ </p><figure class="highlight lsl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line">代码清单<span class="number">6</span><span class="number">-5</span>　异常表运作演示</span><br><span class="line"></span><br><span class="line"><span class="comment">//Java源码 </span></span><br><span class="line">public int inc()&#123; </span><br><span class="line">    int x;  </span><br><span class="line">    try&#123; </span><br><span class="line">        x = <span class="number">1</span>;  </span><br><span class="line">        return x;  </span><br><span class="line">    &#125; catch(Exception e) &#123; </span><br><span class="line">        x = <span class="number">2</span>;  </span><br><span class="line">        return x;  </span><br><span class="line">    &#125; finally &#123; </span><br><span class="line">        x = <span class="number">3</span>;  </span><br><span class="line">    &#125; </span><br><span class="line">&#125; </span><br><span class="line"></span><br><span class="line"><span class="comment">//编译后的ByteCode字节码及异常表 </span></span><br><span class="line">public int inc();  </span><br><span class="line">    Code： </span><br><span class="line">        Stack=<span class="number">1</span>，Locals=<span class="number">5</span>，Args_size=<span class="number">1</span> </span><br><span class="line">        <span class="number">0</span>：iconst_1 <span class="comment">//try块中的x=1 </span></span><br><span class="line">        <span class="number">1</span>：istore_1 </span><br><span class="line">        <span class="number">2</span>：iload_1 <span class="comment">//保存x到returnValue中，此时x=1 </span></span><br><span class="line">        <span class="number">3</span>：istore <span class="number">4</span> </span><br><span class="line">        <span class="number">5</span>：iconst_3 <span class="comment">//finaly块中的x=3 </span></span><br><span class="line">        <span class="number">6</span>：istore_1 </span><br><span class="line">        <span class="number">7</span>：iload <span class="number">4</span> <span class="comment">//将returnValue中的值放到栈顶，准备给ireturn返回 </span></span><br><span class="line">        <span class="number">9</span>：ireturn <span class="number">10</span>：astore_2<span class="comment">//给catch中定义的Exception e赋值，存储在Slot 2中 </span></span><br><span class="line">        <span class="number">11</span>：iconst_2 <span class="comment">//catch块中的x=2 </span></span><br><span class="line">        <span class="number">12</span>：istore_1 </span><br><span class="line">        <span class="number">13</span>：iload_1 <span class="comment">//保存x到returnValue中，此时x=2 </span></span><br><span class="line">        <span class="number">14</span>：istore <span class="number">4</span> </span><br><span class="line">        <span class="number">16</span>：iconst_3 <span class="comment">//finaly块中的x=3 </span></span><br><span class="line">        <span class="number">17</span>：istore_1 </span><br><span class="line">        <span class="number">18</span>：iload <span class="number">4</span> <span class="comment">//将returnValue中的值放到栈顶，准备给ireturn返回 </span></span><br><span class="line">        <span class="number">20</span>：ireturn </span><br><span class="line">        <span class="number">21</span>：astore_3 <span class="comment">//如果出现了不属于java.lang.Exception及其子类的异常才会走到这里 </span></span><br><span class="line">        <span class="number">22</span>：iconst_3 <span class="comment">//finaly块中的x=3 </span></span><br><span class="line">        <span class="number">23</span>：istore_1 </span><br><span class="line">        <span class="number">24</span>：aload_3 <span class="comment">//将异常放置到栈顶，并抛出 </span></span><br><span class="line">        <span class="number">25</span>：athrow </span><br><span class="line">    Exception table： </span><br><span class="line">        from to target type </span><br><span class="line">        <span class="number">0</span>    <span class="number">5</span>  <span class="number">10</span>     Class java/lang/Exception </span><br><span class="line">        <span class="number">0</span>    <span class="number">5</span>  <span class="number">21</span>     any </span><br><span class="line">        <span class="number">10</span>   <span class="number">16</span> <span class="number">21</span>     any</span><br></pre></td></tr></table></figure><p>&emsp;&emsp;编译器为这段Java源码生成了3条异常表记录，对应3条可能出现的代码执行路径。从Java代码的语义上讲，这3条执行路径分别为： </p><blockquote><ul><li>如果try语句块中出现属于Exception或其子类的异常，则转到catch语句块处理。 </li><li>如果try语句块中出现不属于Exception或其子类的异常，则转到finally语句块处理。 </li><li>如果catch语句块中出现任何异常，则转到finally语句块处理。 </li></ul></blockquote><p>&emsp;&emsp;返回到我们上面提出的问题，这段代码的返回值应该是多少？对Java语言熟悉的读者应该很容易说出答案：如果没有出现异常，返回值是1；如果出现了Exception异常，返回值是2；如果出现了Exception以外的异常，方法非正常退出，没有返回值。我们一起来分析一下字节码的执行过程，从字节码的层面上看看为何会有这样的返回结果。 </p><p>&emsp;&emsp;字节码中第0～4行所做的操作就是将整数1赋值给变量x，并且将此时x的值复制一份副本到最后一个本地变量表的Slot中（这个Slot里面的值在ireturn指令执行前将会被重新读到操作栈顶，作为方法返回值使用。为了讲解方便，作者给这个Slot起了个名字：returnValue）。 </p><p>&emsp;&emsp;如果这时没有出现异常，则会继续走到第5～9行，将变量x赋值为3，然后将之前保存在returnValue中的整数1读入到操作栈顶，最后ireturn指令会以int形式返回操作栈顶中的值，方法结束。如果出现了异常，PC寄存器指针转到第10行，第10～20行所做的事情是将2赋值给变量x，然后将变量x此时的值赋给returnValue，最后再将变量x的值改为3。方法返回前同样将returnValue中保留的整数2读到了操作栈顶。从第21行开始的代码，作用是变量x的值赋为3，并将栈顶的异常抛出，方法结束。 </p><p>&emsp;&emsp;尽管大家都知道这段代码出现异常的概率非常小，但并不影响它为我们演示异常表的作用。如果大家到这里仍然对字节码的运作过程比较模糊，其实也不要紧，关于虚拟机执行字节码的过程，<a href="../2019121001.html" title="Title">字节码执行引擎</a>中将会有更详细的讲解。 </p><h4 id="3-6-2-Exceptions属性"><a href="#3-6-2-Exceptions属性" class="headerlink" title="3.6.2 Exceptions属性"></a><strong>3.6.2 Exceptions属性</strong></h4><p>&emsp;&emsp;这里的Exceptions属性是在方法表中与Code属性平级的一项属性，读者不要与前面刚刚讲解完的异常表产生混淆。Exceptions属性的作用是列举出方法中可能抛出的受查异常（Checked Excepitons），也就是方法描述时在throws关键字后面列举的异常。它的结构见表6-17。</p><p><img src="https://pic-1258215793.cos.ap-shanghai.myqcloud.com/content/20191201/201912010143.png" alt="属性表结构"></p><p>&emsp;&emsp;Exceptions属性中的number_of_exceptions项表示方法可能抛出number_of_exceptions种受查异常，每一种受查异常使用一个exception_index_table项表示，exception_index_table是一个指向常量池中CONSTANT_Class_info型常量的索引，代表了该受查异常的类型。</p><h4 id="3-6-3-LineNumberTable属性"><a href="#3-6-3-LineNumberTable属性" class="headerlink" title="3.6.3 LineNumberTable属性"></a><strong>3.6.3 LineNumberTable属性</strong></h4><p>&emsp;&emsp;LineNumberTable属性用于描述Java源码行号与字节码行号（字节码的偏移量）之间的对应关系。它并不是运行时必需的属性，但默认会生成到Class文件之中，可以在Javac中分别使用-g：none或-g：lines选项来取消或要求生成这项信息。如果选择不生成LineNumberTable属性，对程序运行产生的最主要的影响就是当抛出异常时，堆栈中将不会显示出错的行号，并且在调试程序的时候，也无法按照源码行来设置断点。LineNumberTable属性的结构见表618。</p><p><img src="https://pic-1258215793.cos.ap-shanghai.myqcloud.com/content/20191201/201912010144.png" alt="LineNumberTable属性结构"></p><p>&emsp;&emsp;line_number_table是一个数量为line_number_table_length、类型为line_number_info的集合，line_number_info表包括了start_pc和line_number两个u2类型的数据项，前者是字节码行号，后者是Java源码行号。 </p><h4 id="3-6-4-LocalVariableTable属性"><a href="#3-6-4-LocalVariableTable属性" class="headerlink" title="3.6.4 LocalVariableTable属性"></a><strong>3.6.4 LocalVariableTable属性</strong></h4><p>&emsp;&emsp;LocalVariableTable属性用于描述栈帧中局部变量表中的变量与Java源码中定义的变量之间的关系，它也不是运行时必需的属性，但默认会生成到Class文件之中，可以在Javac中分别使用-g：none或-g：vars选项来取消或要求生成这项信息。如果没有生成这项属性，最大的影响就是当其他人引用这个方法时，所有的参数名称都将会丢失，IDE将会使用诸如arg0、arg1之类的占位符代替原有的参数名，这对程序运行没有影响，但是会对代码编写带来较大不便，而且在调试期间无法根据参数名称从上下文中获得参数值。LocalVariableTable属性的结构见表6-19。</p><p><img src="https://pic-1258215793.cos.ap-shanghai.myqcloud.com/content/20191201/201912010145.png" alt="LocalVariableTable属性结构"></p><p>&emsp;&emsp;其中，local_variable_info项目代表了一个栈帧与源码中的局部变量的关联，结构见表6-20。</p><p><img src="https://pic-1258215793.cos.ap-shanghai.myqcloud.com/content/20191201/201912010146.png" alt="local_variable_info项目结构"></p><p>&emsp;&emsp;start_pc和length属性分别代表了这个局部变量的生命周期开始的字节码偏移量及其作用范围覆盖的长度，两者结合起来就是这个局部变量在字节码之中的作用域范围。 </p><p>&emsp;&emsp;name_index和descriptor_index都是指向常量池中CONSTANT_Utf8_info型常量的索引，分别代表了局部变量的名称以及这个局部变量的描述符。 </p><p>&emsp;&emsp;index是这个局部变量在栈帧局部变量表中Slot的位置。当这个变量数据类型是64位类型时（double和long），它占用的Slot为index和index+1两个。 </p><p>&emsp;&emsp;顺便提一下，在JDK 1.5引入泛型之后，LocalVariableTable属性增加了一个“姐妹属性”：LocalVariableTypeTable，这个新增的属性结构与LocalVariableTable非常相似，仅仅是把记录的字段描述符的descriptor_index替换成了字段的特征签名（Signature），对于非泛型类型来说，描述符和特征签名能描述的信息是基本一致的，但是泛型引入之后，由于描述符中泛型的参数化类型被擦除掉[3]，描述符就不能准确地描述泛型类型了，因此出现了 LocalVariableTypeTable。 </p><h4 id="3-6-5-SourceFile属性"><a href="#3-6-5-SourceFile属性" class="headerlink" title="3.6.5 SourceFile属性"></a><strong>3.6.5 SourceFile属性</strong></h4><p>&emsp;&emsp;SourceFile属性用于记录生成这个Class文件的源码文件名称。这个属性也是可选的，可以分别使用Javac的-g：none或-g：source选项来关闭或要求生成这项信息。在Java中，对于大多数的类来说，类名和文件名是一致的，但是有一些特殊情况（如内部类）例外。如果不生成这项属性，当抛出异常时，堆栈中将不会显示出错代码所属的文件名。这个属性是一个定长的属性，其结构见表6-21。</p><p><img src="https://pic-1258215793.cos.ap-shanghai.myqcloud.com/content/20191201/201912010147.png" alt="SourceFile属性结构"></p><p>&emsp;&emsp;sourcefile_index数据项是指向常量池中CONSTANT_Utf8_info型常量的索引，常量值是源码文件的文件名。</p><h4 id="3-6-6-ConstantValue属性"><a href="#3-6-6-ConstantValue属性" class="headerlink" title="3.6.6 ConstantValue属性"></a><strong>3.6.6 ConstantValue属性</strong></h4><p>&emsp;&emsp;ConstantValue属性的作用是通知虚拟机自动为静态变量赋值。只有被static关键字修饰的 变量（类变量）才可以使用这项属性。类似“int x=123”和“static int x=123”这样的变量定义在Java程序中是非常常见的事情，但虚拟机对这两种变量赋值的方式和时刻都有所不同。对于非static类型的变量（也就是实例变量）的赋值是在实例构造器＜init＞方法中进行的；而对于类变量，则有两种方式可以选择：在类构造器＜clinit＞方法中或者使用ConstantValue属性。目前Sun Javac编译器的选择是：如果同时使用final和static来修饰一个变量（按照习惯，这里称“常量”更贴切），并且这个变量的数据类型是基本类型或者java.lang.String的话，就生成ConstantValue属性来进行初始化，如果这个变量没有被final修饰，或者并非基本类型及字符串，则将会选择在＜clinit＞方法中进行初始化。 </p><p>&emsp;&emsp;虽然有final关键字才更符合“ConstantValue”的语义，但虚拟机规范中并没有强制要求字段必须设置了ACC_FINAL标志，只要求了有ConstantValue属性的字段必须设置ACC_STATIC标志而已，对final关键字的要求是Javac编译器自己加入的限制。而对ConstantValue的属性值只能限于基本类型和String，不过作者不认为这是什么限制，因为此属性的属性值只是一个常量池的索引号，由于Class文件格式的常量类型中只有与基本属性和字符串相对应的字面量，所以就算ConstantValue属性想支持别的类型也无能为力。ConstantValue属性的结构见表6-22。</p><p><img src="https://pic-1258215793.cos.ap-shanghai.myqcloud.com/content/20191201/201912010148.png" alt="ConstantValue属性结构"></p><p>&emsp;&emsp;从数据结构中可以看出，ConstantValue属性是一个定长属性，它的attribute_length数据项值必须固定为2。constantvalue_index数据项代表了常量池中一个字面量常量的引用，根据字段类型的不同，字面量可以是CONSTANT_Long_info、CONSTANT_Float_info、 CONSTANT_Double_info、CONSTANT_Integer_info、CONSTANT_String_info常量中的一种。 </p><h4 id="3-6-7-InnerClasses属性"><a href="#3-6-7-InnerClasses属性" class="headerlink" title="3.6.7 InnerClasses属性"></a><strong>3.6.7 InnerClasses属性</strong></h4><p>&emsp;&emsp;InnerClasses属性用于记录内部类与宿主类之间的关联。如果一个类中定义了内部类，那编译器将会为它以及它所包含的内部类生成InnerClasses属性。该属性的结构见表6-23。</p><p><img src="https://pic-1258215793.cos.ap-shanghai.myqcloud.com/content/20191201/201912010149.png" alt="InnerClasses属性结构"></p><p>&emsp;&emsp;数据项number_of_classes代表需要记录多少个内部类信息，每一个内部类的信息都由一个inner_classes_info表进行描述。inner_classes_info表的结构见表6-24。</p><p><img src="https://pic-1258215793.cos.ap-shanghai.myqcloud.com/content/20191201/201912010150.png" alt="inner_classes_info表结构"></p><p>&emsp;&emsp;inner_class_info_index和outer_class_info_index都是指向常量池中CONSTANT_Class_info型常量的索引，分别代表了内部类和宿主类的符号引用。</p><p>&emsp;&emsp;inner_name_index是指向常量池中CONSTANT_Utf8_info型常量的索引，代表这个内部类的名称，如果是匿名内部类，那么这项值为0。 </p><p>&emsp;&emsp;inner_class_access_flags是内部类的访问标志，类似于类的access_flags，它的取值范围见表6-25。</p><p><img src="https://pic-1258215793.cos.ap-shanghai.myqcloud.com/content/20191201/201912010151.png" alt="inner_class_access_flags标志"></p><h4 id="3-6-8-Deprecated及Synthetic属性"><a href="#3-6-8-Deprecated及Synthetic属性" class="headerlink" title="3.6.8 Deprecated及Synthetic属性"></a><strong>3.6.8 Deprecated及Synthetic属性</strong></h4><p>&emsp;&emsp;Deprecated和Synthetic两个属性都属于标志类型的布尔属性，只存在有和没有的区别，没有属性值的概念。 </p><p>&emsp;&emsp;Deprecated属性用于表示某个类、字段或者方法，已经被程序作者定为不再推荐使用，它可以通过在代码中使用@deprecated注释进行设置。 </p><p>&emsp;&emsp;Synthetic属性代表此字段或者方法并不是由Java源码直接产生的，而是由编译器自行添加的，在JDK 1.5之后，标识一个类、字段或者方法是编译器自动产生的，也可以设置它们访问标志中的ACC_SYNTHETIC标志位，其中最典型的例子就是Bridge Method。所有由非用户代码产生的类、方法及字段都应当至少设置Synthetic属性和ACC_SYNTHETIC标志位中的一项，唯一的例外是实例构造器“＜init＞”方法和类构造器“＜clinit＞”方法。 </p><p>&emsp;&emsp;Deprecated和Synthetic属性的结构非常简单，见表6-26。</p><p><img src="https://pic-1258215793.cos.ap-shanghai.myqcloud.com/content/20191201/201912010152.png" alt="Deprecated及Synthetic属性结构"></p><p>&emsp;&emsp;其中attribute_length数据项的值必须为0x00000000，因为没有任何属性值需要设置。 </p><h4 id="3-6-9-StackMapTable属性"><a href="#3-6-9-StackMapTable属性" class="headerlink" title="3.6.9 StackMapTable属性"></a><strong>3.6.9 StackMapTable属性</strong></h4><p>&emsp;&emsp;StackMapTable属性在JDK 1.6发布后增加到了Class文件规范中，它是一个复杂的变长属性，位于Code属性的属性表中。这个属性会在虚拟机类加载的字节码验证阶段被新类型检查验证器（Type Checker）使用（见3.2节），目的在于代替以前比较消耗性能的基于数据流分析的类型推导验证器。 </p><p>&emsp;&emsp;这个类型检查验证器最初来源于Sheng Liang（听名字似乎是虚拟机团队中的华裔成员）为Java ME CLDC实现的字节码验证器。新的验证器在同样能保证Class文件合法性的前提下，省略了在运行期通过数据流分析去确认字节码的行为逻辑合法性的步骤，而是在编译阶段将一系列的验证类型（Verification Types）直接记录在Class文件之中，通过检查这些验证 类型代替了类型推导过程，从而大幅提升了字节码验证的性能。这个验证器在JDK 1.6中首次提供，并在JDK 1.7中强制代替原本基于类型推断的字节码验证器。关于这个验证器的工作原理，《Java虚拟机规范（Java SE 7版）》花费了整整120页的篇幅来讲解描述，并且分析证明新验证方法的严谨性，作者在此不再赘述。 </p><p>&emsp;&emsp;StackMapTable属性中包含零至多个栈映射帧（Stack Map Frames），每个栈映射帧都显式或隐式地代表了一个字节码偏移量，用于表示该执行到该字节码时局部变量表和操作数栈的验证类型。类型检查验证器会通过检查目标方法的局部变量和操作数栈所需要的类型来确定一段字节码指令是否符合逻辑约束。StackMapTable属性的结构见表6-27。</p><p><img src="https://pic-1258215793.cos.ap-shanghai.myqcloud.com/content/20191201/201912010153.png" alt="StackMapTable属性结构"></p><p>&emsp;&emsp;《Java虚拟机规范（Java SE 7版）》明确规定：在版本号大于或等于50.0的Class文件中，如果方法的Code属性中没有附带StackMapTable属性，那就意味着它带有一个隐式的StackMap属性。这个StackMap属性的作用等同于number_of_entries值为0的StackMapTable属性。一个方法的Code属性最多只能有一个StackMapTable属性，否则将抛出ClassFormatError异常。</p><h4 id="3-6-10-Signature属性"><a href="#3-6-10-Signature属性" class="headerlink" title="3.6.10 Signature属性"></a><strong>3.6.10 Signature属性</strong></h4><p>&emsp;&emsp;Signature属性在JDK 1.5发布后增加到了Class文件规范之中，它是一个可选的定长属性，可以出现于类、属性表和方法表结构的属性表中。在JDK 1.5中大幅增强了Java语言的语法，在此之后，任何类、接口、初始化方法或成员的泛型签名如果包含了类型变量（Type Variables）或参数化类型（Parameterized Types），则Signature属性会为它记录泛型签名信息。之所以要专门使用这样一个属性去记录泛型类型，是因为Java语言的泛型采用的是擦除法实现的伪泛型，在字节码（Code属性）中，泛型信息编译（类型变量、参数化类型）之后都通通被擦除掉。使用擦除法的好处是实现简单（主要修改Javac编译器，虚拟机内部只做了很少的改动）、非常容易实现Backport，运行期也能够节省一些类型所占的内存空间。但坏处是运行期就无法像C#等有真泛型支持的语言那样，将泛型类型与用户定义的普通类型同等对待，例如运行期做反射时无法获得到泛型信息。Signature属性就是为了弥补这个缺陷而增设的，现在Java的反射API能够获取泛型类型，最终的数据来源也就是这个属性。关于Java泛型、Signature属性和类型擦除，在第10章介绍编译器优化的时候会通过一个具体的例子来讲解。Signature属性的结构见表6-28。</p><p><img src="https://pic-1258215793.cos.ap-shanghai.myqcloud.com/content/20191201/201912010154.png" alt="Signature属性结构"></p><p>&emsp;&emsp;其中signature_index项的值必须是一个对常量池的有效索引。常量池在该索引处的项必须是CONSTANT_Utf8_info结构，表示类签名、方法类型签名或字段类型签名。如果当前的Signature属性是类文件的属性，则这个结构表示类签名，如果当前的Signature属性是方法表的属性，则这个结构表示方法类型签名，如果当前Signature属性是字段表的属性，则这个结构表示字段类型签名。 </p><h4 id="3-6-11-BootstrapMethods属性"><a href="#3-6-11-BootstrapMethods属性" class="headerlink" title="3.6.11 BootstrapMethods属性"></a><strong>3.6.11 BootstrapMethods属性</strong></h4><p>&emsp;&emsp;BootstrapMethods属性在JDK 1.7发布后增加到了Class文件规范之中，它是一个复杂的变长属性，位于类文件的属性表中。这个属性用于保存invokedynamic指令引用的引导方法限定符。《Java虚拟机规范（Java SE 7版）》规定，如果某个类文件结构的常量池中曾经出现过CONSTANT_InvokeDynamic_info类型的常量，那么这个类文件的属性表中必须存在一个明确的BootstrapMethods属性，另外，即使CONSTANT_InvokeDynamic_info类型的常量在常量池中出现过多次，类文件的属性表中最多也只能有一个BootstrapMethods属性。BootstrapMethods属性与JSR-292中的InvokeDynamic指令和java.lang.Invoke包关系非常密切，要介绍这个属性的作用，必须先弄清楚InovkeDynamic指令的运作原理，作者将在<a href="../2019121001.html" title="Title">字节码执行引擎</a>专门用1节篇幅去介绍它们，在此先暂时略过。 </p><p>&emsp;&emsp;目前的Javac暂时无法生成InvokeDynamic指令和BootstrapMethods属性，必须通过一些非常规的手段才能使用到它们，也许在不久的将来，等JSR-292更加成熟一些，这种状况就会改变。BootstrapMethods属性的结构见表6-29。</p><p><img src="https://pic-1258215793.cos.ap-shanghai.myqcloud.com/content/20191201/201912010155.png" alt="BootstrapMethods属性结构"></p><p>&emsp;&emsp;其中引用到的bootstrap_method结构见表6-30。</p><p><img src="https://pic-1258215793.cos.ap-shanghai.myqcloud.com/content/20191201/201912010156.png" alt="bootstrap_method属性结构"></p><p>&emsp;&emsp;BootstrapMethods属性中，num_bootstrap_methods项的值给出了bootstrap_methods[]数组中的引导方法限定符的数量。而bootstrap_methods[]数组的每个成员包含了一个指向常量池CONSTANT_MethodHandle结构的索引值，它代表了一个引导方法，还包含了这个引导方法静态参数的序列（可能为空）。</p><blockquote><p>bootstrap_methods[]数组中的每个成员必须包含以下3项内容。 </p><ul><li>bootstrap_method_ref：bootstrap_method_ref项的值必须是一个对常量池的有效索引。常 量池在该索引处的值必须是一个CONSTANT_MethodHandle_info结构。</li><li>num_bootstrap_arguments：num_bootstrap_arguments项的值给出了bootstrap_arguments[]数 组成员的数量。 </li><li>bootstrap_arguments[]：bootstrap_arguments[]数组的每个成员必须是一个对常量池的有效 索引。常量池在该索引处必须是下列结构之一：CONSTANT_String_info、 CONSTANT_Class_info、CONSTANT_Integer_info、CONSTANT_Long_info、 CONSTANT_Float_info、CONSTANT_Double_info、CONSTANT_MethodHandle_info或 CONSTANT_MethodType_info。 </li></ul></blockquote><hr><p><em>参考博客和文章书籍等：</em></p><blockquote><p>《深入理解Java虚拟机》</p></blockquote><p><em>因博客主等未标明不可引用，若部分内容涉及侵权请及时告知，我会尽快修改和删除相关内容</em></p>]]></content>
    
    <summary type="html">
    
      简单介绍Java虚拟机中的类文件结构-Class类文件的结构，包括：魔数与Class文件的版本，常量池，访问标志，类索引、父类索引与接口索引集合，字段表集合，方法表集合，属性表集合（Code属性、Exceptions属性、LineNumberTable属性、LocalVariableTable属性、SourceFile属性、ConstantValue属性、InnerClasses属性、Deprecated及Synthetic属性、StackMapTable属性、Signature属性、BootstrapMethods属性）等内容。
    
    </summary>
    
      <category term="技术文档" scheme="http://linyishui.top/categories/%E6%8A%80%E6%9C%AF%E6%96%87%E6%A1%A3/"/>
    
    
      <category term="java" scheme="http://linyishui.top/tags/java/"/>
    
      <category term="jvm" scheme="http://linyishui.top/tags/jvm/"/>
    
  </entry>
  
  <entry>
    <title>类文件结构</title>
    <link href="http://linyishui.top/2019120301.html"/>
    <id>http://linyishui.top/2019120301.html</id>
    <published>2019-12-03T02:17:54.000Z</published>
    <updated>2020-01-10T03:11:43.144Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="类文件结构"><a href="#类文件结构" class="headerlink" title="类文件结构"></a><strong>类文件结构</strong></h1><h2 id="第一节-概述"><a href="#第一节-概述" class="headerlink" title="第一节 概述"></a><strong>第一节 概述</strong></h2><p>&emsp;&emsp;记得在第一节计算机程序课上老师就讲过：“计算机只认识0和1，所以我们写的程序需要被编译器翻译成由0和1构成的二进制格式才能被计算机执行”。10多年的时间过去了，今天的计算机仍然只能识别0和1，但由于最近10年内虚拟机及建立在虚拟机之上的大量程序语言如雨后春笋般出现并蓬勃发展，将我们编写的<strong>程序编译成二进制本地机器码（Native Code）已不再是唯一的选择</strong>，越来越多的程序语言选择了与操作系统和机器指令集无关的、平台中立的格式作为程序编译后的存储格式。</p><hr><h2 id="第二节-无关性的基石"><a href="#第二节-无关性的基石" class="headerlink" title="第二节 无关性的基石"></a><strong>第二节 无关性的基石</strong></h2><p>&emsp;&emsp;如果计算机的CPU指令集就只有x86一种，操作系统就只有Windows一种，那也许就不会有Java语言的出现。Java在刚刚诞生之时曾经提出过一个非常著名的宣传口号：“一次编写，到处运行（Write Once, Run Anywhere）”，这句话充分表达了软件开发人员对冲破平台界限的渴求。在无时无刻不充满竞争的IT领域，不可能只有Wintel存在，我们也不希望只有Wintel存在，各种不同的硬件体系结构和不同的操作系统定将会长期并存发展。“与平台无关”的理想最终实现在操作系统的应用层上：<strong>Sun公司及其他虚拟机提供商发布了许多可以运行在各种不同平台上的虚拟机，这些虚拟机都可以载入和执行同一种平台无关的字节码</strong>，从而实现程序的“一次编写，到处运行”。</p><p>&emsp;&emsp;各种不同平台的虚拟机与所有平台都统一使用的程序存储格式—<strong>字节码</strong>（ByteCode）是构成平台无关性的基石，但本节标题中刻意省略了“平台”二字，那是因为笔者注意到虚拟机的另外一种中立的特性—如今语言无关性越来越被开发者所重视。到今天为止，或许大部分程序员都还认为Java虚拟机执行Java程序是一件理所当然和天经地义的事情。但在Java发展之初，设计者们就曾经考虑过并实现了让其他语言运行在Java虚拟机之上的可能性，他们在发布规范文档的时候，也刻意把Java的规范拆分成了Java语言规范《The Java Language Specification》及Java虚拟机规范《The Java Virtual Machine Specification》。并且在1997年发布的第一版Java虚拟机规范中就曾经承诺过：“In the future,we will consider bounded extensions to the Java virtual machine to provide better support for other languages”（在未来，我们会对Java虚拟机进行适当的扩展，以便更好地支持其他语言运行于JVM之上），<strong>当Java虚拟机发展到JDK 1.7~1.8的时候，JVM设计者通过JSR-292基本兑现了这个承诺</strong>。</p><p>&emsp;&emsp;时至今日，商业机构和开源机构已经在Java语言之外发展出一大批在Java虚拟机之上运行的语言，如Clojure、Groovy、JRuby、Jython、Scala，等等。使用过这些语言的开发者可能还不是非常多，但是听说过的人肯定已经不少，随着时间的推移，谁能保证日后Java虚拟机在语言无关性上的优势不会赶上甚至超越它在平台无关性上的优势呢？</p><p>&emsp;&emsp;<strong>实现语言无关性的基础仍然是虚拟机和字节码存储格式</strong>，使用Java编译器可以把Java代码编译为存储字节码的Class文件，使用JRuby等其他语言的编译器一样可以把程序代码编译成Class文件，虚拟机并不关心Class的来源是什么语言，只要它符合Class文件应有的结构就可以在Java虚拟机中运行，如图6-1所示。</p><p><img src="https://pic-1258215793.cos.ap-shanghai.myqcloud.com/content/20191201/201912010114.png" alt="Java虚拟机提供的语言无关性"></p><p>&emsp;&emsp;<strong>Java语言中的各种变量、关键字和运算符号的语义最终都是由多条字节码命令组合而成的</strong>，因此字节码命令所能提供的语义描述能力肯定会比Java语言本身更强大。因此，有一些Java语言本身无法有效支持的语言特性并不代表字节码本身无法有效支持，这也为其他语言实现一些有别于Java的语言特性提供了基础。</p><hr><h2 id="第三节-Class类文件的结构"><a href="#第三节-Class类文件的结构" class="headerlink" title="第三节 Class类文件的结构"></a><strong>第三节 Class类文件的结构</strong></h2><p>&emsp;&emsp;<a href="../2019120401.html" title="Title">类文件结构-Class类文件的结构</a></p><hr><h2 id="第四节-字节码指令简介"><a href="#第四节-字节码指令简介" class="headerlink" title="第四节 字节码指令简介"></a><strong>第四节 字节码指令简介</strong></h2><p>&emsp;&emsp;<a href="../2019120501.html" title="Title">类文件结构-字节码指令简介</a></p><hr><h2 id="第五节-公有设计和私有实现"><a href="#第五节-公有设计和私有实现" class="headerlink" title="第五节 公有设计和私有实现"></a><strong>第五节 公有设计和私有实现</strong></h2><p>&emsp;&emsp;Java虚拟机规范描绘了Java虚拟机应有的共同程序存储格式：<strong>Class文件格式</strong>以及<strong>字节码指令集</strong>。这些内容与硬件、操作系统及具体的Java虚拟机实现之间是完全独立的，虚拟机实现者可能更愿意把它们看做是程序在各种Java平台实现之间互相安全地交互的手段。</p><p>&emsp;&emsp;理解公有设计与私有实现之间的分界线是非常有必要的，Java虚拟机实现必须能够读取 Class文件并精确实现包含在其中的Java虚拟机代码的语义。拿着Java虚拟机规范一成不变地 逐字实现其中要求的内容当然是一种可行的途径，但一个优秀的虚拟机实现，在满足虚拟机 规范的约束下对具体实现做出修改和优化也是完全可行的，并且虚拟机规范中明确鼓励实现 者这样做。只要优化后Class文件依然可以被正确读取，并且包含在其中的语义能得到完整的 保持，那实现者就可以选择任何方式去实现这些语义，虚拟机后台如何处理Class文件完全是 实现者自己的事情，只要它在外部接口上看起来与规范描述的一致即可[1]。 </p><p>&emsp;&emsp;虚拟机实现者可以使用这种伸缩性来让Java虚拟机获得更高的性能、更低的内存消耗或 者更好的可移植性，选择哪种特性取决于Java虚拟机实现的目标和关注点是什么。虚拟机实 现的方式主要有以下两种： </p><blockquote><ul><li>将输入的Java虚拟机代码在加载或执行时翻译成另外一种虚拟机的指令集。 </li><li>将输入的Java虚拟机代码在加载或执行时翻译成宿主机CPU的本地指令集（即JIT代码生 成技术）。 </li></ul></blockquote><p>&emsp;&emsp;精确定义的虚拟机和目标文件格式不应当对虚拟机实现者的创造性产生太多的限制，Java虚拟机应被设计成可以允许有众多不同的实现，并且各种实现可以在保持兼容性的 同时提供不同的、新的、有趣的解决方案。 </p><hr><h2 id="第六节-Class文件结构的发展"><a href="#第六节-Class文件结构的发展" class="headerlink" title="第六节 Class文件结构的发展"></a><strong>第六节 Class文件结构的发展</strong></h2><p>&emsp;&emsp;Class文件结构自Java虚拟机规范第1版订立以来，已经有十多年的历史。这十多年 间，Java技术体系有了翻天覆地的改变，JDK的版本号已经从1.0提升到了1.7。相对于语言、 API以及Java技术体系中其他方面的变化，Class文件结构一直处于比较稳定的状态，Class文 件的主体结构、字节码指令的语义和数量几乎没有出现过变动[1]，所有对Class文件格式的改 进，都集中在向访问标志、属性表这些在设计上就可扩展的数据结构中添加内容。 </p><p>&emsp;&emsp;如果以《Java虚拟机规范（第2版）》为基准进行比较的话，那么在后续Class文件格式 的发展过程中，访问标志里新加入了ACC_SYNTHETIC、ACC_ANNOTATION、 ACC_ENUM、ACC_BRIDGE、ACC_VARARGS共5个标志。而属性表集合中，在JDK 1.5到 JDK 1.7版本之间一共增加了12项新的属性，这些属性大部分用于支持Java中许多新出现的语 言特性，如枚举、变长参数、泛型、动态注解等。还有一些是为了支持性能改进和调试信 息，譬如JDK 1.6的新类型校验器的StackMapTable属性和对非Java代码调试中用到的 SourceDebugExtension属性。</p><p>&emsp;&emsp;Class文件格式所具备的平台中立（不依赖于特定硬件及操作系统）、紧凑、稳定和可扩 展的特点，是Java技术体系实现平台无关、语言无关两项特性的重要支柱。 </p><hr><h2 id="第七节-总结"><a href="#第七节-总结" class="headerlink" title="第七节 总结"></a><strong>第七节 总结</strong></h2><p>&emsp;&emsp;Class文件是Java虚拟机执行引擎的数据入口，也是Java技术体系的基础构成之一。了解 Class文件的结构对后面进一步了解虚拟机执行引擎有很重要的意义。 </p><p>&emsp;&emsp;本章详细讲解了Class文件结构中的各个组成部分，以及每个部分的定义、数据结构和使 用方法。通过代码清单6-1的Java代码与它的Class文件样例，以实战的方式演示了Class的数 据是如何存储和访问的。从第7章开始，我们将以动态的、运行时的角度去看看字节码流在 虚拟机执行引擎中是怎样被解释执行的。</p><hr><p><em>参考博客和文章书籍等：</em></p><blockquote><p>《深入理解Java虚拟机》</p></blockquote><p><em>因博客主等未标明不可引用，若部分内容涉及侵权请及时告知，我会尽快修改和删除相关内容</em></p>]]></content>
    
    <summary type="html">
    
      简单介绍Java虚拟机中的类文件结构，包括：概述，无关性的基石，Class类文件的结构，字节码指令简介，公有设计和私有实现，Class文件结构的发展，总结等内容。
    
    </summary>
    
      <category term="技术文档" scheme="http://linyishui.top/categories/%E6%8A%80%E6%9C%AF%E6%96%87%E6%A1%A3/"/>
    
    
      <category term="java" scheme="http://linyishui.top/tags/java/"/>
    
      <category term="jvm" scheme="http://linyishui.top/tags/jvm/"/>
    
  </entry>
  
  <entry>
    <title>虚拟机调优案例分析与实战</title>
    <link href="http://linyishui.top/2019120101.html"/>
    <id>http://linyishui.top/2019120101.html</id>
    <published>2019-12-01T12:53:58.000Z</published>
    <updated>2020-01-10T03:12:26.494Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="虚拟机调优案例分析与实战"><a href="#虚拟机调优案例分析与实战" class="headerlink" title="虚拟机调优案例分析与实战"></a><strong>虚拟机调优案例分析与实战</strong></h1><h2 id="第一节-概述"><a href="#第一节-概述" class="headerlink" title="第一节 概述"></a><strong>第一节 概述</strong></h2><p>&emsp;&emsp;<a href="../2019112501.html" title="Title">虚拟机性能监控和故障处理工具</a>介绍了处理Java虚拟机内存问题的知识与工具，在处理实际项目的问题时，除了知识与工具外，经验也是一个很重要的因素。因此本章将分享几个比较有代表性的实际案例。考虑到虚拟机故障处理和调优主要面向各类服务端应用，而大部分Java程序员较少有机会直接接触生产环境的服务器，因此本章还准备了一个所有开发人员都能够进行“亲身实战”的练习，希望通过实践使读者获得故障处理和调优的经验。</p><hr><h2 id="第二节-案例分析"><a href="#第二节-案例分析" class="headerlink" title="第二节 案例分析"></a><strong>第二节 案例分析</strong></h2><p>&emsp;&emsp;本章中的案例大部分来源于作者处理过的一些问题，还有一小部分来源于网上有特色和代表性的案例总结。出于对客户商业信息保护的目的，在不影响前后逻辑的前提下，作者对实际环境和用户业务做了一些屏蔽和精简。</p><h3 id="2-1-高性能硬件上的程序部署策略"><a href="#2-1-高性能硬件上的程序部署策略" class="headerlink" title="2.1 高性能硬件上的程序部署策略"></a><strong>2.1 高性能硬件上的程序部署策略</strong></h3><p>&emsp;&emsp;例如一个15万PV/天左右的在线文档类型网站最近更换了硬件系统，新的硬件为4个CPU、16GB物理内存，操作系统为64位CentOS 5.4，Resin作为Web服务器。整个服务器暂时没有部署别的应用，所有硬件资源都可以提供给访问量并不算太大的网站使用。管理员为了尽量利用硬件资源选用了64位的JDK 1.5，并通过-Xmx和-Xms参数将Java堆固定在12GB。使用一段时间后发现使用效果并不理想，网站经常不定期出现长时间没有响应的现象。</p><p>&emsp;&emsp;监控服务器运行状况后发现网站没有响应是由GC停顿导致的，虚拟机运行在Server模式，默认使用吞吐量优先收集器，回收12GB的堆，一次Full GC的停顿时间高达14秒。并且由于程序设计的关系，访问文档时要把文档从磁盘提取到内存中，导致内存中出现很多由文档序列化产生的大对象，这些大对象很多都进入了老年代，没有在Minor GC中清理掉。这种情况下即使有12GB的堆，内存也很快会被消耗殆尽，由此导致每隔十几分钟出现十几秒的停顿，令网站开发人员和管理员感到很沮丧。</p><p>&emsp;&emsp;这里先不延伸讨论程序代码问题，程序部署上的主要问题显然是<strong>过大的堆内存进行回收时带来的长时间的停顿</strong>。硬件升级前使用32位系统1.5GB的堆，用户只感到访问网站比较缓慢，但不会发生十分明显的停顿，因此才考虑升级硬件提升程序效能，如果重新缩小给Java堆分配的内存，那么硬件上的投资就浪费了。</p><blockquote><p>在高性能硬件上部署程序，目前主要有两种方式：</p><ul><li>通过64位JDK来使用大内存。</li><li>使用若干个32位虚拟机建立逻辑集群来利用硬件资源。</li></ul></blockquote><p>&emsp;&emsp;此案例中的管理员采用了第一种部署方式。对于用户交互性强、对停顿时间敏感的系统，可以给Java虚拟机分配超大堆的前提是有把握把应用程序的Full GC频率控制得足够低，至少要低到不会影响用户使用，譬如十几个小时乃至一天才出现一次Full GC，这样可以<strong>通过在深夜执行定时任务的方式触发Full GC甚至自动重启应用服务器来将内存可用空间保持在一个稳定的水平</strong>。</p><p>&emsp;&emsp;控制Full GC频率的关键是看应用中绝大多数对象能否符合“朝生夕灭”的原则，即大多数对象的生存时间不应当太长，尤其是不能产生成批量的、长生存时间的大对象，这样才能保障老年代空间的稳定。</p><p>&emsp;&emsp;在大多数网站形式的应用里，主要对象的生存周期都应该是请求级或页面级的，会话级和全局级的长生命对象相对很少。只要代码写得合理，应当都能实现在超大堆中正常使用而没有Full GC，这样的话，使用超大堆内存时，网站响应的速度才比较有保证。除此之外，如果读者计划使用64位JDK来管理大内存，还需要考虑下面可能面临的问题：</p><blockquote><ul><li>内存回收导致的长时间停顿。</li><li>现阶段，64位JDK的性能测试结果普遍低于32位JDK。</li><li>需要保证程序足够稳定，因为这种应用要是产生堆溢出几乎就无法产生堆转储快照 （因为要产生十几GB乃至更大的dump文件），哪怕产生了快照也几乎无法进行分 析。</li><li>相同的程序在64位JDK中消耗的内存一般比32位JDK大，这是由指针膨胀及数据类型对齐补白等因素导致的。</li></ul></blockquote><p>&emsp;&emsp;上面的问题听起来有点吓人，所以现阶段不少管理员还是选择第二种方式：使用若干个32位虚拟机建立逻辑集群来利用硬件资源。具体做法是<strong>在一台物理机器上启动多个应用服务器进程，给每个服务器进程分配不同的端口，然后在前端搭建一个负载均衡器，以反向代理的方式来分配访问请求</strong>。读者不需要太在意均衡器转发所消耗的性能，即使使用64位JDK，许多应用也不止有一台服务器，因此在许多应用中前端的均衡器总是要存在的。</p><p>&emsp;&emsp;考虑到在一台物理机器上建立逻辑集群的目的仅仅是尽可能地利用硬件资源，并不需要关心状态保留、热转移之类的高可用性需求，也不需要保证每个虚拟机进程有绝对准确的均衡负载，因此使用无Session复制的亲合式集群是一个相当不错的选择。我们仅仅需要保障集群具备亲和性，也就是均衡器按一定的规则算法（一般根 据SessionID分配）将一个固定的用户请求永远分配到固定的一个集群节点进行处理即可，这样程序开发阶段就基本不用为集群环境做什么特别的考虑。</p><p>&emsp;&emsp;当然，很少有没有缺点的方案，如果读者计划使用逻辑集群的方式来部署程序，可能会遇到下面一些问题：</p><blockquote><ul><li>尽量避免节点竞争全局的资源，最典型的就是磁盘竞争，各个节点如果同时访问某个磁盘文件的话（尤其是并发写操作容易出现问题），很容易导致IO异常。</li><li>很难最高效率地利用某些资源池，譬如连接池，一般都是在各个节点建立自己独立的连接池，这样有可能导致一些节点池满了而另外一些节点仍有较多空余。尽管可以使用集中式的JNDI，但这有一定的复杂性并且可能带来额外的性能代价。</li><li>各个节点仍然不可避免地受到32位的内存限制，在32位Windows平台中每个进程只能使用2GB的内存，考虑到堆以外的内存开销，堆一般最多只能开到1.5GB。在某些 Linux, Unix系统（如Solaris）中，可以提升到3GB乃至接近4GB的内存，但32位中仍然受最高4GB（2^32）内存的限制。</li><li>大量使用本地缓存（如大量使用HashMap作为K/V缓存）的应用，在逻辑集群中会造成较大的内存浪费，因为每个逻辑节点上都有一份缓存，这时可以考虑把本地缓存改为集中式缓存。</li></ul></blockquote><p>&emsp;&emsp;介绍完这两种部署方式，再重新回到这个案例之中，最后的部署方案调整为建立5个32位JDK的逻辑集群，每个进程按2GB内存计算（其中堆固定为1.5GB），占用了10GB的内存。另外建立一个Apache服务作为前端均衡代理访问门户。考虑到用户对响应速度比较关心，并且文档服务的主要压力集中在磁盘和内存访问上，CPU资源敏感度较低，因此改为CMS收集器进行垃圾回收。部署方式调整后，服务再没有出现长时间停顿，速度比硬件升级前有较大提升。</p><h3 id="2-2-集群间同步导致的内存溢出"><a href="#2-2-集群间同步导致的内存溢出" class="headerlink" title="2.2 集群间同步导致的内存溢出"></a><strong>2.2 集群间同步导致的内存溢出</strong></h3><p>&emsp;&emsp;一个基于B/S的MIS系统，硬件为两台2个CPU、8GB内存的HP小型机，服务器是WebLogic 9.2，每台机器启动了3个WebLogic实例，构成一个6个节点的亲合式集群。由于是亲合式集群，节点之间没有进行Session同步，但是有一些需求要实现部分数据在各个节点间共享。开始这些数据存放在数据库中，但由于读写频繁竞争很激烈，对性能的影响较大，后面使用JBossCache构建了一个全局缓存。全局缓存启用后，服务正常使用了较长的一段时间。但最近不定期地多次出现内存溢出问题。</p><p>&emsp;&emsp;在不出现内存溢出异常的时候，服务内存回收状况一直正常，每次内存回收后都能恢复到一个稳定的可用空间，开始怀疑是程序的某些不常用的代码路径中存在内存泄漏，但管理员反映最近程序并未更新或升级过，也没有进行什么特别的操作。只好让服务带着-XX：+HeapDumpOnOutOfMemoryError参数运行了一段时间。在最近一次溢出之后，管理员发回了heapdump文件，发现里面存在着大量的org.jgroups.protocols.pbcast.NAKACK对象。</p><p>&emsp;&emsp;JBossCache是基于自家的JGroups进行集群间的数据通信，JGroups使用协议栈的方式来实现收发数据包的各种所需特性的自由组合，数据包接收和发送时要经过每层协议栈的up()和down()方法，其中的NAKACK栈用于保障各个包的有效顺序及重发。JBossCache协议栈如图5-1所示。</p><p><img src="https://pic-1258215793.cos.ap-shanghai.myqcloud.com/content/20191201/201912010101.png" alt="JBossCache协议栈"></p><p>&emsp;&emsp;由于信息有传输失败需要重发的可能性，在确认所有注册在GMS（Group Membership Service）的节点都收到正确的信息前，发送的信息必须在内存中保 留。而此MIS的服务端中有一个负责安全校验的全局Filter，每当接收到请求时，均会更新一次最后的操作时间，并且将这个时间同步到所有的节点中，使得一个用户在一段时间内不能在多台机器上登录。在服务使用过程中，往往一个页面会产生数次乃至数十次的请求，因此这个过滤器导致集群各个节点之间的网络交互非常频繁。当网络情况不能满足传输要求时，重发数据在内存中不断地堆积，很快就产生了内存溢出。</p><p>&emsp;&emsp;这个案例中的问题，既有JBossCache的缺陷，也有MIS系统实现方式上的缺陷。JBossCache官方的maillist中讨论过很多次类似的内存溢出异常问题，据说后续版本有了改进。而更重要的缺陷是这一类被集群共享的数据如果要使用类似JBossCache这种集群缓存来同步的话，可以允许读操作频繁，因为数据在本地内存有一份副本，读取的动作不会耗费多少资源，但不应当有过于频繁的写操作，这会带来很大的网络同步的开销。</p><h3 id="2-3-堆外内存导致的溢出错误"><a href="#2-3-堆外内存导致的溢出错误" class="headerlink" title="2.3 堆外内存导致的溢出错误"></a><strong>2.3 堆外内存导致的溢出错误</strong></h3><p>&emsp;&emsp;这是一个学校的小型项目：基于B/S的电子考试系统，为了实现客户端能实时地从服务端接收考试数据，系统使用了逆向AJAX技术（也称为Comet或Server Side Push），选用CometD 1.1.1作为服务端推送框架，服务器是Jetty 7.1.4，硬件为一台普通PC机，Core i5 CPU，4GB内存，运行32位Windows操作系统。</p><p>&emsp;&emsp;测试期间发现服务端不定时抛出内存溢出异常，服务器不一定每次都会出现异常，但假如正式考试时崩溃一次，那估计整场电子考试都会乱套，网站管理员尝试过把堆开到最大，32位系统最多到1.6GB基本无法再加大了，而且开大了也基本没效果，抛出内存溢出异常好像更加频繁了。加入-XX: +HeapDumpOnOutOfMemoryError，居然也没有任何反应，抛出内存溢出异常时什么文件都没有产生。无奈之下只好挂着jstat使劲盯屏幕，发现GC并不频繁，Eden 区、Survivor区、老年代及永久代内存全部都表示“情绪稳定，压力不大”，但照样不停地抛出内存溢出异常，管理员压力很大。最后，在内存溢出后从系统日志中找到异常堆栈，如代码清单5-1所示。</p><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">代码清单<span class="number">5</span>-<span class="number">1</span> 异常堆栈<span class="number">1</span></span><br><span class="line">[org<span class="selector-class">.eclipse</span><span class="selector-class">.jetty</span><span class="selector-class">.util</span><span class="selector-class">.log</span>]handle failed java<span class="selector-class">.lang</span><span class="selector-class">.OutOfMemoryError</span>：null</span><br><span class="line">at sun<span class="selector-class">.misc</span><span class="selector-class">.Unsafe</span><span class="selector-class">.allocateMemory</span>(Native Method)</span><br><span class="line">at java<span class="selector-class">.nio</span><span class="selector-class">.DirectByteBuffer</span>.&lt;init&gt;(DirectByteBuffer.java：<span class="number">99</span>)</span><br><span class="line">at java<span class="selector-class">.nio</span><span class="selector-class">.ByteBuffer</span><span class="selector-class">.allocateDirect</span>(ByteBuffer.java：<span class="number">288</span>)</span><br><span class="line">at org<span class="selector-class">.eclipse</span><span class="selector-class">.jetty</span><span class="selector-class">.io</span><span class="selector-class">.nio</span><span class="selector-class">.DirectNIOBuffer</span>.&lt;init&gt;</span><br><span class="line">……</span><br></pre></td></tr></table></figure><p>&emsp;&emsp;如果认真阅读过本书的第2章，看到异常堆栈就应该清楚这个内存溢出异常是怎么回事了。大家知道操作系统对每个进程能管理的内存是有限制的，这台服务器使用的32位Windows平台的限制是2GB，其中给了Java堆1.6GB，而Direct Memory并不算在1.6GB的堆之内，因此它只能在剩余的0.4GB空间中分出一部分。在此应用中导致溢出的关键是：垃圾收集进行时，虚拟机虽然会对Direct Memory进行回收，但是Direct Memory却不能像新生代和老年代那样，发现空间不足了就通知收集器进行垃圾回收，它只能等待老年代满了后Full GC，然后“顺便地”帮它清理掉内存的废弃对象。否则，它只能等到抛出内存溢出异常时，先catch掉，再在catch块里面“大喊”一声：“System.gc()！”。要是虚拟机还是不听（譬如打开了-XX:+DisableExplicitGC开关），那就只能眼睁睁地看着堆中还有许多空闲内存，自己却不得不抛出内存溢出异常了。而本案例中使用的CometD 1.1.1框架，正好有大量的NIO操作需要用到Direct Memory。</p><p>&emsp;&emsp;从实践经验的角度出发，除了Java堆和永久代之外，我们注意到下面这些区域还会占用较多的内存，这里所有的内存总和会受到操作系统进程最大内存的限制：</p><blockquote><ul><li>Direct Memory：可通过-XX:MaxDirectMemorySize调整大小，内存不足时抛出OutOfMemoryError或OutOfMemoryError：Direct buffer memory。</li><li>线程堆栈：可通过-Xss调整大小，内存不足时抛出StackOverflowError（纵向无法分配，即无法分配新的栈帧）或OutOfMemoryError：unable to create new native thread（横向无法分配，即无法建立新的线程）。</li><li>Socket缓存区：每个Socket连接都Receive和Send两个缓存区，分别占大约37KB和25KB的内存，连接多的话这块内存占用也比较可观。如果无法分配，则可能会抛出IOException：Too many open files异常。</li><li>JNI代码：如果代码中使用JNI调用本地库，那本地库使用的内存也不在堆中。</li><li>虚拟机和GC：虚拟机和GC的代码执行也要消耗一定的内存。</li></ul></blockquote><h3 id="2-4-外部命令导致系统缓慢"><a href="#2-4-外部命令导致系统缓慢" class="headerlink" title="2.4 外部命令导致系统缓慢"></a><strong>2.4 外部命令导致系统缓慢</strong></h3><p>&emsp;&emsp;这是一个来自网络的案例：一个数字校园应用系统，运行在一台4个CPU的Solaris 10操作系统上，中间件为GlassFish服务器。系统在进行大并发压力测试的时候，发现请求响应时间比较慢，通过操作系统的mpstat工具发现CPU使用率很高，并且占用绝大多数CPU资源的程序并不是应用系统本身。这是个不正常的现象，通常情况下用户应用的CPU占用率应该占主要地位，才能说明系统是正常工作的。</p><p>&emsp;&emsp;通过Solaris 10的Dtrace脚本可以查看当前情况下哪些系统调用花费了最多的CPU资源，Dtrace运行后发现最消耗CPU资源的竟然是“fork”系统调用。众所周知，“fork”系统调用是Linux用来产生新进程的，在Java虚拟机中，用户编写的Java代码最多只有线程的概念，不应当有进程的产生。</p><p>&emsp;&emsp;这是个非常异常的现象。通过本系统的开发人员最终找到了答案：每个用户请求的处理都需要执行一个外部shell脚本来获得系统的一些信息。执行这个shell脚本是通过Java的Runtime.getRuntime().exec()方法来调用的。这种调用方式可以达到目的，但是它在Java虚拟机中非常消耗资源，即使外部命令本身能很快执行完毕，频繁调用时创建进程的开销也非常可观。Java虚拟机执行这个命令的过程是：首先克隆一个和当前虚拟机拥有一样环境变量的进程，再用这个新的进程去执行外部命令，最后再退出这个进程。如果频繁执行这个操作，系统的消耗会很大，不仅是CPU，内存的负担也很重。</p><p>&emsp;&emsp;用户根据建议去掉这个shell脚本执行的语句，改为使用Java的API去获取这些信息后，系统很快就恢复了正常。</p><h3 id="2-5-服务器JVM进程崩溃"><a href="#2-5-服务器JVM进程崩溃" class="headerlink" title="2.5 服务器JVM进程崩溃"></a><strong>2.5 服务器JVM进程崩溃</strong></h3><p>&emsp;&emsp;一个基于B/S的MIS系统，硬件为两台2个CPU、8GB内存的HP系统，服务器是 WebLogic 9.2（就是第二个案例中的那套系统）。正常运行一段时间后，最近发现在运行期间频繁出现集群节点的虚拟机进程自动关闭的现象，留下了一个hs_err_pid###.log文件后，进程就消失了，两台物理机器里的每个节点都出现过进程崩溃的现象。从系统日志中注意到，每个节点的虚拟机进程在崩溃前不久，都发生过大量相同的异常，见代码清单5-2。</p><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">代码清单<span class="number">5</span>-<span class="number">2</span> 异常堆栈<span class="number">2</span></span><br><span class="line">java<span class="selector-class">.net</span><span class="selector-class">.SocketException</span>：Connection reset</span><br><span class="line">at java<span class="selector-class">.net</span><span class="selector-class">.SocketInputStream</span><span class="selector-class">.read</span>(SocketInputStream.java：<span class="number">168</span>)</span><br><span class="line">at java<span class="selector-class">.io</span><span class="selector-class">.BufferedInputStream</span><span class="selector-class">.fill</span>(BufferedInputStream.java： <span class="number">218</span>)</span><br><span class="line">at java<span class="selector-class">.io</span><span class="selector-class">.BufferedInputStream</span><span class="selector-class">.read</span>(BufferedInputStream.java：<span class="number">235</span>)</span><br><span class="line">at org<span class="selector-class">.apache</span><span class="selector-class">.axis</span><span class="selector-class">.transport</span><span class="selector-class">.http</span><span class="selector-class">.HTTPSender</span><span class="selector-class">.readHeadersFromSocket</span>(HTTPSe <span class="number">583</span>)</span><br><span class="line">at org<span class="selector-class">.apache</span><span class="selector-class">.axis</span><span class="selector-class">.transport</span><span class="selector-class">.http</span><span class="selector-class">.HTTPSender</span><span class="selector-class">.invoke</span>(HTTPSender.java： <span class="number">143</span>)</span><br><span class="line">……<span class="number">99</span> more</span><br></pre></td></tr></table></figure><p>&emsp;&emsp;这是一个远端断开连接的异常，通过系统管理员了解到系统最近与一个OA门户做了集成，在MIS系统工作流的待办事项变化时，要通过Web服务通知OA门户系统，把待办事项的变化同步到OA门户之中。通过SoapUI测试了一下同步待办事项的几个Web服务，发现调用后竟然需要长达3分钟才能返回，并且返回的结果都是连接中断。</p><p>&emsp;&emsp;由于MIS系统的用户多，待办事项变化很快，为了不被OA系统的速度拖累，使用了异步的方式调用Web服务，但由于两边服务的速度完全不对等，时间越长就累积了越多Web服务没有调用完成，导致在等待的线程和Socket连接越来越多，最终超过虚拟机的承受能力后使得虚拟机进程崩溃。通知OA门户方修复无法使用的集成接口，并将异步调用改为生产者/消费者模式的消息队列实现后，系统恢复正常。</p><h3 id="2-6-不恰当数据结构导致内存占用过大"><a href="#2-6-不恰当数据结构导致内存占用过大" class="headerlink" title="2.6 不恰当数据结构导致内存占用过大"></a><strong>2.6 不恰当数据结构导致内存占用过大</strong></h3><p>&emsp;&emsp;例如，有一个后台RPC服务器，使用64位虚拟机，内存配置为-Xms4g -Xmx8g -Xmnlg，使用ParNew+CMS的收集器组合。平时对外服务的Minor GC时间约在30毫秒以内，完全可以接受。但业务上需要每10分钟加载一个约80MB的数据文件到内存进行数据分析，这些数据会在内存中形成超过100万个HashMap&lt;Long, Long&gt;Entry，在这段时间里面Minor GC就会造成超过500毫秒的停顿，这个时间就有些接受不了了，具体情况如下面GC日志所示。</p><figure class="highlight x86asm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">&#123;Heap before GC invocations=<span class="number">95</span>(full <span class="number">4</span>):</span><br><span class="line">    par new generation total 903168K,used 803142K[<span class="number">0x00002aaaae770000</span>，<span class="number">0x00002aaaebb70000</span>，<span class="number">0x00002aaaebb70000</span>)</span><br><span class="line">    eden space 802816K，<span class="number">100</span>%used[<span class="number">0x00002aaaae770000</span>，<span class="number">0x00002aaadf770000</span>，<span class="number">0x00002aaadf770000</span>)</span><br><span class="line">    from space 100352K，<span class="number">0</span>%used[<span class="number">0x00002aaae5970000</span>，<span class="number">0x00002aaae59c1910</span>，<span class="number">0x00002aaaebb70000</span>)</span><br><span class="line">    to space 100352K，<span class="number">0</span>%used[<span class="number">0x00002aaadf770000</span>，<span class="number">0x00002aaadf770000</span>，<span class="number">0x00002aaae5970000</span>)</span><br><span class="line">    concurrent mark-sweep generation total 5845540K,used 3898978K[<span class="number">0x00002aaaebb70000</span>，<span class="number">0x00002aac507f9000</span>，<span class="number">0x00002aacae770000</span>)</span><br><span class="line">    concurrent-mark-sweep perm gen total 65536K,used 40333K[<span class="number">0x00002aacae770000</span>，<span class="number">0x00002aacb2770000</span>，<span class="number">0x00002aacb2770000</span>)</span><br><span class="line">    <span class="number">2011</span>-<span class="number">10</span>-<span class="number">28</span> T <span class="number">11</span>:<span class="number">40</span>:<span class="number">45.162</span>+<span class="number">0800</span>: <span class="number">226.504</span>:[GC <span class="number">226.504</span>: [ParNew:803142K-&gt;100352K(903168K)，<span class="number">0.5995670</span> secs] 4702120K-&gt; 4056332K(6748708K)，<span class="number">0.5997560</span> secs][<span class="built_in">Times</span>:user=<span class="number">1.46</span> sys=<span class="number">0.04</span>，real=<span class="number">0.60</span> secs]</span><br><span class="line">    Heap after GC invocations=<span class="number">96</span>(full <span class="number">4</span>):</span><br><span class="line">    par new generation total 903168K,used 100352K[<span class="number">0x00002aaaae770000</span>，<span class="number">0x00002aaaebb70000</span>，<span class="number">0x00002aaaebb70000</span>)</span><br><span class="line">    eden space 802816K，<span class="number">0</span>%used[<span class="number">0x00002aaaae770000</span>，<span class="number">0x00002aaaae770000</span>，<span class="number">0x00002aaadf770000</span>)</span><br><span class="line">    from space 100352K，<span class="number">100</span>%used[<span class="number">0x00002aaadf770000</span>，<span class="number">0x00002aaae5970000</span>，<span class="number">0x00002aaae5970000</span>)</span><br><span class="line">    to space 100352K，<span class="number">0x00002aaaebb70000</span>)<span class="number">0</span>%used[<span class="number">0x00002aaae5970000</span>，<span class="number">0x00002aaae5970000</span>，</span><br><span class="line">    concurrent mark-sweep generation total 5845540K,used 3955980K[<span class="number">0x00002aaaebb70000</span>，<span class="number">0x00002aac507f9000</span>，<span class="number">0x00002aacae770000</span>)</span><br><span class="line">    concurrent-mark-sweep perm gen total 65536K,used 40333K[<span class="number">0x00002aacae770000</span>，<span class="number">0x00002aacb2770000</span>，<span class="number">0x00002aacb2770000</span>)</span><br><span class="line">&#125;</span><br><span class="line">Total time for which application threads were stopped:<span class="number">0.6070570</span> seconds</span><br></pre></td></tr></table></figure><p>&emsp;&emsp;观察这个案例，发现平时的Minor GC时间很短，原因是新生代的绝大部分对象都是可清除的，在Minor GC之后Eden和Survivor基本上处于完全空闲的状态。而在分析数据文件期间，800MB的Eden空间很快被填满从而引发GC，但Minor GC之后，新生代中绝大部分对象依然是存活的。我们知道ParNew收集器使用的是复制算法，这个算法的高效是建立在大部分对象都“朝生夕灭”的特性上的，如果存活对象过多，把这些对象复制到Survivor并维持这些对象引用的正确就成为一个沉重的负担，因此导致GC暂停时间明显变长。</p><p>&emsp;&emsp;如果不修改程序，仅从GC调优的角度去解决这个问题，可以考虑将Survivor空间去掉（加入参数-XX:SurvivorRatio=65536、-XX:MaxTenuringThreshold=0或者-XX:+AlwaysTenure），让新生代中存活的对象在第一次Minor GC后立即进入老年代，等到Major GC的时候再清理它们。这种措施可以治标，但也有很大副作用，治本的方案需要修改程序，因为这里的问题产生的根本原因是用HashMap&lt;Long, Long&gt;结构来存储数据文件空间效率太低。</p><p>&emsp;&emsp;下面具体分析一下空间效率。在HashMap&lt;Long, Long&gt;结构中，只有Key和Value所存放的两个长整型数据是有效数据，共16B（2×8B）。这两个长整型数据包装成java.lang.Long对象之后，就分别具有8B的MarkWord、8B的Klass指针，在加8B存储数据的long值。在这两个Long对象组成Map.Entry之后，又多了16B的对象头，然后一个8B的next字段和4B的int型的hash字段，为了对齐，还必须添加4B的空白填充，最后还有HashMap中对这个Entry的8B的引用，这样增加两个长整型数字，实际耗费的内存为(Long(24B)×2) + Entry(32B) + HashMap Ref (8B) = 88B，空间效率为16B/88B=18%，实在太低了。</p><h3 id="2-7-由Windows虚拟内存导致的长时间停顿"><a href="#2-7-由Windows虚拟内存导致的长时间停顿" class="headerlink" title="2.7 由Windows虚拟内存导致的长时间停顿"></a><strong>2.7 由Windows虚拟内存导致的长时间停顿</strong></h3><p>&emsp;&emsp;例如，有一个带心跳检测功能的GUI桌面程序，每15秒会发送一次心跳检测信号，如果对方30秒以内都没有信号返回，那就认为和对方程序的连接已经断开。程序上线后发现心跳检测有误报的概率，查询日志发现误报的原因是程序会偶尔出现间隔约一分钟左右的时间完全无日志输出，处于停顿状态。</p><p>&emsp;&emsp;因为是桌面程序，所需的内存并不大（-Xmx256m），所以开始并没有想到是GC导致的程序停顿，但是加入参数-XX:+PrintGCApplicationStoppedTime -XX:+PrintGCDateStamps Xloggc:gclog.log后，从GC日志文件中确认了停顿确实是由GC导致的，大部分GC时间都控制在100毫秒以内，但偶尔就会出现一次接近1分钟的GC。</p><figure class="highlight applescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">Total <span class="built_in">time</span> <span class="keyword">for</span> which <span class="built_in">application</span> threads were stopped：<span class="number">0.0112389</span> seconds</span><br><span class="line">Total <span class="built_in">time</span> <span class="keyword">for</span> which <span class="built_in">application</span> threads were stopped：<span class="number">0.0001335</span> seconds</span><br><span class="line">Total <span class="built_in">time</span> <span class="keyword">for</span> which <span class="built_in">application</span> threads were stopped：<span class="number">0.0003246</span> seconds</span><br><span class="line">Total <span class="built_in">time</span> <span class="keyword">for</span> which <span class="built_in">application</span> threads were stopped：<span class="number">41.4731411</span> seconds</span><br><span class="line">Total <span class="built_in">time</span> <span class="keyword">for</span> which <span class="built_in">application</span> threads were stopped：<span class="number">0.0489481</span> seconds</span><br><span class="line">Total <span class="built_in">time</span> <span class="keyword">for</span> which <span class="built_in">application</span> threads were stopped：<span class="number">0.1110761</span> seconds</span><br><span class="line">Total <span class="built_in">time</span> <span class="keyword">for</span> which <span class="built_in">application</span> threads were stopped：<span class="number">0.0007286</span> seconds</span><br><span class="line">Total <span class="built_in">time</span> <span class="keyword">for</span> which <span class="built_in">application</span> threads were stopped：<span class="number">0.0001268</span> seconds</span><br></pre></td></tr></table></figure><p>&emsp;&emsp;从GC日志中找到长时间停顿的具体日志信息（添加了-XX:+PrintReferenceGC参数），找到的日志片段如下所示。从日志中可以看出，真正执行GC动作的时间不是很长，但从准备开始GC，到真正开始GC之间所消耗的时间却占了绝大部分。</p><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">2012-08-29T19：14：30.968+0800：10069.800：[<span class="string">GC10099.225：[SoftReference，0 refs，0.0000109 secs</span>]10099.226：[<span class="string">WeakReference，4072 refs，0.0012099 secs</span>]10099.227：[<span class="string">FinalReference，984 refs，1.5822450 secs</span>]10100.809：[<span class="string">PhantomReference，251 refs，0.0001394 secs</span>]10100.809：[<span class="string">JNI Weak Reference，0.0994015 secs</span>] [<span class="string">PSYoungGen：175672K-＞8528K（167360K）</span>]251523K-＞100182K（353152K），31.1580402 secs][Times：user=0.61 sys=0.52，real=31.16 secs]</span><br></pre></td></tr></table></figure><p>&emsp;&emsp;除GC日志之外，还观察到这个GUI程序内存变化的一个特点，当它最小化的时候，资源管理中显示的占用内存大幅度减小，但是虚拟内存则没有变化，因此怀疑程序在最小化时它的工作内存被自动交换到磁盘的页面文件之中了，这样发生GC时就有可能因为恢复页面文件的操作而导致不正常的GC停顿。</p><p>&emsp;&emsp;在MSDN上查证后确认了这种猜想，因此，在Java的GUI程序中要避免这种现象，可以加入参数“-Dsun.awt.keepWorkingSetOnMinimize=true”来解决。这个参数在许多AWT的程序上都有应用，例如JDK自带的Visual VM，用于保证程序在恢复最小化时能够立即响应。在这个案例中加入该参数后，问题得到解决。</p><hr><h2 id="第三节-实战：Eclipse运行速度调优"><a href="#第三节-实战：Eclipse运行速度调优" class="headerlink" title="第三节 实战：Eclipse运行速度调优"></a><strong>第三节 实战：Eclipse运行速度调优</strong></h2><p>&emsp;&emsp;很多Java开发人员都有这样一种观念：系统调优的工作都是针对服务端应用而言的，规模越大的系统，需要越专业的调优运维团队参与。这个观点不能说不对，上一节中作者所列举的案例确实都是服务端运维和调优的例子，但服务端应用需要调优，并不说明其他应用就不需要了，作为一个普通的Java开发人员，前面讲的各种 虚拟机的原理和最佳实践的方法距离我们并不遥远，开发者身边的很多场景都可以使用上面这些知识。下面就通过一个普通程序员日常工作中可以随时接触到的开发工具开始这次实战。</p><h3 id="3-1-调优前的程序运行状态"><a href="#3-1-调优前的程序运行状态" class="headerlink" title="3.1 调优前的程序运行状态"></a><strong>3.1 调优前的程序运行状态</strong></h3><p>&emsp;&emsp;作者使用Eclipse 3.5作为日常工作中的主要IDE工具，由于安装的插件比较大（如 Klocwork、ClearCase LT等）、代码也很多，启动Eclipse直到所有项目编译完成需要四五分钟。一直对开发环境的速度感到不满意，趁着编写这本书的机会，决定对Eclipse进行“动刀”调优。</p><p>&emsp;&emsp;作者机器的Eclipse运行平台是32位Windows 7系统，虚拟机为HotSpot VM 1.5 b64，硬件为ThinkPad X201，Intel i5 CPU，4GB物理内存。在初始的配置文件eclipse.ini中，除了指定JDK的路径、设置最大堆为512MB及开启了JMX管理（需要在VisualVM中收集原始数据）外，未作任何改动，原始配置内容如代码清单5-3 所示。</p><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">代码清单<span class="number">5</span>-<span class="number">3</span> Eclipse <span class="number">3.5</span>初始配置</span><br><span class="line">-vm</span><br><span class="line">D：/_DevSpace/jdk1.<span class="number">5.0</span>/bin/javaw.exe</span><br><span class="line">-startup</span><br><span class="line">plugins/org<span class="selector-class">.eclipse</span><span class="selector-class">.equinox</span><span class="selector-class">.launcher_1</span>.<span class="number">0.201</span><span class="selector-class">.R35x_v20090715</span><span class="selector-class">.jar</span></span><br><span class="line">--launcher.library</span><br><span class="line">plugins/org<span class="selector-class">.eclipse</span><span class="selector-class">.equinox</span><span class="selector-class">.launcher</span><span class="selector-class">.win32</span><span class="selector-class">.win32</span><span class="selector-class">.x86_1</span>.<span class="number">0.200</span>.v20090519</span><br><span class="line">-product</span><br><span class="line">org<span class="selector-class">.eclipse</span><span class="selector-class">.epp</span><span class="selector-class">.package</span><span class="selector-class">.jee</span><span class="selector-class">.product</span></span><br><span class="line">--launcher.XXMaxPermSize</span><br><span class="line"><span class="number">256</span>M</span><br><span class="line">-showsplash</span><br><span class="line">org<span class="selector-class">.eclipse</span><span class="selector-class">.platform</span></span><br><span class="line">-vmargs</span><br><span class="line">-Dosgi.requiredJavaVersion=<span class="number">1.5</span></span><br><span class="line">-Xmx512m</span><br><span class="line">-Dcom<span class="selector-class">.sun</span><span class="selector-class">.management</span><span class="selector-class">.jmxremote</span></span><br></pre></td></tr></table></figure><p>&emsp;&emsp;为了与调优后的结果进行量化对比，调优开始前作者先做了一次初始数据测试。测试用例很简单，就是收集从Eclipse启动开始，直到所有插件加载完成为止的总耗时及运行状态数据，虚拟机的运行数据通过VisualVM及其扩展插件VisualGC进行采集。测试过程中反复启动Eclipse数次直到测试结果稳定后，取最后一次运行的结果作为数据样本（为了避免操作系统未能及时进行磁盘缓存而产生的影响），数据样本如图5-2所示。</p><p><img src="https://pic-1258215793.cos.ap-shanghai.myqcloud.com/content/20191201/201912010102.png" alt="Eclipse原始运行数据"></p><p>&emsp;&emsp;Eclipse启动的总耗时没有办法从监控工具中直接获得，因为VisualVM不可能知道Eclipse运行到什么阶段才算是启动完成。为了保证测试的准确性，作者写了一个简单的Eclipse插件，用于统计Eclipse的启动耗时。由于代码很简单，并且本书不是Eclispe RCP的开发教程，所以只列出代码清单5-4供读者参考，不再延伸讲解。</p><figure class="highlight actionscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line">--代码清单<span class="number">5</span><span class="number">-4</span> Eclipse启动耗时统计插件ShowTime.java代码：</span><br><span class="line"></span><br><span class="line"><span class="meta"><span class="meta-keyword">import</span> org.eclipse.jface.dialogs.MessageDialog;</span></span><br><span class="line"><span class="meta"><span class="meta-keyword">import</span> org.eclipse.swt.widgets.Display;</span></span><br><span class="line"><span class="meta"><span class="meta-keyword">import</span> org.eclipse.swt.widgets.Shell;</span></span><br><span class="line"><span class="meta"><span class="meta-keyword">import</span> org.eclipse.ui.IStartup;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">*统计Eclipse启动耗时</span></span><br><span class="line"><span class="comment">*@author zzm</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ShowTime</span> <span class="keyword">implements</span> <span class="title">IStartup</span></span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> earlyStartup()&#123;</span><br><span class="line">        Display.getDefault().syncExec(<span class="keyword">new</span> Runnable()&#123;</span><br><span class="line">            <span class="keyword">public</span> <span class="keyword">void</span> run()&#123;</span><br><span class="line">                long eclipseStartTime = Long.parseLong(System.getProperty(<span class="string">"eclipse.startTime"</span>));</span><br><span class="line">                long costTime = System.currentTimeMillis() - eclipseStartTime;</span><br><span class="line">                Shell shell = Display.getDefault().getActiveShell();</span><br><span class="line">                String message = <span class="string">"Eclipse启动耗时："</span> + costTime+<span class="string">"ms"</span>;</span><br><span class="line">                MessageDialog.openInformation(shell, <span class="string">"Information"</span>, message);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">--plugin.xml代码：</span><br><span class="line">&lt;?xml version=<span class="string">"1.0"</span>encoding=<span class="string">"UTF-8"</span>?&gt;</span><br><span class="line">&lt;?eclipse version=<span class="string">"3.4"</span>?&gt;</span><br><span class="line">&lt;plugin&gt;</span><br><span class="line">    &lt;extension point=<span class="string">"org.eclipse.ui.startup"</span>&gt;</span><br><span class="line">        &lt;startup <span class="class"><span class="keyword">class</span>="<span class="title">eclipsestarttime</span>.<span class="title">actions</span>.<span class="title">ShowTime</span>"/&gt;</span></span><br><span class="line"><span class="class">    &lt;/<span class="title">extension</span>&gt;</span></span><br><span class="line"><span class="class">&lt;/<span class="title">plugin</span>&gt;</span></span><br></pre></td></tr></table></figure><p>&emsp;&emsp;上述代码打包成jar后放到Eclipse的plugins目录中，反复启动几次后，插件显示的平均时间稳定在15秒左右，如图5-3所示。</p><p><img src="https://pic-1258215793.cos.ap-shanghai.myqcloud.com/content/20191201/201912010103.png" alt="耗时统计插件运行效果"></p><p>&emsp;&emsp;根据VisualGC和Eclipse插件收集到的信息，总结原始配置下的测试结果如下：</p><blockquote><ul><li>整个启动过程平均耗时约15秒。</li><li>最后一次启动的数据样本中，垃圾收集总耗时4.149秒，其中：Full GC被触发了19次，共耗时3.166秒；Minor GC被触发了378次，共耗时0.983秒。</li><li>加载类9115个，耗时4.114秒。</li><li>JIT的编译时间为1.999秒。</li><li>虚拟机512MB的堆内存被分配为40MB的新生代（31.5MB的Eden空间和2个4MB的 Surviver空间）及472MB的老年代。</li></ul></blockquote><p>&emsp;&emsp;客观地说，由于机器硬件还不错（请读者以2010年普通PC机的标准来衡量），15秒的启动时间其实还在可接受的范围以内，但是从VisualGC中反映的数据来看，主要问题是非用户程序时间（图5-2中的Compile Time、Class Loader Time、GC Time）非常高，占了整个启动过程耗时的一半以上（这里存在少许夸张成分，因为<br>如果JIT编译等动作是在后台线程完成的，用户程序在此期间也正常执行，所以并没有占用一半以上的绝对时间）。虚拟机后台占用太多时间也直接导致Eclipse在启动后的使用过程中经常有停顿的感觉，所以进行调优有较大的价值。</p><h3 id="3-2-升级JDK-1-6的性能变化及兼容问题"><a href="#3-2-升级JDK-1-6的性能变化及兼容问题" class="headerlink" title="3.2 升级JDK 1.6的性能变化及兼容问题"></a><strong>3.2 升级JDK 1.6的性能变化及兼容问题</strong></h3><p>&emsp;&emsp;对Eclipse进行调优的第一步就是先把虚拟机的版本做个升级，希望能先从虚拟机 版本上得到一些“免费的”性能提升。</p><p>&emsp;&emsp;每次JDK的大版本发布时，开发商肯定都会宣称虚拟机的运行速度比上一版本有了很大的提高，这虽然是个广告性质的宣言，经常被人从升级列表或技术白皮书中直接忽略过去，但从国内外的第三方评测数据来看，版本升级在某些方面确实带来了一定的性能改善，以下是一个第三方网站对JDK 1.5、1.6、1.7三个版本做的性能评测，分别测试了以下四个用例：</p><blockquote><ul><li>生成500万个字符串。</li><li>500万次ArrayList<string>数据插入，使用第一点生成的数据。</string></li><li>生成500万个HashMap&lt;String, Integer&gt;，每个键-值对通过并发线程计算，测试并发能力。</li><li>打印500万个ArrayList<string>中的值到文件，并重读回内存。</string></li></ul></blockquote><p>&emsp;&emsp;三个版本的JDK分别运行这些用例的测试程序，测试结果如图5-4所示。</p><p><img src="https://pic-1258215793.cos.ap-shanghai.myqcloud.com/content/20191201/201912010104.png" alt="JDK横向性能对比"></p><p>&emsp;&emsp;从这4个用例的测试结果来看，JDK 1.6比1.5有大约15%的性能提升，尽管对JDK仅测试这4个用例并不能说明什么问题，需要通过测试数据来量化描述一个JDK比旧版提升了多少是很难做到非常科学准确的（要做稍微靠谱一点的测试，可以使用SPECjvm2008来完成，或者把相应版本的TCK中数万个测试用例的性能数据对比一<br>下可能更有说服力），但我还是选择相信这次“软广告”性质的测试，把JDK版本升级到1.6 Update 21，升级的最主要理由是：本书是基于JDK 1.6编写的。</p><p>&emsp;&emsp;这次升级到JDK 1.6之后，性能有什么变化暂且不谈，在使用几分钟之后，作者的Eclipse就和前面几个服务端的案例一样“不负众望”地发生了内存溢出，如图5-5所示。</p><p><img src="https://pic-1258215793.cos.ap-shanghai.myqcloud.com/content/20191201/201912010105.png" alt="Eclipse OutOfMemoryError"></p><p>&emsp;&emsp;这次内存溢出完全出乎作者的意料：决定对Eclipse做调优是因为速度慢，但开发环境一直都很稳定，至少没有出现过内存溢出的问题，而这次升级除了eclipse.ini中的JVM路径改了之外，还未进行任何运行参数的调整，进到Eclipse主界面之后随便开了几个文件居然就抛出内存溢出异常了，难道JDK 1.6 Update21有哪个API出现了严重的泄漏问题吗？</p><p>&emsp;&emsp;事实上并不是JDK 1.6出现了什么问题，根据前面讲解的原理和工具，我们要查明这个异常的原因并且解决它一点也不困难。打开VisualVM，监视页签中的内存曲线部分，如图5-6和图5-7所示。</p><p><img src="https://pic-1258215793.cos.ap-shanghai.myqcloud.com/content/20191201/201912010106.png" alt="Java堆监视曲线"></p><p><img src="https://pic-1258215793.cos.ap-shanghai.myqcloud.com/content/20191201/201912010107.png" alt="永久代监视曲线"></p><p>&emsp;&emsp;在Java堆的监视曲线里，“堆大小”曲线与“使用的堆”曲线一直都有很大的间隔距离，每当两条曲线开始出现互相靠近的趋势时，“最大堆”曲线就会快速向上转向，而“使用的堆”曲线会向下转向。“最大堆”曲线向上是虚拟机内部在进行堆扩容，运行参数中并没有指定最小堆（-Xms）的值与最大堆（-Xmx）相等，所以堆容量一开始并没有扩展到最大值，而是根据使用情况进行伸缩扩展。“使用的堆”曲线向下是因为虚拟机内部触发了一次垃圾收集，一些废弃对象的空间被回收后，内存用量相应少，从图形上看，Java堆运作是完全正常的。但永久代的监视曲线就很有问题了，“PermGen大小”曲线与“使用的PermGen”曲线几乎完全重合在一起，这说明永久代中没有可回收的资源，所以“使用的PermGen”曲线不会向下发展，永久代中也没有空间可以扩展，所以“PermGen大小”曲线不能向上扩展。那么这次很明显是永久代导致的内存溢出。</p><p>&emsp;&emsp;再注意看图5-7中永久代的最大容量：“67，108，864个字节”，也就是64MB，这恰好是JDK在未使用-XX:MaxPermSize参数明确指定永久代最大容量时的默认值，无论JDK 1.5还是JDK 1.6，这个默认值都是64MB。对于Eclipse这种规模的Java程序来说，64MB的永久代内存空间显然是不够的，溢出很正常，那为何在JDK 1.5中没有发生过溢出呢？</p><p>&emsp;&emsp;在VisualVM的“概述-JVM参数”页签中，分别检查使用JDK 1.5和JDK 1.6运行Eclipse时的JVM参数，发现使用JDK 1.6时只有以下3个JVM参数，如代码清单5-5 所示。</p><figure class="highlight haml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">代码清单5-5 JDK 1.6的Eclipse运行期参数</span><br><span class="line">-<span class="ruby">Dcom.sun.management.jmxremote</span></span><br><span class="line"><span class="ruby">-Dosgi.requiredJavaVersion=<span class="number">1.5</span></span></span><br><span class="line"><span class="ruby">-Xmx512m</span></span><br></pre></td></tr></table></figure><p>&emsp;&emsp;而使用JDK 1.5运行时有4个JVM参数，其中多出来的一个正好就是设置永久代最大 容量的-XX：MaxPermSize=256M，如代码清单5-6所示。</p><figure class="highlight haml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">代码清单5-6 JDK 1.5的Eclipse运行期参数</span><br><span class="line">-<span class="ruby">Dcom.sun.management.jmxremote</span></span><br><span class="line"><span class="ruby">-Dosgi.requiredJavaVersion=<span class="number">1.5</span></span></span><br><span class="line"><span class="ruby">-Xmx512m</span></span><br><span class="line"><span class="ruby">-XX：MaxPermSize=<span class="number">256</span>M</span></span><br></pre></td></tr></table></figure><p>&emsp;&emsp;为什么会这样呢？作者从Eclipse的Bug List网站上找到答案：使用JDK 1.5时之所以有永久代容量这个参数，是因为在eclipse.ini中存在“-launcher.XXMaxPermSize 256M”这项设置，当launcher—Windows下的可执行程序eclipse.exe检测到是Eclipse运行在Sun公司的虚拟机上的话，就会把参数值转化为-XX:MaxPermSize传递给虚拟机进程，因为三大商用虚拟机中只有Sun系列的虚拟机才有永久代的概念，即只有HotSpot虚拟机需要设置这个参数，JRockit虚拟机和IBM J9虚拟机都不需要设置。</p><p>&emsp;&emsp;2010年4月10日，Oracle正式完成了对Sun的收购，此后无论是网页还是具体的程序产品，提供商都从Sun变为了Oracle，而eclipse.exe就是根据程序提供商判断是否是Sun的虚拟机，当JDK 1.6 Update21中java.exe、javaw.exe 的“Company”属性从“Sun Microsystems Inc.”变为“Oracle Corporation”之后，Eclipse就完全不认识这个虚拟机了，因此没有把最大永久代的参数传递过去。</p><p>&emsp;&emsp;了解原因之后，解决方案就简单了，launcher不认识就只好由人来告诉它，在eclipse.ini中明确指定-XX：MaxPermSize=256M这个参数就可以了。</p><h3 id="3-3-编译时间和类加载时间的优化"><a href="#3-3-编译时间和类加载时间的优化" class="headerlink" title="3.3 编译时间和类加载时间的优化"></a><strong>3.3 编译时间和类加载时间的优化</strong></h3><p>&emsp;&emsp;从Eclipse启动时间上看，升级到JDK 1.6所带来的性能提升是……嗯？基本上没有 提升？多次测试的平均值与JDK 1.5的差距完全在实验误差范围之内。</p><p>&emsp;&emsp;各位读者不必失望，Sun JDK 1.6性能白皮书描述的众多相对于JDK 1.5的提升不至于全部是广告，虽然总启动时间没有减少，但在查看运行细节的时候，却发现了一件很值得注意的事情：在JDK 1.6中启动完Eclipse所消耗的类加载时间比JDK 1.5长了接近一倍，不要看反了，这里写的是1.6的类加载比1.5慢一倍，测试结果 如代码清单5-7所示，反复测试多次仍然是相似的结果。</p><figure class="highlight lsl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">代码清单<span class="number">5</span><span class="number">-7</span> JDK <span class="number">1.5</span>和<span class="number">1.6</span>中的类加载时间对比</span><br><span class="line"></span><br><span class="line">使用JDK <span class="number">1.6</span>的类加载时间：</span><br><span class="line">C：\Users\IcyFenix＞jps</span><br><span class="line"><span class="number">3552</span></span><br><span class="line"><span class="number">6372</span> org.eclipse.equinox.launcher_1<span class="number">.0</span><span class="number">.201</span>.R35x_v20090715.jar</span><br><span class="line"><span class="number">6900</span> Jps</span><br><span class="line"></span><br><span class="line">C：\Users\IcyFenix＞jstat-class <span class="number">6372</span></span><br><span class="line">Loaded Bytes Unloaded Bytes Time</span><br><span class="line"><span class="number">7917</span> <span class="number">10190.3</span> <span class="number">0</span> <span class="number">0.0</span> <span class="number">8.18</span></span><br><span class="line"></span><br><span class="line">使用JDK <span class="number">1.5</span>的类加载时间：</span><br><span class="line">C：\Users\IcyFenix＞jps</span><br><span class="line"><span class="number">3552</span></span><br><span class="line"><span class="number">7272</span> Jps</span><br><span class="line"><span class="number">7216</span> org.eclipse.equinox.launcher_1<span class="number">.0</span><span class="number">.201</span>.R35x_v20090715.jar</span><br><span class="line"></span><br><span class="line">C：\Users\IcyFenix＞jstat-class <span class="number">7216</span></span><br><span class="line">Loaded Bytes Unloaded Bytes Time</span><br><span class="line"><span class="number">7902</span> <span class="number">9691.2</span> <span class="number">3</span> <span class="number">2.6</span> <span class="number">4.34</span></span><br></pre></td></tr></table></figure><p>&emsp;&emsp;在本例中类加载时间上的差距并不能作为一个普遍性的测试结果去说明JDK 1.6的类加载必然比1.5慢，作者测试了自己机器上的Tomcat和ClassFish启动过程，并没有出现类似的差距。在国内最大的Java社区中，作者发起过关于此问题的讨论，从参与者反馈的测试结果来看，此问题只在一部分机器上存在，而且JDK 1.6的各<br>个update版之间也存在很大差异。</p><p>&emsp;&emsp;多次试验后，发现在作者机器上的两个JDK进行类加载时，字节码验证部分的耗时差 距尤其严重。考虑到实际情况：Eclipse使用者甚多，它的编译代码我们认为是可靠的，不需要在加载的时候再进行字节码验证，因此通过参数-Xverify:none禁止掉字节码验证过程也可作为一项优化措施。加入这个参数后，两个版本的JDK类加载速度都有所提高，JDK 1.6的类加载速度仍然比1.5慢，但是两者的耗时已经接近了许多，测试数据如代码清单5-8所示。关于类与类加载的话题，譬如刚刚提到的字节码验证是怎么回事，本书专门规划了两个章节进行详细讲解，在此不再延伸。</p><figure class="highlight lsl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">代码清单<span class="number">5</span><span class="number">-8</span> JDK <span class="number">1.5</span>和<span class="number">1.6</span>中取消字节码验证后的类加载时间对比</span><br><span class="line"></span><br><span class="line">使用JDK <span class="number">1.6</span>的类加载时间：</span><br><span class="line">C：\Users\IcyFenix＞jps</span><br><span class="line"><span class="number">5512</span> org.eclipse.equinox.launcher_1<span class="number">.0</span><span class="number">.201</span>.R35x_v20090715.jar</span><br><span class="line"><span class="number">5596</span> Jps</span><br><span class="line"></span><br><span class="line">C：\Users\IcyFenix＞jstat-class <span class="number">5512</span></span><br><span class="line">Loaded Bytes Unloaded Bytes Time</span><br><span class="line"><span class="number">6749</span> <span class="number">8837.0</span> <span class="number">0</span> <span class="number">0.0</span> <span class="number">3.94</span></span><br><span class="line"></span><br><span class="line">使用JDK <span class="number">1.5</span>的类加载时间：</span><br><span class="line">C：\Users\IcyFenix＞jps</span><br><span class="line"><span class="number">4724</span> org.eclipse.equinox.launcher_1<span class="number">.0</span><span class="number">.201</span>.R35x_v20090715.jar</span><br><span class="line"><span class="number">5412</span> Jps</span><br><span class="line"></span><br><span class="line">C：\Users\IcyFenix＞jstat-class <span class="number">4724</span></span><br><span class="line">Loaded Bytes Unloaded Bytes Time</span><br><span class="line"><span class="number">6885</span> <span class="number">9109.7</span> <span class="number">3</span> <span class="number">2.6</span> <span class="number">3.10</span></span><br></pre></td></tr></table></figure><p>&emsp;&emsp;在取消字节码验证之后，JDK 1.5的平均启动时间降到了13秒，而JDK 1.6的测试数 据平均比JDK 1.5快1秒，平均下降到12秒左右，如图5-8所示。在类加载时间仍然落后的情况下，依然可以看到JDK 1.6在性能上比JDK 1.5略有优势，说明至少在Eclipse启动这个测试用例上，升级JDK版本确实能带来一些“免费的”性能提升。</p><p><img src="https://pic-1258215793.cos.ap-shanghai.myqcloud.com/content/20191201/201912010108.png" alt="运行在JDK 1.6下取消字节码验证的启动时间"></p><p>&emsp;&emsp;前面说过，除了类加载时间以外，在VisualGC的监视曲线中显示了两项很大的非用户程序耗时：编译时间（Compile Time）和垃圾收集时间（GC Time）。垃圾收集时间读者应该非常清楚了，而编译时间是什么？程序在运行之前不是已经编译了吗？虚拟机的JIT编译与垃圾收集一样，是本书的一个重要部分，后面有专门章节讲解，这里先简单介绍一下：<strong>编译时间</strong>是指虚拟机的<strong>JIT编译器</strong>（Just In Time Compiler）编译<strong>热点代码</strong>（Hot Spot Code）的耗时。我们知道Java语言为了实现跨平台的特性，Java代码编译出来后形成的Class文件中储存的是字节码（ByteCode），虚拟机通过解释方式执行字节码命令，比起C/C++编译成本地二进制代码来说，速度要慢不少。为了解决程序解释执行的速度问题，JDK 1.2以后，虚拟机内置了两个运行时编译器，如果一段Java方法被调用的次数到达一定程度，就会被判定为热代码，从而交给JIT编译器即时编译为本地代码，以提高运行速度（这就是HotSpot虚拟机名字的由来）。甚至有可能在运行期动态编译比C/C++的编译器静态编译出来的代码更优秀，因为运行期可以收集很多编译器无法知道的信息，甚至可以采用一些很激进的优化手段，在优化条件不成立的时候再逆优化退回来。所以Java程序只要代码没有问题（主要是泄漏问题，如内存泄漏、连接泄漏），随着代码被编译得越来越彻底，运行速度应当是越来越快。Java运行期编译最大的缺点就是编译需要消耗程序正常的运行时间，也就是上面所说的“编译时间”。</p><p>&emsp;&emsp;虚拟机提供了一个参数-Xint禁止编译器运作，强制虚拟机对字节码采用纯解释方式执行。如果读者想使用这个参数省下Eclipse启动中那2秒的编译时间获得一个“更好看”的成绩的话，那恐怕要失望了，加上这个参数之后虽然编译时间确实下降到0，但Eclipse启动的总时间将剧增到27秒。看来这个参数现在最大的作用就是让用户缅怀一下JDK 1.2之前那令人心酸和心碎的运行速度。</p><p>&emsp;&emsp;与解释执行相对应的另一方面，虚拟机还有力度更强的编译器：当虚拟机运行在client模式的时候，使用的是一个代号为C1的轻量级编译器，另外还有一个代号为C2的相对重量级的编译器，它能提供更多的优化措施。如果使用-server模式的虚拟机启动Eclipse将会用到C2编译器，这时从VisualGC可以看到启动过程中虚拟机 使用了超过15秒的时间去进行代码编译。如果读者的工作习惯是长时间不关闭Eclipse的话，C2编译器所消耗的额外编译时间最终还是会在运行速度的提升之中赚回来，这样使用-server模式也是一个不错的选择。不过至少在本次实战中，我们还是继续选用-client虚拟机来运行Eclipse。</p><h3 id="3-4-调整内存设置控制垃圾收集频率"><a href="#3-4-调整内存设置控制垃圾收集频率" class="headerlink" title="3.4 调整内存设置控制垃圾收集频率"></a><strong>3.4 调整内存设置控制垃圾收集频率</strong></h3><p>&emsp;&emsp;三大块非用户程序时间中，还剩下GC时间没有调整，而GC时间却是其中最重要的一块，并不只是因为它是耗时最长的一块，更因为它是一个持续稳定的过程。由于我们所做的测试是在检测程序的启动时间，类加载和编译时间在这项测试中的影响力被大幅度放大了。在绝大多数的应用中，不可能出现持续不断的类被加载和卸载。 在程序运行一段时间后，热点方法不断被编译，新的热点方法数量也总会下降，但是垃圾收集是随着程序的运行而不断运作的，所以它对性能的影响才尤为重要。</p><p>&emsp;&emsp;在Eclipse启动的原始数据样本中，短短15秒类共发生了19次Full GC和378次 Minor GC，一共397次GC，共造成了超过4秒的停顿，也就是超过1/4的时间都是在进行垃圾收集，这个运行数据看起来实在是太糟糕了。</p><p>&emsp;&emsp;首先来解决新生代中的Minor GC，虽然GC的总时间只有不到1秒，但却发生了378次之多。从VisualGC的线程监视中看到Eclipse启动期间一共发起了超过70个线程，同时在运行的线程数超过25个，每当发生一次垃圾收集的动作，所有的用户线程都必须跑到最近的一个安全点（SafePoint），然后挂起线程等待垃圾回收。这样 过于频繁的GC就会导致很多没有必要的安全点检测、线程挂起及恢复操作。</p><p>&emsp;&emsp;新生代GC频繁发生，很明显是由于虚拟机分配给新生代的空间太小而导致的，Eden区加上一个Survivor区还不到35MB，因此很有必要使用-Xmn参数调整新生代的大小。</p><p>&emsp;&emsp;再来看一看那19次Full GC，看起来19次并“不多”（相对于378次Minor GC来说），但总共消耗了3.166秒，占了绝大部分的GC时间，降低GC时间的主要目标就 是降低这部分时间。从VisualGC的曲线图上看得不够精确，这次直接从GC日志中分析一下这些Full GC是如何产生的，代码清单5-9中是启动最开始的2.5秒内发生的 10次Full GC的记录。</p><figure class="highlight lsl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">代码清单<span class="number">5</span><span class="number">-9</span> Full GC记录</span><br><span class="line"><span class="number">0.278</span>：[GC <span class="number">0.278</span>：[DefNew：<span class="number">574</span>K-＞<span class="number">33</span>K（<span class="number">576</span>K），<span class="number">0.0012562</span> secs]<span class="number">0.279</span>：[Tenured：<span class="number">1467</span>K-＞<span class="number">997</span>K（<span class="number">1536</span>K），<span class="number">0.0181775</span> secs]<span class="number">1920</span>K-＞ <span class="number">997</span>K（<span class="number">2112</span>K），<span class="number">0.0195257</span> secs]</span><br><span class="line"><span class="number">0.312</span>：[GC <span class="number">0.312</span>：[DefNew：<span class="number">575</span>K-＞<span class="number">64</span>K（<span class="number">576</span>K），<span class="number">0.0004974</span> secs]<span class="number">0.312</span>：[Tenured：<span class="number">1544</span>K-＞<span class="number">1608</span>K（<span class="number">1664</span>K），<span class="number">0.0191592</span> secs]<span class="number">1980</span>K＞<span class="number">1608</span>K（<span class="number">2240</span>K），<span class="number">0.0197396</span> secs]</span><br><span class="line"><span class="number">0.590</span>：[GC <span class="number">0.590</span>：[DefNew：<span class="number">576</span>K-＞<span class="number">64</span>K（<span class="number">576</span>K），<span class="number">0.0006360</span> secs]<span class="number">0.590</span>：[Tenured：<span class="number">2675</span>K-＞<span class="number">2219</span>K（<span class="number">2684</span>K），<span class="number">0.0256020</span> secs]<span class="number">3090</span>K＞<span class="number">2219</span>K（<span class="number">3260</span>K），<span class="number">0.0263501</span> secs]</span><br><span class="line"><span class="number">0.958</span>：[GC <span class="number">0.958</span>：[DefNew：<span class="number">551</span>K-＞<span class="number">64</span>K（<span class="number">576</span>K），<span class="number">0.0011433</span> secs]<span class="number">0.959</span>：[Tenured：<span class="number">3979</span>K-＞<span class="number">3470</span>K（<span class="number">4084</span>K），<span class="number">0.0419335</span> secs]<span class="number">4222</span>K＞<span class="number">3470</span>K（<span class="number">4660</span>K），<span class="number">0.0431992</span> secs]</span><br><span class="line"><span class="number">1.575</span>：[Full GC <span class="number">1.575</span>：[Tenured：<span class="number">4800</span>K-＞<span class="number">5046</span>K（<span class="number">5784</span>K），<span class="number">0.0543136</span> secs]<span class="number">5189</span>K-＞<span class="number">5046</span>K（<span class="number">6360</span>K），[Perm：<span class="number">12287</span>K-＞<span class="number">12287</span>K（<span class="number">12288</span>K）]， <span class="number">0.0544163</span> secs]</span><br><span class="line"><span class="number">1.703</span>：[GC <span class="number">1.703</span>：[DefNew：<span class="number">703</span>K-＞<span class="number">63</span>K（<span class="number">704</span>K），<span class="number">0.0012609</span> secs]<span class="number">1.705</span>：[Tenured：<span class="number">8441</span>K-＞<span class="number">8505</span>K（<span class="number">8540</span>K），<span class="number">0.0607638</span> secs]<span class="number">8691</span>K＞<span class="number">8505</span>K（<span class="number">9244</span>K），<span class="number">0.0621470</span> secs]</span><br><span class="line"><span class="number">1.837</span>：[GC <span class="number">1.837</span>：[DefNew：<span class="number">1151</span>K-＞<span class="number">64</span>K（<span class="number">1152</span>K），<span class="number">0.0020698</span> secs]<span class="number">1.839</span>：[Tenured：<span class="number">14616</span>K-＞<span class="number">14680</span>K（<span class="number">14688</span>K），<span class="number">0.0708748</span> secs]<span class="number">15035</span>K-＞<span class="number">14680</span>K（<span class="number">15840</span>K），<span class="number">0.0730947</span> secs]</span><br><span class="line"><span class="number">2.144</span>：[GC <span class="number">2.144</span>：[DefNew：<span class="number">1856</span>K-＞<span class="number">191</span>K（<span class="number">1856</span>K），<span class="number">0.0026810</span> secs]<span class="number">2.147</span>：[Tenured：<span class="number">25092</span>K-＞<span class="number">24656</span>K（<span class="number">25108</span>K），<span class="number">0.1112429</span> secs]<span class="number">26172</span>K-＞<span class="number">24656</span>K（<span class="number">26964</span>K），<span class="number">0.1141099</span> secs]</span><br><span class="line"><span class="number">2.337</span>：[GC <span class="number">2.337</span>：[DefNew：<span class="number">1914</span>K-＞<span class="number">0</span>K（<span class="number">3136</span>K），<span class="number">0.0009697</span> secs]<span class="number">2.338</span>：[Tenured：<span class="number">41779</span>K-＞<span class="number">27347</span>K（<span class="number">42056</span>K），<span class="number">0.0954341</span> secs]<span class="number">42733</span>K-＞<span class="number">27347</span>K（<span class="number">45192</span>K），<span class="number">0.0965513</span> secs]</span><br><span class="line"><span class="number">2.465</span>：[GC <span class="number">2.465</span>：[DefNew：<span class="number">2490</span>K-＞<span class="number">0</span>K（<span class="number">3456</span>K），<span class="number">0.0011044</span> secs]<span class="number">2.466</span>：[Tenured：<span class="number">46379</span>K-＞<span class="number">27635</span>K（<span class="number">46828</span>K），<span class="number">0.0956937</span> secs]<span class="number">47621</span>K-＞<span class="number">27635</span>K（<span class="number">50284</span>K），<span class="number">0.0969918</span> secs]</span><br></pre></td></tr></table></figure><p>&emsp;&emsp;括号中的数字代表着老年代的容量，这组GC日志显示了10次Full GC发生的原因全部都是老年代空间耗尽，每发生一次Full GC都伴随着一次老年代空间扩容：1536KB→1664KB→2684KB→……→42056KB→46828KB，10次GC以后老年代容量从起始的1536KB扩大到46828KB，当15秒后Eclipse启动完成时，老年代容量扩大到了103428KB，代码编译开始后，老年代容量达到顶峰473MB，整个Java堆达到最大容量512MB。</p><p>&emsp;&emsp;日志还显示有些时候内存回收状况很不理想，空间扩容成为获取可用内存的最主要手段，譬如，“Tenured：25092K→24656K（25108K），0.1112429 secs”代表老年代的当前容量为25108KB，内存使用到25092KB的时候发生Full GC，花费0.11秒把内存使用降低到24656KB，只回收了不到500KB的内存，这次GC基本没有什么回收效果，仅仅做了扩容，扩容过程比起回收过程可以看做是基本不需要花费时间的，所以说这0.11秒几乎是白白浪费了。</p><p>&emsp;&emsp;由上述分析可以得出结论：Eclipse启动时Full GC大多数是由于老年代容量扩展而导致的，由永久代空间扩展而导致的也有一部分。为了避免这些扩展所带来的性能浪费，我们可以把-Xms和-XX:PermSize参数值分别设置为-Xmx和-XX: PermSizeMax参数值，强制虚拟机在启动的时候就把老年代和永久代的容量固定下来，避免运行时自动扩展。</p><p>&emsp;&emsp;根据分析，优化计划确定为：把新生代容量提升到128MB，避免新生代频繁GC；把Java堆、永久代的容量分别固定为512MB和96MB，避免内存扩展。这几个数值都是根据机器硬件、Eclipse插件和工程数量来决定的，读者实战的时候应根据VisualGC中收集到的实际数据进行设置。改动后的eclipse.ini配置如代码清单510所示。</p><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">代码清单<span class="number">5</span>-<span class="number">10</span> 内存调整后的Eclipse配置文件</span><br><span class="line">-vm</span><br><span class="line">D：/_DevSpace/jdk1.<span class="number">6.0</span>_21/bin/javaw.exe</span><br><span class="line">-startup</span><br><span class="line">plugins/org<span class="selector-class">.eclipse</span><span class="selector-class">.equinox</span><span class="selector-class">.launcher_1</span>.<span class="number">0.201</span><span class="selector-class">.R35x_v20090715</span><span class="selector-class">.jar</span></span><br><span class="line">--launcher.library</span><br><span class="line">plugins/org<span class="selector-class">.eclipse</span><span class="selector-class">.equinox</span><span class="selector-class">.launcher</span><span class="selector-class">.win32</span><span class="selector-class">.win32</span><span class="selector-class">.x86_1</span>.<span class="number">0.200</span>.v20090519</span><br><span class="line">-product</span><br><span class="line">org<span class="selector-class">.eclipse</span><span class="selector-class">.epp</span><span class="selector-class">.package</span><span class="selector-class">.jee</span><span class="selector-class">.product</span></span><br><span class="line">-showsplash</span><br><span class="line">org<span class="selector-class">.eclipse</span><span class="selector-class">.platform</span></span><br><span class="line">-vmargs</span><br><span class="line">-Dosgi.requiredJavaVersion=<span class="number">1.5</span></span><br><span class="line">-Xverify：<span class="attribute">none</span></span><br><span class="line">-Xmx512m</span><br><span class="line">-Xms512m</span><br><span class="line">-Xmn128m</span><br><span class="line">-XX：PermSize=<span class="number">96</span>m</span><br><span class="line">-XX：MaxPermSize=<span class="number">96</span>m</span><br></pre></td></tr></table></figure><p>&emsp;&emsp;现在的这个配置之下，GC次数已经大幅度降低，图5-9是Eclipse启动后1分钟的监视曲线，只发生了8次Minor GC和4次Full GC，总耗时为1.928秒。</p><p><img src="https://pic-1258215793.cos.ap-shanghai.myqcloud.com/content/20191201/201912010109.png" alt="GC调整后的运行数据"></p><p>&emsp;&emsp;这个结果已经算是基本正常，但是还存在一点瑕疵：从Old Gen曲线上看，永久代直接固定在384MB，而内存使用量只有66MB，并且一直很平滑，完全不应该发生Full GC才对，那4次Full GC是怎么来的？使用jstat-gccause查询一下最近一次GC的原因，见代码清单5-11。</p><figure class="highlight lsl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">代码清单<span class="number">5</span><span class="number">-11</span> 查询GC原因</span><br><span class="line">C：\Users\IcyFenix&gt;jps</span><br><span class="line"><span class="number">9772</span> Jps</span><br><span class="line"><span class="number">4068</span> org.eclipse.equinox.launcher_1<span class="number">.0</span><span class="number">.201</span>.R35x_v20090715.jar</span><br><span class="line">C：\Users\IcyFenix&gt;jstat-gccause <span class="number">4068</span></span><br><span class="line">S0 S1 E O P YGC YGCT FGC FGCT GCT LGCC GCC</span><br><span class="line"><span class="number">0.00</span> <span class="number">0.00</span> <span class="number">1.00</span> <span class="number">14.81</span> <span class="number">39.29</span> <span class="number">6</span> <span class="number">0.422</span> <span class="number">20</span> <span class="number">5.992</span> <span class="number">6.414</span></span><br><span class="line">System.gc() No GC</span><br></pre></td></tr></table></figure><p>&emsp;&emsp;从LGCC（Last GC Cause）中看到原来是代码调用System.gc()显式触发的GC，在内存设置调整后，这种显式GC不符合我们的期望，因此在eclipse.ini中加入参数-XX:+DisableExplicitGC屏蔽掉System.gc()。再次测试发现启动期间的Full GC已经完全没有了，只有6次Minor GC，耗时417毫秒，与调优前4.149秒的测试样本相比，正好是十分之一。进行GC调优后Eclipse的启动时间下降非常明显，比整个GC时间降低的绝对值还大，现在启动只需要7秒多，如图5-10所示。</p><p><img src="https://pic-1258215793.cos.ap-shanghai.myqcloud.com/content/20191201/201912010110.png" alt="Eclipse启动时间"></p><h3 id="3-5-选择收集器降低延迟"><a href="#3-5-选择收集器降低延迟" class="headerlink" title="3.5 选择收集器降低延迟"></a><strong>3.5 选择收集器降低延迟</strong></h3><p>&emsp;&emsp;现在Eclipse启动已经比较迅速了，但我们的调优实战还没有结束，毕竟Eclipse是拿来写程序的，不是拿来测试启动速度的。我们不妨再在Eclipse中测试一个非常常用但又比较耗时的操作：代码编译。图5-11是当前配置下Eclipse进行代码编译时的运行数据，从图中可以看出，新生代每次回收耗时约65毫秒，老年代每次回收 耗时约725毫秒。对于用户来说，新生代GC的耗时还好，65毫秒在使用中无法察觉到，而老年代每次GC停顿的时间接近1秒钟，虽然比较长时间才会出现一次，但停顿还是太长了一些。</p><p><img src="https://pic-1258215793.cos.ap-shanghai.myqcloud.com/content/20191201/201912010111.png" alt="编译期间运行数据"></p><p>&emsp;&emsp;再注意看一下编译期间的CPU资源使用状况，图5-12是Eclipse在编译期间的CPU使用率曲线图，整个编译过程中平均只使用了不到30%的CPU资源，垃圾收集的CPU使用率曲线更是几乎与坐标横轴紧贴在一起，这说明CPU资源还有很多可利用的余地。</p><p>&emsp;&emsp;列举GC停顿时间、CPU资源富余的目的，都是为接下来替换掉Client模式的虚拟机 中默认的新生代及老年代串行收集器做铺垫。</p><p>&emsp;&emsp;Eclipse应当算是与使用者交互非常频繁的应用程序，由于代码太多，作者习惯在做全量编译或清理动作的时候，使用“Run in Backgroup”功能一边编译一边继续工作。回顾一下在第3章提到的几种收集器，很容易想到CMS是最符合这类场景的收集器。因此尝试在eclipse.ini中再加入两个参数-XX:+UseConcMarkSweepGC和XX:+UseParNewGC（ParNew收集器是使用CMS收集器后的默认新生代收集器，写上仅是为了使得配置更加清晰），要求虚拟机在新生代和老年代分别使用ParNew和CMS收集器进行垃圾回收。指定收集器之后，再次测试的结果如图5-13所示，与原来使用的串行收集器对比，新生代停顿从每次65毫秒下降到了每次53毫秒，而老年代的停顿时间更是从725毫秒大幅下降到了36毫秒。</p><p><img src="https://pic-1258215793.cos.ap-shanghai.myqcloud.com/content/20191201/201912010113.png" alt="指定ParNew和CMS收集器后的GC数据"></p><p>&emsp;&emsp;当然，CMS的停顿阶段只是收集过程中的一小部分，并不是真的把垃圾收集时间从 725毫秒变成36毫秒了。在GC日志中可以看到CMS与程序并发的时间约为400毫秒。不过由于CMS默认老年代使用了68%就进行收集，所以Full GC次数上升到了6次，为了避免总体吞吐量下降得太厉害，使用-XX:CMSInitiatingOccupancyFraction=85将GC临界值提升到85%，修改-XX:CMSInitiatingOccupancyFraction参数后，Full GC次数下降至3次，这样收集器的运作结果就比较令人满意了。</p><p>&emsp;&emsp;到这里为止，对于虚拟机内存的调优就基本结束了，这次实战可以看做是一次简化的服务端调优过程，服务端调优有可能还会出现在更多方面，如数据库、资源池、 磁盘I/O等，对于虚拟机内存部分的优化，与这次实战中的思路没有太大差别。即使读者实际工作中接触不到服务器，根据自己的工作环境做一些试验，总结几个参数让自己日常工作环境的速度有较大幅度的提升也是很划算的。最终eclipse.ini的配置如代码清单5-12所示。</p><figure class="highlight haml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">代码清单5-12 修改收集器配置后的Eclipse配置</span><br><span class="line">-<span class="ruby">vm</span></span><br><span class="line"><span class="ruby">D：/_DevSpace/jdk1.<span class="number">6.0_21</span>/bin/javaw.exe</span></span><br><span class="line"><span class="ruby">-startup</span></span><br><span class="line"><span class="ruby">plugins/org.eclipse.equinox.launcher_1.<span class="number">0</span>.<span class="number">201</span>.R35x_v20090715.jar</span></span><br><span class="line"><span class="ruby">--launcher.library</span></span><br><span class="line"><span class="ruby">plugins/org.eclipse.equinox.launcher.win32.win32.x86_1.<span class="number">0</span>.<span class="number">200</span>.v20090519</span></span><br><span class="line"><span class="ruby">-product</span></span><br><span class="line"><span class="ruby">org.eclipse.epp.package.jee.product</span></span><br><span class="line"><span class="ruby">-showsplash</span></span><br><span class="line"><span class="ruby">org.eclipse.platform</span></span><br><span class="line"><span class="ruby">-vmargs</span></span><br><span class="line"><span class="ruby">-Dcom.sun.management.jmxremote</span></span><br><span class="line"><span class="ruby">-Dosgi.requiredJavaVersion=<span class="number">1.5</span></span></span><br><span class="line"><span class="ruby">-Xverify：none</span></span><br><span class="line"><span class="ruby">-Xmx512m</span></span><br><span class="line"><span class="ruby">-Xms512m</span></span><br><span class="line"><span class="ruby">-Xmn128m</span></span><br><span class="line"><span class="ruby">-XX：PermSize=<span class="number">96</span>m</span></span><br><span class="line"><span class="ruby">-XX：MaxPermSize=<span class="number">96</span>m</span></span><br><span class="line"><span class="ruby">-XX：+DisableExplicitGC</span></span><br><span class="line"><span class="ruby">-Xnoclassgc</span></span><br><span class="line"><span class="ruby">-XX：+UseParNewGC</span></span><br><span class="line"><span class="ruby">-XX：+UseConcMarkSweepGC</span></span><br><span class="line"><span class="ruby">-XX：CMSInitiatingOccupancyFraction=<span class="number">85</span></span></span><br></pre></td></tr></table></figure><hr><h2 id="第四节-总结"><a href="#第四节-总结" class="headerlink" title="第四节 总结"></a><strong>第四节 总结</strong></h2><p>&emsp;&emsp;Java虚拟机的内存管理与垃圾收集是虚拟机结构体系中最重要的组成部分，对我们程序的性能和稳定性有着非常大的影响，在本书的第2～5章中，作者从理论知识、异常现象、代码、工具、案例和实战等几个方面对其进行讲解，希望读者能有所收获。</p><p>&emsp;&emsp;本书关于虚拟机内存管理的部分到此为止就结束了，下一章我们将开始学习Class文件与虚拟机执行子系统方面的知识。</p><hr><p><em>参考博客和文章书籍等：</em></p><blockquote><p>《深入理解Java虚拟机》</p></blockquote><p><em>因博客主等未标明不可引用，若部分内容涉及侵权请及时告知，我会尽快修改和删除相关内容</em></p>]]></content>
    
    <summary type="html">
    
      简单介绍Java虚拟机中的虚拟机调优案例分析与实战，包括：概述，案例分析（高性能硬件上的程序部署策略、集群间同步导致的内存溢出、堆外内存导致的溢出错误、外部命令导致系统缓慢、服务器JVM进程崩溃、不恰当数据结构导致内存占用过大、由Windows虚拟内存导致的长时间停顿），实战：Eclipse运行速度调优（调优前的程序运行状态、升级JDK 1.6的性能变化及兼容问题、编译时间和类加载时间的优化、调整内存设置控制垃圾收集频率、选择收集器降低延迟），总结等内容。
    
    </summary>
    
      <category term="技术文档" scheme="http://linyishui.top/categories/%E6%8A%80%E6%9C%AF%E6%96%87%E6%A1%A3/"/>
    
    
      <category term="java" scheme="http://linyishui.top/tags/java/"/>
    
      <category term="jvm" scheme="http://linyishui.top/tags/jvm/"/>
    
  </entry>
  
  <entry>
    <title>虚拟机性能监控和故障处理工具</title>
    <link href="http://linyishui.top/2019112501.html"/>
    <id>http://linyishui.top/2019112501.html</id>
    <published>2019-11-25T10:10:18.000Z</published>
    <updated>2020-01-10T08:19:04.409Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="虚拟机性能监控和故障处理工具"><a href="#虚拟机性能监控和故障处理工具" class="headerlink" title="虚拟机性能监控和故障处理工具"></a><strong>虚拟机性能监控和故障处理工具</strong></h1><h2 id="第一节-引文"><a href="#第一节-引文" class="headerlink" title="第一节 引文"></a><strong>第一节 引文</strong></h2><p>&emsp;&emsp;为一个系统定位问题时，知识、经验是关键基础，数据是依据，工具是运用知识处理数据手段。数据包括：运行日志、异常堆栈、GC日志、线程快照（threaddump/javacore文件）、堆转储快照（headdump/hprof文件）等。学会使用虚拟机性能监控和故障处理工具可以加快我们分析数据、定位解决问题的速度。</p><hr><h2 id="第二节-JDK的命令行工具"><a href="#第二节-JDK的命令行工具" class="headerlink" title="第二节 JDK的命令行工具"></a><strong>第二节 JDK的命令行工具</strong></h2><p>&emsp;&emsp;JDK中的bin目录除了java.exe和javac.exe这两个常用的命令行工具还有其他程序，这些程序中包括一些虚拟机性能监控和故障处理工具，能在处理应用程序性能问题、定位故障是发挥巨大作用。</p><p>&emsp;&emsp;命令行工具都比较小巧，主要的功能代码都在tools类库中实现。如果使用Linux版本的JDK，会发现很多工具是由Shell脚本写成，可以直接用vim打开。</p><p>&emsp;&emsp;JDK开发团队选择采用Java代码来实现这些监控工具是有用意的：当应用程序部署到生产环境后，无论是直接接触物理服务器还是远程到Telnet到服务器上都可能会受到限制，借助tools.jar类库里面的接口，我们可以直接在应用程序中实现功能强大的监控分析功能。</p><table><thead><tr><th style="text-align:center">名称</th><th style="text-align:left">主要作用</th></tr></thead><tbody><tr><td style="text-align:center">jps</td><td style="text-align:left">JVM Process Status Tool，显式指定系统内所有的HotSpot虚拟机进程</td></tr><tr><td style="text-align:center">jstat</td><td style="text-align:left">JVM Statistics Monitoring Tool，用于收集HotSpot虚拟机各方面的运行数据</td></tr><tr><td style="text-align:center">jinfo</td><td style="text-align:left">Configuration Info for Java，显式虚拟机配置信息</td></tr><tr><td style="text-align:center">jmap</td><td style="text-align:left">Memory Map for Java，生成虚拟机的内存转储快照（heapdump文件）</td></tr><tr><td style="text-align:center">jhat</td><td style="text-align:left">JVM Heap Dump Browser，用于分析heapdump文件，它会建立一个HTTP/HTML服务器，让用户可以在浏览器上查看分析结果</td></tr><tr><td style="text-align:center">jstack</td><td style="text-align:left">Stack Trace for Java，显示虚拟机的线程快照</td></tr></tbody></table><h3 id="2-1-jps：虚拟机进程状况工具"><a href="#2-1-jps：虚拟机进程状况工具" class="headerlink" title="2.1 jps：虚拟机进程状况工具"></a><strong>2.1 jps：虚拟机进程状况工具</strong></h3><p>&emsp;&emsp;JVM Process Status Tool，除了名字像UNIX的ps命令外，其功能也类似于ps命令：可以列出正在运行的虚拟机进程，并显示虚拟机执行主类（Main Class，main()函数所在的类）名称以及这些进程的本地虚拟机唯一ID（Local Virtual Machine Identifer，LVMD）。</p><p>&emsp;&emsp;虽然功能单一，但其是<strong>使用频率最高</strong>的JDK命令行工具，其他工具大多需要输入它查询到的LVMID来确定要监控的是哪一个虚拟机进程。</p><p>&emsp;&emsp;对于本地虚拟机进程来说，LVMID与操作系统的进程ID（Process Identifier，PID）是一致的，使用Windows平台的任务管理器或UNIX平台的ps命令也可以查到LVMID，但若同时启动了多个虚拟机进程，无法根据进程名称进行定位时，就只能依赖于jps命令显式主类的功能来进行区分了。</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-tag">--jps</span>命令格式</span><br><span class="line"><span class="selector-tag">jps</span> <span class="selector-attr">[ options ]</span> <span class="selector-attr">[ hostid ]</span></span><br><span class="line"></span><br><span class="line"><span class="selector-tag">--jps</span>执行样例</span><br><span class="line"><span class="selector-tag">D</span>:\<span class="selector-tag">Develop</span>\<span class="selector-tag">Java</span>\<span class="selector-tag">jdk1</span><span class="selector-class">.6</span><span class="selector-class">.0_21</span>\<span class="selector-tag">bin</span>&gt;<span class="selector-tag">jps</span> <span class="selector-tag">-l</span></span><br><span class="line">2388 <span class="selector-tag">D</span>:\<span class="selector-tag">Develop</span>\<span class="selector-tag">glassfish</span>\<span class="selector-tag">bin</span>\..\<span class="selector-tag">modules</span>\<span class="selector-tag">admin-cli</span><span class="selector-class">.jar</span></span><br><span class="line">2764 <span class="selector-tag">com</span><span class="selector-class">.sun</span><span class="selector-class">.enterprise</span><span class="selector-class">.glassfish</span><span class="selector-class">.bootstrap</span><span class="selector-class">.ASMain</span></span><br><span class="line">3788 <span class="selector-tag">sun</span><span class="selector-class">.tools</span><span class="selector-class">.jps</span><span class="selector-class">.Jps</span></span><br></pre></td></tr></table></figure><p>&emsp;&emsp;jps可以通过<strong>RMI协议</strong>查询开启了RMI服务的远程虚拟机进程状态，hostid为RMI注册表中注册的主机名。jps其他常用选项如下表。</p><table><thead><tr><th style="text-align:center">选项</th><th style="text-align:left">作用</th></tr></thead><tbody><tr><td style="text-align:center">-q</td><td style="text-align:left">只输出LVMID，省略主类的名称</td></tr><tr><td style="text-align:center">-m</td><td style="text-align:left">输出虚拟机进程启动时传递给主类main()函数的参数</td></tr><tr><td style="text-align:center">-l</td><td style="text-align:left">输出主类的全名，如果进程执行的是Jar包，输出Jar路径</td></tr><tr><td style="text-align:center">-v</td><td style="text-align:left">输出虚拟机进程启动时JVM参数</td></tr></tbody></table><h3 id="2-2-jstat：虚拟机统计信息监视工具"><a href="#2-2-jstat：虚拟机统计信息监视工具" class="headerlink" title="2.2 jstat：虚拟机统计信息监视工具"></a><strong>2.2 jstat：虚拟机统计信息监视工具</strong></h3><p>&emsp;&emsp;JVM Statistics Monitoring Tool，是<strong>用于监视虚拟机各种运行状态信息的命令行工具</strong>。可以显示本地或远程虚拟机进程中的类装载、内存、垃圾收集、JIT编译等运行数据，在没有GUI图形界面，只提供了纯文本控制台环境的服务器上，它将是<strong>运行期定位虚拟机性能问题的首选工具</strong>。</p><figure class="highlight inform7"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">--jstat命令格式为：</span><br><span class="line">jstat <span class="comment">[ option vmid <span class="comment">[interval<span class="comment">[s|ms]</span> <span class="comment">[count]</span> ]</span> ]</span></span><br></pre></td></tr></table></figure><p>&emsp;&emsp;对于命令格式中的VMID与LVMID需要特别说明一下：如果是本地虚拟机进程，VMID与LVMID是一致的，如果是远程虚拟机进程，那VMID的格式应当是：</p><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[<span class="string">protocol：</span>][<span class="symbol">//</span>]lvmid[@hostname[：port]/servername]</span><br></pre></td></tr></table></figure><p>&emsp;&emsp;参数interval和count代表查询间隔和次数，如果省略这两个参数，说明只查询一次。假设需要每250毫秒查询一次进程2764垃圾收集的状况，一共查询20次，那命令应当是：</p><figure class="highlight lsl"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">jstat -gc <span class="number">2764</span> <span class="number">250</span> <span class="number">20</span></span><br></pre></td></tr></table></figure><p>&emsp;&emsp;选项option代表着用户希望查询的虚拟机信息，主要分为3类：类装载、垃圾收集和运行期编译状况，具体选项及作用请参考表4-3中的描述。</p><p><img src="https://pic-1258215793.cos.ap-shanghai.myqcloud.com/content/20191101/201911010159.png" alt="jstat工具主要选项"></p><p>&emsp;&emsp;举一例监视一台刚刚启动的GlassFish v3服务器的内存状况的例子来演示如何查看监视结果。监视参数与输出结果如代码清单4-1所示。</p><p><img src="https://pic-1258215793.cos.ap-shanghai.myqcloud.com/content/20191101/201911010160.png" alt="jstat执行样例"></p><p>&emsp;&emsp;查询结果表明：这台服务器的新生代Eden区（E，表示Eden）使用了6.2%的空间，两个Survivor区（S0、S1，表示Survivor0、Survivor1）里面都是空的，老年代（O，表示Old）和永久代（P，表示Permanent）则分别使用了41.42%和47.20%的空间。程序运行以来共发生Minor GC（YGC，表示Young GC）16次，总耗时0.105 秒，发生Full GC（FGC，表示Full GC）3次，Full GC总耗时（FGCT，表示Full GC Time）为0.472秒，所有GC总耗时（GCT，表示GC Time）为0.577秒。</p><p>&emsp;&emsp;使用jstat工具在纯文本状态下监视虚拟机状态的变化，确实不如后面将会提到的VisualVM等可视化的监视工具直接以图表展现的那样直观。但许多服务器管理员都习惯了在文本控制台中工作，直接在控制台中使用jstat命令依然是一种常用的监控方式。</p><h3 id="2-3-jinfo：Java配置信息工具"><a href="#2-3-jinfo：Java配置信息工具" class="headerlink" title="2.3 jinfo：Java配置信息工具"></a><strong>2.3 jinfo：Java配置信息工具</strong></h3><p>&emsp;&emsp;jinfo（Configuration Info for Java）的作用是<strong>实时地查看和调整虚拟机的各项参数</strong>。使用jps命令的-v参数可以查看虚拟机启动时显式指定的参数列表，但如果想知道未被显式指定的参数的系统默认值，除了去找资料外，就只能使用jinfo的flag选项进行查询了（如果只限于JDK 1.6或以上版本的话，使用java -XX：+PrintFlagsFinal查看参数默认值也是一个很好的选择），jinfo还可以使用sysprops选项把虚拟机进程的System.getProperties()的内容打印出来。</p><p>&emsp;&emsp;这个命令在JDK 1.5时期已经随着Linux版的JDK发布，当时只提供了信息查询的功能，JDK 1.6之后，jinfo在Windows和Linux平台都有提供，并且加入了运行期修改参数的能力，可以使用-flag [+|-] name或-flag name = value修改一部分运行期可写的虚拟机参数值。JDK 1.6中，jinfo对于Windows平台的功能仍然有较大的限制，只提供了最基本的-flag选项。</p><figure class="highlight haml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">-<span class="ruby">-jinfo命令格式：</span></span><br><span class="line"><span class="ruby">jinfo [ option ] pid</span></span><br><span class="line"><span class="ruby"></span></span><br><span class="line"><span class="ruby">--执行样例：查询CMSInitiatingOccupancyFraction参数值。</span></span><br><span class="line"><span class="ruby">C：\&gt;jinfo -flag CMSInitiatingOccupancyFraction <span class="number">1444</span></span></span><br><span class="line"><span class="ruby">-<span class="symbol">XX:</span>CMSInitiatingOccupancyFraction=<span class="number">85</span></span></span><br></pre></td></tr></table></figure><h3 id="2-4-jmap：Java内存映像工具"><a href="#2-4-jmap：Java内存映像工具" class="headerlink" title="2.4 jmap：Java内存映像工具"></a><strong>2.4 jmap：Java内存映像工具</strong></h3><p>&emsp;&emsp;jmap（Memory Map for Java）命令用于生成堆转储快照（一般称为heapdump或dump文件）。如果不使用jmap命令，要想获取Java堆转储快照还有一些比较“暴力”的手段：譬如-XX:HeapDumpOnOutOfMemoryError参数，可以让虚拟机在OOM异常出现之后自动生成dump文件，通过-XX:HeapDumpOnCtrlBreak参数则可以使用[Ctrl]+[Break]键让虚拟机生成dump文件，又或者在Linux系统下通过Kill-3命令发送进程退出信号“恐吓”一下虚拟机，也能拿到dump文件。</p><p>&emsp;&emsp;jmap的作用并不仅仅是为了获取dump文件，它还可以查询finalize执行队列，Java堆和永久代的详细信息，如空间使用率、当前用的是哪种收集器等。</p><p>&emsp;&emsp;和jinfo命令一样，jmap有不少功能在Windows平台下都是受限的，除了生成dump文件的-dump选项和用于查看每个类的实例、空间占用统计的-histo选项所有操作系统都提供之外，其余选项都只能在Linux/Solaris下使用。</p><figure class="highlight haml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">-<span class="ruby">-jmap命令格式：</span></span><br><span class="line"><span class="ruby">jmap [ option ] vmid</span></span><br></pre></td></tr></table></figure><p>&emsp;&emsp;option选项的合法值与具体含义如表4-4所示</p><p><img src="https://pic-1258215793.cos.ap-shanghai.myqcloud.com/content/20191101/201911010161.png" alt="jmap工具主要选项"></p><p>&emsp;&emsp;代码清单4-2是使用jmap生成一个正在运行的Eclipse的dump快照文件的例子，例子中的3500是通过jps命令查询到的LVMID。</p><figure class="highlight gradle"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">--代码清单<span class="number">4</span>-<span class="number">2</span> 使用jmap生成<span class="keyword">dump</span>文件</span><br><span class="line">C：\Users\IcyFenix&gt;jmap-<span class="keyword">dump</span>：format=b, <span class="keyword">file</span>=eclipse.bin <span class="number">3500</span></span><br><span class="line">Dumping heap to C：\Users\IcyFenix\eclipse.bin……</span><br><span class="line">Heap <span class="keyword">dump</span> <span class="keyword">file</span> created</span><br></pre></td></tr></table></figure><h3 id="2-5-jhat：虚拟机堆转储快照分析工具"><a href="#2-5-jhat：虚拟机堆转储快照分析工具" class="headerlink" title="2.5 jhat：虚拟机堆转储快照分析工具"></a><strong>2.5 jhat：虚拟机堆转储快照分析工具</strong></h3><p>&emsp;&emsp;Sun JDK提供jhat（JVM Heap Analysis Tool）命令与jmap搭配使用，来分析jmap生成的堆转储快照。jhat内置了一个微型的HTTP/HTML服务器，生成dump文件的分析结果后，可以在浏览器中查看。</p><p>&emsp;&emsp;不过实事求是地说，在实际工作中，除非真的没有别的工具可用，否则<strong>一般都不会去直接使用jhat命令来分析dump文件</strong>，主要原因有二：一是一般不会在部署应用程序的服务器上直接分析dump文件，即使可以这样做，也会尽量将dump文件拷贝到其他机器上进行分析，因为分析工作是一个耗时而且消耗硬件资源的过程，既然都要在其他机器上进行，就没必要受到命令行工具的限制了。另外一个原因是jhat的分析功能相对来说比较简陋，后文将会介绍到VisualVM，以及专业用于分析dump文件的Eclipse Memory Analyzer、IBM HeapAnalyzer等工具，都能实现比jhat更强大更专业的分析功能。代码清单4-3演示了使用jhat分析上一节采用jmap生成的Eclipse IDE的内存快照文件。</p><figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">--代码清单4-3 使用jhat分析dump文件</span><br><span class="line">C：\Users\IcyFenix&gt;jhat eclipse.bin</span><br><span class="line">Reading <span class="keyword">from</span> eclipse.bin……</span><br><span class="line">Dump file created Fri Nov 19 22：07：21 CST 2010</span><br><span class="line">Snapshot read, resolving……</span><br><span class="line">Resolving 1225951 objects……</span><br><span class="line">Chasing references, expect 245 dots……</span><br><span class="line">Eliminating duplicate references……</span><br><span class="line">Snapshot resolved.</span><br><span class="line">Started HTTP<span class="built_in"> server </span>on<span class="built_in"> port </span>7000</span><br><span class="line">Server is ready.</span><br></pre></td></tr></table></figure><p>&emsp;&emsp;屏幕显示“Server is ready.”的提示后，用户在浏览器中键入http：//localhost：7000/就可以看到分析结果，如图4-3所示。</p><p><img src="https://pic-1258215793.cos.ap-shanghai.myqcloud.com/content/20191101/201911010162.png" alt="jhat的分析结果"></p><p>&emsp;&emsp;分析结果默认以包为单位进行分组显示，分析内存泄漏问题主要会使用到其中的“Heap Histogram”（与jmap-histo功能一样）与OQL页签的功能，前者可以找到内存中总容量最大的对象，后者是标准的对象查询语言，使用类似SQL的语法对内存中的对象进行查询统计。</p><h3 id="2-6-jstack：Java堆栈跟踪工具"><a href="#2-6-jstack：Java堆栈跟踪工具" class="headerlink" title="2.6 jstack：Java堆栈跟踪工具"></a><strong>2.6 jstack：Java堆栈跟踪工具</strong></h3><p>&emsp;&emsp;jstack（Stack Trace for Java）命令用于生成虚拟机当前时刻的<strong>线程快照</strong>（一般称为threaddump或javacore文件）。<strong>线程快照就是当前虚拟机内每一条线程正在执行的方法堆栈的集合</strong>，生成线程快照的主要目的是<strong>定位线程出现长时间停顿的原因</strong>，如线程间死锁、死循环、请求外部资源导致的长时间等待等都是导致线程长时间停顿的常见原因。线程出现停顿的时候通过jstack来查看各个线程的调用堆栈，就可以知道没有响应的线程到底在后台做些什么事情，或者等待着什么资源。</p><figure class="highlight haml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">-<span class="ruby">-jstack命令格式：</span></span><br><span class="line"><span class="ruby">jstack [ option ] vmid</span></span><br></pre></td></tr></table></figure><p>&emsp;&emsp;option选项的合法值与具体含义如表4-5所示。</p><p><img src="https://pic-1258215793.cos.ap-shanghai.myqcloud.com/content/20191101/201911010163.png" alt="jstack工具的主要选项"></p><p>&emsp;&emsp;代码清单4-4是使用jstack查看Eclipse线程堆栈的例子，例子中的3500是通过jps命令查询到的LVMID。</p><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">代码清单<span class="number">4</span>-<span class="number">4</span> 使用jstack查看线程堆栈（部分结果）</span><br><span class="line">C：\Users\IcyFenix&gt;jstack-l <span class="number">3500</span></span><br><span class="line"><span class="number">2010</span>-<span class="number">11</span>-<span class="number">19</span> <span class="number">23</span>：<span class="number">11</span>：<span class="number">26</span></span><br><span class="line">Full thread dump Java HotSpot（TM）<span class="number">64</span>-Bit Server VM（<span class="number">17.1</span>-b03 mixed mode）：</span><br><span class="line"><span class="string">"[ThreadPool Manager] - Idle Thread"</span> daemon prio=<span class="number">6</span> tid=<span class="number">0</span>x0000000039dd4000 nid=<span class="number">0</span>xf50 <span class="keyword">in</span> Object.wait() [<span class="number">0</span>x000000003c96f000]</span><br><span class="line">    java<span class="selector-class">.lang</span><span class="selector-class">.Thread</span><span class="selector-class">.State</span>：WAITING（on <span class="selector-tag">object</span> monitor）</span><br><span class="line">        at java<span class="selector-class">.lang</span><span class="selector-class">.Object</span><span class="selector-class">.wait</span>（Native Method）</span><br><span class="line">        -waiting on&lt;<span class="number">0</span>x0000000016bdcc60&gt;（<span class="selector-tag">a</span> org<span class="selector-class">.eclipse</span><span class="selector-class">.equinox</span><span class="selector-class">.internal</span><span class="selector-class">.util</span><span class="selector-class">.impl</span><span class="selector-class">.tpt</span><span class="selector-class">.threadpool</span><span class="selector-class">.Executor</span>）</span><br><span class="line">        at java<span class="selector-class">.lang</span><span class="selector-class">.Object</span><span class="selector-class">.wait</span>（Object.java：<span class="number">485</span>）</span><br><span class="line">        at org<span class="selector-class">.eclipse</span><span class="selector-class">.equinox</span><span class="selector-class">.internal</span><span class="selector-class">.util</span><span class="selector-class">.impl</span><span class="selector-class">.tpt</span><span class="selector-class">.threadpool</span><span class="selector-class">.Executor</span><span class="selector-class">.run</span>（Exe <span class="number">106</span>）</span><br><span class="line">        -locked&lt;<span class="number">0</span>x0000000016bdcc60&gt;（<span class="selector-tag">a</span> org<span class="selector-class">.eclipse</span><span class="selector-class">.equinox</span><span class="selector-class">.internal</span><span class="selector-class">.util</span><span class="selector-class">.impl</span><span class="selector-class">.tpt</span><span class="selector-class">.threadpool</span><span class="selector-class">.Executor</span>）</span><br><span class="line"></span><br><span class="line">    Locked ownable synchronizers：</span><br><span class="line">        -None</span><br></pre></td></tr></table></figure><p>&emsp;&emsp;在JDK 1.5中，java.lang.Thread类新增了一个getAllStackTraces()方法用于获取虚拟机中所有线程的StackTraceElement对象。使用这个方法可以通过简单的几行代码就完成jstack的大部分功能，在实际项目中不妨调用这个方法做个管理员页面，可以随时使用浏览器来查看线程堆栈，如代码清单4-5所示，这是书作者的一个小经验。</p><figure class="highlight mojolicious"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="xml">代码清单4-5 查看线程状况的JSP页面</span></span><br><span class="line"><span class="xml"><span class="tag">&lt;<span class="name">%</span></span></span><span class="perl">@ page import=<span class="string">"java.util.Map"</span></span><span class="xml"><span class="tag">%&gt;</span></span></span><br><span class="line"><span class="xml"></span></span><br><span class="line"><span class="xml"><span class="tag">&lt;<span class="name">html</span>&gt;</span></span></span><br><span class="line"><span class="xml"><span class="tag">&lt;<span class="name">head</span>&gt;</span></span></span><br><span class="line"><span class="xml"><span class="tag">&lt;<span class="name">title</span>&gt;</span>服务器线程信息<span class="tag">&lt;/<span class="name">title</span>&gt;</span></span></span><br><span class="line"><span class="xml"><span class="tag">&lt;/<span class="name">head</span>&gt;</span></span></span><br><span class="line"><span class="xml"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span></span><br><span class="line"><span class="xml"><span class="tag">&lt;<span class="name">pre</span>&gt;</span></span></span><br><span class="line"><span class="xml"><span class="tag">&lt;<span class="name">%</span></span></span><span class="perl"></span></span><br><span class="line"><span class="perl">    <span class="keyword">for</span>(Map.Entry&lt;Thread, StackTraceElement[]&gt;stackTrace： Thread.getAllStackTraces().entrySet())&#123;</span></span><br><span class="line"><span class="perl">        Thread thread=(Thread)stackTrace.getKey();</span></span><br><span class="line"><span class="perl">        StackTraceElement[]stack=(StackTraceElement[]) stackTrace.getValue();</span></span><br><span class="line"><span class="perl">        <span class="keyword">if</span>(thread.equals(Thread.currentThread()))&#123;</span></span><br><span class="line"><span class="perl">            <span class="keyword">continue</span>;</span></span><br><span class="line"><span class="perl">        &#125;</span></span><br><span class="line"><span class="perl">        out.<span class="keyword">print</span>(<span class="string">"\n线程："</span>+thread.getName()+<span class="string">"\n"</span>);</span></span><br><span class="line"><span class="perl">        <span class="keyword">for</span>(StackTraceElement element：stack)&#123;</span></span><br><span class="line"><span class="perl">            out.<span class="keyword">print</span>(<span class="string">"\t"</span>+element+<span class="string">"\n"</span>);</span></span><br><span class="line"><span class="perl">        &#125;</span></span><br><span class="line"><span class="perl">    &#125;</span></span><br><span class="line"><span class="perl"></span><span class="xml">%&gt;</span></span><br><span class="line"><span class="xml"><span class="tag">&lt;/<span class="name">pre</span>&gt;</span></span></span><br><span class="line"><span class="xml"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span></span><br><span class="line"><span class="xml"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span></span><br></pre></td></tr></table></figure><h3 id="2-7-HSDIS：JIT生成代码反汇编"><a href="#2-7-HSDIS：JIT生成代码反汇编" class="headerlink" title="2.7 HSDIS：JIT生成代码反汇编"></a><strong>2.7 HSDIS：JIT生成代码反汇编</strong></h3><p>&emsp;&emsp;在Java虚拟机规范中，详细描述了虚拟机指令集中每条指令的执行过程、执行前后对操作数栈、局部变量表的影响等细节。这些细节描述与Sun的早期虚拟机高度吻合，但随着技术的发展，高性能虚拟机真正的细节实现方式已经渐渐与虚拟机规范所描述的方式产生了越来越大的差距，虚拟机规范的描述逐渐成了虚拟机实现的“<strong>概念模型</strong>”——即实现只能保证规范描述等效。基于这个原因，我们分析程序的<strong>执行语义问题</strong>（虚拟机做了什么）时，在字节码层面上分析完全可行，但分析程序的<strong>执行行为问题</strong>（虚拟机是怎样做的、性能如何）时，在字节码层面上分析就没有什么意义了，需要通过其他方式解决。</p><p>&emsp;&emsp;分析程序如何执行，通过软件调试工具（CDB、Windbg等）来断点调试是最常见的手段，但这样的调试方式在Java虚拟机中会遇到很大的困难，因为大量执行代码是<strong>通过JIT编译器动态生成到CodeBuffer中</strong>的，没有很简单的手段来处理这种混合模式的调试。基于这种背景来引入HSDIS插件。</p><p>&emsp;&emsp;HSDIS是一个Sun官方推荐的HotSpot虚拟机JIT编译代码的反汇编插件，它包含在HotSpot虚拟机的源码中，但没有提供编译后的程序。可以在Project Kenai网站下载到单独的源码。它的作用是让HotSpot的-XX:+PrintAssembly指令调用它来把动态生成的本地代码还原为汇编代码输出，同时还生成了大量非常有价值的注释，这样我们就可以通过输出的代码来分析问题。我们可以根据自己的操作系统和CPU类型从Project Kenai网站上下载编译好的插件，直接放到JDK_HOME/jre/bin/client和JDK_HOME/jre/bin/server目录中即可。</p><p>&emsp;&emsp;如果使用的是Debug或FastDebug版的HotSpot，可以直接通过-XX:+PrintAssembly指令使用插件;如果使用的是Product版的HotSpot，还需要额外加入一个-XX:+UnlockDiagnosticVMOptions参数。以下简单测试代码演示如何使用插件。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Bar</span> &#123;</span></span><br><span class="line">    <span class="keyword">int</span> a = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">int</span> b = <span class="number">2</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">sum</span><span class="params">(<span class="keyword">int</span> c)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> a + b + c;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">new</span> Bar.sum(<span class="number">3</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>&emsp;&emsp;编译这段代码，并使用以下命令执行。</p><figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">java -XX:+PrintAssembly -Xcomp -XX:<span class="attribute">CompileCommand</span>=dontinline,*Bar.sum -XX:<span class="attribute">CompileCommand</span>=compileonly,*Bar.sum test.Bar</span><br></pre></td></tr></table></figure><p>&emsp;&emsp;其中，-Xcomp是让虚拟机以编译模式执行代码，这样代码可以“偷懒”，不需要执行足够次数来预热就可以触发JIT编译（此指令在较新的HotSpot中被移除了，可以加个循环预热代码从而触发JIT编译）。两个-XX:CompileCommand意思是让编译器不要内联sum()并且只编译sum()，-XX:+PrintAssembly就是输出反汇编内容。</p><figure class="highlight perl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">[Disassembling <span class="keyword">for</span> mach=<span class="string">'i386'</span>]</span><br><span class="line">[Entry Point]</span><br><span class="line">[Constants]</span><br><span class="line">  <span class="comment"># &#123;method&#125; 'sum' '(I)I' in 'test/Bar'</span></span><br><span class="line">  <span class="comment"># this:     ecx       = 'test/Bar'</span></span><br><span class="line">  <span class="comment"># parm0:    edx       = int</span></span><br><span class="line">  <span class="comment">#           [sp+0x20]  (sp of caller)</span></span><br><span class="line">  ……</span><br><span class="line">  <span class="number">0x01cac407</span>: cmp    <span class="number">0x4</span>(%ecx),%eax</span><br><span class="line">  <span class="number">0x01cac40a</span>: jne    <span class="number">0x01c6b050</span>         ;   <span class="string">&#123;runtime_call&#125;</span></span><br><span class="line">[Verified Entry Point]</span><br><span class="line">  <span class="number">0x01cac410</span>: mov    %eax,-<span class="number">0x8000</span>(%esp)</span><br><span class="line">  <span class="number">0x01cac417</span>: <span class="keyword">push</span>   %ebp</span><br><span class="line">  <span class="number">0x01cac418</span>: <span class="function"><span class="keyword">sub</span>    $0<span class="title">x18</span>,%<span class="title">esp</span>         </span>;*aload_<span class="number">0</span></span><br><span class="line">                                        ; - test.Bar::sum@0 (line  <span class="number">8</span>)</span><br><span class="line">  ;;  block B<span class="number">0</span> [<span class="number">0</span>, <span class="number">10</span>]</span><br><span class="line"></span><br><span class="line">  <span class="number">0x01cac41b</span>: mov    <span class="number">0x8</span>(%ecx),%eax     ;*getfield a</span><br><span class="line">                                        ; - test.Bar::sum@1 (line <span class="number">8</span>)</span><br><span class="line">  <span class="number">0x01cac41e</span>: mov    $0x3d2fad8,%esi    ;   &#123;oop(a </span><br><span class="line"><span class="string">'java/lang/Class'</span> = <span class="string">'test/Bar'</span>)&#125;</span><br><span class="line">  <span class="number">0x01cac423</span>: mov    <span class="number">0x68</span>(%esi),%esi    ;*getstatic b</span><br><span class="line">                                        ; - test.Bar::sum@4 (line <span class="number">8</span>)</span><br><span class="line">  <span class="number">0x01cac426</span>: add    %esi,%eax</span><br><span class="line">  <span class="number">0x01cac428</span>: add    %edx,%eax</span><br><span class="line">  <span class="number">0x01cac42a</span>: add    $0x18,%esp</span><br><span class="line">  <span class="number">0x01cac42d</span>: <span class="keyword">pop</span>    %ebp</span><br><span class="line">  <span class="number">0x01cac42e</span>: test   %eax,<span class="number">0x2b0100</span>      ;   <span class="string">&#123;poll_return&#125;</span></span><br><span class="line">  <span class="number">0x01cac434</span>: ret</span><br></pre></td></tr></table></figure><p>&emsp;&emsp;代码并不多，一句一句来看：</p><ol><li>mov %eax,-0x8000(%esp)：检查栈溢。</li><li>push %ebp：保存上一栈帧基址。</li><li>sub $0x18,%esp：给新帧分配空间。</li><li>mov 0x8(%ecx),%eax：取实例变量a，这里0x8(%ecx)就是ecx+0x8的意思，前面“[Constants]”节中提示了“this:ecx = ‘test/Bar’”，即ecx寄存器中放的就是this对象的地址。偏移0x8是越过this对象的对象头，之后就是实例变量a的内存位置。这次是访问“Java堆”中的数据。</li><li>mov $0x3d2fad8,%esi：取test.Bar在方法区的指针。</li><li>mov 0x68(%esi),%esi：取类变量b，这次是访问“方法区”中的数据。</li><li>add %esi,%eax 、add %edx,%eax：做2次加法，求a+b+c的值，前面的代码把a放在eax中，把b放在esi中，而c在[Constants]中提示了，“parm0:edx = int”，说明c在edx中。</li><li>add $0x18,%esp：撤销栈帧。</li><li>pop %ebp：恢复上一栈帧。</li><li>test %eax,0x2b0100：轮询方法返回处的SafePoint</li><li>ret：方法返回。[/list]</li></ol><hr><h2 id="第三节-JDK的可视化工具"><a href="#第三节-JDK的可视化工具" class="headerlink" title="第三节 JDK的可视化工具"></a><strong>第三节 JDK的可视化工具</strong></h2><p>&emsp;&emsp;JDK中除了提供大量的命令行工具外，还有两个功能强大的可视化工具：JConsole和VisualVM，这两个工具是JDK的正式成员，没有被贴上“unsupported and experimental”的标签。</p><p>&emsp;&emsp;其中JConsole是在JDK 1.5时期就已经提供的虚拟机监控工具，而VisualVM在JDK 1.6 Update7中才首次发布，现在已经成为Sun（Oracle）主力推动的多合一故障处理工具，并且已经从JDK中分离出来成为可以独立发展的开源项目。</p><h3 id="3-1-JConsole：Java监视与管理控制台"><a href="#3-1-JConsole：Java监视与管理控制台" class="headerlink" title="3.1 JConsole：Java监视与管理控制台"></a><strong>3.1 JConsole：Java监视与管理控制台</strong></h3><p>&emsp;&emsp;JConsole（Java Monitoring and Management Console）是一款基于JMX的可视化监视和管理的工具。它管理部分的功能是针对JMX MBean进行管理，由于MBean可以使用代码、中间件服务器的管理控制台或者所有符合JMX规范的软件进行访问，所以本节中将会着重介绍JConsole监视部分的功能。</p><h4 id="3-1-1-启动JConsole"><a href="#3-1-1-启动JConsole" class="headerlink" title="3.1.1 启动JConsole"></a><strong>3.1.1 启动JConsole</strong></h4><p>&emsp;&emsp;通过JDK/bin目录下的“jconsole.exe”启动JConsole后，将自动搜索出本机运行的所有虚拟机进程，不需要用户自己再使用jps来查询了，如图4-4所示。双击选择其中一个进程即可开始监控，也可以使用下面的“远程进程”功能来连接远程服务器，对远程虚拟机进行监控。</p><p><img src="https://pic-1258215793.cos.ap-shanghai.myqcloud.com/content/20191101/201911010164.jpg" alt="JConsole连接页面"></p><p>&emsp;&emsp;从图4-4中可以看到作者的机器现在运行了Eclipse、JConsole和MonitoringTest一共三个本地虚拟机进程，其中MonitoringTest就是作者准备的“反面教材”代码之一。双击它进入JConsole主界面，可以看到主界面里共包括“概述”、“内存”、“线程”、“类”、“VM摘要”和“MBean”六个页签，如图4-5所示。</p><p><img src="https://pic-1258215793.cos.ap-shanghai.myqcloud.com/content/20191101/201911010165.png" alt="JConsole主界面"></p><p>&emsp;&emsp;“概述”页签显示的是整个虚拟机主要运行数据的概览，其中包括“堆内存使用情况”、“线程”、“类”、“CPU使用情况”四项信息的曲线图，这些曲线图是后面“内存”、“线程”、“类”页签的信息汇总，具体内容将在后面介绍。</p><h4 id="3-1-2-内存监控"><a href="#3-1-2-内存监控" class="headerlink" title="3.1.2 内存监控"></a><strong>3.1.2 内存监控</strong></h4><p>&emsp;&emsp;“内存”页签相当于可视化的jstat命令，用于监视受收集器管理的虚拟机内存（Java堆和永久代）的变化趋势。我们通过运行下列代码清单中的代码来体验一下它的监视功能。运行时设置的虚拟机参数为：-Xms100m-Xmx100m-XX：+UseSerialGC，这段代码的作用是以64KB/50毫秒的速度往Java堆中填充数据，一共填充1000次，使用JConsole的“内存”页签进行监视，观察曲线和柱状指示图的变化。</p><figure class="highlight cs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">*内存占位符对象，一个OOMObject大约占64K</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">class</span> <span class="title">OOMObject</span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">byte</span>[] placeholder = <span class="keyword">new</span> <span class="keyword">byte</span>[<span class="number">64</span>*<span class="number">1024</span>];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">fillHeap</span> (<span class="params"><span class="keyword">int</span> num</span>) throws InterruptedException</span>&#123;</span><br><span class="line">    List&lt;OOMObject&gt; list = <span class="keyword">new</span> ArrayList&lt;OOMObject&gt;();</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;num; i++) &#123;</span><br><span class="line">        <span class="comment">//稍作延时，令监视曲线的变化更加明显</span></span><br><span class="line">        Thread.sleep(<span class="number">50</span>);</span><br><span class="line">        list.<span class="keyword">add</span>(<span class="keyword">new</span> OOMObject());</span><br><span class="line">    &#125;</span><br><span class="line">    System.gc();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span>(<span class="params">String[]args</span>) throws Exception</span>&#123;</span><br><span class="line">    fillHeap(<span class="number">1000</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>&emsp;&emsp;程序运行后，在“内存”页签中可以看到内存池Eden区的运行趋势呈现折线状，如图4-6所示。而监视范围扩大至整个堆后，会发现曲线是一条向上增长的平滑曲线。 并且从柱状图可以看到，在1000次循环执行结束，运行了System.gc()后，虽然整个新生代Eden和Survivor区都基本被清空了，但是代表老年代的柱状图仍然保持峰值状态，说明被填充进堆中的数据在System.gc()方法执行之后仍然存活着。作者的分析就到此为止，提两个小问题供读者思考一下，答案稍后给出。</p><ol><li>虚拟机启动参数只限制了Java堆为100MB，没有指定-Xmn参数，能否从监控图中估计出新生代有多大？</li><li>为何执行了System.gc()之后，图4-6中代表老年代的柱状图仍然显示为峰值状态，代码需要如何调整才能让System.gc()回收掉填充到堆中的对象？</li></ol><p><img src="https://pic-1258215793.cos.ap-shanghai.myqcloud.com/content/20191101/201911010166.png" alt="Eden区内存变化状况"></p><p>&emsp;&emsp;问题1的答案：图4-6显示Eden空间为27328KB，因为没有设置-XX：SurvivorRadio参数，所以Eden与Survivor空间比例为默认值8:1，因此整个新生代空间大约为27328KB×125%=34160KB。</p><p>&emsp;&emsp;问题2的答案：System.gc()之后，空间未能回收是因为List<oomobject> list对象仍然存活着，fillHeap()方法仍然没有退出，因此list对象在执行 System.gc()时仍然处于作用域之内。如果把System.gc()移动到fillHeap()方法外，调用就可以回收掉全部内存。</oomobject></p><h4 id="3-1-3-线程监控"><a href="#3-1-3-线程监控" class="headerlink" title="3.1.3 线程监控"></a><strong>3.1.3 线程监控</strong></h4><p>&emsp;&emsp;如果上面的“内存”页签相当于可视化的jstat命令的话，“线程”页签的功能则相当于可视化的jstack命令，遇到线程停顿的时候可以使用这个页签进行监控分析。前面讲解jstack命令的时候提到过线程长时间停顿的主要原因有：等待外部资源(数据库连接、网络资源、设备资源等)、死循环、锁等待(活锁和死锁)。通过代码清单4-7分别演示一下这几种情况。</p><figure class="highlight cs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">*线程死循环演示</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">createBusyThread</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    Thread thread = <span class="keyword">new</span> Thread(<span class="keyword">new</span> Runnable()&#123;</span><br><span class="line">        @Override</span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">            <span class="keyword">while</span>(<span class="literal">true</span>);<span class="comment">//第41行                    </span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;，<span class="string">"testBusyThread"</span>);</span><br><span class="line">    thread.start();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">*线程锁等待演示</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">createLockThread</span>(<span class="params">final Object <span class="keyword">lock</span></span>) </span>&#123;</span><br><span class="line">    Thread thread=<span class="keyword">new</span> Thread(<span class="keyword">new</span> Runnable()&#123;</span><br><span class="line">        @Override</span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">            synchronized(<span class="keyword">lock</span>) &#123;</span><br><span class="line">                <span class="keyword">try</span>&#123;</span><br><span class="line">                    <span class="keyword">lock</span>.wait();</span><br><span class="line">                &#125;<span class="keyword">catch</span>(InterruptedException e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;，<span class="string">"testLockThread"</span>);</span><br><span class="line">    thread.start();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span>(<span class="params">String[]args</span>) throws Exception</span>&#123;</span><br><span class="line">    BufferedReader br = <span class="keyword">new</span> BufferedReader(<span class="keyword">new</span> InputStreamReader(System.<span class="keyword">in</span>));</span><br><span class="line">    br.readLine();</span><br><span class="line">    createBusyThread();</span><br><span class="line">    r.readLine();</span><br><span class="line">    bject obj=<span class="keyword">new</span> Object();</span><br><span class="line">    reateLockThread(obj);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>&emsp;&emsp;程序运行后，首先在“线程”页签中选择main线程，如图4-7所示。堆栈追踪显示 BufferedReader在readBytes方法中等待System.in的键盘输入，这时候线程为 Runnable状态，Runnable状态的进程会被分配运行时间，但readBytes方法检查到流没有更新时会立刻归还执行令牌，这种等待只消耗很小的CPU资源。</p><p><img src="https://pic-1258215793.cos.ap-shanghai.myqcloud.com/content/20191101/201911010167.png" alt="main线程"></p><p>&emsp;&emsp;接着监控testBusyThread线程，如图4-8所示，testBusyThread线程一直在执行空循环，从堆栈追踪中可以看到一直停留在MonitoringTest.java代码的41行，41行为while(true)。这时候线程为Runnable状态，而且没有归还线程执行令牌的动作，会在空循环上用尽全部执行时间直到线程切换，这种等待会消耗较多的CPU资源。</p><p><img src="https://pic-1258215793.cos.ap-shanghai.myqcloud.com/content/20191101/201911010168.png" alt="testBusyThread线程"></p><p><img src="https://pic-1258215793.cos.ap-shanghai.myqcloud.com/content/20191101/201911010169.png" alt="testLockThread线程"></p><p>&emsp;&emsp;图4-9显示testLockThread线程在等待着lock对象的notify或notifyAll方法的出现，线程这时候处在WAITING状态，在被唤醒前不会被分配执行时间。</p><p>&emsp;&emsp;testLockThread线程正处于正常的活锁等待状态，只要lock对象的notify()或 notifyAll()方法被调用，这个线程便能激活以继续执行。下列代码清单演示了一个无法再被激活的死锁等待。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">*线程死锁等待演示</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">SynAddRunalbe</span> <span class="keyword">implements</span> <span class="title">Runnable</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> a, b;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">SynAddRunalbe</span><span class="params">(<span class="keyword">int</span> a, <span class="keyword">int</span> b)</span></span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.a=a;</span><br><span class="line">        <span class="keyword">this</span>.b=b;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">synchronized</span>(Integer.valueOf(a))&#123;</span><br><span class="line">            <span class="keyword">synchronized</span>(Integer.valueOf(b))&#123;</span><br><span class="line">                System.out.println(a+b);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[]args)</span></span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;<span class="number">100</span>;i++)&#123;</span><br><span class="line">        <span class="keyword">new</span> Thread(<span class="keyword">new</span> SynAddRunalbe(<span class="number">1</span>，<span class="number">2</span>)).start();</span><br><span class="line">        <span class="keyword">new</span> Thread(<span class="keyword">new</span> SynAddRunalbe(<span class="number">2</span>，<span class="number">1</span>)).start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>&emsp;&emsp;这段代码开了200个线程分别去计算1+2及2+1的值，其实for循环是可省略的，两个线程也可能会导致死锁，不过那样概率太小，需要尝试运行很多次才能看到效果。如果运气不是特别差的话，带for循环的版本最多运行2～3次就会遇到线程死锁，程序无法结束。造成死锁的原因是Integer.valueOf()方法基于减少对象创建次数 和节省内存的考虑，[-128，127]之间的数字会被缓存，当valueOf()方法在这个范围之内传入参数，将直接返回缓存中的对象。也就是说代码中调用了200次 Integer.valueOf()方法一共就只返回了两个不同的对象。假如在某个线程的两 个synchronized块之间发生了一次线程切换，就会出现线程A等着被线程B持有的 Integer.valueOf(1)，线程B又等着被线程A持有的Integer.valueOf(2)，结果大家都跑不下去的情景。</p><p>&emsp;&emsp;出现线程死锁之后，点击JConsole线程面板的“检测到死锁”的按钮，将出现一个新的“死锁”页签，如图4-10所示。</p><p><img src="https://pic-1258215793.cos.ap-shanghai.myqcloud.com/content/20191101/201911010170.png" alt="线程死锁"></p><p>&emsp;&emsp;图中很清晰地显示线程Thread-43在等待一个被线程Thread-12持有Integer对象，而点击线程Thread-12则显示它也在等待一个Integer对象，被线程Thread-43持有，这样两个线程就互相卡住，都不存在等到锁释放的希望了。</p><h3 id="3-2-VisualVM：多合一故障处理工具"><a href="#3-2-VisualVM：多合一故障处理工具" class="headerlink" title="3.2 VisualVM：多合一故障处理工具"></a><strong>3.2 VisualVM：多合一故障处理工具</strong></h3><p>&emsp;&emsp;VisualVM（All-in-One Java Troubleshooting Tool）是到目前为止，随JDK发布的功能最强大的运行监视和故障处理程序，并且可以预见在未来一段时间内都是官方主力发展的虚拟机故障处理工具。官方在VisualVM的软件说明中写上了“All-in-One”的描述字样，预示着它除了运行监视、故障处理外，还提供了很多其他方面的功能。如性能分析（Profiling），VisualVM的性能分析功能甚至比起JProfiler、YourKit等专业且收费的Profiling工具都不会逊色多少，而且VisualVM的还有一个很大优点：不需要被监视的程序基于特殊Agent运行，因此它对应用程序的实际性能的影响很小，使得它可以直接应用在生产环境中。这个优点是JProfiler、YourKit等工具无法与之媲美的。</p><h4 id="3-2-1-VisualVM兼容范围与插件安装"><a href="#3-2-1-VisualVM兼容范围与插件安装" class="headerlink" title="3.2.1 VisualVM兼容范围与插件安装"></a><strong>3.2.1 VisualVM兼容范围与插件安装</strong></h4><p>&emsp;&emsp;VisualVM基于NetBeans平台开发，因此它一开始就具备了插件扩展功能的特性。</p><blockquote><p>通过插件扩展支持，VisualVM可以做到：</p><ul><li>显示虚拟机进程及进程的配置和环境信息（jps、jinfo）。</li><li>监视应用程序的CPU、GC、堆、方法区及线程的信息（jstat、jstack）。</li><li>dump及分析堆转储快照（jmap、jhat）。</li><li>方法级的程序运行性能分析，找出被调用最多、运行时间最长的方法。</li><li>离线程序快照：收集程序的运行时配置、线程dump、内存dump等信息建立一个快照，可以将快照发送开发者处进行Bug反馈。</li><li>其他plugins的无限的可能性……</li></ul></blockquote><p>&emsp;&emsp;VisualVM在JDK 1.6 update 7中才首次出现，但并不意味着它只能监控运行于JDK 1.6上的程序，它具备很强的向下兼容能力，甚至能向下兼容至近10年前发布的JDK 1.4.2平台，这对无数已经处于实施、维护状态的项目很有意义。当然，并非所有的功能都能完美地向下兼容，主要特性的兼容性如表4-6所示。</p><p><img src="https://pic-1258215793.cos.ap-shanghai.myqcloud.com/content/20191101/201911010171.png" alt="VisualVM主要特性的兼容性列表"></p><p>&emsp;&emsp;首次启动VisualVM后，读者先不必着急找应用程序进行监测，因为现在VisualVM还 没有加载任何插件，虽然基本的监视、线程面板的功能主程序都以默认插件的形式 提供了，但是不给VisualVM装任何扩展插件，就相当于放弃了它最精华的功能，和没有安装任何应用软件操作系统差不多。</p><p>&emsp;&emsp;插件可以手工安装，在网站上下载*.nbm包后，点击“工具”→“插件”→“已下 载”菜单，然后在弹出的对话框中指定nbm包路径便可进行安装，插件安装后存放在 JDK_HOME/lib/visualvm/visualvm中。不过手工安装并不常用，使用VisualVM 的自动安装功能已经可以找到所需的大多数插件，在有网络连接的环境下，点击“工具”→“插件”菜单，弹出如图4-11所示的插件页签，在页签的“可用插 件”中列举了当前版本VisualVM可以使用的插件，选中插件后在右边窗口将显示这个插件的基本信息，如开发者、版本、功能描述等。</p><p><img src="https://pic-1258215793.cos.ap-shanghai.myqcloud.com/content/20191101/201911010172.png" alt="VisualVM插件页签"></p><p>&emsp;&emsp;大家可以根据自己的工作需要和兴趣选择合适的插件，然后点击安装按钮，弹出如 图4-12所示的下载进度窗口，跟着提示操作稍后即可安装完成。</p><p><img src="https://pic-1258215793.cos.ap-shanghai.myqcloud.com/content/20191101/201911010173.png" alt="VisualVM插件安装过程"></p><p>&emsp;&emsp;安装完插件后，选择一个需要监视的程序就进入程序的主界面了，如图4-13所示。根据读者选择安装插件数量的不同，看到的页签可能和图4-13中的会有差异。</p><p><img src="https://pic-1258215793.cos.ap-shanghai.myqcloud.com/content/20191101/201911010174.png" alt="VisualVM主界面"></p><p>&emsp;&emsp;VisualVM中“概述”、“监视”、“线程”、“MBeans”的功能与前面介绍的JConsole差别不大，读者根据上一节的内容类比使用即可，下面挑选几个特色功能和插件进行介绍。</p><h4 id="3-2-2-生成和浏览堆转储快照"><a href="#3-2-2-生成和浏览堆转储快照" class="headerlink" title="3.2.2 生成和浏览堆转储快照"></a><strong>3.2.2 生成和浏览堆转储快照</strong></h4><blockquote><p>在VisualVM中生成dump文件有两种方式，可以执行下列任一操作：</p><ul><li>在“应用程序”窗口中右键单击应用程序节点，然后选择“堆Dump”。</li><li>在“应用程序”窗口中双击应用程序节点以打开应用程序标签，然后在“监视”标 签中单击“堆Dump”。</li></ul></blockquote><p>&emsp;&emsp;生成了dump文件之后，应用程序页签将在该堆的应用程序下增加一个以[heapdump] 开头的子节点，并且在主页签中打开该转储快照，如图4-14所示。如果需要把dump文件保存或发送出去，要在heapdump节点上右键选择“另存为”菜单，否则当VisualVM关闭时，生成的dump文件会被当做临时文件被删除掉。要打开一个已经存在的dump文件，通过文件菜单中的“装入”功能，选择硬盘上的dump文件即可。</p><p><img src="https://pic-1258215793.cos.ap-shanghai.myqcloud.com/content/20191101/201911010175.png" alt="浏览dump文件"></p><p>&emsp;&emsp;从堆页签中的“摘要”面板可以看到应用程序dump时的运行时参数、System.getProperties()的内容、线程堆栈等信息，“类”面板则是以类为统 计口径统计类的实例数量和容量信息，“实例”面板不能直接使用，因为不能确定 用户想查看哪个类的实例，所以需要通过“类”面板进入，在“类”中选择一个关 心的类后双击鼠标，即可在“实例”中看见此类中500个实例的具体属性信息。“OQL控制台”面板里面就是运行OQL查询语句的，同jhat里面介绍的OQL功能 一样。如果需要了解具体OQL语法和使用，可参见本书附录D的内容。</p><h4 id="3-2-3-分析程序性能"><a href="#3-2-3-分析程序性能" class="headerlink" title="3.2.3 分析程序性能"></a><strong>3.2.3 分析程序性能</strong></h4><p>&emsp;&emsp;在Profiler页签中，VisualVM提供了程序运行期间方法级的CPU执行时间分析及内存分析，进行Profiling分析肯定会对程序运行性能有比较大的影响，所以一般不在生产环境中使用这项功能。</p><p>&emsp;&emsp;要开始分析，先选择“CPU”和“内存”按钮中的一个，然后切换到应用程序中对程序进行操作，VisualVM会记录到这段时间中应用程序执行过的方法。如果是CPU分析，将会统计每个方法的执行次数、执行耗时；如果是内存分析则会统计每个方法 关联的对象数及这些对象所占的空间。分析结束后，点击“停止”按钮结束监控过 程，如图4-15所示。</p><p><img src="https://pic-1258215793.cos.ap-shanghai.myqcloud.com/content/20191101/201911010176.png" alt="对应用程序进行CPU执行时间分析"></p><p>&emsp;&emsp;注意：在JDK 1.5之后，在Client模式下的虚拟机加入并且自动开启了类共享—这是一个在多虚拟机进程中共享rt.jar中的类数据以提高加载速度和节省内存的优化，而根据相关Bug报告的反映，VisualVM的Profiler功能可能会因为类共享而导致被 监视的应用程序崩溃，所以读者进行Profiling前，最好在被监视的程序中使用Xshare：off参数来关闭类共享优化。</p><p>&emsp;&emsp;图4-15中是对Eclipse IDE一段操作的录制和分析结果，读者分析自己的应用程序 时，可以根据实际业务的复杂程度与方法的时间和调用次数做比较，找到最有优化价值的方法。</p><h4 id="3-2-4-BTrace动态日志跟踪"><a href="#3-2-4-BTrace动态日志跟踪" class="headerlink" title="3.2.4 BTrace动态日志跟踪"></a><strong>3.2.4 BTrace动态日志跟踪</strong></h4><p>&emsp;&emsp;BTrace是一个很“有趣”的VisualVM插件，本身也是可以独立运行的程序。它的作用是在不停止目标程序运行的前提下，通过HotSpot虚拟机的HotSwap技术动态加入原本并不存在的调试代码。这项功能对实际生产中的程序很有意义：经常遇到程序出现问题，但排查错误的一些必要信息，譬如方法参数、返回值等，在开发时并没有打印到日志之中，以至于不得不停掉服务，通过调试增量来加入日志代码以解决问题。当遇到生产环境服务无法随便停止时，缺一两句日志导致排错进行不下去是一件非常郁闷的事情。</p><p>&emsp;&emsp;在VisualVM中安装了BTrace插件后，应用程序面板右键点击要调试的程序，会出现“Trace Application”菜单，点击将进入BTrace面板。这个面板里面看起来就像一个简单的Java程序开发环境，里面还有一小段Java代码，如图4-16所示。</p><p><img src="https://pic-1258215793.cos.ap-shanghai.myqcloud.com/content/20191101/201911010177.png" alt="BTrace动态跟踪"></p><p>&emsp;&emsp;作者准备了一段很简单的Java代码来演示BTrace的功能：产生两个1000以内的随机整数，输出这2个数字相加的结果，如代码清单4-9BTrace跟踪演示所示。</p><figure class="highlight processing"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> class BTraceTest&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="built_in">int</span> <span class="built_in">add</span>(<span class="built_in">int</span> a, <span class="built_in">int</span> b)&#123;</span><br><span class="line">        <span class="keyword">return</span> a+b;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> main(<span class="keyword">String</span>[]args) <span class="keyword">throws</span> IOException &#123;</span><br><span class="line">        BTraceTest test = <span class="keyword">new</span> BTraceTest();</span><br><span class="line">        <span class="keyword">BufferedReader</span> reader = <span class="keyword">new</span> <span class="keyword">BufferedReader</span>(<span class="keyword">new</span> InputStreamReader(System.in));</span><br><span class="line">        <span class="keyword">for</span>(<span class="built_in">int</span> i=<span class="number">0</span>;i&lt;<span class="number">10</span>;i++)&#123;</span><br><span class="line">            reader.readLine();</span><br><span class="line">            <span class="built_in">int</span> a = (<span class="built_in">int</span>)Math.<span class="built_in">round</span>(Math.<span class="built_in">random</span>()*<span class="number">1000</span>);</span><br><span class="line">            <span class="built_in">int</span> b = (<span class="built_in">int</span>)Math.<span class="built_in">round</span>(Math.<span class="built_in">random</span>()*<span class="number">1000</span>);</span><br><span class="line">            System.out.<span class="built_in">println</span>(test.<span class="built_in">add</span>(a, b));</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>&emsp;&emsp;程序运行后，在VisualVM中打开该程序的监视，在BTrace页签填充TracingScript的内容，输入调试代码如代码清单4-10BTrace调试代码所示。</p><figure class="highlight less"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*BTrace Script Template*/</span></span><br><span class="line"><span class="selector-tag">import</span> <span class="selector-tag">com</span><span class="selector-class">.sun</span><span class="selector-class">.btrace</span><span class="selector-class">.annotations</span>.*;</span><br><span class="line"><span class="selector-tag">import</span> <span class="selector-tag">static</span> <span class="selector-tag">com</span><span class="selector-class">.sun</span><span class="selector-class">.btrace</span><span class="selector-class">.BTraceUtils</span>.*;</span><br><span class="line"></span><br><span class="line">@<span class="selector-tag">BTrace</span></span><br><span class="line"><span class="selector-tag">public</span> <span class="selector-tag">class</span> <span class="selector-tag">TracingScript</span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="variable">@OnMethod</span>(clazz=<span class="string">"org.fenixsoft.monitoring.BTraceTest"</span>,</span><br><span class="line">              method=<span class="string">"add"</span>,</span><br><span class="line">              location=<span class="variable">@Location</span>(Kind.RETURN))</span><br><span class="line">    public static void func(<span class="variable">@Self</span> org.fenixsoft.monitoring.BTraceTest instance, int a, int b, <span class="variable">@Return</span> int result)&#123;</span><br><span class="line">        <span class="selector-tag">println</span>(<span class="string">"调用堆栈："</span>);</span><br><span class="line">        <span class="selector-tag">jstack</span>();</span><br><span class="line">        <span class="selector-tag">println</span>(strcat(<span class="string">"方法参数A："</span>, str(a)));</span><br><span class="line">        <span class="selector-tag">println</span>(strcat(<span class="string">"方法参数B："</span>, str(b)));</span><br><span class="line">        <span class="selector-tag">println</span>(strcat(<span class="string">"方法结果："</span>, str(result)));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>&emsp;&emsp;点击“Start”按钮后稍等片刻，编译完成后，可见Output面板中出现“BTrace code successfuly deployed”的字样。程序运行的时候在Output面板将会输出 如图4-17所示的调试信息。</p><p><img src="https://pic-1258215793.cos.ap-shanghai.myqcloud.com/content/20191101/201911010178.png" alt="BTrace跟踪结果"></p><p>&emsp;&emsp;BTrace的用法还有许多，打印调用堆栈、参数、返回值只是最基本的应用，在它的 网站上有使用BTrace进行性能监视、定位连接泄漏、内存泄漏、解决多线程竞争问题等的使用例子，有兴趣的读者可以去网上了解相关信息。</p><hr><h2 id="第四节-总结"><a href="#第四节-总结" class="headerlink" title="第四节 总结"></a><strong>第四节 总结</strong></h2><p>&emsp;&emsp;本章介绍了随JDK发布的6个命令行工具与2个可视化的故障处理工具，灵活使用这些工具，可以给处理问题带来很大的便利。</p><p>&emsp;&emsp;除了JDK自带的工具之外，常用的故障处理工具还有很多，如果读者使用的是非Sun 系列的JDK，非HotSpot的虚拟机，就需要使用对应的工具进行分析，如：</p><blockquote><ul><li>IBM的Support Assistant、Heap Analyzer、Javacore Analyzer、Garbage</li><li>Collector Analyzer适用于IBM J9 VM。</li><li>HP的HPjmeter、HPjtune适用于HP-UX、SAP、HotSpot VM。</li><li>Eclipse的Memory Analyzer Tool（MAT）适用于HP-UX、SAP、HotSpot VM，</li><li>安装IBM DTFJ插件后可支持IBM J9 VM。</li><li>BEA的JRockit Mission Control，适用于JRockit VM。</li></ul></blockquote><hr><p><em>参考博客和文章书籍等：</em></p><blockquote><p>《深入理解Java虚拟机》</p></blockquote><p><em>因博客主等未标明不可引用，若部分内容涉及侵权请及时告知，我会尽快修改和删除相关内容</em></p>]]></content>
    
    <summary type="html">
    
      简单介绍Java虚拟机中的虚拟机性能监控和故障处理工具，包括：引文，JDK的命令行工具（jps、jstat、jinfo、jmap、jhat、jstack、HSDIS），JDK的可视化工具（JConsole、VisualVM），总结等内容。
    
    </summary>
    
      <category term="技术文档" scheme="http://linyishui.top/categories/%E6%8A%80%E6%9C%AF%E6%96%87%E6%A1%A3/"/>
    
    
      <category term="java" scheme="http://linyishui.top/tags/java/"/>
    
      <category term="jvm" scheme="http://linyishui.top/tags/jvm/"/>
    
  </entry>
  
  <entry>
    <title>小厂研发生产的一些反思（未完成）</title>
    <link href="http://linyishui.top/2019112101.html"/>
    <id>http://linyishui.top/2019112101.html</id>
    <published>2019-11-21T13:44:58.000Z</published>
    <updated>2020-01-02T03:24:56.195Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="小厂研发生产的一些反思"><a href="#小厂研发生产的一些反思" class="headerlink" title="小厂研发生产的一些反思"></a><strong>小厂研发生产的一些反思</strong></h1><h2 id="为什么不重视设计？"><a href="#为什么不重视设计？" class="headerlink" title="为什么不重视设计？"></a><strong>为什么不重视设计？</strong></h2><p>&emsp;&emsp;领导的理念是先动手做，项目不能站住不往前推进，不给设计阶段留时间，但其实设计和评审也是推进过程，而且能够有效的加速推进。</p><p>&emsp;&emsp;参与设计的人员能力参差不齐，设计阶段没有明确地任务目标，全靠自我驱动，人员能力不齐导致更多的意见分歧和分工不均，最后变成能力强的包干。</p><p>&emsp;&emsp;没有需求池和技术积累，做过的工作每次都要再做一遍，只能通过人的成长来带动公司的成长。</p><p>&emsp;&emsp;小厂没有准备足够的流程和技术来应对频繁的需求变更，导致一些参与人员会产生不能确定的需求进行详细的设计最终还是要推翻这种想法。</p><hr><h2 id="为什么做不好文档？"><a href="#为什么做不好文档？" class="headerlink" title="为什么做不好文档？"></a><strong>为什么做不好文档？</strong></h2><p>&emsp;&emsp;写文档很耗时间，对于小厂的日常项目，写完的文档几乎不会有再看的机会，快速开发完成测试后就交付上线了，上线后的维护压力也比较小，这使得项目内的成员没有足够的理由和动力来写好文档。</p><p>&emsp;&emsp;对于我个人来说，写文档是个人工作习惯，但花时间写好的文档几乎只是给自己看的，后来一些小项目就懒于管理文档了，还有有时会突然需要写几份文档，一般是为了交付项目，时间要求非常紧，只能非常粗略的写个大概。</p><p>&emsp;&emsp;文档没有审查、指导和监管，糟糕的文档可能相比没有文档好一些，但也会极大的浪费后来接管项目的人的时间，对于小厂的技术能力来说，早期阶段文档难以避免粗制滥造的情况，再加上没有优化过程和合格判断，导致即使团队负责人要求提供文档，但参与人员却敷衍了事的结果。</p><hr><h2 id="为什么不重视单元测试？"><a href="#为什么不重视单元测试？" class="headerlink" title="为什么不重视单元测试？"></a><strong>为什么不重视单元测试？</strong></h2><p>&emsp;&emsp;项目规模小，生产阶段的问题造成的损失可控可接受，所以对于产品质量的要求自然就不高。项目的开发时间给的比较少，开发人员除了研发身兼多职，甚至同时负责多条开发线路，再加上小厂一些其他缺点（无法有效应对需求频繁变更，不重视项目前期的设计以及多次评审的流程），开发人员水平不行时认识不到单元测试的重要性，开发人员水平不错，也就是成了熟练工，开发出现的问题比较少，对于整个项目来说这些问题可以接受在测试阶段处理，甚至上线后处理。</p><hr><h2 id="为什么都是人力测试，不做自动化测试？"><a href="#为什么都是人力测试，不做自动化测试？" class="headerlink" title="为什么都是人力测试，不做自动化测试？"></a><strong>为什么都是人力测试，不做自动化测试？</strong></h2><p>&emsp;&emsp;原因如上，人力测试成本低，足以应付小项目的交付需求。</p><hr><h2 id="为什么不做CodeReview？"><a href="#为什么不做CodeReview？" class="headerlink" title="为什么不做CodeReview？"></a><strong>为什么不做CodeReview？</strong></h2><p>&emsp;&emsp;因为小厂都是在做项目，而不是做产品。项目并没有什么维护下去的必要，一般验收后就不会继续迭代和维护，也就没有必要CodeReview，只要能过验收那一关即可。CodeReview本身应该是很消耗时间，且需要有设计进行有效的Review，这些对于小厂有些苛刻。且对于项目看不到任何效益，这些项目生产时产生的BUG也不会直接对乙方公司造成特别严重的伤害，Leader自然不会对代码质量有特别大的压力，稍微在测试流程或者开发流程上加一些压力就能满足项目的需求，再多的成本对于小公司来说可能是“浪费”了。</p><hr><h2 id="这样的公司，核心的财富是什么呢？"><a href="#这样的公司，核心的财富是什么呢？" class="headerlink" title="这样的公司，核心的财富是什么呢？"></a><strong>这样的公司，核心的财富是什么呢？</strong></h2><hr><h2 id="为什么不效仿一些大厂，让员工螺丝化？"><a href="#为什么不效仿一些大厂，让员工螺丝化？" class="headerlink" title="为什么不效仿一些大厂，让员工螺丝化？"></a><strong>为什么不效仿一些大厂，让员工螺丝化？</strong></h2><p>&emsp;&emsp;在小厂工作似乎唯一的好处就是身兼多职，甚至一个项目就是一个人，一方面很累但另一方面也很锻炼自己，什么都要做做试试，当然也浪费了时间来精通某一方向。为什么小厂不花些功夫来让生产流水化呢，毕竟核心员工的流失对于小厂是很大的损失。</p><p>&emsp;&emsp;首先小厂没有专业的管理能力，日常工作依赖于团队高效的执行能力，因为是小舟，即使驶错了方向也能在碰礁前及时的转向。而设计出一套专业的开发流程需要在所在领域积累足够的开发经验以及一定的高级人才储备，这些都是小厂所欠缺的。</p><p>&emsp;&emsp;再有就是不重视开发流程，每个环节甚至不能明白的确定一个负责人，找问题的时候互相甩锅</p>]]></content>
    
    <summary type="html">
    
      瞎想一下这一两年在小公司工作的感受和反思。
    
    </summary>
    
      <category term="个人记录" scheme="http://linyishui.top/categories/%E4%B8%AA%E4%BA%BA%E8%AE%B0%E5%BD%95/"/>
    
    
      <category term="unfinished" scheme="http://linyishui.top/tags/unfinished/"/>
    
      <category term="other" scheme="http://linyishui.top/tags/other/"/>
    
  </entry>
  
  <entry>
    <title>Base64编码</title>
    <link href="http://linyishui.top/2019112001.html"/>
    <id>http://linyishui.top/2019112001.html</id>
    <published>2019-11-20T14:17:40.000Z</published>
    <updated>2020-01-02T02:25:20.648Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="加密算法"><a href="#加密算法" class="headerlink" title="加密算法"></a><strong>加密算法</strong></h1><h2 id="第一节-简介"><a href="#第一节-简介" class="headerlink" title="第一节 简介"></a><strong>第一节 简介</strong></h2><p>&emsp;&emsp;Base64不是安全领域下的加密解密算法，只能算是一个编码算法，通常用于把二进制数据编码为可写的字符形式的数据，对数据内容进行编码来适合传输(可以对img图像编码用于传输)。这是一种<strong>可逆</strong>的编码方式。</p><p>&emsp;&emsp;编码后的数据是一个字符串，其中包含的字符为：A-Z、a-z、0-9、+、/，共64个字符(26 + 26 + 10 + 1 + 1 = 64，其实是65个字符，“=”是填充字符。Base64要求把每三个8Bit的字节转换为四个6Bit的字节(3<em>8 = 4</em>6 = 24)，然后把6Bit再添两位高位0，组成四个8Bit的字节，也就是说，转换后的字符串理论上将要比原来的长1/3。原文的字节最后不够3个的地方用0来补足，转换时Base64编码用=号来代替。这就是为什么有些Base64编码会以一个或两个等号结束的原因，中间是不可能出现等号的，但等号最多只有两个。其实不用”=”也不耽误解码，之所以用”=”，可能是考虑到多段编码后的Base64字符串拼起来也不会引起混淆。)</p><p>&emsp;&emsp;Base64编码是从二进制到字符的过程，像一些中文字符用不同的编码转为二进制时，产生的二进制是不一样的，所以最终产生的Base64字符也不一样。例如”上网”对应utf-8格式的Base64编码是”5LiK572R”，对应GB2312格式的Base64编码是”yc/N+A==”。</p><p>&emsp;&emsp;标准的Base64并不适合直接放在URL里传输，因为URL编码器会把标准Base64中的“/”和“+”字符变为形如“%XX”的形式，而这些“%”号在存入数据库时还需要再进行转换，因为ANSI SQL中已将“%”号用作通配符。</p><p>&emsp;&emsp;为解决此问题，可采用一种用于URL的改进Base64编码，它不在末尾填充’=’号，并将标准Base64中的“+”和“/”分别改成了“-”和“_”，这样就免去了在URL编解码和数据库存储时所要作的转换，避免了编码信息长度在此过程中的增加，并统一了数据库、表单等处对象标识符的格式。</p><p>&emsp;&emsp;另有一种用于正则表达式的改进Base64变种，它将“+”和“/”改成了“!”和“-”，因为“+”，“*”以及前面在IRCu中用到的“[”和“]”在正则表达式中都可能具有特殊含义。</p><p>&emsp;&emsp;此外还有一些变种，它们将“+/”改为“<em>-”或“.</em>”（用作编程语言中的标识符名称）或“.-”（用于XML中的Nmtoken）甚至“_:”（用于XML中的Name）。</p><hr><h2 id="第二节-Java中使用Base64编码"><a href="#第二节-Java中使用Base64编码" class="headerlink" title="第二节 Java中使用Base64编码"></a><strong>第二节 Java中使用Base64编码</strong></h2><h3 id="2-1-早期"><a href="#2-1-早期" class="headerlink" title="2.1 早期"></a><strong>2.1 早期</strong></h3><p>&emsp;&emsp;早期在Java上做Base64的编码与解码，会使用到JDK里sun.misc套件下的BASE64Encoder和BASE64Decoder这两个类别，用法如下：</p><figure class="highlight processing"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> main(<span class="keyword">String</span>[] args) <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">    <span class="keyword">final</span> BASE64Encoder encoder = <span class="keyword">new</span> BASE64Encoder();</span><br><span class="line">    <span class="keyword">final</span> BASE64Decoder decoder = <span class="keyword">new</span> BASE64Decoder();</span><br><span class="line">    <span class="keyword">final</span> <span class="keyword">String</span> <span class="built_in">text</span> =<span class="string">"Java深入"</span>;</span><br><span class="line">    <span class="keyword">final</span> <span class="built_in">byte</span>[] textByte = <span class="built_in">text</span>.getBytes(<span class="string">"UTF-8"</span>);</span><br><span class="line">    <span class="comment">//编码</span></span><br><span class="line">    <span class="keyword">final</span> <span class="keyword">String</span> encodedText = encoder.encode(textByte);</span><br><span class="line">    System.out.<span class="built_in">println</span>(<span class="string">"编码后："</span> + encodedText);<span class="comment">//编码后：SmF2Yea3seWFpQ==</span></span><br><span class="line">    <span class="comment">//解码</span></span><br><span class="line">    System.out.<span class="built_in">println</span>(<span class="string">"解码后："</span> + <span class="keyword">new</span> <span class="keyword">String</span>(decoder.decodeBuffer(encodedText),<span class="string">"UTF-8"</span>));<span class="comment">//解码后：Java深入</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="2-2-Apache-Commons-Codec"><a href="#2-2-Apache-Commons-Codec" class="headerlink" title="2.2 Apache Commons Codec"></a><strong>2.2 Apache Commons Codec</strong></h3><p>&emsp;&emsp;Apache Commons Codec有提供Base64的编码与解码功能，会使用到org.apache.commons.codec.binary套件下的Base64类别，用法如下：</p><figure class="highlight processing"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">final</span> Base64 base64 = <span class="keyword">new</span> Base64();</span><br><span class="line"><span class="keyword">final</span> <span class="keyword">String</span> <span class="built_in">text</span> = <span class="string">"Java深入"</span>;</span><br><span class="line"><span class="keyword">final</span> <span class="built_in">byte</span>[] textByte = <span class="built_in">text</span>.getBytes(<span class="string">"UTF-8"</span>);</span><br><span class="line"><span class="comment">//编码</span></span><br><span class="line"><span class="keyword">final</span> <span class="keyword">String</span> encodedText = base64.encodeToString(textByte);System.out.<span class="built_in">println</span>(encodedText);</span><br><span class="line"><span class="comment">//解码</span></span><br><span class="line">System.out.<span class="built_in">println</span>(<span class="keyword">new</span> <span class="keyword">String</span>(base64.decode(encodedText),<span class="string">"UTF-8"</span>));</span><br></pre></td></tr></table></figure><h3 id="2-3-Java8"><a href="#2-3-Java8" class="headerlink" title="2.3 Java8"></a><strong>2.3 Java8</strong></h3><p>&emsp;&emsp;Java 8的java.util套件中，新增了Base64的类别，可以用来处理Base64的编码与解码，用法如下：</p><figure class="highlight processing"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">final</span> Base64.Decoder decoder = Base64.getDecoder();</span><br><span class="line"><span class="keyword">final</span> Base64.Encoder encoder = Base64.getEncoder();</span><br><span class="line"><span class="keyword">final</span> <span class="keyword">String</span> <span class="built_in">text</span> = <span class="string">"Java深入"</span>;</span><br><span class="line"><span class="keyword">final</span> <span class="built_in">byte</span>[] textByte = <span class="built_in">text</span>.getBytes(<span class="string">"UTF-8"</span>);</span><br><span class="line"><span class="comment">//编码</span></span><br><span class="line"><span class="keyword">final</span> <span class="keyword">String</span> encodedText = encoder.encodeToString(textByte);</span><br><span class="line">System.out.<span class="built_in">println</span>(<span class="string">"编码后："</span> + encodedText);<span class="comment">//编码后：SmF2Yea3seWFpQ==</span></span><br><span class="line"><span class="comment">//解码</span></span><br><span class="line">System.out.<span class="built_in">println</span>(<span class="string">"解码后："</span> + <span class="keyword">new</span> <span class="keyword">String</span>(decoder.decode(encodedText), <span class="string">"UTF-8"</span>));<span class="comment">//解码后：Java深入</span></span><br></pre></td></tr></table></figure><p>&emsp;&emsp;与sun.mis c套件和Apache Commons Codec所提供的Base64编解码器来比较的话，Java 8提供的Base64拥有更好的效能。实际测试编码与解码速度的话，Java 8提供的Base64，要比sun.mis c套件提供的还要快至少11倍，比Apache Commons Codec提供的还要快至少3倍。</p><h4 id="2-3-1-三种编码"><a href="#2-3-1-三种编码" class="headerlink" title="2.3.1 三种编码"></a><strong>2.3.1 三种编码</strong></h4><blockquote><p>java.util.Base64工具类提供了一套静态方法获取下面三种BASE64编解码器：</p><ol><li>Basic编码：标准的BASE64编码，用于处理常规的需求</li><li>URL编码：使用下划线替换反斜线“/”有特殊的意义，URL编码会替换掉反斜线</li><li>MIME编码：使用基本的字母数字产生BASE64输出，对MIME格式比较适配：每一行输出不超过76个字符，而且每行以“\r\n”符结束。</li></ol></blockquote><figure class="highlight processing"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">        <span class="comment">//Basic编码</span></span><br><span class="line">        <span class="keyword">String</span> basicEncoded = Base64.getEncoder().encodeToString(<span class="string">"subjects?parm=abcd"</span>.getBytes(<span class="string">"UTF-8"</span>));</span><br><span class="line">        System.out.<span class="built_in">println</span>(<span class="string">"basic encoder: "</span> + basicEncoded);<span class="comment">//basic encoder: c3ViamVjdHM/cGFybT1hYmNk</span></span><br><span class="line">        <span class="comment">//URL编码</span></span><br><span class="line">        <span class="keyword">String</span> urlEncoded = Base64.getUrlEncoder().encodeToString(<span class="string">"subjects?parm=abcd"</span>.getBytes(<span class="string">"UTF-8"</span>));</span><br><span class="line">        System.out.<span class="built_in">println</span>(<span class="string">"url encoder: "</span> + urlEncoded);<span class="comment">//url encoder: c3ViamVjdHM_cGFybT1hYmNk</span></span><br><span class="line">        <span class="comment">//MIME编码</span></span><br><span class="line">        StringBuilder sb = <span class="keyword">new</span> StringBuilder();</span><br><span class="line">        <span class="keyword">for</span> (<span class="built_in">int</span> t = <span class="number">0</span>; t &lt; <span class="number">10</span>; ++t) &#123;</span><br><span class="line">            sb.<span class="built_in">append</span>(UUID.randomUUID().toString());</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">byte</span>[] toEncode = sb.toString().getBytes(<span class="string">"UTF-8"</span>);</span><br><span class="line">        <span class="keyword">String</span> mimeEncoded = Base64.getMimeEncoder().encodeToString(toEncode);</span><br><span class="line">        System.out.<span class="built_in">println</span>(<span class="string">"mime encoder: "</span> + mimeEncoded);</span><br><span class="line"></span><br><span class="line">mime encoder: NWZkZjNhYTAtNTM5OS00MWMzLWJkMzctNDQ5MTI2ZTM1MmFlNzgxMmZhYmItODllMS00ZDI5LThi</span><br><span class="line">MTktMzVjNjdiYzQyMzYyMWRmNjdjMmUtNmI4YS00Y2MxLWEwOTAtODdkM2Y2Mzk4OTM3NjYzY2E3</span><br><span class="line">NjEtMThkZi00NTAwLThiNTgtMWZiOTQ5YWUwOTNhN2NhYTIzYWEtMDg1Zi00YTIyLWI5OTAtMGEw</span><br><span class="line">ZGI5YTYzMTRmNzU1OTAwODMtYjg0My00MjQyLTkxZDEtYzgwZGFlZTBmNmIzNzkxM2RmZjEtNGVi</span><br><span class="line">Ny00YTgzLWEyYjYtMGI5NTY5OGE4MjQwYmMwZDE3NDktZTI2Mi00NGNlLWJmOTgtZjZjNWVhNzIw</span><br><span class="line">OTNjMTRjODJhMjUtYWNjNS00ODZhLWIzNmEtMGU4ZTJkYjAzNTFhZDc3OTUzOTItMWQ3NS00ZWZh</span><br><span class="line">LWE4YWItMjFlOWZiNjRkYjMz</span><br></pre></td></tr></table></figure><h4 id="2-3-2-流的支持"><a href="#2-3-2-流的支持" class="headerlink" title="2.3.2 流的支持"></a><strong>2.3.2 流的支持</strong></h4><p>&emsp;&emsp;java.util.Base64支持流，包括编码和效率都很高，编码器和解码器的输入和输出无需缓冲Buffer。</p><figure class="highlight arduino"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> wrapping() throws IOException &#123;</span><br><span class="line">    <span class="keyword">String</span> src = <span class="string">"This is the content of any resource read from somewhere"</span> +</span><br><span class="line">            <span class="string">" into a stream. This can be text, image, video or any other stream."</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 编码器封装OutputStream, 文件/tmp/buff-base64.txt的内容是BASE64编码的形式</span></span><br><span class="line">    <span class="built_in">try</span> (OutputStream os = Base64.getEncoder().wrap(<span class="keyword">new</span> FileOutputStream(<span class="string">"/tmp/buff-base64.txt"</span>))) &#123;</span><br><span class="line">        os.<span class="built_in">write</span>(src.getBytes(<span class="string">"UTF-8"</span>));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 解码器封装InputStream, 以及以流的方式解码, 无需缓冲</span></span><br><span class="line">    <span class="comment">// is being consumed. There is no need to buffer the content of the file just for decoding it.</span></span><br><span class="line">    <span class="built_in">try</span> (InputStream is = Base64.getDecoder().wrap(<span class="keyword">new</span> FileInputStream(<span class="string">"/tmp/buff-base64.txt"</span>))) &#123;</span><br><span class="line">        <span class="keyword">int</span> len;</span><br><span class="line">        <span class="keyword">byte</span>[] bytes = <span class="keyword">new</span> <span class="keyword">byte</span>[<span class="number">100</span>];</span><br><span class="line">        <span class="built_in">while</span> ((len = is.<span class="built_in">read</span>(bytes)) != <span class="number">-1</span>) &#123;</span><br><span class="line">            System.out.<span class="built_in">print</span>(<span class="keyword">new</span> <span class="keyword">String</span>(bytes, <span class="number">0</span>, len, <span class="string">"UTF-8"</span>));</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><p><em>参考博客和文章书籍等：</em></p><blockquote><p><a href="https://segmentfault.com/a/1190000016083208" title="Title" target="_blank" rel="noopener">Java Base64 编码解码方案总结</a></p></blockquote><p><em>因博客主等未标明不可引用，若部分内容涉及侵权请及时告知，我会尽快修改和删除相关内容</em></p>]]></content>
    
    <summary type="html">
    
      介绍Base64编码，内容包括：简介，Java中使用Base64编码等。
    
    </summary>
    
      <category term="技术文档" scheme="http://linyishui.top/categories/%E6%8A%80%E6%9C%AF%E6%96%87%E6%A1%A3/"/>
    
    
      <category term="java" scheme="http://linyishui.top/tags/java/"/>
    
      <category term="security" scheme="http://linyishui.top/tags/security/"/>
    
  </entry>
  
  <entry>
    <title>DES加密</title>
    <link href="http://linyishui.top/2019111901.html"/>
    <id>http://linyishui.top/2019111901.html</id>
    <published>2019-11-19T13:41:14.000Z</published>
    <updated>2019-12-26T14:14:22.797Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="DES加密"><a href="#DES加密" class="headerlink" title="DES加密"></a><strong>DES加密</strong></h1><h2 id="第一节-简介"><a href="#第一节-简介" class="headerlink" title="第一节 简介"></a><strong>第一节 简介</strong></h2><h3 id="1-1-背景"><a href="#1-1-背景" class="headerlink" title="1.1 背景"></a><strong>1.1 背景</strong></h3><p>&emsp;&emsp;在20世纪60年代后期，IBM公司成立了一个由Horst Feistel负责的计算机密码学研究项目。1971年设计出密码算法LUCIFER后，该项目宣告结束。LUCIFER被卖给了伦敦的Lloyd公司，用在同样由IBM公司开发的现金发放系统上。LUCIFER是分组长度为64位、密钥长度为128位、具有Feistel结构的分组密码算法。因为LUCIFER非常成功，IBM决定开发一个适合于芯片实现的商业密码产品。这一次由Walter Tuchman和Carl Meyer牵头，参与者不仅有IBM公司的研究人员，而且还有美国国家安全局（NSA）的技术顾问。这次努力的结果是给出了LUCIFER的一个修订版，它的抗密码分析能力更强，而且密钥长度减小为56位。</p><p>&emsp;&emsp;1973年，美国国家标准局（NBS）征求美国国家密码标准方案时，IBM将Tuchman-Meyer方案提交给NBS，它是所有应征方案中最好的一个，所以1977年NBS将它采纳为数据加密标准，即DES。</p><h3 id="1-2-DES是什么"><a href="#1-2-DES是什么" class="headerlink" title="1.2 DES是什么"></a><strong>1.2 DES是什么</strong></h3><p>&emsp;&emsp;<strong>数据加密标准</strong>（英语：Data Encryption Standard，缩写为 DES）是一种<strong>对称密钥加密块密码算法</strong>，1976年被美国联邦政府的国家标准局确定为联邦资料处理标准（FIPS），随后在国际上广泛流传开来。它<strong>基于使用56位密钥的对称算法</strong>。</p><p>&emsp;&emsp;这个算法因为包含一些机密设计元素，相对短的密钥长度以及怀疑内含美国国家安全局（NSA）的后门而在开始时有争议，DES因此受到了强烈的学院派式的审查，并以此推动了现代的块密码及其密码分析的发展。</p><p>&emsp;&emsp;DES现在已经不是一种安全的加密方法，主要因为它使用的56位密钥过短。1999年1月，distributed.net与电子前哨基金会合作，在22小时15分钟内即公开破解了一个DES密钥。也有一些分析报告提出了该算法的理论上的弱点，虽然在实际中难以应用。为了提供实用所需的安全性，可以使用DES的派生算法3DES来进行加密，虽然3DES也存在理论上的攻击方法。在2001年，DES作为一个标准已经被<strong>高级加密标准</strong>（AES）所取代。另外，DES已经不再作为国家标准科技协会（前国家标准局）的一个标准。</p><p>&emsp;&emsp;在某些文献中，作为算法的DES被称为DEA（Data Encryption Algorithm，数据加密算法），以与作为标准的DES区分开来。</p><h3 id="1-3-Feistel"><a href="#1-3-Feistel" class="headerlink" title="1.3 Feistel"></a><strong>1.3 Feistel</strong></h3><p>&emsp;&emsp;分组密码常用的结构有SP、Feistel、Lai-Massey、MISTY等，其中Feistel结构的使用较为普遍，不仅DES用到了，后续的很多经典算法中都有涉及。</p><p>&emsp;&emsp;Feistel是以发明者Horst Feistel的名字命名的。加解密的原理如右图1，左边表示的加密过程，右边表示解密过程。</p><p>&emsp;&emsp;加密和解密公式如下：</p><p><img src="https://pic-1258215793.cos.ap-shanghai.myqcloud.com/content/20191101/201911010151.jpg" alt="加密和解密公式"></p><p>&emsp;&emsp;在每一轮加密过程中，明文被分成左右两部分。</p><p><img src="https://pic-1258215793.cos.ap-shanghai.myqcloud.com/content/20191101/201911010150.jpg" alt="Feistel"></p><p>&emsp;&emsp;不同的是，在加密过程中，轮数和轮密钥从小开始递增；解密时正好相反，从最大开始递减。</p><p>&emsp;&emsp;从图中可以看出，加密最后一轮的操作与前面的有所不同，最后一轮得到的两个部分没有交换，之所以这样是为了保持解密的流程和加密一致，这样在硬件设计时可以使用相同的结构，进而减少硬件面积。</p><p>&emsp;&emsp;假设明文为（L0,R0），一共有两轮计算，每轮的密钥分别为k0、k1，加解密的流程如图2。</p><p><img src="https://pic-1258215793.cos.ap-shanghai.myqcloud.com/content/20191101/201911010152.jpg" alt="加解密的流程"></p><hr><h2 id="第二节-算法流程"><a href="#第二节-算法流程" class="headerlink" title="第二节 算法流程"></a><strong>第二节 算法流程</strong></h2><p><img src="https://pic-1258215793.cos.ap-shanghai.myqcloud.com/content/20191101/201911010153.jpg" alt="DES算法原理"></p><blockquote><p>DES算法原理如上图，相关参数如下：　</p><ul><li>明文分组长度：64 bits</li><li>密钥长度：64 bits</li><li>轮数：16轮<br>　<br>整个操作可以分为3部分：</li><li>初始置换和逆初始置换：这是一对可逆操作，一组数字经过初始置换（或逆初始置换）后，再经过逆初始置换（或初始置换）即可恢复原来的值；</li><li>每轮的加解密操作：64位明文和48为密钥经过一定的操作，输出64位密文；</li><li>轮密钥计算：64位初始密钥经过置换、循环移位等得到16轮的密钥，每轮密钥长度为48位。</li></ul></blockquote><p>&emsp;&emsp;接下来分别对这三种核心操作进行介绍。</p><h3 id="2-1-初始置换与逆初始置换"><a href="#2-1-初始置换与逆初始置换" class="headerlink" title="2.1 初始置换与逆初始置换"></a><strong>2.1 初始置换与逆初始置换</strong></h3><p>&emsp;&emsp;置换的操作如下表1、表2，将一个64位的输入通过各位的提到得到一个新的64位输出。观察可以发现x = IP-1 ( IP(x) ) = IP ( IP-1(x) )。　　</p><p>&emsp;&emsp;需要注意的一点是，图中的索引值从1开始（下文中的数字也类似），有些资料中是从0开始的，如果从零开始，则所有的数字减1即可。</p><p><img src="https://pic-1258215793.cos.ap-shanghai.myqcloud.com/content/20191101/201911010154.jpg" alt="DES算法原理"></p><h3 id="2-2-每轮的操作"><a href="#2-2-每轮的操作" class="headerlink" title="2.2 每轮的操作"></a><strong>2.2 每轮的操作</strong></h3><p>&emsp;&emsp;每一轮的流程如图4，从图中可以看出DES用到了Feistel结构。F即为图中虚线框的内容。</p><p><img src="https://pic-1258215793.cos.ap-shanghai.myqcloud.com/content/20191101/201911010155.jpg" alt="轮操作流程"></p><blockquote><p>每一轮主要涉及3中操作：</p><ul><li>扩展/置换：将32位输入扩展成48位输出，如表3；</li><li>S盒：将48位输入分成8组分别作为8个S盒的输入，每组6位，最高位和最低位作为行索引，中间4位作为列索引，得到一个值x（0&lt;=x&lt;=15），表示为二进制即为4位，8个S盒的输出和在一起正好32位。表4是S1的数值；</li><li>置换：对32位输入进行位的变化，输出仍为32位，如表5。</li></ul></blockquote><p><img src="https://pic-1258215793.cos.ap-shanghai.myqcloud.com/content/20191101/201911010156.jpg" alt="轮操作流程"></p><h3 id="2-3-轮密钥扩展"><a href="#2-3-轮密钥扩展" class="headerlink" title="2.3 轮密钥扩展"></a><strong>2.3 轮密钥扩展</strong></h3><blockquote><p>从图1和图4中可以得出，密钥扩展流程可以表示如下：</p><ol><li>64位初始密钥P进行置换选择1，得到56位输出K；</li><li>将K循环左移一定位数，再进行置换选择2得到48位输出k1(即第一轮的密钥)；</li><li>循环步骤2)，直至得到16轮的密钥（k1、k2、……、k16）；</li><li>结束。</li></ol></blockquote><p>&emsp;&emsp;置换选择1、置换选择2和左移次数的值分别如表6、表7、表8。</p><p><img src="https://pic-1258215793.cos.ap-shanghai.myqcloud.com/content/20191101/201911010157.jpg" alt="轮操作流程"></p><hr><h2 id="第二节-源码解析"><a href="#第二节-源码解析" class="headerlink" title="第二节 源码解析"></a><strong>第二节 源码解析</strong></h2><p>&emsp;&emsp;暂无。</p><hr><h2 id="第三节-实战应用"><a href="#第三节-实战应用" class="headerlink" title="第三节 实战应用"></a><strong>第三节 实战应用</strong></h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure><hr><p><em>参考博客和文章书籍等：</em></p><blockquote><p><a href="https://www.cnblogs.com/luop/p/4366902.html" title="Title" target="_blank" rel="noopener">密码算法详解——DES</a></p></blockquote><blockquote><p><a href="https://www.cnblogs.com/songwenlong/p/5944139.html" title="Title" target="_blank" rel="noopener">安全体系（一）—— DES算法详解</a></p></blockquote><blockquote><p><a href="https://zh.wikipedia.org/wiki/%E8%B3%87%E6%96%99%E5%8A%A0%E5%AF%86%E6%A8%99%E6%BA%96" title="Title" target="_blank" rel="noopener">数据加密标准</a></p></blockquote><p><em>因博客主等未标明不可引用，若部分内容涉及侵权请及时告知，我会尽快修改和删除相关内容</em></p>]]></content>
    
    <summary type="html">
    
      介绍DES加密算法，内容包括：简介（背景、AES是什么、AES思维导图），算法流程（字节替代、行移位、列混淆、轮密钥加、密钥扩展算法、总结），源码解析，实战应用等。
    
    </summary>
    
      <category term="技术文档" scheme="http://linyishui.top/categories/%E6%8A%80%E6%9C%AF%E6%96%87%E6%A1%A3/"/>
    
    
      <category term="java" scheme="http://linyishui.top/tags/java/"/>
    
      <category term="security" scheme="http://linyishui.top/tags/security/"/>
    
  </entry>
  
  <entry>
    <title>AES加密</title>
    <link href="http://linyishui.top/2019111801.html"/>
    <id>http://linyishui.top/2019111801.html</id>
    <published>2019-11-18T07:33:30.000Z</published>
    <updated>2019-12-26T13:56:21.663Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="AES加密"><a href="#AES加密" class="headerlink" title="AES加密"></a><strong>AES加密</strong></h1><h2 id="第一节-简介"><a href="#第一节-简介" class="headerlink" title="第一节 简介"></a><strong>第一节 简介</strong></h2><h3 id="1-1-背景"><a href="#1-1-背景" class="headerlink" title="1.1 背景"></a><strong>1.1 背景</strong></h3><p>&emsp;&emsp;我们知道<strong>数据加密标准</strong>（Data Encryption Standard: DES）的密钥长度是56比特，因此算法的理论安全强度是256。但二十世纪中后期正是计算机飞速发展的阶段，元器件制造工艺的进步使得<strong>计算机的处理能力越来越强</strong>，<strong>DES将不能提供足够的安全性</strong>。1997年1月2号，美国国家标准技术研究所（National Institute of Standards and Technology: NIST）宣布希望征集高级加密标准（Advanced Encryption Standard: AES）[3]，用以取代DES。AES得到了全世界很多密码工作者的响应，先后有很多人提交了自己设计的算法。最终有5个候选算法进入最后一轮：Rijndael，Serpent，Twofish，RC6和MARS，下图分别为其中的5位作者。最终经过安全性分析、软硬件性能评估等严格的步骤，Rijndael算法获胜。</p><h3 id="1-2-AES是什么"><a href="#1-2-AES是什么" class="headerlink" title="1.2 AES是什么"></a><strong>1.2 AES是什么</strong></h3><p>&emsp;&emsp;Rijndael由比利时两位非常著名的密码学家Joan Daemen和Vincent Rijmen设计。Rijndael是一个<strong>分组密码算法族</strong>，其分组长度包括128比特、160比特、192比特、224比特、256比特，密钥长度也包括这五种长度，但是最终AES只选取了分组长度为128比特，密钥长度为128比特、192比特和256比特的三个版本。本文主要结合AES-128进行介绍，AES-196和AES-256的思路基本一样，只是密钥扩展算法的过程会稍有不同，加解密的轮数会适当增加，但加解密的操作都是一样的。另外，本文只对AES算法的各个模块、基本原理进行介绍，旨在加深对算法流程、密码算法实现的了解。在正式软件运用中并不推荐自己编写代码，很多开源项目如Linux，OPENSSL，SRTP等都有非常高效的实现。由于数学知识的缺陷，本文不介绍算法安全性分析相关的知识，有兴趣的读者可以自行阅读相关文献。</p><p>&emsp;&emsp;AES是一个<strong>分组密码</strong>，属于<strong>对称密码</strong>范畴，AES算法的模块在对称密码领域特别是分组密码领域常有使用。</p><h3 id="1-3-AES思维导图"><a href="#1-3-AES思维导图" class="headerlink" title="1.3 AES思维导图"></a><strong>1.3 AES思维导图</strong></h3><p><img src="https://pic-1258215793.cos.ap-shanghai.myqcloud.com/content/20191101/201911010148.jpg" alt="AES思维导图"></p><hr><h2 id="第二节-算法流程"><a href="#第二节-算法流程" class="headerlink" title="第二节 算法流程"></a><strong>第二节 算法流程</strong></h2><p>&emsp;&emsp;Rijndael算法是基于代换-置换网络（SPN，Substitution-permutation network）的迭代算法。明文数据经过多轮次的转换后方能生成密文，每个轮次的转换操作由轮函数定义。轮函数任务就是根据密钥编排序列（即轮密码）对数据进行不同的代换及置换等操作。</p><p><img src="https://pic-1258215793.cos.ap-shanghai.myqcloud.com/content/20191101/201911010149.png" alt="轮函数的流程"></p><p>&emsp;&emsp;上图左侧为轮函数的流程，主要涉及4种操作：<strong>字节替代</strong>（SubBytes）、<strong>行移位</strong>（ShiftRows）、<strong>列混淆</strong>（MixColumns）和<strong>轮密钥加</strong>（AddRoundKey）。图右侧为密钥编排方案，在Rijndael中称为<strong>密钥扩展算法</strong>（KeyExpansion）。</p><blockquote><p>下图给出了AES加解密的流程，从图中可以看出：</p><ol><li>解密算法的每一步分别对应加密算法的逆操作</li><li>加解密所有操作的顺序正好是相反的。</li></ol></blockquote><p>&emsp;&emsp;正是由于这几点（再加上加密算法与解密算法每步的操作互逆）保证了算法的正确性。加解密中每轮的密钥分别由种子密钥经过密钥扩展算法得到。算法中16字节的明文、密文和轮子密钥都以一个4x4的矩阵表示。AES标准算法将128位的明文，以特定次序生成一个4x4的矩阵（每个元素是一个字节，8位），即初始状态（state），经由轮函数的迭代转换之后又将作为下一轮迭代的输入继续参与运算直到迭代结束。</p><p><img src="https://pic-1258215793.cos.ap-shanghai.myqcloud.com/content/20191101/201911010139.png" alt="算法流程"></p><p>&emsp;&emsp;Rijndael算法支持大于128位的明文分组，所以需要列数更多的矩阵来描述。Rijndael轮函数的运算是在特殊定义的有限域GF(256)上进行的。有限域（Finite Field）又名伽罗瓦域（Galois field），简单言之就是一个满足特定规则的集合，集合中的元素可以进行加减乘除运算，且运算结果也是属于此集合。更详细有有关Rijndael算法的数学描述，在此不做熬述。</p><h3 id="2-1-字节替代"><a href="#2-1-字节替代" class="headerlink" title="2.1 字节替代"></a><strong>2.1 字节替代</strong></h3><p>&emsp;&emsp;字节代替的主要功能是通过S盒完成一个字节到另外一个字节的映射，S盒的详细构造方法就不展开了，这里直接给出构造好的结果，下图(a)为S盒，图(b)为S-1（S盒的逆）。S盒用于提供密码算法的<strong>混淆性</strong>。</p><p><img src="https://pic-1258215793.cos.ap-shanghai.myqcloud.com/content/20191101/201911010140.png" alt="S-BOX"></p><p><img src="https://pic-1258215793.cos.ap-shanghai.myqcloud.com/content/20191101/201911010141.png" alt="Inverse S-BOX"></p><p>&emsp;&emsp;S和S-1分别为16x16的矩阵，完成一个8比特输入到8比特输出的映射，输入的高4-bit对应的值作为行标，低4-bit对应的值作为列标。假设输入字节的值为a=a7a6a5a4a3a2a1a0，则输出值为S[a7a6a5a4][a3a2a1a0]，S-1的变换也同理。</p><p>&emsp;&emsp;例如：字节00000000B替换后的值为（S[0][0]=）63H，再通过S-1即可得到替换前的值，（S-1 [6][3]=）00H。</p><h3 id="2-2-行移位"><a href="#2-2-行移位" class="headerlink" title="2.2 行移位"></a><strong>2.2 行移位</strong></h3><p>&emsp;&emsp;行移位是一个4x4的矩阵内部字节之间的置换，用于提供算法的<strong>扩散性</strong>。</p><h4 id="2-2-1-正向行移位"><a href="#2-2-1-正向行移位" class="headerlink" title="2.2.1 正向行移位"></a><strong>2.2.1 正向行移位</strong></h4><p>&emsp;&emsp;正向行移位用于加密，其原理图如下。其中：第一行保持不变，第二行循环左移8比特，第三行循环左移16比特，第四行循环左移24比特。</p><p>&emsp;&emsp;假设矩阵的名字为state，用公式表示如下：state’[i][j] = state[i][(j+i)%4];其中i、j属于[0,3]。</p><p><img src="https://pic-1258215793.cos.ap-shanghai.myqcloud.com/content/20191101/201911010142.png" alt="行移位"></p><h4 id="2-2-2-逆向行移位"><a href="#2-2-2-逆向行移位" class="headerlink" title="2.2.2 逆向行移位"></a><strong>2.2.2 逆向行移位</strong></h4><p>&emsp;&emsp;逆向行移位即是相反的操作，即：第一行保持不变，第二行循环右移8比特，第三行循环右移16比特，第四行循环右移24比特。</p><p>&emsp;&emsp;用公式表示如下：state’[i][j] = state[i][(4+j-i)%4];其中i、j属于[0,3]。</p><h3 id="2-3-列混淆"><a href="#2-3-列混淆" class="headerlink" title="2.3 列混淆"></a><strong>2.3 列混淆</strong></h3><p>&emsp;&emsp;列混淆：利用GF(28)域上算术特性的一个代替，同样用于提供算法的<strong>扩散性</strong>。</p><h4 id="2-3-1-正向列混淆"><a href="#2-3-1-正向列混淆" class="headerlink" title="2.3.1 正向列混淆"></a><strong>2.3.1 正向列混淆</strong></h4><p>&emsp;&emsp;正向列混淆的原理图如下：</p><p><img src="https://pic-1258215793.cos.ap-shanghai.myqcloud.com/content/20191101/201911010143.png" alt="列混淆原理图"></p><p>&emsp;&emsp;根据矩阵的乘法可知，在列混淆的过程中，每个字节对应的值只与该列的4个值有关系。</p><blockquote><p>此处的乘法和加法都是定义在GF(28)上的，需要注意如下几点：</p><ol><li>将某个字节所对应的值乘以2，其结果就是将该值的二进制位左移一位，如果原始值的最高位为1，则还需要将移位后的结果异或00011011；[1]</li><li>乘法对加法满足分配率，例如：07·S0,0=(01⊕02⊕04)·S0,0= S0,0⊕(02·S0,0)(04·S0,0)</li><li>此处的矩阵乘法与一般意义上矩阵的乘法有所不同，各个值在相加时使用的是模28加法（异或运算）。</li></ol></blockquote><p>&emsp;&emsp;下面举一个例子，假设某一列的值如下图，运算过程如下：</p><p><img src="https://pic-1258215793.cos.ap-shanghai.myqcloud.com/content/20191101/201911010144.png" alt="运算过程"></p><p>&emsp;&emsp;在计算02与C9的乘积时，由于C9对应最左边的比特为1，因此需要将C9左移一位后的值与(0001 1011)求异或。同理可以求出另外几个值。</p><h4 id="2-3-2-逆向列混淆"><a href="#2-3-2-逆向列混淆" class="headerlink" title="2.3.2 逆向列混淆"></a><strong>2.3.2 逆向列混淆</strong></h4><p>　<br>&emsp;&emsp;逆向列混淆的原理图如下：</p><p><img src="https://pic-1258215793.cos.ap-shanghai.myqcloud.com/content/20191101/201911010145.png" alt="逆向列混淆原理图"></p><p>&emsp;&emsp;由于：</p><p><img src="https://pic-1258215793.cos.ap-shanghai.myqcloud.com/content/20191101/201911010146.png" alt="由于"></p><p>&emsp;&emsp;说明两个矩阵互逆，经过一次逆向列混淆后即可恢复原文。</p><h3 id="2-4-轮密钥加"><a href="#2-4-轮密钥加" class="headerlink" title="2.4 轮密钥加"></a><strong>2.4 轮密钥加</strong></h3><p>&emsp;&emsp;这个操作相对简单，其依据的原理是“任何数和自身的异或结果为0”。加密过程中，每轮的输入与轮子密钥异或一次；因此，解密时再异或上该轮的轮子密钥即可恢复。</p><h3 id="2-5-密钥扩展算法"><a href="#2-5-密钥扩展算法" class="headerlink" title="2.5 密钥扩展算法"></a><strong>2.5 密钥扩展算法</strong></h3><p>&emsp;&emsp;密钥扩展过程说明：</p><p><img src="https://pic-1258215793.cos.ap-shanghai.myqcloud.com/content/20191101/201911010147.png" alt="密钥扩展过程"></p><blockquote><ol><li>将种子密钥按图(a)的格式排列，其中k0、k1、……、k15依次表示种子密钥的一个字节；排列后用4个32比特的字表示，分别记为w[0]、w[1]、w[2]、w[3]；</li><li>按照如下方式，依次求解w[j]，其中j是整数并且属于[4,43]；</li><li>若j%4=0,则w[j]=w[j-4]⊕g(w[j-1]),否则w[j]=w[j-4]⊕w[j-1]；</li></ol></blockquote><blockquote><p>函数g的流程说明：</p><p>&emsp;&emsp;a)  将w循环左移8比特；</p><p>&emsp;&emsp;b)  分别对每个字节做S盒置换；</p><p>&emsp;&emsp;c)  与32比特的常量（RC[j/4],0,0,0）进行异或，RC是一个一维数组，其值如下。（RC的值只需要有10个，而此处用了11个，实际上RC[0]在运算中没有用到，增加RC[0]是为了便于程序中用数组表示。由于j的最小取值是4，j/4的最小取值则是1，因此不会产生错误。）</p></blockquote><p>&emsp;&emsp;RC = {0x00, 0x01, 0x02, 0x04, 0x08, 0x10, 0x20, 0x40, 0x80, 0x1B, 0x36}</p><h3 id="2-6-总结"><a href="#2-6-总结" class="headerlink" title="2.6 总结"></a><strong>2.6 总结</strong></h3><p>&emsp;&emsp;密码算法要求是可逆的，这样解密算法才能正确的恢复明文。拿AES来说，在密钥固定的情况下，明文和密文在整个输入空间是一一对应的。因此算法的各个部件也都是可逆的，再将各个部件的操作顺序设计成可逆的，密文就能正确的解密了。</p><hr><h2 id="第二节-源码解析"><a href="#第二节-源码解析" class="headerlink" title="第二节 源码解析"></a><strong>第二节 源码解析</strong></h2><p>&emsp;&emsp;暂无。</p><hr><h2 id="第三节-实战应用"><a href="#第三节-实战应用" class="headerlink" title="第三节 实战应用"></a><strong>第三节 实战应用</strong></h2><figure class="highlight processing"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> class AesEncryptUtils &#123;</span><br><span class="line">    <span class="comment">//可配置到Constant中，并读取配置文件注入,16位,自己定义</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">String</span> KEY = <span class="string">"abcdefghijklmnop"</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//参数分别代表 算法名称/加密模式/数据填充方式</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">String</span> ALGORITHMSTR = <span class="string">"AES/ECB/PKCS5Padding"</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 加密</span></span><br><span class="line"><span class="comment">     * @param content 加密的字符串</span></span><br><span class="line"><span class="comment">     * @param encryptKey key值</span></span><br><span class="line"><span class="comment">     * @return</span></span><br><span class="line"><span class="comment">     * @throws Exception</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">String</span> encrypt(<span class="keyword">String</span> content, <span class="keyword">String</span> encryptKey) <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        KeyGenerator kgen = KeyGenerator.getInstance(<span class="string">"AES"</span>);</span><br><span class="line">        kgen.init(<span class="number">128</span>);</span><br><span class="line">        Cipher cipher = Cipher.getInstance(ALGORITHMSTR);</span><br><span class="line">        cipher.init(Cipher.ENCRYPT_MODE, <span class="keyword">new</span> SecretKeySpec(encryptKey.getBytes(), <span class="string">"AES"</span>));</span><br><span class="line">        <span class="built_in">byte</span>[] b = cipher.doFinal(content.getBytes(<span class="string">"utf-8"</span>));</span><br><span class="line">        <span class="comment">// 采用base64算法进行转码,避免出现中文乱码</span></span><br><span class="line">        <span class="keyword">return</span> Base64.encodeBase64String(b);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 解密</span></span><br><span class="line"><span class="comment">     * @param encryptStr 解密的字符串</span></span><br><span class="line"><span class="comment">     * @param decryptKey 解密的key值</span></span><br><span class="line"><span class="comment">     * @return</span></span><br><span class="line"><span class="comment">     * @throws Exception</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">String</span> decrypt(<span class="keyword">String</span> encryptStr, <span class="keyword">String</span> decryptKey) <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        KeyGenerator kgen = KeyGenerator.getInstance(<span class="string">"AES"</span>);</span><br><span class="line">        kgen.init(<span class="number">128</span>);</span><br><span class="line">        Cipher cipher = Cipher.getInstance(ALGORITHMSTR);</span><br><span class="line">        cipher.init(Cipher.DECRYPT_MODE, <span class="keyword">new</span> SecretKeySpec(decryptKey.getBytes(), <span class="string">"AES"</span>));</span><br><span class="line">        <span class="comment">// 采用base64算法进行转码,避免出现中文乱码</span></span><br><span class="line">        <span class="built_in">byte</span>[] encryptBytes = Base64.decodeBase64(encryptStr);</span><br><span class="line">        <span class="built_in">byte</span>[] decryptBytes = cipher.doFinal(encryptBytes);</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="keyword">String</span>(decryptBytes);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">String</span> encrypt(<span class="keyword">String</span> content) <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        <span class="keyword">return</span> encrypt(content, KEY);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">String</span> decrypt(<span class="keyword">String</span> encryptStr) <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        <span class="keyword">return</span> decrypt(encryptStr, KEY);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> main(<span class="keyword">String</span>[] args) <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        <span class="keyword">String</span> content = <span class="string">"dhfkKjhsd23wefsd"</span>;</span><br><span class="line">        System.out.<span class="built_in">println</span>(<span class="string">"加密前："</span> + content);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">String</span> encrypt = encrypt(content, KEY);</span><br><span class="line">        System.out.<span class="built_in">println</span>(<span class="string">"加密后："</span> + encrypt);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">String</span> decrypt = decrypt(encrypt, KEY);</span><br><span class="line">        System.out.<span class="built_in">println</span>(<span class="string">"解密后："</span> + decrypt);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><p><em>参考博客和文章书籍等：</em></p><blockquote><p><a href="https://github.com/matt-wu/AES" title="Title" target="_blank" rel="noopener">matt-wu/AES</a></p></blockquote><blockquote><p><a href="https://www.cnblogs.com/luop/p/4334160.html" title="Title" target="_blank" rel="noopener">密码算法详解——AES</a></p></blockquote><blockquote><p><a href="https://blog.csdn.net/qq_28205153/article/details/55798628" title="Title" target="_blank" rel="noopener">AES加密算法的详细介绍与实现</a></p></blockquote><p><em>因博客主等未标明不可引用，若部分内容涉及侵权请及时告知，我会尽快修改和删除相关内容</em></p>]]></content>
    
    <summary type="html">
    
      介绍AES加密算法，内容包括：简介（背景、AES是什么、AES思维导图），算法流程（字节替代、行移位、列混淆、轮密钥加、密钥扩展算法、总结），源码解析，实战应用等。
    
    </summary>
    
      <category term="技术文档" scheme="http://linyishui.top/categories/%E6%8A%80%E6%9C%AF%E6%96%87%E6%A1%A3/"/>
    
    
      <category term="java" scheme="http://linyishui.top/tags/java/"/>
    
      <category term="security" scheme="http://linyishui.top/tags/security/"/>
    
  </entry>
  
  <entry>
    <title>Spring Security OAuth2（未完成）</title>
    <link href="http://linyishui.top/2019111701.html"/>
    <id>http://linyishui.top/2019111701.html</id>
    <published>2019-11-17T07:53:56.000Z</published>
    <updated>2020-01-02T02:23:43.403Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="Spring-Security-OAuth2"><a href="#Spring-Security-OAuth2" class="headerlink" title="Spring Security OAuth2"></a><strong>Spring Security OAuth2</strong></h1><h2 id="第一节-简介"><a href="#第一节-简介" class="headerlink" title="第一节 简介"></a><strong>第一节 简介</strong></h2><p><img src="https://pic-1258215793.cos.ap-shanghai.myqcloud.com/content/20191101/201911010158.jpg" alt="Spring Security&#39;s OAuth2结构"></p><hr><h2 id="第二节-Spring新版本迁移"><a href="#第二节-Spring新版本迁移" class="headerlink" title="第二节 Spring新版本迁移"></a><strong>第二节 Spring新版本迁移</strong></h2><p>&emsp;&emsp;OAuth 2.0客户端和资源服务器从Spring Security OAuth 2.x移动到Spring Security 5.2.x的指南。由于<a href="https://github.com/spring-projects/spring-security" title="Title" target="_blank" rel="noopener">Spring Security</a>不提供授权服务器支持，因此迁移<a href="https://github.com/spring-projects/spring-security-oauth" title="Title" target="_blank" rel="noopener">Spring Security OAuth</a>授权服务器超出了本文档的范围</p><h3 id="2-1-客户端-Client"><a href="#2-1-客户端-Client" class="headerlink" title="2.1 客户端 Client"></a><strong>2.1 客户端 Client</strong></h3><p>&emsp;&emsp;通过添加@EnableOAuth2Client注释可以启用Spring Security OAuth对Authorization Code flow的支持，而其他的flows则需要构造并公开OAuth2ClientContext实例。</p><p>&emsp;&emsp;Spring Security的OAuth 2.0 Client则是通过oauth2Client的DSL方法启用支持的。</p><h4 id="2-1-1-RestTemplate-and-WebClient"><a href="#2-1-1-RestTemplate-and-WebClient" class="headerlink" title="2.1.1 RestTemplate and WebClient"></a><strong>2.1.1 RestTemplate and WebClient</strong></h4><p>&emsp;&emsp;Spring Security OAuth扩展了RestTemplate, 引入了OAuth2RestTemplate，这个类需要注册为@Bean并实例化。</p><p>&emsp;&emsp;Spring Security则选择了支持组合并提供了OAuth2AuthorizedClientService,用来帮助创建RestTemplate拦截器或WebClient交换过滤器函数。Spring Security同时为基于Servlet-和基于WebFlux-的应用程序提供了ExchangeFilterFunction。</p><h4 id="2-1-2-Simplified-Client-Resolution"><a href="#2-1-2-Simplified-Client-Resolution" class="headerlink" title="2.1.2 Simplified Client Resolution"></a><strong>2.1.2 Simplified Client Resolution</strong></h4><p>&emsp;&emsp;在Spring Security OAuth中检索当前授权的客户端，需要自动注入（autowire）OAuth2ClientContext实例。Spring Security OAuth通过Spring MVCs request以及session scope来存储OAuth2ClientContext实例。</p><p>&emsp;&emsp;在Spring Security中检索当前授权的客户端，需要@RegisteredOAuth2AuthorizedClient方法参数注解。Spring Security 把已授权的客户端存储在OAuth2AuthorizedClientRepository中。</p><h4 id="2-1-3-Enhanced-Client-Resolution"><a href="#2-1-3-Enhanced-Client-Resolution" class="headerlink" title="2.1.3 Enhanced Client Resolution"></a><strong>2.1.3 Enhanced Client Resolution</strong></h4><p>&emsp;&emsp;Spring Security OAuth通过Spring Boot properties配置单个客户端。</p><p>&emsp;&emsp;Spring Security使用ClientRegistrationRepository来表示客户端，客户端可以通过Spring Security DSL来提供或仍使用Spring Boot配置。</p><h4 id="2-1-4-Simplified-JWT-Support"><a href="#2-1-4-Simplified-JWT-Support" class="headerlink" title="2.1.4 Simplified JWT Support"></a><strong>2.1.4 Simplified JWT Support</strong></h4><p>&emsp;&emsp;Spring Security OAuth通过spring-security-jwt提供JWT支持。</p><p>&emsp;&emsp;Spring Security则依赖于Nimbus提供JWT支持。</p><h4 id="2-1-5-示例-Examples-Matrix"><a href="#2-1-5-示例-Examples-Matrix" class="headerlink" title="2.1.5 示例 Examples Matrix"></a><strong>2.1.5 示例 Examples Matrix</strong></h4><p>&emsp;&emsp;Spring Security和Spring Security OAuth2都提供了如何配置客户端的示例：</p><table><thead><tr><th style="text-align:left">用例</th><th style="text-align:left">Spring Security</th><th style="text-align:left">Spring Security OAuth</th></tr></thead><tbody><tr><td style="text-align:left">Authorization Code</td><td style="text-align:left"><a href="https://github.com/jgrandja/spring-security-oauth-5-2-migrate" title="Title" target="_blank" rel="noopener">Sample</a></td><td style="text-align:left"><a href="https://github.com/jgrandja/spring-security-oauth-2-4-migrate" title="Title" target="_blank" rel="noopener">Sample</a></td></tr><tr><td style="text-align:left">Refresh Token</td><td style="text-align:left"><a href="https://github.com/jgrandja/spring-security-oauth-5-2-migrate" title="Title" target="_blank" rel="noopener">Sample</a></td><td style="text-align:left"><a href="https://github.com/jgrandja/spring-security-oauth-2-4-migrate" title="Title" target="_blank" rel="noopener">Sample</a></td></tr><tr><td style="text-align:left">Client Credentials</td><td style="text-align:left"><a href="https://github.com/jgrandja/spring-security-oauth-5-2-migrate" title="Title" target="_blank" rel="noopener">Sample</a></td><td style="text-align:left"><a href="https://github.com/jgrandja/spring-security-oauth-2-4-migrate" title="Title" target="_blank" rel="noopener">Sample</a></td></tr><tr><td style="text-align:left">Resource Owner Password Credentials</td><td style="text-align:left"><a href="https://github.com/jgrandja/spring-security-oauth-5-2-migrate" title="Title" target="_blank" rel="noopener">Sample</a></td><td style="text-align:left"><a href="https://github.com/jgrandja/spring-security-oauth-2-4-migrate" title="Title" target="_blank" rel="noopener">Sample</a></td></tr></tbody></table><h3 id="2-2-登录-Login"><a href="#2-2-登录-Login" class="headerlink" title="2.2 登录 Login"></a><strong>2.2 登录 Login</strong></h3><h4 id="2-2-1-方法变更-Changes-In-Approach"><a href="#2-2-1-方法变更-Changes-In-Approach" class="headerlink" title="2.2.1 方法变更 Changes In Approach"></a><strong>2.2.1 方法变更 Changes In Approach</strong></h4><p>&emsp;&emsp;Spring Security称呼此功能为OAuth 2.0 Login而Spring Security OAuth则称为SSO。</p><p>&emsp;&emsp;Spring Security OAuth的SSO支持通过添加@EnableOAuth2Sso注解开启。</p><p>&emsp;&emsp;Spring Security的OAuth 2.0 Login支持通过oauth2Login() DSL方法启用的。</p><h3 id="2-3-资源服务器-Resource-Server"><a href="#2-3-资源服务器-Resource-Server" class="headerlink" title="2.3 资源服务器 Resource Server"></a><strong>2.3 资源服务器 Resource Server</strong></h3><h4 id="2-3-1-方法变更-Changes-In-Approach"><a href="#2-3-1-方法变更-Changes-In-Approach" class="headerlink" title="2.3.1 方法变更 Changes In Approach"></a><strong>2.3.1 方法变更 Changes In Approach</strong></h4><p>&emsp;&emsp;Spring Security OAuth的资源服务器支持通过添加@EnableResourceServer注解开启。</p><p>&emsp;&emsp;Spring Security的资源服务器支持通过oauth2ResourceServer DSL方法启用的。</p><p>&emsp;&emsp;Spring Security OAuth为资源服务器提供了两种不同的DSL方法，通过扩展ResourceServerConfigurerAdapter来配置。</p><p>&emsp;&emsp;Spring Security通过Spring Security DSL提供相同的功能, 通过扩展WebSecurityConfigurerAdapter来配置。</p><p>&emsp;&emsp;Spring Security OAuth为具体授权规则指定了两个位置，第一个是通过ResourceServerConfigurerAdapter - 此处的任意规则都是为存在（present）的bearer token设定，第二个是通过WebSecurityConfigurerAdapter - 此处的任意规则都是为缺席（absent）的bearer token设定。</p><p>&emsp;&emsp;Spring Security则标明所有的授权规则都是通过一个或多个WebSecurityConfigurerAdapter配置而来的。</p><p>&emsp;&emsp;Spring Security OAuth提供了一个自定义的SpEL变量oauth2。为了基于scope去进行授权请求或方法, 可以编写一个表达式如access(“#oauth2.hasScope(‘scope’)”)。</p><p>&emsp;&emsp;Spring Security转换scope遵循授权命名规范。为了基于scope去进行授权请求或方法, 可以编写一个表达式如hasAuthority(“SCOPE_scope”)。</p><h4 id="2-3-2-示例-Examples-Matrix"><a href="#2-3-2-示例-Examples-Matrix" class="headerlink" title="2.3.2 示例 Examples Matrix"></a><strong>2.3.2 示例 Examples Matrix</strong></h4><table><thead><tr><th style="text-align:left">用例</th><th style="text-align:left">Spring Security</th><th style="text-align:left">Spring Security OAuth</th></tr></thead><tbody><tr><td style="text-align:left">JWT + JWK</td><td style="text-align:left"><a href="https://github.com/spring-projects/spring-security/tree/master/samples/boot/oauth2resourceserver" title="Title" target="_blank" rel="noopener">Sample</a></td><td style="text-align:left"><a href="https://github.com/spring-projects/spring-security-oauth2-boot/tree/master/samples/spring-boot-sample-secure-oauth2-resource-jwt" title="Title" target="_blank" rel="noopener">Sample</a></td></tr><tr><td style="text-align:left">JWT + Key</td><td style="text-align:left"><a href="https://github.com/spring-projects/spring-security/tree/master/samples/boot/oauth2resourceserver-static" title="Title" target="_blank" rel="noopener">Sample</a></td><td style="text-align:left"><a href="https://docs.spring.io/spring-security-oauth2-boot/docs/current/reference/htmlsingle/#oauth2-boot-resource-server-jwt-single-key" title="Title" target="_blank" rel="noopener">Doc</a></td></tr><tr><td style="text-align:left">Opaque Token</td><td style="text-align:left"><a href="https://github.com/spring-projects/spring-security/tree/master/samples/boot/oauth2resourceserver-opaque" title="Title" target="_blank" rel="noopener">Sample</a></td><td style="text-align:left"><a href="https://github.com/spring-projects/spring-security-oauth2-boot/tree/master/samples/spring-boot-sample-secure-oauth2-resource" title="Title" target="_blank" rel="noopener">Sample</a></td></tr><tr><td style="text-align:left">w/ Actuator</td><td style="text-align:left"><a href="https://docs.spring.io/spring-security/site/docs/current/reference/htmlsingle/#multiple-httpsecurity" title="Title" target="_blank" rel="noopener">Doc</a></td><td style="text-align:left"><a href="https://github.com/spring-projects/spring-security-oauth2-boot/tree/master/samples/spring-boot-sample-secure-oauth2-actuator" title="Title" target="_blank" rel="noopener">Sample</a></td></tr><tr><td style="text-align:left">Audience Validation</td><td style="text-align:left"><a href="https://docs.spring.io/spring-security/site/docs/current/reference/htmlsingle/#oauth2resourceserver-jwt-validation-custom" title="Title" target="_blank" rel="noopener">Doc</a></td><td style="text-align:left"></td></tr><tr><td style="text-align:left">Authorizing Requests</td><td style="text-align:left"><a href="https://docs.spring.io/spring-security/site/docs/current/reference/htmlsingle/#oauth2resourceserver-jwt-authorization" title="Title" target="_blank" rel="noopener">Doc</a></td><td style="text-align:left"><a href="https://docs.spring.io/spring-security-oauth2-boot/docs/current/reference/htmlsingle/#oauth2-boot-resource-server-authorization" title="Title" target="_blank" rel="noopener">Doc</a></td></tr></tbody></table><h4 id="2-3-3-未移植功能-Unported-Features"><a href="#2-3-3-未移植功能-Unported-Features" class="headerlink" title="2.3.3 未移植功能 Unported Features"></a><strong>2.3.3 未移植功能 Unported Features</strong></h4><p>&emsp;&emsp;There are some features that we currently have no plans to port over.</p><p>&emsp;&emsp;In Spring Security OAuth, you can configure a UserDetailsService to look up a user that corresponds with the incoming bearer token. There are no plans for Spring Security’s Resource Server support to pick up a UserDetailsService. This is still simple in Spring Security, though, via the jwtAuthenticationConverter DSL method. Notably, one can return a BearerTokenAuthentication which takes an instance of OAuth2AuthenticatedPrincipal for a principal.</p><p>&emsp;&emsp;In Spring Security OAuth, you can assign an identifier to the resource server via the ResourceServerSecurityConfigurer#resourceId method. This configures the realm name used by the authentication entry point as well as adds audience validation. No such identifier is planned for Spring Security. However, audience validation and a custom realm name are both simple to achieve by configuring an OAuth2TokenValidator and AuthenticationEntryPoint respectively.</p><hr><h2 id="第三节-实战：实现单点登录"><a href="#第三节-实战：实现单点登录" class="headerlink" title="第三节 实战：实现单点登录"></a><strong>第三节 实战：实现单点登录</strong></h2><p>&emsp;&emsp;</p><hr><h2 id="第四节-实战：APP平台第三方应用授权"><a href="#第四节-实战：APP平台第三方应用授权" class="headerlink" title="第四节 实战：APP平台第三方应用授权"></a><strong>第四节 实战：APP平台第三方应用授权</strong></h2><p>&emsp;&emsp;首先在平台官网注册成为开发者。</p><p>&emsp;&emsp;然后注册应用信息，并搭建好项目。</p><p>&emsp;&emsp;OAuth时序图如下，通过OAuth来对接个人项目和APP平台，之后开发完毕后，只要保证提供一个稳定可用的线上版本即可。</p><p><img src="https://pic-1258215793.cos.ap-shanghai.myqcloud.com/content/20191101/201911010138.jpg" alt="OAuth时序图"></p><p>&emsp;&emsp;官网文档提供了OAuth2.0的authorize接口、access token接口、获取用户信息接口。</p><p>&emsp;&emsp;怎么通过Spring Security配置OAuth2 Client？找了一下Spring官网Demo：<a href="https://github.com/jgrandja/spring-security-oauth-5-2-migrate" title="Title" target="_blank" rel="noopener">OAuth-2.0-Migration-Guide</a>，直接按Demo来实现我们的需求。</p><p>&emsp;&emsp;代码就没必要再贴一遍了，了解OAuth2协议流程，对整个技术框架都会比较熟悉了，快速的实现需求后，再慢慢解决遇到的问题。</p><p>&emsp;&emsp;以下为部分配置文件内容。</p><figure class="highlight roboconf"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Spring-Security</span></span><br><span class="line">spring.security.oauth2.client.registration.cpdemo-client.provider=cpdemo</span><br><span class="line">spring.security.oauth2.client.registration.cpdemo-client.client-id=15764595791470995</span><br><span class="line">spring.security.oauth2.client.registration.cpdemo-client.client-secret=trmCkkXvNTEtURIZjqj0yQ0A13PJ90</span><br><span class="line">spring.security.oauth2.client.registration.cpdemo-client.authorization-grant-type=authorization_code</span><br><span class="line">spring.security.oauth2.client.registration.cpdemo-client.client-name=TEST</span><br><span class="line">spring.security.oauth2.client.registration.cpdemo-client.redirect-uri=&#123;<span class="attribute">baseUrl&#125;/login/oauth2/code/&#123;registrationId&#125;</span></span><br><span class="line"><span class="attribute">spring.security.oauth2.client.registration.cpdemo-client.scope=get_user_info</span></span><br><span class="line"><span class="attribute"></span></span><br><span class="line"><span class="attribute">spring.security.oauth2.client.provider.cpdemo.authorization-uri=https</span>://www<span class="variable">.cpdemo</span><span class="variable">.com</span>/connect/oauth2/authorize</span><br><span class="line">spring<span class="variable">.security</span><span class="variable">.oauth</span>2<span class="variable">.client</span><span class="variable">.provider</span><span class="variable">.cpdemo</span><span class="variable">.token-uri</span>=https://www<span class="variable">.cpdemo</span><span class="variable">.com</span>/connect/oauth2/token</span><br><span class="line">spring<span class="variable">.security</span><span class="variable">.oauth</span>2<span class="variable">.client</span><span class="variable">.provider</span><span class="variable">.cpdemo</span><span class="variable">.user-info-uri</span>=https://api<span class="variable">.cpdemo</span><span class="variable">.com</span>/user/campus/get_user_info</span><br><span class="line">spring<span class="variable">.security</span><span class="variable">.oauth</span>2<span class="variable">.client</span><span class="variable">.provider</span><span class="variable">.cpdemo</span><span class="variable">.user-name-attribute</span>=user_name</span><br><span class="line"></span><br><span class="line"># 解决  Possible CSRF detected - state parameter was required but no state could be found  问题</span><br><span class="line">server<span class="variable">.servlet</span><span class="variable">.session</span><span class="variable">.cookie</span><span class="variable">.name</span>=OAUTH2CLIENTSESSION</span><br></pre></td></tr></table></figure><hr><h2 id="第五节-问题记录：得到授权code后无法获取访问令牌"><a href="#第五节-问题记录：得到授权code后无法获取访问令牌" class="headerlink" title="第五节 问题记录：得到授权code后无法获取访问令牌"></a><strong>第五节 问题记录：得到授权code后无法获取访问令牌</strong></h2><h3 id="1-1-问题描述"><a href="#1-1-问题描述" class="headerlink" title="1.1 问题描述"></a><strong>1.1 问题描述</strong></h3><p>&emsp;&emsp;正常访问<a href="http://localhost:7990/，向server发出授权请求，并重定向到一个PC接口需要用APP端扫码二维码，扫码成功后发生异常，返回/login?error页面提示错误msg：[authorization_request_not_found]" target="_blank" rel="noopener">http://localhost:7990/，向server发出授权请求，并重定向到一个PC接口需要用APP端扫码二维码，扫码成功后发生异常，返回/login?error页面提示错误msg：[authorization_request_not_found]</a></p><h3 id="1-2-问题跟踪"><a href="#1-2-问题跟踪" class="headerlink" title="1.2 问题跟踪"></a><strong>1.2 问题跟踪</strong></h3><p>&emsp;&emsp;开始调试代码，并记录访问流程。</p><figure class="highlight pf"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line">--首先客户发起请求，收到rep重定向到/index</span><br><span class="line">http://localhost:<span class="number">7990</span>/</span><br><span class="line">    Status Code: <span class="number">302</span> </span><br><span class="line">    Response：</span><br><span class="line">        Location: http://localhost:<span class="number">7990</span>/index</span><br><span class="line"></span><br><span class="line">--请求/index，收到rep重定向到/oauth2/authorization/cpdemo-client，并用Cookie保存session：OAUTH2CLIENTSESSION</span><br><span class="line">http://localhost:<span class="number">7990</span>/index</span><br><span class="line">    Status Code: <span class="number">302</span> </span><br><span class="line">    Response：</span><br><span class="line">        Location: http://localhost:<span class="number">7990</span>/oauth2/authorization/cpdemo-client</span><br><span class="line">        Set-Cookie: OAUTH2CLIENTSESSION=<span class="number">907</span>AE53F4C3C1DA967944F7B89E295EA; Path=/; HttpOnly</span><br><span class="line"></span><br><span class="line">--请求/oauth2/authorization/cpdemo-client，携带Cookie，收到rep重定向到www.xxx.com的授权接口，注意此时<span class="keyword">state</span>为WiSvFEChWOuaLw0GtwigPzmRx7ocBPRDGxZJMqzAnkQ%<span class="number">3</span>D</span><br><span class="line">http://localhost:<span class="number">7990</span>/oauth2/authorization/cpdemo-client</span><br><span class="line">    Status Code: <span class="number">302</span> </span><br><span class="line">    Request：</span><br><span class="line">        Cookie: OAUTH2CLIENTSESSION=<span class="number">907</span>AE53F4C3C1DA967944F7B89E295EA</span><br><span class="line">    Response：</span><br><span class="line">        Location: https://www.xxx.com/connect/oauth2/authorize?response_type=code&amp;client_id=xxx&amp;scope=get_user_info&amp;<span class="keyword">state</span>=WiSvFEChWOuaLw0GtwigPzmRx7ocBPRDGxZJMqzAnkQ%<span class="number">3</span>D&amp;redirect_uri=http://localhost:<span class="number">7990</span>/login/oauth2/code/cpdemo-client</span><br><span class="line"></span><br><span class="line">--请求www.cpdemo.com的授权接口，收到rep重定向到/pc/qrcode/index.html，并用保存Cookie：acw_tc，授权服务器检测到PC端访问，跳转到一个二维码界面</span><br><span class="line">https://www.cpdemo.com/connect/oauth2/authorize?response_type=code&amp;client_id=xxx&amp;scope=get_user_info&amp;<span class="keyword">state</span>=WiSvFEChWOuaLw0GtwigPzmRx7ocBPRDGxZJMqzAnkQ%<span class="number">3</span>D&amp;redirect_uri=http://localhost:<span class="number">7990</span>/login/oauth2/code/cpdemo-client</span><br><span class="line">    Status Code: <span class="number">302</span> </span><br><span class="line">    Response</span><br><span class="line">        Location: https://www.cpdemo.com/connect/pc/qrcode/index.html?response_type=code&amp;scope=get_user_info&amp;client_id=<span class="number">15764595791470995</span>&amp;redirect_uri=http%<span class="number">3</span>A%<span class="number">2</span>F%<span class="number">2</span>Flocalhost%<span class="number">3</span>A7990%<span class="number">2</span>Flogin%<span class="number">2</span>Foauth2%<span class="number">2</span>Fcode%<span class="number">2</span>Fcpdemo-client&amp;<span class="keyword">state</span>=WiSvFEChWOuaLw0GtwigPzmRx7ocBPRDGxZJMqzAnkQ=&amp;top_redirect=&amp;support_free_login=&amp;_=<span class="number">1577692641980</span><span class="comment">#</span></span><br><span class="line">        Set-Cookie: acw_tc=<span class="number">76</span>b20fec15776926419723186e2e77475066dc07c6ab3101e3cd340c96ff46;path=/;HttpOnly;Max-Age=<span class="number">2678401</span></span><br><span class="line"></span><br><span class="line">--请求/pc/qrcode/index.html，携带Cookie，获取二维码界面</span><br><span class="line">https://www.cpdemo.com/connect/pc/qrcode/index.html?response_type=code&amp;scope=get_user_info&amp;client_id=xxx&amp;redirect_uri=http%<span class="number">3</span>A%<span class="number">2</span>F%<span class="number">2</span>Flocalhost%<span class="number">3</span>A7990%<span class="number">2</span>Flogin%<span class="number">2</span>Foauth2%<span class="number">2</span>Fcode%<span class="number">2</span>Fcpdemo-client&amp;<span class="keyword">state</span>=WiSvFEChWOuaLw0GtwigPzmRx7ocBPRDGxZJMqzAnkQ=&amp;top_redirect=&amp;support_free_login=&amp;_=xxx</span><br><span class="line">    Status Code: <span class="number">200</span> </span><br><span class="line">    Request：</span><br><span class="line">        Cookie: acw_tc=<span class="number">76</span>b20fec15776926419723186e2e77475066dc07c6ab3101e3cd340c96ff46</span><br><span class="line"></span><br><span class="line">--扫码登陆，并携带新的参数，注意此时<span class="keyword">state</span>值为login</span><br><span class="line">https://www.cpdemo.com/connect/qrcode/jsLogin</span><br><span class="line">    Status Code: <span class="number">200</span> </span><br><span class="line">    Request：</span><br><span class="line">        Cookie: acw_tc=<span class="number">76</span>b20fec15776926419723186e2e77475066dc07c6ab3101e3cd340c96ff46</span><br><span class="line">    Playload：</span><br><span class="line">        clientId: <span class="string">"xxx"</span></span><br><span class="line">        redirectUri: <span class="string">"http://localhost:7990/login/oauth2/code/cpdemo-client"</span></span><br><span class="line">        scope: <span class="string">"get_user_info"</span></span><br><span class="line">        responseType: <span class="string">"code"</span></span><br><span class="line">        <span class="keyword">state</span>: <span class="string">"login"</span></span><br><span class="line">        supportFreeLogin: <span class="string">""</span></span><br><span class="line"></span><br><span class="line">--登陆成功，重定向到redirectUri：/login/oauth2/code/cpdemo-client，并携带授权code和<span class="keyword">state</span>，请求失败，跳转error界面</span><br><span class="line">http://localhost:<span class="number">7990</span>/login/oauth2/code/cpdemo-client?code=cCrxmz1ds745WmV4WPYa1577692667&amp;<span class="keyword">state</span>=login</span><br><span class="line">    Request：</span><br><span class="line">        Cookie: OAUTH2CLIENTSESSION=<span class="number">907</span>AE53F4C3C1DA967944F7B89E295EA</span><br></pre></td></tr></table></figure><p>&emsp;&emsp;再看DEBUG日志</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br></pre></td><td class="code"><pre><span class="line"><span class="bullet">-</span><span class="bullet">-本地客户端服务器收到code和state</span></span><br><span class="line"><span class="string">o.a.coyote.http11.Http11InputBuffer</span>      <span class="string">:</span> <span class="string">Received</span> <span class="string">[GET</span> <span class="string">/login/oauth2/code/cpdemo-client?code=PYd42xxZiDccJH5K6Hmz1577674731&amp;state=login</span> <span class="string">HTTP/1.1</span></span><br><span class="line"></span><br><span class="line"><span class="attr">Host:</span> <span class="attr">localhost:7990</span></span><br><span class="line"><span class="attr">Connection:</span> <span class="string">keep-alive</span></span><br><span class="line"><span class="attr">Cache-Control:</span> <span class="string">max-age=0</span></span><br><span class="line"><span class="attr">Upgrade-Insecure-Requests:</span> <span class="number">1</span></span><br><span class="line"><span class="attr">User-Agent:</span> <span class="string">Mozilla/5.0</span> <span class="string">(Windows</span> <span class="string">NT</span> <span class="number">10.0</span><span class="string">;</span> <span class="string">Win64;</span> <span class="string">x64)</span> <span class="string">AppleWebKit/537.36</span> <span class="string">(KHTML,</span> <span class="string">like</span> <span class="string">Gecko)</span> <span class="string">Chrome/79.0.3945.88</span> <span class="string">Safari/537.36</span></span><br><span class="line"><span class="attr">Accept:</span> <span class="string">text/html,application/xhtml+xml,application/xml;q=0.9,image/webp,image/apng,*/*;q=0.8,application/signed-exchange;v=b3;q=0.9</span></span><br><span class="line"><span class="attr">Sec-Fetch-Site:</span> <span class="string">cross-site</span></span><br><span class="line"><span class="attr">Sec-Fetch-Mode:</span> <span class="string">navigate</span></span><br><span class="line"><span class="attr">Accept-Encoding:</span> <span class="string">gzip,</span> <span class="string">deflate,</span> <span class="string">br</span></span><br><span class="line"><span class="attr">Accept-Language:</span> <span class="string">zh-CN,zh;q=0.9,en;q=0.8</span></span><br><span class="line"><span class="attr">Cookie:</span> <span class="string">OAUTH2CLIENTSESSION=9F0F448755B953A5542B4E2856AC7C54</span></span><br><span class="line"></span><br><span class="line"><span class="string">]</span></span><br><span class="line"></span><br><span class="line"><span class="string">...</span></span><br><span class="line"></span><br><span class="line"><span class="bullet">-</span><span class="bullet">-过滤器校验</span></span><br><span class="line"></span><br><span class="line"><span class="number">2019</span><span class="bullet">-12</span><span class="bullet">-30</span> <span class="number">15</span><span class="string">:51:44.889</span> <span class="string">DEBUG</span> <span class="number">20732</span> <span class="meta">---</span> <span class="string">[nio-7990-exec-1]</span> <span class="string">o.s.security.web.FilterChainProxy</span>        <span class="string">:</span> <span class="string">/login/oauth2/code/cpdemo-client?code=PYd42xxZiDccJH5K6Hmz1577674731&amp;state=login</span> <span class="string">at</span> <span class="string">position</span> <span class="number">1</span> <span class="string">of</span> <span class="number">15</span> <span class="string">in</span> <span class="string">additional</span> <span class="string">filter</span> <span class="string">chain;</span> <span class="string">firing</span> <span class="attr">Filter:</span> <span class="string">'WebAsyncManagerIntegrationFilter'</span></span><br><span class="line"><span class="number">2019</span><span class="bullet">-12</span><span class="bullet">-30</span> <span class="number">15</span><span class="string">:51:44.889</span> <span class="string">DEBUG</span> <span class="number">20732</span> <span class="meta">---</span> <span class="string">[nio-7990-exec-1]</span> <span class="string">o.s.security.web.FilterChainProxy</span>        <span class="string">:</span> <span class="string">/login/oauth2/code/cpdemo-client?code=PYd42xxZiDccJH5K6Hmz1577674731&amp;state=login</span> <span class="string">at</span> <span class="string">position</span> <span class="number">2</span> <span class="string">of</span> <span class="number">15</span> <span class="string">in</span> <span class="string">additional</span> <span class="string">filter</span> <span class="string">chain;</span> <span class="string">firing</span> <span class="attr">Filter:</span> <span class="string">'SecurityContextPersistenceFilter'</span></span><br><span class="line"></span><br><span class="line"><span class="bullet">-</span><span class="bullet">-HttpSessionSecurityContextRepository提示取不到HttpSession</span></span><br><span class="line"></span><br><span class="line"><span class="number">2019</span><span class="bullet">-12</span><span class="bullet">-30</span> <span class="number">15</span><span class="string">:51:44.889</span> <span class="string">DEBUG</span> <span class="number">20732</span> <span class="meta">---</span> <span class="string">[nio-7990-exec-1]</span> <span class="string">w.c.HttpSessionSecurityContextRepository</span> <span class="string">:</span> <span class="literal">No</span> <span class="string">HttpSession</span> <span class="string">currently</span> <span class="string">exists</span></span><br><span class="line"><span class="number">2019</span><span class="bullet">-12</span><span class="bullet">-30</span> <span class="number">15</span><span class="string">:51:44.889</span> <span class="string">DEBUG</span> <span class="number">20732</span> <span class="meta">---</span> <span class="string">[nio-7990-exec-1]</span> <span class="string">w.c.HttpSessionSecurityContextRepository</span> <span class="string">:</span> <span class="literal">No</span> <span class="string">SecurityContext</span> <span class="string">was</span> <span class="string">available</span> <span class="string">from</span> <span class="string">the</span> <span class="attr">HttpSession:</span> <span class="literal">null</span>. <span class="string">A</span> <span class="string">new</span> <span class="string">one</span> <span class="string">will</span> <span class="string">be</span> <span class="string">created.</span></span><br><span class="line"><span class="number">2019</span><span class="bullet">-12</span><span class="bullet">-30</span> <span class="number">15</span><span class="string">:51:44.889</span> <span class="string">DEBUG</span> <span class="number">20732</span> <span class="meta">---</span> <span class="string">[nio-7990-exec-1]</span> <span class="string">o.s.security.web.FilterChainProxy</span>        <span class="string">:</span> <span class="string">/login/oauth2/code/cpdemo-client?code=PYd42xxZiDccJH5K6Hmz1577674731&amp;state=login</span> <span class="string">at</span> <span class="string">position</span> <span class="number">3</span> <span class="string">of</span> <span class="number">15</span> <span class="string">in</span> <span class="string">additional</span> <span class="string">filter</span> <span class="string">chain;</span> <span class="string">firing</span> <span class="attr">Filter:</span> <span class="string">'HeaderWriterFilter'</span></span><br><span class="line"><span class="number">2019</span><span class="bullet">-12</span><span class="bullet">-30</span> <span class="number">15</span><span class="string">:51:44.889</span> <span class="string">DEBUG</span> <span class="number">20732</span> <span class="meta">---</span> <span class="string">[nio-7990-exec-1]</span> <span class="string">o.s.security.web.FilterChainProxy</span>        <span class="string">:</span> <span class="string">/login/oauth2/code/cpdemo-client?code=PYd42xxZiDccJH5K6Hmz1577674731&amp;state=login</span> <span class="string">at</span> <span class="string">position</span> <span class="number">4</span> <span class="string">of</span> <span class="number">15</span> <span class="string">in</span> <span class="string">additional</span> <span class="string">filter</span> <span class="string">chain;</span> <span class="string">firing</span> <span class="attr">Filter:</span> <span class="string">'CsrfFilter'</span></span><br><span class="line"><span class="number">2019</span><span class="bullet">-12</span><span class="bullet">-30</span> <span class="number">15</span><span class="string">:51:44.889</span> <span class="string">DEBUG</span> <span class="number">20732</span> <span class="meta">---</span> <span class="string">[nio-7990-exec-1]</span> <span class="string">o.s.security.web.FilterChainProxy</span>        <span class="string">:</span> <span class="string">/login/oauth2/code/cpdemo-client?code=PYd42xxZiDccJH5K6Hmz1577674731&amp;state=login</span> <span class="string">at</span> <span class="string">position</span> <span class="number">5</span> <span class="string">of</span> <span class="number">15</span> <span class="string">in</span> <span class="string">additional</span> <span class="string">filter</span> <span class="string">chain;</span> <span class="string">firing</span> <span class="attr">Filter:</span> <span class="string">'LogoutFilter'</span></span><br><span class="line"><span class="number">2019</span><span class="bullet">-12</span><span class="bullet">-30</span> <span class="number">15</span><span class="string">:51:44.889</span> <span class="string">DEBUG</span> <span class="number">20732</span> <span class="meta">---</span> <span class="string">[nio-7990-exec-1]</span> <span class="string">o.s.s.w.u.matcher.AntPathRequestMatcher</span>  <span class="string">:</span> <span class="string">Request</span> <span class="string">'GET /login/oauth2/code/cpdemo-client'</span> <span class="string">doesn't</span> <span class="string">match</span> <span class="string">'POST /logout'</span></span><br><span class="line"><span class="number">2019</span><span class="bullet">-12</span><span class="bullet">-30</span> <span class="number">15</span><span class="string">:51:44.889</span> <span class="string">DEBUG</span> <span class="number">20732</span> <span class="meta">---</span> <span class="string">[nio-7990-exec-1]</span> <span class="string">o.s.security.web.FilterChainProxy</span>        <span class="string">:</span> <span class="string">/login/oauth2/code/cpdemo-client?code=PYd42xxZiDccJH5K6Hmz1577674731&amp;state=login</span> <span class="string">at</span> <span class="string">position</span> <span class="number">6</span> <span class="string">of</span> <span class="number">15</span> <span class="string">in</span> <span class="string">additional</span> <span class="string">filter</span> <span class="string">chain;</span> <span class="string">firing</span> <span class="attr">Filter:</span> <span class="string">'OAuth2AuthorizationRequestRedirectFilter'</span></span><br><span class="line"><span class="number">2019</span><span class="bullet">-12</span><span class="bullet">-30</span> <span class="number">15</span><span class="string">:51:44.889</span> <span class="string">DEBUG</span> <span class="number">20732</span> <span class="meta">---</span> <span class="string">[nio-7990-exec-1]</span> <span class="string">o.s.s.w.u.matcher.AntPathRequestMatcher</span>  <span class="string">:</span> <span class="string">Checking</span> <span class="string">match</span> <span class="string">of</span> <span class="string">request</span> <span class="string">:</span> <span class="string">'/login/oauth2/code/cpdemo-client'</span><span class="string">;</span> <span class="string">against</span> <span class="string">'/oauth2/authorization/&#123;registrationId&#125;'</span></span><br><span class="line"><span class="number">2019</span><span class="bullet">-12</span><span class="bullet">-30</span> <span class="number">15</span><span class="string">:51:44.889</span> <span class="string">DEBUG</span> <span class="number">20732</span> <span class="meta">---</span> <span class="string">[nio-7990-exec-1]</span> <span class="string">org.apache.tomcat.util.http.Parameters</span>   <span class="string">:</span> <span class="string">Set</span> <span class="string">encoding</span> <span class="string">to</span> <span class="string">UTF-8</span></span><br><span class="line"><span class="number">2019</span><span class="bullet">-12</span><span class="bullet">-30</span> <span class="number">15</span><span class="string">:51:44.889</span> <span class="string">DEBUG</span> <span class="number">20732</span> <span class="meta">---</span> <span class="string">[nio-7990-exec-1]</span> <span class="string">org.apache.tomcat.util.http.Parameters</span>   <span class="string">:</span> <span class="string">Decoding</span> <span class="string">query</span> <span class="literal">null</span> <span class="string">UTF-8</span></span><br><span class="line"><span class="number">2019</span><span class="bullet">-12</span><span class="bullet">-30</span> <span class="number">15</span><span class="string">:51:44.889</span> <span class="string">DEBUG</span> <span class="number">20732</span> <span class="meta">---</span> <span class="string">[nio-7990-exec-1]</span> <span class="string">org.apache.tomcat.util.http.Parameters</span>   <span class="string">:</span> <span class="string">Start</span> <span class="string">processing</span> <span class="string">with</span> <span class="string">input</span> <span class="string">[code=PYd42xxZiDccJH5K6Hmz1577674731&amp;state=login]</span></span><br><span class="line"><span class="number">2019</span><span class="bullet">-12</span><span class="bullet">-30</span> <span class="number">15</span><span class="string">:51:44.889</span> <span class="string">DEBUG</span> <span class="number">20732</span> <span class="meta">---</span> <span class="string">[nio-7990-exec-1]</span> <span class="string">o.s.security.web.FilterChainProxy</span>        <span class="string">:</span> <span class="string">/login/oauth2/code/cpdemo-client?code=PYd42xxZiDccJH5K6Hmz1577674731&amp;state=login</span> <span class="string">at</span> <span class="string">position</span> <span class="number">7</span> <span class="string">of</span> <span class="number">15</span> <span class="string">in</span> <span class="string">additional</span> <span class="string">filter</span> <span class="string">chain;</span> <span class="string">firing</span> <span class="attr">Filter:</span> <span class="string">'OAuth2LoginAuthenticationFilter'</span></span><br><span class="line"><span class="number">2019</span><span class="bullet">-12</span><span class="bullet">-30</span> <span class="number">15</span><span class="string">:51:44.905</span> <span class="string">DEBUG</span> <span class="number">20732</span> <span class="meta">---</span> <span class="string">[nio-7990-exec-1]</span> <span class="string">o.s.s.w.u.matcher.AntPathRequestMatcher</span>  <span class="string">:</span> <span class="string">Checking</span> <span class="string">match</span> <span class="string">of</span> <span class="string">request</span> <span class="string">:</span> <span class="string">'/login/oauth2/code/cpdemo-client'</span><span class="string">;</span> <span class="string">against</span> <span class="string">'/login/oauth2/code/*'</span></span><br><span class="line"></span><br><span class="line"><span class="bullet">-</span><span class="bullet">-OAuth2LoginAuthenticationFilter抛出异常OAuth2AuthenticationException：[authorization_request_not_found]</span> </span><br><span class="line"></span><br><span class="line"><span class="number">2019</span><span class="bullet">-12</span><span class="bullet">-30</span> <span class="number">15</span><span class="string">:51:44.905</span> <span class="string">DEBUG</span> <span class="number">20732</span> <span class="meta">---</span> <span class="string">[nio-7990-exec-1]</span> <span class="string">.s.o.c.w.OAuth2LoginAuthenticationFilter</span> <span class="string">:</span> <span class="string">Request</span> <span class="string">is</span> <span class="string">to</span> <span class="string">process</span> <span class="string">authentication</span></span><br><span class="line"><span class="number">2019</span><span class="bullet">-12</span><span class="bullet">-30</span> <span class="number">15</span><span class="string">:51:44.912</span> <span class="string">DEBUG</span> <span class="number">20732</span> <span class="meta">---</span> <span class="string">[nio-7990-exec-1]</span> <span class="string">.s.o.c.w.OAuth2LoginAuthenticationFilter</span> <span class="string">:</span> <span class="string">Authentication</span> <span class="string">request</span> <span class="attr">failed:</span> <span class="string">org.springframework.security.oauth2.core.OAuth2AuthenticationException:</span> <span class="string">[authorization_request_not_found]</span> </span><br><span class="line"></span><br><span class="line"><span class="string">org.springframework.security.oauth2.core.OAuth2AuthenticationException:</span> <span class="string">[authorization_request_not_found]</span> </span><br><span class="line"><span class="string">at</span> <span class="string">org.springframework.security.oauth2.client.web.OAuth2LoginAuthenticationFilter.attemptAuthentication(OAuth2LoginAuthenticationFilter.java:163)</span> <span class="string">~[spring-security-oauth2-client-5.2.1.RELEASE.jar:5.2.1.RELEASE]</span></span><br><span class="line"><span class="string">at</span> <span class="string">org.springframework.security.web.authentication.AbstractAuthenticationProcessingFilter.doFilter(AbstractAuthenticationProcessingFilter.java:212)</span> <span class="string">~[spring-security-web-5.2.1.RELEASE.jar:5.2.1.RELEASE]</span></span><br><span class="line"><span class="string">at</span> <span class="string">org.springframework.security.web.FilterChainProxy$VirtualFilterChain.doFilter(FilterChainProxy.java:334)</span> <span class="string">[spring-security-web-5.2.1.RELEASE.jar:5.2.1.RELEASE]</span></span><br><span class="line"></span><br><span class="line"><span class="number">2019</span><span class="bullet">-12</span><span class="bullet">-30</span> <span class="number">15</span><span class="string">:51:44.914</span> <span class="string">DEBUG</span> <span class="number">20732</span> <span class="meta">---</span> <span class="string">[nio-7990-exec-1]</span> <span class="string">.s.o.c.w.OAuth2LoginAuthenticationFilter</span> <span class="string">:</span> <span class="string">Updated</span> <span class="string">SecurityContextHolder</span> <span class="string">to</span> <span class="string">contain</span> <span class="literal">null</span> <span class="string">Authentication</span></span><br><span class="line"><span class="number">2019</span><span class="bullet">-12</span><span class="bullet">-30</span> <span class="number">15</span><span class="string">:51:44.914</span> <span class="string">DEBUG</span> <span class="number">20732</span> <span class="meta">---</span> <span class="string">[nio-7990-exec-1]</span> <span class="string">.s.o.c.w.OAuth2LoginAuthenticationFilter</span> <span class="string">:</span> <span class="string">Delegating</span> <span class="string">to</span> <span class="string">authentication</span> <span class="string">failure</span> <span class="string">handler</span> <span class="string">org.springframework.security.web.authentication.SimpleUrlAuthenticationFailureHandler@48edcd38</span></span><br><span class="line"><span class="number">2019</span><span class="bullet">-12</span><span class="bullet">-30</span> <span class="number">15</span><span class="string">:51:44.914</span> <span class="string">DEBUG</span> <span class="number">20732</span> <span class="meta">---</span> <span class="string">[nio-7990-exec-1]</span> <span class="string">.a.SimpleUrlAuthenticationFailureHandler</span> <span class="string">:</span> <span class="string">Redirecting</span> <span class="string">to</span> <span class="string">/login?error</span></span><br><span class="line"><span class="number">2019</span><span class="bullet">-12</span><span class="bullet">-30</span> <span class="number">15</span><span class="string">:51:44.914</span> <span class="string">DEBUG</span> <span class="number">20732</span> <span class="meta">---</span> <span class="string">[nio-7990-exec-1]</span> <span class="string">o.s.s.web.DefaultRedirectStrategy</span>        <span class="string">:</span> <span class="string">Redirecting</span> <span class="string">to</span> <span class="string">'/login?error'</span></span><br><span class="line"><span class="number">2019</span><span class="bullet">-12</span><span class="bullet">-30</span> <span class="number">15</span><span class="string">:51:44.915</span> <span class="string">DEBUG</span> <span class="number">20732</span> <span class="meta">---</span> <span class="string">[nio-7990-exec-1]</span> <span class="string">o.s.s.w.header.writers.HstsHeaderWriter</span>  <span class="string">:</span> <span class="string">Not</span> <span class="string">injecting</span> <span class="string">HSTS</span> <span class="string">header</span> <span class="string">since</span> <span class="string">it</span> <span class="string">did</span> <span class="string">not</span> <span class="string">match</span> <span class="string">the</span> <span class="string">requestMatcher</span> <span class="string">org.springframework.security.web.header.writers.HstsHeaderWriter$SecureRequestMatcher@93c27ef</span></span><br><span class="line"><span class="number">2019</span><span class="bullet">-12</span><span class="bullet">-30</span> <span class="number">15</span><span class="string">:51:44.915</span> <span class="string">DEBUG</span> <span class="number">20732</span> <span class="meta">---</span> <span class="string">[nio-7990-exec-1]</span> <span class="string">w.c.HttpSessionSecurityContextRepository</span> <span class="string">:</span> <span class="string">SecurityContext</span> <span class="string">is</span> <span class="string">empty</span> <span class="string">or</span> <span class="string">contents</span> <span class="string">are</span> <span class="string">anonymous</span> <span class="bullet">-</span> <span class="string">context</span> <span class="string">will</span> <span class="string">not</span> <span class="string">be</span> <span class="string">stored</span> <span class="string">in</span> <span class="string">HttpSession.</span></span><br><span class="line"><span class="number">2019</span><span class="bullet">-12</span><span class="bullet">-30</span> <span class="number">15</span><span class="string">:51:44.915</span> <span class="string">DEBUG</span> <span class="number">20732</span> <span class="meta">---</span> <span class="string">[nio-7990-exec-1]</span> <span class="string">s.s.w.c.SecurityContextPersistenceFilter</span> <span class="string">:</span> <span class="string">SecurityContextHolder</span> <span class="string">now</span> <span class="string">cleared,</span> <span class="string">as</span> <span class="string">request</span> <span class="string">processing</span> <span class="string">completed</span></span><br></pre></td></tr></table></figure><p>&emsp;&emsp;定位到异常发生的代码，部分源码如下。</p><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">public <span class="class"><span class="keyword">class</span> <span class="title">OAuth2LoginAuthenticationFilter</span> <span class="keyword">extends</span> <span class="title">AbstractAuthenticationProcessingFilter</span> </span>&#123;</span><br><span class="line">    public <span class="type">Authentication</span> attemptAuthentication(<span class="type">HttpServletRequest</span> request, <span class="type">HttpServletResponse</span> response) <span class="keyword">throws</span> <span class="type">AuthenticationException</span> &#123;</span><br><span class="line">        <span class="type">MultiValueMap</span>&lt;<span class="type">String</span>, <span class="type">String</span>&gt; params = <span class="type">OAuth2AuthorizationResponseUtils</span>.toMultiMap(request.getParameterMap());</span><br><span class="line">        <span class="keyword">if</span> (!<span class="type">OAuth2AuthorizationResponseUtils</span>.isAuthorizationResponse(params)) &#123;</span><br><span class="line">            <span class="type">OAuth2Error</span> oauth2Error = <span class="keyword">new</span> <span class="type">OAuth2Error</span>(<span class="string">"invalid_request"</span>);</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="type">OAuth2AuthenticationException</span>(oauth2Error, oauth2Error.toString());</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="type">OAuth2AuthorizationRequest</span> authorizationRequest = <span class="keyword">this</span>.authorizationRequestRepository.removeAuthorizationRequest(request, response);<span class="comment">//此处获取authorizationRequest为null</span></span><br><span class="line">            <span class="keyword">if</span> (authorizationRequest == <span class="literal">null</span>) &#123;</span><br><span class="line">                <span class="type">OAuth2Error</span> oauth2Error = <span class="keyword">new</span> <span class="type">OAuth2Error</span>(<span class="string">"authorization_request_not_found"</span>);</span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> <span class="type">OAuth2AuthenticationException</span>(oauth2Error, oauth2Error.toString());<span class="comment">//此处抛出异常</span></span><br><span class="line">            &#125; </span><br><span class="line">            ...</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>&emsp;&emsp;继续跟踪代码。</p><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line">public <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">HttpSessionOAuth2AuthorizationRequestRepository</span> <span class="keyword">implements</span> <span class="title">AuthorizationRequestRepository</span>&lt;<span class="title">OAuth2AuthorizationRequest</span>&gt; </span>&#123;</span><br><span class="line"></span><br><span class="line">    public OAuth2AuthorizationRequest removeAuthorizationRequest(HttpServletRequest request) &#123;</span><br><span class="line">        Assert.notNull(request, <span class="string">"request cannot be null"</span>);</span><br><span class="line">        <span class="built_in">String</span> stateParameter = <span class="keyword">this</span>.getStateParameter(request);<span class="comment">//取得state参数值为login</span></span><br><span class="line">        <span class="keyword">if</span> (stateParameter == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="built_in">Map</span>&lt;<span class="built_in">String</span>, OAuth2AuthorizationRequest&gt; authorizationRequests = <span class="keyword">this</span>.getAuthorizationRequests(request);<span class="comment">//获得映射："WiSvFEChWOuaLw0GtwigPzmRx7ocBPRDGxZJMqzAnkQ=" -&gt; req</span></span><br><span class="line">            OAuth2AuthorizationRequest originalRequest = (OAuth2AuthorizationRequest)authorizationRequests.remove(stateParameter);<span class="comment">//获得originalRequest为null</span></span><br><span class="line">            <span class="keyword">if</span> (!authorizationRequests.isEmpty()) &#123;</span><br><span class="line">                request.getSession().setAttribute(<span class="keyword">this</span>.sessionAttributeName, authorizationRequests);</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                request.getSession().removeAttribute(<span class="keyword">this</span>.sessionAttributeName);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">return</span> originalRequest;<span class="comment">//返回null</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    ...</span><br><span class="line"></span><br><span class="line">    private <span class="built_in">String</span> getStateParameter(HttpServletRequest request) &#123;</span><br><span class="line">        <span class="keyword">return</span> request.getParameter(<span class="string">"state"</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    private <span class="built_in">Map</span>&lt;<span class="built_in">String</span>, OAuth2AuthorizationRequest&gt; getAuthorizationRequests(HttpServletRequest request) &#123;</span><br><span class="line">        HttpSession session = request.getSession(<span class="keyword">false</span>);</span><br><span class="line">        <span class="built_in">Map</span>&lt;<span class="built_in">String</span>, OAuth2AuthorizationRequest&gt; authorizationRequests = session == <span class="keyword">null</span> ? <span class="keyword">null</span> : (<span class="built_in">Map</span>)session.getAttribute(<span class="keyword">this</span>.sessionAttributeName);</span><br><span class="line">        <span class="keyword">return</span> (<span class="built_in">Map</span>)(authorizationRequests == <span class="keyword">null</span> ? <span class="keyword">new</span> HashMap() : authorizationRequests);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>&emsp;&emsp;我们得到的session中有两个attribute：AUTHORIZATION_REQUEST和SPRING_SECURITY_SAVED_REQUEST，前者存储了一组映射（”WiSvFEChWOuaLw0GtwigPzmRx7ocBPRDGxZJMqzAnkQ=” -&gt; req），后者则是默认Req：<a href="http://localhost:7990/index。" target="_blank" rel="noopener">http://localhost:7990/index。</a></p><p>&emsp;&emsp;所以此处是根据state参数值来获取session中存储的信息，但我们知道在首次请求授权服务器时我们提供的state为：WiSvFEChWOuaLw0GtwigPzmRx7ocBPRDGxZJMqzAnkQ=，扫码登陆后又提交了state为：login，但这里需要的是旧的state参数。</p><p>&emsp;&emsp;所以要么授权服务器在扫码登陆时不要替换state为login，而是WiSv；要么授权服务器在扫码登陆后返回code和state时给旧值WiSv；要么我们客户端重构。</p><p>&emsp;&emsp;联系对方工程师后，回复：“<strong>把state写死试试</strong>”。虽然有点无语，但好吧。</p><h3 id="1-3-问题处理"><a href="#1-3-问题处理" class="headerlink" title="1.3 问题处理"></a><strong>1.3 问题处理</strong></h3><h4 id="1-3-1-自定义Authorization-Code-Request"><a href="#1-3-1-自定义Authorization-Code-Request" class="headerlink" title="1.3.1 自定义Authorization_Code_Request"></a><strong>1.3.1 自定义Authorization_Code_Request</strong></h4><p>&emsp;&emsp;写死state，首先要自定义authorization code request，首先自定义OAuth2AuthorizationRequestResolver，覆盖state参数，代码如下。</p><figure class="highlight processing"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> class CustomAuthorizationRequestResolver implements OAuth2AuthorizationRequestResolver &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> ClientRegistrationRepository clientRegistrationRepository;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> AntPathRequestMatcher authorizationRequestMatcher;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> StringKeyGenerator stateGenerator = <span class="keyword">new</span> Base64StringKeyGenerator(Base64.getUrlEncoder());</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> StringKeyGenerator secureKeyGenerator = <span class="keyword">new</span> Base64StringKeyGenerator(Base64.getUrlEncoder().withoutPadding(), <span class="number">96</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> CustomAuthorizationRequestResolver(</span><br><span class="line">            ClientRegistrationRepository clientRegistrationRepository, <span class="keyword">String</span> authorizationRequestBaseUri) &#123;</span><br><span class="line">        Assert.notNull(clientRegistrationRepository, <span class="string">"clientRegistrationRepository cannot be null"</span>);</span><br><span class="line">        Assert.hasText(authorizationRequestBaseUri, <span class="string">"authorizationRequestBaseUri cannot be empty"</span>);</span><br><span class="line">        <span class="keyword">this</span>.clientRegistrationRepository = clientRegistrationRepository;</span><br><span class="line">        <span class="keyword">this</span>.authorizationRequestMatcher = <span class="keyword">new</span> AntPathRequestMatcher(authorizationRequestBaseUri + <span class="string">"/&#123;"</span> + <span class="string">"registrationId"</span> + <span class="string">"&#125;"</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    <span class="keyword">public</span> OAuth2AuthorizationRequest resolve(HttpServletRequest request) &#123;</span><br><span class="line">        <span class="keyword">String</span> registrationId = <span class="keyword">this</span>.resolveRegistrationId(request);</span><br><span class="line">        <span class="keyword">String</span> redirectUriAction = <span class="keyword">this</span>.getAction(request, <span class="string">"login"</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">this</span>.resolve(request, registrationId, redirectUriAction);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    <span class="keyword">public</span> OAuth2AuthorizationRequest resolve(HttpServletRequest request, <span class="keyword">String</span> registrationId) &#123;</span><br><span class="line">        <span class="keyword">if</span> (registrationId == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">String</span> redirectUriAction = <span class="keyword">this</span>.getAction(request, <span class="string">"authorize"</span>);</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">this</span>.resolve(request, registrationId, redirectUriAction);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">String</span> getAction(HttpServletRequest request, <span class="keyword">String</span> defaultAction) &#123;</span><br><span class="line">        <span class="keyword">String</span> action = request.getParameter(<span class="string">"action"</span>);</span><br><span class="line">        <span class="keyword">return</span> action == <span class="keyword">null</span> ? defaultAction : action;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> OAuth2AuthorizationRequest resolve(HttpServletRequest request, <span class="keyword">String</span> registrationId, <span class="keyword">String</span> redirectUriAction) &#123;</span><br><span class="line">        <span class="keyword">if</span> (registrationId == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            ClientRegistration clientRegistration = <span class="keyword">this</span>.clientRegistrationRepository.findByRegistrationId(registrationId);</span><br><span class="line">            <span class="keyword">if</span> (clientRegistration == <span class="keyword">null</span>) &#123;</span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(<span class="string">"Invalid Client Registration with Id: "</span> + registrationId);</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                Map&lt;<span class="keyword">String</span>, <span class="keyword">Object</span>&gt; attributes = <span class="keyword">new</span> <span class="keyword">HashMap</span>();</span><br><span class="line">                attributes.put(<span class="string">"registration_id"</span>, clientRegistration.getRegistrationId());</span><br><span class="line">                OAuth2AuthorizationRequest.Builder builder;</span><br><span class="line">                <span class="keyword">if</span> (AuthorizationGrantType.AUTHORIZATION_CODE.equals(clientRegistration.getAuthorizationGrantType())) &#123;</span><br><span class="line">                    builder = OAuth2AuthorizationRequest.authorizationCode();</span><br><span class="line">                    Map&lt;<span class="keyword">String</span>, <span class="keyword">Object</span>&gt; additionalParameters = <span class="keyword">new</span> <span class="keyword">HashMap</span>();</span><br><span class="line">                    <span class="keyword">if</span> (!CollectionUtils.isEmpty(clientRegistration.getScopes()) &amp;&amp; clientRegistration.getScopes().contains(<span class="string">"openid"</span>)) &#123;</span><br><span class="line">                        <span class="keyword">this</span>.addNonceParameters(attributes, additionalParameters);</span><br><span class="line">                    &#125;</span><br><span class="line"></span><br><span class="line">                    <span class="keyword">if</span> (ClientAuthenticationMethod.NONE.equals(clientRegistration.getClientAuthenticationMethod())) &#123;</span><br><span class="line">                        <span class="keyword">this</span>.addPkceParameters(attributes, additionalParameters);</span><br><span class="line">                    &#125;</span><br><span class="line"></span><br><span class="line">                    builder.additionalParameters(additionalParameters);</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    <span class="keyword">if</span> (!AuthorizationGrantType.IMPLICIT.equals(clientRegistration.getAuthorizationGrantType())) &#123;</span><br><span class="line">                        <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(<span class="string">"Invalid Authorization Grant Type ("</span> + clientRegistration.getAuthorizationGrantType().getValue() + <span class="string">") for Client Registration with Id: "</span> + clientRegistration.getRegistrationId());</span><br><span class="line">                    &#125;</span><br><span class="line"></span><br><span class="line">                    builder = OAuth2AuthorizationRequest.implicit();</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                <span class="keyword">String</span> redirectUriStr = expandRedirectUri(request, clientRegistration, redirectUriAction);</span><br><span class="line"><span class="comment">//                OAuth2AuthorizationRequest authorizationRequest = builder.clientId(clientRegistration.getClientId()).authorizationUri(clientRegistration.getProviderDetails().getAuthorizationUri()).redirectUri(redirectUriStr).scopes(clientRegistration.getScopes()).state(this.stateGenerator.generateKey()).attributes(attributes).build();</span></span><br><span class="line">                <span class="comment">//stateGenerator.generateKey()替换为常量login</span></span><br><span class="line">                OAuth2AuthorizationRequest authorizationRequest = builder.clientId(clientRegistration.getClientId()).authorizationUri(clientRegistration.getProviderDetails().getAuthorizationUri()).redirectUri(redirectUriStr).scopes(clientRegistration.getScopes()).state(<span class="string">"login"</span>).attributes(attributes).build();</span><br><span class="line">                <span class="comment">//自定义修改请求</span></span><br><span class="line">                <span class="keyword">return</span> customizeAuthorizationRequest(authorizationRequest);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//自定义请求参数</span></span><br><span class="line">    <span class="keyword">private</span> OAuth2AuthorizationRequest customizeAuthorizationRequest(</span><br><span class="line">            OAuth2AuthorizationRequest req) &#123;</span><br><span class="line">        Map&lt;<span class="keyword">String</span>,<span class="keyword">Object</span>&gt; extraParams = <span class="keyword">new</span> <span class="keyword">HashMap</span>&lt;&gt;();</span><br><span class="line">        System.out.<span class="built_in">println</span>(req.getAdditionalParameters());</span><br><span class="line">        extraParams.putAll(req.getAdditionalParameters());</span><br><span class="line">        <span class="comment">//覆盖state</span></span><br><span class="line">        extraParams.put(<span class="string">"state"</span>, <span class="string">"login"</span>);</span><br><span class="line">        <span class="keyword">return</span> OAuth2AuthorizationRequest</span><br><span class="line">                .from(req)</span><br><span class="line">                .additionalParameters(extraParams)</span><br><span class="line">                .build();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">String</span> resolveRegistrationId(HttpServletRequest request) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">this</span>.authorizationRequestMatcher.matches(request) ? (<span class="keyword">String</span>)<span class="keyword">this</span>.authorizationRequestMatcher.matcher(request).getVariables().<span class="built_in">get</span>(<span class="string">"registrationId"</span>) : <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">String</span> expandRedirectUri(HttpServletRequest request, ClientRegistration clientRegistration, <span class="keyword">String</span> action) &#123;</span><br><span class="line">        Map&lt;<span class="keyword">String</span>, <span class="keyword">String</span>&gt; uriVariables = <span class="keyword">new</span> <span class="keyword">HashMap</span>();</span><br><span class="line">        uriVariables.put(<span class="string">"registrationId"</span>, clientRegistration.getRegistrationId());</span><br><span class="line">        UriComponents uriComponents = UriComponentsBuilder.fromHttpUrl(UrlUtils.buildFullRequestUrl(request)).replacePath(request.getContextPath()).replaceQuery((<span class="keyword">String</span>)<span class="keyword">null</span>).fragment((<span class="keyword">String</span>)<span class="keyword">null</span>).build();</span><br><span class="line">        <span class="keyword">String</span> scheme = uriComponents.getScheme();</span><br><span class="line">        uriVariables.put(<span class="string">"baseScheme"</span>, scheme == <span class="keyword">null</span> ? <span class="string">""</span> : scheme);</span><br><span class="line">        <span class="keyword">String</span> host = uriComponents.getHost();</span><br><span class="line">        uriVariables.put(<span class="string">"baseHost"</span>, host == <span class="keyword">null</span> ? <span class="string">""</span> : host);</span><br><span class="line">        <span class="built_in">int</span> port = uriComponents.getPort();</span><br><span class="line">        uriVariables.put(<span class="string">"basePort"</span>, port == <span class="number">-1</span> ? <span class="string">""</span> : <span class="string">":"</span> + port);</span><br><span class="line">        <span class="keyword">String</span> path = uriComponents.getPath();</span><br><span class="line">        <span class="keyword">if</span> (StringUtils.hasLength(path) &amp;&amp; path.charAt(<span class="number">0</span>) != <span class="string">'/'</span>) &#123;</span><br><span class="line">            path = <span class="string">'/'</span> + path;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        uriVariables.put(<span class="string">"basePath"</span>, path == <span class="keyword">null</span> ? <span class="string">""</span> : path);</span><br><span class="line">        uriVariables.put(<span class="string">"baseUrl"</span>, uriComponents.toUriString());</span><br><span class="line">        uriVariables.put(<span class="string">"action"</span>, action == <span class="keyword">null</span> ? <span class="string">""</span> : action);</span><br><span class="line">        <span class="keyword">return</span> UriComponentsBuilder.fromUriString(clientRegistration.getRedirectUriTemplate()).buildAndExpand(uriVariables).toUriString();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">void</span> addNonceParameters(Map&lt;<span class="keyword">String</span>, <span class="keyword">Object</span>&gt; attributes, Map&lt;<span class="keyword">String</span>, <span class="keyword">Object</span>&gt; additionalParameters) &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">String</span> nonce = <span class="keyword">this</span>.secureKeyGenerator.generateKey();</span><br><span class="line">            <span class="keyword">String</span> nonceHash = createHash(nonce);</span><br><span class="line">            attributes.put(<span class="string">"nonce"</span>, nonce);</span><br><span class="line">            additionalParameters.put(<span class="string">"nonce"</span>, nonceHash);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (NoSuchAlgorithmException var5) &#123;</span><br><span class="line">            ;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">void</span> addPkceParameters(Map&lt;<span class="keyword">String</span>, <span class="keyword">Object</span>&gt; attributes, Map&lt;<span class="keyword">String</span>, <span class="keyword">Object</span>&gt; additionalParameters) &#123;</span><br><span class="line">        <span class="keyword">String</span> codeVerifier = <span class="keyword">this</span>.secureKeyGenerator.generateKey();</span><br><span class="line">        attributes.put(<span class="string">"code_verifier"</span>, codeVerifier);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">String</span> codeChallenge = createHash(codeVerifier);</span><br><span class="line">            additionalParameters.put(<span class="string">"code_challenge"</span>, codeChallenge);</span><br><span class="line">            additionalParameters.put(<span class="string">"code_challenge_method"</span>, <span class="string">"S256"</span>);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (NoSuchAlgorithmException var5) &#123;</span><br><span class="line">            additionalParameters.put(<span class="string">"code_challenge"</span>, codeVerifier);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">String</span> createHash(<span class="keyword">String</span> value) <span class="keyword">throws</span> NoSuchAlgorithmException &#123;</span><br><span class="line">        MessageDigest md = MessageDigest.getInstance(<span class="string">"SHA-256"</span>);</span><br><span class="line">        <span class="built_in">byte</span>[] digest = md.digest(value.getBytes(StandardCharsets.US_ASCII));</span><br><span class="line">        <span class="keyword">return</span> Base64.getUrlEncoder().withoutPadding().encodeToString(digest);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>&emsp;&emsp;在SecurityConfig中配置应用CustomAuthorizationRequestResolver。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@EnableWebSecurity</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SecurityConfig</span> <span class="keyword">extends</span> <span class="title">WebSecurityConfigurerAdapter</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">configure</span><span class="params">(HttpSecurity http)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        http.oauth2Login()</span><br><span class="line">                .authorizationEndpoint()</span><br><span class="line">                    .authorizationRequestRepository(authorizationRequestRepository())</span><br><span class="line">                    .authorizationRequestResolver(<span class="keyword">new</span> CustomAuthorizationRequestResolver(</span><br><span class="line">                                clientRegistrationRepository(), <span class="string">"/oauth2/authorization"</span>))</span><br><span class="line">                ...</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> AuthorizationRequestRepository&lt;OAuth2AuthorizationRequest&gt; <span class="title">authorizationRequestRepository</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> HttpSessionOAuth2AuthorizationRequestRepository();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//clientRegistrationId集合</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> List&lt;String&gt; clients = Arrays.asList(<span class="string">"cpdemo-client"</span>);</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> String CLIENT_PROPERTY_KEY = <span class="string">"spring.security.oauth2.client.registration."</span>;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> String CLIENT_PROVIDER_KEY = <span class="string">"spring.security.oauth2.client.provider."</span>;</span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> Environment env;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//@Bean</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> ClientRegistrationRepository <span class="title">clientRegistrationRepository</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="comment">//Steam获取clients对应ClientRegistration，筛掉空值</span></span><br><span class="line">        List&lt;ClientRegistration&gt; registrations = clients.stream()</span><br><span class="line">                .map(c -&gt; getRegistration(c))</span><br><span class="line">                .filter(registration -&gt; registration != <span class="keyword">null</span>)</span><br><span class="line">                .collect(Collectors.toList());</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> InMemoryClientRegistrationRepository(registrations);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">private</span> ClientRegistration <span class="title">getRegistration</span><span class="params">(String client)</span> </span>&#123;</span><br><span class="line">        String clientId = env.getProperty(CLIENT_PROPERTY_KEY + client + <span class="string">".client-id"</span>);</span><br><span class="line">        <span class="keyword">if</span> (clientId == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        String clientSecret = env.getProperty(CLIENT_PROPERTY_KEY + client + <span class="string">".client-secret"</span>);</span><br><span class="line">        <span class="keyword">if</span> (client.equals(<span class="string">"cpdemo-client"</span>)) &#123;</span><br><span class="line">            String provider = <span class="string">"cpdemo"</span>;</span><br><span class="line">            ClientRegistration.Builder builder = ClientRegistration.withRegistrationId(client);</span><br><span class="line">            <span class="keyword">return</span> builder.clientId(clientId)</span><br><span class="line">                    .clientSecret(clientSecret)</span><br><span class="line">                    .clientAuthenticationMethod(ClientAuthenticationMethod.BASIC)</span><br><span class="line">                    .authorizationGrantType(AuthorizationGrantType.AUTHORIZATION_CODE)</span><br><span class="line">                    .redirectUriTemplate(env.getProperty(CLIENT_PROPERTY_KEY + client + <span class="string">".redirect-uri"</span>))</span><br><span class="line">                    .scope(env.getProperty(CLIENT_PROPERTY_KEY + client + <span class="string">".scope"</span>))</span><br><span class="line">                    .authorizationUri(env.getProperty(CLIENT_PROVIDER_KEY + provider + <span class="string">".authorization-uri"</span>))</span><br><span class="line">                    .tokenUri(env.getProperty(CLIENT_PROVIDER_KEY + provider + <span class="string">".token-uri"</span>))</span><br><span class="line">                    .userInfoUri(env.getProperty(CLIENT_PROVIDER_KEY + provider + <span class="string">".user-info-uri"</span>)).build();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>&emsp;&emsp;执行后发现之前的问题解决，但发现授权平台提供的token请求和响应格式与标准不同，需要自定义修改。</p><h4 id="1-3-2-自定义Access-Token-Request和Access-Token-Response"><a href="#1-3-2-自定义Access-Token-Request和Access-Token-Response" class="headerlink" title="1.3.2 自定义Access_Token_Request和Access_Token_Response"></a><strong>1.3.2 自定义Access_Token_Request和Access_Token_Response</strong></h4><p>&emsp;&emsp;首先实现CustomRequestEntityConverter，为token请求增加参数client_id和client_secret。</p><figure class="highlight haxe"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">CustomRequestEntityConverter</span> <span class="title">implements</span></span></span><br><span class="line"><span class="class">        <span class="title">Converter</span>&lt;<span class="title">OAuth2AuthorizationCodeGrantRequest</span>, <span class="title">RequestEntity</span>&lt;?&gt;&gt; </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">String</span> CLIENT_PROPERTY_KEY = <span class="string">"spring.security.oauth2.client.registration.cpdemo-client."</span>;</span><br><span class="line">    <span class="keyword">private</span> Environment env;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> OAuth2AuthorizationCodeGrantRequestEntityConverter defaultConverter;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> CustomRequestEntityConverter(Environment env) &#123;</span><br><span class="line">        defaultConverter = <span class="keyword">new</span> <span class="type">OAuth2AuthorizationCodeGrantRequestEntityConverter</span>();</span><br><span class="line">        <span class="built_in">this</span>.env = env;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//自定以请求参数格式，增加client_id和client_secret</span></span><br><span class="line">    @Override</span><br><span class="line">    <span class="keyword">public</span> RequestEntity&lt;?&gt; convert(OAuth2AuthorizationCodeGrantRequest req) &#123;</span><br><span class="line">        RequestEntity&lt;?&gt; entity = defaultConverter.convert(req);</span><br><span class="line">        MultiValueMap&lt;<span class="keyword">String</span>, <span class="keyword">String</span>&gt; params = (MultiValueMap&lt;<span class="keyword">String</span>,<span class="keyword">String</span>&gt;) entity.getBody();</span><br><span class="line">        params.add(<span class="string">"client_id"</span>, env.getProperty(CLIENT_PROPERTY_KEY + <span class="string">"client-id"</span>));</span><br><span class="line">        params.add(<span class="string">"client_secret"</span>, env.getProperty(CLIENT_PROPERTY_KEY + <span class="string">"client-secret"</span>));</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="type">RequestEntity</span>&lt;&gt;(params, entity.getHeaders(),</span><br><span class="line">                entity.getMethod(), entity.getUrl());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>&emsp;&emsp;然后实现CustomTokenResponseConverter，为token响应配置参数格式。</p><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line">public <span class="class"><span class="keyword">class</span> <span class="title">CustomTokenResponseConverter</span> <span class="keyword">implements</span></span></span><br><span class="line"><span class="class">        <span class="title">Converter</span>&lt;<span class="title">Map</span>&lt;<span class="title">String</span>, <span class="title">String</span>&gt;, <span class="title">OAuth2AccessTokenResponse</span>&gt; </span>&#123;</span><br><span class="line">    private <span class="keyword">static</span> <span class="keyword">final</span> <span class="built_in">Set</span>&lt;<span class="built_in">String</span>&gt; TOKEN_RESPONSE_PARAMETER_NAMES = Stream.of(</span><br><span class="line">            OAuth2ParameterNames.ACCESS_TOKEN,</span><br><span class="line">            OAuth2ParameterNames.TOKEN_TYPE,</span><br><span class="line">            OAuth2ParameterNames.EXPIRES_IN,</span><br><span class="line">            OAuth2ParameterNames.REFRESH_TOKEN,</span><br><span class="line">            OAuth2ParameterNames.SCOPE).collect(Collectors.toSet());</span><br><span class="line"></span><br><span class="line">    <span class="comment">//自定义OAuth2AccessTokenResponse返回参数格式</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    public OAuth2AccessTokenResponse convert(<span class="built_in">Map</span>&lt;<span class="built_in">String</span>, <span class="built_in">String</span>&gt; tokenResponseParameters) &#123;</span><br><span class="line">        <span class="built_in">String</span> accessToken = tokenResponseParameters.<span class="keyword">get</span>(OAuth2ParameterNames.ACCESS_TOKEN);</span><br><span class="line"></span><br><span class="line">        long expiresIn = Long.valueOf(tokenResponseParameters.<span class="keyword">get</span>(OAuth2ParameterNames.EXPIRES_IN));</span><br><span class="line">        OAuth2AccessToken.TokenType accessTokenType = OAuth2AccessToken.TokenType.BEARER;</span><br><span class="line"></span><br><span class="line">        <span class="built_in">Set</span>&lt;<span class="built_in">String</span>&gt; scopes = Collections.emptySet();</span><br><span class="line">        <span class="keyword">if</span> (tokenResponseParameters.containsKey(OAuth2ParameterNames.SCOPE)) &#123;</span><br><span class="line">            <span class="built_in">String</span> scope = tokenResponseParameters.<span class="keyword">get</span>(OAuth2ParameterNames.SCOPE);</span><br><span class="line">            scopes = Arrays.stream(StringUtils.delimitedListToStringArray(scope, <span class="string">","</span>))</span><br><span class="line">                    .collect(Collectors.toSet());</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//...</span></span><br><span class="line">        <span class="keyword">return</span> OAuth2AccessTokenResponse.withToken(accessToken)</span><br><span class="line">                .tokenType(accessTokenType)</span><br><span class="line">                .expiresIn(expiresIn)</span><br><span class="line">                .scopes(scopes)</span><br><span class="line"><span class="comment">//                .refreshToken(refreshToken)</span></span><br><span class="line"><span class="comment">//                .additionalParameters(additionalParameters)</span></span><br><span class="line">                .build();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>&emsp;&emsp;最后修改SecurityConfig，增加token端点配置。</p><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@EnableWebSecurity</span></span><br><span class="line">public <span class="class"><span class="keyword">class</span> <span class="title">SecurityConfig</span> <span class="keyword">extends</span> <span class="title">WebSecurityConfigurerAdapter</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">protected</span> void configure(<span class="type">HttpSecurity</span> http) <span class="keyword">throws</span> <span class="type">Exception</span> &#123;</span><br><span class="line">        http.oauth2Login()</span><br><span class="line">                .authorizationEndpoint()</span><br><span class="line">                    .authorizationRequestRepository(authorizationRequestRepository())</span><br><span class="line">                    .authorizationRequestResolver(<span class="keyword">new</span> <span class="type">CustomAuthorizationRequestResolver</span>(</span><br><span class="line">                                clientRegistrationRepository(), <span class="string">"/oauth2/authorization"</span>))</span><br><span class="line">                    .and()</span><br><span class="line">                .tokenEndpoint()</span><br><span class="line">                    .accessTokenResponseClient(accessTokenResponseClient())</span><br><span class="line">                ...</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">//通过自定义OAuth2AccessTokenResponseClient来自定义token请求</span></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    public <span class="type">OAuth2AccessTokenResponseClient</span>&lt;<span class="type">OAuth2AuthorizationCodeGrantRequest</span>&gt; accessTokenResponseClient()&#123;</span><br><span class="line">        <span class="type">DefaultAuthorizationCodeTokenResponseClient</span> accessTokenResponseClient =</span><br><span class="line">                <span class="keyword">new</span> <span class="type">DefaultAuthorizationCodeTokenResponseClient</span>();</span><br><span class="line">        <span class="comment">//自定义req</span></span><br><span class="line">        accessTokenResponseClient.setRequestEntityConverter(<span class="keyword">new</span> <span class="type">CustomRequestEntityConverter</span>(env));</span><br><span class="line"></span><br><span class="line">        <span class="comment">//启用OAuth2AccessTokenResponseHttpMessageConverter来转换HTTP消息，获取OAuth2AccessTokenResponse</span></span><br><span class="line">        <span class="type">OAuth2AccessTokenResponseHttpMessageConverter</span> tokenResponseHttpMessageConverter =</span><br><span class="line">                <span class="keyword">new</span> <span class="type">OAuth2AccessTokenResponseHttpMessageConverter</span>();</span><br><span class="line"></span><br><span class="line">        <span class="comment">//自定义rep</span></span><br><span class="line">        tokenResponseHttpMessageConverter.setTokenResponseConverter(<span class="keyword">new</span> <span class="type">CustomTokenResponseConverter</span>());</span><br><span class="line">        </span><br><span class="line">        <span class="comment">//为Rest Http工具配置适用的HttpMessageConverter</span></span><br><span class="line">        <span class="type">RestTemplate</span> restTemplate = <span class="keyword">new</span> <span class="type">RestTemplate</span>(<span class="type">Arrays</span>.asList(</span><br><span class="line">                <span class="keyword">new</span> <span class="type">FormHttpMessageConverter</span>(), tokenResponseHttpMessageConverter));</span><br><span class="line">        restTemplate.setErrorHandler(<span class="keyword">new</span> <span class="type">OAuth2ErrorResponseErrorHandler</span>());</span><br><span class="line">        accessTokenResponseClient.setRestOperations(restTemplate);</span><br><span class="line">        <span class="keyword">return</span> accessTokenResponseClient;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>&emsp;&emsp;执行后发现之前的问题解决，但获取用户信息的响应格式需要自定义。</p><h4 id="1-3-3-自定义User-Info-Response"><a href="#1-3-3-自定义User-Info-Response" class="headerlink" title="1.3.3 自定义User_Info_Response"></a><strong>1.3.3 自定义User_Info_Response</strong></h4><p>&emsp;&emsp;创建CustomOAuth2User，对应user-info响应消息格式。</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Data</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">CustomOAuth2User</span> <span class="title">implements</span> <span class="title">OAuth2User</span> </span>&#123;</span><br><span class="line">    <span class="meta">@JsonIgnore</span></span><br><span class="line">    <span class="keyword">private</span> List&lt;GrantedAuthority&gt; authorities =</span><br><span class="line">            AuthorityUtils.createAuthorityList(<span class="string">"ROLE_USER"</span>);</span><br><span class="line">    <span class="meta">@JsonIgnore</span></span><br><span class="line">    <span class="keyword">private</span> Map&lt;String, Object&gt; attributes;</span><br><span class="line">    <span class="meta">@NonNull</span></span><br><span class="line">    <span class="meta">@JsonProperty(required = true,value = <span class="meta-string">"campus_user_id"</span>)</span></span><br><span class="line">    <span class="keyword">private</span> String id;</span><br><span class="line">    <span class="meta">@NonNull</span></span><br><span class="line">    <span class="meta">@JsonProperty(required = true,value = <span class="meta-string">"campus_id"</span>)</span></span><br><span class="line">    <span class="keyword">private</span> String userId;</span><br><span class="line">    <span class="meta">@JsonProperty(required = true,value = <span class="meta-string">"tenant_code"</span>)</span></span><br><span class="line">    <span class="keyword">private</span> String tenantCode;</span><br><span class="line">    <span class="meta">@NonNull</span></span><br><span class="line">    <span class="meta">@JsonProperty(required = true,value = <span class="meta-string">"user_name"</span>)</span></span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line">    <span class="meta">@JsonProperty(required = true,value = <span class="meta-string">"user_type"</span>)</span></span><br><span class="line">    <span class="keyword">private</span> String type;</span><br><span class="line">    <span class="meta">@JsonProperty(required = true,value = <span class="meta-string">"gender"</span>)</span></span><br><span class="line">    <span class="keyword">private</span> String gender;</span><br><span class="line">    ...</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> Collection&lt;? extends GrantedAuthority&gt; getAuthorities() &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">this</span>.authorities;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> String getName() &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">this</span>.name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> Map&lt;String, Object&gt; getAttributes() &#123;</span><br><span class="line">        <span class="keyword">if</span> (<span class="keyword">this</span>.attributes == <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="keyword">this</span>.attributes = new HashMap&lt;&gt;();</span><br><span class="line">            <span class="keyword">this</span>.attributes.put(<span class="string">"id"</span>, <span class="keyword">this</span>.id);</span><br><span class="line">            <span class="keyword">this</span>.attributes.put(<span class="string">"userId"</span>, <span class="keyword">this</span>.userId);</span><br><span class="line">            <span class="keyword">this</span>.attributes.put(<span class="string">"tenantCode"</span>, <span class="keyword">this</span>.tenantCode);</span><br><span class="line">            <span class="keyword">this</span>.attributes.put(<span class="string">"name"</span>, <span class="keyword">this</span>.name);</span><br><span class="line">            <span class="keyword">this</span>.attributes.put(<span class="string">"type"</span>, <span class="keyword">this</span>.type);</span><br><span class="line">            <span class="keyword">this</span>.attributes.put(<span class="string">"gender"</span>, <span class="keyword">this</span>.gender);</span><br><span class="line">            ...</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> attributes;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>&emsp;&emsp;修改SecurityConfig，增加customUserType配置。</p><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@EnableWebSecurity</span></span><br><span class="line">public <span class="class"><span class="keyword">class</span> <span class="title">SecurityConfig</span> <span class="keyword">extends</span> <span class="title">WebSecurityConfigurerAdapter</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">protected</span> void configure(<span class="type">HttpSecurity</span> http) <span class="keyword">throws</span> <span class="type">Exception</span> &#123;</span><br><span class="line">        http.oauth2Login()</span><br><span class="line">                .authorizationEndpoint()</span><br><span class="line">                    .authorizationRequestRepository(authorizationRequestRepository())</span><br><span class="line">                    .authorizationRequestResolver(<span class="keyword">new</span> <span class="type">CustomAuthorizationRequestResolver</span>(</span><br><span class="line">                                clientRegistrationRepository(), <span class="string">"/oauth2/authorization"</span>))</span><br><span class="line">                    .and()</span><br><span class="line">                .tokenEndpoint()</span><br><span class="line">                    .accessTokenResponseClient(accessTokenResponseClient())</span><br><span class="line">                    .and()</span><br><span class="line">                .userInfoEndpoint()</span><br><span class="line">                    .customUserType(<span class="type">CustomOAuth2User</span>.<span class="keyword">class</span>,<span class="string">"cpdemo-client"</span>);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>&emsp;&emsp;执行后发现get user info流程报错，如下，user-info的响应编码格式为octet-stream，但默认的转换器不支持。</p><figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="literal">no</span> suitable HttpMessageConverter found <span class="keyword">for</span> response<span class="built_in"> type </span>[XXX] <span class="keyword">and</span> content<span class="built_in"> type </span>[application/octet-stream]</span><br></pre></td></tr></table></figure><h4 id="1-3-4-自定义User-Info-Request"><a href="#1-3-4-自定义User-Info-Request" class="headerlink" title="1.3.4 自定义User_Info_Request"></a><strong>1.3.4 自定义User_Info_Request</strong></h4><p>&emsp;&emsp;自定义OAuth2UserService，为RestTemplate配置支持OCTET_STREAM（CustomOAuth2UserRequestEntityConverter此时还为OAuth2UserRequestEntityConverter）</p><figure class="highlight haxe"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">CustomUserService</span> <span class="keyword"><span class="keyword">implements</span> <span class="type">OAuth2UserService</span></span>&lt;<span class="title">OAuth2UserRequest</span>, <span class="title">OAuth2User</span>&gt; </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> final Map&lt;<span class="keyword">String</span>, Class&lt;? extends OAuth2User&gt;&gt; customUserTypes;</span><br><span class="line">    <span class="keyword">private</span> Converter&lt;OAuth2UserRequest, RequestEntity&lt;?&gt;&gt; requestEntityConverter = <span class="keyword">new</span> <span class="type">CustomOAuth2UserRequestEntityConverter</span>();</span><br><span class="line">    <span class="keyword">private</span> RestOperations restOperations;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> CustomUserService(Map&lt;<span class="keyword">String</span>, Class&lt;? extends OAuth2User&gt;&gt; customUserTypes) &#123;</span><br><span class="line">        Assert.notEmpty(customUserTypes, <span class="string">"customUserTypes cannot be empty"</span>);</span><br><span class="line">        <span class="built_in">this</span>.customUserTypes = Collections.unmodifiableMap(<span class="keyword">new</span> <span class="type">LinkedHashMap</span>(customUserTypes));</span><br><span class="line">        <span class="comment">//打印RestTemplate的Http请求日志</span></span><br><span class="line">        RestTemplate restTemplate = <span class="keyword">new</span> <span class="type">RestTemplate</span>(<span class="keyword">new</span> <span class="type">BufferingClientHttpRequestFactory</span>(<span class="keyword">new</span> <span class="type">SimpleClientHttpRequestFactory</span>()));</span><br><span class="line">        List&lt;ClientHttpRequestInterceptor&gt; interceptors = <span class="keyword">new</span> <span class="type">ArrayList</span>&lt;&gt;();</span><br><span class="line">        interceptors.add(<span class="keyword">new</span> <span class="type">LoggingRequestInterceptor</span>());</span><br><span class="line">        restTemplate.setInterceptors(interceptors);</span><br><span class="line">        <span class="comment">//解决no suitable HttpMessageConverter found for response type [CustomOAuth2User] and content type [application/octet-stream]</span></span><br><span class="line">        MappingJackson2HttpMessageConverter converter = <span class="keyword">new</span> <span class="type">MappingJackson2HttpMessageConverter</span>();</span><br><span class="line">        converter.setSupportedMediaTypes(Arrays.asList(<span class="keyword">new</span> <span class="type">MediaType</span>[]&#123;MediaType.APPLICATION_JSON, MediaType.APPLICATION_OCTET_STREAM&#125;));</span><br><span class="line">        restTemplate.setMessageConverters(Arrays.asList(converter, <span class="keyword">new</span> <span class="type">FormHttpMessageConverter</span>()));</span><br><span class="line">        <span class="built_in">this</span>.restOperations = restTemplate;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    <span class="keyword">public</span> OAuth2User loadUser(OAuth2UserRequest userRequest) throws OAuth2AuthenticationException &#123;</span><br><span class="line">        Assert.notNull(userRequest, <span class="string">"userRequest cannot be null"</span>);</span><br><span class="line">        <span class="keyword">String</span> registrationId = userRequest.getClientRegistration().getRegistrationId();</span><br><span class="line">        Class customUserType;</span><br><span class="line">        <span class="keyword">if</span> ((customUserType = (Class)<span class="built_in">this</span>.customUserTypes.<span class="keyword">get</span>(registrationId)) == <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">//添加参数</span></span><br><span class="line">            System.out.println(<span class="string">"此时access token ："</span> + userRequest.getAccessToken().getTokenValue());</span><br><span class="line">            System.out.println(<span class="string">"此时AdditionalParameters ："</span> + userRequest.getAdditionalParameters().toString());</span><br><span class="line"></span><br><span class="line">            RequestEntity request = (RequestEntity)<span class="built_in">this</span>.requestEntityConverter.convert(userRequest);</span><br><span class="line"></span><br><span class="line">            ResponseEntity response;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                response = <span class="built_in">this</span>.restOperations.exchange(request, customUserType);</span><br><span class="line">            &#125; <span class="keyword">catch</span> (RestClientException var8) &#123;</span><br><span class="line">                OAuth2Error oauth2Error = <span class="keyword">new</span> <span class="type">OAuth2Error</span>(<span class="string">"invalid_user_info_response"</span>, <span class="string">"An error occurred while attempting to retrieve the UserInfo Resource: "</span> + var8.getMessage(), (<span class="keyword">String</span>)<span class="literal">null</span>);</span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> <span class="type">OAuth2AuthenticationException</span>(oauth2Error, oauth2Error.toString(), var8);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            OAuth2User oauth2User = (OAuth2User)response.getBody();</span><br><span class="line">            <span class="keyword">return</span> oauth2User;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> final void setRequestEntityConverter(Converter&lt;OAuth2UserRequest, RequestEntity&lt;?&gt;&gt; requestEntityConverter) &#123;</span><br><span class="line">        Assert.notNull(requestEntityConverter, <span class="string">"requestEntityConverter cannot be null"</span>);</span><br><span class="line">        <span class="built_in">this</span>.requestEntityConverter = requestEntityConverter;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> final void setRestOperations(RestOperations restOperations) &#123;</span><br><span class="line">        Assert.notNull(restOperations, <span class="string">"restOperations cannot be null"</span>);</span><br><span class="line">        <span class="built_in">this</span>.restOperations = restOperations;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>&emsp;&emsp;通过实现ClientHttpRequestInterceptor接口来对RestTemplate打印日志。</p><figure class="highlight processing"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> class LoggingRequestInterceptor implements ClientHttpRequestInterceptor &#123;</span><br><span class="line">    <span class="keyword">final</span> <span class="keyword">static</span> Logger <span class="built_in">log</span> = LoggerFactory.getLogger(LoggingRequestInterceptor.class);</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    <span class="keyword">public</span> ClientHttpResponse intercept(HttpRequest httpRequest, <span class="built_in">byte</span>[] bytes, ClientHttpRequestExecution clientHttpRequestExecution)<span class="keyword">throws</span> UnsupportedEncodingException,IOException &#123;</span><br><span class="line">        traceRequest(httpRequest,bytes);</span><br><span class="line">        ClientHttpResponse response = clientHttpRequestExecution.execute(httpRequest,bytes);</span><br><span class="line">        traceResponse(response);</span><br><span class="line">        <span class="keyword">return</span> response;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">void</span> traceRequest(HttpRequest httpRequest, <span class="built_in">byte</span>[] bytes)<span class="keyword">throws</span> UnsupportedEncodingException &#123;</span><br><span class="line">        <span class="built_in">log</span>.info(<span class="string">"=============================request begin=============================="</span>);</span><br><span class="line">        <span class="built_in">log</span>.debug(<span class="string">"URI            : &#123;&#125;"</span>,httpRequest.getURI());</span><br><span class="line">        <span class="built_in">log</span>.debug(<span class="string">"Method         : &#123;&#125;"</span>,httpRequest.getMethod());</span><br><span class="line">        <span class="built_in">log</span>.debug(<span class="string">"Headers        : &#123;&#125;"</span>,httpRequest.getHeaders());</span><br><span class="line">        <span class="built_in">log</span>.debug(<span class="string">"Body           : &#123;&#125;"</span>,<span class="keyword">new</span> <span class="keyword">String</span>(bytes,<span class="string">"UTF-8"</span>));</span><br><span class="line">        <span class="built_in">log</span>.info(<span class="string">"=============================request end=============================="</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">void</span> traceResponse(ClientHttpResponse response)<span class="keyword">throws</span> IOException &#123;</span><br><span class="line">        StringBuilder inputStringBuilder = <span class="keyword">new</span> StringBuilder();</span><br><span class="line">        <span class="keyword">BufferedReader</span> reader = <span class="keyword">new</span> <span class="keyword">BufferedReader</span>(<span class="keyword">new</span> InputStreamReader(response.getBody(),<span class="string">"UTF-8"</span>));</span><br><span class="line">        <span class="keyword">String</span> <span class="built_in">line</span> = reader.readLine();</span><br><span class="line">        <span class="keyword">while</span> (<span class="built_in">line</span> != <span class="keyword">null</span>)&#123;</span><br><span class="line">            inputStringBuilder.<span class="built_in">append</span>(<span class="built_in">line</span>);</span><br><span class="line">            inputStringBuilder.<span class="built_in">append</span>(<span class="string">'\n'</span>);</span><br><span class="line">            <span class="built_in">line</span> = reader.readLine();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">log</span>.info(<span class="string">"=============================response begin=============================="</span>);</span><br><span class="line">        <span class="built_in">log</span>.debug(<span class="string">"StatusCode     : &#123;&#125;"</span>,response.getStatusCode());</span><br><span class="line">        <span class="built_in">log</span>.debug(<span class="string">"StatusText     : &#123;&#125;"</span>,response.getStatusText());</span><br><span class="line">        <span class="built_in">log</span>.debug(<span class="string">"Headers        : &#123;&#125;"</span>,response.getHeaders());</span><br><span class="line">        <span class="built_in">log</span>.debug(<span class="string">"Body           : &#123;&#125;"</span>,inputStringBuilder.toString());</span><br><span class="line">        <span class="built_in">log</span>.info(<span class="string">"=============================response end=============================="</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>&emsp;&emsp;修改SecurityConfig，增加userService配置。</p><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@EnableWebSecurity</span></span><br><span class="line">public <span class="class"><span class="keyword">class</span> <span class="title">SecurityConfig</span> <span class="keyword">extends</span> <span class="title">WebSecurityConfigurerAdapter</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">protected</span> void configure(<span class="type">HttpSecurity</span> http) <span class="keyword">throws</span> <span class="type">Exception</span> &#123;</span><br><span class="line">        http.authorizeRequests()</span><br><span class="line">                .antMatchers(<span class="string">"/"</span>,<span class="string">"/home"</span>, <span class="string">"/login**"</span>,<span class="string">"/callback/"</span>, <span class="string">"/webjars/**"</span>, <span class="string">"/error**"</span>, <span class="string">"/oauth2/authorization/**"</span>)</span><br><span class="line">                .permitAll()</span><br><span class="line">                .anyRequest()</span><br><span class="line">                .authenticated();</span><br><span class="line"></span><br><span class="line">        <span class="type">Map</span>&lt;<span class="type">String</span>,<span class="type">Class</span>&lt;? <span class="keyword">extends</span> <span class="type">OAuth2User</span>&gt;&gt; customUserTypes = <span class="keyword">new</span> <span class="type">HashMap</span>&lt;&gt;();</span><br><span class="line">        customUserTypes.put(<span class="string">"cpdemo-client"</span>,<span class="type">CustomOAuth2User</span>.<span class="keyword">class</span>);</span><br><span class="line"></span><br><span class="line">        http.oauth2Login()</span><br><span class="line">                .authorizationEndpoint()</span><br><span class="line">                    .authorizationRequestRepository(authorizationRequestRepository())</span><br><span class="line">                    .authorizationRequestResolver(<span class="keyword">new</span> <span class="type">CustomAuthorizationRequestResolver</span>(</span><br><span class="line">                                clientRegistrationRepository(), <span class="string">"/oauth2/authorization"</span>))</span><br><span class="line">                    .and()</span><br><span class="line">                .tokenEndpoint()</span><br><span class="line">                    .accessTokenResponseClient(accessTokenResponseClient())</span><br><span class="line">                    .and()</span><br><span class="line">                .userInfoEndpoint()</span><br><span class="line">                    .userService(<span class="keyword">new</span> <span class="type">CustomUserService</span>(customUserTypes))</span><br><span class="line">                    .customUserType(<span class="type">CustomOAuth2User</span>.<span class="keyword">class</span>,<span class="string">"cpdemo-client"</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    public <span class="type">AuthorizationRequestRepository</span>&lt;<span class="type">OAuth2AuthorizationRequest</span>&gt; authorizationRequestRepository() &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="type">HttpSessionOAuth2AuthorizationRequestRepository</span>();</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>&emsp;&emsp;执行后发现提示请求Token时未提供所需参数，根据接口文档发现授权服务器要求把授权令牌写入Get_Parm，查看源码可以发现默认Converter会根据请求类别把授权令牌放入HEADER或FORM_PARM。</p><p>&emsp;&emsp;自定义转换器CustomOAuth2UserRequestEntityConverter，强行将access_token拼入URL。</p><figure class="highlight haxe"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">CustomOAuth2UserRequestEntityConverter</span> <span class="keyword"><span class="keyword">implements</span> <span class="type">Converter</span></span>&lt;<span class="title">OAuth2UserRequest</span>, <span class="title">RequestEntity</span>&lt;?&gt;&gt; </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> final MediaType DEFAULT_CONTENT_TYPE = MediaType.valueOf(<span class="string">"application/x-www-form-urlencoded;charset=UTF-8"</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> CustomOAuth2UserRequestEntityConverter() &#123;</span><br><span class="line">    &#125;</span><br><span class="line">    @Override</span><br><span class="line">    <span class="keyword">public</span> RequestEntity&lt;?&gt; convert(OAuth2UserRequest userRequest) &#123;</span><br><span class="line">        ClientRegistration clientRegistration = userRequest.getClientRegistration();</span><br><span class="line">        HttpMethod httpMethod = HttpMethod.GET;</span><br><span class="line">        <span class="keyword">if</span> (AuthenticationMethod.FORM.equals(clientRegistration.getProviderDetails().getUserInfoEndpoint().getAuthenticationMethod())) &#123;</span><br><span class="line">            httpMethod = HttpMethod.POST;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        HttpHeaders headers = <span class="keyword">new</span> <span class="type">HttpHeaders</span>();</span><br><span class="line">        headers.setAccept(Collections.singletonList(MediaType.APPLICATION_JSON));</span><br><span class="line"><span class="comment">//        URI uri = UriComponentsBuilder.fromUriString(clientRegistration.getProviderDetails().getUserInfoEndpoint().getUri()).build().toUri();</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">//强行拼接</span></span><br><span class="line">        URI uri = UriComponentsBuilder.fromUriString(clientRegistration.getProviderDetails().getUserInfoEndpoint().getUri()</span><br><span class="line">                + <span class="string">"?access_token="</span> + userRequest.getAccessToken().getTokenValue()).build().toUri();</span><br><span class="line"></span><br><span class="line">        RequestEntity request;</span><br><span class="line">        <span class="keyword">if</span> (HttpMethod.POST.equals(httpMethod)) &#123;</span><br><span class="line">            headers.setContentType(DEFAULT_CONTENT_TYPE);</span><br><span class="line">            MultiValueMap&lt;<span class="keyword">String</span>, <span class="keyword">String</span>&gt; formParameters = <span class="keyword">new</span> <span class="type">LinkedMultiValueMap</span>();</span><br><span class="line">            formParameters.add(<span class="string">"access_token"</span>, userRequest.getAccessToken().getTokenValue());</span><br><span class="line">            request = <span class="keyword">new</span> <span class="type">RequestEntity</span>(formParameters, headers, httpMethod, uri);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            headers.setBearerAuth(userRequest.getAccessToken().getTokenValue());</span><br><span class="line">            request = <span class="keyword">new</span> <span class="type">RequestEntity</span>(headers, httpMethod, uri);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> request;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>&emsp;&emsp;执行后发现问题解决，流程跑通。</p><hr><p><em>参考博客和文章书籍等：</em></p><blockquote><p><a href="https://github.com/spring-projects/spring-security/wiki/OAuth-2.0-Migration-Guide" title="Title" target="_blank" rel="noopener">OAuth-2.0-Migration-Guide</a></p></blockquote><blockquote><p><a href="https://projects.spring.io/spring-security-oauth/docs/Home.html" title="Title" target="_blank" rel="noopener">spring-security-oauth</a></p></blockquote><blockquote><p><a href="https://mrbird.cc/Spring-Security-OAuth2-Guide.html" title="Title" target="_blank" rel="noopener">Spring Security OAuth2入门</a></p></blockquote><blockquote><p><a href="https://www.jianshu.com/p/cb886f995e86?utm_source=oschina-app" title="Title" target="_blank" rel="noopener">深入理解Spring Cloud Security OAuth2及JWT</a></p></blockquote><blockquote><p><a href="https://zhuanlan.zhihu.com/p/74267287" title="Title" target="_blank" rel="noopener">OAuth2实现单点登录SSO</a></p></blockquote><blockquote><p><a href="https://docs.spring.io/spring-security/site/docs/current/reference/html/webclient.html" title="Title" target="_blank" rel="noopener">Spring文档-26. WebClient</a></p></blockquote><blockquote><p><a href="https://docs.spring.io/spring-security/site/docs/5.0.7.RELEASE/reference/html/oauth2login-advanced.html#oauth2login-advanced-userinfo-endpoint" title="Title" target="_blank" rel="noopener">Spring文档-31.OAuth 2.0 Login</a></p></blockquote><blockquote><p><a href="https://www.ziyueknow.com/page/spring-security/part06-3.html#oauth2login-advanced-userinfo-endpoint" title="Title" target="_blank" rel="noopener">Spring文档中文翻译</a></p></blockquote><blockquote><p><a href="https://www.cnblogs.com/cjsblog/p/9241217.html" title="Title" target="_blank" rel="noopener">Spring Boot OAuth 2.0 客户端</a></p></blockquote><blockquote><p><a href="https://www.baeldung.com/spring-webclient-oauth2" title="Title" target="_blank" rel="noopener">baeldung：Spring WebClient and OAuth2 Support</a></p></blockquote><blockquote><p><a href="https://www.baeldung.com/spring-security-custom-oauth-requests" title="Title" target="_blank" rel="noopener">baeldung：Customizing Authorization and Token Requests with Spring Security 5.1 Client</a></p></blockquote><blockquote><p><a href="https://github.com/eugenp/tutorials/tree/master/spring-5-security-oauth" title="Title" target="_blank" rel="noopener">github：spring-5-security-oauth</a></p></blockquote><blockquote><p><a href="https://github.com/jgrandja/spring-security-oauth-5-2-migrate" title="Title" target="_blank" rel="noopener">github：spring-security-oauth-5-2-migrate</a></p></blockquote><blockquote><p><a href="https://objectpartners.com/2018/03/01/log-your-resttemplate-request-and-response-without-destroying-the-body/" title="Title" target="_blank" rel="noopener">Log your RestTemplate Request and Response without destroying the body</a></p></blockquote><blockquote><p><a href="https://dzone.com/articles/spring-boot-how-to-solve-oauth2-err-too-many-redir" title="Title" target="_blank" rel="noopener">Spring Boot: Solving OAuth2 ERR_TOO_MANY_REDIRECTS [Snippet]</a></p></blockquote><blockquote><p><a href="https://stackoverflow.com/questions/57761917/spring-5-security-oauth2-login-redirect-loop" title="Title" target="_blank" rel="noopener">stackoverflow：Spring 5 Security OAuth2 Login Redirect Loop</a></p></blockquote><blockquote><p><a href="https://stackoverflow.com/questions/49315552/authorizationgranttype-cannot-be-null-in-spring-security-5-oauth-client-and-spri" title="Title" target="_blank" rel="noopener">stackoverflow：authorizationGrantType cannot be null in Spring Security 5 OAuth Client and Spring Boot 2.0</a></p></blockquote><blockquote><p><a href="https://stackoverflow.com/questions/49062866/spring-boot-resttemplate-response-body-is-null-while-interceptor-clearly-shows-b" title="Title" target="_blank" rel="noopener">stackoverflow：Spring-boot Resttemplate response.body is null while interceptor clearly shows body</a></p></blockquote><blockquote><p><a href="https://stackoverflow.com/questions/50908023/using-spring-security-oauth-using-a-custom-oauth-provider-i-get-authorization" title="Title" target="_blank" rel="noopener">stackoverflow：Using Spring security oauth, using a custom OAuth provider, I get [authorization_request_not_found], should I handle the callback method myself?</a><br>y-shows-b “Title”)</p></blockquote><blockquote><p><a href="https://stackoverflow.com/questions/7952154/spring-resttemplate-how-to-enable-full-debugging-logging-of-requests-responses" title="Title" target="_blank" rel="noopener">stackoverflow：Spring RestTemplate - how to enable full debugging/logging of requests/responses?</a></p></blockquote><p><em>因博客主等未标明不可引用，若部分内容涉及侵权请及时告知，我会尽快修改和删除相关内容</em></p>]]></content>
    
    <summary type="html">
    
      Spring Security OAuth2实战练习，内容包括：等。
    
    </summary>
    
      <category term="技术文档" scheme="http://linyishui.top/categories/%E6%8A%80%E6%9C%AF%E6%96%87%E6%A1%A3/"/>
    
    
      <category term="spring boot" scheme="http://linyishui.top/tags/spring-boot/"/>
    
      <category term="unfinished" scheme="http://linyishui.top/tags/unfinished/"/>
    
      <category term="oauth2" scheme="http://linyishui.top/tags/oauth2/"/>
    
      <category term="spring security" scheme="http://linyishui.top/tags/spring-security/"/>
    
  </entry>
  
  <entry>
    <title>OAuth2协议框架</title>
    <link href="http://linyishui.top/2019111601.html"/>
    <id>http://linyishui.top/2019111601.html</id>
    <published>2019-11-16T10:30:59.000Z</published>
    <updated>2019-12-25T06:30:59.939Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="OAuth2"><a href="#OAuth2" class="headerlink" title="OAuth2"></a><strong>OAuth2</strong></h1><h2 id="第一节-引文"><a href="#第一节-引文" class="headerlink" title="第一节 引文"></a><strong>第一节 引文</strong></h2><p>&emsp;&emsp;随着分布式Web服务和云计算的流行，一些第三方应用常常要访问一些服务器托管资源。这些资源通常都是受保护的，需要请求者携带资源拥有者允许的私有证书进行身份验证。</p><p>&emsp;&emsp;在传统的基于客户端-服务器的身份验证模型中，客户端为了访问服务器的受保护资源，通过私有证书来做身份验证。而现在这个私有证书往往要同时提供给第三方，这就带来了很多的问题，也存在着很多的局限性。</p><blockquote><p><strong>传统身份验证模型的问题：</strong></p><ul><li>第三方应用需要用明文保存私有证书，以便持续的使用，这种对称的密码验证方式会带来安全隐患。</li><li>第三方应用对受保护资源获得了过多的使用权限，但资源拥有者却没办法来限制到具体的资源子集，比如限制权限的时间，或是限制支持的访问方式等。</li><li>资源拥有者无法在不影响第三方应用的前提下撤销某个第三方的访问权限，只能通过修改密码的方法来回收权限。</li></ul></blockquote><p>&emsp;&emsp;OAuth通过将客户端和资源拥有者的<strong>角色分离</strong>来解决这些问题，在OAuth中，客户端提出请求访问由资源拥有者控制，并由资源服务器托管的资源，然后会得到与资源拥有者不同的一套私有证书。客户端不会像以前那样直接使用资源拥有者的证书来访问，而是得到了一个<strong>访问令牌</strong>（access token）：一个代表着某一特定作用域、持续时间和其它属性的字符串。</p><p>&emsp;&emsp;访问令牌由<strong>授权服务器</strong>在资源拥有者的授意下分发给第三方客户端，客户端携带访问令牌访问由<strong>资源服务器</strong>托管的受保护资源。</p><h3 id="1-1-符号规范"><a href="#1-1-符号规范" class="headerlink" title="1.1 符号规范"></a><strong>1.1 符号规范</strong></h3><p>&emsp;&emsp;这篇文档中的关键词“必须”、“一定不能”、“要求”、“会”、“不会”、“应该”、“不应该”、“建议”、“可以”、“可选的”，遵从<a href="https://tools.ietf.org/id/draft-ietf-oauth-v2-11.html#RFC2119" title="Title" target="_blank" rel="noopener">[RFC2119]</a>中的解释。</p><p>&emsp;&emsp;这篇文档使用出自<a href="https://tools.ietf.org/id/draft-ietf-oauth-v2-11.html#I-D.ietf-httpbis-p1-messaging" title="Title" target="_blank" rel="noopener">[I-D.ietf-httpbis-p1-messaging]</a>的增强型巴科斯范式（ABNF）标记法。另外，介绍一些规则定义的出处：URI-Reference出自<a href="https://tools.ietf.org/id/draft-ietf-oauth-v2-11.html#RFC3986" title="Title" target="_blank" rel="noopener">[RFC3986]</a>；OWS、RWS和quoted-string出自<a href="https://tools.ietf.org/id/draft-ietf-oauth-v2-11.html#I-D.ietf-httpbis-p1-messaging" title="Title" target="_blank" rel="noopener">[I-D.ietf-httpbis-p1-messaging]</a>。</p><p>&emsp;&emsp;除非特别提到，否则所有协议参数的名字和值都是大小写敏感的。</p><h3 id="1-2-技术术语"><a href="#1-2-技术术语" class="headerlink" title="1.2 技术术语"></a><strong>1.2 技术术语</strong></h3><blockquote><ul><li>受保护资源（protected resource）：能够使用OAuth请求获取的访问限制性资源。</li><li>资源服务器（resource server）：能够接受和响应受保护资源请求的服务器。</li><li>客户端（client）：获取授权和发送受保护资源请求的应用。</li><li>资源拥有者（resource owner）：能够对受保护资源进行访问许可控制的实体。</li><li>终端用户（end-user）：起到资源拥有者角色的用户。</li><li>令牌（token）：分发给客户端的代表访问授权的字符串。通常这个字符串对客户端来说是不透明的。令牌代表资源拥有者许可的访问作用域和持续时间，并由资源服务器和授权服务器强制保证。这个令牌可以代表一个标识符，用于检索授权信息，或以一种可验证的方式自包含授权信息（即一个包含数据和签名的令牌字符串）。令牌可能只代表纯粹的访问能力。而为了让客户端使用令牌，也可能需要一些多余的特定验证证书。</li><li>访问令牌（access token）：被客户端用来代表资源拥有者发送验证请求的令牌。</li><li>刷新令牌（refresh token）：被客户端用来获取新的访问令牌的令牌，而不用资源拥有者的参与。</li><li>授权码（authorization code）：一个短期令牌，代表终端用户的授权。授权码用于获取一个访问令牌和一个刷新令牌。</li><li>访问许可（access grant）：用于描述中间形式的私有证书（如终端用户的密码或授权码）的一个通用词汇，代表资源拥有者的授权。客户端使用访问许可来获取访问令牌。通过将各种形式的访问许可都交换成访问令牌，资源服务器只需要支持一种验证机制。</li><li>授权服务器（authorization server）：能够成功验证资源拥有者和获取授权，并在此之后分发令牌的服务器。授权服务器可以和资源服务器是同一个服务器，也可以是不同的实体。单独一个授权服务器可以为多个资源服务器分发令牌。</li><li>终端用户授权端点（end-user authorization endpoint）：授权服务器上能够验证终端用户并获取授权的HTTP endpoint。终端用户授权endpoint在第4节详细描述。</li><li>令牌端点（token endpoint）：授权服务器上能够分发令牌和刷新过期令牌的HTTP endpoint。令牌endpoint在第5节详细描述。</li><li>客户端标识符（client identifier）：分发给客户端的唯一标识，用于客户端向授权服务器标识自己。客户端标识符可以有一个对应的密钥。客户端标识符在第3节详细描述。</li></ul></blockquote><h3 id="1-3-概述"><a href="#1-3-概述" class="headerlink" title="1.3 概述"></a><strong>1.3 概述</strong></h3><p>&emsp;&emsp;OAuth为客户端提供了一种代表资源拥有者访问受保护资源的方法。在客户端访问受保护资源之前，它必须先从资源拥有者获取授权 （访问许可，access grant），然后用访问许可交换访问令牌（access token，代表许可的作用域、持续时间和其它属性）。客户端通过向资源服务器出示访问令牌来访问受保护资源。</p><p>&emsp;&emsp;访问令牌提供了一个抽象层，将不同的授权结构（如用户名密码、断言）替换成资源服务器可以理解的单一令牌。这种抽象使得分发短期有效的访问令牌成为可能，也使得资源服务器不必理解多种多样的授权机制。</p><figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">+--------+                               +---------------+</span><br><span class="line">|        |--(A)- Authorization Request -&gt;|  <span class="built_in"> Resource </span>   |</span><br><span class="line">|        |                               |     Owner     |</span><br><span class="line">|        |&lt;-(B)----- Access Grant -------|               |</span><br><span class="line">|        |                               +---------------+</span><br><span class="line">|        |</span><br><span class="line">|        |           Access Grant &amp;      +---------------+</span><br><span class="line">|        |--(C)---<span class="built_in"> Client </span>Credentials --&gt;| Authorization |</span><br><span class="line">|<span class="built_in"> Client </span>|                               |    <span class="built_in"> Server </span>   |</span><br><span class="line">|        |&lt;-(D)----- Access Token -------|               |</span><br><span class="line">|        |                               +---------------+</span><br><span class="line">|        |</span><br><span class="line">|        |                               +---------------+</span><br><span class="line">|        |--(E)----- Access Token ------&gt;|   <span class="built_in"> Resource </span>  |</span><br><span class="line">|        |                               |    <span class="built_in"> Server </span>   |</span><br><span class="line">|        |&lt;-(F)--- Protected<span class="built_in"> Resource </span>---|               |</span><br><span class="line">+--------+                               +---------------+</span><br><span class="line">图1: 抽象的协议流程</span><br></pre></td></tr></table></figure><blockquote><p>图1所示的抽象流程协议的总体架构，它包含下列步骤：</p><p>&emsp;(A) 客户端从资源拥有者那里请求授权。授权请求能够直接发送给资源拥有者，或者间接地通过授权服务器这样的中介，而后者更为可取。</p><p>&emsp;(B) 客户端收到一个访问许可，它代表由资源服务器提供的授权。</p><p>&emsp;(C) 客户端使用它自己的私有证书到授权服务器上验证，并出示访问许可，来请求一个访问令牌。</p><p>&emsp;(D) 授权服务器验证客户端私有证书和访问许可的有效性，如果验证通过则分发一个访问令牌。</p><p>&emsp;(E) 客户端通过出示访问令牌向资源服务器请求受保护资源。</p><p>&emsp;(F) 资源服务器验证访问令牌的有效性，如果验证通过则响应这个资源请求。</p></blockquote><h3 id="1-4-访问许可-Access-Grants"><a href="#1-4-访问许可-Access-Grants" class="headerlink" title="1.4 访问许可 Access Grants"></a><strong>1.4 访问许可 Access Grants</strong></h3><p>&emsp;&emsp;访问许可代表资源拥有者提供的授权。访问许可的类型取决于客户端使用的获取方式和授权服务器所支持的方式。</p><h4 id="1-4-1-授权码-Authorization-Code"><a href="#1-4-1-授权码-Authorization-Code" class="headerlink" title="1.4.1 授权码 Authorization Code"></a><strong>1.4.1 授权码 Authorization Code</strong></h4><p>&emsp;&emsp;授权码是通过将终端用户引导到授权服务器而获得的一种访问许可。授权服务器验证终端用户，获得授权，然后向客户端分发一个授权码。因为终端用户只在授权服务器上进行验证，所以终端用户的密码从来不用分享给客户端。</p><p>&emsp;&emsp;当客户端通过一个user-agent同终端用户进行交互的时候，授权码这种访问许可是很合适的。</p><figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">+----------+</span><br><span class="line">|          |</span><br><span class="line">| End-User |</span><br><span class="line">|          |</span><br><span class="line">+----------+</span><br><span class="line">     ^</span><br><span class="line">     |</span><br><span class="line">    (B)</span><br><span class="line">+----|-----+       <span class="built_in"> Client </span>Identifier     +---------------+</span><br><span class="line">|         -+--(A)--- &amp; Redirect URI -----&gt;|               |</span><br><span class="line">|  User-   |                              | Authorization |</span><br><span class="line">|  Agent  -|--(B)--<span class="built_in"> User </span>authenticates --&gt;|    <span class="built_in"> Server </span>   |</span><br><span class="line">|          |                              |               |</span><br><span class="line">|         -+--(C)-- Authorization Code --&lt;|               |</span><br><span class="line">+-|----|---+                              +---------------+</span><br><span class="line"> (A)  (C)</span><br><span class="line">  |    |</span><br><span class="line">  ^    v</span><br><span class="line">+---------+</span><br><span class="line">|         |</span><br><span class="line">| <span class="built_in"> Client </span>|</span><br><span class="line">|         |</span><br><span class="line">+---------+</span><br><span class="line">图2: 获取授权码</span><br></pre></td></tr></table></figure><blockquote><p>图2所示的授权码获取流程包含下列步骤：</p><p>&emsp;(A) 客户端通过将终端用户的user-agent引导到授权服务器的终端用户授权端点来发起这个流程。客户端传入标识符、请求作用域、本地状态，和一个重定向URI（在访问被许可或被拒绝后授权服务器会重新将user-agent引导回这个URI）。</p><p>&emsp;(B) 授权服务器验证终端用户的身份（通过user-agent），并且确定终端用户是许可还是拒绝了客户端的访问请求。</p><p>&emsp;(C) 如果访问被许可，授权服务器会使用重定向URI将user-agent引导回客户端。授权服务器传回一个授权码给客户端，用于进一步获取访问令牌。</p></blockquote><p>&emsp;&emsp;一旦客户端获得了授权码，它会到授权服务器上去做验证（使用客户端私有证书）并出示授权码（访问许可），以借此请求一个访问令牌。</p><p>&emsp;&emsp;在客户端无法维护它自己的私有证书的情况下（如原生程序或用某种user-agent脚本实现的程序），授权服务器在(C)步直接给客户端分发一个访问令牌，而不再分发一个授权码。</p><p>&emsp;&emsp;获得授权码的过程在第4节详述。</p><h4 id="1-4-2-资源拥有者密码证书-Resource-Owner-Password-Credentials"><a href="#1-4-2-资源拥有者密码证书-Resource-Owner-Password-Credentials" class="headerlink" title="1.4.2 资源拥有者密码证书 Resource Owner Password Credentials"></a><strong>1.4.2 资源拥有者密码证书 Resource Owner Password Credentials</strong></h4><p>&emsp;&emsp;资源拥有者密码证书（例如用户名和密码）可以直接用作访问许可来获取访问令牌。这种私有证书只应该在以下两种情况下使用：当在资源拥有者和客户端之间有很强的信任关系的时候（例如，资源拥有者的计算机操作系统，或具有很高特权的程序），以及当其它访问许可类型（如授权码）不可用的时候。</p><p>&emsp;&emsp;即使这种许可类型需要客户端直接访问资源拥有者的私有证书，资源拥有者的私有证书也只是在一个请求中使用，并交换成访问令牌。与<a href="https://tools.ietf.org/id/draft-ietf-oauth-v2-11.html#RFC2617" title="Title" target="_blank" rel="noopener">[RFC2617]</a>定义的HTTP Basic验证机制不同，这种许可类型不再需要客户端存储资源拥有者的私有证书以备日后使用。</p><p>&emsp;&emsp;在图3中，客户端直接从资源拥有者请求授权。当资源拥有者是一个终端用户时，客户端通常的做法是提示终端用户输入用户名和密码。</p><figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">+--------+                               +----------+</span><br><span class="line">|        |--(A)- Authorization Request -&gt;|<span class="built_in"> Resource </span>|</span><br><span class="line">|<span class="built_in"> Client </span>|                               |   Owner  |</span><br><span class="line">|        |&lt;-(B)-- Username &amp; Password ---|          |</span><br><span class="line">+--------+                               +----------+</span><br><span class="line">图3: 获取资源拥有者密码证书</span><br></pre></td></tr></table></figure><h4 id="1-4-3-客户端私有证书-Client-Credentials"><a href="#1-4-3-客户端私有证书-Client-Credentials" class="headerlink" title="1.4.3 客户端私有证书 Client Credentials"></a><strong>1.4.3 客户端私有证书 Client Credentials</strong></h4><p>&emsp;&emsp;当授权作用域限制在客户端所控制的受保护资源或之前与授权服务器约定好的受保护资源时，客户端本身的私有证书可被用作访问许可。客户端私有证书用作访问许可的典型例子是，当客户端代表它自己执行操作时（客户端同时也是资源拥有者）。</p><h4 id="1-4-4-刷新令牌-Refresh-Token"><a href="#1-4-4-刷新令牌-Refresh-Token" class="headerlink" title="1.4.4 刷新令牌 Refresh Token"></a><strong>1.4.4 刷新令牌 Refresh Token</strong></h4><p>&emsp;&emsp;访问令牌的生命周期通常比资源拥有者授予的要短一些。当分发一个访问令牌时，授权服务器可以同时传回一个刷新令牌，在当前访问令牌超时后，客户端可以用这个刷新令牌重新获取一个访问令牌。当请求新的访问令牌时，刷新令牌担当起访问许可的角色。使用刷新令牌，不再需要再次与资源拥有者交互，也不需要存储原始的访问许可来获得访问令牌和刷新令牌。</p><figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">  +--------+          Access Grant &amp;      +---------------+</span><br><span class="line">  |        |--(A)--<span class="built_in"> Client </span>Credentials --&gt;| Authorization |</span><br><span class="line">  |        |                              |    <span class="built_in"> Server </span>   |</span><br><span class="line">  |        |&lt;-(B)---- Access Token -------|               |</span><br><span class="line">  |        |         &amp; Refresh Token      +---------------+</span><br><span class="line">  |        |</span><br><span class="line">  |        |                              +---------------+</span><br><span class="line">  |        |--(C)----- Access Token -----&gt;|               |</span><br><span class="line">  |        |                              |               |</span><br><span class="line">  |        |&lt;-(D)-- Protected<span class="built_in"> Resource </span>---|   <span class="built_in"> Resource </span>  |</span><br><span class="line">  |<span class="built_in"> Client </span>|                              |    <span class="built_in"> Server </span>   |</span><br><span class="line">  |        |--(E)----- Access Token -----&gt;|               |</span><br><span class="line">  |        |                              |               |</span><br><span class="line">  |        |&lt;-(F)-- Invalid Token <span class="builtin-name">Error</span> --|               |</span><br><span class="line">  |        |                              +---------------+</span><br><span class="line">  |        |</span><br><span class="line">  |        |          Refresh Token &amp;     +---------------+</span><br><span class="line">  |        |--(G)--<span class="built_in"> Client </span>Credentials --&gt;| Authorization |</span><br><span class="line">  |        |                              |    <span class="built_in"> Server </span>   |</span><br><span class="line">  |        |&lt;-(H)----- Access Token ------|               |</span><br><span class="line">  +--------+     &amp; Optional Refresh Token +---------------+</span><br><span class="line"></span><br><span class="line">图4: 刷新访问令牌</span><br></pre></td></tr></table></figure><blockquote><p>图4所示的刷新令牌流程包含下列步骤：</p><p>&emsp;(A) 客户端通过使用它自己的私有证书在授权服务器上验证，并出示一个访问许可。</p><p>&emsp;(B) 授权服务器验证客户端私有证书和访问许可的有效性，如果通过则分发一个访问令牌和刷新令牌。</p><p>&emsp;(C) 客户端通过出示访问令牌向资源服务器请求受保护资源。</p><p>&emsp;(D) 资源服务器验证访问令牌的有效性，如果通过，则相应这个请求。</p><p>&emsp;(E) 步骤(C)(D)不停重复，直到访问令牌过期。如果客户端不知道访问令牌过期，它会再请求一次受保护资源。否则，跳到步骤(G)。</p><p>&emsp;(F) 因为访问令牌是无效的（过期了），资源服务器返回一个无效令牌错误。</p><p>&emsp;(G) 客户端通过使用它的私有证书在授权服务器上验证并出示刷新令牌（用作访问许可），来请求一个新的访问令牌。</p><p>&emsp;(H) 授权服务器验证客户端私有证书的有效性，如果通过则分发一个新的访问令牌（也可能还有一个刷新令牌）。</p></blockquote><h4 id="1-4-5-断言-Assertion"><a href="#1-4-5-断言-Assertion" class="headerlink" title="1.4.5 断言 Assertion"></a><strong>1.4.5 断言 Assertion</strong></h4><p>&emsp;&emsp;断言在OAuth和其它信任框架之间架起一座桥梁。它们允许客户端利用现成的信任关系来获取访问令牌。一个断言所代表的访问许可取决于断言类型、断言内容，以及断言被分发的方式，而这些内容不在本规范的规定范围之内。</p><p>&emsp;&emsp;断言可以用在协议扩展模型的部分，它为授权服务器提供了一种支持其它访问许可类型的方式。</p><hr><h2 id="第二节-Client-Profiles"><a href="#第二节-Client-Profiles" class="headerlink" title="第二节 Client Profiles"></a><strong>第二节 Client Profiles</strong></h2><h3 id="2-1-服务端-Web-Server"><a href="#2-1-服务端-Web-Server" class="headerlink" title="2.1 服务端 Web Server"></a><strong>2.1 服务端 Web Server</strong></h3><p>&emsp;&emsp;服务端概要(Web Server profile) 适用于有能力与终端用户的user-agent（通常是浏览器）交互并能够从授权服务器接收（通过重定向）请求（即有能力担当HTTP服务器的角色）的客户端。</p><figure class="highlight gherkin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">  +----------+          Client Identifier      +---------------+</span><br><span class="line">  |<span class="string">         -+----(A)--- &amp; Redirect URI ------&gt;</span>|<span class="string">               </span>|</span><br><span class="line">  |<span class="string"> End-user </span>|<span class="string">                                 </span>|<span class="string"> Authorization </span>|</span><br><span class="line">  |<span class="string">    at    </span>|<span class="string">&lt;---(B)-- User authenticates ---&gt;</span>|<span class="string">     Server    </span>|</span><br><span class="line">  |<span class="string"> Browser  </span>|<span class="string">                                 </span>|<span class="string">               </span>|</span><br><span class="line">  |<span class="string">         -+----(C)-- Authorization Code ---&lt;</span>|<span class="string">               </span>|</span><br><span class="line">  +-|<span class="string">----</span>|<span class="string">---+                                 +---------------+</span></span><br><span class="line"><span class="string">    </span>|<span class="string">    </span>|<span class="string">                                         ^      v</span></span><br><span class="line"><span class="string">   (A)  (C)                                        </span>|<span class="string">      </span>|</span><br><span class="line">    |<span class="string">    </span>|<span class="string">                                         </span>|<span class="string">      </span>|</span><br><span class="line">    ^    v                                         |<span class="string">      </span>|</span><br><span class="line">  +---------+                                      |<span class="string">      </span>|</span><br><span class="line">  |<span class="string">         </span>|<span class="string">&gt;---(D)-- Client Credentials, --------'      </span>|</span><br><span class="line">  |<span class="string">  Server </span>|<span class="string">          Authorization Code,                </span>|</span><br><span class="line">  |<span class="string">  -Based </span>|<span class="string">            &amp; Redirect URI                   </span>|</span><br><span class="line">  |<span class="string">  Client </span>|<span class="string">                                             </span>|</span><br><span class="line">  |<span class="string">         </span>|<span class="string">&lt;---(E)----- Access Token -------------------'</span></span><br><span class="line"><span class="string">  +---------+       (w/ Optional Refresh Token)</span></span><br><span class="line"><span class="string">图5: Web Server流程</span></span><br></pre></td></tr></table></figure><blockquote><p>图5所示的web server流程包含下列步骤：</p><p>&emsp;(A) 如第4节所述，web客户端通过将终端用户的user-agent重定向到授权服务器来发起这个流程。客户端传入它的客户端标识符、请求作用域、本地状态和一个重定向URI，在访问被许可（或被拒绝）后授权服务器会重新将终端用户引导回这个URI。</p><p>&emsp;(B) 授权服务器验证终端用户（借助于user-agent），并确定终端用户是否许可客户端的访问请求。</p><p>&emsp;(C) 假定终端用户许可了这次访问，授权服务器会将user-agent重定向到之前提供的重定向URI上去。授权服务器为客户端传回一个授权码做获取访问令牌之用。</p><p>&emsp;(D) 如第5节所述，客户端通过验证并传入上一步取得的授权码从授权服务器请求一个访问令牌。</p><p>&emsp;(E) 授权服务器验证客户端私有证书和授权码的有效性并返回访问令牌。</p></blockquote><h3 id="2-2-用户代理-User-Agent"><a href="#2-2-用户代理-User-Agent" class="headerlink" title="2.2 用户代理 User-Agent"></a><strong>2.2 用户代理 User-Agent</strong></h3><p>&emsp;&emsp;User-Agent子态适用于常驻user-agent的客户端应用，典型的例子是用诸如JavaScript语言编写并运行在浏览器的程序。这些客户端不能保存客户端私有证书，并且客户端的验证基于user-agent的同源策略。</p><p>&emsp;&emsp;在其它子态中，客户端对于终端用户的授权和访问令牌使用分开的不同请求来完成，而与之不同的是，在user-agent子态中，客户端以HTTP重定向的方式在终端用户授权请求的结果中获取到访问令牌。客户端请求授权服务器将user-agent重定向到另一个web服务器或user-agent能访问到的本地资源，而且user-agent有能力从响应信息中提取出访问令牌并传给客户端。</p><p>&emsp;&emsp;这种user-agent子态并不使用客户端密钥，因为客户端执行程序常驻于终端用户的计算机或设备上，这使得客户端密钥可以被访问或收集到。因为访问令牌被编码到重定向URI中，所以它可能会暴露给终端用户和常驻计算机或设备上的其它应用。</p><figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">         +----------+         <span class="built_in"> Client </span>Identifier     +----------------+</span><br><span class="line">         |          |&gt;---(A)-- &amp; Redirection URI ---&gt;|                |</span><br><span class="line">         |          |                                |                |</span><br><span class="line">  End &lt;--+  -  -  - +----(B)--<span class="built_in"> User </span>authenticates --&gt;|  Authorization |</span><br><span class="line"> <span class="built_in"> User </span>  |          |                                |    <span class="built_in"> Server </span>    |</span><br><span class="line">         |          |&lt;---(C)--- Redirect URI -------&lt;|                |</span><br><span class="line">         | <span class="built_in"> Client </span> |         with Access Token      |                |</span><br><span class="line">         |    <span class="keyword">in</span>    |            <span class="keyword">in</span> Fragment         +----------------+</span><br><span class="line">         |  Browser |</span><br><span class="line">         |          |                                +----------------+</span><br><span class="line">         |          |&gt;---(D)--- Redirect URI -------&gt;|                |</span><br><span class="line">         |          |         without Fragment       |   Web<span class="built_in"> Server </span>  |</span><br><span class="line">         |          |                                |   with<span class="built_in"> Client </span> |</span><br><span class="line">         |    (F)   |&lt;---(E)--- Web<span class="built_in"> Page </span>with ------&lt;|   <span class="built_in"> Resource </span>   |</span><br><span class="line">         |  Access  |             <span class="built_in"> Script </span>           |                |</span><br><span class="line">         |   Token  |                                +----------------+</span><br><span class="line">         +----------+</span><br><span class="line">图6: User-Agent流程</span><br></pre></td></tr></table></figure><blockquote><p>图6所示的user-agent流程包含下列步骤：</p><p>&emsp;(A) 如第5节所述，客户端将user-agent引导到终端用户授权endpoint。客户端传入它的客户端标识符、请求作用域、本地状态和一个重定向URI，在访问被许可（或被拒绝）后授权服务器会重新将终端用户引导回这个URI。</p><p>&emsp;(B) 授权服务器验证终端用户（通过user-agent）并确认终端用户是许可还是拒绝了客户端的访问请求。</p><p>&emsp;(C) 如果终端用户许可了这次访问，那么授权服务器会将user-agent引导到之前提供的重定向URI。重定向URI会在URI片断{译者注：URI片断是指URI中#号之后的内容}中包含访问令牌。</p><p>&emsp;(D) user-agent响应重定向指令，向web服务器发送不包含URI片断的请求。user-agent在本地保存URI片断。</p><p>&emsp;(E) web服务器返回一个web页面（通常是嵌入了脚本的HTML网页），这个页面能够访问完整的重定向URI，它包含了由user-agent保存的URI片断，同时这个页面能够将包含在URI片断中的访问令牌（和其它参数）提取出来。</p><p>&emsp;(F) user-agent在本地执行由web服务器提供的脚本，该脚本提取出访问令牌并将它传递给客户端。</p></blockquote><h3 id="2-3-原生程序-Native-Application"><a href="#2-3-原生程序-Native-Application" class="headerlink" title="2.3 原生程序 Native Application"></a><strong>2.3 原生程序 Native Application</strong></h3><p>&emsp;&emsp;原生程序是作为原生代码运行在终端用户计算机或设备上的客户端（即，在user-agent之外运行或作为一个桌面程序）。这些客户端通常有能力与终端用户的user-agent交互（或嵌入user-agent），但是在这些交互如何影响终端用户体验的方式上受到限制。在很多情况下，原生程序无法直接从服务器接收回调请求（例如，防火墙、操作系统限制）。</p><p>&emsp;&emsp;基于不同的需求和期望的终端用户体验，原生程序客户端可以用不同的方式实现。原生程序客户端可以：</p><blockquote><ul><li>如第4节所述，通过启动一个外部user-agent来访问终端用户授权endpoint。客户端可以通过下面的方式捕获响应文本：提供一个具有自定义URI scheme{译者注：URI scheme就是一个URI里面的第一部分，即冒号前面的部分}的重定向URI（在操作系统上注册过以便调用客户端应用），或者提供一个指向在客户端控制下的服务器资源的重定向URI，这使得响应文本对客户端可见（例如，使用窗口标题或在user-agent外面可以访问到的其它位置）。</li><li>如第4节所述，通过嵌入一个user-agent来访问终端用户授权endpoint。客户端通过与嵌入的user-agent直接通信获取到响应文本。</li><li>提示终端用户输入密码，使用密码直接获得一个访问令牌。通常来讲，这是一种不推荐的方式，因为它将终端用户的密码直接交给了第三方客户端，而客户端不得不用明文存储密码。它还要求服务器支持基于密码的身份验证。</li></ul></blockquote><p>&emsp;&emsp;当在启动外部浏览器和嵌入的user-agent之间进行选择时，开发者应该考虑下列因素：</p><blockquote><ul><li>外部浏览器可能会提高完成比率，因为终端用户可能已经登录过了而不需要重新进行身份验证。</li><li>嵌入的user-agent通常能提供更好的用户流程，因为它不必切换上下文并打开新窗口。</li><li>嵌入的user-agent对安全提出了挑战，因为用户在一个无法辨别的窗口之中进行身份验证，而不像很多user-agent那样能提供可视化的保护。</li></ul></blockquote><h3 id="2-4-自治态-Autonomous"><a href="#2-4-自治态-Autonomous" class="headerlink" title="2.4 自治态 Autonomous"></a><strong>2.4 自治态 Autonomous</strong></h3><p>&emsp;&emsp;自治客户端使用现成的信任关系或框架来建立授权。基于自治客户端的需求和他们所依赖的现存信任框架，自治客户端可以用不同的方式实现。自治客户端可以：</p><blockquote><ul><li>通过使用客户端私有证书与授权服务器进行验证，从而获得访问令牌。访问令牌的作用域局限于受客户端控制的受保护资源，或者其它资源拥有者与授权服务器预先约定的资源。</li><li>使用现存的某种访问许可，它被表达成授权服务器所支持的某种断言格式。使用断言需要客户端从一个断言发行方获得一个断言（如SAML[OASIS.saml-core-2.0-os]断言）或自己分发一个断言。断言的格式、获得断言的过程，以及验证断言的方法，由断言发行方和授权服务器定义，不在本规范的规定范围之内。</li></ul></blockquote><hr><h2 id="第三节-客户端私有证书-Client-Credentials"><a href="#第三节-客户端私有证书-Client-Credentials" class="headerlink" title="第三节 客户端私有证书 Client Credentials"></a><strong>第三节 客户端私有证书 Client Credentials</strong></h2><p>&emsp;&emsp;当与授权服务器进行交互时，客户端使用一个私有证书集合来标识自己，这个证书集合包含一个客户端标识符和用于客户端身份验证的其它一些属性。客户端获得私有证书的方式不在本规范的规定范围之内，不过这通常都包含一个在授权服务器上注册的过程。</p><p>&emsp;&emsp;考虑到一些客户端的本质特性，在与客户端没有确立信任关系的前提下，授权服务器不应该对客户端密钥的私密性做出任何假设。授权服务器不应该向没有能力对密钥进行秘密保存的客户端分发密钥。</p><p>&emsp;&emsp;授权服务器可以使用任一合适的私有证书集合和验证机制来对客户端进行身份验证。客户端一定不能在一个请求中使用多个私有证书集合和验证机制。</p><h3 id="3-1-客户端密码证书-Client-Password-Credentials"><a href="#3-1-客户端密码证书-Client-Password-Credentials" class="headerlink" title="3.1 客户端密码证书 Client Password Credentials"></a><strong>3.1 客户端密码证书 Client Password Credentials</strong></h3><p>&emsp;&emsp;客户端密码证书使用一个共享的对称密钥来验证客户端。客户端标识符和密码被包含在请求当中，使用<a href="https://tools.ietf.org/id/draft-ietf-oauth-v2-11.html#RFC2617" title="Title" target="_blank" rel="noopener">[RFC2617]</a>定义的HTTP Basic验证机制，将客户端标识符作为用户名（username）并将客户端密码作为密码（password）来传送。</p><p>&emsp;&emsp;例如（换行符只用于显示目的）：</p><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">POST</span> <span class="string">/token</span> HTTP/1.1</span><br><span class="line"><span class="attribute">Host</span>: server.example.com</span><br><span class="line"><span class="attribute">Authorization</span>: Basic czZCaGRSa3F0MzpnWDFmQmF0M2JW</span><br><span class="line"><span class="attribute">Content-Type</span>: application/x-www-form-urlencoded</span><br><span class="line"></span><br><span class="line">grant_type=authorization_code&amp;code=i1WsRn1uB1&amp;</span><br><span class="line">redirect_uri=https%3A%2F%2Fclient%2Eexample%2Ecom%2Fcb</span><br></pre></td></tr></table></figure><p>&emsp;&emsp;作为可选方式，客户端可以使用下列参数将密码包含在请求体（request body）中：</p><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">client_id</span><br><span class="line">    必需参数。客户端标识符。</span><br><span class="line">client_secret</span><br><span class="line">    必需参数。客户端密钥。</span><br></pre></td></tr></table></figure><p>&emsp;&emsp;例如（换行符只用于显示目的）：</p><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">POST</span> <span class="string">/token</span> HTTP/1.1</span><br><span class="line"><span class="attribute">Host</span>: server.example.com</span><br><span class="line"><span class="attribute">Content-Type</span>: application/x-www-form-urlencoded</span><br><span class="line"></span><br><span class="line">grant_type=authorization_code&amp;client_id=s6BhdRkqt3&amp;</span><br><span class="line">client_secret=gX1fBat3bV&amp;code=i1WsRn1uB1&amp;</span><br><span class="line">redirect_uri=https%3A%2F%2Fclient%2Eexample%2Ecom%2Fcb</span><br></pre></td></tr></table></figure><p>&emsp;&emsp;授权服务器必须能够使用请求参数和HTTP Basic验证协议两种方式接受客户端私有证书。授权服务器可以支持更多适合于密码证书传输的验证机制。</p><h3 id="3-2-客户端断言证书-Client-Assertion-Credentials"><a href="#3-2-客户端断言证书-Client-Assertion-Credentials" class="headerlink" title="3.2 客户端断言证书 Client Assertion Credentials"></a><strong>3.2 客户端断言证书 Client Assertion Credentials</strong></h3><p>&emsp;&emsp;客户端断言证书用于不宜使用密码（明文共享对称密钥）或密码无法为客户端验证提供足够安全性的情况。在这样的情况下，常见的做法是使用诸如HMAC或数字签名之类不需要发送明文密钥的其它机制。客户端断言证书提供了一种扩展机制，能够使用被授权服务器所支持的某种断言格式进行客户端身份验证。</p><p>&emsp;&emsp;使用断言需要客户端从一个断言发行方获得一个断言（如SAML[OASIS.saml-core-2.0-os]断言）或自己分发一个断言。断言的格式、获得断言的过程，以及验证断言的方法，由断言发行方和授权服务器定义，不在本规范的规定范围之内。</p><p>&emsp;&emsp;当使用客户端断言时，客户端传送下列参数：</p><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">client_assertion_type</span><br><span class="line">    必需参数。由授权服务器定义的断言格式。这个值必须是一个绝对URI。</span><br><span class="line">client_assertion</span><br><span class="line">    必需参数。客户端断言。</span><br></pre></td></tr></table></figure><p>&emsp;&emsp;例如，客户端使用一个SAML 2.0断言发送如下访问令牌请求来验证自己（换行符只用于显示目的）：</p><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">POST</span> <span class="string">/token</span> HTTP/1.1</span><br><span class="line"><span class="attribute">Host</span>: server.example.com</span><br><span class="line"><span class="attribute">Content-Type</span>: application/x-www-form-urlencoded</span><br><span class="line"></span><br><span class="line">grant_type=authorization_code&amp;code=i1WsRn1uB1&amp;</span><br><span class="line">client_assertion=PHNhbWxwOl[...omitted for brevity...]ZT4%3D&amp;</span><br><span class="line">client_assertion_type=</span><br><span class="line"><span class="attribute">urn%3Aoasis%3Anames%sAtc%3ASAML%3A2.0%3Aassertion&amp;</span></span><br><span class="line">redirect_uri=https%3A%2F%2Fclient%2Eexample%2Ecom%2Fcb</span><br></pre></td></tr></table></figure><p>&emsp;&emsp;当使用一个客户端断言和一个授权码获得一个访问令牌的时候，需要一个机制在用于获取授权码的“client_id”参数值和客户端断言之间完成映射。这个机制不在本规范的规定范围之内，但对于与授权码结合使用的任何客户端断言类型都必须明确指明。</p><p>&emsp;&emsp;对于那些使用客户端断言证书但不包含能够提供下列信息的HMAC或签名值的访问令牌请求，授权服务器必须拒绝响应：</p><blockquote><ul><li>指明这个断言是专门分发给当前接收endpoint来处理的（一般是通过一个包含接收endpoint标识符的audience或recipient值）。</li><li>标识出分发断言的实体（一般是通过一个issuer值）。</li><li>用一个绝对时间标识出断言在何时过期（一般是通过一个包含UTC日期/时间值的过期值）。授权服务器必须拒绝过期的断言。</li></ul></blockquote><hr><h2 id="第四节-获得终端用户授权-Obtaining-End-User-Authorization"><a href="#第四节-获得终端用户授权-Obtaining-End-User-Authorization" class="headerlink" title="第四节 获得终端用户授权 Obtaining End-User Authorization"></a><strong>第四节 获得终端用户授权 Obtaining End-User Authorization</strong></h2><p>&emsp;&emsp;在客户端能够访问一个受保护资源之前，它必须首先从终端用户那里获取授权。为了获得终端用户授权，客户端需要将终端用户引导到终端用户授权endpoint。一旦获得授权，终端用户的访问许可会被表示成一个授权码，客户端能够使用它去获取一个访问令牌。</p><p>&emsp;&emsp;在终端用户授权endpoint上，终端用户首先在授权服务器上完成身份验证，然后允许或者拒绝当前访问请求。授权服务器验证用户的方式（例如，用户名和密码登录，OpenID，会话cookie）和授权服务器获取终端用户授权的方式，以及是否使用诸如TSL之类的安全通道，不在本规范的规定范围之内。然而，授权服务器必须要首先验证终端用户的身份。</p><p>&emsp;&emsp;终端用户授权endpoint的位置能够在服务器文档中找到。终端用户授权endpoint的URI可以按照[RFC3986]第3节的定义包含一个查询参数部分，它们在添加其它参数时必须被保留。</p><p>&emsp;&emsp;既然对于终端用户授权endpoint的请求会导致用户身份验证和敏感信息的传输，授权服务器应该要求在向终端用户授权endpoint发送请求的时候使用诸如TLS之类的传输层安全机制。</p><h3 id="4-1-授权请求-Authorization-Request"><a href="#4-1-授权请求-Authorization-Request" class="headerlink" title="4.1 授权请求 Authorization Request"></a><strong>4.1 授权请求 Authorization Request</strong></h3><p>&emsp;&emsp;为了将终端用户的user-agent引导到授权服务器，客户端将下列参数添加到终端用户授权endpoint URI的查询参数部分，并使用如<a href="https://tools.ietf.org/id/draft-ietf-oauth-v2-11.html#W3C.REC-html401-19991224" title="Title" target="_blank" rel="noopener">[W3C.REC-html401-19991224]</a>所定义的“application/x-www-form-urlencoded”格式构建起一个请求URI，如下定义：</p><figure class="highlight pf"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">response_type</span><br><span class="line">    必需参数。请求的响应中：一个访问令牌、一个授权码，或两者都有。请求访问令牌参数值必须设为“token”，请求授权码参数值必须设为“code”，或者使用参数值为“code_and_token”同时请求两者。授权服务器可能拒绝提供这些响应类型中的一种或多种。</span><br><span class="line">client_id</span><br><span class="line">    必需参数。如第<span class="number">3</span>节所述的客户端标识符。</span><br><span class="line">redirect_uri</span><br><span class="line">    必需参数，除非通过其它方式在客户端和授权服务器之间已经确定了一个重定向URI。这是当终端用户的授权步骤完成时授权服务器将要把user-agent重定向到的一个绝对URI。授权服务器应该要求客户端预先注册它们的重定向URI。</span><br><span class="line">scope</span><br><span class="line">    可选参数。访问请求的作用域，以空格隔开的字符串列表来表示。“scope”参数的值由授权服务器定义。如果这个值包含多个空格隔开的字符串，那么它们的顺序不分先后，而且每个字符串都为请求的作用域增加一个新的访问范围。</span><br><span class="line"><span class="keyword">state</span></span><br><span class="line">    可选参数。被客户端用来在请求和回调之间维护状态的值，对授权服务器来说是不透明的。授权服务器在将user-agent重定向回客户端时传回这个值。</span><br></pre></td></tr></table></figure><p>&emsp;&emsp;客户端通过user-agent使用HTTP重定向响应，或者其它可用的方式，将终端用户引导到构建好的URI上。对于终端用户授权endpoint，授权服务器必须支持HTTP的“GET”方法，也可以支持使用“POST”方法。</p><p>&emsp;&emsp;例如，客户端引导终端用户的user-agent使用传输层安全机制发送下列HTTP请求（换行符只用于显示目的）:</p><figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="attribute">GET</span> /authorize?response_type=code&amp;client_id=s6BhdRkqt3&amp;</span><br><span class="line">    <span class="attribute">redirect_uri</span>=https<span class="number">%3</span>A<span class="number">%2</span>F<span class="number">%2</span>Fclient<span class="number">%2</span>Eexample<span class="number">%2</span>Ecom<span class="number">%2</span>Fcb HTTP/1.1</span><br><span class="line"><span class="attribute">Host</span>: server.example.com</span><br></pre></td></tr></table></figure><p>&emsp;&emsp;如果客户端已经在授权服务器上预先注册了一个重定向URI，授权服务器必须保证收到的重定向URI与当前客户端标识符所对应的注册URI相匹配。授权服务器不应该将user-agent重定向到没有注册过的或不信任的URI，以避免endpoint被用作一个公开的转向器。如果没有可用的有效重定向URI，授权服务器应该将发生的错误报告给用户[[提供如何执行匹配操作的建议]]。</p><p>&emsp;&emsp;没有值的参数必须被当做它们在请求中不存在一样。授权服务器应该忽略识别不了的请求参数。</p><p>&emsp;&emsp;授权服务器对请求进行验证以保证所有必需参数都存在并有效。如果请求是无效的，授权服务器将使用重定向URI把user-agent重定向回客户端，并且URI后面加上适当的错误码，如4.3节所述。</p><p>&emsp;&emsp;授权服务器验证终端用户的身份并获得一个授权决定（通过询问用户或通过其它方式认可）。当一个决定被做出后，授权服务器将终端用户的user-agent引导到客户端提供的重定向URI，这个重定向或者使用HTTP重定向响应，或者通过终端用户user-agent的其它可用的方式。</p><h3 id="4-2-授权响应-Authorization-Response"><a href="#4-2-授权响应-Authorization-Response" class="headerlink" title="4.2 授权响应 Authorization Response"></a><strong>4.2 授权响应 Authorization Response</strong></h3><p>&emsp;&emsp;如果终端用户许可了访问请求，授权服务器会分发一个访问令牌，或一个授权码，或者两者都有，并且通过将下列参数添加到重定向URI将这些分发结果传递给客户端（如下所述）。</p><figure class="highlight pf"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">code</span><br><span class="line">    如果响应类型是“code”或“code_and_token”则是必需的，否则一定不能包含这个参数。表示由授权服务器产生的授权码。授权码应该在分发后迅速过期，以降低泄露风险。客户端一定不能重用同一个授权码。如果一个授权码被多次使用，授权服务器可能撤销之前基于这个授权码分发的所有令牌。授权码与客户端标识符和重定向URI相绑定。</span><br><span class="line">access_token</span><br><span class="line">    如果响应类型是“token”或“code_and_token”则是必需的，否则一定不能包含这个参数。表示由授权服务器分发的访问令牌。</span><br><span class="line">token_type</span><br><span class="line">    如果响应中包含一个访问令牌则是必需的。表示分发的令牌类型。令牌类型告诉客户端一个信息，即当访问一个受保护资源时访问令牌应该如何被使用，如<span class="number">6.1</span>节所述。</span><br><span class="line">expires_in</span><br><span class="line">    可选参数。如果包含访问令牌参数，则表示访问令牌生命周期的秒数。例如，“<span class="number">3600</span>”表示自响应被授权服务器产生的时刻起，访问令牌将在一小时后过期。</span><br><span class="line">scope</span><br><span class="line">    可选参数。如果包含访问令牌参数，则表示访问令牌的作用域，表示为一个空格隔开的字符串列表。“scope”参数的值由授权服务器定义。如果这个值包含多个空格隔开的字符串，那么它们的顺序不分先后，而且每个字符串都为请求的作用域增加一个新的访问范围。如果请求到的作用域不同于客户端申请的作用域，授权服务器应该传回这个参数。</span><br><span class="line"><span class="keyword">state</span></span><br><span class="line">    如果“<span class="keyword">state</span>”参数在客户端授权请求中存在，则这个参数是必需的。需要精确地设置成从客户端接收到的值。</span><br></pre></td></tr></table></figure><p>&emsp;&emsp;授权服务器在重定向URI上添加参数的方式取决于客户端在授权请求中请求的响应类型，由“response_type”参数指定。</p><p>&emsp;&emsp;如果响应类型是“code”，授权服务器使用如<a href="https://tools.ietf.org/id/draft-ietf-oauth-v2-11.html#W3C.REC-html401-19991224" title="Title" target="_blank" rel="noopener">[W3C.REC-html401-19991224]</a>所定义的“application/x-www-form-urlencoded”格式添加参数到重定向URI的查询参数部分。</p><p>&emsp;&emsp;例如，授权服务器通过发送下列HTTP响应将终端用户的user-agent进行重定向：</p><figure class="highlight groovy"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">HTTP/<span class="number">1.1</span> <span class="number">302</span> Found</span><br><span class="line"><span class="string">Location:</span> <span class="string">https:</span><span class="comment">//client.example.com/cb?code=i1WsRn1uB1</span></span><br></pre></td></tr></table></figure><p>&emsp;&emsp;如果响应类型是“code”或“code_and_token”，授权服务器使用如<a href="https://tools.ietf.org/id/draft-ietf-oauth-v2-11.html#W3C.REC-html401-19991224" title="Title" target="_blank" rel="noopener">[W3C.REC-html401-19991224]</a>所定义的“application/x-www-form-urlencoded”格式添加参数到重定向URI的分段参数部分。</p><p>&emsp;&emsp;例如，授权服务器通过发送下列HTTP响应将终端用户的user-agent进行重定向（URI换行符只用于显示目的）：</p><figure class="highlight dts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">HTTP/<span class="number">1.1</span> <span class="number">302</span> Found</span><br><span class="line"><span class="symbol">  Location:</span> http:<span class="comment">//example.com/rd#access_token=FJQbwq9&amp;</span></span><br><span class="line">            token_type=example<span class="variable">&amp;expires_in</span>=<span class="number">3600</span></span><br></pre></td></tr></table></figure><p>&emsp;&emsp;客户端应该忽略无法识别的响应参数。从授权服务器接收到的令牌和其它参数值的大小，本规范未作定义。客户端应该避免对参数值大小做任何假设。服务器应该对它们所分发的任何参数值的期望大小做出文档说明。</p><h3 id="4-3-错误响应-Error-Response"><a href="#4-3-错误响应-Error-Response" class="headerlink" title="4.3 错误响应 Error Response"></a><strong>4.3 错误响应 Error Response</strong></h3><p>&emsp;&emsp;如果终端用户拒绝了访问请求，或者由于除了缺少或无效重定向URI之外的其它原因而导致请求失败，授权服务器使用如<a href="https://tools.ietf.org/id/draft-ietf-oauth-v2-11.html#W3C.REC-html401-19991224" title="Title" target="_blank" rel="noopener">[W3C.REC-html401-19991224]</a>所定义的“application/x-www-form-urlencoded”格式添加下列参数到重定向URI的查询参数部分以通知客户端：</p><figure class="highlight pf"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">error</span><br><span class="line">    必需参数。如<span class="number">4.3</span>.<span class="number">1</span>节所述的一个错误码。</span><br><span class="line">error_description</span><br><span class="line">    可选参数。提供额外信息的一段人类可读的文字，用来帮助理解和解决发生的错误。</span><br><span class="line">error_uri</span><br><span class="line">    可选参数。指明了一个人类可读的网页URI，带有关于错误的信息，用来为终端用户提供与错误有关的额外信息。</span><br><span class="line"><span class="keyword">state</span></span><br><span class="line">    如果“<span class="keyword">state</span>”参数在客户端授权请求中存在，则这个参数是必需的。需要精确地设置成从客户端接收到的值。</span><br></pre></td></tr></table></figure><p>&emsp;&emsp;例如，授权服务器通过发送下列HTTP响应将终端用户的user-agent进行重定向：</p><figure class="highlight groovy"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">HTTP/<span class="number">1.1</span> <span class="number">302</span> Found</span><br><span class="line"><span class="string">Location:</span> <span class="string">https:</span><span class="comment">//client.example.com/cb?error=access_denied</span></span><br></pre></td></tr></table></figure><p>&emsp;&emsp;如果由于缺少或无效重定向URI而导致请求失败，授权服务器应该通知终端用户这个错误，而一定不能将终端用户的user-agent重定向到这个无效的重定向URI。</p><h4 id="4-3-1-错误码-Error-Codes"><a href="#4-3-1-错误码-Error-Codes" class="headerlink" title="4.3.1 错误码 Error Codes"></a><strong>4.3.1 错误码 Error Codes</strong></h4><p>&emsp;&emsp;授权服务器在错误响应中包含下列错误码之一：</p><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">invalid_request</span><br><span class="line">    请求缺少某个必需参数，包含一个不支持的参数或参数值，或者格式不正确。</span><br><span class="line">invalid_client</span><br><span class="line">    提供的客户端标识符是无效的。</span><br><span class="line">unauthorized_client</span><br><span class="line">    客户端没有权限使用该请求的响应类型。</span><br><span class="line">redirect_uri_mismatch</span><br><span class="line">    提供的重定向URI与预先注册的值不匹配。</span><br><span class="line">access_denied</span><br><span class="line">    终端用户或授权服务器拒绝了请求。</span><br><span class="line">unsupported_response_type</span><br><span class="line">    请求的响应类型不为授权服务器所支持。</span><br><span class="line">invalid_scope</span><br><span class="line">    请求的作用域是无效的、未知的，或格式不正确的。</span><br></pre></td></tr></table></figure><p>&emsp;&emsp;[[增加扩展错误码的机制]]</p><hr><h2 id="第五节-获取访问令牌"><a href="#第五节-获取访问令牌" class="headerlink" title="第五节 获取访问令牌"></a><strong>第五节 获取访问令牌</strong></h2><p>&emsp;&emsp;客户端通过在授权服务器上验证并出示它的访问许可（表示成授权码、资源拥有者私有证书、断言或刷新令牌的形式）来获取一个访问令牌。</p><p>&emsp;&emsp;既然对于令牌endpoint的请求会导致在HTTP请求和响应中传输明文证书，授权服务器必需要求在向令牌endpoint发送请求的时候使用传输层安全机制。服务器必需支持<a href="https://tools.ietf.org/id/draft-ietf-oauth-v2-11.html#RFC5246" title="Title" target="_blank" rel="noopener">[RFC5246]</a>所定义的TLS 1.2，并且可能支持额外的传输层安全机制。</p><p>&emsp;&emsp;客户端通过向令牌endpoint发送一个HTTP POST请求来获取一个访问令牌。令牌endpoint的位置能够在服务器文档中找到。令牌endpoint URI可能包含一个查询参数部分。</p><p>&emsp;&emsp;客户端通过在请求中添加客户端私有证书与授权服务器进行验证，如第3节所述。当客户端标识符不重要的时候（例如匿名客户端），或当客户端标识符通过其它方式确定的时候（例如使用一个断言访问许可），授权服务器可能允许不经验证的访问令牌请求。</p><p>&emsp;&emsp;客户端通过在HTTP请求的entity-body中使用“application/x-www-form-urlencoded”格式包含下列参数，来构建请求：</p><figure class="highlight d"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">grant_type</span><br><span class="line">    必需参数。在请求中所包含的访问许可类型。它的值必须是“authorization_code”、“password”、“refresh_token”、“client_credentials”或一个用来标识被授权服务器所支持的断言类型的绝对URI。</span><br><span class="line"><span class="keyword">scope</span></span><br><span class="line">    可选参数。访问请求的作用域，表达为一个由空格隔开的字符串列表。“<span class="keyword">scope</span>”参数的值由授权服务器定义。如果这个值包含多个空格隔开的字符串，那么它们的顺序不分先后，而且每个字符串都为请求的作用域增加一个新的访问范围。如果使用的访问许可已经代表了一个许可作用域（例如，授权码、断言），那么请求的作用域必须等于或少于之前许可的作用域，如果缺少这个参数就认为是等于之前的许可作用域。</span><br></pre></td></tr></table></figure><p>&emsp;&emsp;另外，对于5.1节列出的某个访问许可类型，客户端必须包含合适的参数。</p><p>&emsp;&emsp;没有值的参数必须被当做它们在请求中不存在一样。授权服务器应该忽略识别不了的请求参数。</p><h3 id="5-1-访问许可类型-Access-Grant-Types"><a href="#5-1-访问许可类型-Access-Grant-Types" class="headerlink" title="5.1 访问许可类型 Access Grant Types"></a><strong>5.1 访问许可类型 Access Grant Types</strong></h3><p>&emsp;&emsp;客户端使用一个授权码、资源拥有者密码证书、客户端私有证书、刷新令牌或断言来请求一个访问许可。</p><h4 id="5-1-1-授权码-Authorization-Code"><a href="#5-1-1-授权码-Authorization-Code" class="headerlink" title="5.1.1 授权码 Authorization Code"></a><strong>5.1.1 授权码 Authorization Code</strong></h4><p>&emsp;&emsp;客户端使用“authorization_code”访问许可类型和下列参数传入授权码：</p><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">code</span><br><span class="line">    必需参数。从授权服务器接收到的授权码。</span><br><span class="line">redirect_uri</span><br><span class="line">    必需参数。在最初请求中使用的重定向URI。</span><br></pre></td></tr></table></figure><p>&emsp;&emsp;例如，客户端通过如第3节所述的“client_secret”参数包含客户端私有证书，并使用传输层安全机制，来发送下列HTTP请求（换行符只用于显示目的）：</p><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">POST</span> <span class="string">/token</span> HTTP/1.1</span><br><span class="line"><span class="attribute">Host</span>: server.example.com</span><br><span class="line"><span class="attribute">Content-Type</span>: application/x-www-form-urlencoded</span><br><span class="line"></span><br><span class="line">grant_type=authorization_code&amp;client_id=s6BhdRkqt3&amp;</span><br><span class="line">client_secret=gX1fBat3bV&amp;code=i1WsRn1uB1&amp;</span><br><span class="line">redirect_uri=https%3A%2F%2Fclient%2Eexample%2Ecom%2Fcb</span><br></pre></td></tr></table></figure><p>&emsp;&emsp;授权服务器必须：</p><blockquote><ul><li>验证客户端私有证书（如果存在）并保证它们与授权码匹配。</li><li>验证授权码和重定向URI都是有效的，并且与存储的关联关系相匹配。</li></ul></blockquote><p>&emsp;&emsp;如果请求有效，授权服务器分发一个成功响应，如5.2节所述。</p><h4 id="5-1-2-资源拥有者密码证书-Resource-Owner-Password-Credentials"><a href="#5-1-2-资源拥有者密码证书-Resource-Owner-Password-Credentials" class="headerlink" title="5.1.2 资源拥有者密码证书 Resource Owner Password Credentials"></a><strong>5.1.2 资源拥有者密码证书 Resource Owner Password Credentials</strong></h4><p>&emsp;&emsp;客户端使用“password”访问许可类型和下列参数传入资源拥有者密码证书：[[增加对于用户名和密码的国际化考虑]]</p><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">username</span><br><span class="line">    必需参数。资源拥有者的用户名。</span><br><span class="line">password</span><br><span class="line">    必需参数。资源拥有者的密码。</span><br></pre></td></tr></table></figure><p>&emsp;&emsp;例如，客户端通过如第3节所述的“client_secret”参数包含客户端私有证书，并使用传输层安全机制，来发送下列HTTP请求（换行符只用于显示目的）：</p><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">POST</span> <span class="string">/token</span> HTTP/1.1</span><br><span class="line"><span class="attribute">Host</span>: server.example.com</span><br><span class="line"><span class="attribute">Content-Type</span>: application/x-www-form-urlencoded</span><br><span class="line"></span><br><span class="line">grant_type=password&amp;client_id=s6BhdRkqt3&amp;</span><br><span class="line">client_secret=47HDu8s&amp;username=johndoe&amp;password=A3ddj3w</span><br></pre></td></tr></table></figure><p>&emsp;&emsp;授权服务器必须验证客户端私有证书（如果存在）和终端用户私有证书，而且如果发现有效则必须发布一个访问令牌响应，如5.2节所述。</p><h4 id="5-1-3-客户端私有证书-Client-Credentials"><a href="#5-1-3-客户端私有证书-Client-Credentials" class="headerlink" title="5.1.3 客户端私有证书 Client Credentials"></a><strong>5.1.3 客户端私有证书 Client Credentials</strong></h4><p>&emsp;&emsp;客户端可以仅仅使用它的客户端私有证书来请求一个访问令牌，即使用“client_credentials”访问许可类型。当省略一个显式的访问许可时，客户端是在请求访问它所控制的受保护资源，或另一个资源拥有者之前与授权服务器约定好的受保护资源（约定方式不在本规范的规定范围之内）。</p><h4 id="5-1-4-刷新令牌-Refresh-Token"><a href="#5-1-4-刷新令牌-Refresh-Token" class="headerlink" title="5.1.4 刷新令牌 Refresh Token"></a><strong>5.1.4 刷新令牌 Refresh Token</strong></h4><p>&emsp;&emsp;客户端使用“refresh_token”访问许可类型和下列参数传入刷新令牌：</p><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">refresh_token</span><br><span class="line">    必需参数。与待刷新的访问令牌相关联的刷新令牌。</span><br></pre></td></tr></table></figure><p>&emsp;&emsp;例如，客户端通过如第3节所述的“client_secret”参数包含客户端私有证书，并使用传输层安全机制，来发送下列HTTP请求（换行符只用于显示目的）：</p><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">POST</span> <span class="string">/token</span> HTTP/1.1</span><br><span class="line"><span class="attribute">Host</span>: server.example.com</span><br><span class="line"><span class="attribute">Content-Type</span>: application/x-www-form-urlencoded</span><br><span class="line"></span><br><span class="line">grant_type=refresh_token&amp;client_id=s6BhdRkqt3&amp;</span><br><span class="line">client_secret=8eSEIpnqmM&amp;refresh_token=n4E9O119d</span><br></pre></td></tr></table></figure><p>&emsp;&emsp;授权服务器必须验证客户端私有证书（如果存在），验证刷新令牌是否有效，以及验证资源拥有者的授权是否仍然有效。如果请求有效，授权服务器则发布一个访问令牌响应，如5.2节所述。授权服务器可以发布一个新的刷新令牌，在这种情况下，客户端必须丢弃旧的刷新令牌并且用新的访问令牌替换。</p><h4 id="5-1-5-断言-Assertion"><a href="#5-1-5-断言-Assertion" class="headerlink" title="5.1.5 断言 Assertion"></a><strong>5.1.5 断言 Assertion</strong></h4><p>&emsp;&emsp;客户端使用一个绝对URI（由授权服务器定义）作为“grant_type”参数的值指定断言格式，并添加下列参数，来传入一个断言：</p><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">assertion</span><br><span class="line">    必需参数。断言。</span><br></pre></td></tr></table></figure><p>&emsp;&emsp;例如，客户端使用传输层安全机制来发送下列HTTP请求，且客户端验证通过断言来完成（换行符只用于显示目的）：</p><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">POST</span> <span class="string">/token</span> HTTP/1.1</span><br><span class="line"><span class="attribute">Host</span>: server.example.com</span><br><span class="line"><span class="attribute">Content-Type</span>: application/x-www-form-urlencoded</span><br><span class="line"></span><br><span class="line">grant_type=urn%3Aoasis%3Anames%3Atc%3ASAML%3A2.0%3Aassertion&amp;</span><br><span class="line">assertion=PHNhbWxwOl[...omitted for brevity...]ZT4%3D</span><br></pre></td></tr></table></figure><p>&emsp;&emsp;授权服务器必须验证客户端私有证书（如果存在）和断言，而且如果发现有效则必须发布一个访问令牌响应，如5.2节所述。授权服务器不应该分发一个刷新令牌（而是应该要求客户端使用相同的或新的断言）。</p><p>&emsp;&emsp;授权服务器应该分发具有有限生命周期的访问令牌，并且要求客户端使用仍然有效的同一个断言来请求新的访问令牌，从而完成对令牌的刷新。</p><h3 id="5-2-访问令牌响应-Access-Token-Response"><a href="#5-2-访问令牌响应-Access-Token-Response" class="headerlink" title="5.2 访问令牌响应 Access Token Response"></a><strong>5.2 访问令牌响应 Access Token Response</strong></h3><p>&emsp;&emsp;在接收到并验证过来自客户端的一个有效且经授权的访问令牌请求之后，授权服务器分发访问令牌和可选的刷新令牌，并且通过一个200（OK）状态码在HTTP响应的entity body中添加下列参数来构造响应：</p><p>&emsp;&emsp;令牌响应包含下列参数：</p><figure class="highlight lsl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">access_token</span><br><span class="line">    必需参数。由授权服务器分发的访问令牌。</span><br><span class="line">token_type</span><br><span class="line">    必需参数。分发的令牌类型。令牌类型告诉客户端一个信息，即当访问一个受保护资源时访问令牌应该如何被使用，如<span class="number">6.1</span>节所述。</span><br><span class="line">expires_in</span><br><span class="line">    可选参数。访问令牌生命周期的秒数。例如，“<span class="number">3600</span>”表示自响应被授权服务器产生的时刻起，访问令牌将在一小时后过期。</span><br><span class="line">refresh_token</span><br><span class="line">    可选参数。用来获取新的访问令牌的刷新令牌，如<span class="number">5.1</span><span class="number">.4</span>节所述使用相同的终端用户访问许可。当访问许可类型是一个断言或一个客户端私有证书集合时，授权服务器不应该分发一个刷新令牌。</span><br><span class="line">scope</span><br><span class="line">    可选参数。访问令牌的作用域，表示为一个空格隔开的字符串列表。“scope”参数的值由授权服务器定义。如果这个值包含多个空格隔开的字符串，那么它们的顺序不分先后，而且每个字符串都为请求的作用域增加一个新的访问范围。如果请求到的作用域不同于客户端申请的作用域，授权服务器应该传回这个参数。</span><br></pre></td></tr></table></figure><p>&emsp;&emsp;参数包含在HTTP响应的entity body中，使用<a href="https://tools.ietf.org/id/draft-ietf-oauth-v2-11.html#RFC4627" title="Title" target="_blank" rel="noopener">[RFC4627]</a>定义的“application/json”媒体类型。通过在最高结构层次上添加每个参数，将它们序列化成一个JSON结构。参数名和字符串值都表示成JSON字符串。数字值表示成JSON数字。</p><p>&emsp;&emsp;在任何包含令牌、密钥或其它敏感信息的响应中，授权服务器必须在“Cache-Control”响应头部字段中传入一个“no-store”的值。</p><p>&emsp;&emsp;例如：</p><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">HTTP/1.1 <span class="number">200</span> OK</span><br><span class="line"><span class="attribute">Content-Type</span>: application/json</span><br><span class="line"><span class="attribute">Cache-Control</span>: no-store</span><br><span class="line"></span><br><span class="line">&#123;</span><br><span class="line">  "access_token":"SlAV32hkKG",</span><br><span class="line">  "token_type":"example",</span><br><span class="line">  "expires_in":3600,</span><br><span class="line">  "refresh_token":"8xLOxBtZp8"</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>&emsp;&emsp;客户端应该忽略无法识别的响应参数。从授权服务器接收到的令牌和其它参数值的大小，本规范未作定义。客户端应该避免对参数值大小做任何假设。服务器应该对它们所分发的任何参数值的期望大小做出文档说明。</p><h3 id="5-3-错误响应-Error-Response"><a href="#5-3-错误响应-Error-Response" class="headerlink" title="5.3 错误响应 Error Response"></a><strong>5.3 错误响应 Error Response</strong></h3><p>&emsp;&emsp;如果令牌请求是无效的或未经授权的，授权服务器通过在HTTP响应的entity body中添加下列参数并使用“application/json”媒体类型来构造响应：</p><figure class="highlight subunit"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">error</span><br><span class="line">    必需参数。如4.3.1节所述的一个错误码。</span><br><span class="line">error_description</span><br><span class="line">    可选参数。提供额外信息的一段人类可读的文字，用来帮助理解和解决发生的错误。</span><br><span class="line">error_uri</span><br><span class="line">    可选参数。指明了一个人类可读的网页URI，带有关于错误的信息，用来为终端用户提供与错误有关的额外信息。</span><br></pre></td></tr></table></figure><p>&emsp;&emsp;例如：</p><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">HTTP/1.1 <span class="number">400</span> Bad Request</span><br><span class="line"><span class="attribute">Content-Type</span>: application/json</span><br><span class="line"><span class="attribute">Cache-Control</span>: no-store</span><br><span class="line"></span><br><span class="line">&#123;</span><br><span class="line">  "error":"invalid_request"</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>&emsp;&emsp;如果客户端通过“Authorization”请求头部字段使用HTTP验证机制这种方式提供了无效的私有证书，那么授权服务器必须用HTTP 401（Unauthorized）状态码进行响应。否则，授权服务器应该用HTTP 400（Bad Request）状态码进行响应。</p><h4 id="5-3-1-错误码-Error-Codes"><a href="#5-3-1-错误码-Error-Codes" class="headerlink" title="5.3.1 错误码 Error Codes"></a><strong>5.3.1 错误码 Error Codes</strong></h4><p>&emsp;&emsp;授权服务器在错误响应中传回下列错误码之一：</p><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">invalid_request</span><br><span class="line">    请求缺少某个必需参数，包含一个不支持的参数或参数值，参数重复，包含多个私有证书，使用了多种验证客户端的机制，或者请求格式不正确。</span><br><span class="line">invalid_client</span><br><span class="line">    提供的客户端标识符是无效的，客户端验证失败，客户端不包含私有证书，提供了多个客户端私有证书，或使用了不支持的证书类型。</span><br><span class="line">unauthorized_client</span><br><span class="line">    经过验证的客户端没有权限使用提供的访问许可类型。</span><br><span class="line">invalid_grant</span><br><span class="line">    提供的访问许可是无效的、过期的或已撤销的（例如，无效的断言，过期的授权令牌，错误的终端用户密码证书，或者不匹配的授权码和重定向URI）。</span><br><span class="line">unsupported_grant_type</span><br><span class="line">    包含的访问许可——它的类型或其它属性——不被授权服务器所支持。</span><br><span class="line">invalid_scope</span><br><span class="line">    请求的作用域是无效的、未知的、格式不正确的，或超出了之前许可的作用域。</span><br></pre></td></tr></table></figure><p>&emsp;&emsp;[[增加扩展错误码的机制]]</p><hr><h2 id="第六节-访问受保护资源-Accessing-a-Protected-Resource"><a href="#第六节-访问受保护资源-Accessing-a-Protected-Resource" class="headerlink" title="第六节 访问受保护资源 Accessing a Protected Resource"></a><strong>第六节 访问受保护资源 Accessing a Protected Resource</strong></h2><p>&emsp;&emsp;客户端通过向资源服务器出示一个访问令牌来访问受保护资源。资源服务器必须验证访问令牌，保证它没有过期并且它的作用域覆盖了请求的资源。被资源服务器用来验证访问令牌的方式不在本规范的规定范围之内，但是它通常需要在资源服务器和授权服务器之间进行交互或配合。</p><p>&emsp;&emsp;客户端利用访问令牌来验证资源服务器的方式取决于由授权服务器分发的访问令牌类型。</p><h3 id="6-1-访问令牌类型-Access-Token-Types"><a href="#6-1-访问令牌类型-Access-Token-Types" class="headerlink" title="6.1 访问令牌类型 Access Token Types"></a><strong>6.1 访问令牌类型 Access Token Types</strong></h3><p>&emsp;&emsp;[[增加令牌类型的解释，可能包含指定其它规范的链接]]</p><h3 id="6-2-WWW-Authenticate响应头部字段-The-WWW-Authenticate-Response-Header-Field"><a href="#6-2-WWW-Authenticate响应头部字段-The-WWW-Authenticate-Response-Header-Field" class="headerlink" title="6.2 WWW-Authenticate响应头部字段 The WWW-Authenticate Response Header Field"></a><strong>6.2 WWW-Authenticate响应头部字段 The WWW-Authenticate Response Header Field</strong></h3><p>&emsp;&emsp;如果对于受保护资源的请求不包含验证证书，包含一个无效的访问令牌，或格式不正确，那么资源服务器必须包含一个HTTP “WWW-Authenticate”响应头部字段。这个“WWW-Authenticate”头部字段使用<a href="https://tools.ietf.org/id/draft-ietf-oauth-v2-11.html#RFC2617" title="Title" target="_blank" rel="noopener">[RFC2617]</a>定义的框架，如下所示：</p><figure class="highlight stata"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">challenge       = <span class="string">"OAuth2"</span> [ RWS 1#param ]</span><br><span class="line"></span><br><span class="line">param           = scope /</span><br><span class="line">                  <span class="keyword">error</span> / <span class="keyword">error</span>-<span class="keyword">desc</span> / <span class="keyword">error</span>-uri /</span><br><span class="line">                  ( <span class="keyword">token</span> <span class="string">"="</span> ( <span class="keyword">token</span> / quoted-string ) )</span><br><span class="line"></span><br><span class="line">scope           = <span class="string">"scope"</span> <span class="string">"="</span> &lt;<span class="string">"&gt; scope-v *( SP scope-v ) &lt;"</span>&gt;</span><br><span class="line">scope-v         = 1*quoted-<span class="built_in">char</span></span><br><span class="line"></span><br><span class="line">quoted-<span class="keyword">char</span>     = <span class="keyword">ALPHA</span> / DIGIT /</span><br><span class="line">                  <span class="string">"!"</span> / <span class="string">"#"</span> / <span class="string">"$"</span> / <span class="string">"%"</span> / <span class="string">"&amp;"</span> / <span class="string">"'"</span> / <span class="string">"("</span> / <span class="string">")"</span> /</span><br><span class="line">                  <span class="string">"*"</span> / <span class="string">"+"</span> / <span class="string">"-"</span> / <span class="string">"."</span> / <span class="string">"/"</span> / <span class="string">":"</span> / <span class="string">"&lt;"</span> / <span class="string">"="</span> /</span><br><span class="line">                  <span class="string">"&gt;"</span> / <span class="string">"?"</span> / <span class="string">"@"</span> / <span class="string">"["</span> / <span class="string">"]"</span> / <span class="string">"^"</span> / <span class="string">"_"</span> / <span class="string">"`"</span> /</span><br><span class="line">                  <span class="string">"&#123;"</span> / <span class="string">"|"</span> / <span class="string">"&#125;"</span> / <span class="string">"~"</span> / <span class="string">"\"</span> / <span class="string">","</span> / <span class="string">";"</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">error</span>           = <span class="string">"error"</span> <span class="string">"="</span> quoted-<span class="built_in">string</span></span><br><span class="line"><span class="keyword">error</span>-<span class="keyword">desc</span>      = <span class="string">"error_description"</span> <span class="string">"="</span> quoted-<span class="built_in">string</span></span><br><span class="line"><span class="keyword">error</span>-uri       = <span class="string">"error_uri"</span> = &lt;<span class="string">"&gt; URI-reference &lt;"</span>&gt;</span><br></pre></td></tr></table></figure><p>&emsp;&emsp;“scope”属性是一个空格隔开的作用域值的列表，表明了为了访问受保护资源所需要访问令牌作用域。“scope”属性一定不能出现多次。</p><p>&emsp;&emsp;如果对于受保护资源的请求包含一个访问令牌并且验证失败了，那么资源服务器应该包含“error”属性来向客户端提供为何访问请求被拒绝的原因。参数值在6.2.1中描述。另外，资源服务器可能包含“error_description”属性来提供一个人类可读的解释，或者包含“error-uri”属性用一个绝对URI来指定一个用于解释错误的人类可读的网页。“error”、“error_description”和“error-uri”属性一定不能出现多次。</p><p>&emsp;&emsp;例如，对于一个缺少验证的受保护资源请求的响应：</p><figure class="highlight http"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">HTTP/1.1 <span class="number">401</span> Unauthorized</span><br><span class="line"><span class="attribute">WWW-Authenticate</span>: OAuth2</span><br></pre></td></tr></table></figure><p>&emsp;&emsp;对于一个使用过期访问令牌尝试验证的受保护资源请求的响应：</p><figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">HTTP/1.1 401 Unauthorized</span><br><span class="line">WWW-Authenticate: OAuth2</span><br><span class="line">                  <span class="attribute">error</span>=<span class="string">"invalid_token"</span>,</span><br><span class="line">                  <span class="attribute">error_description</span>=<span class="string">"The access token expired"</span></span><br></pre></td></tr></table></figure><h4 id="6-2-1-错误码-Error-Codes"><a href="#6-2-1-错误码-Error-Codes" class="headerlink" title="6.2.1 错误码 Error Codes"></a><strong>6.2.1 错误码 Error Codes</strong></h4><p>&emsp;&emsp;当一个请求失败时，资源服务器使用恰当的HTTP状态码（典型的如400、401或403）进行响应，并且在响应中包含下列错误码之一：</p><figure class="highlight lsl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">invalid_request</span><br><span class="line">    请求缺少某个必需参数，包含一个不支持的参数或参数值，参数重复，使用多种方式包含访问令牌，或者请求格式不正确。资源服务器应该使用HTTP <span class="number">400</span>（Bad Request）状态码进行响应。</span><br><span class="line">invalid_token</span><br><span class="line">    提供的访问令牌是过期的、已撤销的、格式不正确的，或由于其它原因是无效的。资源服务器应该使用HTTP <span class="number">401</span>（Unauthorized）状态码进行响应。客户端可能请求一个新的访问令牌并重试受保护资源请求。</span><br><span class="line">insufficient_scope</span><br><span class="line">    请求需要比访问令牌所提供的权限更高的权限。资源服务器应该使用HTTP <span class="number">403</span>（Forbidden）状态码进行响应并且包含“scope”属性，带上访问该受保护资源必需的作用域。</span><br></pre></td></tr></table></figure><p>&emsp;&emsp;[[增加扩展错误码的机制]]</p><p>&emsp;&emsp;如果请求中缺少任何验证信息（即客户端没有意识到验证是必需的或尝试使用一个不支持的验证方法），那么资源服务器不应该包含一个错误码和其它错误信息。</p><p>&emsp;&emsp;例如：</p><figure class="highlight http"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">HTTP/1.1 <span class="number">401</span> Unauthorized</span><br><span class="line"><span class="attribute">WWW-Authenticate</span>: OAuth2</span><br></pre></td></tr></table></figure><hr><h2 id="第七节-扩展-Extensibility"><a href="#第七节-扩展-Extensibility" class="headerlink" title="第七节 扩展 Extensibility"></a><strong>第七节 扩展 Extensibility</strong></h2><h3 id="7-1-定义新的客户端证书类型-Defining-New-Client-Credentials-Types"><a href="#7-1-定义新的客户端证书类型-Defining-New-Client-Credentials-Types" class="headerlink" title="7.1 定义新的客户端证书类型 Defining New Client Credentials Types"></a><strong>7.1 定义新的客户端证书类型 Defining New Client Credentials Types</strong></h3><p>&emsp;&emsp;[[待定]]</p><h3 id="7-2-定义新的Endpoint参数-Defining-New-Endpoint-Parameters"><a href="#7-2-定义新的Endpoint参数-Defining-New-Endpoint-Parameters" class="headerlink" title="7.2 定义新的Endpoint参数 Defining New Endpoint Parameters"></a><strong>7.2 定义新的Endpoint参数 Defining New Endpoint Parameters</strong></h3><p>&emsp;&emsp;希望在终端用户授权endpoint和令牌endpoint上定义新的请求和响应参数的应用，应该使用下列两种方式之一：在参数注册表中注册（遵从9.1节描述的流程），或使用“x_”参数名前缀。</p><p>&emsp;&emsp;使用“x_”参数名前缀的参数必须局限于那些不会被广泛应用的针对厂商特性的扩展，并且特定于授权服务器使用场景的实现细节。所有其它参数必须被注册，并且一定不能使用“x_”参数名前缀。</p><p>&emsp;&emsp;参数名必须遵从param-name的ABNF，并且参数值语法必须被规范地定义（例如，使用ABNF，或者引用到现存参数的语法）。</p><figure class="highlight abnf"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="attribute">param-name</span>  = <span class="number">1</span>*name-char</span><br><span class="line"><span class="attribute">name-char</span>   = <span class="string">"-"</span> / <span class="string">"."</span> / <span class="string">"_"</span> / <span class="keyword">DIGIT</span> / <span class="keyword">ALPHA</span></span><br></pre></td></tr></table></figure><h3 id="7-3-定义新的头部字段参数-Defining-New-Header-Field-Parameters"><a href="#7-3-定义新的头部字段参数-Defining-New-Header-Field-Parameters" class="headerlink" title="7.3 定义新的头部字段参数 Defining New Header Field Parameters"></a><strong>7.3 定义新的头部字段参数 Defining New Header Field Parameters</strong></h3><p>&emsp;&emsp;希望在OAuth “WWW-Authenticate”头部字段中定义新参数的应用必须在参数注册表中进行注册，遵从9.1节描述的流程。</p><p>&emsp;&emsp;参数名必须遵从param-name的ABNF并且不能以“x_”开头。参数值必须遵从param-value的ABNF并且语法必须被规范地定义（例如，使用ABNF，或者引用到现存参数的语法）。</p><figure class="highlight livecodeserver"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">param</span>-<span class="built_in">value</span> = quoted-<span class="built_in">value</span> | quoted-<span class="keyword">string</span></span><br></pre></td></tr></table></figure><h3 id="7-4-定义新的访问许可类型-Defining-New-Access-Grant-Types"><a href="#7-4-定义新的访问许可类型-Defining-New-Access-Grant-Types" class="headerlink" title="7.4 定义新的访问许可类型 Defining New Access Grant Types"></a><strong>7.4 定义新的访问许可类型 Defining New Access Grant Types</strong></h3><p>&emsp;&emsp;断言访问许可类型允许授权服务器接受其它未规定的访问许可。希望定义其它访问许可类型的应用能够通过利用新的或现存的断言类型和格式进行实现。</p><hr><h2 id="第八节-安全考虑-Security-Considerations"><a href="#第八节-安全考虑-Security-Considerations" class="headerlink" title="第八节 安全考虑 Security Considerations"></a><strong>第八节 安全考虑 Security Considerations</strong></h2><p>&emsp;&emsp;[[待定]]</p><hr><h2 id="第九节-IANA事项-IANA-Considerations"><a href="#第九节-IANA事项-IANA-Considerations" class="headerlink" title="第九节 IANA事项 IANA Considerations"></a><strong>第九节 IANA事项 IANA Considerations</strong></h2><h3 id="9-1-OAuth参数注册表-The-OAuth-Parameters-Registry"><a href="#9-1-OAuth参数注册表-The-OAuth-Parameters-Registry" class="headerlink" title="9.1 OAuth参数注册表 The OAuth Parameters Registry"></a><strong>9.1 OAuth参数注册表 The OAuth Parameters Registry</strong></h3><p>&emsp;&emsp;本文档设立参数注册表。</p><p>&emsp;&emsp;用于终端用户授权endpoint的请求、终端用户授权endpoint的响应、令牌endpoint的请求、令牌endpoint的响应或“WWW-Authenticate”头部字段的多余参数，在一个或多个“指派专家”（由IESG或他们的代理机构指定）的指导下进行注册，遵从所需的规范（使用[RFC5226]的术语）。然而，为了允许在发布之前对值进行分配，“指派专家”们一旦认同这样的一个规范能够发布，可能就立即批准注册。</p><p>&emsp;&emsp;注册请求应该发送给[待定]@ietf.org邮件组进行评审和讨论，使用恰当的标题（如“Request for parameter: example”）。[[RFC-EDITOR注解：邮件组名称应该在与IESG和IANA磋商后确定。建议名称：oauth-ext-review。]]</p><p>&emsp;&emsp;在14天之内，“指派专家”们会批准或拒绝注册请求，并将结果告知邮件组和IANA。拒绝的决定应该包含一个解释，并且，如果可行的话，应该包含如何进行修改的建议。在21天以上未确定的注册请求会交由IESG处理（使用<a href="mailto:iesg@iesg.org" target="_blank" rel="noopener">iesg@iesg.org</a>邮件组）。</p><h4 id="9-1-1-注册模板-Registration-Template"><a href="#9-1-1-注册模板-Registration-Template" class="headerlink" title="9.1.1 注册模板 Registration Template"></a><strong>9.1.1 注册模板 Registration Template</strong></h4><figure class="highlight gams"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">Parameter</span> name: 请求的名称（例如“example”）。</span><br><span class="line"><span class="keyword">Parameter</span> <span class="comment">usage location:</span> 参数能够被使用的位置。可能的位置包括：终端用户授权<span class="comment">endpoint</span>的请求、终端用户授权<span class="comment">endpoint</span>的响应、令牌<span class="comment">endpoint</span>的请求、令牌<span class="comment">endpoint</span>的响应或“<span class="comment">WWW-Authenticate</span>”头部字段。</span><br><span class="line">Change <span class="comment">controller:</span> 对于标准轨道的<span class="comment">RFC</span>，写明“<span class="comment">IETF</span>”。对于其它规范，使用负责机构的名称。其它细节（例如，邮编地址，电子邮件地址，主页<span class="comment">URI</span>）也可以包含。</span><br><span class="line">Specification <span class="comment">document(s):</span> 对规定参数的文档引用，可取的方式是包含一个能够获取到文档拷贝的<span class="comment">URI</span>。对于相关章节的标示也可以包含</span><br><span class="line">Related <span class="comment">information:</span></span><br><span class="line">Optionally, citations <span class="comment">to additional documents containing further relevant information.</span></span><br></pre></td></tr></table></figure><p>&emsp;&emsp;未完待续。</p><hr><p><em>参考博客和文章书籍等：</em></p><blockquote><p><a href="https://tools.ietf.org/id/draft-ietf-oauth-v2-11.html" title="Title" target="_blank" rel="noopener">The OAuth 2.0 Protocol Framework</a></p></blockquote><p><em>因博客主等未标明不可引用，若部分内容涉及侵权请及时告知，我会尽快修改和删除相关内容</em></p>]]></content>
    
    <summary type="html">
    
      The OAuth 2.0 Protocol Framework文档翻译，内容包括：引文（符号规范、技术术语、概述、访问许可），Client Profiles（Web Server、User-Agent、原生程序、自治态），客户端私有证书（客户端密码证书、客户端断言证书），获得终端用户授权（授权请求、授权响应、错误响应），获取访问令牌（访问许可类型、访问令牌响应、错误响应），访问受保护资源（访问令牌类型、WWW-Authenticate响应头部字段），扩展（定义新的客户端证书类型、定义新的Endpoint参数、定义新的头部字段参数、定义新的访问许可类型），安全考虑，IANA事项等。
    
    </summary>
    
      <category term="技术文档" scheme="http://linyishui.top/categories/%E6%8A%80%E6%9C%AF%E6%96%87%E6%A1%A3/"/>
    
    
      <category term="oauth2" scheme="http://linyishui.top/tags/oauth2/"/>
    
  </entry>
  
  <entry>
    <title>Spring Cloud-Zuul API网关</title>
    <link href="http://linyishui.top/2019111401.html"/>
    <id>http://linyishui.top/2019111401.html</id>
    <published>2019-11-14T09:35:25.000Z</published>
    <updated>2019-12-23T09:38:33.504Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="Spring-Cloud-Zuul-API网关"><a href="#Spring-Cloud-Zuul-API网关" class="headerlink" title="Spring Cloud-Zuul API网关"></a><strong>Spring Cloud-Zuul API网关</strong></h1><h2 id="第一节"><a href="#第一节" class="headerlink" title="第一节 "></a><strong>第一节 </strong></h2><p>&emsp;&emsp;</p><hr><p><em>参考博客和文章书籍等：</em></p><blockquote><p>《Spring Cloud微服务-入门、实战和进阶》</p></blockquote><p><em>因博客主等未标明不可引用，若部分内容涉及侵权请及时告知，我会尽快修改和删除相关内容</em></p>]]></content>
    
    <summary type="html">
    
      Spring Cloud Zuul API网关
    
    </summary>
    
      <category term="技术文档" scheme="http://linyishui.top/categories/%E6%8A%80%E6%9C%AF%E6%96%87%E6%A1%A3/"/>
    
    
      <category term="spring cloud" scheme="http://linyishui.top/tags/spring-cloud/"/>
    
  </entry>
  
  <entry>
    <title>Spring Cloud-Hystrix 服务容错处理</title>
    <link href="http://linyishui.top/2019111301.html"/>
    <id>http://linyishui.top/2019111301.html</id>
    <published>2019-11-13T09:35:16.000Z</published>
    <updated>2019-12-23T09:38:22.159Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="Spring-Cloud-Hystrix-服务容错处理"><a href="#Spring-Cloud-Hystrix-服务容错处理" class="headerlink" title="Spring Cloud-Hystrix 服务容错处理"></a><strong>Spring Cloud-Hystrix 服务容错处理</strong></h1><h2 id="第一节"><a href="#第一节" class="headerlink" title="第一节 "></a><strong>第一节 </strong></h2><p>&emsp;&emsp;</p><hr><p><em>参考博客和文章书籍等：</em></p><blockquote><p>《Spring Cloud微服务-入门、实战和进阶》</p></blockquote><p><em>因博客主等未标明不可引用，若部分内容涉及侵权请及时告知，我会尽快修改和删除相关内容</em></p>]]></content>
    
    <summary type="html">
    
      Spring Cloud Hystrix 服务容错处理
    
    </summary>
    
      <category term="技术文档" scheme="http://linyishui.top/categories/%E6%8A%80%E6%9C%AF%E6%96%87%E6%A1%A3/"/>
    
    
      <category term="spring cloud" scheme="http://linyishui.top/tags/spring-cloud/"/>
    
  </entry>
  
  <entry>
    <title>Spring Cloud-Feign 声明式REST客户端</title>
    <link href="http://linyishui.top/2019111201.html"/>
    <id>http://linyishui.top/2019111201.html</id>
    <published>2019-11-12T09:35:08.000Z</published>
    <updated>2019-12-23T09:38:12.833Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="Spring-Cloud-Feign-声明式REST客户端"><a href="#Spring-Cloud-Feign-声明式REST客户端" class="headerlink" title="Spring Cloud-Feign 声明式REST客户端"></a><strong>Spring Cloud-Feign 声明式REST客户端</strong></h1><h2 id="第一节"><a href="#第一节" class="headerlink" title="第一节 "></a><strong>第一节 </strong></h2><p>&emsp;&emsp;</p><hr><p><em>参考博客和文章书籍等：</em></p><blockquote><p>《Spring Cloud微服务-入门、实战和进阶》</p></blockquote><p><em>因博客主等未标明不可引用，若部分内容涉及侵权请及时告知，我会尽快修改和删除相关内容</em></p>]]></content>
    
    <summary type="html">
    
      Spring Cloud Feign 声明式REST客户端
    
    </summary>
    
      <category term="技术文档" scheme="http://linyishui.top/categories/%E6%8A%80%E6%9C%AF%E6%96%87%E6%A1%A3/"/>
    
    
      <category term="spring cloud" scheme="http://linyishui.top/tags/spring-cloud/"/>
    
  </entry>
  
</feed>
