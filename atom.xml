<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>俺的部落格</title>
  
  <subtitle>俺寻思俺需要记点东西</subtitle>
  <link href="http://linyishui.top/atom.xml" rel="self"/>
  
  <link href="http://linyishui.top/"/>
  <updated>2022-06-19T13:47:24.451Z</updated>
  <id>http://linyishui.top/</id>
  
  <author>
    <name>Lys</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>英语-阅读</title>
    <link href="http://linyishui.top/2022050301.html"/>
    <id>http://linyishui.top/2022050301.html</id>
    <published>2022-05-03T13:47:22.000Z</published>
    <updated>2022-06-19T13:47:24.451Z</updated>
    
    <content type="html"><![CDATA[<h1 id="阅读"><a href="#阅读" class="headerlink" title="阅读"></a>阅读</h1><h2 id="综合"><a href="#综合" class="headerlink" title="综合"></a>综合</h2><ul><li>阅读考试时长：1小时</li><li>三篇文章，每篇长度在1000 ~ 1200个单词，总共40道题，每篇在12 ~ 14不等。</li><li>不涉及具体语法、词汇的专项题型，只考察综合阅读能力</li></ul><p>考察方面：</p><ul><li>把握复杂句子结构</li><li>猜测词义</li><li>把握文章结构</li><li>快速浏览文章（Skimming）</li><li>扫描特定信息（Scanning）</li></ul><p>打分：</p><table><thead><tr><th align="center">正确题目数</th><th align="center">分值</th></tr></thead><tbody><tr><td align="center">40</td><td align="center">9</td></tr><tr><td align="center">38-39</td><td align="center">8.5</td></tr><tr><td align="center">35-37</td><td align="center">8</td></tr><tr><td align="center">33-34</td><td align="center">7.5</td></tr><tr><td align="center">30-31</td><td align="center">7</td></tr><tr><td align="center">27-29</td><td align="center">6.5</td></tr><tr><td align="center">23-25</td><td align="center">6</td></tr><tr><td align="center">20-22</td><td align="center">5.5</td></tr><tr><td align="center">15-19</td><td align="center">5</td></tr><tr><td align="center">12-14</td><td align="center">4.5</td></tr><tr><td align="center">10-11</td><td align="center">4</td></tr></tbody></table><h2 id="阅读真经笔记"><a href="#阅读真经笔记" class="headerlink" title="阅读真经笔记"></a>阅读真经笔记</h2><h3 id="一-总纲"><a href="#一-总纲" class="headerlink" title="一. 总纲"></a>一. 总纲</h3><ul><li>阅读先看题，定位快寻觅，<ul><li>第二章，阅读的基本原则，正确的阅读顺序和方法可以提高速度。</li></ul></li><li>两种题后做，优先细节题，</li><li>同义替换多，单词有灵犀。<ul><li>讲解原文和题目的同义替换原理，第三章提高做题的正确率。</li><li>第四章开始分题型讲解做题技巧。</li></ul></li><li>填词有规律，前后找痕迹，<ul><li>填词题有四种衍生形式，原理一样，第四章。</li></ul></li><li>并列需细查，生词不用疑，</li><li>难度为中等，变幻四种体。</li><li>填表填图题，一见笑眯眯，<ul><li>第九章，该题型难度最低，出现概率最小，解题原理与填词题相似。</li></ul></li><li>顺藤能摸瓜，按图可索骥，</li><li>答案常集中，原是送分题。</li><li>段落选标题，连锁不简单，<ul><li>题型较难，容易连锁错误，第六章。</li></ul></li><li>段中找两点，中心藏后边。</li><li>判断实不难，真假未提及，<ul><li>句子判断题，题量较大，第五章讲解命题思路。</li></ul></li><li>末题少驳斥，首题少NG。</li><li>我有七种意，天下剑桥题。</li><li>多选找并列，单选是TRUE题,<ul><li>第八章，单选多选原理都可以推敲。</li></ul></li><li>如遇选标题，末段加大意。</li><li>匹配乱序多，定位找同义，<ul><li>匹配题考查定位能力，第七章。</li></ul></li><li>段落含信息，小心有NB。</li><li>莫夸境界高，无招胜有招，<ul><li>第十章为备考计划。</li></ul></li><li>三剑已合璧，笑看雅思谜。</li></ul><h3 id="二-阅读的基本原则"><a href="#二-阅读的基本原则" class="headerlink" title="二. 阅读的基本原则"></a>二. 阅读的基本原则</h3><ul><li>雅思考题的设计核心思想：学语言的目的是为了交流 Communication</li><li>托福考题的设计核心思想：英语听说读写的综合实践运用 Integration</li></ul><p>雅思阅读要点：</p><ol><li>找到顺序感</li><li>学会定位词</li><li>正确的阅读方法</li></ol><p>雅思阅读文章后有2~4种题型，正常有13道题目，3篇文章组成40道题。</p><p>出题顺序则有两种：</p><ol><li>各题型按原文顺序安排</li><li>各题型乱序组合</li></ol><p>顺序出题的做题步骤：读完即做完，但该类出现概率不高。</p><ol><li>看文章标题；</li><li>看文章后题型组合；</li><li>记忆的定位词；</li><li>回到原文开始快速阅读，注意同义词。找到后停止往下阅读，精读前文并查找答案。</li><li>持续步骤4。</li></ol><p>乱序的题型，如果按照顺序做题，会导致重读，比较耗时。</p><ul><li><strong>定位词</strong>：keywords，是题目中的单词，代表该题的特点，通过其可以快速定位到原文出处。</li><li>分类：<ul><li>特殊词汇：题目中出现的数字、大写、特殊符号、长相怪异的词</li><li>朴素词汇：简单、具体的词（好理解、容易记、同义词少）</li><li>逻辑词汇：表示重要的语法</li></ul></li><li>定位词的选择：<ol><li>快速定位。</li><li>唯一定位。</li><li>组合定位。</li></ol></li></ul><p>影响阅读方式的主要因素是题型：<strong>两种题后做，优先细节题</strong></p><ul><li>如段落中心题和段落信息匹配题，都是针对全文出题。</li><li>可以先处理每个自然段的其他细节题目，如Summary、T/F/NG。</li><li>读完一个自然段，处理完相关题目后再处理针对全文的题型。</li></ul><blockquote><p>总结：</p><ol><li>拿到套题后，先看三篇文章标题，判断难易度，用来分配考试时间。</li><li>先看标题，再看题型分布组合。</li><li>当段落中心和匹配题作为第一道出现时，读文章段落后优先完成后面题型。</li><li>画出题型的定位词，方便回到原文定位。</li></ol></blockquote><p>除了难题外，一遍读完，题目做完。雅思阅读量大（2700词左右），时间短（60分钟），文章中总有自然段不出题（无效信息）。</p><h3 id="三-原文和题目的同义替换原理"><a href="#三-原文和题目的同义替换原理" class="headerlink" title="三. 原文和题目的同义替换原理"></a>三. 原文和题目的同义替换原理</h3><p><strong>同义替换</strong>是唯一的阅读出题方式。</p><p>只要有题目就会有题干，题干的单词来自于原文或原文的同义替换。如题干有most，原文一定有most或majority等。题干中有最高级，原文就一定有对应。题干中有并列结构，题干也一定有并列关系。</p><p>同义替换的三种常见手法：</p><ul><li>同义词设计：               80%</li><li>双重反义词设计：       10%</li><li>对原文思想归纳总结：10%</li></ul><p>同义词设计：</p><ul><li>题型：TRUE/FALSE/NOT GIVEN（判断题）</li><li>题目：<strong>Feeding increasing</strong> populations is possible <strong>due primarily to improved</strong> irrigation systems.</li><li>原文：<strong>Food production</strong> has kept pace with <strong>soaring</strong> populations <strong>mainly because of</strong> the <strong>expansion</strong> of  artificial irrigation systems that make possible the growth of 40% of the world’s food.</li><li>feeding来自原文中的food production；increasing来自<br>soaring；due to来自because of；primarily来自mainly；improved来自expansiono；</li><li>答案是YES。</li></ul><p>双重反义词设计：</p><ul><li>题型：Paragraph Matching（段落信息匹配）</li><li>题目：How <strong>early mammals avoided dying out</strong></li><li>原文：…In the time when the dinosaurs dominated the daytime economy, our <strong>mammalian ancestors</strong> probably only <strong>managed</strong> to <strong>survive</strong> at all because they found ways of scraping a living at night…</li><li>early一词的含义来自原文ancestors（祖先）；avoid（避免，没有做）的反义词是 manage to do （成功地做了）；die out（灭绝）的反义词是survive（幸存）。</li><li>题干是双重反义表达原文同义的设计。</li></ul><p>对原文思想归纳总结：</p><ul><li><p>题型：Multiple Choice（选择题）</p></li><li><p>题目：What is the writer doing in paragraph C?</p><ul><li>A supporting other research</li><li>B making a proposal</li><li>C rejecting a common belief</li><li>D describing limitations</li></ul></li><li><p>原文：</p><blockquote><p>C In spite of its importance to our emotional and sensory lives, smell is probably the most<br><strong>undervalued sense in many cultures</strong>. The reason often given for the <strong>low regard</strong> in which smell<br>is held is that, in comparison with its importance among animals, the human sense of smell is<br>feeble and undeveloped. <strong>While it is true that</strong> the olfactory powers of humans are nothing like as<br>fine as those possessed by certain animals, <strong>they are still</strong> remarkably acute. Our noses are able to<br>recognise thousands of smells, and to perceive odours which are present only in extremely small<br>quantities.</p></blockquote></li><li><p>答案是c，选项rejecting a common belief。</p></li><li><p>注意C选项中的几个单词原文中没有出现，也没有明显的同义词。如果读懂C段大意，会发现”在许多文化中人们低估了嗅觉这种感知”就是一种common belief。common一词=in many cultures；belief指的是嗅觉的low regard。</p></li><li><p>rejecting（反驳）一词是来自一个句型：While it is true that…, they are still…这是一个让步转折：”虽然（你说的有一定道理），但是（我还是要反驳你）。”雅思命题者通过这个句子归纳总结出了reject这个单词。</p></li><li><p>归纳题是难题。</p></li></ul><p>原文标注法：（不适用机考）</p><ol><li>双下划线画出题目定位词在原文位置。</li><li>尽可能找出题干所有单词在原文的同义词出处，用下划线画出。</li><li>用圈将答案在原文圈出。</li></ol><p>同义词找到越多，逻辑越缜密，推导出的结果正确率越高。</p><h3 id="四-分题型讲解做题技巧"><a href="#四-分题型讲解做题技巧" class="headerlink" title="四. 分题型讲解做题技巧"></a>四. 分题型讲解做题技巧</h3><h4 id="（1）单词填写题"><a href="#（1）单词填写题" class="headerlink" title="（1）单词填写题"></a>（1）单词填写题</h4><p>单词填写题：主要考察单词理解，不像True/false/Not given是理解句子，Headings是理解归纳自然段。还包括填表格，填图题，这两种更简单，但出现概率不高。单词填写题是细节题，优先做。</p><p>要点：</p><ol><li>词汇语法并重，看似考察空格单词，实际暗含<strong>词性判断</strong>、<strong>并列结构</strong>等语法考点。</li><li>熟悉出题形式，主要有四种。<ul><li>原文选词填空完成摘要（Summary）。</li><li>从题目后面的单词列表中选词填空完成摘要。</li><li>从原文选词填空完成句子。</li><li>从原文选词回答问题。</li></ul></li><li>熟练典型题目。</li></ol><p>命题：</p><ul><li>概率：40道题中的10个。</li><li>难度：前3类，三星；第4类，两星。</li></ul><h5 id="填空完成摘要-Summary"><a href="#填空完成摘要-Summary" class="headerlink" title="填空完成摘要-Summary"></a>填空完成摘要-Summary</h5><p>做题步骤：</p><ol><li><p>确定整个Summary在原文的出处。</p><ul><li>看题型描述中是否已给出信息。如 The summary below is based on Part C of the passage.</li><li>看Summary题型位置，如果是第二种题型，大多是对文章中间1~3段的总结，如果是最后一种题型，则大多是对文章末尾1~3段的总结。</li><li>定位Summary首句中的Keywords。</li></ul></li><li><p>判断所需空格词性。</p><p>实际考试中名词（n）概率有8成，动词（v）有1成，形容词（adj）副词（adv）和数词（num）占1成。不会考察介词、连词、代词、冠词。</p></li><li><p>根据空格前后信息在原文中锁定答案。</p><p>注意空格前后的单词，尤其是动词和名词。<strong>夹心饼干原则</strong>：空格是心，前后单词是饼干，找到原文中的饼干一夹，就可以找到心。</p></li><li><p>填完后通读一遍Summary。</p><p>答案填入后，将整个Summary通读一遍，从逻辑、语义和语法上检查。</p></li></ol><p>注意：</p><ul><li>空格有字数限制，解题前看清楚。</li><li>答案大部分情况下符合原文顺序，有可能1到2题倒序。</li><li>一个Summary题型中会有1到2道难题。</li><li>空格答案有可能需要变换原文单词的词性。</li><li>答案经常是高难词或<strong>生词</strong>。</li><li>题型重点考察空格前后单词对应原文的同义词理解。</li></ul><h5 id="原文选词"><a href="#原文选词" class="headerlink" title="原文选词"></a>原文选词</h5><p>从原文选词，注意词性判断，以及what、which、why、where、when等引导的疑问句，who就找人名，where找地名，when找时间，how/why找due to、thanks to、based on、by等介词后的名词，what找名词。</p><h4 id="（2）判断题"><a href="#（2）判断题" class="headerlink" title="（2）判断题"></a>（2）判断题</h4><p>判断题有两种书写形式：</p><ul><li>TURE/FALSE/NOT GIVEN：议论文采用。</li><li>YES/NO/NOT GIVEN：说明文采用。</li></ul><p>命题：</p><ul><li>概率：40道题中的12个，多分布于两篇文章中。</li><li>难度：四星。</li><li>主要考察句子理解，<strong>出题概率最高</strong>，易混淆FALSE和NOT GIVEN。</li><li>只有13.6%会在首题选NG，有9%在末题选F。</li></ul><p>做题要点：</p><ol><li><p>放慢速度，读懂题目。</p><p>一定要读懂题干含义。</p></li><li><p>90%顺序原则。</p><p>大概率题目对应原文顺序，偶尔乱序，一次读两道题，记忆keywords，回到原文定位。</p></li><li><p>常见题目中考点。</p><p>题目中出现only、all、most、first或比较级、最高级、比较结构（more…than…）、数字、因果关系等，这些词是该题的考点。</p></li><li><p>首题不蒙NG，尾题不蒙FALSE。</p></li></ol><p>True题命题规律：</p><ol><li>题目是对原文一句话的同义替换改写。50%概率，低难度。</li><li>题目是对原文信息（相邻两个句子或同一自然段中上下文信息）的归纳总结。45%概率，中难度。</li><li>题目是对原文中不同自然段中信息的归纳总结。5%概率，高难度。</li></ol><p>False题命题规律：</p><ol><li>题目和原文出现了反义词设置。60%概率，低难度。</li><li>题目中描述的关系或事实驳斥原文描述（关系型驳斥）。40%概率，高难度。</li></ol><p>NOT GIVEN题命题规律：<strong>NG并不就一定是原文找不到，而是根据原文无法确定，或者只是原文的一种可能性</strong></p><ol><li>题目陈述句中前或后的信息原文没有提及（大多是具体名词，如government、country、doctor、scientist、capital等）。50%概率，低难度。</li><li>题目中描述的关系原文没有提及（如比较关系more than等）。50%概率，中难度。</li></ol><h4 id="（3）段落题"><a href="#（3）段落题" class="headerlink" title="（3）段落题"></a>（3）段落题</h4><p>命题：</p><ul><li>概率：40道题中的6个。</li><li>难度：五星。</li><li>唯一一种在文章前出题的题型，可以自然的先看题目。要求阅读自然段，选出中心思想。</li><li>阅读题型中对理解能力要求最高的题型，要求真正读懂一个自然段，并有归纳能力，出现概率极高。</li><li>没有该题型时，也大概率会有段落信息匹配题（Paragraph Matching）</li></ul><p>注意：</p><ol><li>首先划掉例子中的heading。</li><li>选过的heading随时划掉，不可再选。</li><li>拿不准的段落先放弃，难题最后做，缩小选择范围后可以利用排除法做题。</li><li>先做每个段落中包含的细节题（如Summary或判断题），最后再选该段的heading。</li></ol><p>解题方法：</p><ul><li>中心句对应法：能够清晰的辨认出自然段中心句时使用。<ul><li>自然段首句总结。</li><li>自然段首句设问。</li><li>举例前的观点句。</li><li>转折词所在句子。</li><li>强调句型或有强调语气词所在句子。</li><li>起定义功能的句子</li><li>下一自然段首句。</li></ul></li><li>关键词对应法：当中心句不明显，或段落没有读完没有印象时使用。<ul><li>某一Heading中的一个Keyword在某自然段出现了一次。不可选。</li><li>某一Heading中的一个Keyword在某自然段出现了两次以上（包括同义词）。可选。</li><li>某一Heading中的两个以上Keywords在某自然段同时出现（包括同义词）。可选。</li></ul></li></ul><h4 id="（4）匹配题"><a href="#（4）匹配题" class="headerlink" title="（4）匹配题"></a>（4）匹配题</h4><p>命题：</p><ul><li>概率：40道题中的8个。</li><li>难度：<ol><li>句子信息与段落匹配：5星</li><li>关系型匹配：3星</li></ol></li><li>主要考察信息查找定位和同义词理解，强调在原文查找细节细腻的能力，很少考察对句子或段落的完整理解。</li><li>标志：Which paragraph contains the following information?</li><li>雅思三类难题：跨过后是阅读7分的水平<ol><li>选自然段中心Heading</li><li>是非判断题</li><li>信息段落匹配</li></ol></li></ul><h5 id="句子信息与段落匹配"><a href="#句子信息与段落匹配" class="headerlink" title="句子信息与段落匹配"></a>句子信息与段落匹配</h5><p>解题步骤：</p><ol><li><p>仔细阅读该题型中所有题目信息，画出所有题目中的Keywords，短暂记忆。</p><p>通常乱序，不能按题号顺序做，要打包做题。</p></li><li><p>接着看下一题型，记忆下一题型的Keywords。</p><p>匹配题通常是第一题型。</p></li><li><p>回原文从首段开始阅读，在阅读中优先选做其他题型在该段落中的题目，最后做该段落和句子信息的匹配。</p><p>匹配题型最后完成。</p></li><li><p>只要某段落中有某题目中Keywords的同义词出现，即可确认选择。</p><p>因为不是选段落中心思想，而是信息包含，只要有就可选。</p></li><li><p>注意：NB You may use any letter more than once.看到NB出现，有段落会被选两次。</p></li><li><p>难题酌情使用排除法，有风险。</p></li></ol><h5 id="关系型匹配（单词短语）"><a href="#关系型匹配（单词短语）" class="headerlink" title="关系型匹配（单词短语）"></a>关系型匹配（单词短语）</h5><p>常考人名对应各自的理论、事物和特点匹配，因为选项和题目有明显的Keywords，所以难度没那么高。</p><p>解题步骤：</p><ol><li>画出该题型中所有题目（选项）中的Keywords，短暂记忆。</li><li>阅读原文时标记出Keywords出现的位置。</li><li>阅读Keywords所在句子，向前向后各多读一句话。</li><li>看出原文句子中某单词和某题干单词的同义替换，然后选择。</li></ol><h5 id="关系型匹配（句子）"><a href="#关系型匹配（句子）" class="headerlink" title="关系型匹配（句子）"></a>关系型匹配（句子）</h5><p>大多数情况可以直接做题。步骤：</p><ol><li>忽略选项，直接通过题目Keywords回原文定位。</li><li>再看原文描述符合哪一选项表达，选出选项并划掉。</li><li>注意该题型有顺序和乱序两种方式，尽量打包做题，先做有把握的题目，运用排除法。</li></ol><h4 id="（5）选择题"><a href="#（5）选择题" class="headerlink" title="（5）选择题"></a>（5）选择题</h4><p>选择题分为：</p><ol><li>单选题：ABCD</li><li>多选题：五选二，七选三等</li><li>选标题：全文中心思想</li></ol><p>命题：</p><ul><li>概率：不是每次考试都出现。</li><li>难度：3星</li><li>多选找并列，单选是True题。</li></ul><h5 id="单选题"><a href="#单选题" class="headerlink" title="单选题"></a>单选题</h5><p>单选是选True的表达，正确选项和题目组合成为一个True的表达句子，其他选项是NOT GIVEN或FALSE干扰，难度低于判断题。</p><p>解题：用题干的Keywords回原文定位，而不是选项。</p><ul><li>对原文中一句话的同义改写。</li><li>对原文上下文的归纳。</li></ul><h5 id="多选题"><a href="#多选题" class="headerlink" title="多选题"></a>多选题</h5><p>针对原文的<strong>并列结构</strong>出题，正确选项是原文并列项之一的同义改写。</p><h5 id="选标题"><a href="#选标题" class="headerlink" title="选标题"></a>选标题</h5><p>重点看原文末段，末段一般是全篇的结论和总结。</p><h5 id="（6）图表题"><a href="#（6）图表题" class="headerlink" title="（6）图表题"></a>（6）图表题</h5><p>图表题可分为：</p><ol><li>填表题。</li><li>填图题。</li><li>选图题。</li></ol><p>命题：</p><ul><li>概率：不是每次考试都出现。</li><li>难度：1星</li><li>图表题出现概率低，受限于表格逻辑结构，或围绕事物的流程原理，是送分题。</li></ul><h5 id="填表题"><a href="#填表题" class="headerlink" title="填表题"></a>填表题</h5><p>注意事项：</p><ol><li>顺序原则：展示了文章的思路和叙述逻辑。</li><li>空格所填答案与上下左右信息的关系。</li></ol><h5 id="填图题"><a href="#填图题" class="headerlink" title="填图题"></a>填图题</h5><p>与雅思写作的流程图题是一个互逆的过程，阅读是文字到图表，写作是图表到文字。</p><p>注意事项：</p><ol><li>因为原文中各部件工作原理会集中描写，所以答案也集中。</li><li>图表题先以简单题作为突破口，仔细观察图表特点判断哪道题简单。</li><li>答案绝大数为名词。</li></ol><h5 id="选图题"><a href="#选图题" class="headerlink" title="选图题"></a>选图题</h5><p>只出现过2次，解题：</p><ol><li>浏览观察各选项图表，注意区别特征。</li><li>回原文定位做题，注意描述性单词。</li></ol><h3 id="五-如何准备阅读"><a href="#五-如何准备阅读" class="headerlink" title="五. 如何准备阅读"></a>五. 如何准备阅读</h3><p>四个要素：</p><ul><li>词汇</li><li>阅读方法论各题型解题技能</li><li>真题</li><li>题经</li></ul><p>阅读上7分需要多少词汇量：</p><ul><li>3000高中水平基础词汇量 + 538雅思考点词</li></ul><p>阅读慢的原因？</p><ul><li>找题目关键词慢</li><li>阅读原文，找定位出处慢</li><li>找到原文后，解题慢</li></ul><p>不要精度原文。反对精度，快速阅读，对比阅读。</p><p>Summary要求能判断空格词形，需要基础语法知识。</p><h2 id="剑桥雅思12周完全攻略-阅读"><a href="#剑桥雅思12周完全攻略-阅读" class="headerlink" title="剑桥雅思12周完全攻略-阅读"></a>剑桥雅思12周完全攻略-阅读</h2><h2 id="待整理"><a href="#待整理" class="headerlink" title="待整理"></a>待整理</h2><p>同义词对词法</p><p>作者：嘉嘉不路<br>链接：<a href="https://www.zhihu.com/question/28886881/answer/1116185417">https://www.zhihu.com/question/28886881/answer/1116185417</a><br>来源：知乎<br>著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。</p><p>一、含义不同</p><p>1、过去式是发生在过去，已经经过的事情，一定用过去式，除了某些定律或永远不变的事。</p><p>比如 ：</p><p>i thought of him.</p><p>我想起了他。</p><p>2、<a href="https://link.zhihu.com/?target=https://www.baidu.com/s?wd=%E8%BF%87%E5%8E%BB%E5%88%86%E8%AF%8D&tn=SE_PcZhidaonwhc_ngpagmjz&rsv_dl=gh_pc_zhidao">过去分词</a>便是一般用于被动句或完成时的。</p><p>比如：</p><p>he is beaten by his father或者he has accomplished his work表示过去做的事对现在的影响或突出“已经”这个意思。</p><p>二、用法不同</p><p><a href="https://link.zhihu.com/?target=https://www.baidu.com/s?wd=%E8%BF%87%E5%8E%BB%E5%88%86%E8%AF%8D&tn=SE_PcZhidaonwhc_ngpagmjz&rsv_dl=gh_pc_zhidao">过去分词</a>不能单独作谓语，必须和be动词构成<a href="https://link.zhihu.com/?target=https://www.baidu.com/s?wd=%E8%A2%AB%E5%8A%A8%E8%AF%AD%E6%80%81&tn=SE_PcZhidaonwhc_ngpagmjz&rsv_dl=gh_pc_zhidao">被动语态</a>才可以作<a href="https://www.zhihu.com/search?q=%E8%B0%93%E8%AF%AD%E5%8A%A8%E8%AF%8D&search_source=Entity&hybrid_search_source=Entity&hybrid_search_extra=%7B%22sourceType%22:%22answer%22,%22sourceId%22:1116185417%7D">谓语动词</a>或和have，has，had构成完成时，但是过去式表示动作发生在过去，可以作谓语动词用。过去完成时也可以做定语，<a href="https://www.zhihu.com/search?q=%E8%A1%A5%E8%AF%AD&search_source=Entity&hybrid_search_source=Entity&hybrid_search_extra=%7B%22sourceType%22:%22answer%22,%22sourceId%22:1116185417%7D">补语</a>或状语。</p><p>如：“have，has，had +<a href="https://link.zhihu.com/?target=https://www.baidu.com/s?wd=%E8%BF%87%E5%8E%BB%E5%88%86%E8%AF%8D&tn=SE_PcZhidaonwhc_ngpagmjz&rsv_dl=gh_pc_zhidao">过去分词</a>”构成<a href="https://link.zhihu.com/?target=https://www.baidu.com/s?wd=%E5%AE%8C%E6%88%90%E6%97%B6%E6%80%81&tn=SE_PcZhidaonwhc_ngpagmjz&rsv_dl=gh_pc_zhidao">完成时态</a>，“be+过去分词”构成<a href="https://link.zhihu.com/?target=https://www.baidu.com/s?wd=%E8%A2%AB%E5%8A%A8%E8%AF%AD%E6%80%81&tn=SE_PcZhidaonwhc_ngpagmjz&rsv_dl=gh_pc_zhidao">被动语态</a>等。</p><p><img src="https://pic3.zhimg.com/50/v2-a3175c0a4cd53adfd52a623dc71ee0ab_720w.jpg?source=1940ef5c" alt="img"><img src="https://pic3.zhimg.com/80/v2-a3175c0a4cd53adfd52a623dc71ee0ab_1440w.jpg?source=1940ef5c" alt="img"></p><p>三、作用不同</p><p>动词的过去分词它相当于一个形容词或<a href="https://link.zhihu.com/?target=https://www.baidu.com/s?wd=%E5%89%AF%E8%AF%8D&tn=SE_PcZhidaonwhc_ngpagmjz&rsv_dl=gh_pc_zhidao">副词</a>，在句中起一个形容词或<a href="https://link.zhihu.com/?target=https://www.baidu.com/s?wd=%E5%89%AF%E8%AF%8D&tn=SE_PcZhidaonwhc_ngpagmjz&rsv_dl=gh_pc_zhidao">副词</a>的作用，可作<a href="https://link.zhihu.com/?target=https://www.baidu.com/s?wd=%E8%A1%A8%E8%AF%AD&tn=SE_PcZhidaonwhc_ngpagmjz&rsv_dl=gh_pc_zhidao">表语</a>，定语、补语等，它的作用与<a href="https://link.zhihu.com/?target=https://www.baidu.com/s?wd=%E7%8E%B0%E5%9C%A8%E5%88%86%E8%AF%8D&tn=SE_PcZhidaonwhc_ngpagmjz&rsv_dl=gh_pc_zhidao">现在分词</a>doing类似，过去分词表的意义是被动或完成。</p><p>过去式是一个动词，而过去分词是一个动词的非谓语形式，相当于一个形容词或<a href="https://link.zhihu.com/?target=https://www.baidu.com/s?wd=%E5%89%AF%E8%AF%8D&tn=SE_PcZhidaonwhc_ngpagmjz&rsv_dl=gh_pc_zhidao">副词</a>。</p>]]></content>
    
    
    <summary type="html">内容主要来自《剑桥雅思12周完全攻略》《刘洪波-雅思阅读真经总纲》等。</summary>
    
    
    
    <category term="编程之外" scheme="http://linyishui.top/categories/%E7%BC%96%E7%A8%8B%E4%B9%8B%E5%A4%96/"/>
    
    <category term="英语" scheme="http://linyishui.top/categories/%E7%BC%96%E7%A8%8B%E4%B9%8B%E5%A4%96/%E8%8B%B1%E8%AF%AD/"/>
    
    
    <category term="updating" scheme="http://linyishui.top/tags/updating/"/>
    
    <category term="english" scheme="http://linyishui.top/tags/english/"/>
    
  </entry>
  
  <entry>
    <title>英语语法（二）读书笔记</title>
    <link href="http://linyishui.top/2022050101.html"/>
    <id>http://linyishui.top/2022050101.html</id>
    <published>2022-05-01T02:01:34.000Z</published>
    <updated>2022-06-19T13:51:53.712Z</updated>
    
    <content type="html"><![CDATA[<h1 id="语法"><a href="#语法" class="headerlink" title="语法"></a>语法</h1><h2 id="1-Present-Tenses"><a href="#1-Present-Tenses" class="headerlink" title="1. Present Tenses"></a>1. Present Tenses</h2><h3 id="1-1-一般现在时（Present-simple）"><a href="#1-1-一般现在时（Present-simple）" class="headerlink" title="1.1 一般现在时（Present simple）"></a>1.1 一般现在时（Present simple）</h3><ul><li>+：verb / verb + (e)s：He plays tennis.</li><li>-：do/does not + verb：She doesn’t play tennis.</li><li>?：do/does … + verb? Do you play tennis?</li></ul><p>场景：</p><ul><li>经常性的习惯，反复发生的动作，描述频率的词汇包括：always、generally、normally、usually、often、sometimes、rarely、never、every day、every evening.</li><li>永久性的情况</li><li>陈述事实或广为接受的真理</li><li>提供指导或指示</li><li>讲述故事、电影、书籍和戏剧</li></ul><h3 id="1-2-现在进行时（Present-continuous）"><a href="#1-2-现在进行时（Present-continuous）" class="headerlink" title="1.2 现在进行时（Present continuous）"></a>1.2 现在进行时（Present continuous）</h3><ul><li>+：am/is/are + verb + -ing：He`s living in Thailand.</li><li>-：am/is/are not + verb + -ing：I`m not living in Thailand.</li><li>?：am/is/are … + verb + -ing? Are they living in Thailand?</li></ul><p>场景：</p><ul><li><p>现在的情况或状态，经常使用的单词或短语：at the moment、currently、now、this week/month/year</p><p>I`m studying really hard for my exams.</p><p>My cousin is living in Thailand at the moment = he doesn’t normally live there.</p></li><li><p>说话间正在发生的动作：I`m waiting for my friends.</p></li><li><p>趋势或正在变化的情况：The price of petrol is rising dramatically.</p></li><li><p>经常发生的动作，常与always、constantly、continually、forever等副词连用，表示羡慕、批评等情绪：</p><p>My mum`s always saying I don’t help enough!</p><p>He`s always visiting exciting places!</p></li></ul><h3 id="1-3-状态动词（State-verbs）"><a href="#1-3-状态动词（State-verbs）" class="headerlink" title="1.3 状态动词（State verbs）"></a>1.3 状态动词（State verbs）</h3><p>状态动词表示一种事实，而不是暂时的事情，通常不出现在<strong>现在进行时</strong>的句子里，表达想法、感情、感知、占有和描述等状态。</p><ul><li><p>想法：agree、assume、believe、disagree、forget、hope、 know、regret、remember、suppose、think、understand</p><p>I <strong>assume</strong> you`re too busy to play computer games.</p></li><li><p>感情：adore、despise、dislike、enjoy、feel、hate、like、love、mind、prefer、want</p><p>Do you <strong>mind</strong> if I ask you a few questions?</p></li><li><p>感知：feel、hear、see、smell、taste，谈论正在发生的事情时可以用can</p><p>This pudding <strong>smells</strong> delicious.</p><p>I <strong>can smell</strong> something burning.</p></li><li><p>占有：have、own、belong</p><p>My parents own a restaurant.</p></li><li><p>描述：appear、contain、look、look like、mean、resemble、seem、smell、sound、taste、weigh</p><p>You <strong>look like</strong> your mother</p></li><li><p>当意思本身表示暂时性时，一些状态动词可以使用进行时，如：</p><ul><li>What are you <strong>thinking</strong> about?</li><li>I <strong>think</strong> you should XXX.</li><li>I`m <strong>tasting</strong> the sauce to see if it needs any more salt.</li><li>The sauce <strong>tastes</strong> delicious.</li><li>She`s <strong>having</strong> a great time.（is having = is experiencing, not possession）</li><li>Students don`t generally <strong>have</strong> much money.（have = possession）</li></ul></li></ul><h3 id="1-4-一般过去时（Past-simple）"><a href="#1-4-一般过去时（Past-simple）" class="headerlink" title="1.4 一般过去时（Past simple）"></a>1.4 一般过去时（Past simple）</h3><ul><li>+：verb + -ed（or -d）：He worked for the police.</li><li>-：did not + verb：She didn’t work for the police.</li><li>?：did … + verb? Did they work for the police?</li></ul><blockquote><p>不规则动词：go-went，come-came，write-wrote等</p></blockquote><p>场景：</p><ul><li><p>过去已经完成的动作，通常会在句子中提到时间（若时间已知则无需提及）。</p><p>A few weeks ago a woman <strong>called</strong> to report a robbery at her house.</p></li><li><p>按照发生顺序描述的一系列动作，表示顺序时经常会使用next、then等。</p><p>The burglar <strong>came in</strong> through the front door, <strong>picked up</strong> the woman`s handbag, <strong>emptied</strong> it out and <strong>stole</strong> her purse.</p></li><li><p>过去的习惯性动作。</p><p>When her son got older he often <strong>went out</strong>  to visit his friend after school.</p></li><li><p>过去长时间保持的，现在已经改变的状态。</p><p>Bill wored for the police force for over 17 years.</p></li></ul><h3 id="1-5-过去进行时（Past-continuous）"><a href="#1-5-过去进行时（Past-continuous）" class="headerlink" title="1.5 过去进行时（Past continuous）"></a>1.5 过去进行时（Past continuous）</h3><ul><li>+：was/were + verb + -ing：She was watching the news.</li><li>-：was/were not + verb + -ing：They weren`t watching the news.</li><li>?：was/were … + verb + -ing? Were you watching the news?</li></ul><p>场景：</p><ul><li><p>为某一动作或事件（其经常为一般过去时）提供场景，通常用到when、while和as等词语</p><p>It <strong>happened</strong> at first in the afternoon <strong>while</strong> she <strong>was watching</strong> the news on TV.</p><p>同一时间可能进行多个动作：</p><p>He <strong>was listening</strong> to music and <strong>working</strong> on his computer.</p></li><li><p>强调某个动作而不关注动作的完成情况</p><p>For a while last year I <strong>was working</strong> at the cinema, <strong>studying</strong> for my degree and <strong>writing</strong> a column for the local newspaper.（不知道动作是否完成，多个动作可能不知道是否同时进行）</p><p>Last year I <strong>worked</strong> at the cinema, <strong>studied</strong> for my degree and <strong>wrote</strong> a column for the local newspaper.（猜测所有动作都已完成，或者按顺序发生）</p><p>状态动词一般没有进行时态。</p></li></ul><h3 id="1-6-Used-to-and-would"><a href="#1-6-Used-to-and-would" class="headerlink" title="1.6 Used to and would"></a>1.6 Used to and would</h3><ul><li>+：used to / would + infinitive：She used to / would lock the door.</li><li>-：did not + used to + infinitive：I didn’t use to lock the door.</li><li>?：did … use to + infinitive? Did they use to lock the door?</li></ul><ol><li><p>used to / would + 动词原形 用于描述过去的习惯动作。</p><p>She used to keep the front door locked（现在不再）</p><p>She would leave the door unlocked whenever she was at home.</p><p>注意：would 一般不出现在被动语态和Yes/No题目中。</p></li><li><p>used to + 动词原形 用于描述现在已经不存在的过去某种持续性状态。</p><p>Bill used to work for the police force.</p><p>当描述某种状态持续了多久时，不用used to：</p><p>Bill worked for the police force for over 17 years.</p><p>would 不能与状态动词同用。</p></li></ol><h3 id="1-7-现在完成时（Present-perfect-simple）"><a href="#1-7-现在完成时（Present-perfect-simple）" class="headerlink" title="1.7 现在完成时（Present perfect simple）"></a>1.7 现在完成时（Present perfect simple）</h3><ul><li>+：have/has + past participle：She`s started the assignment.</li><li>-：have/has not + past participle：I haven`t started the assignment.</li><li>?：have/has … + past participle?：Have you started the assignment?</li></ul><p>场景：</p><ul><li><p><strong>到现在（today，this week）为止仍为结束的一段时间</strong>。</p><p>I`<strong>ve written</strong> a rough plan this morning.</p></li><li><p><strong>现在之前的过去某个时间点已经发生的事情，句中不需要指出具体发生的时间</strong>。</p><p>I`<strong>ve collected</strong> plenty of information.（at some point before now and I will use it to write my essay）</p><p>经常使用以下表示时间的单词和短语：<strong>ever、never、before、up to now、still、so far</strong></p><p>It`s the longest I`<strong>ve ever had</strong> to write.（at any point before now）</p><p>但是如果强调的只有某件事情在某时发生了，使用一般过去时。</p><p>I <strong>wasted</strong> a lot of time last week.（not： I have wasted a lot of time last week）</p></li><li><p><strong>起源于过去，并延续到现在的某种状态，通常和for、since连用</strong>。</p><p>I`<strong>ve worked</strong> really hard for the last two weeks.（for指某个时间段，since则指某个时间点）</p></li><li><p><strong>过去未提及的时间里发生的，与现在情况有联系的事情</strong>。</p><p>I`<strong>ve read</strong> all the books on the reading list.（I have the notes now）</p><p>通常使用以下表示时间的单词和短语：<strong>recently、just、already、yet</strong>。</p><p>I`<strong>ve just got</strong> up.</p><p><strong>Have</strong> you <strong>written</strong> your assignment <strong>yet</strong>?</p></li></ul><p>对比：</p><ul><li><p>现在完成时</p><ul><li><p>连接过去和现在：</p><p>I`<strong>ve made</strong> quite a lot of notes.（at some point before now and I may make more notes）</p></li><li><p>不关注过去某个具体的时间点：</p><p><strong>Have</strong> you <strong>read</strong> the leaflet?（at some time before now）</p></li><li><p>使用说明时段仍未结束的时间表达</p><p>I`<strong>ve read</strong> six articles this week.（this week isn’t finished）</p></li></ul></li><li><p>一般过去时：</p><ul><li><p>仅仅谈论过去：</p><p>I made notes on the most important things.（when I did the reading and I`ve finished making notes）</p></li><li><p>说明过去一个具体时间，或过去时间是可推知的：</p><p>I read the leaflet when I was in the library.（I`m not in the library now and the reading is finished）</p></li><li><p>使用说明时段已经结束的时间表达：</p><p>I read five books last week.（last week has finished）</p></li></ul></li></ul><p>注意，下列时间在现在完成时的位置：</p><ul><li><p><strong>在助动词和主动词之间：如recently、already、always、ever、just、never</strong></p><p>I`ve already written the notes.</p><p>I`ve just finished my essay.</p><p>ever常用于疑问句或否定句中：</p><p>Have you ever been to Buenos Aires?</p></li><li><p>在主动词之后：如all my life、every day、yet、before、for ages、for two weeks、since 2003、since I was a child等</p><p>I`ve felt tired for weeks.</p><p>I haven’t flown before.</p><p>如果句子中有宾语从句，时间表达放在句尾：</p><p>I`ve gone to bed early every night since then.</p><p>I`ve written more than ten assignments since I started this course.</p></li></ul><h3 id="1-8-现在完成进行时（Present-perfect-continuous）"><a href="#1-8-现在完成进行时（Present-perfect-continuous）" class="headerlink" title="1.8 现在完成进行时（Present perfect continuous）"></a>1.8 现在完成进行时（Present perfect continuous）</h3><ul><li>+：have/has been + verb + -ing：I`ve been studying really hard.</li><li>-：have/has not been + verb + -ing：He hasn`t been studying really hard.</li><li>?：have/has … been + verb + -ing?：Have you been studying really hard?</li></ul><p>描述某种状态或动作持续了多久，使用现在完成时或现在完成进行时，通常和for、since连用。</p><ul><li>I`ve worked at the restaurant since I moved here.</li><li>I`ve been working at the restaurant for three years. </li></ul><p>比较：</p><ul><li><p>现在完成进行时：</p><ul><li><p>强调状态或行为持续了多久：</p><p>I`ve been reading for the past two weeks.</p></li><li><p>关注行为本身（而不是关注这个行为是否已经完成）：</p><p>I`ve been writing my essay.（we don’t know if the essay is finished or not）</p></li></ul></li><li><p>现在完成时：</p><ul><li><p>强调已经完成的次数：</p><p>I`ve read three articles.</p></li><li><p>关注行为的结果或完成情况：</p><p>I`ve written my essay.（the essay is finished but we don’t know when）</p></li></ul></li></ul>]]></content>
    
    
    <summary type="html">内容主要来自《剑桥雅思语法精炼精讲》。</summary>
    
    
    
    <category term="编程之外" scheme="http://linyishui.top/categories/%E7%BC%96%E7%A8%8B%E4%B9%8B%E5%A4%96/"/>
    
    <category term="英语" scheme="http://linyishui.top/categories/%E7%BC%96%E7%A8%8B%E4%B9%8B%E5%A4%96/%E8%8B%B1%E8%AF%AD/"/>
    
    
    <category term="updating" scheme="http://linyishui.top/tags/updating/"/>
    
    <category term="english" scheme="http://linyishui.top/tags/english/"/>
    
  </entry>
  
  <entry>
    <title>英语-单词短语</title>
    <link href="http://linyishui.top/2022042901.html"/>
    <id>http://linyishui.top/2022042901.html</id>
    <published>2022-04-29T08:16:22.000Z</published>
    <updated>2022-06-19T13:44:21.106Z</updated>
    
    <content type="html"><![CDATA[<h1 id="单词短语"><a href="#单词短语" class="headerlink" title="单词短语"></a>单词短语</h1><h2 id="一-易混淆的单词"><a href="#一-易混淆的单词" class="headerlink" title="一. 易混淆的单词"></a>一. 易混淆的单词</h2><h3 id="1-1-词形相似-派生联想"><a href="#1-1-词形相似-派生联想" class="headerlink" title="1.1 词形相似/派生联想"></a>1.1 词形相似/派生联想</h3><h4 id="adapt-adopt"><a href="#adapt-adopt" class="headerlink" title="adapt/adopt"></a>adapt/adopt</h4><ul><li>adapt：v.使适应，改编</li><li>adopt：v.领养，采纳，接受</li></ul><p>派生：</p><ul><li>adaptable：adj.有适应能力的，能适应的</li><li>adaptation：n.适应，改编本</li><li>adaptive：adj.适应的，有适应能力的</li><li>adaption：n.改编，适应</li><li>adapter：n.转接器</li><li>adapted：<ul><li>adj.适应…的，改编成…的</li><li>v.adapt的过去式和过去分词</li></ul></li><li>adoption：n.收养，领养，采纳，接受</li><li>adoptive：adj.收养的，有收养关系的</li><li>adopted：<ul><li>adj.收养的，领养的，移居的</li><li>v.adopt的过去式和过去分词</li></ul></li></ul><h4 id="aptitude-appetite"><a href="#aptitude-appetite" class="headerlink" title="aptitude/appetite"></a>aptitude/appetite</h4><ul><li>aptitude：n. 天赋, 天资, 天生的才能</li><li>appetite：n. 胃口, 食欲; 欲望; 爱好</li></ul><h4 id="board-broad"><a href="#board-broad" class="headerlink" title="board/broad"></a>board/broad</h4><ul><li>board：<ul><li>n.木板，公告板，董事会，伙食，舞台</li><li>v.登（船、飞机、车），寄宿</li></ul></li><li>broad：<ul><li>adj.宽阔的，丰富的，粗略的，概括的，一般的，口音重的</li><li>n.娘儿们</li><li>adv.宽阔地</li></ul></li><li>aboard：<ul><li>prep.上（船、飞机、车），新入伙</li><li>adv.上（船），靠船边，在…上</li></ul></li><li>abroad：adv.国外，海外，出国，在国外，如to live abroad</li></ul><p>派生：</p><ul><li>boarder：n.寄宿生</li><li>overboard：adv.从船上落下，向船外</li><li>boarding：n.木板，板材，寄宿；v.board的现在分词</li></ul><h4 id="boil-foil-soil"><a href="#boil-foil-soil" class="headerlink" title="boil/foil/soil"></a>boil/foil/soil</h4><ul><li>boil：<ul><li>v. 烧开, 煮沸, 怒火中烧, （使）沸腾</li><li>n. 沸腾, 疖, 沸点, 皮下脓肿</li></ul></li><li>foil：<ul><li>n. 〔包裹食物用的〕箔；箔纸；陪衬物；〔击剑中的〕轻剑，花剑</li><li>v. 衬托, 阻止, 挫败, 【猎】搅乱</li></ul></li><li>soil：<ul><li>n. 土壤, 土地, 国土, 领土</li><li>v. 弄脏</li></ul></li></ul><h4 id="concept-concert"><a href="#concept-concert" class="headerlink" title="concept/concert"></a>concept/concert</h4><ul><li>concept：n. 概念, 观念, 设想, 观点</li><li>concert：<ul><li>n. 音乐会；演奏会</li><li>v. 协商；合订(计划)；协同工作</li></ul></li></ul><h4 id="conduct-induct-conduce-induce"><a href="#conduct-induct-conduce-induce" class="headerlink" title="conduct/induct/conduce/induce"></a>conduct/induct/conduce/induce</h4><ul><li>conduct：<ul><li>v. 进行; 组织, 实施; 处理; 管理; 表现, 为人; 指挥; 导电, 传热; 给…做向导, 陪同</li><li>n. 举止; 行为; 处理(方式); 管理(方式)</li></ul></li><li>induct：v. （尤指在典礼上）使正式就职, 正式吸收（为成员）, （尤指）征召入伍</li><li>conduce：v. 有助于, 导致</li><li>induce：v. 诱使，引诱；引起，导致；催生</li></ul><h4 id="consul-consult"><a href="#consul-consult" class="headerlink" title="consul/consult"></a>consul/consult</h4><ul><li>consul：n.领事</li><li>consulate：n.领事馆</li><li>consular：adj. 领事的, 【史】执政官的</li><li>consult：v.咨询，请教，参阅</li><li>consultant：n.顾问, 高级顾问医师, 会诊医师</li><li>consultancy：n.咨询公司, 专家咨询</li><li>consultative：adj. 咨询的, 顾问的</li><li>consultation：n. 咨询, 磋商, 查阅, 商讨</li></ul><h4 id="gear-rear"><a href="#gear-rear" class="headerlink" title="gear/rear"></a>gear/rear</h4><ul><li>gear：<ul><li>n. 排挡；齿轮；传动装置;（某种活动的）设备，用具；衣服</li><li>v. 用齿轮连接；（使）适合，使适应；（使）准备好</li><li>adj. 时髦的；好极了</li></ul></li><li>rear：<ul><li>adj. 后面的；后部的</li><li>n. 后部；屁股，臀部</li><li>v. 抚养，养育；饲养；用后腿直立</li></ul></li></ul><h4 id="vauge-gauge-judge-dredge"><a href="#vauge-gauge-judge-dredge" class="headerlink" title="vauge/gauge/judge/dredge"></a>vauge/gauge/judge/dredge</h4><ul><li>vague：adj.模糊的，不明确的，含糊其词的</li><li>gauge：<ul><li>v.估计，判定，估算，测量</li><li>n.厚度，标准，测量仪器。</li></ul></li><li>judge：<ul><li>n.法官，裁判，鉴赏家</li><li>v.判断，断定，认为，估计，猜测，裁判，评级，批评，审判</li></ul></li><li>dredge：<ul><li>v.挖掘，打捞，清淤</li><li>n.挖泥船，捕捞船</li></ul></li><li>wedge：<ul><li>n.楔子，三角木，楔形物</li><li>v.将…挤入/塞进/插入，把…楔牢</li></ul></li><li>badge：n.徽章，奖章，标记，标识，警徽，象征<ul><li>chains are a badge of slavery.</li></ul></li><li>budget：<ul><li>n.预算</li><li>v.做预算，节省开支</li><li>adj.廉价的，不贵的</li></ul></li></ul><h4 id="stuff-staff-shaft-shift"><a href="#stuff-staff-shaft-shift" class="headerlink" title="stuff/staff/shaft/shift"></a>stuff/staff/shaft/shift</h4><ul><li>stuff：<ul><li>v.填满，塞满，吃撑</li><li>n.材料，原料，东西，物品，技巧，能力</li></ul></li><li>staff：<ul><li>n.全体职工，管理人员，拐杖，棍棒</li><li>v.在…工作，任职于</li></ul></li><li>shaft：<ul><li>n.轴，杆，井穴，一束光，挖苦，尖酸的话</li><li>v.蒙骗，欺骗</li><li>give sb the shaft 亏待某人</li></ul></li><li>shift：<ul><li>v.转移，更替，转嫁，换挡，变速</li><li>n.交换，变化，轮班</li></ul></li></ul><h4 id="profit-benefit-credit"><a href="#profit-benefit-credit" class="headerlink" title="profit/benefit/credit"></a>profit/benefit/credit</h4><ul><li><p>profit：</p><ul><li>n.利润，收益，盈利</li><li>v.盈利，获取利润，赚钱</li></ul></li><li><p>benefit：</p><ul><li>n.益处，优势，成效，福利费，救济金，抚恤金</li><li>v.对…有用，使受益，得益于，获利</li></ul></li><li><p>credit：</p><ul><li>n.信用，赊欠，信贷，贷方，信誉，赞扬，荣誉，学分</li><li>v.把…归功于，允许赊欠，为…提供贷款</li></ul></li><li><p>advantage：</p><ul><li>n.优势，优点，有利条件</li><li>v.有利于，有助于，使处于有利地位</li></ul></li><li><p>debit：</p><ul><li>n. 借记, 借方, 收方, 借项</li><li>v. 借记, 记入（账户）的借方</li></ul></li></ul><p>派生：</p><ul><li>profitable：adj.有益的，有用的，能盈利的</li><li>profiteer：<ul><li>n.奸商，投机商人</li><li>v.取的不正当利益</li></ul></li><li>nonprofit：adj.非盈利的</li><li>profitless：adj.无利可图的，无益的</li><li>beneficial：adj.有益的，有利的</li><li>beneficent：adj.行善的，慈善的</li><li>creditable：adj.值得赞扬的，高尚的</li><li>discredit：<ul><li>v.败坏…名声，使丧失信誉，使丢脸，使不相信</li><li>n.丢脸，信誉丧失</li></ul></li><li>creditor：n.债权人，债主，贷方</li></ul><p>把…归因于：</p><ul><li>credit：同上</li><li>ascribe：v.归因于，归咎于</li><li>attribute：<ul><li>v.把…归因于，把…归咎于，认为…属于</li><li>n.属性，特性，品质，象征</li></ul></li><li>impute：v.把…归因于，把…归咎于</li></ul><h4 id="wrap-swap"><a href="#wrap-swap" class="headerlink" title="wrap/swap"></a>wrap/swap</h4><ul><li>wrap：<ul><li>v.包，裹，围住</li><li>n.披肩，围巾，饺子皮，保鲜膜</li></ul></li><li>swap：<ul><li>v.交换，替换</li><li>n.交换，交换物</li></ul></li></ul><h4 id="steer-steep-sheer-sheet"><a href="#steer-steep-sheer-sheet" class="headerlink" title="steer/steep/sheer/sheet"></a>steer/steep/sheer/sheet</h4><ul><li>steer：<ul><li>v.驾驶，操纵，控制，引导</li><li>n.建议，劝告，忠告</li></ul></li><li>steep：<ul><li>adj.险峻的，陡峭的，急剧的，大幅度的，昂贵的</li><li>n.峭壁</li><li>v.浸泡，浸透</li></ul></li><li>sheer：<ul><li>adj.垂直的，陡峭的，轻薄透明的，纯粹的，完全的，十足的</li><li>v.突然变向</li><li>n.突然转向</li></ul></li><li>sheet：<ul><li>n.薄板，床单，纸张，报纸</li><li>v.覆盖，展开，铺开</li><li>adj.片状的</li></ul></li><li>veer：v.突然转向，改变方向，改变立场/态度</li></ul><h4 id="object-subject"><a href="#object-subject" class="headerlink" title="object/subject"></a>object/subject</h4><ul><li>object：<ul><li>n.物体，事物，目的，目标，宾语，客观，对象</li><li>v.反对</li></ul></li><li>objective：<ul><li>n.目标，目的</li><li>adj.客观的，基于事实的</li></ul></li><li>objection：n.反对，异议</li><li>objectify：v.将…物化，将…人格物化</li><li>objector：n.反对者</li><li>subject：<ul><li>n.学科，题材，主题，问题，实验对象，主语</li><li>adj.服从的，受支配的，可能受…影响的，易遭受…的</li><li>v.使臣服，使顺从，使遭受，提供，呈交</li></ul></li><li>subjection：n.服从，征服</li><li>subjective：adj.主观的，主语的</li><li>subjectivism：n.主观论，主观主义</li><li>aim：<ul><li>n.目标，对准</li><li>v.瞄准，旨在</li></ul></li><li>intention：n.意图，意向，目的</li><li>goal：n.目标，目的，球门，射门</li><li>purpose：<ul><li>n.目的，用途，目标，意图</li><li>v.想，决心（做）</li></ul></li><li>target：<ul><li>n.目标，靶，指标，对象</li><li>v.面向，把…作为攻击（批评）目标</li></ul></li></ul><h4 id="miser-misery"><a href="#miser-misery" class="headerlink" title="miser/misery"></a>miser/misery</h4><ul><li>miser：n. 守财奴, 吝啬鬼</li><li>miserly：adj. 吝啬的, 小气的, 极少的, 太小的</li><li>misery：n. 痛苦，悲惨的境遇，苦难</li><li>miserable：adj. 悲惨的，痛苦的</li></ul><h4 id="instinct-distinct-extinct"><a href="#instinct-distinct-extinct" class="headerlink" title="instinct/distinct/extinct"></a>instinct/distinct/extinct</h4><ul><li>instinct：n. 本能，天性；直觉</li><li>distinct：adj. 清晰的，明显的；截然不同的，有区别的；不同种类的；确实的，不容忽视的</li><li>extinct：adj. （动植物，语言）灭绝的；（习俗，工作等）消失的</li></ul><h4 id="invent-invest-invert-advent"><a href="#invent-invest-invert-advent" class="headerlink" title="invent/invest/invert/advent"></a>invent/invest/invert/advent</h4><ul><li>invent：v. 发明, 创造, 编造, 捏造</li><li>invest：v. 投资, （把资金）投入, 投入（时间、精力等）, 授予</li><li>invert：v.（使）倒转，（使）颠倒</li><li>advent：n.出现，到来，降临节</li><li>investigate：v. 调查，研究；审查</li></ul><h4 id="mutual-mature"><a href="#mutual-mature" class="headerlink" title="mutual/mature"></a>mutual/mature</h4><ul><li>mutual：adj. 共同的，相互的</li><li>mature：<ul><li>adj. 明白事理的；成熟的；发育完全的</li><li>v. 成熟；长成；有判断力</li></ul></li></ul><h4 id="server-severe"><a href="#server-severe" class="headerlink" title="server/severe"></a>server/severe</h4><ul><li>server：n. 服务员, 吃饭分餐时的器具, 【体】发球者, (宗教仪式时) 助祭者<ul><li>serve：v. 服务；提供；接待；任期为；为…工作，服役 n. 发球</li><li>servant：n. 仆人, 佣人, （公司或机构的）雇员, 奴仆般受制（或献身）于…的人</li><li>serving：n. （供一个人吃的）一份食物 adj. 用于上菜的 v. “serve”的现在分词</li></ul></li><li>severe：adj. 严重的，严峻的；剧烈的；严厉的，严格的（看得见的）</li><li>severely：adv. 严重地, 严厉地, 严格地, 苛刻地</li><li>serious：adj. 严肃的，庄重的；不好的, 严重的, 有危险的；需认真思考的</li></ul><h4 id="rotate-relate"><a href="#rotate-relate" class="headerlink" title="rotate/relate"></a>rotate/relate</h4><ul><li>rotate：v. （使）旋转，（使）转动；（使）轮流</li><li>relate：v. 联系, 讲述, 叙述, 使有联系</li></ul><h4 id="spite-split"><a href="#spite-split" class="headerlink" title="spite/split"></a>spite/split</h4><ul><li><p>spite：</p><ul><li>n. 恶意, 怨恨; (短语in spite of)尽管</li><li>v. 刁难, 存心伤害, 故意使烦恼, 存心使苦恼</li></ul></li><li><p>split：</p><ul><li>v. 劈开; 切开; 撕裂; 分担; 分得; 使分裂; 使不团结; [化]分解; [核]使产生核裂变</li><li>n. 劈开; 分割; 裂口; 裂缝; 分裂; 派系; 裂片; 薄片; 劈叉; 平局</li></ul></li><li><p>despite prep.尽管 = in spite of </p></li></ul><h4 id="entire-entail"><a href="#entire-entail" class="headerlink" title="entire/entail"></a>entire/entail</h4><ul><li>entire：全部的，整个的</li><li>entail：v.需要，使其成为必要</li><li>involve：v.需要，包含，牵涉，使参与</li></ul><ul><li>proposal：</li><li>purpose：</li></ul><ul><li>grand：</li><li>gland：</li></ul><ul><li>revolve：</li><li>rotate：</li></ul><ul><li>detract：</li><li>distract：</li></ul><p>magnify amplify expand enlarge</p><ul><li>attitude：</li><li>altitude：</li><li>latitude：</li><li>longtitude：</li></ul><ul><li>complete：</li><li>compete：</li><li>competent：adj.有能力的，能胜任的</li><li>competence：n.能力，称职</li></ul><ul><li>derive：v.来自，起源，获得</li><li>deprive：v.剥夺，免职</li><li>deplete：v.耗尽，使枯竭</li><li>delete：v.删除</li><li>drain：v.耗尽，排出，喝光</li></ul><ul><li>capable：adj.有能力的</li><li>competent：adj.有能力的，能胜任的</li><li>viable：adj.可行的，可生存的</li></ul><ul><li>foreland：</li><li>upland：</li><li>hinterland：</li><li>headland：</li></ul><ul><li>demolish：</li><li>damage：</li><li>destroy：</li><li>destruct：</li></ul><ul><li>vessel：</li><li>artery：</li><li>vein：</li></ul><ul><li>barrier：</li><li>barrel：</li><li>barren：</li><li>barred：</li><li>barre：</li></ul><h4 id="proceed"><a href="#proceed" class="headerlink" title="proceed"></a>proceed</h4><ul><li>proceed：<ul><li>v.继续进行，接着做。</li><li>n.收益</li></ul></li><li>procedure：n.程序，步骤，手续</li><li>procession：<ul><li>n.行列，游行，一队人</li><li>v.排队前进</li></ul></li><li>proceeding：n.诉讼，过程，会议记录</li><li>proceeds：收益，第三人称复数</li><li>process：<ul><li>n.进程，流程，工序，工艺流程，程序，步骤，方法</li><li>v.处理，加工，审核</li></ul></li><li>processor：n.处理器，加工的工人</li><li>reprocess：v.再加工（废品）</li><li>processed：adj.经加工的，处理的</li></ul><ul><li>embark：</li><li>embank：</li></ul><h4 id="scent"><a href="#scent" class="headerlink" title="scent"></a>scent</h4><ul><li>adolescent：</li><li>scent：</li><li>scenery：</li><li>scene：</li><li>scenic：</li></ul><h4 id="cohere"><a href="#cohere" class="headerlink" title="cohere"></a>cohere</h4><ul><li><p>cohere：v.一致，连贯，团结一致，齐心协力</p><ul><li><p>her-（hes-）：粘附，坚持</p></li><li><p>co-：强调，共同，一起</p></li></ul></li><li><p>coherent：adj.条理清晰的，连贯的，前后一致的，协调的，一致的，有黏性的，聚合在一起的</p><ul><li>-ent：形容词后缀</li></ul></li><li><p>coherence：n.连贯性，条理性</p><ul><li>-ence：行为，状态，性质</li></ul></li><li><p>cohesion：n.内聚力，结合，凝聚性，粘合</p><ul><li>-sion：行为，状态</li></ul></li><li><p>cohesive：adj.结合一个整体的，使结合的，使内聚的</p><ul><li>-ive：倾向于，具有…的品质</li></ul></li></ul><p>相同词根her-：</p><ul><li>adhere：v.黏附，附着，坚守，遵守<ul><li>ad-：强调</li></ul></li><li>inherent：adj.内在的，固有的</li><li>adherent：<ul><li>n.信徒</li><li>adj.依附的，修饰语的（在名词之前）</li></ul></li><li>adherence：n.坚持，遵守，遵循</li></ul><p>相同词根hes-：</p><ul><li>adhesion：n.黏附（力）<ul><li>ad-：朝向</li></ul></li><li>adhesive：<ul><li>adj.黏合的，黏附的</li><li>n.黏合剂</li></ul></li><li>hesitate：v.犹豫，迟疑，顾虑，不愿做</li><li>hesitation：n.犹豫，迟疑，勉强，不情愿</li><li>hesitant：adj.犹豫的，不情愿的</li><li>hesitancy：n.犹豫，迟疑不决</li></ul><h4 id="declare-claim"><a href="#declare-claim" class="headerlink" title="declare + claim"></a>declare + claim</h4><ul><li><p>declare：v.宣布，声明，申报</p><ul><li>clar-：清楚，明亮，辉煌</li><li>de-：否定，向下，完全，反方向，来自</li></ul></li><li><p>declaration：n.公告，宣言，宣称，声明</p><ul><li>-tion：状态，动作，行为</li></ul></li><li><p>declarative：adj.陈述的</p><ul><li><p>claim-：说话，呼喊，叫喊</p></li><li><p>-ative：倾向于</p></li></ul></li><li><p>declared：adj.公开宣布的，declare的过去分词和过去式</p></li><li><p>declarer：n.宣言者，庄家</p></li></ul><p>相同词根claim-：说话，呼喊，叫喊</p><ul><li><p>claim：</p><ul><li><p>v.声称，宣称，认领，索取，获得，需要</p></li><li><p>n.索赔，宣称，声明，断言，要求，主张</p></li></ul></li><li><p>proclaim：v.宣告，宣布，表名，声明（正式）</p><ul><li>pro-：在…前面，向前，代表</li></ul></li><li><p>exclaim：v.大叫，呼喊，大声叫</p><ul><li>ex-：向外，完全，移除，没有，向上</li></ul></li><li><p>exclamation：n.呼喊，惊叫，感叹词，感叹句，感叹号</p><ul><li>-ation：行为，状态</li></ul></li><li><p>reclaim：v.收回，拿回，要求归还，开垦，改造</p><ul><li>re-：再次，向后，反方向</li></ul></li><li><p>acclaim：</p><ul><li>v.拥护，为…喝彩，称赞</li><li>n.赞扬，欢呼，欢迎</li></ul></li><li><p>disclaim：v.公开否认，拒绝承认，放弃权利</p><ul><li>dis-：否定，分离，完全，在不同方向</li></ul></li><li><p>disclaimer：n.免责声明，弃权声明</p></li><li><p>declaim：v.巧辩，雄辩，慷慨陈词，演说，朗诵</p><ul><li>de-：否定，向下，完全，反方向，来自</li></ul></li><li><p>declamatory：adj.慷慨陈词的，雄辩演说的</p><ul><li>-ory：与…相关</li></ul></li><li><p>declamation：n.雄辩，朗诵，慷慨激昂的演说</p></li><li><p>claimant：n.要求者，索要者，领取救济金者</p><ul><li>-ant：专长于某事的人</li></ul></li><li><p>unclaimed：adj.无人认领的，无人索取的</p><ul><li>un-：否定，相反，取消，取走，单一，一</li></ul></li></ul><p>相同词根clam-：说话，呼喊，叫喊</p><ul><li>clamor：<ul><li>v.吵闹的要求，大声喊叫，呼叫</li><li>n.扰攘，叫喊</li><li>-or：结果，状态</li></ul></li><li>clamour：<ul><li>v.吵闹的要求，大声喊叫，呼叫</li><li>n.吵闹，嘈杂声，民众的要求</li></ul></li><li>clamorous：adj.扰攘的，喧哗的<ul><li>-ous：具有某种品质</li></ul></li><li>proclamation：n.宣言，公告，声明</li><li>acclamation：n.欢呼，喝彩，欢迎，拥护</li><li>reclamation：n.回收，再生，开垦，土壤改良</li></ul><h4 id="compose"><a href="#compose" class="headerlink" title="compose"></a>compose</h4><h4 id="part"><a href="#part" class="headerlink" title="part"></a>part</h4><ul><li>part：</li><li>impart：</li><li>apart：</li><li>partial</li></ul><h4 id="inter"><a href="#inter" class="headerlink" title="inter-"></a>inter-</h4><p>inter-：一起，在…之间</p><ul><li><p>intervene：</p></li><li><p>interact：</p></li><li><p>interactive：</p></li><li><p>interstellar：</p></li><li><p>interest：</p></li><li><p>interesting：</p></li><li><p>interfere：</p></li><li><p>interface：</p></li><li><p>interior：</p></li><li><p>intermediate：</p></li><li><p>internal：</p></li></ul><h4 id="bound"><a href="#bound" class="headerlink" title="bound"></a>bound</h4><h3 id="1-2-同义词"><a href="#1-2-同义词" class="headerlink" title="1.2 同义词"></a>1.2 同义词</h3><h4 id="获得"><a href="#获得" class="headerlink" title="获得"></a>获得</h4><ul><li>attain：</li><li>achieve：</li><li>acquire：</li><li>gain：</li><li>chalk up：</li><li>clock up：</li></ul><h4 id="腐烂，分解"><a href="#腐烂，分解" class="headerlink" title="腐烂，分解"></a>腐烂，分解</h4><ul><li>decay：</li><li>rot：</li><li>decompose：</li><li>spoil：</li><li>decline：</li><li>degeneration：</li><li>deterioration：</li><li>fester：</li><li>perish：</li><li>putrefy</li></ul><h4 id="代表"><a href="#代表" class="headerlink" title="代表"></a>代表</h4><h4 id="抵消，弥补"><a href="#抵消，弥补" class="headerlink" title="抵消，弥补"></a>抵消，弥补</h4><ul><li>offset：</li><li>compensate：</li><li>counteract：</li><li>counterbalance：</li><li>counterpoise：</li><li>cancel out：</li><li>make up for：</li></ul><h4 id="发明"><a href="#发明" class="headerlink" title="发明"></a>发明</h4><ul><li>invent：</li><li>devise：</li><li>fabricate：</li><li>create：</li><li>make up：</li><li>cook up：</li></ul><h4 id="批评，指责"><a href="#批评，指责" class="headerlink" title="批评，指责"></a>批评，指责</h4><ul><li>censure：<ul><li>n.谴责，责备</li><li>v.谴责，指责</li></ul></li><li>condemn：v.指责，谴责，宣判，判处，使陷入（不愉快的境地）</li><li>condemnation：n.谴责，指责</li><li>denounce：v.谴责，痛斥，告发，检举</li><li>denounciation：n.谴责，痛斥，告发，检举</li><li>reprimand：v. / n. 训斥，谴责</li><li>reproach：v. / n. 责备，指责，谴责，自责</li><li>reprove：v.谴责，指责</li><li>reproof：n.谴责，指责</li><li>stricture：n.指责，反对，限制，约束</li><li>accuse：</li></ul><h4 id="重要的，不可缺少的，有活力的"><a href="#重要的，不可缺少的，有活力的" class="headerlink" title="重要的，不可缺少的，有活力的"></a>重要的，不可缺少的，有活力的</h4><ul><li>vital：adj.必不可少的，必要的，重要的，生机勃勃的</li><li>important：adj.重要的，必要的，有声望的，有影响的</li><li>essential：<ul><li>adj.必不可少的，基本的，本质的，根本的 </li><li>n.必需品</li></ul></li><li>significant：adj.数量相当大的，显著的，重要的，有意义的</li><li>integral：adj.基本的，必须的</li><li>energetic：adj.充满活力的，精力充沛的，积极主动的，强烈的</li><li>vigorous：adj.剧烈的，强度大的，活跃的，积极的</li><li>dynamic：<ul><li>adj.精力充沛的，活跃的，动态的 </li><li>n.动力，活力，动态，相互作用，力学，动力学</li></ul></li><li>peppy：adj.充满活力的，生机勃勃的</li></ul><h4 id="渴望的，焦虑的"><a href="#渴望的，焦虑的" class="headerlink" title="渴望的，焦虑的"></a>渴望的，焦虑的</h4><p>核心词：</p><ul><li>anxious：adj.焦虑的，渴望的，担心的</li><li>anxiety：n.焦虑，忧虑，担心，害怕</li></ul><p>焦虑的：</p><ul><li>nervous：adj.焦虑的，担忧的，惶恐的，神经质的</li><li>edgy：adj.紧张的，躁动不安的，激动人心的</li><li>jittery：adj.紧张不安的，心神不宁的</li><li>perturbed：adj.焦虑的，不安的，烦躁的。purturb的过去式和过去分词<ul><li>perturb：v.使焦虑，使不安</li><li>perturbation：n.扰动，忧虑</li><li>disturb：v.扰乱，妨碍，使…不安</li><li>disturbed：adj.有精神病的，心理不正常的，不安的，烦恼的。disturb的过去式和过去分词</li><li>per-：借助，通过，超越，完全</li><li>turb-：喧嚣，混乱，旋转，旋流</li></ul></li><li>upset：<ul><li>adj.不快的，烦恼的，难过的，失望的</li><li>v.使生气，使心烦，打乱，扰乱，弄翻</li><li>n.忧虑，烦闷，苦恼，爆冷门</li><li>sad：adj.悲哀的，难过的</li><li>unhappy：adj.不快乐的，难过的</li><li>……</li></ul></li><li>worried：adj.担心的，担忧的，发愁的。worry的过去式和过去分词<ul><li>worry：<ul><li>v.担心，担忧，发愁</li><li>n.担心，忧虑</li></ul></li><li>worrisome：adj.令人担心的，-some：形容词词尾。</li><li>worrying：adj.令人担心的。worry的现在分词</li></ul></li><li>uneasy：adj.担心的，忧虑的，不稳定的，靠不住的，令人不舒服的，不和谐的<ul><li>uneasiness：n.不安，忧虑</li></ul></li><li>ill at ease：phrase.不自在，局促不安，心神不宁</li><li>agitate：v.搅动，鼓动，激怒，使不安<ul><li>agitated：adj.焦虑不安的，激动地。agitate的过去式和过去分词</li></ul></li><li>discomfort：<ul><li>n.不适，不安，轻微的病痛</li><li>v.使不舒服，使不安，使尴尬</li></ul></li><li>discompose：v.扰乱，使不安，使心烦意乱<ul><li>compose：v.组成，写作，作曲，使镇静</li></ul></li><li>disquiet：<ul><li>n.不安，忧虑，烦恼</li><li>v.使不安</li></ul></li><li>flurry：<ul><li>n.一阵忙乱，小阵雪，小雨</li><li>v.搅乱，使混乱，使慌张</li></ul></li><li>unsettle：v.使心神不宁，扰乱，使担忧</li><li>concern：<ul><li>n.担心，忧虑，公司，企业</li><li>v.涉及，影响，牵涉，与…有关</li><li>concerned：adj.担心的，忧虑的，感兴趣的，关注的。concern的过去式和过去分词</li></ul></li><li>alarm：<ul><li>n.警报，警报器，闹钟，惊慌，惊恐</li><li>v.使惊恐，使担心，使害怕，安装警报器</li></ul></li><li>bother：<ul><li>v.打扰，花费时间/精力做…，使…烦恼</li><li>n.麻烦，困难</li><li>int.表示对某事/某人烦恼</li></ul></li></ul><p>渴望的：</p><ul><li>thirsty：adj.渴望的，口渴的，干旱的，缺水的，耗油的<ul><li>arid：adj.干旱的，干燥的</li><li>dry：<ul><li>adj.干的，干燥的，干旱的，枯竭的，吸干的，被榨干的</li><li>v.变干，弄干，擦干</li><li>n.干旱，干燥</li></ul></li><li>droughty：adj.干旱的，干燥的，口渴的（古）</li></ul></li><li>thirst：n.渴望，口渴，渴求</li><li>longing：<ul><li>n.渴望，热望</li><li>adj.渴望的，热望的</li></ul></li><li>yearn：v.渴望，渴求</li><li>yearning：<ul><li>n.渴望，向往</li><li>adj.思慕的，渴望的</li><li>v.yearn的现在分词</li></ul></li><li>eager：adj.渴望的，热切的</li><li>keen：<ul><li>adj.热衷的，热情的，渴望的，敏捷的，灵敏的，锋利的，对…有兴趣的，被…吸引的</li><li>n.恸哭，挽歌</li><li>v.恸哭</li></ul></li><li>keener：<ul><li>adj.渴望的，热衷于，喜爱的</li><li>n.号哭，挽歌</li><li>v.号哭</li></ul></li><li>itch：<ul><li>v.渴望，发痒</li><li>n.痒，渴望</li></ul></li><li>raring：adj.迫不及待的，渴望的</li></ul><h4 id="干预，介入"><a href="#干预，介入" class="headerlink" title="干预，介入"></a>干预，介入</h4><ul><li>intervene</li></ul><h4 id="组成，构成"><a href="#组成，构成" class="headerlink" title="组成，构成"></a>组成，构成</h4><ul><li>consist：<ul><li>consist of：由…组成</li><li>consist in：存在于</li><li>consist with：与…一致</li></ul></li><li>comprise：</li><li>constitute：</li><li>form：</li><li>compose：</li></ul><h4 id="同意，允许"><a href="#同意，允许" class="headerlink" title="同意，允许"></a>同意，允许</h4><ul><li>grant：</li><li>acknowledge：</li><li>agree：</li><li>allow：</li><li>concede：</li><li>admit：</li><li>allocation：</li><li>appropriation：</li></ul><h4 id="精确，准确，要求"><a href="#精确，准确，要求" class="headerlink" title="精确，准确，要求"></a>精确，准确，要求</h4><ul><li>exact：</li><li>exactly：</li><li>accurate：</li><li>accuracy：</li><li>inaccurate：</li><li>precise：</li><li>precision：</li><li>correct：</li><li>claim：</li><li>demand：</li><li>call for：</li></ul><h4 id="揭露，公开"><a href="#揭露，公开" class="headerlink" title="揭露，公开"></a>揭露，公开</h4><ul><li>disclose：</li><li>reveal：</li><li>expose：</li><li>uncover：</li><li>unmask：</li><li>revelation：</li><li>disclosure：</li><li>uncovery：</li><li>unveiled：</li></ul><h4 id="想象"><a href="#想象" class="headerlink" title="想象"></a>想象</h4><ul><li>imagine：</li><li>imagination：</li><li>conceive：</li><li>envisage：</li><li>envision：</li><li>fancy：</li><li>fantasize：</li><li>visualize：</li><li>picture：</li><li>conjure up：</li></ul><h4 id="弯曲，歪曲"><a href="#弯曲，歪曲" class="headerlink" title="弯曲，歪曲"></a>弯曲，歪曲</h4><ul><li>skew：</li><li>distort：</li><li>warp：</li><li>misinterpret：</li><li>misconstrue：</li><li>tilt：</li><li>crooked：</li><li>awry：</li><li>askew：</li><li>lopsided：</li><li>skewed：</li><li>screw</li></ul><h4 id="抓住，抓取"><a href="#抓住，抓取" class="headerlink" title="抓住，抓取"></a>抓住，抓取</h4><ul><li><p>grab：</p><ul><li>v.抓住，抓取，利用机会做…，赶紧…</li><li>n.争夺</li></ul></li><li><p>抓住，握住：clutch clench cling grip grasp inclip</p><p>glimpse</p></li></ul><h4 id="估价，评价"><a href="#估价，评价" class="headerlink" title="估价，评价"></a>估价，评价</h4><ul><li>estimate：</li><li>appraise：</li><li>assess：</li><li>evaluate：</li><li>value：</li><li>appraisal：</li><li>assessment：</li><li>estimation：</li><li>evaluation：</li><li>reckoning：</li><li>valuation：</li></ul><h4 id="组成，构成-1"><a href="#组成，构成-1" class="headerlink" title="组成，构成"></a>组成，构成</h4><ul><li>constitute：主语表事物的组成部分，宾语表示事物整体</li><li>consist：与of连用，指一个整体是由几个部分所组成，或由某些材料构成</li><li>compose：多用被动态，指将多个人/物放到一起形成整体</li><li>comprise：指整体是由几个独立的部分所组成</li><li>form：</li><li>make up：</li><li>constitution：</li></ul><h4 id="线"><a href="#线" class="headerlink" title="线"></a>线</h4><ul><li>string：</li><li>rope：</li><li>line：</li><li>cord：</li><li>thread：</li><li>wire：</li></ul><p>截图</p><h4 id="交换"><a href="#交换" class="headerlink" title="交换"></a>交换</h4><ul><li>switch：</li><li>swap：</li><li>replace：</li><li>exchange：</li><li>substitute：</li><li>change：</li><li>barter：</li><li>dicker：</li><li>trade：</li><li>shift：</li><li>displace：</li><li>transpose：</li><li>transfer：</li></ul><h4 id="参加，出席"><a href="#参加，出席" class="headerlink" title="参加，出席"></a>参加，出席</h4><ul><li>present：<ul><li>adj.目前的，现在的，出席的，在场的，存在的</li><li>v.颁发，授予，赠送，提出，呈现，介绍</li><li>n.目前，现在，礼物</li><li>sent-：存在</li></ul></li><li>presence：n.出席，存在，风度</li><li>attendance：n.出席</li><li>attend：v.参加，照料</li><li>absent：<ul><li>adj.缺席的，缺少的，心不在焉的</li><li>v.缺席，不参加，不在</li><li>prep.没有，缺乏</li></ul></li><li>absence：n.没有，缺乏，缺席</li><li>absentee：n.缺席者，缺勤者</li><li>absenteeism：n.旷工，旷课</li><li>absentminded：adj.心不在焉的，健忘的</li><li>absently：adv.心不在焉地，出神地</li><li>represent：v.代表，表示，象征，表现</li></ul><p>appearance presence attend present presently presentation</p><h4 id="击打"><a href="#击打" class="headerlink" title="击打"></a>击打</h4><ul><li>strike：<ul><li>v.击打，撞击，（疾病）侵袭，进攻，使突然想起，使受吸引，（光）照到…上，罢工，删除，铸造，开采出</li><li>n.击打，敲，袭击，罢工，矿藏发现，挫折</li><li>strike struck struck（过去式，过去分词）</li></ul></li><li>hit：</li><li>beat：</li><li>bang：</li><li>pound：</li><li>attack：</li><li>knock：</li><li>walkout：</li><li>stoppage：</li><li>setback：</li><li></li></ul><p>派生：</p><ul><li>striking：adj.引人注目的，显著的，妩媚动人的，俊秀的</li><li>stricken：adj.受煎熬的，患病的，遭受挫折的</li><li>striker：n.前锋，罢工者，罢课者</li></ul><h4 id="不重要的"><a href="#不重要的" class="headerlink" title="不重要的"></a>不重要的</h4><ul><li>trivial：adj.不重要的，琐碎的，微不足道的</li><li>fiddling：<ul><li>adj.琐碎的，繁琐的</li><li>v.fiddle的现在分词，fiddle：<ul><li>n.小提琴，欺诈，骗局，小麻烦</li><li>v.不停摆弄，篡改，动手脚，虚度光阴</li></ul></li><li>n.小提琴表演</li></ul></li><li>inconsequential：adj.不重要的，琐碎的，微不足道的<ul><li>consequential：adj.随之而来的，相应发生的，作为结果的，重要的</li><li>consequent：adj.随之发生的，作为结果的，合乎逻辑的</li><li>consequence：n.结果，后果</li><li>consequently：adv.因此，所以</li><li>inconsequent：adj.不连贯的，矛盾的，不重要的</li></ul></li><li>inconsiderable：adj.不值得考虑的<ul><li>consider：v.认为，觉得，以为，顾及，考虑，思考</li><li>considerable：adj.相当大的，相当多的，重大的，重要的</li><li>consideration：n.考虑，体贴</li><li>reconsider：v.重新考虑，重新审议</li></ul></li><li>insignificant：adj.无关紧要的，不重要的<ul><li>insignificance：n.无意义，无价值，不重要</li></ul></li><li>negligible：adj.微不足道的，不重要的，不值一提的</li><li>unimportant：adj.不重要的，无足轻重的</li><li>paltry：adj.可忽略不计的，微小的，微不足道的</li><li>lowly：<ul><li>adj.地位低的，不重要的</li><li>adv.谦恭地，卑下地，低声地</li></ul></li><li>marginal：adj.小的，微不足道的，不重要的，边缘的</li><li>niggling：<ul><li>adj.烦人的，不重要的，微不足道的</li><li>n.麻烦事</li><li>niggle的现在分词：<ul><li>v.使烦恼，使焦虑，吹毛求疵，挑剔</li><li>n.轻微的批评，小牢骚，轻微疼痛</li></ul></li></ul></li><li>trifling：adj.琐碎的，微不足道的，不重要的，trifle的现在分词</li><li>trifle：<ul><li>n.小事，琐事，小玩意，不值钱的东西，少量，一点儿</li><li>v.开玩笑，轻视，戏弄，虚度光阴，浪费</li></ul></li></ul><h4 id="不同的"><a href="#不同的" class="headerlink" title="不同的"></a>不同的</h4><ul><li>different：adj.与众不同的，不同的，有区别的</li><li>distinct：adj.清晰的，明显的，截然不同的，有区别的，不容忽视的</li><li>disparate：<ul><li>adj.由不同的人组成的，迥然不同的，无法比较的，不相干的</li><li>n.无法比较的东西</li></ul></li><li>dissimilar：adj.不一样的，不同的，不相似的</li><li>diverse：adj.不同的，多种多样的</li><li>unlike：<ul><li>prep.不像，与…不同</li><li>adj.不同，不像</li></ul></li></ul><h4 id="开始"><a href="#开始" class="headerlink" title="开始"></a>开始</h4><ul><li>commence：v.开始发生，开始，着手</li><li>begin：</li><li>embark：</li><li>enter upon：</li><li>fall to：</li><li>kick off：</li><li>lead off：</li></ul><h4 id="混合，融合"><a href="#混合，融合" class="headerlink" title="混合，融合"></a>混合，融合</h4><ul><li>blend：<ul><li>v.混合，融合</li><li>n.混合</li></ul></li><li>amalgam：</li><li>amalgamate：</li><li>commingle：</li><li>commix：</li><li>incorporate：</li><li>integrate：</li><li>merge：</li><li>combination：</li><li>fusion：</li><li>admixture：</li><li>intermixture：</li><li>mix：</li></ul><h4 id="怀疑"><a href="#怀疑" class="headerlink" title="怀疑"></a>怀疑</h4><ul><li>suspicious：</li><li>suspect：</li><li>dodgy：</li><li>dubious：</li><li>queer：</li><li>questionable：</li><li>doubtful：</li><li>question：</li><li>skeptical：</li><li>sceptical：</li><li>distrust：</li><li>impeach：</li></ul><h4 id="激励"><a href="#激励" class="headerlink" title="激励"></a>激励</h4><ul><li>motivate：v. 激励，激发<ul><li>motive：n. 动机，目的</li><li>motivation：n. 动力, 动机的形成, 动机因素</li><li>motivator：n. 激发因素，动因</li><li>motivated：v. （“motivate”的过去分词和过去式）激励，激发 adj. 有动机的；有积极性的</li></ul></li><li>incent：v. 刺激…采取行动, 激动</li><li>incentive：<ul><li>n. 激励, 刺激, 鼓励</li><li>adj. 刺激性的</li></ul></li><li>inspire：v. 激励，鼓舞；启发，使产生灵感<ul><li>inspiration：n. 灵感；启发灵感；鼓舞人心（的人或物）；妙计，好主意</li><li>inspirational：adj. 启发灵感的, 鼓舞人心的</li><li>inspiring：adj. 鼓舞人心的, 激励的, 启发灵感的 v. “inspire”的现在分词</li><li>uninspiring：adj. 不能让人提起精神来的</li><li>inspired：adj. 品质优秀的, 能力卓越的, 借助于灵感创作的 v. “inspire”的过去式和过去分词</li><li>uninspired：adj. 无创意的, 不激励人心的, 乏味的</li><li>inspiratory：adj. 吸气的, 吸入的</li></ul></li><li>encourage：v. 鼓励, 激励, 促进, 助长<ul><li>courage：n. 勇气, 勇敢, 无畏, 胆量</li><li>encouragement：n. 鼓励, 鼓舞, 起激励作用的事物</li><li>encouraging：adj. 鼓舞人心的；鼓励的 v. “encourage”的现在分词</li><li>courageous：adj. 勇敢的；无畏的</li></ul></li></ul><h2 id="二-词缀词根"><a href="#二-词缀词根" class="headerlink" title="二. 词缀词根"></a>二. 词缀词根</h2><h3 id="2-1-词缀-头"><a href="#2-1-词缀-头" class="headerlink" title="2.1 词缀-头"></a>2.1 词缀-头</h3><ul><li>de-：否定，向下，完全，反方向，来自</li><li>dis-：否定，分离，完全，在不同方向</li><li>com-：强调，共同，一起</li><li>con-：强调，共同，一起</li><li>ex-：向外，完全，移除，没有，向上</li><li>in-：趋向，朝着，里面</li><li>sub-：在…下，少于，低于，在下，次级的，局部的，副的</li><li>ad-：强调，向，朝向</li><li>at-：朝向</li><li>ab-：来自</li><li>en-：置于…之中，使处于…状态，赋予，使成为</li><li>re-：再次，向后，反方向</li><li>per-：借助，通过，超越，完全</li><li>pro-：在…前面，向前，代表</li><li>un-：否定，相反，取消，取走，单一，一</li><li>se-：独自，没有，在旁边</li></ul><h3 id="2-2-词缀-尾"><a href="#2-2-词缀-尾" class="headerlink" title="2.2 词缀-尾"></a>2.2 词缀-尾</h3><ul><li>-gist：学家，职业</li><li>-ology：学科，科学（名词词尾）</li><li>-tude：状态，品质，条件（名词词尾）</li><li>-ile：有…能力，有…的倾向</li><li>-ible：可以…的（形容词词尾）</li><li>-able：可以…的（形容词词尾）</li><li>-ity：状态，品质（抽象名词词尾）</li><li>-ive：倾向于，有…的品质（形容词词尾）</li><li>-ious：具有某种品质（形容词词尾）</li><li>-ous：具有某种品质</li><li>-ment：行为，结果</li><li>-able：可以…的</li><li>-ary（-ar）：具备…性质，与…相关</li><li>-al：（-ial） 关于，与…相关</li><li>-ate：做，使，让（动词词尾）</li><li>-tion：状态，动作，行为（名词词尾）</li><li>-sion：行为，状态（名词词尾）</li><li>-uous：倾向于</li><li>-eal：与…相关的，关于（形容词词尾）</li><li>-ure：行为，结果（名词词尾）</li><li>-ence：行为，状态，性质（名词词尾）</li><li>-ory：与…相关（形容词词尾）</li><li>-ant：<ul><li>专长于某事的人（名词词尾）</li><li>形容词后缀（形容词词尾）</li><li>某事，某物</li></ul></li><li>-ent：形容词后缀（形容词词尾）</li><li>-some：（形容词词尾）</li><li>-or（-our）：结果，状态；某人，某物（名词词尾）</li><li>-ic：与…相关，…的本质（形容词词尾）</li><li>-ly：把名词变形容词，把形容词变副词（副词/形容词词尾）</li><li>-age：（名词词尾）</li><li>-ular：与…有关的</li></ul><h3 id="2-3-词根"><a href="#2-3-词根" class="headerlink" title="2.3 词根"></a>2.3 词根</h3><p>pet-：寻求，追寻</p><p>per-：借助，通过，超越，完全</p><p>cult-：耕种，培养</p><p>fer-：生产</p><p>riv-：河流，河岸</p><p>potent：能力，力量，控制</p><p>contra-：反对，对面，不同，冲突</p><p>sta：站立，固定，静止，停留</p><p>pel：驱动，推动，驱逐</p><p>vacu-：空的，清空，撤离</p><p>sper-：希望，desperate</p><p>-stinct：分开，扑灭，消灭，清除</p><p>-sist：站立，固定，静止，停留</p><p>turb-：喧嚣，混乱，旋转，旋流</p><ul><li>-lig-：挑选，收集</li><li>同：-lect-，-lection，</li><li>-lig-：阅读，可读</li><li>同：-lect-，leg-，-ligi-</li></ul><h3 id="2-4-常见词根对应词汇"><a href="#2-4-常见词根对应词汇" class="headerlink" title="2.4 常见词根对应词汇"></a>2.4 常见词根对应词汇</h3><h4 id="apt"><a href="#apt" class="headerlink" title="apt-"></a>apt-</h4><p>apt-, ept-【拉丁】 表示“适应”；“合适的”；“加入”；“系紧”</p><p><strong>同根词</strong>adapt|attitude|apt|adaptable|adept|aptitude|inapt|</p><p>apt-：适应，合适的</p><ul><li>adapt：</li></ul><h4 id="cap-cip-capt-cept-ceive-ceipt-ceit-cipient"><a href="#cap-cip-capt-cept-ceive-ceipt-ceit-cipient" class="headerlink" title="cap-, cip-, capt-, cept-, ceive, -ceipt, -ceit, -cipient"></a>cap-, cip-, capt-, cept-, ceive, -ceipt, -ceit, -cipient</h4><p><strong>cap-, cip-, capt-, cept-, ceive, -ceipt, -ceit, -cipient</strong>【拉丁】捕捉，抓，握住；收到；包括；被抓，被俘</p><p><strong>同根词</strong>accept|acceptable|receptacle|susceptible|conceive|acceptance|anticipate|concept|</p><h4 id="cess"><a href="#cess" class="headerlink" title="-cess"></a>-cess</h4><p>-cede, -ceed, -cess, -cease【拉丁】移动；走，走开；放弃</p><p><strong>同根词</strong>incessant|access|exceed|exceedingly|excess|excessive|necessary|</p><p>-cess：</p><ul><li>accessory：</li><li>access：</li><li>ancestor：</li><li>process：</li><li>procession：</li><li>succession：</li><li>concession：</li><li>predecessor：</li></ul><p>-cede：</p><ul><li>preceding：</li><li>procedure：</li><li>precede：</li><li>accede：</li><li>cede：</li><li>concede：</li></ul><p>-cease：</p><ul><li>ceaseless：</li></ul><p>-cess：让步，放弃</p><ul><li>incessant：</li><li>concessive：</li></ul><p>-ceed：移动，走</p><ul><li>exceed：</li><li>proceed：</li><li>succeed：</li><li>proceeding：</li><li>proceeds：</li><li>exceeding：</li></ul><p>-cess：产出</p><ul><li>excess：</li><li>excessive：</li></ul><h4 id="ceive"><a href="#ceive" class="headerlink" title="ceive-"></a>ceive-</h4><p>ceive-：捕捉，抓，握住</p><ul><li>conceive：</li><li>concept：</li><li>conception：</li><li>conceptual：</li><li>conceptualize：</li><li>…</li></ul><p>cap-：</p><ul><li>occupy：</li></ul><h4 id="credit"><a href="#credit" class="headerlink" title="credit-"></a>credit-</h4><p>credit-：相信，信任，信念</p><ul><li>credit：</li></ul><h4 id="culture"><a href="#culture" class="headerlink" title="-culture"></a>-culture</h4><p>-cult：耕种，培养</p><p>-culture：耕种，培养</p><p>-cultural：耕种，培养</p><p>agri-：田地，土地</p><ul><li>cultivate：v.耕作，种植，培养，结交，建立，加强</li><li>cultivation：n.栽培，修养，文化，教化</li><li>cultural：adj.与文化有关的，文化的</li><li>cultivated：<ul><li>adj.有教养的，有修养的，举止优雅的，用于耕作的</li><li>v.cultivate的过去式和过去分词</li></ul></li><li>cultivable：adj.可耕作的</li><li>agriculture：n.农业</li><li>apiculture：n.养蜂，养蜂学</li><li>horticulture：n.园艺，园艺学</li><li>aviculture：n.养鸟，鸟类饲养</li><li>arboriculture：n.树木栽培研究</li><li>sericulture：n.养蚕，养蚕业</li><li>aquaculture：n.水产养殖，水产养殖学</li><li>mariculture：n.海水养殖</li><li>pisciculture：n.养鱼，养鱼业，养鱼术</li><li>agricultural：adj.农学的，农业的</li><li>horticultural：adj.园艺的</li></ul><h4 id="cur"><a href="#cur" class="headerlink" title="cur-"></a>cur-</h4><p>cur-：关心，照顾</p><ul><li>assure：v.保证，确信，确保</li><li>curious：adj.好奇的，稀奇的</li><li>curiosity：n.好奇心，求知欲，珍品，罕见有趣的东西</li><li>secure：<ul><li>adj.安心的，安全的，牢固的，稳定的，有把握的</li><li>v.使安全，担保，保护，使获得</li><li>se-：独自，没有，在旁边</li></ul></li><li>security：n.安全措施，保安部门，担保，保证，安全，证券，抵押品。</li><li>securely：adv.安心地</li><li>insecure：adj.缺乏信心的，无把握的，不安全的</li><li>unsecured：adj.不稳当的，未固定的，无担保的</li><li>accurate：（cura-）adj.准确的，精确的</li><li>inaccurate：adj.不准确的，有错误的</li><li>accuracy：n.准确性，精确度</li><li>curator：n.馆长</li><li>procure：v.取得，诱使卖淫</li><li>procurement：n.（为政府或机构）采购</li></ul><p>cur-：治愈</p><ul><li>cure：<ul><li>v.治疗，治愈</li><li>n.治疗，治愈，疗法，解决方法</li></ul></li><li>curable：adj.可医治的，可治愈的</li><li>curative：<ul><li>adj.能治病的，有疗效的</li><li>n.医药，治疗物</li></ul></li></ul><h4 id="dict-dic"><a href="#dict-dic" class="headerlink" title="dict-/dic-"></a>dict-/dic-</h4><p>dict-：说话，断言</p><p>dic-：说话，断言</p><ul><li>dictate：</li><li>indicate：</li><li>indication：</li><li>indicative：</li><li>indicator：</li><li>dictionary：</li><li>predict：</li><li>contradict：</li><li>dictator：</li><li>verdict：</li><li>contradictory：</li><li>vindicate：</li><li>contradition：</li><li>dedicate：<ul><li>相似：delicate，delegate，devote</li></ul></li><li>predicament：</li><li>abdicate：</li><li>benediction：</li></ul><h4 id="duc-duce-duct"><a href="#duc-duce-duct" class="headerlink" title="duc-/-duce/-duct"></a>duc-/-duce/-duct</h4><p><strong>duc-, -duce, -duct, -ducent, -ductor, -duction, -ductive, -ducer, -ducement, -ducation</strong>【拉丁】表示“带领，引领”；“带来”；“向前或向外拉”</p><ul><li>conduct：</li><li>induct：</li></ul><h4 id="duce"><a href="#duce" class="headerlink" title="-duce"></a>-duce</h4><p>-duce：带领，引领，带来</p><ul><li>introduce：v.介绍，引进，实施，采用，将…放入，作为…的开头，将…提交讨论</li><li></li></ul><h4 id="estim"><a href="#estim" class="headerlink" title="estim-"></a>estim-</h4><p>estim-：估价，评估</p><ul><li>estimate：</li><li></li></ul><h4 id="fert"><a href="#fert" class="headerlink" title="fert-"></a>fert-</h4><ul><li>fertile：</li></ul><h4 id="gress-grade-grad-gree"><a href="#gress-grade-grad-gree" class="headerlink" title="-gress/-grade/grad-/-gree"></a>-gress/-grade/grad-/-gree</h4><p>-gress：行走</p><p>-grade：走，四处走动</p><p>grad-：行走，步，阶段</p><p>-gree：走，四处走动</p><ul><li>progress：</li><li>aggressive：</li><li>progressive：</li><li>digress：</li><li>digression：</li><li>egress：</li><li>ingress：</li><li>regressive：</li><li>retrogress：</li><li>centigrade：</li><li>retrograde：</li><li>anterograde：</li><li>degrade：</li><li>gradient：</li><li>biodegradable：</li><li>postgraduate：</li><li>downgrade：</li><li>degrading：</li><li>degree：</li><li>gradual：</li><li>graduation：</li><li>gradation：</li></ul><h4 id="leg"><a href="#leg" class="headerlink" title="leg-"></a>leg-</h4><p>leg-：</p><ul><li>legal：</li><li></li></ul><h4 id="lig"><a href="#lig" class="headerlink" title="-lig"></a>-lig</h4><p>-lig-：挑选，收集</p><ul><li>eligible：</li><li>negligible：</li><li>negligence：</li><li>negligent：</li></ul><h4 id="mis-mit"><a href="#mis-mit" class="headerlink" title="mis-/mit-"></a>mis-/mit-</h4><p><strong>miss-, mis-, -miss, -mis, mit-, mitt-, -mit, -mitt</strong>【拉丁】表示“送，释放”；“放出”；“扔，投掷”</p><ul><li><p>commit：v. 犯罪, 做错(坏)事；承诺, 使承担义务, 使作出保证, 使卷入；委托, 把…托付给；调拨 (钱、资源)</p><ul><li><p>committee：n. 委员会</p><ul><li>subcommittee：n. （委员会内的）小组委员会</li></ul></li><li><p>commitment：n. 承诺, 投入, 保证, 许诺；委托；献身</p></li><li><p>recommit：v. 重新审议；重新委托</p></li><li><p>committal：n. 收监, 拘押, 送入（精神病院）；下葬；火化</p><ul><li>noncommittal：adj. (态度,观点等)不明朗的, 不承担义务的</li></ul></li><li><p>committed：adj. 尽心尽力的；坚信的；坚定的 v. commit的过去式和过去分</p><ul><li>uncommitted：adj. 未作承诺的, 未表态的</li></ul></li></ul></li><li><p>admit：</p><ul><li>admission：</li><li>admittance：</li></ul></li><li><p>premise：</p></li><li><p>commission：</p></li><li><p>dismiss</p></li></ul><h4 id="mot-mov"><a href="#mot-mov" class="headerlink" title="mot-/mov-"></a>mot-/mov-</h4><p>**mot-, moto-, -motile, -motility, -motorial, -motoric, -motive, -motored; mov-**【拉丁】表示“移动”</p><ul><li>motion：<ul><li>n. 运动；移动；动作；动议</li><li>v. 运动；向…打手势</li></ul></li><li>motive：</li><li>emotion：</li><li>emotional：</li><li>locomotive：</li><li>mobile：</li><li>moment：</li><li>motivate</li></ul><h4 id="not"><a href="#not" class="headerlink" title="not-"></a>not-</h4><p>not-：标记，逐渐了解</p><ul><li>note：<ul><li>n.笔记，注释，记录，便条，票据，音符，音调</li><li>v.注意，指出，留意，特别提到</li></ul></li><li>notice：<ul><li>v.注意，留意，意识到</li><li>n.注意，通知，布告</li></ul></li><li>notify：v.通报，通知</li><li>notarize：v.公证，由人证实</li><li>noticeable：adj.显著的，显而易见的</li><li>denote：v.象征，预示，表示</li><li>notable：<ul><li>adj.值得注意的，显著的，重要的</li><li>n.名人，重要任务</li></ul></li><li>noted：<ul><li>adj.著名的，有声望的</li><li>v.note的过去式和过去分词</li></ul></li><li>notion：n.观念，想法，主张</li></ul><h4 id="ordinate"><a href="#ordinate" class="headerlink" title="-ordinate"></a>-ordinate</h4><ul><li>ordinate：</li><li>inordinate：</li><li>coordinate：</li><li>subordinate：</li><li>insubordinate</li><li>ordination：</li><li>coordination：</li><li>coordinator：</li></ul><p>ord-：</p><ul><li>order：</li><li>disorder：</li><li>orderly：</li><li>primordial：</li><li>disorderly：</li></ul><p>-ordin-：</p><ul><li>ordinary：</li><li>extraordinary：</li><li>extraordinarily：</li><li>ordinarily：</li><li>ordinace：</li><li>ordinal：</li></ul><h4 id="pel"><a href="#pel" class="headerlink" title="-pel"></a>-pel</h4><p>-pel：驱动，推动，驱逐</p><ul><li>propel：</li><li>expel：</li><li>repel：</li><li>compel：</li><li>dispel：</li><li>impel：</li></ul><p>-peal：驱动，推动，驱逐</p><ul><li>appeal：</li><li>repeal：</li><li>appealing：</li><li>appellate：</li><li>peal：</li><li>appellant：</li></ul><p>-pell：驱动，推动，驱逐</p><ul><li>propeller：</li><li>propellant：</li></ul><p>-pellent：驱动，推动，驱逐</p><ul><li>repellent：</li></ul><h4 id="popu"><a href="#popu" class="headerlink" title="popu-"></a>popu-</h4><ul><li>popu-：人民（拉丁）</li><li>populate：v.居住于，生活于，构成…的人口，迁移</li><li>popular：<ul><li>adj.受喜爱的，受欢迎的</li><li>n.大众音乐会</li></ul></li><li>population：n.人口，种群</li><li>populace：n.民众</li><li>popularity：n.普及，流行，受欢迎，声望</li><li>populous：adj.人口众多的，人口密集的</li><li>popularize：v.推广，宣传</li><li>overpopulated：adj.人口过多的</li></ul><h4 id="pos"><a href="#pos" class="headerlink" title="pos-"></a>pos-</h4><ul><li><p>decompose：</p></li><li><p>compose：</p></li><li><p>suppose：</p></li><li><p>composure：</p></li><li><p>dispose：</p></li><li><p>expose：</p></li><li><p>exposure： </p></li><li></li></ul><h4 id="priv"><a href="#priv" class="headerlink" title="priv-"></a>priv-</h4><ul><li>deprive：</li><li>privilege：</li><li>privacy：</li><li>deprivation：</li><li>privation：</li><li>privy：</li><li>privity：</li><li>privily：</li><li>privilege：</li><li>privileged：</li><li>private：</li><li>privately：</li><li>privateer：</li><li>privatize：</li></ul><h4 id="put"><a href="#put" class="headerlink" title="put-"></a>put-</h4><p>put-：修建，切掉，测算，思考</p><ul><li>impute</li></ul><h4 id="quir"><a href="#quir" class="headerlink" title="quir-"></a>quir-</h4><p><strong>quir-, quisit-, quis-, que-, quer-, quest-, -quirement, -quirable, -quisition, -quisitive</strong>【拉丁】表示“寻求，询问”</p><p><strong>uest,quir, quis, quer</strong>【拉丁】表示“寻求，询问”</p><ul><li><p>acquire：v. 获得, （通过努力、能力、行为表现）获得, 购得, 得到</p><ul><li>acquisition：n. (技能、习惯或品质的)习得, 培养; (一家公司对另一家公司的) 收购; 资产获得, 获得物</li><li>acquisitive：adj. 渴求获取财物的，贪婪的</li><li>acquirer：n. 获得物</li><li>acquirement：n. 取得，（通过训练获得的）技能</li></ul></li><li><p>enquire：v. 询问, 调查, 打听</p><ul><li>enquiry：n. 查询, 调查, 询问, 探索</li><li>enquirer：n. 询问者, 调查者</li></ul></li><li><p>inquire：v. 询问, 打听, 调查, 〈古〉质问</p><ul><li>inquiry：n. 打听，询问；调查，查问；探究，探索</li><li>inquisitive：adj. 过分打听他人私事的, 好学的, 好奇的, 兴趣广泛的 n. 好询问的人</li><li>inquirer：n. 调查者</li><li>inquiring：adj. 好奇的, 爱追根究底的 v. “inquire”的现在分词</li><li>inquisition：n.宗教审判所，一连串的提问</li></ul></li><li><p>require：v. 需要, （法律或规则）要求，规定</p><ul><li>requirement：n. 必要条件, 所需的（或所要的）东西, 必备的条件</li><li>requisition：v. （尤指战时或紧急状态时）征用 n. 征用, 需要, 正式要求</li></ul></li><li><p>quest：</p><ul><li>n. 探索，寻找，追求</li><li>v. 探索；探求</li></ul></li><li><p>query：</p><ul><li>n. 询问, 疑问, 问号</li><li>v. 询问, 怀疑, 表示疑虑</li></ul></li><li><p>request：</p><ul><li>n. 要求，请求</li><li>v. 请求，要求</li></ul></li><li><p>question：</p><ul><li>n. 问题，疑问；怀疑；议题</li><li>v. 问；怀疑；质询；正式提问</li><li>questionable：adj. 可疑的，有问题的；可能不诚实的，别有用心的</li><li>unquestionable：adj. 无疑的, 无可非议的, 确实的</li><li>unquestioned：adj. 显而易见的, 无可争议的, 毋庸置疑的, 公认的</li><li>questioner：n. （广播节目或公开辩论等的）提问人</li><li>questioning：adj. 询问的, 表示怀疑的 n. 提问, 询问, 盘问 v. “question”的现在分词</li><li>unquestioning：adj. 不加质询的, 不表示怀疑（等）的</li></ul></li><li><p>conquer：v. 征服, 克服, 战胜, 攻克</p><ul><li>conqueror：n. 征服者；占领者；胜利者</li><li>reconquer：v. 重新占领（国家或城市）, 再征服, 夺回</li><li>unconquerable：adj. 不可战胜的, 坚不可摧的, 难以改变的</li><li>unconquered：adj. 未被征服(或击败、攻取)的,未克服的</li></ul></li><li><p>conquest：n. 征服, 占领, 占领（或征服）的地区, （爱情或性方面）被俘虏的人</p></li><li><p>inquest：n. 勘验, 死因审理, 验尸, （对失败的事进行的）讨论</p></li></ul><h4 id="reg-rec-regi"><a href="#reg-rec-regi" class="headerlink" title="reg-/rec-/regi-/"></a>reg-/rec-/regi-/</h4><p>reg-：统治，管理</p><p>regi-：统治，管理</p><p>rec-：正，直</p><p>reg-：保持直线</p><ul><li>regular：</li><li>irregular：</li><li>regularly：</li><li>regularity：</li><li>regularize：</li><li>reign：</li><li>realm：</li><li>regulate：</li><li>regulation：</li><li>regal：</li><li>regent：</li><li>regency：</li><li>regalia：</li><li>regime：</li><li>region：</li><li>regiment：</li><li>regicide：</li><li>corrigible：</li><li>indirect：</li></ul><h4 id="semble"><a href="#semble" class="headerlink" title="-semble"></a>-semble</h4><p>-semble</p><ul><li>assemble：</li><li>resemble：</li></ul><h4 id="sens"><a href="#sens" class="headerlink" title="sens-"></a>sens-</h4><p>sens-：感觉，认知，意识</p><ul><li>sense：</li><li>sensitive：</li><li>nosense：</li></ul><h4 id="sol"><a href="#sol" class="headerlink" title="sol-"></a>sol-</h4><p>sol-：安慰，鼓励</p><ul><li>console：<ul><li>v.安慰，抚慰，慰藉</li><li>n.控制台，仪表盘</li></ul></li><li>consolation：n.安慰，使感到安慰的人或物</li><li>inconsolable：adj.悲痛欲绝的</li><li>disconsolate：adj.忧郁的，沮丧的</li><li>consolatory：adj.安慰的，慰藉的</li><li>solace：<ul><li>n.安慰，使感到安慰的人或物</li><li>v.安慰，缓和，使高兴</li></ul></li></ul><h4 id="sorb-sorpt"><a href="#sorb-sorpt" class="headerlink" title="sorb-/sorpt-"></a>sorb-/sorpt-</h4><p>**sorb-, sorpt-**【拉丁】表示“吸收”；“吞下”</p><ul><li>absorb：v.吸收，吸引…的注意，使全神贯注，经受住，承受住</li><li>absorbtion：n.吸收，并入，同化，全神贯注</li><li>absorbed：adj.全神贯注的，被吸收的</li><li>absorbent：<ul><li>adj.易吸收的</li><li>n.吸收剂，淋巴管</li></ul></li><li>absorbing：adj.吸引人的，非常有趣的</li><li>reabsorb：v.重吸收</li><li>absorbance：n. 【物】吸光度, 消光度, 光密度</li><li>absorbency：n. 吸收力</li></ul><h4 id="spect"><a href="#spect" class="headerlink" title="spect-"></a>spect-</h4><p>spect-：看，检查</p><ul><li>suspect：</li><li>aspect：</li><li>expect：</li><li>expectation：</li><li>prospect：</li><li>spectacle：</li><li>spectacular：</li><li>circumspect：</li></ul><p>spec-：看，检查</p><ul><li>respectful：</li><li>respect：</li><li>specimen：</li><li>respectable：</li><li>spectrum：</li><li>speculate：</li><li>retrospect：</li><li>retrospective：</li><li>specious：</li></ul><p>spic-：看，检查</p><ul><li>despise：</li><li>suspicion：</li><li>suspicious：</li><li>conspicuous：</li></ul><p>-spection：看，检查</p><ul><li>inspection：</li><li>introspection：</li></ul><p>-spective：看，检查</p><ul><li>perspective：</li></ul><p>spectat-：看，检查</p><ul><li>spectator：</li></ul><h4 id="spire"><a href="#spire" class="headerlink" title="-spire"></a>-spire</h4><p>-spire：</p><ul><li>inspire：</li></ul><h4 id="stat"><a href="#stat" class="headerlink" title="stat-"></a>stat-</h4><p>**stat-**：站立，固定，静止，停留</p><ul><li>static：<ul><li>adj.静止的，静态的，不变化的</li><li>n.静电，静电干扰</li></ul></li><li>stationary：<ul><li>adj.不动的，静止的，固定的</li><li>n.驻军，不动的人</li></ul></li><li>state：<ul><li>n.国家，州，状态</li><li>v.说明，陈述，声明，规定</li><li>adj.国家的，州的，正式的</li></ul></li><li>statement：n.声明，陈述</li><li>statue：<ul><li>n.雕像，塑像</li><li>v.用雕像装饰</li></ul></li><li>status：n.地位，身份，情形，状况</li><li>stature：n.身高，声望</li><li>apostate：<ul><li>n.叛教者，变节者</li><li>adj.叛教的，变节的，放弃信仰的</li></ul></li></ul><p><strong>-stasi</strong>：站立，固定，静止，停留</p><ul><li>apostasy：n.叛教，变节，放弃信仰</li></ul><p>**sta-**：站立，固定，静止，停留</p><ul><li>stagnant：adj.不流动而污浊的，停滞的，无变化的</li><li>circumstance：n.（复数）情况，环境，（单数）命运</li><li>contrast：<ul><li>n.对比，对照，差异</li><li>v.对比，对照</li></ul></li><li>distant：adj.遥远的，久远的，冷淡的，疏远的</li><li>distance：<ul><li>n.距离，远处，间距，远方</li><li>v.拉开距离，与…疏远</li></ul></li><li>distantly：adv.遥远地，疏远地，陌生地</li><li>establish：v.建立，创立，使立足，使稳固，得到认可，查明，证实</li><li>instant：<ul><li>adj.立即的，立刻的，速食的</li><li>n.瞬间，片刻</li><li>conj.同as soon as</li></ul></li><li>instantly：adv.立即，马上</li><li>instantaneous：adj.瞬间的，立即的</li><li>instance：（非本词根）<ul><li>n.实例，例子，举例</li><li>v.举…为例</li></ul></li><li>obstacle：n.障碍，绊脚石</li></ul><p><strong>-sist</strong>：站立，固定，静止，停留</p><ul><li>assist：<ul><li>v.协助，帮助，援助，促进</li><li>n.助攻</li></ul></li><li>assistant：<ul><li>n.助手，助理，副手</li><li>adj.助理的，辅助的</li></ul></li><li>assistance：n.帮助，援助，支持</li><li>assistive：adj.辅助的</li><li>unassisted：adj.无人帮助的，不靠外援的</li><li>consist：v.组成，构成，存在于</li><li>desist：v.停止，结束</li><li>insist：v.坚持，坚决认为</li><li>insistence：n.坚持，坚决要求，固执</li><li>insistent：adj.一再要求的，持续不断的，反复的</li><li>irresistible：adj.不可遏制的，无法抵制的，极诱人的</li><li>persist：v.坚持，执意，执着，维持，持续</li><li>persistent：adj.执着的，不屈不挠的，坚持不懈的</li><li>persistence：n.坚持，执意，维持，持续存在</li><li>persistency：n.坚持，固执，持久</li><li>persistently：adv.固执地，坚持地</li></ul><p><strong>-stitute</strong>：站立，固定，静止，停留</p><ul><li>institute：<ul><li>n.机构，研究所，学院</li><li>v.建立，实行，开始</li></ul></li><li>institution：n.协会，机构，制度，惯例，大金融公司/机构，建立，制定</li><li>substitute：<ul><li>v.用…代替，代以</li><li>n.代替者</li></ul></li><li>constitute：v.组成，构成，成立，设定，被视作，算作</li><li>constitution：n.宪法，构成，组成，体质，体格</li><li>constituent：<ul><li>n.组成部分，成分，选民，委托人</li><li>adj.组成的，构成的，任命的，选举的</li></ul></li><li>superstition：n.迷信</li><li>superstitious：adj.迷信的</li><li>destitute：<ul><li>adj.没有的，贫困的，贫穷的</li><li>n.穷人</li></ul></li><li>destitution：n.贫穷，缺乏</li><li>prostitute：<ul><li>n.卖淫者，娼妓，妓女</li><li>v.滥用才能，糟蹋自己，卖淫</li><li>adj.卖淫的，堕落的</li></ul></li><li>prostitution：n.卖淫，为娼，才能的滥用</li><li>restitute：v.赔偿，归还</li><li>restitution：n.补偿，赔偿，归还</li></ul><p><strong>-static</strong>：站立，固定，静止，停留</p><ul><li><p>ecstatic：adj.狂喜的，热情极高的</p></li><li><p>hemostatic：</p><ul><li>adj.能够止血的</li><li>n.止血剂</li></ul></li><li></li></ul><h4 id="stinct"><a href="#stinct" class="headerlink" title="-stinct"></a>-stinct</h4><p>stingu-, -stingu, stinct-, -stinct【拉丁】表示“分开”；“熄灭”；“消除”；“刺激”；“刺破”</p><p>词根助记：instinct:in里面+stinct=内部兴起的东西=本能</p><h4 id="surg"><a href="#surg" class="headerlink" title="surg-"></a>surg-</h4><ul><li>surge：</li><li>insurgent：</li><li>resurgence：</li><li>resurgent：</li><li>resurge：</li><li>insurgence：</li><li>insurgency：</li><li>counterinsurgency：</li></ul><h4 id="tact"><a href="#tact" class="headerlink" title="tact-"></a>tact-</h4><p>tact-：</p><ul><li>contact：</li></ul><h4 id="tain"><a href="#tain" class="headerlink" title="-tain"></a>-tain</h4><p>-tain：抓住，握紧，拥有</p><p>ten-：抓住，握紧，拥有</p><p>-tenance：抓住，握紧，拥有</p><p>-tainment：抓住，握紧，拥有</p><p>tin-：抓住，握紧，拥有</p><ul><li><p>contain </p></li><li><p>content</p></li><li><p>attain：</p></li><li><p>container：</p></li><li><p>maintain：</p></li><li><p>obtain：</p></li><li><p>retain：</p></li><li><p>appertain：</p></li><li><p>sustain：</p><ul><li><p>sus-：在…之下</p></li><li><p>sustained：</p></li><li><p>sustenance：</p></li><li><p>sustainable：</p></li><li><p>self-sustaining：</p></li></ul></li><li><p>abstemious：</p></li><li><p>tenure：</p></li><li><p>tenant：</p></li><li><p>tenacious：</p></li><li><p>abstinence：</p></li><li><p>tenacity：</p></li><li><p>tenement：</p></li><li><p>maintenance：</p></li><li><p>appurtenance：</p></li><li><p>containment：</p></li><li><p>pertinent：</p></li></ul><h4 id="trans-tran-tra"><a href="#trans-tran-tra" class="headerlink" title="trans-/tran-/tra-"></a>trans-/tran-/tra-</h4><p>**trans-, tran-, tra-**【拉丁】表示“穿过，越过”；“在另一边”</p><ul><li>transit<ul><li>transition</li><li>transitional</li></ul></li><li>transform</li><li>traffic</li><li>transport</li><li>shipment </li><li>transmit</li><li>transmission</li><li>transcript</li><li>transcribe</li><li>transfer</li><li>transplant</li></ul><h4 id="tribu"><a href="#tribu" class="headerlink" title="tribu-"></a>tribu-</h4><p>tribu-：任命，分配，分发，分销</p><ul><li>distribute：v.分配，分发，配送，分散</li><li>distribution：n.分布，分配，分发，分销</li><li>tribute：n.致敬，颂词，悼念，贡品</li><li>tributary：<ul><li>n.支流</li><li>adj.纳贡的，附庸的，补助的，支流的</li></ul></li><li>attribute：<ul><li>v.把…归因于，认为…属于</li><li>n.属性，特性，品质，象征</li></ul></li><li>attribution：n.归因，属性，权限</li><li>contribute：v.捐助，投稿，贡献，促使</li><li>contribution：n.贡献，捐款，稿件</li><li>retribution：n.报应，惩罚，报复</li><li>retributive：adj.报应的，报复的，惩罚的</li></ul><h4 id="vacu"><a href="#vacu" class="headerlink" title="vacu-"></a>vacu-</h4><ul><li>vacant：</li><li>vacancy：</li><li>vacuous：</li><li>vacation：</li><li>vacuum：</li><li>evacuate：</li><li>evacuation：</li><li>vacate：</li><li>vacuity：</li></ul><h4 id="vad"><a href="#vad" class="headerlink" title="vad-"></a>vad-</h4><p>vad-, vas-【拉丁】表示“去，走”</p><p>词根助记：invade:in进入+vad走，去=走进去=入侵，侵略</p><h4 id="vari"><a href="#vari" class="headerlink" title="vari-"></a>vari-</h4><p>vari-：变化，不同，多样性</p><ul><li>vary：</li><li>variable：</li><li>variation：</li><li>variety：</li><li>varied：</li><li>unvarying：</li><li>invariably：</li><li>invariable：</li><li>variant：</li><li>variance：</li><li>prevaricate：</li><li>variability：</li><li>variegated：</li></ul><h4 id="vent"><a href="#vent" class="headerlink" title="vent-"></a>vent-</h4><p>ven-, vent-, veni-, ventu-【拉丁】表示“来，到来，来临”</p><p><strong>同根词</strong>adventure|advent|convenience|convention|venture|intervene|revenue|</p><h4 id="vert"><a href="#vert" class="headerlink" title="vert-"></a>vert-</h4><p>invert</p><p>revert</p><h4 id="vict"><a href="#vict" class="headerlink" title="vict-"></a>vict-</h4><p>vict-：</p><ul><li>convict：</li><li>conviction：</li></ul><h3 id="2-5-常见词缀对应词汇"><a href="#2-5-常见词缀对应词汇" class="headerlink" title="2.5 常见词缀对应词汇"></a>2.5 常见词缀对应词汇</h3><h4 id="ology"><a href="#ology" class="headerlink" title="-ology"></a>-ology</h4><p>-ology：学科，科学（名词词尾）</p><p>sociology biology geology</p><p>aesthetic</p><h4 id="tude"><a href="#tude" class="headerlink" title="-tude"></a>-tude</h4><p>-tude【拉丁】后缀；表示“……的状态，品质，条件”</p><p><strong>同根词</strong>altitude|attitude|amplitude|latitude|multitude|aptitude|beatitude|</p><ul><li>magnitude：</li></ul><h4 id="fy"><a href="#fy" class="headerlink" title="-fy"></a>-fy</h4><ul><li>notify：</li></ul><h4 id="con"><a href="#con" class="headerlink" title="con-"></a>con-</h4><ul><li>constant：</li><li>constantly：</li><li>inconstant：</li><li>constancy：</li></ul><h2 id="三-介词"><a href="#三-介词" class="headerlink" title="三. 介词"></a>三. 介词</h2><ul><li><p>following：</p><ul><li>adj. （时间上）接着的, 下述的, 下列的</li><li>n. 如下, 下列, 下述, 追随者</li><li>prep. 在（某事）以后, 由于</li><li>v. “follow”的现在分词</li></ul></li><li><p>since：</p><ul><li>prep. 自…以后, 从…以来, （表示气愤）何曾</li><li>adv. 此后, 后来, 自…以后, 从…以来</li><li>conj. 因为, 由于, 既然, 从…以后</li></ul></li><li></li></ul><h2 id="四-不规则动词"><a href="#四-不规则动词" class="headerlink" title="四. 不规则动词"></a>四. 不规则动词</h2><ul><li><p>take：took</p></li><li><p>mean：meant</p></li><li><p>ride：rode</p></li></ul><h2 id="五-短语"><a href="#五-短语" class="headerlink" title="五. 短语"></a>五. 短语</h2><ul><li>According to：<ul><li>根据，按照</li><li>取决于，以…为转移</li><li>据…所说，按…所载</li></ul></li><li>appear to be：看起来好像</li><li>squeaky clean：非常干净的, 品行完美的, 一尘不染的, 无可挑剔的</li></ul><p>make up</p><p>phrase. 补充,补足;弥补;补偿,赔偿 (损失等);支付 (费用)</p><p>phrase. 捏造,(尤指为了欺骗) 临时编造,虚构;创造</p><p>phrase. 编辑,编制;草拟;结算</p><p>phrase. 配制,合成 (药剂等)</p><p>phrase. 包扎,捆扎;包装</p><p>phrase. (由部分) 组成,构成 (全体)</p><p>phrase. 排 (版);将 (铅字、插图等) 拼版</p><p>phrase. 裁制;缝制;把 (布料、裁片等) 做成;(布料等) 足够缝制成衣</p><p>phrase. (为…) 化妆;(给…) 化装</p><p>phrase. 解决 (争端等);和解,言归于好</p><p>phrase. 下定 (决心),拿定 (主意)</p><p>phrase. 准备,安排;整理 (床铺、房间等)</p><p>phrase. 加添燃料使 (火) 不熄;生(火)</p><p>phrase. 补修 (不及格或未修的课程);补 (考)</p><p>phrase. 重印;换掉</p><p>phrase. 洗 (牌)</p><p>phrase. 积聚;升起</p><p>phrase. 铺 (路面等)</p><p>口语：</p><ul><li>cut it out：别说了，住嘴（对无礼的行为）</li></ul><h2 id="六-待整理"><a href="#六-待整理" class="headerlink" title="六. 待整理"></a>六. 待整理</h2><p>prompt</p><p>adj. 迅速的，立刻的；敏捷的</p><p>v. 激起，促进，推动；提示</p><p>n. 〔计算机屏幕上的〕提示符；〔给演员的〕提词，提白</p><p>issue</p><p>n. 重要议题, 问题; (书刊等)期, 号; 发行物; 颁布; 分配, 分发</p><p>v. 发表; 颁布, 发出; 发给, 分发; 正式发行</p><p>encounter</p><p>v. 偶然碰到; 相遇; 遇到, 遭到, 受到; 与…发生冲突; 与…交战</p><p>n. 偶遇; 遭遇; 冲突; 交战</p><p>commission</p><p>n. 委员会；佣金，回扣；手续费；正式委托；犯错，犯罪行为</p><p>v. 正式委托；任命…为军官</p><p>breach</p><p>n. 突破口, 破坏, 缺口, （对法规等的）违背</p><p>v. 违反, 违背, 在…上打开缺口</p><p>raise</p><p>v. 举起; 养育, 喂养, 种植; 提出; 募集; 提升, 增大; 引起, 唤起</p><p>n. 加薪; 赌注加码; (持杠铃时的) 提, 举</p><p>protest</p><p>v. 反对，抗议</p><p>n. 抗议，反对</p><p>erupt</p><p>v. （火山）爆发,；（岩浆、烟等）喷出； 突然发生；爆发；突然发出（叫喊）</p><p>culminate</p><p>v. 最终达到, （在某一点）结束</p><p>demonstration</p><p>n. 示范, 演示, 证明; 表示，表露；示威游行; 示威集会</p><p>sanction</p><p>n. 制裁；处罚；正式许可；批准</p><p>v. 许可, 准许, 准予, 惩罚</p><p>eventual</p><p>eventually adv. 终于，最后</p><p>pursue</p><p>v. 追赶; 追捕; 追求, 寻求; 达到(目标); 从事, 忙于; 继续调查, 探究, 讨论; 实行, 采取(行动路线); (人或路)沿着(小道、路线)前进, 延伸</p><p>narrative</p><p>n. 叙述, 讲故事, 叙事技巧</p><p>adj. 叙述的, 故事体的, 善于叙述的</p><p>aggress</p><p>v. 攻击；挑衅；侵略，侵犯</p><p>manoeuvre</p><p>n. 演习；谨慎或熟练的动作；巧计，策略</p><p>v. 有技巧地引导；用计得到；调动；演习；诱使</p><p>sacrifice</p><p>v. 牺牲；舍弃；献出；献祭</p><p>n. 牺牲，供俸，祭品</p><p>sake</p><p>n. 目的; 理由; 缘故; 利益, 好处; 清酒(一种日本米酒)</p><p>sentence</p><p>n. 句子; 判决, 判刑, 宣判; 命题</p><p>v. 判决, 判刑, 宣判</p><p>court</p><p>n. 法庭; 法院; 全体法官(审判员); 审判庭; 球场; 朝廷; 宫廷; 院子; 殷勤; 追求, 求婚</p><p>v. 追求, 求婚; 寻求, 吸引; 向…献殷勤; 招致</p><p>stress</p><p>n. 压力; 紧迫, 紧张; 造成紧张的因素; 强调; 重要性; 重音; 重读; [物]应力</p><p>v. 着重, 强调; 重读; 使受应力; 加压力于; (使)紧张; 焦虑</p><p>course</p><p>n. 过程, 进展; 航向, 行动方向; 行为做法; 道路, 路线; 课程, 科目; 一道菜; 追踪狩猎</p><p>v. 沿特定路线行进; 迅速越过; 迅速流动; 追踪狩猎</p><p>rebel</p><p>n. 叛徒，起义者</p><p>v. 造反，反抗</p><p>tragedy</p><p>n. 悲剧, (文学)悲剧, 不幸, 灾难</p>]]></content>
    
    
    <summary type="html">整理单词短语，内容包括：易混淆的单词，词根词缀等。</summary>
    
    
    
    <category term="编程之外" scheme="http://linyishui.top/categories/%E7%BC%96%E7%A8%8B%E4%B9%8B%E5%A4%96/"/>
    
    <category term="英语" scheme="http://linyishui.top/categories/%E7%BC%96%E7%A8%8B%E4%B9%8B%E5%A4%96/%E8%8B%B1%E8%AF%AD/"/>
    
    
    <category term="updating" scheme="http://linyishui.top/tags/updating/"/>
    
    <category term="english" scheme="http://linyishui.top/tags/english/"/>
    
  </entry>
  
  <entry>
    <title>英语语法（一）基础</title>
    <link href="http://linyishui.top/2022042301.html"/>
    <id>http://linyishui.top/2022042301.html</id>
    <published>2022-04-23T08:16:22.000Z</published>
    <updated>2022-06-19T13:50:54.404Z</updated>
    
    <content type="html"><![CDATA[<h1 id="英语语法"><a href="#英语语法" class="headerlink" title="英语语法"></a>英语语法</h1><h2 id="一-绪论"><a href="#一-绪论" class="headerlink" title="一. 绪论"></a>一. 绪论</h2><h3 id="1-1-英语简介"><a href="#1-1-英语简介" class="headerlink" title="1.1 英语简介"></a>1.1 英语简介</h3><ul><li>英语是盎格鲁—萨克逊人的民族语。</li><li>属于印欧语系的日耳曼西部语支。</li><li>三个特征：<ol><li>曲折变化形式较少：除名词、代词、动词、形容词和副词有变化，数词、介词、连词、冠词和感叹词都是不变的。</li><li>词汇的开放性：，一半为日耳曼语族词汇，一半为罗曼语族词汇，以及其他舶来词。</li><li>句法的灵活性：只有三种句子结构，简单句、并列句和复合句。</li></ol></li></ul><h3 id="1-2-词类"><a href="#1-2-词类" class="headerlink" title="1.2 词类"></a>1.2 词类</h3><p>很多词汇都可以属于不同词类。</p><ul><li><p>实词（notional word）：有实义。</p><ol><li>名词：noun，缩写为 <code>n.</code> ，如book，water。</li><li>代词：pronoun，缩写为 <code>pron.</code> ，如I，you。</li><li>形容词：adjective，缩写为 <code>a.</code> 或 <code>adj.</code> ，如clear，happy。</li><li>数词：numeral，缩写为 <code>num.</code> ，如four，sixty。</li><li>动词：verb，缩写为 <code>v.</code> ，如come，take。</li><li>副词：adverb，缩写为 <code>adv.</code> ，如here，today。<ul><li>表示行为或状态特征，修饰动词、形容词、副词或全句。</li></ul></li></ol></li><li><p>虚词（form word）：无实义。</p><ol start="7"><li>冠词：article，缩写为 <code>art.</code> ，如a，the。放在名词前帮助说明。</li><li>介词：preposition，缩写为 <code>prep.</code> ，如of，to。<ul><li>前置词，表示名词、代词等与其他词的关系。</li></ul></li><li>连词：conjunction，缩写为 <code>conj.</code> ，如and，or。</li><li>感叹词：interjection，缩写为 <code>int.</code> ，如oh，alas。</li></ol></li><li><p>短语构成的词类：</p><ol><li>短语动词（phrasal verb）：如get up，call on，take care of。</li><li>短语介词（phrasal preposition）：如because of，instead of，in front of。</li><li>短语连词（phrasal conjunction）：如as if，so that，as long as。</li><li>从属关联词（subordinate correlative）：即引导从句的连词、疑问代词、疑问副词、关系代词、关系副词、缩合连接代词和缩合连接副词。</li></ol></li></ul><h3 id="1-3-句子成分"><a href="#1-3-句子成分" class="headerlink" title="1.3 句子成分"></a>1.3 句子成分</h3><p>句子组成：Professor Ward teaches English to university students.</p><ul><li>主语部分（subject group）：Professor Ward。 </li><li>谓语部分（predicate group）：teaches English to university students。</li></ul><p>句子成分：</p><ol><li><p>主语（subject）：全句述说的对象，一般为相当于名词的词位于句首。</p></li><li><p>谓语/谓语动词（predicate or predicate verb）：说明主语的动作或状态，常用动词担任，置于主语之后（区别于谓语部分）。</p></li><li><p>宾语：表示及物动词（及物表示可以直接跟宾语）的动作对象和介词所联系的对象，常有相当于名词的词担任，置于及物动词或介词之后。</p></li><li><p>补语（complement）和表语（predicative）：</p><ul><li>补语用来补充主语和宾语意义，着重说明主语或宾语的特征，常由名词或形容词担任。</li><li>表语是位于连系动词之后的主语补语。</li></ul></li><li><p>定语（attribute）：限定或修饰名词或相当于名词的词，由形容词或相当于形容词的短语或从句担任。形容词常置于名词之前，相当于形容词的则置于名词之后。</p><p>John had a great desire to travel.</p></li><li><p>状语（adverbial）：修饰动词、形容词、副词以及全句的，常由副词或相当于副词的短语或从句担任。修饰动词时，位于之前，也可以位于之后；修饰形容词或副词时，置于之间。</p><p>I don`t think the plan will succeed.</p></li></ol><p>虚词在句子中一般不担任成分，位置比较固定：</p><ul><li><p>冠词位于名词前：</p><p>Karl bought a video recorder.</p></li><li><p>介词一般位于名词或代词之前：</p><p>My car broke down on the highway.</p></li><li><p>连词置于词与词、短语与短语、分句与分句、主句与主句之间，或置于从句之首：</p><p>You had to have a job or go hungry.</p></li><li><p>感叹词往往用于句首：</p><p>Oh, please don`t ask me any more.</p></li></ul><p>连系动词：不能独立做谓语，必须与表语一起构成系表结构，也就是所谓的<strong>合成谓语，用来说明主语的状态、特征、性质、身份等</strong>。</p><ul><li>最常见的连系动词为be/系动词，即<strong>完全连系动词</strong>。</li><li>另外还有look/turn/feel/become/sound/remain等<strong>半连系动词</strong>（由实义动词变来的）。一般半系动词强调主语所处的状态或主语的属性特点；做实义动词时强调动作。</li></ul><p>例如：</p><ul><li>The girl is smelling the flower.(实义动词)</li><li>The flower smells good .</li></ul><p>动词分类：</p><ul><li><p>实义动词：</p><ul><li>及物动词 +<ul><li>宾语</li><li>双宾语</li><li>复合宾语</li></ul></li><li>不及物动词</li></ul></li><li><p>系动词：be，seem，turn，become等 + 表语</p><ul><li><p>状态系动词：be，Our future will be beautiful.</p></li><li><p>感官系动词：如五感动词（fell，smell，sound，taste，look）与like搭配使用表示”X起来像“</p><p>The meat smells terrible, but tastes good.</p></li><li><p>持续系动词：用来表示主语继续或保持一种状况或态度，有keep，remain，stay，stand，continue，lie，hold，rest。</p><p>He always keeps silent at meeting.</p></li><li><p>表象系动词：表示看起来像这一概念，有seem，appear</p><p>It seems that everything will be OK.</p></li><li><p>变化系动词：表示主语变成什么样，状态变化，主要有become，grow，turn，get，go，come，run，make，fall。</p><p>The machine went wrong.</p></li></ul></li><li><p>助动词：</p><ul><li>be +<ul><li>doing</li><li>done</li></ul></li><li>have +<ul><li>done</li><li>been doing</li></ul></li><li>do，does，did</li><li>will，shall，would，should</li></ul></li></ul><h3 id="1-4-短语"><a href="#1-4-短语" class="headerlink" title="1.4 短语"></a>1.4 短语</h3><p>分类：</p><ol><li><p>名词短语（noun phrase）：作用相当于名词</p><p>My cousin is a university student.</p></li><li><p>动词短语（verb phrase）：动词 + 介词/介词/名词</p><p>I can`t believe John has failed.</p><p>Keep an eye on the baby while I am out.</p><p>You have to be patient with him.</p></li><li><p>形容词短语（adjectival phrase）：</p><p>The clouds soon cleared away and it became quite warm.</p></li><li><p>副词短语（adverbial phrase）：</p><p>John plays the piano very nice.</p></li><li><p>介词短语（prepositional phrase）：常用作状语</p><p>The car is waiting at the gate.</p></li><li><p>不定式短语（infinitive phrase）：</p><p>To eat three times a day is healthy.</p></li><li><p>动名词短语（gerundial phrase）：</p><p>Watching TV is a pleasure.</p></li><li><p>分词短语（participial phrase）：</p><p>The woman washing the dishes is my aunt.</p></li><li><p>固定词组（set phrase）：词序和意义都固定的习语</p><p>Dr. smith is to leave at once.</p></li></ol><h3 id="1-5-从句"><a href="#1-5-从句" class="headerlink" title="1.5 从句"></a>1.5 从句</h3><p>分类：</p><ul><li><p>主语从句（subject clause）：</p><p>That we shall be late is certain.</p><p>How this happened is not clear to anyone.</p></li><li><p>表语从句（predicative clause）：</p><p>The trouble is that I have lost his address.</p></li><li><p>宾语从句（object clause）：</p><p>She asked me which I liked best.</p></li><li><p>定语从句（attributive clause）：</p><p>The man who I saw is called Smith.</p></li><li><p>状语从句（adverbial clause）：</p><p>The house stood where three roads met.</p><p>If she asks me, I`ll tell her.</p></li><li><p>同位语从句（appositive clause）：</p><p>The fact that the money has gone does not mean is was stolen.</p></li></ul><h3 id="1-6-句子"><a href="#1-6-句子" class="headerlink" title="1.6 句子"></a>1.6 句子</h3><p>句子（sentence）是具有主语和谓语部分的一组词，包括五种基本结构：</p><ol><li><p>主语+谓语：</p><p>Day downs.</p></li><li><p>主语+谓语+宾语：</p><p>Rose understands French.</p></li><li><p>主语+谓语+间接宾语+直接宾语：</p><p>He told us the whole story.</p></li><li><p>主语+谓语+主语补语 或 主语+连系动词+表语：</p><p>He died a poor man.</p><p>Tom`s father is a professor.</p></li><li><p>主语+谓语+宾语+宾语补语：</p><p>He found George intelligent.</p></li></ol><p>句子结构分类：</p><ul><li><p>简单句：含有主语谓语的句子。</p><p>Fire and water do not agree.</p></li><li><p>并列句：由等立连词把两个或以上的简单句合成的句子。</p><p>I came home early, but she remained to the end of the concert.</p></li><li><p>复合句：由关联词把主句和一个或以上从句合成的句子。</p><p>He said he would come in the evening.</p></li></ul><p>句子目的分类：</p><ul><li><p>陈述句：陈述事实</p><p>The sun rises in the east.</p></li><li><p>疑问句：提出问题</p><p>Who is standing at the window?</p></li><li><p>祈使句：表示请求</p><p>Open the window, please.</p></li><li><p>感叹句：表示喜怒哀乐等情绪</p><p>How spotless the snow is!</p></li></ul><h2 id="二-基础语法"><a href="#二-基础语法" class="headerlink" title="二. 基础语法"></a>二. 基础语法</h2><h3 id="2-1-GPA语法评分标准"><a href="#2-1-GPA语法评分标准" class="headerlink" title="2.1 GPA语法评分标准"></a>2.1 GPA语法评分标准</h3><p>Criterion of the writing test：</p><ul><li>task response：（考察写作能力）<ol><li>有没有回应题干中的所有内容</li><li>有没有清晰的个人观点</li><li>有没有在核心段落中扩展小分论点</li></ol></li><li>coherence and cohesion：衔接与连贯（考察写作能力）<ol><li>有没有清晰的论证过程</li><li>使用一些逻辑连接词</li><li>核心段落要有中心句</li></ol></li><li>lexical resource：词汇量（考察英语水平）</li><li>grammatical range and accuracy：语法宽度和准确性（考察英语水平）</li></ul><p>语法拿分范围：5~7</p><ul><li>7 分：<ul><li>Use a variety of complex structures：使用各种复杂结构 （从句，虚拟语气，强调句型，独立主格，倒装，非谓语，介词使用等）</li><li>Produces frequent error-free sentences：频繁写出不犯错的句子</li><li>Has good control of grammar and punctuation but make a few errors：对语法和标点符号控制得很好，但可以有一点点错误（3到5个）。</li></ul></li><li>6 分：<ul><li>uses a mix of simple and complex sentence forms：使用混合简单和复杂的句子形式。</li><li>makes some errors in grammar and punctuation but they rarely reduce communication：在语法和标点上有一些错误，但这些错误很少会影响理解。</li></ul></li><li>5 分：<ul><li>uses only a limited range of structures：只使用有限的结构范围</li><li>attempts complex sentences but this tend to be less accurate than simple sentences：尝试复杂的句子，但往往不如简单的句子准确。</li><li>may make frequent grammatical errors and punctuation may be faculty; errors can cause some<br>difficulty for the reader：可能会经常出现语法错误，标点符号可能是教员；错误会给读者带来一些困难。</li></ul></li></ul><h3 id="2-2-复杂句结构"><a href="#2-2-复杂句结构" class="headerlink" title="2.2 复杂句结构"></a>2.2 复杂句结构</h3><p>A variety of complex structures：</p><ul><li><p>并列句（compound sentence）：并列复合句，两个或以上的主谓结构-姐妹关系；连词，中间往往有逗号。</p><p>It is clear that the proportion of girls saw a significant increase, while that of boys decreased sharply over the decade from 2001 to 2010.</p><p>As is shown in the diagram, the first step is to pick peaches from trees, and then they will be transported to the factory by a truck.</p><ul><li>表示并列：and，as well as，not only but also，neither nor，both and</li><li>表示选择：or，either or</li><li>表示转折：but，while/whereas，yet</li><li>表示因果：so，for，and therefore，and thus</li><li>表示顺序：and then</li></ul></li><li><p>复杂句（complex sentence）：从属复合句，主干+修饰</p><ul><li><p>定语从句：修饰名词–adj</p><ul><li><p>政府应该投资在可以给大多数纳税人带来利润的领域。</p><p>The government should invest in the fields <strong>that can bring real benefits to taxpayers</strong>.</p></li><li><p>全职工作的母亲们不能很好地照顾她们的孩子。</p><p>The mothers <strong>who work full-time</strong> cannot take good care of their children.</p></li><li><p>很多学生选择那个他们可以喝免费咖啡的图书馆。</p><p>Many students choose the library <strong>where they can have free coffee</strong>.</p></li></ul></li><li><p>状语从句：修饰动词或限定句子–adv</p><ul><li><p>政府应该给老年人提供足够多的养老金，因为他们自己无法在大城市谋生。</p><p>The government should provide enough pensions for the elderly in the metropolis because they cannot make a living in the metropolis by themselves. </p></li><li><p>当毕业生找工作时，他们通常优先重视工资。</p><p>When graduates hunt for jobs, they usually give top priority to salaries. </p></li><li><p>学生们会选择出国旅游一旦他们通过考试。</p><p>Students will travel abroad once they pass the exam.</p></li></ul></li><li><p>主语从句：从句在句子中做主语</p><ul><li><p>政府应该做的就是给老年人提供足够多的养老金。</p><p>What the government should do is to provide enough pensions for the elderly</p></li><li><p>是否男人和女人应该均摊家务已经吸引了我们的关注。</p><p>Whether men and women should share housework equally has attracted our great<br>attention.</p></li></ul></li><li><p>宾语从句：从句在句子中做宾语</p><ul><li><p>我认为，不努力没有人可以通过考试。</p><p>I believe that the government should provide enough pensions for the elderly</p></li><li><p>我认为政府应该投资大量的钱在旅游业。</p><p>I hold that the government needs to invest a great amount of money in tourism industry.</p></li></ul></li><li><p>表语从句：从句在句子中做表语</p><ul><li><p>我的观点是动物实验在道德上是错误的。</p><p>My idea is that the government should provide enough pensions for the elderly</p></li></ul></li><li><p>同位语从句：解释说明一个抽象名词。</p><ul><li><p>青少年通常有错误的观点就是成功可以被取得而不用努力工作。</p><p>Teenagers usually have the wrong idea that success can be achieved without working hard</p></li><li><p>你应该有信心就是祂可以将你从一切的罪恶中拯救出来。</p><p>You should have the faith that he can save you from all of your sins.</p></li></ul></li></ul></li><li><p>非谓语：不是谓语，目的是<strong>规避双谓语</strong>。</p><p>谓语：do/did/does/can do/will do/have done/be doing/be done</p><p>非谓语：to do；doing；done</p><ul><li><p><strong>To do/doing，做主语</strong>。</p><ul><li>Studying English makes me happy. </li><li>Playing basketball allows teenagers to cultivate team spirit. </li><li>Watching too much TV may cause students to be seriously addicted to the screen. </li></ul></li><li><p><strong>doing/done，做后置定语</strong></p><ul><li><p>The students who choose to study abroad need to learn English.</p><p>The students=who，重复两次。定语从句无主语，不能有谓语，变为非谓语。</p><p><strong>主动用doing，被动用done</strong>。</p><p>The students choosing to learn English need to learn English.</p></li><li><p>The countries <strong>planning to develop tourism industry</strong> need to collect more taxes. </p></li></ul></li><li><p><strong>doing/done，做状语</strong></p><ul><li><p><strong>Compared with apples</strong>, pears are usually sweeter.</p></li><li><p><strong>Comparing those apples</strong>, I choose three. </p></li><li><p><strong>Feeling a little cold</strong>, I plan to go shopping for clothes this weekend.</p></li><li><p><strong>Influenced by advertisements</strong>, I buy many things that I do not need .</p></li><li><p>结果状语：</p><p>Nowadays, many readers can have access to e-libraries, <strong>making it possible for them to borrow books without commuting</strong>. </p><p>Many adults go to major cities for better jobs, <strong>leaving their young children unprotected at home</strong>.</p></li></ul></li></ul></li><li><p>介词+n/doing/being done</p><ul><li><p>介词做<strong>表语</strong>。</p><p>I am at home. </p><p>I am with my parents.</p><p>I am in dire need of financial support.</p><p>I am in favor of animal testing.</p><p>I am against smoking in public places.</p></li><li><p>介词做后置定语。</p><p>The people in extreme poverty usually suffer from various diseases.</p><p>Couples with children are usually busy.</p><p>The kite of good quality can fly high.</p></li><li><p>介词做状语。</p><p><strong>Due to serious air pollution</strong>, many people in the metropolis suffer from lung diseases.</p><p><strong>Thanks to advanced medical care</strong>, people can live longer than their grandparents.</p><p><strong>Despite some troubles of garbage-sorting</strong>, it is still a positive development in general.</p></li></ul></li><li><p>主语多样性：</p><ul><li>能发出动作的对象或者主体：the government; people; they; I ; citizens; the young; the elderly</li><li>Doing做主语</li><li>抽象名词作主语</li><li>It is +adj for sb to do sth</li><li>There be+n （就近原则）</li><li>主语从句</li></ul></li></ul><h3 id="2-3-标点符号"><a href="#2-3-标点符号" class="headerlink" title="2.3 标点符号"></a>2.3 标点符号</h3><p>逗号不能连接两个完整句子：</p><ul><li>John values his work, he usually gets to his office early in the morning. （×）</li><li>John values his work, and he usually gets to his office early in the morning.（√）</li></ul><p>加逗号的地方：</p><ul><li><p>并列句：and; but; so; and therefore; or; and then; while; whereas; yet（并列连词）</p><p>John values his work, and he usually gets to his office early in the morning. </p></li><li><p>引导状语从句的连词： when; where; because; so that ; if ; although （<strong>前加中不加</strong>）</p><p>Because you are honest, I like you very much.</p><p>I like you very much because you are honest.</p></li><li><p>非限制性定语从句：完整句子, which…….（which 指代前面一件事或者一个名词）</p><p>I have ordered an extremely pricey hotel, which costs me a great<br>amount of time.<br>I have ordered a hotel facing the sea, which allows me to see the<br>sunrise clearly everyday.</p></li><li><p>副词/介词/非谓语：放在句首，通常有逗号，Generally/In addition/Feeling awkward, I……….</p><p>Generally, girls do not like dogs.</p><p>At school, students usually have weekends.</p><p>Feeling a little cold, I choose not to attend the class.</p></li><li><p>插入语/同位语：插入语-给予补充信息，语法上独立； 同位语-解释说明一个名词<br>（前后有逗号）</p><p>John, I believe, is one of the most talented students in our class.</p><p>John’s mother, a teacher in local high school, is my role model.</p></li></ul><h3 id="2-4-四个基本句型"><a href="#2-4-四个基本句型" class="headerlink" title="2.4 四个基本句型"></a>2.4 四个基本句型</h3><ol><li><p><strong>主谓宾</strong></p><p>Teenagers should consume less fast food.</p><p>The proportion of girls fluctuates.</p><p>The proportion of girls fluctuates significantly.</p><p>The pork consumption sharply rises.</p><p>The sales of clothes soar.</p><p>The number of girls studying aboard plunges.</p><p>Environmental problems have seriously impeded.</p></li><li><p><strong>被动语态 be done</strong></p><p>The fish are caught from the sea.</p><p>Moon cakes are packed in boxes.</p><p>Beef is frozen in the fridge.</p><p>Children should be sent to the kindergarten.</p><p>Some effective measures should be adopted by the government to release<br>traffic pressure.</p><p>The economic development of the area is often hindered due to serious<br>environmental problems.</p></li><li><p><strong>It is + adj. for sb. to do sth. by doing sth.</strong></p><p>It is unhealthy for teenagers to consume too much fast food.</p><p>It is effective to lose weight by having a diet.</p><p>It is feasible for the government to release the traffic pressure by controlling the<br>number of private cars.</p><p>It is possible for students to get band 7 by working hard.</p></li><li><p><strong>There be +n. (就近原则)</strong></p><p>There should be less time spent on the screen for teenagers.</p><p>There should be less consumption of fast food.</p><p>There is an apple and two pears. / there are two pears and an apple.</p></li></ol><p>Adolescents should spend less time on the screen.</p><p>•Less time should be spent on the screen for adolescents.</p><p>•It is beneficial for adolescents to spend less time on the screen.</p><p>•There should be less time for teenagers to spend on the screen.</p><p>•There should be less time spent on the screen for teenagers.</p><p>•政府应该采取措施解决交通问题</p><p>•The government should take measures to solve traffic problems.</p><p>•Measures should be taken by the government to solve traffic problems.</p><p>•It is necessary for the government to take measures to solve traffic problems.</p><p>•There should be some measures for the government to take to solve traffic problems.</p><p>•There should be some measures taken by the government to solve </p><p>traffic problems. </p><h3 id="2-5-五个词组搭配"><a href="#2-5-五个词组搭配" class="headerlink" title="2.5 五个词组搭配"></a>2.5 五个词组搭配</h3><h4 id="（1）Be-n-adj-prep"><a href="#（1）Be-n-adj-prep" class="headerlink" title="（1）Be+n/adj/prep"></a>（1）Be+n/adj/prep</h4><p>•It is a fact that……（表示背景）</p><p>•确实很多家长选择把孩子送到私立学校来获取更好的教育。</p><p>•It is a fact that many parents choose to send their children to private schools for better education.</p><p>•It is a common phenomenon that…..（表示背景）</p><p>•很多年长的人被选举来承担政府的重要职责而不是年轻人。</p><p>•It is a common phenomenon that the elderly are elected to undertake important positions of the government rather than the young.</p><p>•现在越来越多的人喜欢买名牌，原因是什么？这是一个积极还是消极的影响？</p><p>•It is a common phenomenon that an increasing number of customers prefer to buy famous brands of products such as bags, clothes and cars.</p><p>•It is +adj +for sb/sth to do sth by doing sth</p><table><thead><tr><th><strong>justified</strong></th><th><strong>合理的</strong></th><th><strong>unjustified</strong></th><th><strong>不合理的</strong></th></tr></thead><tbody><tr><td><strong>vitally  important</strong></td><td><strong>重要的</strong></td><td><strong>pointless</strong></td><td><strong>不重要的</strong></td></tr><tr><td><strong>reasonable</strong></td><td><strong>合理的</strong></td><td><strong>unreasonable</strong></td><td><strong>不合理的</strong></td></tr><tr><td><strong>necessary</strong></td><td><strong>有必要的</strong></td><td><strong>unnecessary</strong></td><td><strong>不必要的</strong></td></tr><tr><td><strong>feasible</strong></td><td><strong>可行的</strong></td><td><strong>unfeasible</strong></td><td><strong>不可行的</strong></td></tr><tr><td><strong>effective</strong></td><td><strong>有效的</strong></td><td><strong>ineffective</strong></td><td><strong>无效的</strong></td></tr><tr><td><strong>fair</strong></td><td><strong>公平的</strong></td><td><strong>unfair</strong></td><td><strong>不公平的</strong></td></tr><tr><td><strong>appropriate</strong></td><td><strong>合适的</strong></td><td><strong>inappropriate</strong></td><td><strong>不合适的</strong></td></tr><tr><td><strong>realistic</strong></td><td><strong>现实的</strong></td><td><strong>unrealistic</strong></td><td><strong>不现实的</strong></td></tr><tr><td><strong>flexible</strong></td><td><strong>灵活的</strong></td><td><strong>inflexible</strong></td><td><strong>不灵活的</strong></td></tr><tr><td><strong>possible</strong></td><td><strong>可能的</strong></td><td><strong>impossible</strong></td><td><strong>不可能的</strong></td></tr></tbody></table><p>•I am in favor of…. 我支持….</p><p>•I am against….. 我反对…</p><p>•It is of great importance to do sth ……是很重要的</p><p>•I am with great respect to do sth </p><p>•The newspaper industry is in decline. 衰落</p><p>•The price of oil is on the rise.</p><p>•The poor countries are in dire need of financial support.</p><h4 id="（2）vt-（冠词）-adj-n"><a href="#（2）vt-（冠词）-adj-n" class="headerlink" title="（2）vt+（冠词）+adj+ n"></a>（2）vt+（冠词）+adj+ n</h4><p>•play an important role in </p><p>•develop some good characters</p><p>•put in a good performance</p><p>•have a devastating effect on</p><p>•see/witness a significant increase </p><p>•pose a huge threat to</p><p>•make enormous contributions to + n</p><p>•become qualified employees</p><h4 id="（3）Adv-Adj"><a href="#（3）Adv-Adj" class="headerlink" title="（3）Adv+Adj"></a>（3）Adv+Adj</h4><p>•seriously polluted</p><p>•highly addictive</p><p>•incredibly beautiful</p><p>•extremely dangerous</p><p>•particularly intelligent</p><p>•especially worried</p><p>•vitally important</p><p>•程度副词</p><p>academically outstanding</p><p>socially active</p><p>economically independent</p><p>financially successful</p><p>physically strong</p><p>mentally healthy</p><p>environmentally friendly</p><p>morally wrong</p><p>visually accessible</p><p>culturally diversified</p><p>方面副词</p><h4 id="（4）V-adv-adv-V"><a href="#（4）V-adv-adv-V" class="headerlink" title="（4）V+adv/adv+V"></a>（4）V+adv/adv+V</h4><p>•increase significantly</p><p>•decrease slowly</p><p>•seriously affect</p><p>•greatly promote</p><p>•gradually become popular</p><p>•strongly recommend</p><p>•financially aid the country </p><p>benefit teenagers both</p><p>  physically and mentally</p><p>heavily depend on</p><p>significantly promote</p><p>副词的位置</p><p>①放在实意动词之前； 情态动词、助动词、系动词之后。</p><p>②I am only 18.</p><p>③I have only missed the beginning.</p><p>④You should only date one person at a time.</p><p>⑤The use of machines has greatly improved our work efficiency. </p><h4 id="（5）prep-n-doing"><a href="#（5）prep-n-doing" class="headerlink" title="（5）prep+n/doing"></a>（5）prep+n/doing</h4><p>•随着时间的流逝</p><p>•With time going by,………介词后面不能加句子，就不能加谓语，只能加非谓语。</p><p>•As time goes by,…… 连词 + 句子</p><p>•With+n+doing/done</p><p>•With many parents choosing to send their children to private schools,…..</p><p>•With much time spent on homework,…..</p><table><thead><tr><th>介词+名词</th><th>连词+句子</th></tr></thead><tbody><tr><td>Due  to+n</td><td>because+句子</td></tr><tr><td>such  as +n</td><td>for  example+句子</td></tr><tr><td>despite+n</td><td>although  +句子</td></tr></tbody></table><p>•Although learning English is difficult, I still choose to learn it with a positive attitude.</p><p>•Despite difficulties of learning English,…..</p><p>•Despite some troubles brought by garbage classification,….</p><p>•Due to a great amount of waste water discharged by the factories,….</p><p>句子翻译：</p><p>•那些社交活跃的学生通常很漂亮，这说明长相在发展性格方面扮演了一个重要角色。（which indicates that）</p><p>•Those socially active students are often incredibly good-looking, which indicates that appearance plays a significantly important role in developing one’s characters.</p><p>•根据词性背诵固定搭配–根据搭配写句子–准确/地道/多样</p><h2 id="三-四种时态"><a href="#三-四种时态" class="headerlink" title="三. 四种时态"></a>三. 四种时态</h2><p>考点：</p><table><thead><tr><th align="center"><strong>雅思大作文</strong></th><th align="center"><strong>时态</strong></th></tr></thead><tbody><tr><td align="center">辩论类-全文呈现、论证自己观点<br/>To what extent do you agree or disagree?<br/>Is it a positive or negative development?<br/>Do advantages outweigh disadvantages?<br/>讨论类-全文讨论两个观点并呈现个人立场<br/>Discuss both views and give your own opinion.<br/>报告类–问两个问题<br/>What are the reasons? What are the solutions?<br/>What are the problems? What are the solutions?<br/>What are the effects? How to solve the problems?</td><td align="center">①一般现在时（最常见）<br/>②情态动词+动词原形（很常见）<br/>Can/may/will/could/might/would<br/>③现在完成时（表背景）<br/>④一般将来时（条件状语从句）</td></tr><tr><td align="center"><strong>流程图</strong></td><td align="center"><strong>时态</strong></td></tr><tr><td align="center">生命周期类</td><td align="center">一般现在时（主动语态较多）</td></tr><tr><td align="center">工艺流程类</td><td align="center">一般现在时（被动语态较多）</td></tr><tr><td align="center"><strong>数据图</strong></td><td align="center"><strong>时态</strong></td></tr><tr><td align="center">过去的时间</td><td align="center">一般过去时</td></tr><tr><td align="center">现在的时间</td><td align="center">一般现在时</td></tr><tr><td align="center">将来的时间</td><td align="center">预计是</td></tr><tr><td align="center"><strong>地图</strong></td><td align="center"><strong>时态</strong></td></tr><tr><td align="center">过去的地图+过去的地图</td><td align="center">一般过去时</td></tr><tr><td align="center">过去的地图+现在的地图</td><td align="center">一般过去时+现在完成时</td></tr><tr><td align="center">现在的地图+将来的地图</td><td align="center">一般将来时（预计是）</td></tr></tbody></table><h3 id="3-1-一般现在时态"><a href="#3-1-一般现在时态" class="headerlink" title="3.1 一般现在时态"></a>3.1 一般现在时态</h3><p>大作文中的主语：</p><ol><li><p>能够发出动作的人或者集体</p><p>citizens; people; the government; the society;the elderly; the young; </p><p>the staff; employees; students; the school </p><p>Many adolescents are addicted to video games, and they can be easily distracted from their study.</p></li><li><p>Doing做主语</p><p>•Getting addicted to video games may cause adolescents to be easily distracted from</p><p>•犯罪使罪犯过一个悲惨的生活</p><p>•Committing crimes causes criminals to lead a miserable life.</p><p>•玩儿太多的电子游戏使青少年很容易被分心</p><p>•Playing too many video games causes teenagers to be easily distracted.</p></li><li><p>抽象名词做主语(高分选手)</p><p>•Serious addiction to video games may….</p><p>•犯罪率的上升直接导致每个人都觉得在外工作和生活不安全。</p><p>•A rise in crime rate will directly lead to the  result that everyone feels insecure to work and live outside.</p><p>•极度的贫穷使当地人遭受着各种各样的常见疾病。</p><p>•The extreme poverty causes local people to suffer from a range of common diseases.</p></li><li><p>It is….</p></li><li><p>There be…..</p></li></ol><p>是I吗？是You吗？是复数吗？<br> 都不是—后面动词+s</p><p>•制作工艺–被动语态：be done(transitive)</p><p>•解冻： The fish are defrosted.（transitive）</p><p>•        The fish thaw.(intransitive)</p><p>•Pick the peaches from the tree. 祈使句不能用在流程图中</p><p>•The cocoons are selected, and then heated in hot water.</p><p>•Coffee and milk is mixed together, and then poured into a cup.</p><p>•The whole process of producing silk cloth can be divided into 5 steps.</p><p>制作桃子罐头</p><p>•Pick-transport-wash-peel-cut in half-soak-steam-package-deliver-sell</p><p>•流程图的写作难点在于凑字数</p><h3 id="3-2-现在完成时"><a href="#3-2-现在完成时" class="headerlink" title="3.2 现在完成时"></a>3.2 现在完成时</h3><p>•构成: have/has done</p><p>•我已经看过那个电影了—不跟你看了</p><p>•我已经吃过饭了—不要请我吃</p><p>•表示后面情况的原因或者背景</p><p>•手机的使用像吸烟一样反社会，所以应该像吸烟一样禁止手机的使用在一些地方。</p><p>•The overuse of phones has seriously affected our public life so that some people begin comparing it to smoking. （背景句-小）</p><h3 id="3-3-过去时态"><a href="#3-3-过去时态" class="headerlink" title="3.3 过去时态"></a>3.3 过去时态</h3><p>（数据图+地图）过去的时间</p><p>•构成：动词的过去式</p><p>•否定：did not +do</p><p>动态图句式</p><p>•①The number of…. increased significantly.</p><p>•②There was a dramatic increase in the number of….</p><p>•③The number of….saw a significant increase.</p><p>•④A dramatic increase was seen in the number of….</p><p>•我们班的女生的数量缓慢地下降在过去五年</p><p>•The number of girls in our class decreased slowly in the past five years. </p><p>•The number of girls in our class decreased to the bottom at 300. </p><p>•There was a slow decrease in the number of girls in our class.</p><p>•The past five years saw a slow decrease in the number of girls in our class. </p><p>•A slow decrease was seen in the number of girls in our class. </p><h3 id="3-4-将来时态"><a href="#3-4-将来时态" class="headerlink" title="3.4 将来时态"></a>3.4 将来时态</h3><p>（大作文+数据图+地图题）</p><p>•大作文：条件状语从句（主将从现）</p><p>•If the government provides enough pensions for the elderly, their living standard will be greatly improved.</p><p>数据图</p><p>•be expected /indicated/predicted to</p><p>•will probably</p><p>•In spite of some fluctuation, the proportion of older people will probably continue to increase in the next two decades in the three countries. A more dramatic rise is predicted between 2030 and 2040 in Japan, by which time it is expected that the proportion of elder people will be similar in the three countries. </p><p>地图</p><p>•be expected /indicated/predicted to</p><p>•will probably</p><p>•A house is expected to be built in the south of the town in the following 20 years.</p><h3 id="3-5-小作文复杂句型（18句）"><a href="#3-5-小作文复杂句型（18句）" class="headerlink" title="3.5 小作文复杂句型（18句）"></a>3.5 小作文复杂句型（18句）</h3><p>①…… before+句子/being done/doing（表示先后）</p><p>②……, after which +完整句子（表示先后）</p><p>③After…..,…….. （表示先后）</p><p>④It is clear/noticeable that….（表示主要特征）</p><p>⑤It is note-worthy that….（表示并列）</p><p>⑥The year XXXX marks the point at which XX exceed/overtake XX（表交点）</p><p>⑦XX stand at XX. 表示起点</p><p>⑧XX reach/arrive at XX/the peak/the bottom at XX.（表示端点值或极值）</p><p>⑨an increase was seen ……., with a jump of XX in XX years from XXXX to XXXX </p><p>（表示上升幅度）</p><p>⑩Despite some fluctuation, XX saw an increasing trend in general during this period.</p><p>⑪……，while/whereas……（表示对比）</p><p>⑫……is a little/much/far/30% /twice larger than …….（表示对比、倍数）</p><p>⑬……is twice/three times/four times as large as……（表示倍数）</p><p>⑭对象+占有+百分比+of+ 总数</p><p>占有:occupy; account for; represent; take up; make up; represent</p><p>Girls account for 20% of all students in my class.</p><p>⑮对象 have/has/had the largest percentage/proportion/amount/number among all the categories. （最高级）</p><p>⑯The whole process of producing XX can be divided into XX steps</p><p>⑰A is located/situated in/on/to the east of B</p><p>⑱A lie in/on/to the east of B</p><h2 id="四-其他常见句型"><a href="#四-其他常见句型" class="headerlink" title="四. 其他常见句型"></a>四. 其他常见句型</h2><h3 id="4-1-主谓宾-vt-冠词-adj-n"><a href="#4-1-主谓宾-vt-冠词-adj-n" class="headerlink" title="4.1 主谓宾-vt.+(冠词)+adj+n"></a>4.1 主谓宾-vt.+(冠词)+adj+n</h3><p>The government should adopt some measures.<br>The government should adopt some effective measures immediately.<br>Parents play an essential role.<br>The elderly put huge pressure on the government.<br>My parents allow a flexible schedule.<br>Employers often motivate the staff by lectures<br>Environmental problems often hinder economic development of the local area.</p><h3 id="4-2-主系表（Be-n）"><a href="#4-2-主系表（Be-n）" class="headerlink" title="4.2 主系表（Be+n）"></a>4.2 主系表（Be+n）</h3><p>My mother is a teacher.<br>It is a fact that young people cannot tell right from wrong.<br>It is a common phenomenon that the elderly are the leaders of the government.<br>It is a truth that nobody can meet our expectation all the time.</p><h3 id="4-3-主系表（be-adj）"><a href="#4-3-主系表（be-adj）" class="headerlink" title="4.3 主系表（be+adj）"></a>4.3 主系表（be+adj）</h3><p>Those girls are incredibly good-looking.<br>Many video games are highly addictive.<br>It is vitally important for teachers to give several examples.<br>It is possible for students to get Band 7 by working hard.<br>It is effective for girls to lose weight by having a diet.</p><h3 id="4-4-主系表（be-prep）"><a href="#4-4-主系表（be-prep）" class="headerlink" title="4.4 主系表（be+prep）"></a>4.4 主系表（be+prep）</h3><p>I am in favor of animal experiments.<br>I am against smoking in public places.<br>Students are at school.<br>It is of great significance/ importance to so sth.<br>The newspaper industry is in decline.<br>The price of oil is on the rise.<br>Poor countries are in dire need of financial help.</p><h2 id="五-定语"><a href="#五-定语" class="headerlink" title="五. 定语"></a>五. 定语</h2><h3 id="5-1-简介"><a href="#5-1-简介" class="headerlink" title="5.1 简介"></a>5.1 简介</h3><ul><li>定语，修饰名词，一般翻译为……的，</li><li>表示事物的性质或状态，</li><li>分为前置和后置，</li><li>常用来做定语的有：形容词、介词短语、定语从句、分词结构等。</li></ul><p>翻译并找出定语：</p><ul><li><p><strong>Generation</strong> gap can be found between parents and children.</p><p>父母和孩子间可以发现代沟。</p></li><li><p>A good personality exerts <strong>great</strong> impacts on one’s career.</p><p>好的性格会对一个人的生涯造成巨大的影响。</p></li><li><p>Couple <strong>with children</strong> were more likely to live in poverty. </p><p>有孩子的夫妇更有可能会生活在贫困中。</p></li><li><p><strong>John’s</strong> father is a teacher. </p><p>约翰的父亲是个教师。</p></li><li><p>Clearly, we are now living in an <strong>updating</strong> society/America is a <strong>developed</strong> country. </p><p>很明显，我们现在生活在一个不断变化的社会，美国是一个发达国家。</p></li><li><p>Studying abroad provides students with a good opportunity <strong>to experience a totally different culture</strong>.</p><p>出国留学为学生提供了一个体验完全不同文化的好机会。</p></li><li><p>Students <strong>living in Beijing</strong> can have access to the latest teaching method. </p><p>生活在北京的学生有机会接触最新的教学方法。</p></li><li><p>Students <strong>locked in the classroom</strong> are starving. </p><p>被锁在教室里的学生在挨饿。</p></li><li><p>That is a good book <strong>which is about social relationships</strong>.</p><p>这是一本关于社会关系的好书。</p></li></ul><h4 id="（1）adj-n"><a href="#（1）adj-n" class="headerlink" title="（1）adj+n"></a>（1）adj+n</h4><ul><li>a productive director</li><li>an effective way</li><li>所有格指名词 + ` ，如 dog`s</li><li>单数名词 + `s ，如the boy`s dog</li><li>复数名词 + ` ，my parents`friends</li></ul><h4 id="（2）分词结构"><a href="#（2）分词结构" class="headerlink" title="（2）分词结构"></a>（2）分词结构</h4><blockquote><p>分词：具有动词及形容词二者特征的词，尤指以-ing或-ed,-d,-t,-en或-n结尾的英语动词性形容词。</p></blockquote><p>分词形容词：</p><ul><li>主动关系：doing，主谓<ul><li>rising sun，roaring lion，working classes</li></ul></li><li>被动关系：done，谓宾<ul><li>used cars，cleaned dishes，broken bottles</li></ul></li></ul><h4 id="（3）n-prep"><a href="#（3）n-prep" class="headerlink" title="（3）n+prep"></a>（3）n+prep</h4><ul><li>people <strong>in extreme poverty</strong>…极端贫困的人</li><li>the reason <strong>for this problem</strong>…这个问题的原因</li><li>the cause <strong>of this issue</strong>…这个问题的原因</li><li>people <strong>in different age groups</strong>…不同年龄段的人</li><li>the suggestion of great value/importance…</li><li>people in favor of animal experiments…</li><li>people against women taking maternity leave…</li><li>couples with several children…</li></ul><h4 id="（4）定语从句"><a href="#（4）定语从句" class="headerlink" title="（4）定语从句"></a>（4）定语从句</h4><ul><li>定义：在复合中修饰名词或代词的从句是定语从句</li><li>先行词：被定语从句修饰的名词或代词</li><li>定语从句一般放在先行词的后面</li><li>引导词：<ul><li>关系代词：that; which; who</li><li>关系副词：when; where; why</li></ul></li></ul><p>that; which; who：</p><blockquote><ul><li><p>I like <strong>the girl</strong> who <strong>works in the factory</strong>.</p><p>the girl= who </p></li><li><p>I could not ignore <strong>the dog</strong> that <strong>had been barking all night</strong>.</p><p>the dog=that</p></li><li><p>I would like to borrow <strong>the book</strong> which <strong>you recommended yesterday</strong>.</p><p>the book =which </p></li></ul><p>that, which, who 引导定语从句指代前面的名词，后面+不完整句子，它们与后面的部分共同构成从句。</p></blockquote><p>when; where; why</p><blockquote><ul><li><p><strong>时间名词</strong> + when：</p><ul><li>I cannot forget <strong>the day</strong> when <strong>I met you the first time</strong>.</li><li>The life cycle of the silkworm <strong>begins</strong> when <strong>the moth lays an egg.</strong></li></ul></li><li><p><strong>地点名词</strong> + where：</p></li><li><p>The government should also make people willing to stay where <strong>they were born</strong>.</p></li><li><p>I like the place where <strong>you study English.</strong> </p></li><li><p>reason + why：</p></li><li><p><strong>The reason</strong> why <strong>he left the company</strong> <strong>was unknown</strong></p></li></ul></blockquote><p>where的特殊用法</p><blockquote><ul><li>where 可以修饰抽象的地点名词：situation; field; case; job; profession; conversation; industry; point</li><li>Today, we will discuss a number of <strong>cases</strong> where beginners of English fail to use the language properly.</li><li>She wants a <strong>job</strong> where her management skills can be put to good use.</li><li>I like the <strong>conversation</strong> where I can talk more.</li><li>I like the <strong>job</strong> where I can teach grammar.</li><li>The government should invest in the <strong>fields</strong> where most taxpayers can reap benefits.</li><li>There are <strong>cases</strong> where wives complain about their husbands not doing housework.</li></ul></blockquote><p>只用which，不用that的情况</p><blockquote><ul><li><p>有逗号，which 指前面一个事或者名词</p><p>I like the book which/that you recommended yesterday.</p><p>修饰–……的 70%</p><p>BJ citizens produce a great amount of waste everyday, which contaminates the earth and river to a large extent.</p><p>指代-这-递进（非限制）</p><p>I cried for hours, which made my mother worried. </p><p>指代一件事30%，这</p></li><li><p>介词提前</p><p>I like the Lamy pen with which I can write well.</p><p>You should check the desk on which the most expensive book is placed.</p><p>You should find the city in which your future husband can work.</p></li></ul><p>其他情况都可以用that</p></blockquote><p>用That而不用Which的情况</p><blockquote><ul><li><p>先行词为all, everything, nothing, something, little, few这种不定代词时</p><p>There is little that I can use.</p></li><li><p>先行词被all, each, few, much, every, no, some, any等不定代词修饰时</p><p>All the books that you need are here.</p></li><li><p>先行词被序数词或者形容词最高级修饰时</p><p>This is the first composition he has written in English.</p></li><li><p>先行词既有人，又有物的时候</p><p>He talked about the teachers and schools that he had visited </p></li><li><p>先行词被the only, the very, the last 修饰时</p><p>This is the very gun that I am looking for.</p></li><li><p>关系代词在从句中做表语的时候</p><p>He is not the young man that he was thirty years ago.</p></li></ul></blockquote><p>翻译句子：</p><ul><li>可以鼓励年轻人建立积极的世界观的运动员应该代言知名品牌。（endorse）</li><li>政府需要解决的主要问题是不断增大的贫富差距。（gap）</li><li>大多数年轻人想居住在有更多就业机会的城市</li><li>司机师傅违反交通规则的情况有时会发生当他们被顾客催促的时候。（rush）</li><li>牛肉的消耗量在1992年到到达最高点5吨，那时鸡肉的消耗量只有1吨。</li><li>很多人反对禁止吸烟的主要原因是这个政策会打击烟草业</li></ul><p>ØAthletes who can encourage young people to build positive world views should endorse famous brands.</p><p>ØThe main problem that the government needs to solve is the constantly increasing gap between the rich and the poor.</p><p>ØMost young people want to live in the cities which have more job opportunities.</p><p>ØThe consumption of beef reached the peak at 5 tons in 1992 when that of chicken was only 1 ton.</p><p>ØThe situation where drivers break traffic rules sometimes happens when they are rushed by passengers.</p><p>ØThe reason why many people are against banning smoking is that this policy will attack tobacco industry.</p><h3 id="6-3-功能句"><a href="#6-3-功能句" class="headerlink" title="6.3 功能句"></a>6.3 功能句</h3><h4 id="（一）定从功能句"><a href="#（一）定从功能句" class="headerlink" title="（一）定从功能句"></a>（一）定从功能句</h4><p><strong>Which</strong>引导非限制性定语从句，指代前面一件事， 后面的谓语动词用单数。</p><ul><li>The movie industry has boomed in recent years, which greatly promote<strong>s</strong> the domestic economic development.</li><li>People tend to check their phones when hanging with their friends, which <strong>is</strong> detrimental to enhancing their relationship.</li></ul><p>一句话（一个现象），which：表示递进关系，对前面现象的评论或者继续阐述</p><ul><li>enables/allows sb to do sth：使能够，使有机会</li><li>encourages sb to do sth：鼓励…</li><li>makes it possible/difficult for sb to do sth</li><li>makes it/sth/sb adj</li><li>means that +完整</li><li>contributes to/promotes…</li><li>is beneficial to +n/doing</li><li>leads to/results in +n</li><li>causes sb to do sth</li><li>prevents/deters sb from doing sth</li><li>discourages sb from doing sth</li><li>is detrimental to +n/doing</li><li>hinders +n /sb from doing sth 阻碍</li><li>has a devastating  effect on </li><li>poses a threat to 对……造成威胁 </li><li>poses pressure on 对……造成压力 </li></ul><p>Some people believe that children can learn effectively by watching TV and they should be encouraged to watch TV regularly both at home and school.</p><p>To what extent do you agree or disagree?</p><ul><li>与传统的教学方法相比，电视上的视频使学习变得简单得多，并且学生很愿意去按照这种方式学习如果他们被如此鼓励，这可能使课本与老师的课程更加得没有吸引力。</li><li>Compared with traditional teaching methods, the videos on TV make learning much easier and children are surely happy to learn through it if they are encouraged so, which may make books or lectures less attractive and appealing.</li></ul><p>Some people think government should invest more money in teaching science than other subjects in order for a country to develop and progress. </p><p>To what extent do you agree or disagree?</p><ul><li>在科技教学方面更多的投资会鼓励科技相关产业更多的劳动力，这可能会阻碍需要创造型人才领域的就业。</li><li>More investment in teaching science may encourage growing workforce in science-related industry, which may hinder the employment of the fields that require creative talents.  </li></ul><p>Some people argue that too much attention and too many resources are given to the protection of wild animals and birds. </p><p>To what extent do you agree or disagree?</p><ul><li>随着农业、居住和工业活动的扩张，野生动物的数量见证了一个大幅度的下降，这对生态平衡造成了巨大的威胁。</li><li>With the expansion of agriculture, settlement and industrial activities, the number of wild animals has seen a plunge, which poses a great threat to our ecological balance. </li></ul><p>In many countries women are allowed to take maternity leave from their jobs during their first month after the birth of their baby.</p><p>Do advantages outweigh disadvantages?</p><ul><li>如果女性可以休产假，那么公司在录取员工的时候肯定会把这个情况考虑在内，这会阻碍女性在职场中担任很重要的角色尽管他们的能力很高。</li><li>If women are entitled to rest for a certain period of time after giving birth, the company will certainly take it into account when recruiting, which may hinder them from undertaking important positions <strong>despite their high qualification</strong>. </li></ul><h4 id="（二）定从功能句"><a href="#（二）定从功能句" class="headerlink" title="（二）定从功能句"></a>（二）定从功能句</h4><ul><li>Those who , 那些……样的人</li><li>Those students who…</li><li>Those elders who….</li><li>Those who cannot focus on class lack self-control. </li><li>Those who do not know the psychology of consumers cannot sell. </li></ul><p>Some people think government should invest more money in teaching science than other subjects in order for a country to develop and progress. </p><p>To what extent do you agree or disagree?</p><ul><li>那些盲目选择科技作为他们专业的学生可能觉得很难去找到工作，有这么多的申请者竞争。</li><li>Those students who blindly choose science as their major may find it difficult to secure a job with so many applicants competing. </li></ul><p>Some people argue that too much attention and too many resources are given to the protection of wild animals and birds. </p><p>To what extent do you agree or disagree?</p><ul><li>那些反对野生动物保护的人可能认为钱应该花在公共服务上，因为这对居民的福祉更有益处。</li><li>Those who are against investment in wild animal protection may think that the money should be spent on public services, which they believe are more important parts for citizens’ well-being.</li></ul><p>In many countries women are allowed to take maternity leave from their jobs during their first month after the birth of their baby.</p><p>Do advantages outweigh disadvantages?</p><ul><li>那些休完产假再来工作的女性更倾向于有一个比较好的家庭关系，从而有一个更好的工作状态，这对公司的长远发展也是十分有利的。</li><li>Those mothers who have taken maternity leave are more likely to enjoy a good relationship with their families and therefore put in a better performance at work, which is also beneficial to the long-term development of the company. </li></ul><h4 id="（三）doing做后置定语"><a href="#（三）doing做后置定语" class="headerlink" title="（三）doing做后置定语"></a>（三）doing做后置定语</h4><p>分析过程：</p><ul><li>There is a door that leads to the garden. </li><li>that=a door</li><li>不喜欢重复</li><li>省略that</li><li>定语从句无主语—就不再是定语从句</li><li>leads to 这个谓语动词就要变成—非谓语</li><li>非谓语有三个选项：doing/done/to do  </li><li>因为 a door 和 lead 是主动关系，所以用doing</li><li>There is a door leading to the garden. </li></ul><p>案例：</p><ul><li>选择出国留学的学生们需要在前期做大量的准备工作以适应国外陌生的环境。</li><li>Those students choosing to study abroad need to make adequate preparations so as to adapt to a totally strange environment.</li><li>经常参观博物馆的青少年通常更能在课堂上一个好的表现比起那些花大量时间玩电子游戏的青少年。</li><li>Those teenagers visiting museums regularly usually put in a better performance at class than those spending much time on video games.</li><li>去美国旅游的印度游客占了总人数的20%。</li><li>The Indian tourists travelling to America account for 20% of whole.</li></ul><h4 id="（四）done-做后置定语"><a href="#（四）done-做后置定语" class="headerlink" title="（四）done 做后置定语"></a>（四）done 做后置定语</h4><p>分析过程：</p><ul><li>There are many children that are addicted to watching TV. </li><li>that = children</li><li>不喜欢重复</li><li>省略that</li><li>定语从句无主语—就不再是定语从句</li><li>are addicted to 这个谓语动词就要变成—非谓语</li><li>非谓语有三个选项：doing/done/to do  </li><li>因为 children 和 addict 是被动关系，所以用done</li><li>There are many children addicted to watching TV. </li></ul><p>案例：</p><ul><li>被明星代言的广告常常成功劝说一些消费者去买他们根本不需要的东西。</li><li>The advertisements performed by celebrities can often successfully persuade some customers to buy the products they barely need.</li><li>对于沉浸在电影里的观众来说最令人沮丧的事就是听到电话铃声响起。</li><li>It will be disturbing for the audience immersed in the movie to hear someone’s phone ringing. </li><li>位于村庄南部的停车场已经被扩建了。</li><li>The car park located in the south of the village has been expanded.</li></ul><h2 id="七-状语"><a href="#七-状语" class="headerlink" title="七. 状语"></a>七. 状语</h2>]]></content>
    
    
    <summary type="html">整理英语语法基础知识。</summary>
    
    
    
    <category term="编程之外" scheme="http://linyishui.top/categories/%E7%BC%96%E7%A8%8B%E4%B9%8B%E5%A4%96/"/>
    
    <category term="英语" scheme="http://linyishui.top/categories/%E7%BC%96%E7%A8%8B%E4%B9%8B%E5%A4%96/%E8%8B%B1%E8%AF%AD/"/>
    
    
    <category term="updating" scheme="http://linyishui.top/tags/updating/"/>
    
    <category term="english" scheme="http://linyishui.top/tags/english/"/>
    
  </entry>
  
  <entry>
    <title>英语词法</title>
    <link href="http://linyishui.top/2022042001.html"/>
    <id>http://linyishui.top/2022042001.html</id>
    <published>2022-04-20T08:16:22.000Z</published>
    <updated>2022-06-19T13:51:24.831Z</updated>
    
    <content type="html"><![CDATA[<h1 id="英语词法"><a href="#英语词法" class="headerlink" title="英语词法"></a>英语词法</h1><h2 id="一-词根"><a href="#一-词根" class="headerlink" title="一. 词根"></a>一. 词根</h2><h3 id="1-1-什么是词根"><a href="#1-1-什么是词根" class="headerlink" title="1.1 什么是词根"></a>1.1 什么是词根</h3><p>增长词汇的捷径：掌握词根，构成所有词汇的原生词。</p><ul><li>英语有很多原生词，但它们无法构成其它单次（如代词you，介词at，连词or等）。</li><li>很多单词主体并非可独立存在的基本单词，如visible，collect等（vis，lect都不是原生词，但有其含义，如vis=to see看，lect=to choose挑选）。</li><li>派生词由词根+派生词缀构成。同一词根加上不同的词缀可以表示不同的意义。</li><li>英语单词大多都可以分析为单词+词缀，单词也可以是复杂词汇：<ul><li>unfriendly可分析成“派生前缀un＋<br>friendly”，而friendly中还含有⼀个基本单词friend；</li><li>whitewasher可以分成“whitewash<br>＋派生后缀er”，可是whitewash却是由white和wash两个基本单词构成的。</li></ul></li><li>《简明牛津词典》定义词根（root）是<strong>语言中不可分析的最小成分，通过添加前缀、后缀或其它修饰成分得以构成单词的基本成分</strong>。<ul><li>把复杂词汇排除出词根定义。</li><li>把vis，lect等非独立单词成分加入词根范畴。</li><li>其它修饰成分也可以加在词根上构词，从而扩展到派生词外。</li><li>但未指出最小成分究竟是什么。</li></ul></li><li>词素构词：语言有句子、分句、词组、词和词素五个自上而下的语法层次。上一层由下一层构成。一切单词都是由一个或多个词素构成。</li><li>词素根据独立性分为：<ul><li>自由词素（Free Morpheme）：可单独作为词。<ul><li>单词词根：friend，white等</li></ul></li><li>粘附词素（Bound Morpheme）：必须与其他词素结合。<ul><li>非单词词根：vis，lect等</li><li>词缀</li></ul></li></ul></li><li>词根是带有主要词汇信息的词素，包括自由词素和粘附词素中的非单词词根。词根语义为主，词缀语义为次。</li></ul><h3 id="1-2-词根的由来"><a href="#1-2-词根的由来" class="headerlink" title="1.2 词根的由来"></a>1.2 词根的由来</h3><p>英语历史：</p><ul><li><p>Celtic，包含一些拉丁语。</p></li><li><p>Old English：Anglo-Saxon人使用，属于日耳曼语。</p></li><li><p>Middle English：引进了数以千计的Latin拉丁词汇和Old French词汇（拉丁语源）。</p></li><li><p>Modern English：拉丁词大规模引入，大量表示社会科学和自然科学的希腊词（Greek）引入，二者都称为古典语词（Classical Words）。</p></li><li><p>1755年，《英语词典》问世标志着英语词汇系统确立。</p></li><li><p>不断吸收世界各种语言的词汇，随着科学发展，通过古典语的词素创造大量表示新概念的词汇，即新古典词（New-classical Words）。</p></li></ul><p>各种语源占比：</p><ul><li>日耳曼（本族）：33%</li><li>拉丁与希腊（古典）：56%</li><li>凯尔特：2%</li><li>混合：3%</li><li>东方、非洲、美洲等：6%</li></ul><p>下面斜体为古典语源，正体则为日耳曼语等：</p><p>   We, the <em>people</em> of the <em>United States</em>, in <em>order</em> to <em>form</em> a more <em>perfect union</em>, <em>establish justice</em>, <em>insure domestic<br>tranquility</em>, <em>provide</em> for the <em>common defense</em>, <em>promote</em> the <em>general</em> welfare, and <em>secure</em> the blessings of <em>liberty</em> to our <em>posterity</em> and ourselves, do <em>ordain</em> and <em>establish</em> this <em>constitution</em> for the <em>United States</em> of <em>America</em>.</p><ul><li>古典词汇不但占多数，且词形复杂，词义生僻，大部分是初学者眼中的生词。</li><li>本族词汇通常词形简单，大部分是表示基本事物、基本概念与基本关系的高使用率的常用词。常为可独立使用的自由词根。</li></ul><p>上述段落整理出的本族词根：</p><table><thead><tr><th align="center">词根</th><th align="center">类型</th><th align="center">含义</th></tr></thead><tbody><tr><td align="center">we</td><td align="center">pron.</td><td align="center">我们</td></tr><tr><td align="center">our</td><td align="center">pron.</td><td align="center">我们的</td></tr><tr><td align="center">this</td><td align="center">pron.</td><td align="center">这</td></tr><tr><td align="center">a</td><td align="center">art.</td><td align="center">一个</td></tr><tr><td align="center">the</td><td align="center">art.</td><td align="center">这</td></tr><tr><td align="center">in</td><td align="center">pron.</td><td align="center">内</td></tr><tr><td align="center">to</td><td align="center">pron.</td><td align="center">向</td></tr><tr><td align="center">of</td><td align="center">pron.</td><td align="center">的</td></tr><tr><td align="center">for</td><td align="center">pron.</td><td align="center">为</td></tr><tr><td align="center">and</td><td align="center">conj.</td><td align="center">和</td></tr><tr><td align="center">more</td><td align="center">adv.</td><td align="center">更</td></tr><tr><td align="center">do</td><td align="center">v.</td><td align="center">做</td></tr><tr><td align="center">bless</td><td align="center">v.</td><td align="center">祝福</td></tr><tr><td align="center">well</td><td align="center">adv.</td><td align="center">好</td></tr><tr><td align="center">fare</td><td align="center">v.</td><td align="center">过活</td></tr><tr><td align="center">self</td><td align="center">n.</td><td align="center">自己</td></tr></tbody></table><p>上述段落整理出的古典词根：</p><table><thead><tr><th align="center">词汇</th><th align="center">含义</th><th align="center">词根</th><th align="center">含义</th></tr></thead><tbody><tr><td align="center"><strong>stat</strong>e</td><td align="center">国家，状态，说明</td><td align="center">st(at)</td><td align="center">站立，固定</td></tr><tr><td align="center">e<strong>sta</strong>blish</td><td align="center">建立；ish为动词后缀</td><td align="center">st(at)</td><td align="center">站立，固定</td></tr><tr><td align="center">con<strong>stitution</strong></td><td align="center">宪法，组成，体质；con为前缀：强调，共同</td><td align="center">stitution</td><td align="center">站立，固定（同源词根）</td></tr><tr><td align="center">union</td><td align="center">联盟，联合</td><td align="center">un</td><td align="center">一</td></tr><tr><td align="center">united</td><td align="center">统一的，和谐的</td><td align="center">un</td><td align="center">一</td></tr><tr><td align="center">order</td><td align="center">顺序，命令，订单</td><td align="center">ord</td><td align="center">顺序</td></tr><tr><td align="center">ordain</td><td align="center">授予，主宰</td><td align="center">ord</td><td align="center">顺序</td></tr><tr><td align="center">insure</td><td align="center">投保，确保</td><td align="center">cur</td><td align="center">关心</td></tr><tr><td align="center">secure</td><td align="center">安全的，有把握的；保护；se为前缀：独自</td><td align="center">cur</td><td align="center">关心</td></tr><tr><td align="center">form</td><td align="center">形式，表格；组建，产生</td><td align="center">form</td><td align="center">形状</td></tr><tr><td align="center">perfect</td><td align="center">完美的；使完善；per为前缀：借助，超越，完全</td><td align="center">fect</td><td align="center">导致，形成</td></tr><tr><td align="center">domestic</td><td align="center">国内的，家庭的；ic为形容词后缀</td><td align="center">dom</td><td align="center">家，房子</td></tr><tr><td align="center">provide</td><td align="center">提供，规定</td><td align="center">vid</td><td align="center">看</td></tr><tr><td align="center">common</td><td align="center">常见的，普遍的；公共用地</td><td align="center">comm/mun</td><td align="center">一般的，普遍的/服务</td></tr><tr><td align="center">defense</td><td align="center">防御，保护；de为前缀：否定，向下，完全</td><td align="center">fen</td><td align="center">击打，防御</td></tr><tr><td align="center">promote</td><td align="center">促进，提升；pro为前缀：前面，代表</td><td align="center">mot</td><td align="center">移动</td></tr><tr><td align="center">general</td><td align="center">全体的，普遍的，首席的；将军</td><td align="center">gene</td><td align="center">种类，阶级</td></tr><tr><td align="center">liberty</td><td align="center">自由</td><td align="center">liber</td><td align="center">自由</td></tr><tr><td align="center">people</td><td align="center">人；居住</td><td align="center">popul</td><td align="center">人民</td></tr><tr><td align="center">justice</td><td align="center">公正，合理，正义；法官，司法</td><td align="center">just</td><td align="center">公正的</td></tr><tr><td align="center">posterity</td><td align="center">后代；ity为后缀：状态，品质</td><td align="center">post</td><td align="center">后来</td></tr><tr><td align="center">tranquility</td><td align="center">宁静</td><td align="center">quil</td><td align="center">平静</td></tr></tbody></table><ul><li>都是不能独立使用的粘附词根。</li><li>单词同根的现象很多。一部8万词条的中型词典中，stat、fect和gen都能找到200个以上的同根词。</li></ul><h3 id="1-3-英语词根"><a href="#1-3-英语词根" class="headerlink" title="1.3 英语词根"></a>1.3 英语词根</h3><p>英语词根分为本族语词根和外来语词根。后者主要是古典语源，多为粘附词根，不能单独构词。如何判定united和union的词根是un？</p><p>粘附词根取自一个古典语基本词的词干（Stem）部分。拉丁语和希腊语通过词尾变化等来表示不同种类，但词干比较稳定。英语吸收时舍弃掉了词尾变化形式，按照自己的规则来构词。</p><ul><li>直接输入外来词汇，根据本族语的模式加以正字和正音，主要发生在词首和词尾部分，词干不变。<ul><li>比如am（爱）：amatory（恋爱的）、amicable（友好的）、amorous（色情的）、enamour（使迷恋的）。</li><li>insul（岛）：insular（岛屿的）、insulate（使孤立）、peninsula（半岛）。</li></ul></li><li>利用外来语成分，按照自己的规则构建单词。外来词干作为零件中的主机，搭配以其他零件。如insul加上表示素的后缀in，组成insulin（胰岛素）。</li></ul><h3 id="1-4-从词根看词缀（常见词缀）"><a href="#1-4-从词根看词缀（常见词缀）" class="headerlink" title="1.4 从词根看词缀（常见词缀）"></a>1.4 从词根看词缀（常见词缀）</h3><p>词缀分为：</p><ul><li><strong>派生词缀</strong>：加在单词上构成派生词，如un-，-er，-ly，-ing等。</li><li><strong>屈折词缀</strong>：可加在词尾上表示语法关系，如-ing，-ed，-s等。</li></ul><p>但上述词缀都要和单词或自由词根组合，粘附词根中的类似部分则未被定义：</p><ul><li>visible：-ible</li><li>unite：-ite</li><li>union：-ion</li><li>establish：-ish</li><li>collect：col-</li><li>perfect：per-</li><li>insure：in-</li><li>provide：pro-</li><li>defense：de-</li></ul><p>un-，-ly，-er，-ing，-ed，-s等都是本族语词缀，粘附词汇中的都属于外来语词缀。相比本族词缀与基本单词、自由词根结合，外来词缀只能和粘附词根结合，可以称为<strong>原生词缀</strong>（Primitive Affix）。</p><p><strong>原生词缀也有很多被英语同化，变成与单词结合的派生词缀，并且被赋予了新的含义</strong>。</p><ul><li>如ex-，在exceed（超出）的含义是out（出），同化后变为former（前），如expresident（前总统）。</li><li>如pro-，原为forward（向前），派生前缀则为in favor of（亲…），progress（前进） VS proGermany（亲德国的）。</li><li>如re-，原为back（回），派生前缀则为again（再），regress（退回）VS reborn（再生）。</li></ul><p>词根为主，可独立存在；词缀为辅，只为协助词根。</p><p>原生词缀分类：</p><ol><li>介词性/副词性原生词缀：前身一般是介词，也可以作副词，主要依附于动词性词根，指示或限定动作的时间、方向、方式等。</li><li>修饰/限定性原生词缀：前身多是表示否定、数量、状态等含义的副词、数词或形容词。</li><li>名词性原生词缀：都是名词后缀，前身是一些表示性质、状态、特征的词根。</li><li>动词性原生词缀：前身是动词性词根，依附于名词或形容词词根上使其动词化。</li></ol><h4 id="（1）介词性-副词性原生词缀"><a href="#（1）介词性-副词性原生词缀" class="headerlink" title="（1）介词性/副词性原生词缀"></a>（1）介词性/副词性原生词缀</h4><table><thead><tr><th align="left">词缀</th><th>同源</th><th>含义</th><th>举例</th></tr></thead><tbody><tr><td align="left">a-</td><td>ab-，abs-</td><td>从，离（from）</td><td>ab- + solv（to loose）+ -e = absolve。解除=to loose from</td></tr><tr><td align="left">ad-</td><td>ac-，af-，ag-，al-，an-，ap-，ar-，as-，at-</td><td>向（towards）</td><td>af- + fect（to make）= affect。影响=to make something towards，or act upon</td></tr><tr><td align="left">ante-</td><td></td><td>在…之前（before）</td><td>ante- + ced（ to go）+ -e = antecede。原先=to go before</td></tr><tr><td align="left">anti-</td><td>ant-</td><td>相对，相反（against）</td><td>anti- + path（to feel）+ -y （名词性后缀）= antipathy。反感=feeling against</td></tr><tr><td align="left">circum-</td><td></td><td>围绕（around）</td><td>circum- + locut（to speak） + -ion（名词性后缀）= circumlocution。委婉话=roundabout speaking</td></tr><tr><td align="left">com-</td><td>co-，col-，con-，cor-</td><td>与，共（together with）</td><td>con- + nect（to join）= connect。连接=to join with</td></tr><tr><td align="left">de-</td><td></td><td>离开，从，由（off，from）</td><td>de- + duc（to lead）+ -e = deduce。推论=to lead or draw a conclusion from</td></tr><tr><td align="left">dis-</td><td>di-，dif-</td><td>分离（apart）</td><td>dif- + fer（to bring）= differ。分歧，相异= to bring apart or disagree</td></tr><tr><td align="left">ex-</td><td>e-，ef-</td><td>出，外（out）</td><td>e- + lect（to choose）= elect。选出=to choose out</td></tr><tr><td align="left">in-</td><td>en-，em-，il-，im-，ir-</td><td>内，入（in，into）</td><td>in- + clud（ to shut）+ -e = inclue。包含，包括=to shut or contain</td></tr><tr><td align="left">inter-</td><td>intel-</td><td>在…之间（between，among）</td><td>inter- + ven（to come）+ -e = intervene。介入，干涉=to come between</td></tr><tr><td align="left">ob-</td><td>oc-，of-，op-</td><td>阻拦，对抗（in the way of，against）</td><td>of- + fend（to hit）= offend。得罪，冒犯=to hit against or displease</td></tr><tr><td align="left">pre-</td><td></td><td>在…之前，事先（before，beforehand）</td><td>pre- + dict（to say） = predict。预言=to say or tell beforehand</td></tr><tr><td align="left">pro-</td><td></td><td>向前（for，forward）</td><td>pro- + ceed（to go） = proceed。进行=to go forward</td></tr><tr><td align="left">re-</td><td></td><td>返，再（back，again）</td><td>re- + vis（to see）+ -e = revise。修正=to see again in order to correct errors</td></tr><tr><td align="left">se-</td><td></td><td>偏，离（aside）</td><td>se- + duc（to lead）+ -e = seduce。引诱，勾引=to lead aside</td></tr><tr><td align="left">sub-</td><td>suc-，suf-，sug-，sup-，sur-，sus-</td><td>在…之下（under）</td><td>sub- + merg（to sink）+ -e = submerge。淹没，沉没=to sink under</td></tr><tr><td align="left">super-</td><td></td><td>在…之上（over，beyond）</td><td>super- + vis（to see）+ -e = supervise。监督，管理=to see over or oversee</td></tr><tr><td align="left">syn-</td><td>syl-，sym-，sys-</td><td>与，共（together with）</td><td>sym- + phon（so sound） + -y（名词后缀）= symphony。交响乐=sounding music together</td></tr><tr><td align="left">trans-</td><td></td><td>越过，穿过（across，through）</td><td>trans- + port（to carry）= transport。运输=to carry across</td></tr></tbody></table><h4 id="（2）修饰-限定性原生词缀"><a href="#（2）修饰-限定性原生词缀" class="headerlink" title="（2）修饰/限定性原生词缀"></a>（2）修饰/限定性原生词缀</h4><table><thead><tr><th align="left">词缀</th><th>同源</th><th>含义</th><th>举例</th></tr></thead><tbody><tr><td align="left">a-</td><td>an-</td><td>不，无（not，without）</td><td>an- + arch（rule）+ -y（名词后缀）= anarchy。无政府状态=society without rule</td></tr><tr><td align="left">bi-</td><td>bin-</td><td>二（two）</td><td>bi- + ocul（eye）+ -ar（形容词后缀）= binocular。双目的=of two eyes</td></tr><tr><td align="left">tri-</td><td></td><td>三（three）</td><td>tri- + angul（angle）+ -ar（形容词后缀）= triangular。三角的=of three angle</td></tr><tr><td align="left">in-</td><td>ig-，il-，im-，ir-</td><td>不（not）</td><td>if- + nor（to know）+ -e = ignore。不知，忽略=not to know</td></tr><tr><td align="left">iso-</td><td></td><td>相等的（equal）</td><td>iso- + gon（angle）+ -ic（形容词后缀）= isogonic。等角的=of equals angles</td></tr><tr><td align="left">male-</td><td>mal-</td><td>恶的，坏的（bad）</td><td>male- + dict（to speak）+ -ion（名词后缀）= malediction。诅咒，诽谤=ill speaking</td></tr><tr><td align="left">bene-</td><td></td><td>好的（good）</td><td>bene- + fact（to do）+ -ion（名词后缀）= benefaction。善行=good doing or good deed</td></tr><tr><td align="left">neo-</td><td></td><td>新的（new）</td><td>neo- + log（to speak）+ -ism（名词后缀）= neologism。新词=new speaking or new word</td></tr><tr><td align="left">-ant</td><td>-ent</td><td>表示性质状态的后缀（being）</td><td>bell（war）+ -i- + ger（to carry）+ -ent = belligerent。交战中的=being carried into war</td></tr><tr><td align="left">-able</td><td>-ible，-ile</td><td>能…的（able or able to be）</td><td>aud（to hear）+ -ible = audible。听得见的=able to be heard</td></tr><tr><td align="left">-ac</td><td>-al，-ar，-ic，-ical，-id</td><td>…的，像…的（of，like）</td><td>cardi（heart） + -ac = cardiac。心脏的=of the heart</td></tr><tr><td align="left">-ive</td><td></td><td>有…能力的，能…的（able to do）</td><td>co- + hes（to stick）+ -ive = cohesive。能粘合的=able to stick together</td></tr></tbody></table><h4 id="（3）名词性原生词缀"><a href="#（3）名词性原生词缀" class="headerlink" title="（3）名词性原生词缀"></a>（3）名词性原生词缀</h4><p>主要有：-acy、-ance、-ence、-ion、-ment、-tude、-ity、-y、-ure</p><ul><li>fall（to err）+ -acy = fallacy。谬误=the state of erring。</li><li>cap（to hold）+ -ac- + -ity = capacity。容量，能力=the ability of holding。</li><li>sent（to feel）+ -i- + -ment = sentiment。感情=the condition of feeling。</li><li>vis（to see）+ -ion = vision。视力=the ability of seeing。</li><li>cert（settled）+ -i- + tude = certitude。确信=the state of feeling settled or certain。</li><li>fract（to break）+ -ure = fracture。破碎=the result of being broken。</li></ul><h4 id="（4）动词性原生词缀"><a href="#（4）动词性原生词缀" class="headerlink" title="（4）动词性原生词缀"></a>（4）动词性原生词缀</h4><p>主要有三个：-ate、-fy、-ish，意思都是to make、to have或to cause to be。</p><ul><li>anim（life）+ -ate = animate。使活跃=to make or put life into。</li><li>un（one）+ -i- + -fy = unify。使合一，统一=to make into one body。</li><li>ad- + mon（to remind）+ -ish = admonish。告诫=to cause to be reminded  of a fault。</li></ul><h3 id="1-5-英语构词方式"><a href="#1-5-英语构词方式" class="headerlink" title="1.5 英语构词方式"></a>1.5 英语构词方式</h3><p>英语的传统构词方式：</p><ul><li>转化：单词词类的转变，不涉及形态的变化。</li><li>合成：两个或以上单词合并构成新词。</li><li>派生：通过添加词缀从一个<strong>单词</strong>产生新的单词。</li></ul><p>粘附词根和原生词缀可以基于词素概念使用派生这一构词方式，只不过不是从一个独立单词，而是词素。</p><ul><li><p>零级派生的无词缀构词（Non-affixation）：也叫零派生构词（Zero Derivation）</p></li><li><p>词根加缀构词（Affixation）：生成的词都称为派生词（Derivative）、复杂词或主从词（Complex Word）。</p><p>根据词根的性质分为：</p><ol><li>粘附词根加缀构词为一级派生，方式为：粘附词根 + 原生词缀 -&gt; 原始派生词或原生词（Primary Derivative）<ul><li>原生词缀 + 粘附词根 -&gt; 前缀原生词<ul><li>ex-（出）+ pend（支付）-&gt; expend v.付出</li><li>im-（入）+ port（云）-&gt; import v. 输入</li><li>pro-（向前）+ gress（步）-&gt; progress n. 进步</li></ul></li><li>粘附词根 + 原生后缀 -&gt; 后缀原生词<ul><li>equ（相等）+ -ate（使…）-&gt; equate v. 使相等</li><li>liter（文字）+ -al（…的）-&gt; literal a. 文字的</li><li>vis（看）+ -ible（可…的）-&gt; visible a. 可见的</li></ul></li><li>原生词缀 + 粘附词根 + 原生后缀 -&gt; 前后缀原生词<ul><li>circum-（环绕）+ locut（说）+ -ion（表方式）-&gt; circumlocution n. 迂回说法</li><li>tele- （远）+ vis（看）+ -ion（表状态）-&gt; television n. 电视</li><li>im- （不）+ pecc（犯罪）+ -able（可…的）-&gt; impeccable a. 无瑕疵的</li></ul></li><li>原生词缀 + 原生词缀 + 粘附词根 （+ 原生后缀）-&gt; 双前缀原生词<ul><li>co-（共）+ in-（在…上）+ cid（降）+ -e = coincide v. 符合</li><li>par-（旁）+ en-（进）+ thesis（放置）= parenthesis n. 圆括号</li><li>pre-（事先）+ di-（出）+ lect（选）+ -ion（表行为）= predilection n. 偏爱</li></ul></li></ul></li><li>自由词根加缀构词为二级派生，方式为：自由词根 + 派生词缀 -&gt; 二级派生词（Secondary Derivative）<ul><li>派生前缀 + 自由词根 -&gt; 前缀派生词<ul><li>un-（不）+ able（a. 可能的）-&gt; unable a. 不可能的</li><li>super-（超）+ man（n. 人）-&gt; superman n. 超人</li><li>en-（使）+ rich（a. 富裕的）-&gt; enrich v. 使富裕</li></ul></li><li>自由词根 + 派生后缀 -&gt; 后缀派生词<ul><li>hope（n. 希望）+ -less（无…的）-&gt; hopeless a. 无望的</li><li>work（v. 工作）+ -er（…者）-&gt; worker n. 工人</li><li>real（a. 实际的）+ -ize（使…）-&gt; realize v. 使实现</li></ul></li></ul></li></ol></li></ul><table><thead><tr><th align="center">分类</th><th align="center">数目</th><th align="center">零原生词缀</th><th align="center">零派生词缀</th><th align="center">原生词缀</th><th align="center">派生词缀</th></tr></thead><tbody><tr><td align="center">粘附</td><td align="center">单个</td><td align="center">简单词</td><td align="center"></td><td align="center">原生词</td><td align="center"></td></tr><tr><td align="center">词根</td><td align="center">双个</td><td align="center">原始复合词</td><td align="center"></td><td align="center">原生词</td><td align="center"></td></tr><tr><td align="center">自由</td><td align="center">单个</td><td align="center"></td><td align="center">转化词【转化法】</td><td align="center"></td><td align="center">（二次）派生词【派生法】</td></tr><tr><td align="center">词根</td><td align="center">双个</td><td align="center"></td><td align="center">合成词【合成法】</td><td align="center"></td><td align="center"></td></tr></tbody></table><h3 id="1-6-派生词分析"><a href="#1-6-派生词分析" class="headerlink" title="1.6 派生词分析"></a>1.6 派生词分析</h3><p>英语绝大部分单词都通过派生法构词。如何分析派生词？</p><ul><li>每个单词由三要素组成（语音、语义和语法）</li><li>三要素的载体是词形。<strong>分析从词形开始</strong>。</li><li>派生词的词形取决于词根与词缀的形态。</li></ul><p>如何分析：</p><ul><li>音节数：英语词根可以看作只有单音节和双音节两种，大部分为单音节。词根都是基本单词，所以遇到多音节的单词就可以考虑分析。</li><li>词根结构：<ul><li>单音节：<ul><li>基本模式是“辅音字母 + 元音字母 + 辅音字母”，如man、vis、log等。</li><li>包括字母组合和r音节的情况，如work、child、fect、phon、therm等。</li><li>少量“元音字母 + 辅音字母”的情况，如act、ann、erg、un等。</li><li>个别“辅音字母 + 元音字母”，如bi、ge、sci等。</li></ul></li><li>双音节：往往在单音节词根模式后加上元音（包括r音节），如anim、imit、ocul、labor、liter、mater等。</li></ul></li><li>派生词的词形分析，只要识别出词根和词缀，就可以分析出大部分单词。有些派生词汇根据读音或习惯的原因，在结合部分发生形态变化（此处不作展开）。</li></ul><blockquote><p>音节：</p><p>一靠后，二分手，多个中间偏左右。</p><p>组合字母算一个，常见组合要遵守。</p><p>词尾看e加音节，发音不发分两种。</p><p>双字相连不连手，听音验证最后头。</p><ul><li>一靠后：两个元音字母间有一个辅音字母时，划分给后面的音节当头。如a-go，be-gin等。</li><li>二分手：两个元音字母间有两个辅音字母时，一边一个。如in-side，com-mon等。</li><li>多个中间偏左右：两个元音字母间有三个以上辅音字母时，最中间的辅音字母两边都有可能。如in-<strong>s</strong>tead，suc-ces<strong>s</strong>-ful。</li><li>组合字母算一个：字母表第6列中的固定组合字母，组合后发一个音，被当做一个字母看待。如re-try，as-tro-no-my，tech-no-lo-gy。</li><li>常见组合要遵守：<ul><li>有些不是固定组合那样发一个音的字母也常常组合在一起，各发各的音。如pr、pl、fr、cl、sp、st、sk、scr、gr等。</li><li>有些独立发音的词头词尾：re-、de-、com-、con-等。</li><li>有些需要发音合并的词头词尾，开头是元音字母要结合辅音：-able、-al、-ate等，如rea-dable、per-so-nal。</li></ul></li><li>词尾看e加音节，发音不发分两种：<ul><li>单词尾加er、est、ing等元音开头的词尾时，通常增加一个音节，并把前面的辅音抢过来当做音节头。如smal-ler，lon-ger等。</li><li>单词尾加s、es、d、ed时，要看e是否需要发音间隔增加音节。<ol><li>s、x、z、ch、sh连es时（或t、d连ed），因为e两边字母发音相近，需要发[i:]来间隔，所以增加音节。</li><li>其他情况e不发音，也不加音节。</li></ol></li></ul></li><li>双字相连不连手：两个单词组合的情况下，一般都分开发音，就算相邻字母刚好构成固定组合，如rest-room。</li><li>听音验证最后头：单词可能会有多种音节划分方案，这种情况下需要尊重历史习惯。</li></ul></blockquote><h2 id="后缀判断词性"><a href="#后缀判断词性" class="headerlink" title="后缀判断词性"></a>后缀判断词性</h2><p>ori：从…出来</p><ul><li>orient</li><li>orientation</li><li>origin</li><li>original</li><li>originate</li></ul><hr>]]></content>
    
    
    <summary type="html">内容来自于《英语词缀与英语派生词》《英语词根与单词的说文解字》。</summary>
    
    
    
    <category term="编程之外" scheme="http://linyishui.top/categories/%E7%BC%96%E7%A8%8B%E4%B9%8B%E5%A4%96/"/>
    
    <category term="英语" scheme="http://linyishui.top/categories/%E7%BC%96%E7%A8%8B%E4%B9%8B%E5%A4%96/%E8%8B%B1%E8%AF%AD/"/>
    
    
    <category term="updating" scheme="http://linyishui.top/tags/updating/"/>
    
    <category term="english" scheme="http://linyishui.top/tags/english/"/>
    
  </entry>
  
  <entry>
    <title>食物归纳</title>
    <link href="http://linyishui.top/2022012901.html"/>
    <id>http://linyishui.top/2022012901.html</id>
    <published>2022-01-29T08:16:22.000Z</published>
    <updated>2022-03-15T01:42:39.015Z</updated>
    
    <content type="html"><![CDATA[<h1 id="食物归纳"><a href="#食物归纳" class="headerlink" title="食物归纳"></a>食物归纳</h1><p>注意：</p><ul><li>饮食清淡。</li><li>少食多餐，细嚼慢咽。</li><li>饭后宜卧床休息1-2小时。保证肝脏得到充足的血液供应，有利于肝细胞修复和再生，帮助恢复肝功能。</li><li>尽量采用蒸、煮、炖、氽、熬的烹调方法，少采用煎、炸、炒的烹调方法，坚持少盐饮食。</li><li>多饮水。</li><li>少熬夜。</li><li>减少焦虑。</li><li>适量的运动，不宜剧烈运动。</li></ul><h2 id="一-谷物"><a href="#一-谷物" class="headerlink" title="一. 谷物"></a>一. 谷物</h2><table><thead><tr><th align="center">名称</th><th align="center">食用</th><th>备注</th></tr></thead><tbody><tr><td align="center">豆类</td><td align="center">是</td><td>补充蛋白质和维生素，有较好的抗氧化功能且易消化吸收</td></tr><tr><td align="center">燕麦片</td><td align="center">是</td><td>高纤维</td></tr><tr><td align="center">全麦面包</td><td align="center">是</td><td>高纤维</td></tr><tr><td align="center">红米</td><td align="center">是</td><td>高纤维</td></tr><tr><td align="center">芝麻</td><td align="center">是</td><td>高纤维</td></tr><tr><td align="center">花生</td><td align="center">是</td><td>高纤维</td></tr><tr><td align="center">杏仁</td><td align="center">是</td><td>高纤维</td></tr><tr><td align="center">腰果</td><td align="center">是</td><td>高纤维</td></tr><tr><td align="center">核桃</td><td align="center">是</td><td></td></tr><tr><td align="center">绿豆</td><td align="center">是</td><td></td></tr></tbody></table><h2 id="二-荤菜"><a href="#二-荤菜" class="headerlink" title="二. 荤菜"></a>二. 荤菜</h2><table><thead><tr><th align="center">名称</th><th align="center">食用</th><th>备注</th></tr></thead><tbody><tr><td align="center">鸡蛋</td><td align="center">是</td><td>胆固醇不能说明有影响，优质蛋白质、维生素、卵磷脂。</td></tr><tr><td align="center">瘦肉</td><td align="center">是</td><td></td></tr><tr><td align="center">肥肉</td><td align="center">少量</td><td>不宜多食</td></tr><tr><td align="center">鱼</td><td align="center">是</td><td>补充蛋白质和维生素，有较好的抗氧化功能且易消化吸收</td></tr><tr><td align="center">虾</td><td align="center">少量</td><td>胆固醇高，优质蛋白，尽量清淡</td></tr><tr><td align="center">螃蟹</td><td align="center">少量</td><td>胆固醇高</td></tr><tr><td align="center">动物肝脏</td><td align="center">否</td><td>胆固醇高</td></tr><tr><td align="center">动物脂肪</td><td align="center">否</td><td>猪油、肥猪肉、黄油、肥羊、肥牛、肥鸭和肥鹅等</td></tr><tr><td align="center">动物皮</td><td align="center">否</td><td>禽类皮</td></tr><tr><td align="center">鱼子</td><td align="center">否</td><td>胆固醇高</td></tr><tr><td align="center">鱿鱼</td><td align="center">否</td><td>胆固醇高</td></tr></tbody></table><h2 id="三-蔬菜"><a href="#三-蔬菜" class="headerlink" title="三. 蔬菜"></a>三. 蔬菜</h2><table><thead><tr><th align="center">名称</th><th align="center">食用</th><th>备注</th></tr></thead><tbody><tr><td align="center">蔬菜</td><td align="center">是</td><td>补充维生素，有较好的抗氧化功能且易消化吸收</td></tr><tr><td align="center">芥蓝</td><td align="center">是</td><td>高纤维，维生素，蛋白质，钙。</td></tr><tr><td align="center">西蓝花</td><td align="center">是</td><td>高纤维，维生素C</td></tr><tr><td align="center">菠菜</td><td align="center">适量</td><td>高纤维。草酸含量较高，肾炎、肾结石一次不宜多食。</td></tr><tr><td align="center">蘑菇</td><td align="center">是</td><td>高纤维，草菇，冬菇，蘑菇，云耳</td></tr><tr><td align="center">大蒜</td><td align="center">否</td><td>辛辣，有刺激性。可以降低血清胆固醇、甘油三脂及防治动脉粥样硬化，还可以降低血糖。</td></tr><tr><td align="center">洋葱</td><td align="center">适量</td><td>辛辣，有刺激性，避免生吃。适宜高血压、高血脂、动脉硬化等心血管疾病、急慢性肠炎以及消化不良者。</td></tr><tr><td align="center">青椒</td><td align="center">否</td><td>眼疾患者、食管炎、胃肠炎、胃溃疡、痔疮患者应少吃或忌食</td></tr></tbody></table><h2 id="四-水果"><a href="#四-水果" class="headerlink" title="四. 水果"></a>四. 水果</h2><table><thead><tr><th align="center">名称</th><th align="center">食用</th><th>备注</th></tr></thead><tbody><tr><td align="center">水果</td><td align="center">是</td><td>补充维生素，有较好的抗氧化功能且易消化吸收。</td></tr><tr><td align="center">西瓜</td><td align="center">适量</td><td>糖分较高。</td></tr><tr><td align="center">香蕉</td><td align="center">是</td><td>胃酸较多时不宜多吃。</td></tr><tr><td align="center">苹果</td><td align="center">是</td><td></td></tr><tr><td align="center">橙子</td><td align="center">是</td><td>维生素，纤维素</td></tr><tr><td align="center">西柚</td><td align="center">是</td><td>葡萄柚。维生素，纤维素</td></tr><tr><td align="center">西梅</td><td align="center">是</td><td>维生素，纤维素</td></tr><tr><td align="center">大枣</td><td align="center">是</td><td>促消化</td></tr><tr><td align="center">山楂</td><td align="center">是</td><td>消食，维生素</td></tr></tbody></table><h2 id="五-奶类"><a href="#五-奶类" class="headerlink" title="五. 奶类"></a>五. 奶类</h2><table><thead><tr><th align="center">名称</th><th align="center">食用</th><th>备注</th></tr></thead><tbody><tr><td align="center">酸牛奶</td><td align="center">是</td><td>降脂</td></tr></tbody></table><h2 id="六-薯类淀粉"><a href="#六-薯类淀粉" class="headerlink" title="六. 薯类淀粉"></a>六. 薯类淀粉</h2><table><thead><tr><th align="center">名称</th><th align="center">食用</th><th>备注</th></tr></thead><tbody><tr><td align="center">土豆</td><td align="center">是</td><td>高纤维</td></tr><tr><td align="center">红薯</td><td align="center">少量</td><td>产生胃酸</td></tr><tr><td align="center">紫薯</td><td align="center">少量</td><td>含糖高，产生胃酸</td></tr></tbody></table><h2 id="七-其它"><a href="#七-其它" class="headerlink" title="七. 其它"></a>七. 其它</h2><table><thead><tr><th align="center">名称</th><th align="center">食用</th><th>备注</th></tr></thead><tbody><tr><td align="center">碳酸饮料</td><td align="center">否</td><td>刺激性，限制糖分</td></tr><tr><td align="center">浓茶</td><td align="center">否</td><td>刺激性</td></tr><tr><td align="center">咖啡</td><td align="center">否</td><td>刺激性</td></tr><tr><td align="center">油炸</td><td align="center">否</td><td>高脂高胆固醇</td></tr><tr><td align="center">膨化食品</td><td align="center">否</td><td>高脂高胆固醇</td></tr><tr><td align="center">烟薰</td><td align="center">否</td><td></td></tr><tr><td align="center">腌制</td><td align="center">否</td><td>减少食盐摄入</td></tr><tr><td align="center">甜食</td><td align="center">否</td><td>限制摄入</td></tr></tbody></table><h2 id="八-水果冷藏"><a href="#八-水果冷藏" class="headerlink" title="八. 水果冷藏"></a>八. 水果冷藏</h2><p>自己会释放乙烯的水果不适合放入冰箱，乙烯是天然催熟剂，冰箱会抑制乙烯生产。</p><ul><li>释放：<ul><li>香蕉</li><li>榴莲</li><li>牛油果：优质脂肪，脂肪含量很高。</li><li>芒果：富含胡萝卜素。</li><li>桃子：桃仁有毒。</li><li>杏：富含钾和胡萝卜素。苦杏仁有毒。</li><li>猕猴桃：富含VC和膳食纤维。</li></ul></li><li>不释放：冷藏或直接吃。<ul><li>草莓：冷藏2到3天吃完。</li><li>葡萄：冷藏一周内吃完。</li><li>菠萝：冷藏5到7天内吃完。</li><li>荔枝：冷藏2到3天吃完。含糖量高。</li><li>樱桃：冷藏2到3天吃完。</li><li>枇杷：冷藏两周内吃完。含糖不高，果核有毒。</li><li>石榴：冷藏一个月吃完。</li><li>橘子：冷藏一周内吃完。</li><li>西瓜：切开后立马吃掉。</li></ul></li></ul><hr>]]></content>
    
    
    <summary type="html">整理胃病期间需要注意的食品摄入。</summary>
    
    
    
    <category term="编程之外" scheme="http://linyishui.top/categories/%E7%BC%96%E7%A8%8B%E4%B9%8B%E5%A4%96/"/>
    
    <category term="健康" scheme="http://linyishui.top/categories/%E7%BC%96%E7%A8%8B%E4%B9%8B%E5%A4%96/%E5%81%A5%E5%BA%B7/"/>
    
    
    <category term="food" scheme="http://linyishui.top/tags/food/"/>
    
  </entry>
  
  <entry>
    <title>Oracle问题排查记录</title>
    <link href="http://linyishui.top/2022010501.html"/>
    <id>http://linyishui.top/2022010501.html</id>
    <published>2022-01-05T01:49:32.000Z</published>
    <updated>2022-04-06T03:06:13.127Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Oracle问题排查记录"><a href="#Oracle问题排查记录" class="headerlink" title="Oracle问题排查记录"></a>Oracle问题排查记录</h1><p>本篇开始记录日常工作中遇到的Oracle数据库相关问题和排查过程，隐去了敏感信息，内容整理形式为个人备忘录，一些问题受限于个人能力和时间不会进行全面的解析。</p><h2 id="一-慢查询SQL"><a href="#一-慢查询SQL" class="headerlink" title="一. 慢查询SQL"></a>一. 慢查询SQL</h2><h3 id="慢查询SQL"><a href="#慢查询SQL" class="headerlink" title="慢查询SQL"></a>慢查询SQL</h3><p>相关内容：《<a href="../2019091401.html" title="Title">SQL规范和优化</a>》查看优化案例内容。</p><h3 id="慢查询SQL-大表关联"><a href="#慢查询SQL-大表关联" class="headerlink" title="慢查询SQL-大表关联"></a>慢查询SQL-大表关联</h3><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">--     1.查询当前在活动的会话获得SQL_ID值</span></span><br><span class="line"><span class="keyword">select</span> a.USERNAME,</span><br><span class="line">       a.SQL_ID,</span><br><span class="line">       a.SID,</span><br><span class="line">       a.MACHINE,</span><br><span class="line">       a.PROGRAM,</span><br><span class="line">       a.sql_hash_value,</span><br><span class="line">       a.blocking_session_status</span><br><span class="line"><span class="keyword">from</span> v$session a</span><br><span class="line"><span class="keyword">where</span> a.status <span class="operator">=</span> <span class="string">&#x27;ACTIVE&#x27;</span></span><br><span class="line">  <span class="keyword">AND</span> a.SCHEMA# <span class="operator">&gt;</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">--     2.获得此sql_id对应的sql语句 </span></span><br><span class="line"><span class="keyword">select</span> sql_id, sql_fulltext <span class="keyword">from</span> v$<span class="keyword">sql</span> <span class="keyword">where</span> sql_id <span class="operator">=</span> <span class="string">&#x27;9j2c5zhzvsfd7&#x27;</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">--     3.查询此sql_id历史执行信息</span></span><br><span class="line"><span class="keyword">select</span> a.INSTANCE_NUMBER,</span><br><span class="line">       a.snap_id,</span><br><span class="line">       a.sql_id,</span><br><span class="line">       a.plan_hash_value,</span><br><span class="line">       b.begin_interval_time</span><br><span class="line"><span class="keyword">from</span> dba_hist_sqlstat a, dba_hist_snapshot b</span><br><span class="line"><span class="keyword">where</span> sql_id <span class="operator">=</span> <span class="string">&#x27;9j2c5zhzvsfd7&#x27;</span></span><br><span class="line">  <span class="keyword">and</span> a.snap_id <span class="operator">=</span> b.snap_id</span><br><span class="line"><span class="keyword">order</span> <span class="keyword">by</span> instance_number, snap_id;</span><br><span class="line"></span><br><span class="line"><span class="comment">--     4.查询变更前后的执行计划</span></span><br><span class="line"><span class="keyword">select</span> sql_id,</span><br><span class="line">       plan_hash_value,</span><br><span class="line">       id,</span><br><span class="line">       operation,</span><br><span class="line">       options,</span><br><span class="line">       object_owner,</span><br><span class="line">       object_name,</span><br><span class="line">       depth,</span><br><span class="line">       cost,</span><br><span class="line">       <span class="type">timestamp</span></span><br><span class="line"><span class="keyword">from</span> DBA_HIST_SQL_PLAN</span><br><span class="line"><span class="keyword">where</span> sql_id <span class="operator">=</span> <span class="string">&#x27;dxx8pvcttf5qv&#x27;</span></span><br><span class="line">  <span class="keyword">and</span> plan_hash_value <span class="keyword">in</span> (<span class="number">1904478120</span>, <span class="number">2125777269</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">--     5.根据执行计划的不同点查找原因-使用coe_xfr_sql_profile.sql可以发现两种执行计划的效率(AVG_ET_SECS)</span></span><br><span class="line"><span class="keyword">select</span> <span class="operator">*</span></span><br><span class="line"><span class="keyword">from</span> dba_objects</span><br><span class="line"><span class="keyword">where</span> object_name <span class="operator">=</span> <span class="string">&#x27;MOD_LOTHISTORY_IDX01&#x27;</span></span><br><span class="line">  <span class="keyword">and</span> owner <span class="operator">=</span> <span class="string">&#x27;MDWMGR&#x27;</span></span><br><span class="line"><span class="keyword">order</span> <span class="keyword">by</span> last_ddl_time <span class="keyword">desc</span>;</span><br></pre></td></tr></table></figure><h3 id="慢查询-数据倾斜，且对绑定变量不敏感"><a href="#慢查询-数据倾斜，且对绑定变量不敏感" class="headerlink" title="慢查询-数据倾斜，且对绑定变量不敏感"></a>慢查询-数据倾斜，且对绑定变量不敏感</h3><h4 id="（1）问题表象"><a href="#（1）问题表象" class="headerlink" title="（1）问题表象"></a>（1）问题表象</h4><p>查询SQL执行超时，耗时几个小时才能返回。</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> xxx</span><br><span class="line"><span class="keyword">from</span> table_a a  </span><br><span class="line"><span class="keyword">left</span> <span class="keyword">join</span> table_m m </span><br><span class="line"><span class="keyword">on</span> a.xxx_code<span class="operator">=</span>m.xxx_code <span class="keyword">and</span> a.xxx_id<span class="operator">=</span>m.xxx_id <span class="keyword">and</span> a.xxx_type<span class="operator">=</span>m.xxx_type <span class="keyword">and</span> a.xxx_date<span class="operator">=</span>m.xxx_date</span><br><span class="line"><span class="keyword">where</span> m.xxx_date <span class="operator">&gt;=</span> :begin_date <span class="keyword">and</span> m.xxx_date <span class="operator">&lt;=</span> :end_date <span class="keyword">and</span> m.xxx_code <span class="operator">=</span>:xxx_code <span class="keyword">and</span> a.xxx_code<span class="operator">=</span>:xxx_code</span><br></pre></td></tr></table></figure><h4 id="（2）排查思路"><a href="#（2）排查思路" class="headerlink" title="（2）排查思路"></a>（2）排查思路</h4><p>1.生产环境PLSQL执行超时SQL，并查看执行计划。未发现性能问题。SQL为大表驱动大表，两表数据规模都为500W左右。</p><p>2.取下超时发生时间段的AWR报告（注意最好间隔1小时的取，时间跨度太大会掩盖掉一些信息）。从报告中未发现明显的资源紧张问题，CPU使用率也不高，未发现硬解析过高等问题。有两处注意点：</p><ul><li>行锁等待时间耗时比较明显，可能是大事务或者DML操作过于频繁，且SQL效率不高导致。</li><li>超时的SQL是耗时最久的SQL_ID。</li></ul><p>3.从AWR报告未能看出导致这个SQL变慢的原因。测试库相同数据未能复现问题，所以怀疑为生产库实际执行选择的执行计划过于糟糕。</p><p>继续查询生产环境下对应SQL的会话信息，是否有异常的等待事件：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> V$SESSION <span class="keyword">WHERE</span> SQL_ID <span class="operator">=</span> <span class="string">&#x27;gtw99bxf2k87d&#x27;</span> <span class="keyword">or</span> prev_sql_id <span class="operator">=</span> <span class="string">&#x27;gtw99bxf2k87d&#x27;</span>;</span><br></pre></td></tr></table></figure><p>发现该SQL发生了Latch争用事件，造成latch: cache buffers chains事件的原因大概率是SQL不够优化，产生了大量的逻辑读（逻辑读指从Buffer Cache中读取数据块，对应的物理读则是从磁盘读入Buffer Cache的过程），每次要访问一个block，就需要获得其对应latch，由于有大量的逻辑读，那么就增加了latch:cache buffers chains争用的机率。 查看AWR报告，发现该SQL确认产生了大量的逻辑读，但根据设想的执行计划分析不会产生如此多的逻辑读。</p><p>所以查看下该SQL_ID数据库中真实的执行计划：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> <span class="keyword">table</span>(dbms_xplan.display_cursor(<span class="string">&#x27;gtw99bxf2k87d&#x27;</span>));</span><br></pre></td></tr></table></figure><p>发现问题，驱动表选择了tableA，而不是tableM，对于A只能通过code过滤，过滤后仍有300W规模数据量（表的一半数据量），相当于全表扫了一遍，再同过滤出的数千条M进行关联过滤，性能可想而知是很糟糕的。</p><p>但是为什么数据库会选择这种执行计划呢？根据数据行和成本估计可以看出，生成该执行计划的那次硬解析判断合约表只会命中一条数据，综合此时的各项信息和排序后选择了该执行计划。</p><p>按照经验来说，Oracle的CBO模式应该会根据字段的取值比重调整对应的执行计划。为什么会一直采用此执行计划呢？</p><blockquote><p>补充知识：11g之前对于使用绑定变量窥探的SQL语句，Oracle会根据第一次执行使用的绑定变量值来用于以后的执行，即第一次做硬解析的时候，窥探了变量值，之后的软解析，不会再窥视。11g之后，有了ACS自适应游标的新特性，会根据绑定变量值的情况可以重新生成执行计划，因此这种问题得到了缓解。缓解了绑定变量窥探的副作用，相应地代价是可能会导致生成很多子游标。11g默认绑定变量窥探是开启的，由optim peek user binds隐藏参数控制。</p></blockquote><p>查看生产库该SQL是否对绑定变量敏感，结果为false：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> SQL_ID,SQL_TEXT,IS_BIND_SENSITIVE,IS_BIND_AWARE <span class="keyword">from</span> v$<span class="keyword">sql</span> t <span class="keyword">where</span> t.SQL_ID <span class="operator">=</span> <span class="string">&#x27;gtw99bxf2k87d&#x27;</span>;</span><br></pre></td></tr></table></figure><p>查看ACS是否开启：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">-- 查看ACS相关配置</span></span><br><span class="line"><span class="keyword">select</span> name, <span class="keyword">value</span> <span class="keyword">from</span> v$<span class="keyword">parameter</span> <span class="keyword">where</span> name <span class="keyword">in</span> (<span class="string">&#x27;optimizer_mode&#x27;</span>, <span class="string">&#x27;optimizer_features_enable&#x27;</span>, <span class="string">&#x27;optimizer_capture_sql_plan_baselines&#x27;</span>, <span class="string">&#x27;cursor_sharing&#x27;</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">-- 需要用SYS</span></span><br><span class="line"><span class="keyword">select</span> a.ksppinm name, </span><br><span class="line">       b.ksppstvl <span class="keyword">value</span>,</span><br><span class="line">      b.ksppstdf  isdefault</span><br><span class="line"><span class="keyword">from</span> sys.x$ksppi a, sys.x$ksppcv b</span><br><span class="line"><span class="keyword">where</span> a.inst_id <span class="operator">=</span> userenv(<span class="string">&#x27;Instance&#x27;</span>) </span><br><span class="line">  <span class="keyword">and</span> b.inst_id <span class="operator">=</span> userenv(<span class="string">&#x27;Instance&#x27;</span>) </span><br><span class="line">  <span class="keyword">and</span> a.indx <span class="operator">=</span> b.indx </span><br><span class="line">  <span class="keyword">and</span> a.ksppinm <span class="keyword">in</span> (<span class="string">&#x27;_optim_peek_user_binds&#x27;</span>, <span class="string">&#x27;_optimizer_adaptive_cursor_sharing&#x27;</span>, <span class="string">&#x27;_optimizer_extended_cursor_sharing&#x27;</span>, <span class="string">&#x27;_optimizer_extended_cursor_sharing_rel&#x27;</span>)</span><br><span class="line"><span class="keyword">order</span> <span class="keyword">by</span> <span class="built_in">translate</span>(a.ksppinm, <span class="string">&#x27; _&#x27;</span>, <span class="string">&#x27; &#x27;</span>);</span><br></pre></td></tr></table></figure><ul><li>optimizer_mode：优化器模式，表示选择使用CBO还是RBO</li><li>optimizer_features_enable：使用优化器特性版本，是否支持ACS。</li><li>optimizer_capture_sql_plan_baselines=false：关闭了SQL执行计划baseline管理机制；</li><li>cursor_sharing=EXACT：完全匹配的绑定变量机制；</li><li>_optim_peek_user_binds：是否开启绑定变量机制；</li></ul><p>之后的三个隐藏参数与ACS开启与否相关：</p><ul><li>_optimizer_adaptive_cursor_sharing</li><li>optimizer_extended_cursor_sharing</li><li>_optimizer_extended_cursor_sharing_rel</li></ul><p>发现都未开启。但开启ACS需要DBA来判断，如果贸然的因为这个问题取修改Oracle配置似乎不太说的过去，即使理应开启以避免其它有数据倾斜情况的表出现同样的问题。但尝试在测试环境造各种情况数据后，都未能复现出生产的以合约信息表为驱动的执行计划，所以无法验证ACS是否有效。</p><h4 id="（3）修改方案"><a href="#（3）修改方案" class="headerlink" title="（3）修改方案"></a>（3）修改方案</h4><p>建议DBA评估开启ACS功能，从而能根据绑定变量的值来选择最优的执行计划，避免绑定变量窥探问题。</p><p>程序修改，在SQL中添加hint注释LEADING(M)，强制以M表为驱动表。</p><p>开发团队进行预警和经验分享，避免相同问题排查解决消耗过多资源。</p><h3 id="压测环境性能问题排查"><a href="#压测环境性能问题排查" class="headerlink" title="压测环境性能问题排查"></a>压测环境性能问题排查</h3><h4 id="（1）问题表象-1"><a href="#（1）问题表象-1" class="headerlink" title="（1）问题表象"></a>（1）问题表象</h4><p>性能机压测时发现任务耗时相比以往有明显增加，同事排查后确认大致为数据库问题，遂取任务执行一小时的AWR报告进行分析。</p><h4 id="（2）排查思路-1"><a href="#（2）排查思路-1" class="headerlink" title="（2）排查思路"></a>（2）排查思路</h4><ol><li>发现数据库有硬解析过多问题，可能和未使用绑定变量有关。</li><li>发现等待事件中Concurrency占比较大，<code>cursor: mutex X</code> 尤为明显，还有 <code>db file sequential read</code> 、<code>cursor: mutex S</code> 、<code>row cache mutex</code> 等。</li><li>发现有多个SQL的Version Count过大，查看子游标产生原因时，发现都是bind_equiv_failure和ROLL_INVALID_MISMATCH导致。前者因为绑定变量与实际字段类型不匹配，后者一般和自动统计信息有关。</li><li>查看问题SQL的实际字段类型发现为NUMBER，绑定变量则为VARCHAR。</li><li>并关联到一个Oracle BUG：Bug 28794230 - 12.2 Cursor Mutex X Due To Sql Not Shared Because Of BIND_EQUIV_FAILURE (Doc ID 28794230.8) </li><li>将此问题反馈给同事。</li></ol><h4 id="（3）修改方案-1"><a href="#（3）修改方案-1" class="headerlink" title="（3）修改方案"></a>（3）修改方案</h4><ul><li>分析问题SQL，尝试优化分解。</li><li>修复Oracle BUG，执行补丁或升级版本。</li></ul><h2 id="二-其他"><a href="#二-其他" class="headerlink" title="二. 其他"></a>二. 其他</h2><h3 id="ORA-24347"><a href="#ORA-24347" class="headerlink" title="ORA-24347"></a>ORA-24347</h3><h4 id="（1）现象"><a href="#（1）现象" class="headerlink" title="（1）现象"></a>（1）现象</h4><p>某生产环境突然发现异常情况，SQL查询一直报错，导致后续流程无法执行。远程查看生产日志后发现报错信息为：<code>ORA-24347: Warning of a NULL column in an aggregate function but no null field</code> 。</p><p>有问题的SQL：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span>  a.XXX, ...,</span><br><span class="line">        (<span class="keyword">case</span> <span class="keyword">when</span> b.xxx <span class="keyword">is</span> <span class="keyword">null</span> <span class="keyword">then</span> <span class="number">0</span> <span class="keyword">else</span> b.xxx <span class="keyword">end</span>) xxx,</span><br><span class="line"><span class="keyword">from</span> table_1 a</span><br><span class="line"><span class="keyword">left</span> <span class="keyword">join</span> (<span class="keyword">select</span> <span class="built_in">min</span>(xxx) xxx, ... </span><br><span class="line">           <span class="keyword">from</span> table_2 </span><br><span class="line">           <span class="keyword">group</span> <span class="keyword">by</span> ...) c  </span><br><span class="line"><span class="keyword">on</span> ...</span><br><span class="line"><span class="keyword">left</span> <span class="keyword">join</span> table_2 b </span><br><span class="line"><span class="keyword">on</span> ...</span><br><span class="line"><span class="keyword">where</span> a.xxx_1 <span class="operator">=</span> :xxx_1 <span class="keyword">and</span> a.xxx_date <span class="operator">&gt;=</span> :begin_date <span class="keyword">and</span> a.xxx_date <span class="operator">&lt;=</span> :end_date</span><br></pre></td></tr></table></figure><h4 id="（2）分析"><a href="#（2）分析" class="headerlink" title="（2）分析"></a>（2）分析</h4><p>根据异常信息可知问题是聚合函数中Column字段中存在Null值，但该系统所有字段应该都有加非空约束，所以首先排查了表结构和约束是否有构建成功：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> TABLE_NAME,COLUMN_NAME,DATA_TYPE,DATA_LENGTH,DATA_PRECISION,DATA_SCALE,NULLABLE,DATA_DEFAULT</span><br><span class="line"><span class="keyword">from</span> user_tab_columns </span><br><span class="line"><span class="keyword">where</span> TABLE_NAME <span class="operator">=</span> <span class="string">&#x27;table_2&#x27;</span></span><br><span class="line"><span class="keyword">ORDER</span> <span class="keyword">BY</span> DATA_LENGTH,TABLE_NAME,COLUMN_NAME,DATA_TYPE;</span><br></pre></td></tr></table></figure><p>结果显示字段xxx有非空约束，远程连接生产库，替换参数后执行该SQL，并无问题。查看该表数据也无Null值字段返回。Oracle官网查看相关资料后，并未发现一样的案例，但该问题似乎有过多次BUG出现，所以怀疑有两种可能：</p><ol><li>现场有多个库环境，我远程看的是正常数据的库，但实际程序执行SQL是异常的库环境（但这个猜想被现场同事否认）。</li><li>PLSQL工具查看时隐藏了异常数据，导致我们无法通过查询命中到Null值的数据（生产无其他工具可供使用）。</li></ol><h4 id="（3）解决"><a href="#（3）解决" class="headerlink" title="（3）解决"></a>（3）解决</h4><p>所以先临时修改SQL，将 <code>min(xxx)</code> 改为 <code>min(NVL(xxx, &#39; &#39;))</code> ，挑了一个空闲间隔重启了程序。重新执行相关功能后，发现问题解决。证明异常数据存在，但暂时无法定位到。</p>]]></content>
    
    
    <summary type="html">记录Oracle日常所遇到的问题排查情况。</summary>
    
    
    
    <category term="技术文档" scheme="http://linyishui.top/categories/%E6%8A%80%E6%9C%AF%E6%96%87%E6%A1%A3/"/>
    
    
    <category term="sql" scheme="http://linyishui.top/tags/sql/"/>
    
    <category term="oracle" scheme="http://linyishui.top/tags/oracle/"/>
    
  </entry>
  
  <entry>
    <title>Oracle-AWR报告 &lt;整&gt;</title>
    <link href="http://linyishui.top/2021123001.html"/>
    <id>http://linyishui.top/2021123001.html</id>
    <published>2021-12-31T07:01:22.000Z</published>
    <updated>2022-04-06T05:52:50.754Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Oracle-AWR报告"><a href="#Oracle-AWR报告" class="headerlink" title="Oracle-AWR报告"></a>Oracle-AWR报告</h1><h2 id="一-简述"><a href="#一-简述" class="headerlink" title="一. 简述"></a>一. 简述</h2><h3 id="1-1-什么是AWR报告？"><a href="#1-1-什么是AWR报告？" class="headerlink" title="1.1 什么是AWR报告？"></a>1.1 什么是AWR报告？</h3><p>AWR (Automatic Workload Repository) 是自动负载信息库的英文缩写，是Oracle 10g以后版本提供的一种性能收集和分析工具，能提供一个时间段内整个系统资源使用情况的报告，通过报告可以了解一个系统的整个运行情况，生成的报告包括多个部分。</p><p>AWR每小时对 <code>v$active_session_history</code> 视图（内存中的ASH采集信息，理论为1小时）进行采样一次，并将信息保存到磁盘中，并且保留7天，7天后旧的记录才会被覆盖。这些采样信息被保存在 <code>wrh$_active_session_history</code> 视图（写入AWR库中的ASH信息，理论为1小时以上）中。而这个采样频率（1小时）和保留时间（7天）是可以根据实际情况进行调整的。</p><h3 id="1-2-使用场景"><a href="#1-2-使用场景" class="headerlink" title="1.2 使用场景"></a>1.2 使用场景</h3><ul><li>查看数据库详细运行状态</li><li>测试过程中发现数据库出现瓶颈但无法定位到具体原因时，可以借用AWR报告进行分析定位。</li></ul><p>数据库出现性能问题，一般都在三个地方：IO、内存、CPU，这三个地方又是息息相关的。当IO负载增大时，肯定需要更多的内存来存放，同时也需要CPU花费更多的时间来过滤这些数据。相反，CPU时间花费多的话，有可能是解析SQL语句，也可能是过滤太多的数据，倒不一定是和IO或内存有关系。</p><ul><li>CPU：解析SQL语句，生成的执行计划。</li><li>内存：SQL语句和执行计划都需要在内存保留一段时间，还有取到的数据，根据LRU算法也会尽量在内存中保留，在执行SQL语句过程中，各种表之间的连接，排序等操作也要占用内存。</li><li>IO：如果需要的数据不在内存中，则需要到磁盘中去取，就会涉及到物理IO了；还有表之间的连接数据太多，以及排序等操作内存放不下的时候，需要用到临时表空间，也会消耗物理IO。</li></ul><p>ORACLE分配的内存中PGA一般只占20%，对于专用服务器模式，每次执行SQL语句、表数据的运算等操作，都在PGA中进行的，也就是说只能用ORACL分配内存的20%左右。如果多个用户都执行多表关联，而且表数据又多，再加上关联不当的话，内存就成为瓶颈了，所以优化SQL很重要的一点就是，减少逻辑读和物理读。</p><h3 id="1-3-生成AWR报告"><a href="#1-3-生成AWR报告" class="headerlink" title="1.3 生成AWR报告"></a>1.3 生成AWR报告</h3><p>Linux使用sqlplus生成AWR报告，安装：<a href="https://www.oracle.com/database/technologies/instant-client/linux-x86-64-downloads.html">Instant Client for Linux x86-64</a></p><p>下载basic和sqlplus的rpm包后，上传到tmp目录：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">cd /tmp</span><br><span class="line">rpm -ivh oracle-instantclientXXX-basic-XXX-1.x86_64.rpm</span><br><span class="line">rpm -ivh oracle-instantclientXXX-sqlplus-XXX-1.x86_64.rpm</span><br></pre></td></tr></table></figure><p>安装完毕后，生成的客户端目录在 <strong>/usr/lib/oracle/12.2/client64</strong> ，在该目录下新建<strong>network</strong>目录，并编写<strong>tnsnames.ora</strong>文件：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">mkdir network</span><br><span class="line">vi tnsnames.ora</span><br><span class="line"></span><br><span class="line">testdb =</span><br><span class="line">  (DESCRIPTION =</span><br><span class="line">    (ADDRESS_LIST =</span><br><span class="line">      (ADDRESS = (PROTOCOL = TCP)(HOST = XXX.XXX.XXX.XXX)(PORT = 1521))</span><br><span class="line">    )</span><br><span class="line">    (CONNECT_DATA =</span><br><span class="line">      (SID = testdb)</span><br><span class="line">      (SERVER = DEDICATED)</span><br><span class="line">    )</span><br><span class="line">  )</span><br></pre></td></tr></table></figure><p>修改完成后按下 <code>esc</code> + <code>:wq</code> 保存退出。</p><p>配置环境变量：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">vi ~/.bash_profile</span><br><span class="line"></span><br><span class="line">export  ORACLE_HOME=/usr/lib/oracle/12.2/client64</span><br><span class="line">export  TNS_ADMIN=$ORACLE_HOME/network</span><br><span class="line">export  LD_LIBRARY_PATH=$ORACLE_HOME/lib:/usr/local/lib:$LD_LIBRARY_PATH:.</span><br><span class="line">export  ORABIN=$ORACLE_HOME/bin</span><br><span class="line">export  NLS_LANG=AMERICAN_AMERICA.ZHS16GBK</span><br><span class="line">export ORACLE_SID=orcl</span><br><span class="line">PATH=$PATH:$ORACLE_HOME/bin:$ORABIN</span><br><span class="line"></span><br><span class="line">source ~/.bash_profile</span><br></pre></td></tr></table></figure><p>登陆sqlplus：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">sqlplus sys@XXX.XXX.XXX.XXX:1521/orcl AS SYSDBA</span><br><span class="line"><span class="meta">sql&gt;</span><span class="bash"> @/u01/app/oracle/12c/rdbms/admin/awrrpt.sql</span></span><br><span class="line"></span><br><span class="line">Enter value of report_type</span><br><span class="line"><span class="meta">#</span><span class="bash"> 意思是生成报告的格式有两种，html和txt，这里选择html</span></span><br><span class="line">Enter value of num_days</span><br><span class="line"><span class="meta">#</span><span class="bash"> 收集几天的报告信息，数字，可以输入1</span></span><br><span class="line">Enter value of begin_snap</span><br><span class="line"><span class="meta">#</span><span class="bash"> 输入开始快照id，要根据日志打印的快照id范围来填</span></span><br></pre></td></tr></table></figure><p>生成的 <code>.lst</code> 文件直接拷贝为html打开即可。</p><h2 id="二-相关知识点"><a href="#二-相关知识点" class="headerlink" title="二. 相关知识点"></a>二. 相关知识点</h2><h3 id="2-1-硬解析和软解析"><a href="#2-1-硬解析和软解析" class="headerlink" title="2.1 硬解析和软解析"></a>2.1 硬解析和软解析</h3><h4 id="（1）SQL执行过程"><a href="#（1）SQL执行过程" class="headerlink" title="（1）SQL执行过程"></a>（1）SQL执行过程</h4><p>Oracle中SQL的执行过程：</p><ol><li><strong>语法检查</strong>（syntax check）：检查此SQL的拼写是否符合语法。如关键字书写错误等。</li><li><strong>语义检查</strong>（semantic check）：诸如检查SQL语句中的访问对象是否存在及该用户是否具备相应的权限。如 <code>ORA-00942: table or view does not exist</code> 等。</li><li>对SQL语句进行<strong>解析</strong>（prase）：利用内部算法对SQL进行解析，生成解析树（parse tree）及执行计划（execution plan）。</li><li>执行SQL，返回结果（execute and return）。</li></ol><h4 id="（2）什么是软、硬解析？"><a href="#（2）什么是软、硬解析？" class="headerlink" title="（2）什么是软、硬解析？"></a>（2）什么是软、硬解析？</h4><p>硬解析和软解析就发生在第三步。Oracle利用hash算法来取得SQL的hash值，然后在library cache里查找是否存在该hash值；</p><ul><li>假设存在，则将此SQL与cache中的进行比较；</li><li>假设“相同”，就将利用已有的解析树与执行计划，而省略了优化器的相关工作。这也就是软解析的过程。</li></ul><p>当然，如果上面的2个假设中任有一个不成立，那么优化器都将进行创建解析树、生成执行计划的动作。这个过程就叫硬解析。创建解析树、生成执行计划对于SQL的执行来说是开销昂贵的动作；以及会占据重要的门闩（latch）资源，严重的影响系统的规模的扩大（即限制了系统的并发行）， 而且引起的问题不能通过增加内存条和cpu的数量来解决。所以应当极力避免硬解析，尽量使用软解析。</p><blockquote><p>闩是锁的细化，可以理解为是一种轻量级的串行化设备。当进程申请到闩后，则这些闩用于保护共享内存的数在同一时刻不会被两个以上的进程修改。在硬解析时，需要申请闩的使用，而闩的数量在有限的情况下需要等待。大量的闩的使用由此造成需要使用闩的进程排队越频繁，性能则逾低下。</p><p>绝大多数latch问题都与没有使用绑定变量有关：</p><ul><li>library-cache latch（库缓存latch）</li><li>重做日志生成问题（redo-allocation latch，重做日志的分配latch ）</li><li>缓存竞争问题（cache-buffers LRU-chain latch，缓存的最近最少使用链latch）</li><li>缓存中的热块（cache-buffers chain latch，缓存链latch）</li></ul></blockquote><p><strong>软解析执行过程</strong>：</p><ul><li>语法、语义及权限检查;</li><li>将整条SQL hash后从库缓存中执行计划。</li></ul><p><strong>硬解析执行过程</strong>：</p><ul><li>语法、语义及权限检查;</li><li>查询转换，通过应用各种不同的转换技巧，会生成语义上等同的新的SQL语句，如 <code>count(1)</code> 会转为 <code>count(*)</code> 。</li><li>根据统计信息生成执行计划，找出成本最低的路径，这一步比较耗时</li><li>将游标信息（执行计划）保存到库缓存（library cache）。</li></ul><p>还包括一种软软解析，指设置了session_cursor_cache后，Cursor被直接Cache在当前Session的PGA中的，在解析的时候只需要对其语法分析、权限对象分析之后就可以转到PGA中查找。</p><p>DDL和DML：</p><ul><li>DDL：CREATE,DROP,ALTER等，必然进行硬解析。</li><li>DML：INSERT,UPDATE,DELETE,SELECT等，进行硬解析或软解析。</li></ul><p>硬解析和软解析模拟：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"># 硬解析，不使用绑定变量</span><br><span class="line"><span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> test <span class="keyword">where</span> object_id<span class="operator">=</span><span class="number">20</span>; </span><br><span class="line"><span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> test <span class="keyword">where</span> object_id<span class="operator">=</span><span class="number">30</span>; </span><br><span class="line"><span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> test <span class="keyword">where</span> object_id<span class="operator">=</span><span class="number">40</span>; </span><br><span class="line"><span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> test <span class="keyword">where</span> object_id<span class="operator">=</span><span class="number">50</span>; </span><br><span class="line"></span><br><span class="line"># 软解析，使用绑定变量</span><br><span class="line"><span class="keyword">declare</span></span><br><span class="line">  sql_stat varchar2(<span class="number">200</span>);</span><br><span class="line">  p00      number(<span class="number">10</span>);</span><br><span class="line">  p01      varchar2(<span class="number">20</span>);</span><br><span class="line">  p02      varchar2(<span class="number">20</span>);</span><br><span class="line"><span class="keyword">begin</span></span><br><span class="line">  p00 :<span class="operator">=</span> <span class="number">3</span>; </span><br><span class="line">  p01 :<span class="operator">=</span> <span class="string">&#x27;321&#x27;</span>; </span><br><span class="line">  p02 :<span class="operator">=</span> <span class="string">&#x27;34030&#x27;</span>;</span><br><span class="line">  sql_stat :<span class="operator">=</span> <span class="string">&#x27;update xxx_table set XXX_time = TO_NUMBER(TO_CHAR(SYSDATE,&#x27;&#x27;YYYYMMDD.HH24MISS&#x27;&#x27;)), XXX_no = &#x27;</span><span class="operator">||</span> p00 <span class="operator">||</span><span class="string">&#x27;,    XXX_desc = &#x27;</span><span class="operator">||</span> p01 <span class="operator">||</span><span class="string">&#x27;    where XXX_ID = &#x27;</span><span class="operator">||</span> p02 <span class="operator">||</span><span class="string">&#x27;   and XXX_no != &#x27;&#x27;4&#x27;&#x27; &#x27;</span>;</span><br><span class="line">  dbms_output.put_line(sql_stat);</span><br><span class="line">  <span class="keyword">execute</span> immediate sql_stat;</span><br><span class="line"><span class="keyword">end</span>;</span><br></pre></td></tr></table></figure><h4 id="（3）Version-Count"><a href="#（3）Version-Count" class="headerlink" title="（3）Version Count"></a>（3）Version Count</h4><p>首次硬解析时同时创建Parent Cursor和Child Cursor（二者都是Shared Cursor，作为Library cache object存放于Hash Buckets中）。</p><p>当SQL再次执行时，首先计算Hash Code，与存放在Parent Cursor的Bucket中的Hash Value进行匹配。匹配到则遍历Child Cursor，可以重用则继续使用，否则重新生成Child Cursor。一个父游标下的子游标个数可以看作Version Count。</p><p>当Version Count很高时，默认超过20就会显示在AWR报告中的SQL ordered by Version Count中，只要超过100，就需要额外注意该SQL。</p><p>查看Cursor不能共享原因的方法：</p><ol><li><p>查看parent cursor 的hash value 和address：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> sql_text, hash_value,address <span class="keyword">from</span> v$sqlarea <span class="keyword">where</span> sql_text <span class="keyword">like</span> <span class="string">&#x27;XXX%&#x27;</span>;</span><br></pre></td></tr></table></figure></li><li><p>检查child cursor：显示结果为Y表示不能共享的原因。</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> v$sql_shared_cursor <span class="keyword">where</span> address <span class="operator">=</span> <span class="string">&#x27;0000000386BC2E58&#x27;</span></span><br></pre></td></tr></table></figure></li></ol><p>cursor的不可重用，也可能与cursor_sharing参数值设置有关。</p><p><code>V$SQL_SHARED_CURSOR</code> explains why a particular child cursor is not shared with existing child cursors. Each column identifies a specific reason why the cursor cannot be shared.</p><table><thead><tr><th align="left">Column</th><th align="left">Datatype</th><th align="left">Description</th></tr></thead><tbody><tr><td align="left"><code>SQL_ID</code></td><td align="left"><code>VARCHAR2(13)</code></td><td align="left">SQL identifier</td></tr><tr><td align="left"><code>ADDRESS</code></td><td align="left">`RAW(4</td><td align="left">8)`</td></tr><tr><td align="left"><code>CHILD_ADDRESS</code></td><td align="left">`RAW(4</td><td align="left">8)`</td></tr><tr><td align="left"><code>CHILD_NUMBER</code></td><td align="left"><code>NUMBER</code></td><td align="left">Child number</td></tr><tr><td align="left"><code>UNBOUND_CURSOR</code></td><td align="left"><code>VARCHAR2(1)</code></td><td align="left">(`Y</td></tr><tr><td align="left"><code>SQL_TYPE_MISMATCH</code></td><td align="left"><code>VARCHAR2(1)</code></td><td align="left">(`Y</td></tr><tr><td align="left"><code>OPTIMIZER_MISMATCH</code></td><td align="left"><code>VARCHAR2(1)</code></td><td align="left">(`Y</td></tr><tr><td align="left"><code>OUTLINE_MISMATCH</code></td><td align="left"><code>VARCHAR2(1)</code></td><td align="left">(`Y</td></tr><tr><td align="left"><code>STATS_ROW_MISMATCH</code></td><td align="left"><code>VARCHAR2(1)</code></td><td align="left">(`Y</td></tr><tr><td align="left"><code>LITERAL_MISMATCH</code></td><td align="left"><code>VARCHAR2(1)</code></td><td align="left">(`Y</td></tr><tr><td align="left"><code>SEC_DEPTH_MISMATCH</code></td><td align="left"><code>VARCHAR2(1)</code></td><td align="left">(`Y</td></tr><tr><td align="left"><code>EXPLAIN_PLAN_CURSOR</code></td><td align="left"><code>VARCHAR2(1)</code></td><td align="left">(`Y</td></tr><tr><td align="left"><code>BUFFERED_DML_MISMATCH</code></td><td align="left"><code>VARCHAR2(1)</code></td><td align="left">(`Y</td></tr><tr><td align="left"><code>PDML_ENV_MISMATCH</code></td><td align="left"><code>VARCHAR2(1)</code></td><td align="left">(`Y</td></tr><tr><td align="left"><code>INST_DRTLD_MISMATCH</code></td><td align="left"><code>VARCHAR2(1)</code></td><td align="left">(`Y</td></tr><tr><td align="left"><code>SLAVE_QC_MISMATCH</code></td><td align="left"><code>VARCHAR2(1)</code></td><td align="left">(`Y</td></tr><tr><td align="left"><code>TYPECHECK_MISMATCH</code></td><td align="left"><code>VARCHAR2(1)</code></td><td align="left">(`Y</td></tr><tr><td align="left"><code>AUTH_CHECK_MISMATCH</code></td><td align="left"><code>VARCHAR2(1)</code></td><td align="left">(`Y</td></tr><tr><td align="left"><code>BIND_MISMATCH</code></td><td align="left"><code>VARCHAR2(1)</code></td><td align="left">(`Y</td></tr><tr><td align="left"><code>DESCRIBE_MISMATCH</code></td><td align="left"><code>VARCHAR2(1)</code></td><td align="left">(`Y</td></tr><tr><td align="left"><code>LANGUAGE_MISMATCH</code></td><td align="left"><code>VARCHAR2(1)</code></td><td align="left">(`Y</td></tr><tr><td align="left"><code>TRANSLATION_MISMATCH</code></td><td align="left"><code>VARCHAR2(1)</code></td><td align="left">(`Y</td></tr><tr><td align="left"><code>ROW_LEVEL_SEC_MISMATCH</code></td><td align="left"><code>VARCHAR2(1)</code></td><td align="left">(`Y</td></tr><tr><td align="left"><code>INSUFF_PRIVS</code></td><td align="left"><code>VARCHAR2(1)</code></td><td align="left">(`Y</td></tr><tr><td align="left"><code>INSUFF_PRIVS_REM</code></td><td align="left"><code>VARCHAR2(1)</code></td><td align="left">(`Y</td></tr><tr><td align="left"><code>REMOTE_TRANS_MISMATCH</code></td><td align="left"><code>VARCHAR2(1)</code></td><td align="left">(`Y</td></tr><tr><td align="left"><code>LOGMINER_SESSION_MISMATCH</code></td><td align="left"><code>VARCHAR2(1)</code></td><td align="left">(`Y</td></tr><tr><td align="left"><code>INCOMP_LTRL_MISMATCH</code></td><td align="left"><code>VARCHAR2(1)</code></td><td align="left">(`Y</td></tr><tr><td align="left"><code>OVERLAP_TIME_MISMATCH</code></td><td align="left"><code>VARCHAR2(1)</code></td><td align="left">Mismatch caused by setting session parameter <code>ERROR_ON_OVERLAP_TIME</code></td></tr><tr><td align="left"><code>SQL_REDIRECT_MISMATCH</code></td><td align="left"><code>VARCHAR2(1)</code></td><td align="left">SQL redirection mismatch</td></tr><tr><td align="left"><code>MV_QUERY_GEN_MISMATCH</code></td><td align="left"><code>VARCHAR2(1)</code></td><td align="left">Internal, used to force a hard-parse when analyzing materialized view queries</td></tr><tr><td align="left"><code>USER_BIND_PEEK_MISMATCH</code></td><td align="left"><code>VARCHAR2(1)</code></td><td align="left">Cursor is not shared because value of one or more user binds is different and this has a potential to change the execution plan</td></tr><tr><td align="left"><code>TYPCHK_DEP_MISMATCH</code></td><td align="left"><code>VARCHAR2(1)</code></td><td align="left">Cursor has typecheck dependencies</td></tr><tr><td align="left"><code>NO_TRIGGER_MISMATCH</code></td><td align="left"><code>VARCHAR2(1)</code></td><td align="left">Cursor and child have no trigger mismatch</td></tr><tr><td align="left"><code>FLASHBACK_CURSOR</code></td><td align="left"><code>VARCHAR2(1)</code></td><td align="left">Cursor non-shareability due to flashback</td></tr><tr><td align="left"><code>ANYDATA_TRANSFORMATION</code></td><td align="left"><code>VARCHAR2(1)</code></td><td align="left">Is criteria for opaque type transformation and does not match</td></tr><tr><td align="left"><code>INCOMPLETE_CURSOR</code></td><td align="left"><code>VARCHAR2(1)</code></td><td align="left">Cursor is incomplete: typecheck heap came from call memory</td></tr><tr><td align="left"><code>TOP_LEVEL_RPI_CURSOR</code></td><td align="left"><code>VARCHAR2(1)</code></td><td align="left">Is top level RPI cursor</td></tr><tr><td align="left"><code>DIFFERENT_LONG_LENGTH</code></td><td align="left"><code>VARCHAR2(1)</code></td><td align="left">Value of <code>LONG</code> does not match</td></tr><tr><td align="left"><code>LOGICAL_STANDBY_APPLY</code></td><td align="left"><code>VARCHAR2(1)</code></td><td align="left">Logical standby apply context does not match</td></tr><tr><td align="left"><code>DIFF_CALL_DURN</code></td><td align="left"><code>VARCHAR2(1)</code></td><td align="left">If Slave SQL cursor/single call</td></tr><tr><td align="left"><code>BIND_UACS_DIFF</code></td><td align="left"><code>VARCHAR2(1)</code></td><td align="left">One cursor has bind UACs and one does not</td></tr><tr><td align="left"><code>PLSQL_CMP_SWITCHS_DIFF</code></td><td align="left"><code>VARCHAR2(1)</code></td><td align="left">PL/SQL anonymous block compiled with different PL/SQL compiler switches</td></tr><tr><td align="left"><code>CURSOR_PARTS_MISMATCH</code></td><td align="left"><code>VARCHAR2(1)</code></td><td align="left">Cursor was compiled with subexecution (cursor parts were executed)</td></tr><tr><td align="left"><code>STB_OBJECT_MISMATCH</code></td><td align="left"><code>VARCHAR2(1)</code></td><td align="left">STB has come into existence since cursor was compiled</td></tr><tr><td align="left"><code>ROW_SHIP_MISMATCH</code></td><td align="left"><code>VARCHAR2(1)</code></td><td align="left">Session does not support row shipping, but cursor built in one that did</td></tr><tr><td align="left"><code>PQ_SLAVE_MISMATCH</code></td><td align="left"><code>VARCHAR2(1)</code></td><td align="left">Top-level slave decides not to share cursor</td></tr><tr><td align="left"><code>TOP_LEVEL_DDL_MISMATCH</code></td><td align="left"><code>VARCHAR2(1)</code></td><td align="left">Is top-level DDL cursor</td></tr><tr><td align="left"><code>MULTI_PX_MISMATCH</code></td><td align="left"><code>VARCHAR2(1)</code></td><td align="left">Cursor has multiple parallelizers and is slave-compiled</td></tr><tr><td align="left"><code>BIND_PEEKED_PQ_MISMATCH</code></td><td align="left"><code>VARCHAR2(1)</code></td><td align="left">Cursor based around bind peeked values</td></tr><tr><td align="left"><code>MV_REWRITE_MISMATCH</code></td><td align="left"><code>VARCHAR2(1)</code></td><td align="left">Cursor needs recompilation because an SCN was used during compile time due to being rewritten by materialized view</td></tr><tr><td align="left"><code>ROLL_INVALID_MISMATCH</code></td><td align="left"><code>VARCHAR2(1)</code></td><td align="left">Marked for rolling invalidation and invalidation window exceeded</td></tr><tr><td align="left"><code>OPTIMIZER_MODE_MISMATCH</code></td><td align="left"><code>VARCHAR2(1)</code></td><td align="left">Parameter <code>OPTIMIZER_MODE</code> mismatch (for example, all_rows versus first_rows_1)</td></tr><tr><td align="left"><code>PX_MISMATCH</code></td><td align="left"><code>VARCHAR2(1)</code></td><td align="left">Mismatch in one parameter affecting the parallelization of a SQL statement. For example, one cursor was compiled with parallel DML enabled while the other was not.</td></tr><tr><td align="left"><code>MV_STALEOBJ_MISMATCH</code></td><td align="left"><code>VARCHAR2(1)</code></td><td align="left">Cursor cannot be shared because there is a mismatch in the list of materialized views which were stale at the time the cursor was built</td></tr><tr><td align="left"><code>FLASHBACK_TABLE_MISMATCH</code></td><td align="left"><code>VARCHAR2(1)</code></td><td align="left">Cursor cannot be shared because there is a mismatch with triggers being enabled and/or referential integrity constraints being deferred</td></tr><tr><td align="left"><code>LITREP_COMP_MISMATCH</code></td><td align="left"><code>VARCHAR2(1)</code></td><td align="left">Mismatch in use of literal replacement</td></tr></tbody></table><h4 id="（4）绑定变量"><a href="#（4）绑定变量" class="headerlink" title="（4）绑定变量"></a>（4）绑定变量</h4><p>日常使用中，硬解析过高常常因为SQL未使用绑定变量导致。</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">-- 使用绑定变量</span></span><br><span class="line"><span class="keyword">select</span> xxx <span class="keyword">from</span> table_a <span class="keyword">where</span> a <span class="operator">=</span> :a <span class="keyword">and</span> b <span class="operator">=</span> :b;</span><br><span class="line"></span><br><span class="line"><span class="comment">-- 不使用绑定变量</span></span><br><span class="line"><span class="keyword">select</span> xxx <span class="keyword">from</span> table_a <span class="keyword">where</span> a <span class="operator">=</span> <span class="number">1</span> <span class="keyword">and</span> b <span class="operator">=</span> <span class="string">&#x27;A&#x27;</span>;</span><br><span class="line"><span class="keyword">select</span> xxx <span class="keyword">from</span> table_a <span class="keyword">where</span> a <span class="operator">=</span> <span class="number">2</span> <span class="keyword">and</span> b <span class="operator">=</span> <span class="string">&#x27;A&#x27;</span>;</span><br></pre></td></tr></table></figure><p>Oracle接收SQL后，首先根据Hash算法得到Hash值，然后在共享池寻找是否有匹配的SQL。如果存在则直接用已有的SQL执行计划来执行，最后返回结果。如果不存在，则需要执行硬解析。</p><p>绑定变量只是起到占位的作用，让Oracle每次对用户发来的SQL做hash运算时，运算出的结果都是同样的Hash值，于是将所有的用户发来的SQL看作是同一个SQL来对象。</p><p>所以合理的使用绑定变量后，Oracle可以在共享池中命中相同SQL，然后从而避免了高昂的硬解析操作，以及减少latch争用，特别是在这个SQL调用次数较多和频繁的场景下。</p><h4 id="（5）Oracle排查硬解析SQL"><a href="#（5）Oracle排查硬解析SQL" class="headerlink" title="（5）Oracle排查硬解析SQL"></a>（5）Oracle排查硬解析SQL</h4><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">-- 查看系统解析统计信息</span></span><br><span class="line"><span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> v$sysstat <span class="keyword">where</span> name <span class="keyword">like</span> <span class="string">&#x27;%parse%&#x27;</span>;</span><br><span class="line"><span class="comment">-- 硬解析统计信息，通过观察value变化可以来确定SQL是否走了硬解析</span></span><br><span class="line"><span class="keyword">select</span> name,class,<span class="keyword">value</span> <span class="keyword">from</span> v$sysstat <span class="keyword">where</span> name <span class="operator">=</span> <span class="string">&#x27;parse count (hard)&#x27;</span>; </span><br><span class="line"></span><br><span class="line"><span class="keyword">select</span> a.value,b.name <span class="keyword">from</span> v$mystat a, v$statname b </span><br><span class="line"><span class="keyword">where</span> a.STATISTIC#<span class="operator">=</span>b.STATISTIC# <span class="keyword">and</span> b.name <span class="keyword">like</span> <span class="string">&#x27;%parse%&#x27;</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">-- 查看指定SQL内容的执行信息，如解析次数，加载次数，执行次数等</span></span><br><span class="line"><span class="keyword">select</span> sql_text,s.parse_calls,loads,executions,FORCE_MATCHING_SIGNATURE </span><br><span class="line"><span class="keyword">from</span> v$<span class="keyword">sql</span> s <span class="keyword">where</span> sql_text <span class="keyword">like</span> <span class="string">&#x27;update XXX_table%&#x27;</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">select</span> sql_id,sql_text,executions,last_load_time <span class="keyword">from</span> v$sqlarea </span><br><span class="line"><span class="keyword">where</span> sql_text <span class="keyword">like</span> <span class="string">&#x27;update XXX_table%&#x27;</span></span><br><span class="line"><span class="keyword">and</span> last_load_time <span class="operator">&gt;</span> trunc(sysdate<span class="number">-1</span><span class="operator">/</span><span class="number">24</span>) <span class="keyword">order</span> <span class="keyword">by</span> last_load_time <span class="keyword">desc</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">-- 按解析次数排序，找出解析次数较多的SQL</span></span><br><span class="line"><span class="keyword">SELECT</span> sql_id,substr(sql_text,<span class="number">1</span>,<span class="number">40</span>) <span class="keyword">sql</span>, parse_calls, executions, hash_value,address <span class="keyword">FROM</span> V$SQLAREA <span class="keyword">WHERE</span> parse_calls <span class="operator">&gt;</span> <span class="number">10</span> <span class="keyword">order</span> <span class="keyword">by</span> parse_calls <span class="keyword">desc</span>;</span><br><span class="line"><span class="comment">-- 变种1</span></span><br><span class="line"><span class="keyword">SELECT</span> sql_id,sql_text, parse_calls,loads, executions, hash_value,address <span class="keyword">FROM</span> V$SQLAREA </span><br><span class="line"><span class="keyword">WHERE</span> parse_calls <span class="operator">&gt;</span> <span class="number">100</span></span><br><span class="line"><span class="keyword">and</span> kept_versions <span class="operator">=</span> <span class="number">0</span></span><br><span class="line"><span class="keyword">and</span> executions <span class="operator">&lt;</span> <span class="number">2</span><span class="operator">*</span>parse_calls</span><br><span class="line"><span class="keyword">order</span> <span class="keyword">by</span> parse_calls <span class="keyword">desc</span>;</span><br><span class="line"><span class="comment">-- 变种2</span></span><br><span class="line"><span class="keyword">SELECT</span> sql_id,sql_text, parse_calls,loads, executions, hash_value,address <span class="keyword">FROM</span> V$SQLAREA </span><br><span class="line"><span class="keyword">WHERE</span> executions <span class="operator">&gt;</span> <span class="number">10000</span></span><br><span class="line"><span class="keyword">order</span> <span class="keyword">by</span> executions <span class="keyword">desc</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">-- 查找指定的SQL内容，Oracle根据hash_value来查找SQL，所以不同hash值会解析多次</span></span><br><span class="line"><span class="keyword">SELECT</span> sql_id,sql_text, parse_calls,loads, executions, hash_value,address </span><br><span class="line"><span class="keyword">FROM</span> V$SQLAREA </span><br><span class="line"><span class="keyword">WHERE</span> sql_text <span class="keyword">like</span> <span class="string">&#x27;%SELECT xxx FROM xxx%&#x27;</span></span><br></pre></td></tr></table></figure><p>硬解析的SQL会在 <code>v$sql_shared_cursor</code> 返回字段为Y：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">from</span> v$<span class="keyword">sql</span> t <span class="keyword">where</span> t.SQL_ID <span class="operator">=</span> <span class="string">&#x27;5auzajv4fy8gm&#x27;</span>;</span><br><span class="line"><span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> v$sqlarea t <span class="keyword">where</span> t.SQL_ID <span class="operator">=</span> <span class="string">&#x27;5auzajv4fy8gm&#x27;</span>;</span><br><span class="line"><span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> v$sql_shared_cursor <span class="keyword">where</span> SQL_ID <span class="operator">=</span> <span class="string">&#x27;5auzajv4fy8gm&#x27;</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">-- 分组汇总硬解析次数最多的SQL内容</span></span><br><span class="line"><span class="keyword">SELECT</span> substr (sql_text,<span class="number">0</span>, <span class="number">40</span>), <span class="built_in">COUNT</span>(<span class="operator">*</span>) <span class="keyword">FROM</span> v$sql_shared_cursor c, v$<span class="keyword">sql</span> s</span><br><span class="line"><span class="keyword">where</span> c.sql_id <span class="operator">=</span> s.sql_id </span><br><span class="line">  <span class="keyword">and</span> (UNBOUND_CURSOR <span class="operator">=</span> <span class="string">&#x27;Y&#x27;</span><span class="keyword">OR</span> </span><br><span class="line">     SQL_TYPE_MISMATCH <span class="operator">=</span> <span class="string">&#x27;Y&#x27;</span><span class="keyword">OR</span> </span><br><span class="line"> OPTIMIZER_MISMATCH <span class="operator">=</span> <span class="string">&#x27;Y&#x27;</span><span class="keyword">OR</span> </span><br><span class="line"> OUTLINE_MISMATCH <span class="operator">=</span> <span class="string">&#x27;Y&#x27;</span><span class="keyword">OR</span> </span><br><span class="line"> STATS_ROW_MISMATCH <span class="operator">=</span> <span class="string">&#x27;Y&#x27;</span><span class="keyword">OR</span> </span><br><span class="line"> LITERAL_MISMATCH <span class="operator">=</span> <span class="string">&#x27;Y&#x27;</span><span class="keyword">OR</span> </span><br><span class="line"> FORCE_HARD_PARSE <span class="operator">=</span> <span class="string">&#x27;Y&#x27;</span><span class="keyword">OR</span> </span><br><span class="line"> EXPLAIN_PLAN_CURSOR <span class="operator">=</span> <span class="string">&#x27;Y&#x27;</span><span class="keyword">OR</span> </span><br><span class="line"> BUFFERED_DML_MISMATCH <span class="operator">=</span> <span class="string">&#x27;Y&#x27;</span><span class="keyword">OR</span></span><br><span class="line"> PDML_ENV_MISMATCH <span class="operator">=</span> <span class="string">&#x27;Y&#x27;</span><span class="keyword">OR</span></span><br><span class="line"> INST_DRTLD_MISMATCH <span class="operator">=</span> <span class="string">&#x27;Y&#x27;</span><span class="keyword">OR</span></span><br><span class="line"> SLAVE_QC_MISMATCH <span class="operator">=</span> <span class="string">&#x27;Y&#x27;</span><span class="keyword">OR</span></span><br><span class="line"> TYPECHECK_MISMATCH <span class="operator">=</span> <span class="string">&#x27;Y&#x27;</span><span class="keyword">OR</span></span><br><span class="line"> AUTH_CHECK_MISMATCH <span class="operator">=</span> <span class="string">&#x27;Y&#x27;</span><span class="keyword">OR</span></span><br><span class="line"> BIND_MISMATCH <span class="operator">=</span> <span class="string">&#x27;Y&#x27;</span><span class="keyword">OR</span></span><br><span class="line"> DESCRIBE_MISMATCH <span class="operator">=</span> <span class="string">&#x27;Y&#x27;</span><span class="keyword">OR</span></span><br><span class="line"> LANGUAGE_MISMATCH <span class="operator">=</span> <span class="string">&#x27;Y&#x27;</span><span class="keyword">OR</span></span><br><span class="line"> TRANSLATION_MISMATCH <span class="operator">=</span> <span class="string">&#x27;Y&#x27;</span><span class="keyword">OR</span></span><br><span class="line"> BIND_EQUIV_FAILURE <span class="operator">=</span> <span class="string">&#x27;Y&#x27;</span><span class="keyword">OR</span></span><br><span class="line"> INSUFF_PRIVS <span class="operator">=</span> <span class="string">&#x27;Y&#x27;</span><span class="keyword">OR</span></span><br><span class="line"> INSUFF_PRIVS_REM <span class="operator">=</span> <span class="string">&#x27;Y&#x27;</span><span class="keyword">OR</span></span><br><span class="line"> REMOTE_TRANS_MISMATCH <span class="operator">=</span> <span class="string">&#x27;Y&#x27;</span><span class="keyword">OR</span></span><br><span class="line"> LOGMINER_SESSION_MISMATCH <span class="operator">=</span> <span class="string">&#x27;Y&#x27;</span><span class="keyword">OR</span></span><br><span class="line"> INCOMP_LTRL_MISMATCH <span class="operator">=</span> <span class="string">&#x27;Y&#x27;</span><span class="keyword">OR</span></span><br><span class="line"> OVERLAP_TIME_MISMATCH <span class="operator">=</span> <span class="string">&#x27;Y&#x27;</span><span class="keyword">OR</span></span><br><span class="line"> EDITION_MISMATCH <span class="operator">=</span> <span class="string">&#x27;Y&#x27;</span><span class="keyword">OR</span></span><br><span class="line"> MV_QUERY_GEN_MISMATCH <span class="operator">=</span> <span class="string">&#x27;Y&#x27;</span><span class="keyword">OR</span></span><br><span class="line"> USER_BIND_PEEK_MISMATCH <span class="operator">=</span> <span class="string">&#x27;Y&#x27;</span><span class="keyword">OR</span></span><br><span class="line"> TYPCHK_DEP_MISMATCH <span class="operator">=</span> <span class="string">&#x27;Y&#x27;</span><span class="keyword">OR</span></span><br><span class="line"> NO_TRIGGER_MISMATCH <span class="operator">=</span> <span class="string">&#x27;Y&#x27;</span><span class="keyword">OR</span></span><br><span class="line"> FLASHBACK_CURSOR <span class="operator">=</span> <span class="string">&#x27;Y&#x27;</span><span class="keyword">OR</span></span><br><span class="line"> ANYDATA_TRANSFORMATION <span class="operator">=</span> <span class="string">&#x27;Y&#x27;</span><span class="keyword">OR</span></span><br><span class="line"> PDDL_ENV_MISMATCH <span class="operator">=</span> <span class="string">&#x27;Y&#x27;</span><span class="keyword">OR</span></span><br><span class="line"> TOP_LEVEL_RPI_CURSOR <span class="operator">=</span> <span class="string">&#x27;Y&#x27;</span><span class="keyword">OR</span></span><br><span class="line"> DIFFERENT_LONG_LENGTH <span class="operator">=</span> <span class="string">&#x27;Y&#x27;</span><span class="keyword">OR</span></span><br><span class="line"> LOGICAL_STANDBY_APPLY <span class="operator">=</span> <span class="string">&#x27;Y&#x27;</span><span class="keyword">OR</span></span><br><span class="line"> DIFF_CALL_DURN <span class="operator">=</span> <span class="string">&#x27;Y&#x27;</span><span class="keyword">OR</span></span><br><span class="line"> BIND_UACS_DIFF <span class="operator">=</span> <span class="string">&#x27;Y&#x27;</span><span class="keyword">OR</span></span><br><span class="line"> PLSQL_CMP_SWITCHS_DIFF <span class="operator">=</span> <span class="string">&#x27;Y&#x27;</span><span class="keyword">OR</span></span><br><span class="line"> CURSOR_PARTS_MISMATCH <span class="operator">=</span> <span class="string">&#x27;Y&#x27;</span><span class="keyword">OR</span></span><br><span class="line"> STB_OBJECT_MISMATCH <span class="operator">=</span> <span class="string">&#x27;Y&#x27;</span><span class="keyword">OR</span></span><br><span class="line"> CROSSEDITION_TRIGGER_MISMATCH <span class="operator">=</span> <span class="string">&#x27;Y&#x27;</span><span class="keyword">OR</span></span><br><span class="line"> PQ_SLAVE_MISMATCH <span class="operator">=</span> <span class="string">&#x27;Y&#x27;</span><span class="keyword">OR</span></span><br><span class="line"> TOP_LEVEL_DDL_MISMATCH <span class="operator">=</span> <span class="string">&#x27;Y&#x27;</span><span class="keyword">OR</span></span><br><span class="line"> MULTI_PX_MISMATCH <span class="operator">=</span> <span class="string">&#x27;Y&#x27;</span><span class="keyword">OR</span></span><br><span class="line"> BIND_PEEKED_PQ_MISMATCH <span class="operator">=</span> <span class="string">&#x27;Y&#x27;</span><span class="keyword">OR</span></span><br><span class="line"> MV_REWRITE_MISMATCH <span class="operator">=</span> <span class="string">&#x27;Y&#x27;</span><span class="keyword">OR</span></span><br><span class="line"> ROLL_INVALID_MISMATCH <span class="operator">=</span> <span class="string">&#x27;Y&#x27;</span><span class="keyword">OR</span></span><br><span class="line"> OPTIMIZER_MODE_MISMATCH <span class="operator">=</span> <span class="string">&#x27;Y&#x27;</span><span class="keyword">OR</span></span><br><span class="line"> PX_MISMATCH <span class="operator">=</span> <span class="string">&#x27;Y&#x27;</span><span class="keyword">OR</span></span><br><span class="line"> MV_STALEOBJ_MISMATCH <span class="operator">=</span> <span class="string">&#x27;Y&#x27;</span><span class="keyword">OR</span></span><br><span class="line"> FLASHBACK_TABLE_MISMATCH <span class="operator">=</span> <span class="string">&#x27;Y&#x27;</span><span class="keyword">OR</span></span><br><span class="line"> LITREP_COMP_MISMATCH <span class="operator">=</span> <span class="string">&#x27;Y&#x27;</span><span class="keyword">OR</span></span><br><span class="line"> PLSQL_DEBUG <span class="operator">=</span> <span class="string">&#x27;Y&#x27;</span><span class="keyword">OR</span></span><br><span class="line"> LOAD_OPTIMIZER_STATS <span class="operator">=</span> <span class="string">&#x27;Y&#x27;</span><span class="keyword">OR</span></span><br><span class="line"> ACL_MISMATCH <span class="operator">=</span> <span class="string">&#x27;Y&#x27;</span><span class="keyword">OR</span></span><br><span class="line"> FLASHBACK_ARCHIVE_MISMATCH <span class="operator">=</span> <span class="string">&#x27;Y&#x27;</span><span class="keyword">OR</span></span><br><span class="line"> LOCK_USER_SCHEMA_FAILED <span class="operator">=</span> <span class="string">&#x27;Y&#x27;</span><span class="keyword">OR</span></span><br><span class="line"> REMOTE_MAPPING_MISMATCH <span class="operator">=</span> <span class="string">&#x27;Y&#x27;</span><span class="keyword">OR</span></span><br><span class="line"> LOAD_RUNTIME_HEAP_FAILED <span class="operator">=</span> <span class="string">&#x27;Y&#x27;</span><span class="keyword">OR</span></span><br><span class="line"> HASH_MATCH_FAILED <span class="operator">=</span> <span class="string">&#x27;Y&#x27;</span><span class="keyword">OR</span></span><br><span class="line"> PURGED_CURSOR <span class="operator">=</span> <span class="string">&#x27;Y&#x27;</span><span class="keyword">OR</span></span><br><span class="line"> BIND_LENGTH_UPGRADEABLE <span class="operator">=</span> <span class="string">&#x27;Y&#x27;</span><span class="keyword">OR</span></span><br><span class="line"> USE_FEEDBACK_STATS <span class="operator">=</span> <span class="string">&#x27;Y&#x27;</span>)</span><br><span class="line"> <span class="keyword">group</span> <span class="keyword">by</span> substr (sql_text,<span class="number">0</span>, <span class="number">40</span>)</span><br><span class="line"> <span class="keyword">order</span> <span class="keyword">by</span> <span class="built_in">count</span> (<span class="operator">*</span>) <span class="keyword">desc</span>;</span><br></pre></td></tr></table></figure><h3 id="2-2-Latch和Mutex"><a href="#2-2-Latch和Mutex" class="headerlink" title="2.2 Latch和Mutex"></a>2.2 Latch和Mutex</h3><h4 id="（1）Latch"><a href="#（1）Latch" class="headerlink" title="（1）Latch"></a>（1）Latch</h4><p>未完待续……</p><h4 id="（2）Mutex"><a href="#（2）Mutex" class="headerlink" title="（2）Mutex"></a>（2）Mutex</h4><h3 id="2-3-PGA"><a href="#2-3-PGA" class="headerlink" title="2.3 PGA"></a>2.3 PGA</h3><p>Program Global Area 程序全局区，对当前运行程序可见的内存。主要由排序工作区和临时结果集组成，产生场景：</p><ul><li>临时结果集作为SQL操作（表关联或子查询）中间步骤创建。</li><li>在SORT-MERGE、ORDER BY或GROUP BY操作中需要使用内存来对数据进行排序。</li><li>为了进行散列联结等操作，使用内存来创建散列结构。为联结中的一个表创建一个临时的散列表。部分如GROUP BY操作也可能使用散列区域。</li></ul><p>如果临时数据过大无法放入PGA，会被写入临时表空间的临时段中。</p><h2 id="三-AWR解析"><a href="#三-AWR解析" class="headerlink" title="三. AWR解析"></a>三. AWR解析</h2><h3 id="3-1-数据库信息"><a href="#3-1-数据库信息" class="headerlink" title="3.1 数据库信息"></a>3.1 数据库信息</h3><p><img src="https://pic-1258215793.cos.ap-shanghai.myqcloud.com/content/20211201/202112010101.png"></p><ul><li>数据库的版本</li><li>数据库 DBID</li><li>数据库实例名称及实例号</li><li>数据库最近一次启动时间</li><li>数据库版本</li><li>数据库是否为rac</li></ul><h3 id="3-2-服务器信息"><a href="#3-2-服务器信息" class="headerlink" title="3.2 服务器信息"></a>3.2 服务器信息</h3><p><img src="https://pic-1258215793.cos.ap-shanghai.myqcloud.com/content/20211201/202112010102.png"></p><ul><li>数据库主机名</li><li>数据库主机平台</li><li>服务器CPU及核数</li><li>服务器CPU个数</li><li>服务器内存大小</li></ul><h3 id="3-3-SnapShot信息"><a href="#3-3-SnapShot信息" class="headerlink" title="3.3 SnapShot信息"></a>3.3 SnapShot信息</h3><p><img src="https://pic-1258215793.cos.ap-shanghai.myqcloud.com/content/20211201/202112010103.png"></p><ul><li>awr报告的起止时间以及当时的session数量等</li><li>awr报告持续时间</li><li>DB 时间</li></ul><p>DB Time= session time spent in database.</p><p>DB Time= CPU Time + Non IDLE wait time.</p><p>可以看到DB Time比 Elapsed大，如果大很多并且有性能问题，需再进一步分析</p><h3 id="3-4-Shared-Pool-Statistics"><a href="#3-4-Shared-Pool-Statistics" class="headerlink" title="3.4 Shared Pool Statistics"></a>3.4 Shared Pool Statistics</h3><p><img src="https://pic-1258215793.cos.ap-shanghai.myqcloud.com/content/20211201/202112010104.png"></p><p>% SQL with executions&gt;1指的是执行次数大于1的SQL比例，越大越好，如过小则可能是为使用绑定变量导致</p><ul><li><p><code>Memory Usage %</code> ：</p><ul><li><p>该指标指的是Oracle数据库Shared Pool的使用率，适用于OLTP系统。</p></li><li><p>该指标一般要求在70%-85%之间。</p></li><li><p>过高说明Shared Pool 剩余空间不足，我们需要查找具体原因或者增加其空间。</p></li><li><p>过低说明Shared Pool 剩余空间过多，造成内存的浪费需要减少Shared Pool 的大小。</p></li></ul></li><li><p><code>% SQL with executions&gt;1</code> :</p><ul><li>该指标指的是Shared Pool 中的SQL语句执行次数大于1的比例，适用于OLTP系统。</li><li>该指标越高越好，如过低说明SQL 未被复用，请检查绑定变量的问题。</li><li>该指标可和上节Instance Efficiency Percentages 部分中的Parse相关指标作对比。</li></ul></li><li><p><code>% Memory for SQL w/exec&gt;1</code> ：</p><ul><li>该指标指的是执行次数大于1的SQL语句占用的Shared Pool内存比例。</li><li>该指标越低说明Shared Pool内存更多的被用在存储不能复用的语句上。从侧面反映出硬解析比较严重。</li></ul></li></ul><h3 id="3-5-Load-Profile"><a href="#3-5-Load-Profile" class="headerlink" title="3.5 Load Profile"></a>3.5 Load Profile</h3><p>了解系统负载的情况：</p><p><img src="https://pic-1258215793.cos.ap-shanghai.myqcloud.com/content/20211201/202112010105.png"></p><ul><li><strong>DB CPU(s) per second</strong>：说明的是每秒钟同时工作的CPU数量，从主机配置可以看到共24个虚拟cpu，而DB CPU(s) per second只有0.2则说明cpu没有瓶颈</li></ul><p>其次关注hard parses和 parses的比例，如硬解析率非常高则需要查看cursor_sharing参数和应用程序的绑定变量问题，一般都是由于绑定变量引起的。</p><h3 id="3-6-Instance-Efficiency-Percentages"><a href="#3-6-Instance-Efficiency-Percentages" class="headerlink" title="3.6 Instance Efficiency Percentages"></a>3.6 Instance Efficiency Percentages</h3><p><img src="https://pic-1258215793.cos.ap-shanghai.myqcloud.com/content/20211201/202112010106.png"></p><p>上面的百分比越高越好，<code>% Non-Parse CPU</code> 指的是数据的CPU资源有78.03%用在非解析上，不算高。理论上说上述比例应接近100%。</p><h4 id="3-6-1-Buffer-Nowait"><a href="#3-6-1-Buffer-Nowait" class="headerlink" title="3.6.1 Buffer Nowait %"></a>3.6.1 Buffer Nowait %</h4><p>该指标指的是可立即访问SGA 中所有数据而不用等待的次数的比例，该指标应接近100%</p><p>如发现该指标过低,则检查awr报告中 <strong>Buffer Wait Statistics</strong> 部分来查看哪种类型的块导致等待。</p><p><img src="https://pic-1258215793.cos.ap-shanghai.myqcloud.com/content/20211201/202112010113.png"></p><h4 id="3-6-2-Redo-NoWait"><a href="#3-6-2-Redo-NoWait" class="headerlink" title="3.6.2 Redo NoWait %"></a>3.6.2 Redo NoWait %</h4><p>该指标指的是redo条目（redo-entries）在redo log中可立即生成而不用等待的次数与全部redo entries的比例。redo entry对应的是每一个DML语句。</p><p>计算公式：<code>100 x (1- (redo log space requests/redo entries)</code> </p><ul><li><strong>redo log space requests</strong> 该请求会在数据库进程请求生成redo entry，而这时redo log空间满的情况下发生，这时数据库会被动的进行日志切换以使事务可以继续进行。</li><li><strong>redo entries</strong> 会在每次redo entry 写入 redo log时增加</li></ul><p>上述2个值可通过视图 <code>v$sysstat</code> 查看，<strong>注意它们的值是累积的</strong>。一般来说我们需要保持redo log space requests的值不增长。</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> v$sysstat <span class="keyword">where</span> name <span class="keyword">in</span> (<span class="string">&#x27;redo log space requests&#x27;</span>, <span class="string">&#x27;redo entries&#x27;</span>);</span><br></pre></td></tr></table></figure><p>如果该参数过低:</p><ol><li>如redo log切换十分频繁(约15分钟切换一次)，则需要增加online redo log大小。</li><li>如果redo log切换不频繁，则说明可能是磁盘IO性能太慢，需将online redo log放置到高性能磁盘中。</li></ol><h4 id="3-6-3-Buffer-Hit"><a href="#3-6-3-Buffer-Hit" class="headerlink" title="3.6.3 Buffer Hit %"></a>3.6.3 Buffer Hit %</h4><p>该指标指的是数据库请求的数据在buffer cache中直接命中的比例。该指标越高代表oracle在buffer cache直接找到需要的数据越多，从而不需要从磁盘进行读取。buffer cache（内存）中读取的速率是从磁盘读取速率的成百上千倍。</p><p>该参数在OLAP和DSS系统中不太重要，因为他们有大量的全表扫描或者并行操作。并行操作有时会跳过buffer cache 而使用PGA。该参数对于OLTP系统非常重要，需要保持在90%以上，因为其有大量连续的操作，从磁盘读取将大大影响系统性能。</p><p>如该指标过低可使用 <strong>data buffer cache advisory</strong> 查看合适建议并修改 <strong>db_cache_size</strong> 参数大小。</p><h4 id="3-6-4-In-memory-Sort"><a href="#3-6-4-In-memory-Sort" class="headerlink" title="3.6.4 In-memory Sort %"></a>3.6.4 In-memory Sort %</h4><p>该参数反应了内存内排序和磁盘排序之间的比例，计算公式为 ：<code>(DeltaMemorySorts / (DeltaDiskSorts + DeltaMemorySorts)) * 100</code> 。disk sort的在temp表空间中进行，他的速度比内存排序慢成百上千倍。</p><p>该查询的值为累计值，计算时应取观察时间段的差值（从instance启动开始）。</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> v$sysstat <span class="keyword">where</span> name <span class="keyword">in</span> (<span class="string">&#x27;sorts (memory)&#x27;</span>, <span class="string">&#x27;sorts (disk)&#x27;</span>);</span><br></pre></td></tr></table></figure><p>存储区域：</p><ul><li>专用服务器( dedicated )类型中，排序区域分配在PGA中。</li><li>共享服务器(shared)类型中，排序区域在 large pool 中，由于是共用的无法手动指定各个session使用的大小。</li></ul><p>如该指标过低，需增加sort area 的大小。in-memory sorts的大小被sort_area_size或者pga_aggregate_target控制。</p><h4 id="3-6-5-Library-Hit"><a href="#3-6-5-Library-Hit" class="headerlink" title="3.6.5 Library Hit %"></a>3.6.5 Library Hit %</h4><p>library cache hit ratio，指的是将要执行的SQL 语句或者PL/SQL 代码已经存在于shared pool中的library cache中并可复用。</p><p><img src="https://pic-1258215793.cos.ap-shanghai.myqcloud.com/content/20211201/202112010114.png"></p><p>查看：</p><ul><li><p><strong>监控库缓冲命中率及重载率(9i及以上)：</strong></p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> <span class="built_in">sum</span> (pins) &quot;Eexcutions&quot;,</span><br><span class="line">       <span class="built_in">sum</span>(pinhits) &quot;Hits&quot;,</span><br><span class="line">       round((( <span class="built_in">sum</span> (pinhits) <span class="operator">/</span> <span class="built_in">sum</span> (pins)) <span class="operator">*</span> <span class="number">100</span>),<span class="number">2</span> ) &quot;PinHitRatio&quot;,</span><br><span class="line">       <span class="built_in">sum</span>(reloads) &quot;Misses&quot;,</span><br><span class="line">     round((( <span class="built_in">sum</span> (pins) <span class="operator">/</span> (<span class="built_in">sum</span> (pins) <span class="operator">+</span> <span class="built_in">sum</span>(reloads))) <span class="operator">*</span> <span class="number">100</span> ),<span class="number">2</span>) &quot;RelodHitRatio&quot;</span><br><span class="line">  <span class="keyword">from</span> v$librarycache;</span><br></pre></td></tr></table></figure></li><li><p><strong>查看库缓冲命中率(10g及以上)：</strong></p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> v$sysmetric <span class="keyword">where</span> metric_name <span class="operator">=</span> <span class="string">&#x27;Library Cache Hit Ratio&#x27;</span>;</span><br></pre></td></tr></table></figure></li></ul><p>如果该指标过低说明SQL过早的被挤出shared pool，可能是由于shared pool过小导致。需要和软解析(soft parse)率进行比较，如过两者都低，需检查解析问题，如绑定变量是否使用。</p><h4 id="3-6-6-Soft-Parse"><a href="#3-6-6-Soft-Parse" class="headerlink" title="3.6.6 Soft Parse %"></a>3.6.6 Soft Parse %</h4><p>软解析指的是需要执行的SQL语句或PL/SQL程序可以在library cache中找到并重复使用。计算公式为：<code>((DeltaParseCountTotal - DeltaParseCountHard) / DeltaParseCountTotal) * 100</code> </p><p>可以通过 <code>v$sysstat</code> 查看到，注意该参数是累积的，计算时需计算时间段的差值：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> v$sysstat <span class="keyword">where</span> name <span class="keyword">in</span> (<span class="string">&#x27;parse count (hard)&#x27;</span>, <span class="string">&#x27;parse count (total)&#x27;</span>);</span><br></pre></td></tr></table></figure><p>如该指标过低(80%),需检查是否有绑定变量问题，并查看parse 的TOP SQL：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> v$sysmetric <span class="keyword">where</span> metric_name <span class="operator">=</span> <span class="string">&#x27;Library Cache Hit Ratio&#x27;</span>;</span><br></pre></td></tr></table></figure><p>如果该指标很高，也不代表不能优化，也需要查看排在前列的语句是否需要优化</p><h4 id="3-6-7-Execute-to-Parse"><a href="#3-6-7-Execute-to-Parse" class="headerlink" title="3.6.7 Execute to Parse %"></a>3.6.7 Execute to Parse %</h4><p>该指标是SQL执行次数和解析次数的比值，计算公式为：<code>round(100*(1-parse/exe),2)</code> 。</p><p>从公式可以看出:</p><ul><li>当parse和execute相差不大时，比值趋近于0，说明每次执行都会进行解析</li><li>当parse远小于execute使，比值接近1，说明解析一次可以执行多次，这是非常好的</li></ul><p>可以通过 <code>v$sysstat</code> 查看到，注意该参数是累积的，计算时需时时间段的差值：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> v$sysstat <span class="keyword">where</span> name <span class="keyword">in</span> (<span class="string">&#x27;parse count (total)&#x27;</span>, <span class="string">&#x27;execute count&#x27;</span>);</span><br></pre></td></tr></table></figure><p>有人会建议设置cursor sharing = similar，会针对相似语句使用软解析，但这样是不可取的，可能会导致性能问题。</p><p>若该指标过低，往往是开发人员的程序造成的，如未使用绑定变量。可参考 <a href="https://asktom.oracle.com/pls/asktom/f?p=100:11:0::::P11_QUESTION_ID:1594740500346667363">官方</a> ：</p><ul><li>You should do it in a single SQL statement if at all possible.</li><li>If you cannot do it in a single SQL Statement, then do it in PL/SQL.</li><li>If you cannot do it in PL/SQL, try a Java Stored Procedure.</li><li>If you cannot do it in Java, do it in a C external procedure.</li><li>If you cannot do it in a C external routine, you might want to seriously think about why it is you need to do it…</li></ul><h4 id="3-6-8-Latch-Hit"><a href="#3-6-8-Latch-Hit" class="headerlink" title="3.6.8 Latch Hit %"></a>3.6.8 Latch Hit %</h4><p>该指标指的是latch不需要等待即可获取的比例。计算公式为：<code>SELECT (1 - (Sum(misses) / Sum(gets))) * 100 FROM v$latch;</code> 。</p><p>可以从 <code>v$latch</code> 视图获取相关信息：</p><ul><li>GETS:以 willing-to-wait 模式请求latch的次数</li><li>MISSES:以 willing-to-wait 模式请求latch但是需要等待的次数</li><li>SLEEPS:以 willing-to-wait 模式请求latch需要等待并且超时的次数</li><li>IMMEDIATE_GETS:以no-wait模式请求latch的次数</li><li>IMMEDIATE_MISSES:以no-wait模式请求latch且失败(miss)的次数</li><li>SPIN_GETS:以willing-to-wait模式请求latch需要等待，但是在spin中获得的次数</li></ul><p>latch是Oracle的一种轻量级的锁，用于保护共享内存，如确保一个数据块同一时间只能被一个session访问等等</p><ul><li>Cache Buffer Chains</li><li>Redo Copy Latch</li><li>…..</li></ul><p>latch获取有2种方式</p><ol><li><p>willing-to-wait：大部分latch采用如下模式，若第一次未取得latch时采用等待的方法。</p><p><img src="https://pic-1258215793.cos.ap-shanghai.myqcloud.com/content/20211201/202112010115.png"></p></li><li><p>no-wait：少部分latch采用这种模式，当第一次获取不到该latch时就不进行等待，直接进入sleep状态。</p></li></ol><p>如此指标低于90%则说明latch等待严重，可查看awr报告的等待事件部分。</p><p><img src="https://pic-1258215793.cos.ap-shanghai.myqcloud.com/content/20211201/202112010116.png"></p><p>如上图表明library cache存在冲突。</p><h4 id="3-6-9-Parse-CPU-to-Parse-Elapsd"><a href="#3-6-9-Parse-CPU-to-Parse-Elapsd" class="headerlink" title="3.6.9 Parse CPU to Parse Elapsd %"></a>3.6.9 Parse CPU to Parse Elapsd %</h4><p>该指标指的是解析过程中CPU时间占的比重。由于解析需要CPU进行操作，如在解析过程中有什么东西阻止进程访问CPU，则会导致该比例过小。如该比例为100%说明解析过程中没有等待。该指标的计算公式为：<code>(parse time cpu/parse time elapsed)*100</code> </p><p>数值可从 <code>v$sysstat</code> 视图获取，注意该参数是累积的，计算时需时时间段的差值：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> v$sysstat <span class="keyword">where</span> name <span class="keyword">in</span> (<span class="string">&#x27;parse time cpu&#x27;</span>, <span class="string">&#x27;parse time elapsed&#x27;</span>);</span><br></pre></td></tr></table></figure><p>如此指标过低说明可能为shared pool 存在冲突，可能为shared pool过小或未使用绑定变量所致。</p><h4 id="3-6-10-Non-Parse-CPU"><a href="#3-6-10-Non-Parse-CPU" class="headerlink" title="3.6.10 % Non-Parse CPU"></a>3.6.10 % Non-Parse CPU</h4><p>该参数的意义就像是字面上的，表明的是用在非解析上面的CPU时间。该指标的计算公式为：<code>(parse time cpu/CPU used by this session)*100</code> 。</p><p>数值可从 <code>v$sysstat</code> 视图获取，注意该参数是累积的，计算时需时时间段的差值：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> v$sysstat <span class="keyword">where</span> name <span class="keyword">in</span> (<span class="string">&#x27;parse time cpu&#x27;</span>, <span class="string">&#x27;CPU used by this session&#x27;</span>);</span><br></pre></td></tr></table></figure><p>如此指标过低(95%)说明CPU时间用在解析上的时间过多，一般是由于SQL未复用导致，也就是未使用绑定变量。</p><h3 id="3-7-Top-10-Foreground-Events-by-Total-Wait-Time"><a href="#3-7-Top-10-Foreground-Events-by-Total-Wait-Time" class="headerlink" title="3.7 Top 10 Foreground Events by Total Wait Time"></a>3.7 Top 10 Foreground Events by Total Wait Time</h3><p>这里是排名前十的前台等待事件：</p><p><img src="https://pic-1258215793.cos.ap-shanghai.myqcloud.com/content/20211201/202112010107.png"></p><ol><li>首先看wait class栏位，如果是 User I/O , System I/O, Others这种的可以不用太担心，如发现Concurrency这类等待需要特别关心</li><li>其次看等待时间，wait avg=total wait time(总等待时间)/waits(等待次数),最主要看平均等待时间是否正常</li></ol><h4 id="3-7-1-db-file-sequential-read"><a href="#3-7-1-db-file-sequential-read" class="headerlink" title="3.7.1 db file sequential read"></a>3.7.1 db file sequential read</h4><ul><li><strong>物理读</strong>发生在一个用户需要的数据块不在SGA，从而将其从磁盘读取到SGA中。如果此时别的会话需要该数据块则必须等待这个过程结束，这时就产生了等待。</li><li><strong>顺序读</strong>是物理读的一种方式，这里的顺序指的是读取数据块到一个连续的内存区域，而且总是读取单个数据块(single-block read)。</li></ul><p>如果该等待严重说明数据块存在严重的争用情况。</p><p>单个数据块读（single-block read）是由SQL语句引起的，用户发出或者递归调用，一般发生在以下情况：</p><ul><li>索引扫描</li><li>表扫描（access by rowid）</li><li>全表扫描（很少发生，例如刚好在extent边缘恰巧被分割成单块，或者已经在buffer cache中）</li></ul><p>由于物理读是非常正常的，出现这个等待事件不意味着数据库出现性能问题。但是如果在AWR报告等待事件相关中看到其处于非常前的位置时就需要引起我们的注意了。</p><p>特别需要关注Avg Waits 参数，最好小于10ms，这里可采用如下方法进行解决：</p><ul><li>将数据文件放在高速磁盘中，提高读取性能，避免热块。</li><li>将数据文件放在LUN（即一些存储设备）中，可确保数据块分散在足够多的磁盘中。</li></ul><p>在优化磁盘的同时，我们还需要注意应用程序的SQL语句问题，因为一般这种等待都是由SQL语句造成的，我们需要找出找出相应的SQL语句。可能是索引使用不当导致，这时我们可以定位到具体的表或索引，通过执行计划判断索引是否合理，是否需要走全表扫描等等方式来进行优化。</p><p>如下是一些常用的诊断方式，通过如下方式定位到具体的会话，在通过sql_id或hash_value找出具体的语句用于优化：</p><ol><li><p>查看当前正在等待的会话：</p><p>我们可以查看 <code>v$session_wait</code> 视图的TIME_WAITED栏位来定位当前哪个会话等待sequential read过长时间（实时）。</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> v$session_Wait <span class="keyword">where</span> event <span class="operator">=</span> <span class="string">&#x27;db file sequential read&#x27;</span></span><br></pre></td></tr></table></figure><ul><li>P1代表File ID，可通过dba_data_File视图的FILE_ID字段看出是哪个数据文件。</li><li>P2代表 First block，即该块在数据文件上开始的位置。</li><li>P3代表块数，由于sequential read为单块读，则该值始终为1。</li></ul><p>我们可以通过P1，P2参数得出对象的名称和类型：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span></span><br><span class="line">   segment_name,</span><br><span class="line">   segment_type</span><br><span class="line"><span class="keyword">from</span> </span><br><span class="line">   dba_extents</span><br><span class="line"><span class="keyword">where</span></span><br><span class="line">   file_id <span class="operator">=</span> <span class="number">128</span> </span><br><span class="line"><span class="keyword">and</span></span><br><span class="line">   <span class="number">3277531</span> <span class="keyword">between</span> </span><br><span class="line">   (block_id <span class="keyword">and</span> block_id <span class="operator">+</span> blocks <span class="operator">-</span> <span class="number">1</span>);</span><br></pre></td></tr></table></figure></li><li><p>查看从实例启动以来等待的会话：</p><p>使用 <code>v$session_event</code> 视图来定位哪个会话等待sequential read过长时间（非实时）。也可使用 <code>v$system_event</code> 视图查看系统整体的等待事件。</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> sid, total_waits, time_waited</span><br><span class="line">  <span class="keyword">FROM</span> v$session_event</span><br><span class="line"> <span class="keyword">WHERE</span> event<span class="operator">=</span><span class="string">&#x27;db file sequential read&#x27;</span></span><br><span class="line">  <span class="keyword">and</span> total_waits<span class="operator">&gt;</span><span class="number">0</span></span><br><span class="line"> <span class="keyword">ORDER</span> <span class="keyword">BY</span> <span class="number">3</span> <span class="keyword">desc</span>,<span class="number">2</span></span><br></pre></td></tr></table></figure><p>注意由于SID是可以复用的，这样查出来的有可能有问题。比如查看SID为617的会话对应的语句也有可能是上个SQL语句导致的sequential read等待，这点需要注意。</p></li></ol><ul><li><p>查看高物理读的数据文件：可以通过awr报告中的 <code>Tablespace IO Stats</code> 和 <code>File IO Stats</code> 区域来定位最多IO操作的表空间和数据文件，如果可以请将其放置在高速的磁盘中（SSD）。</p></li><li><p>查看高物理读的SQL语句：同样可以查看v$sql中高物理读的语句以及awr报告中的 <code>SQL ordered by Reads</code> 区域</p></li></ul><h4 id="3-7-2-db-file-scattered-read"><a href="#3-7-2-db-file-scattered-read" class="headerlink" title="3.7.2 db file scattered read"></a>3.7.2 db file scattered read</h4><p>离散读是物理读的一种方式，这里的离散指的是读取数据块到一块离散(不连续)的内存区域，而且一般读取多个数据块（multi-block read），可能为单个数据库。每次读取的块数由 <code>DB_FILE_MULTIBLOCK_READ_COUNT</code> 参数控制，这点不同于sequential read。</p><p>下图为各种读取方式的比较：</p><p><img src="https://pic-1258215793.cos.ap-shanghai.myqcloud.com/content/20211201/202112010122.png"></p><p>多数据块读（multi-block read）是由SQL语句引起的，用户发出或者递归调用，一般发生在以下情况：</p><ul><li>全表扫描( full table scans )</li><li>索引快速全扫描( index fast full scans)</li></ul><p>在优化磁盘的同时，我们还需要注意应用程序的SQL语句问题，因为一般这种等待都是SQL语句造成的，我们需要找出相应的SQL语句：</p><ol><li>通过执行计划进行优化判断全表扫描或者索引全扫描是否合理，是否使用了合适的驱动表，以需要达到减少物理读和逻辑读的目的。</li><li>执行计划中 <code>HASH JOIN</code> 和 <code>SORT MERGE</code> 动作（operation）会导致scattered read。</li><li>可增加 <code>DB_FILE_MULTIBLOCK_READ_COUNT</code> 参数的值来减少IO次数。</li><li>调整 <code>HASH_AREA_SIZE</code> 和 <code>OPTIMIZER_INDEX_COST_ADJ</code> 参数的值也可用来优化scattered read。</li><li>保证统计信息的及时性。</li></ol><p>与db file sequential read的区别在event值为 <code>db file scattered read</code> 。</p><h4 id="3-7-3-log-file-sync"><a href="#3-7-3-log-file-sync" class="headerlink" title="3.7.3 log file sync"></a>3.7.3 log file sync</h4><p>当用户提交（commit）语句时，一个进程会建立一个redo记录并把它拷贝至SGA中的log buffer中，然后这个进程会通知LGWR进程再将log buffer中的内容写入日志文件（redo file）中，同时清空log buffer的内容，最后返回完成消息，这就完成了一次commit操作。</p><p><img src="https://pic-1258215793.cos.ap-shanghai.myqcloud.com/content/20211201/202112010123.png"></p><p>commit动作在LGWR进程没有返回完成消息前是不会完成的，我们把LGWR将log buffer中的内容写入日志文件（redo file）以及返回完成消息的这段时间标记为log file sync等待事件，它有个1s的超时时间。这个等待事件往往伴随着log file parallel write等待事件。</p><p>log buffer大小：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SQL</span><span class="operator">&gt;</span> <span class="keyword">show</span> <span class="keyword">parameter</span> log_buffer</span><br></pre></td></tr></table></figure><p>这里需要注意的是LGWR写log buffer内容至日志文件有多种情况：</p><ul><li>每三秒钟</li><li>每一次commit</li><li>当其1/3满的时候</li><li>当其达到1M的时候</li></ul><p>查看LGWR进程等待情况（整体）：通过上面的讲解我们知道log file sync事件和LWGR进程相关，我们可以查询</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> sid, event, time_waited, time_waited_micro</span><br><span class="line">  <span class="keyword">from</span> v$session_event</span><br><span class="line"> <span class="keyword">where</span> sid <span class="keyword">in</span> (<span class="keyword">select</span> sid <span class="keyword">from</span> v$session <span class="keyword">where</span> program <span class="keyword">like</span> <span class="string">&#x27;%LGWR%&#x27;</span>)</span><br><span class="line"> <span class="keyword">order</span> <span class="keyword">by</span> <span class="number">3</span></span><br></pre></td></tr></table></figure><p>可以看到LGWR进程主要的等待有哪些，哪些等待比较严重：</p><ol><li>rdbms ipc message表示LGWR正在等待写redo log，表示其处于空闲状体，我们不必理会。</li><li>log file single/parallel write即我们今天所说的LGWR写redo文件。</li></ol><p>查询当前LGWR进程状态（实时）：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> a.<span class="operator">*</span></span><br><span class="line">  <span class="keyword">from</span> v$Session_wait a, v$session b</span><br><span class="line"> <span class="keyword">where</span> a.sid <span class="operator">=</span> b.sid</span><br><span class="line">   <span class="keyword">and</span> b.program <span class="keyword">like</span> <span class="string">&#x27;%LGWR%&#x27;</span>;</span><br></pre></td></tr></table></figure><p>如发现为log file write等说明目前LGWR进程正在繁忙。如等待事件为log file parallel write 则其参数意义如下</p><ul><li>P1：需要写入的redo log的数量，即日志文件组的成员数量。</li><li>P2：需要写入每个redo log 成员的redo block数。</li><li>P3：写入完成需要进行的I/O请求次数。</li></ul><p>如果log file sync等待事件占有过多的CPU时间，我们就需要注意了：</p><ol><li>低速的磁盘可能会导致LGWR进程写文件较慢从而导致log file sync等待，我们可以简单的通过avg waits来判断，如超过15ms则说明磁盘可能是瓶颈，需要放到高速的磁盘，另外加日志组中成员文件放在不同的磁盘中。</li><li>服务器CPU内存资源不足会导致进程相应缓慢，同样会增加log file sync等待，所以在调优时首先保证系统资源充足。</li><li>数据库锁及latch也会影响log file sync等待。</li><li>过大的log buffer大小，log buffer过大可能导致刷新过于次数过低，从而导致单次刷新过慢。</li><li>过多的commit操作，通过上面我们知道每次commit操作都会导致LGWR写操作，如commit过多则该等待则会明显的上升。</li></ol><h4 id="3-7-4-log-file-parallel-write"><a href="#3-7-4-log-file-parallel-write" class="headerlink" title="3.7.4 log file parallel write"></a>3.7.4 log file parallel write</h4><p>为了冗余考虑，redo log组一般都会有多个成员，log file parallel write中的parallel指的是并行的写入多个redo log成员文件。log file parallel write指的是LGWR进程并行的将log buffer中的内容写入redo log，在全部写入到所有redo log前的等待计入log file parallel write 等待事件。</p><p>查看redo log文件情况：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> thread#, <span class="keyword">group</span>#, members, bytes <span class="operator">/</span> <span class="number">1024</span> <span class="operator">/</span> <span class="number">1024</span> byte_mb, status</span><br><span class="line"> <span class="keyword">FROM</span> v$log</span><br><span class="line"><span class="keyword">order</span> <span class="keyword">by</span> thread#, <span class="keyword">group</span>#;</span><br></pre></td></tr></table></figure><blockquote><p>log file sync（LFS）和log file parallel write（LFPW）对比：</p><p>通过上面的定义我们知道LFS和LFPW都是等待LGWR进程完成I/O操作。</p><ul><li>LFS是用户进程等待LGWR进程完成I/O操作。</li><li>LFPW是LGWR进程本身等待其I/O操作完成。</li></ul><p>例如有五个用户进程同时commit，每个完成耗时都是10ms。则LFS次数增加五次，LFS的wait time增加50ms。而LFPW次数增加一次，LFPW的wait time增加10ms。注意LGWR 进行写日志动作原因有很多，用户commit只是其中一个。</p><ul><li>每三秒钟</li><li>每一次commit/rollback</li><li>当其 1/3满的时候，这个由_LOG_IO_SIZE参数控制</li><li>当其达到1M的时候</li></ul></blockquote><p>减少日志组中成员的数量可减少I/O此时从而减少log file parallel write等待。</p><p>查看日志切换频率：直接将如下代码执行，PLSQL请使用command界面。</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">column</span> h0 format <span class="number">999</span></span><br><span class="line"><span class="keyword">column</span> h1 format <span class="number">999</span></span><br><span class="line"><span class="keyword">column</span> h2 format <span class="number">999</span></span><br><span class="line"><span class="keyword">column</span> h3 format <span class="number">999</span></span><br><span class="line"><span class="keyword">column</span> h4 format <span class="number">999</span></span><br><span class="line"><span class="keyword">column</span> h5 format <span class="number">999</span></span><br><span class="line"><span class="keyword">column</span> h6 format <span class="number">999</span></span><br><span class="line"><span class="keyword">column</span> h7 format <span class="number">999</span></span><br><span class="line"><span class="keyword">column</span> h8 format <span class="number">999</span></span><br><span class="line"><span class="keyword">column</span> h9 format <span class="number">999</span></span><br><span class="line"><span class="keyword">column</span> h10 format <span class="number">999</span></span><br><span class="line"><span class="keyword">column</span> h11 format <span class="number">999</span></span><br><span class="line"><span class="keyword">column</span> h12 format <span class="number">999</span></span><br><span class="line"><span class="keyword">column</span> h13 format <span class="number">999</span></span><br><span class="line"><span class="keyword">column</span> h14 format <span class="number">999</span></span><br><span class="line"><span class="keyword">column</span> h15 format <span class="number">999</span></span><br><span class="line"><span class="keyword">column</span> h16 format <span class="number">999</span></span><br><span class="line"><span class="keyword">column</span> h17 format <span class="number">999</span></span><br><span class="line"><span class="keyword">column</span> h18 format <span class="number">999</span></span><br><span class="line"><span class="keyword">column</span> h19 format <span class="number">999</span></span><br><span class="line"><span class="keyword">column</span> h20 format <span class="number">999</span></span><br><span class="line"><span class="keyword">column</span> h21 format <span class="number">999</span></span><br><span class="line"><span class="keyword">column</span> h22 format <span class="number">999</span></span><br><span class="line"><span class="keyword">column</span> h23 format <span class="number">999</span></span><br><span class="line"><span class="keyword">column</span> avg format <span class="number">999.99</span></span><br><span class="line"><span class="keyword">column</span> <span class="keyword">day</span> format a6</span><br><span class="line"></span><br><span class="line"><span class="keyword">SELECT</span> TRUNC (first_time) &quot;Date&quot;, TO_CHAR (first_time, <span class="string">&#x27;Dy&#x27;</span>) &quot;Day&quot;, <span class="built_in">COUNT</span> (<span class="number">1</span>) &quot;Total&quot;,</span><br><span class="line"><span class="built_in">SUM</span> (DECODE (TO_CHAR (first_time, <span class="string">&#x27;hh24&#x27;</span>), <span class="string">&#x27;00&#x27;</span>, <span class="number">1</span>, <span class="number">0</span>)) h0,</span><br><span class="line"><span class="built_in">SUM</span> (DECODE (TO_CHAR (first_time, <span class="string">&#x27;hh24&#x27;</span>), <span class="string">&#x27;01&#x27;</span>, <span class="number">1</span>, <span class="number">0</span>)) &quot;h1&quot;,</span><br><span class="line"><span class="built_in">SUM</span> (DECODE (TO_CHAR (first_time, <span class="string">&#x27;hh24&#x27;</span>), <span class="string">&#x27;02&#x27;</span>, <span class="number">1</span>, <span class="number">0</span>)) &quot;h2&quot;,</span><br><span class="line"><span class="built_in">SUM</span> (DECODE (TO_CHAR (first_time, <span class="string">&#x27;hh24&#x27;</span>), <span class="string">&#x27;03&#x27;</span>, <span class="number">1</span>, <span class="number">0</span>)) &quot;h3&quot;,</span><br><span class="line"><span class="built_in">SUM</span> (DECODE (TO_CHAR (first_time, <span class="string">&#x27;hh24&#x27;</span>), <span class="string">&#x27;04&#x27;</span>, <span class="number">1</span>, <span class="number">0</span>)) &quot;h4&quot;,</span><br><span class="line"><span class="built_in">SUM</span> (DECODE (TO_CHAR (first_time, <span class="string">&#x27;hh24&#x27;</span>), <span class="string">&#x27;05&#x27;</span>, <span class="number">1</span>, <span class="number">0</span>)) &quot;h5&quot;,</span><br><span class="line"><span class="built_in">SUM</span> (DECODE (TO_CHAR (first_time, <span class="string">&#x27;hh24&#x27;</span>), <span class="string">&#x27;06&#x27;</span>, <span class="number">1</span>, <span class="number">0</span>)) &quot;h6&quot;,</span><br><span class="line"><span class="built_in">SUM</span> (DECODE (TO_CHAR (first_time, <span class="string">&#x27;hh24&#x27;</span>), <span class="string">&#x27;07&#x27;</span>, <span class="number">1</span>, <span class="number">0</span>)) &quot;h7&quot;,</span><br><span class="line"><span class="built_in">SUM</span> (DECODE (TO_CHAR (first_time, <span class="string">&#x27;hh24&#x27;</span>), <span class="string">&#x27;08&#x27;</span>, <span class="number">1</span>, <span class="number">0</span>)) &quot;h8&quot;,</span><br><span class="line"><span class="built_in">SUM</span> (DECODE (TO_CHAR (first_time, <span class="string">&#x27;hh24&#x27;</span>), <span class="string">&#x27;09&#x27;</span>, <span class="number">1</span>, <span class="number">0</span>)) &quot;h9&quot;,</span><br><span class="line"><span class="built_in">SUM</span> (DECODE (TO_CHAR (first_time, <span class="string">&#x27;hh24&#x27;</span>), <span class="string">&#x27;10&#x27;</span>, <span class="number">1</span>, <span class="number">0</span>)) &quot;h10&quot;,</span><br><span class="line"><span class="built_in">SUM</span> (DECODE (TO_CHAR (first_time, <span class="string">&#x27;hh24&#x27;</span>), <span class="string">&#x27;11&#x27;</span>, <span class="number">1</span>, <span class="number">0</span>)) &quot;h11&quot;,</span><br><span class="line"><span class="built_in">SUM</span> (DECODE (TO_CHAR (first_time, <span class="string">&#x27;hh24&#x27;</span>), <span class="string">&#x27;12&#x27;</span>, <span class="number">1</span>, <span class="number">0</span>)) &quot;h12&quot;,</span><br><span class="line"><span class="built_in">SUM</span> (DECODE (TO_CHAR (first_time, <span class="string">&#x27;hh24&#x27;</span>), <span class="string">&#x27;13&#x27;</span>, <span class="number">1</span>, <span class="number">0</span>)) &quot;h13&quot;,</span><br><span class="line"><span class="built_in">SUM</span> (DECODE (TO_CHAR (first_time, <span class="string">&#x27;hh24&#x27;</span>), <span class="string">&#x27;14&#x27;</span>, <span class="number">1</span>, <span class="number">0</span>)) &quot;h14&quot;,</span><br><span class="line"><span class="built_in">SUM</span> (DECODE (TO_CHAR (first_time, <span class="string">&#x27;hh24&#x27;</span>), <span class="string">&#x27;15&#x27;</span>, <span class="number">1</span>, <span class="number">0</span>)) &quot;h15&quot;,</span><br><span class="line"><span class="built_in">SUM</span> (DECODE (TO_CHAR (first_time, <span class="string">&#x27;hh24&#x27;</span>), <span class="string">&#x27;16&#x27;</span>, <span class="number">1</span>, <span class="number">0</span>)) &quot;h16&quot;,</span><br><span class="line"><span class="built_in">SUM</span> (DECODE (TO_CHAR (first_time, <span class="string">&#x27;hh24&#x27;</span>), <span class="string">&#x27;17&#x27;</span>, <span class="number">1</span>, <span class="number">0</span>)) &quot;h17&quot;,</span><br><span class="line"><span class="built_in">SUM</span> (DECODE (TO_CHAR (first_time, <span class="string">&#x27;hh24&#x27;</span>), <span class="string">&#x27;18&#x27;</span>, <span class="number">1</span>, <span class="number">0</span>)) &quot;h18&quot;,</span><br><span class="line"><span class="built_in">SUM</span> (DECODE (TO_CHAR (first_time, <span class="string">&#x27;hh24&#x27;</span>), <span class="string">&#x27;19&#x27;</span>, <span class="number">1</span>, <span class="number">0</span>)) &quot;h19&quot;,</span><br><span class="line"><span class="built_in">SUM</span> (DECODE (TO_CHAR (first_time, <span class="string">&#x27;hh24&#x27;</span>), <span class="string">&#x27;20&#x27;</span>, <span class="number">1</span>, <span class="number">0</span>)) &quot;h20&quot;,</span><br><span class="line"><span class="built_in">SUM</span> (DECODE (TO_CHAR (first_time, <span class="string">&#x27;hh24&#x27;</span>), <span class="string">&#x27;21&#x27;</span>, <span class="number">1</span>, <span class="number">0</span>)) &quot;h21&quot;,</span><br><span class="line"><span class="built_in">SUM</span> (DECODE (TO_CHAR (first_time, <span class="string">&#x27;hh24&#x27;</span>), <span class="string">&#x27;22&#x27;</span>, <span class="number">1</span>, <span class="number">0</span>)) &quot;h22&quot;,</span><br><span class="line"><span class="built_in">SUM</span> (DECODE (TO_CHAR (first_time, <span class="string">&#x27;hh24&#x27;</span>), <span class="string">&#x27;23&#x27;</span>, <span class="number">1</span>, <span class="number">0</span>)) &quot;h23&quot;, ROUND (<span class="built_in">COUNT</span> (<span class="number">1</span>) <span class="operator">/</span> <span class="number">24</span>, <span class="number">2</span>) &quot;Avg&quot;</span><br><span class="line"><span class="keyword">FROM</span> gv$log_history</span><br><span class="line"><span class="keyword">WHERE</span> first_time <span class="operator">&gt;=</span> trunc(SYSDATE) <span class="operator">-</span> <span class="number">30</span></span><br><span class="line"><span class="keyword">and</span> thread# <span class="operator">=</span> inst_id</span><br><span class="line"><span class="keyword">GROUP</span> <span class="keyword">BY</span> TRUNC (first_time), TO_CHAR (first_time, <span class="string">&#x27;Dy&#x27;</span>)</span><br><span class="line"><span class="keyword">ORDER</span> <span class="keyword">BY</span> <span class="number">1</span> <span class="keyword">DESC</span>;</span><br></pre></td></tr></table></figure><h4 id="3-7-5-log-buffer-space"><a href="#3-7-5-log-buffer-space" class="headerlink" title="3.7.5 log buffer space"></a>3.7.5 log buffer space</h4><p>log buffer space这个等待事件一般来说很少发生，一旦等待比较严重往往说明是系统的设置问题。Oracle的一些DML操作（insert,update,insert）会产生redo条目，并存储在log buffer中，当发生以下情况时LGWR进程会把log buffer中的信息写入redo log，之后清空log buffer。当redo条目的产生速度快于LGWR清理的速度就会发生redo log space requests等待事件。</p><ol><li>每三秒钟</li><li>每一次commit/rollback</li><li>当其 1/3满的时候，这个由_LOG_IO_SIZE参数控制</li><li>当其达到1M的时候</li></ol><p>log buffer的大小由参数log_buffer参数决定。默认值为512k或者128k*CPU数量，一般来说这个默认值是够用的。如果系统DML操作很多且这个等待事件比较严重时可以考虑增加log buffer参数的大小。修改该参数需要重启数据库。</p><p>log buffer过大也会有问题。上面说到当log bufffer达到1/3满时LGWR进程会清空log buffer。如log buffer为10m，则意味着在没有commit/rollbak的情况下，需要等到3m才会切换，这样会导致LGWR写入redo log缓慢，从而导致log file sync等待。所以我们在调优log buffer space时不应该增加其他等待事件，需要取得一个平衡。</p><p>如何调优：</p><ol><li>IO性能不好会导致LGWR进程清空log buffer过慢从而导致log buffer space等待，这时需要将redo log放在高速的磁盘（SSD）或裸设备上。</li><li>减少应用的commit活动，或者使用nologging选项，仅更新表中需要更新的栏位。</li><li>物化视图更新使用fast代替complete模式。</li><li>查看 log file switch 是否频繁。</li></ol><h4 id="3-7-6-SQL-Net-message-from-dblink"><a href="#3-7-6-SQL-Net-message-from-dblink" class="headerlink" title="3.7.6 SQL*Net message from dblink"></a>3.7.6 SQL*Net message from dblink</h4><p>这个等待事件发生在会话在等待从远程数据库获取信息，该信息是通过dblink进行传输的，oracle把该等待事件归类于network类。</p><ul><li><p>查询实时的等待：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> v$session_wait <span class="keyword">where</span> event<span class="operator">=</span> <span class="string">&#x27;SQL*Net message from dblink&#x27;</span></span><br></pre></td></tr></table></figure><ul><li><p>P1代表driver id。</p></li><li><p>P2代表通过dblink传输的字节数。</p></li></ul></li><li><p>查询非实时的等待：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> <span class="operator">*</span></span><br><span class="line"> <span class="keyword">from</span> v$session_event</span><br><span class="line"><span class="keyword">where</span> event <span class="keyword">like</span> <span class="string">&#x27;%SQL*Net message from  dblink%&#x27;</span></span><br><span class="line"><span class="keyword">order</span> <span class="keyword">by</span> time_waited <span class="keyword">desc</span></span><br></pre></td></tr></table></figure><p>注意这里的信息是从实例起来的汇总，同时由于SID是可以复用的，所以查看出来的SID并不代表上次的语句是这个等待。</p></li></ul><p>当我们的SQL语句通过dblink访问远程数据库时，需要先将远程数据传输到本地再进行处理，在完成这个动作之前该会话处于SQL*Net message from dblink等待。该等待主要发生在如下几种情形：</p><ol><li>数据库中有大量的物化视图需要定时同步远程数据库至本地。</li><li>数据库中有大量SQL语句需要通过dblink从远程获取数据。</li></ol><p>如何调优：</p><ol><li>针对物化视图我们首先需要减少不必要的物化视图数量，同时采用增量更新的方式，对于DML操作频繁的主表我们需要提高刷新频率。</li><li>针对SQL语句中有大量dblink的语句我们需要尽量减少dblink的访问。</li><li>如果不能减少可以通过在源库建立view的方式使其在源库执行。</li><li>也可以使用DRIVING_SITE hint的方式，手动指定oracle让其在源库执行。</li></ol><h4 id="3-7-7-SQL-Net-message-to-dblink"><a href="#3-7-7-SQL-Net-message-to-dblink" class="headerlink" title="3.7.7 SQL*Net message to dblink"></a>3.7.7 SQL*Net message to dblink</h4><p>这个等待事件发生在会话在等待一个远程数据库一个确认信息，确认其发送的数据远程数据库是否收到，该数据通过dblink发送。一般是由于目标服务器无法及时接受信息，Oracle将该等待事件列为Network类。</p><ul><li><p>查询实时的等待：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> v$session_wait <span class="keyword">where</span> event <span class="operator">=</span> <span class="string">&#x27;SQL*Net message to dblink&#x27;</span></span><br></pre></td></tr></table></figure><ul><li>P1代表driver id。</li><li>P2代表通过dblink传输的字节数。</li></ul></li><li><p>查询非实时的等待：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> <span class="operator">*</span></span><br><span class="line">  <span class="keyword">from</span> v$session_event</span><br><span class="line"> <span class="keyword">where</span> event <span class="keyword">like</span> <span class="string">&#x27;%SQL*Net message to dblink%&#x27;</span></span><br><span class="line"> <span class="keyword">order</span> <span class="keyword">by</span> time_waited <span class="keyword">desc</span></span><br></pre></td></tr></table></figure><p>注意这里的信息是从实例起来的汇总，同时由于SID是可以复用的，所以查看出来的SID并不代表上次的语句是这个等待</p></li></ul><p>当我们的SQL语句通过dblink访问远程数据库时，需要先将远程数据传输到本地再进行处理，这时远端数据库会发送数据至本地，此时远端数据库如不能及时接受消息，会话处于SQL*Net message to dblink等待。该等待主要发生在如下几种情形：</p><ol><li>数据库中有大量的物化视图需要定时同步远程数据库至本地。</li><li>数据库中有大量SQL语句需要通过dblink从远程获取数据。</li></ol><p>如何调优：</p><ol><li>针对物化视图我们首先需要减少不必要的物化视图数量，同时采用增量更新的方式，对于DML操作频繁的主表我们需要提高刷新频率。</li><li>针对SQL语句中有大量dblink的语句我们需要尽量减少dblink的访问。</li><li>如果不能减少可以通过在源库建立view的方式使其在源库执行。</li><li>也可以使用DRIVING_SITE hint的方式，手动指定oracle让其在源库执行。</li></ol><h4 id="3-7-8-SQL-Net-message-from-client"><a href="#3-7-8-SQL-Net-message-from-client" class="headerlink" title="3.7.8 SQL*Net message from client"></a>3.7.8 SQL*Net message from client</h4><p>这个等待事件发生在会话在完成请求后等待后续client发送命令，查询 <code>v$session</code> 可以看到处于这种等待事件的session状态为非活动。Oracle将该等待事件列为Idle类，对于此类等待我们无须理会。</p><p>通过如下语句查询实时的等待事件：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> <span class="operator">*</span></span><br><span class="line"> <span class="keyword">from</span> v$session_wait</span><br><span class="line"><span class="keyword">where</span> event <span class="operator">=</span> <span class="string">&#x27;SQL*Net message from client&#x27;</span></span><br><span class="line"><span class="keyword">order</span> <span class="keyword">by</span> sid</span><br></pre></td></tr></table></figure><h4 id="3-7-9-SQL-Net-message-to-client"><a href="#3-7-9-SQL-Net-message-to-client" class="headerlink" title="3.7.9 SQL*Net message to client"></a>3.7.9 SQL*Net message to client</h4><p>这个等待事件发生在会话发送数据到客户端时客户端无法及时接受时发生，Oracle将该等待事件列为Network类。</p><p>通过如下语句查询实时的等待事件</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> <span class="operator">*</span></span><br><span class="line"> <span class="keyword">from</span> v$session_wait</span><br><span class="line"><span class="keyword">where</span> event <span class="operator">=</span> <span class="string">&#x27;SQL*Net message to client&#x27;</span></span><br><span class="line"><span class="keyword">order</span> <span class="keyword">by</span> sid</span><br></pre></td></tr></table></figure><p>查询非实时的等待事件：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> <span class="operator">*</span></span><br><span class="line"> <span class="keyword">from</span> v$session_event</span><br><span class="line"><span class="keyword">where</span> event <span class="operator">=</span><span class="string">&#x27;SQL*Net message to client&#x27;</span></span><br><span class="line"><span class="keyword">order</span> <span class="keyword">by</span> time_waited <span class="keyword">desc</span></span><br></pre></td></tr></table></figure><p>该等待一般是由网络问题导致。</p><h4 id="3-7-10-cursor-mutex-X"><a href="#3-7-10-cursor-mutex-X" class="headerlink" title="3.7.10 cursor:mutex X"></a>3.7.10 cursor:mutex X</h4><p>Cursor正在被解析并尝试以独占的方式获取时产生的等待事件。实质就是一些会话长期持有互斥锁，在latch/mutex发生争用，意味着解析会面临压力，解析SQL需要更长的时间。可能导致该事件的原因有：</p><ul><li>频繁硬解析。</li><li>High Version Count。<ul><li>绑定变量不匹配。如带绑定变量的 sql 由于 ACS 特性（自适应游标）导致。</li><li>统计信息导致。</li><li>绑定变量字段类型不一致。</li><li>触发此问题也有可能是Oracle BUG导致，如多个PDB字符集不一致BUG25054064，以及High Waits On cursor: mutex X After Upgrading The Database to 12c, 18c &amp; 19c (Doc ID 2625815.1)等。</li></ul></li><li>Cursor失效。</li><li>Oracle BUG。</li></ul><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> DBA_HIST_ACTIVE_SESS_HISTORY <span class="keyword">where</span> event <span class="keyword">LIKE</span> <span class="string">&#x27;%mutex%&#x27;</span>;</span><br><span class="line"><span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> v$session_wait <span class="keyword">where</span> event <span class="keyword">LIKE</span> <span class="string">&#x27;%mutex%&#x27;</span>;</span><br><span class="line"><span class="comment">-- 查看SQL对应子游标个数，为Y的字段表示为何不能共享</span></span><br><span class="line"><span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> v$sql_shared_cursor <span class="keyword">where</span> address <span class="operator">=</span> <span class="string">&#x27;00000000AEC7BB48&#x27;</span>;</span><br></pre></td></tr></table></figure><p>可以查看故障时段做的hang分析日志，分析导致会话blocking的操作，以及如产生大量子Cursor的原因。</p><p>Bug 28794230 - 12.2 Cursor Mutex X Due To Sql Not Shared Because Of BIND_EQUIV_FAILURE (Doc ID 28794230.8) </p><p>该BUG修复版本：</p><ul><li>20.1.0</li><li>19.10.0.0.210119 (Jan 2021) Database Release Update (DB RU)</li><li>19.9.0.0.201020 (Oct 2020) Database Release Update(DB RU)</li><li>18.13.0.0.210119 (JAN 2021) Database Release Update (DB RU)</li><li>12.1.0.2.210119 (JAN 2021) Database Proactive Bundle Patch</li><li>12.2.0.1.191015 (Oct 2019) Bundle Patch for Windows Platforms</li></ul><p>可以查看AWR报告中的Mutex Sleep Summary统计项，并于正常的进行对比。</p><h4 id="3-7-11-cursor-mutex-S"><a href="#3-7-11-cursor-mutex-S" class="headerlink" title="3.7.11 cursor:mutex S"></a>3.7.11 cursor:mutex S</h4><p>会话在共享模式下请求一个mutex，此时另外一个会话在同一个Cursor对象上以独占模式持有它时导致的事件。</p><p>场景：</p><ul><li>Change the reference count (“in flux”)= “new guy is interested / spinning”</li><li>Parent examination</li><li>When finding a cursor to execute, the parent must be examined. The examination of the parent is performed using the mutex, cursor: mutex S.</li><li> When the parent cursor has many child cursors involved, this waits will come as the server process has to traverse the entire list of child cursors under the parent to find a match.</li><li>Mutex is in the parent cursor.</li></ul><h3 id="3-8-Wait-Events-Statistics"><a href="#3-8-Wait-Events-Statistics" class="headerlink" title="3.8 Wait Events Statistics"></a>3.8 Wait Events Statistics</h3><h4 id="3-8-1-Time-Model-Statistics"><a href="#3-8-1-Time-Model-Statistics" class="headerlink" title="3.8.1 Time Model Statistics"></a>3.8.1 Time Model Statistics</h4><p>该视图说明的是各过程所占的资源比例：</p><p><img src="https://pic-1258215793.cos.ap-shanghai.myqcloud.com/content/20211201/202112010108.png"></p><p>我们注意到所有 <code>% of DB Time</code> 总和大于100%，因为这是一个累计的比例，下面DB CPU相关的过程包含在DB CPU中。我们需要注意的是一些异常的高占用情况，如hard parse elapsed time (硬解析时间)占用时间过长等。</p><ul><li>Statistic Name：表示状态的名称。</li><li>Time (s)：表示在awr报告时间内持续的时间。</li><li>% of DB Time：表示和DB Time相比其占用的比例。<code>DB Time=DB CPU+Non-Idle Wait Time</code> 。</li></ul><p>Oracle进程(服务器，前台，影子等)的运行需要消耗CPU时间，我们把这些时间成为DB CPU ，注意后台进程的消耗不包括在DB Time中。如果一个进程不消耗CPU资源，它就会处于等待状态。等待包含空闲等待和非空闲等待，非空闲等待（顺序读,离散读,log sync,锁,闩等）所消耗的时间我们称为 <code>Non-Idle Wait Time</code> 。</p><ul><li>sql execute elapsed time：表示执行SQL语句语句所用的时间，102%说明大部分DB Time都在执行SQL语句，这是非常好的，说明DB Time没有浪费在其他动作上，如解析。</li><li>DB CPU：如上面所说表示消耗CPU的时间。</li><li>parse time elapsed：表示解析所占用的时间。</li><li>hard parse elapsed time：表示硬解析所占用的时间。</li><li>DB time = DB CPU+Non-Idle Wait Time。</li><li>background elapsed time：表示后台进程持续的时间。</li><li>background cpu time：表示后台进程的CPU时间。</li></ul><p><strong>如何计算Non-Idle Wait Time？</strong></p><p><code>Non-Idle Wait Time=DB Time-DB CPU</code> 通过上面公式我们可以计算非空闲等待时间的时间.回到上图，Non-Idle Wait Time=18877-11432=7445。</p><p><strong>80/20原则</strong>：这个原则告诉我们80%的等待是由20%的事件造成的，我们需要集中精力解决排行前几的事件</p><h4 id="3-8-2-Operating-System-Statistics"><a href="#3-8-2-Operating-System-Statistics" class="headerlink" title="3.8.2 Operating System Statistics"></a>3.8.2 Operating System Statistics</h4><p>该视图是操作系统层面的性能指标</p><p><img src="https://pic-1258215793.cos.ap-shanghai.myqcloud.com/content/20211201/202112010109.png"></p><p>该部分说明的是OS层面的一些状态信息,如CPU,IO</p><ul><li>CPU使用率=BUSY_TIME/(BUSY_TIME+IDLE_TIME)=20%。</li><li>BUSY_TIME=SYS_TIME+USER_TIME。</li></ul><p><img src="https://pic-1258215793.cos.ap-shanghai.myqcloud.com/content/20211201/202112010110.png"></p><p>这里需要注意%iowait，他代表CPU在等待io操作完成，这个可能是io过慢或者io操作过多导致。</p><h4 id="3-8-3-Wait-Class"><a href="#3-8-3-Wait-Class" class="headerlink" title="3.8.3 Wait Class"></a>3.8.3 Wait Class</h4><p><img src="https://pic-1258215793.cos.ap-shanghai.myqcloud.com/content/20211201/202112010117.png"></p><p>这部分是根据等待的类型来排序等待事件。</p><h4 id="3-8-4-Wait-Events"><a href="#3-8-4-Wait-Events" class="headerlink" title="3.8.4 Wait Events"></a>3.8.4 Wait Events</h4><p><img src="https://pic-1258215793.cos.ap-shanghai.myqcloud.com/content/20211201/202112010118.png"></p><p>这部分以具体的等待事件名称来进行排序，让我们可以清晰的知道是什么等待事件占的比例高。</p><h4 id="3-8-5-Background-Wait-Events"><a href="#3-8-5-Background-Wait-Events" class="headerlink" title="3.8.5 Background Wait Events"></a>3.8.5 Background Wait Events</h4><p><img src="https://pic-1258215793.cos.ap-shanghai.myqcloud.com/content/20211201/202112010119.png"></p><p>这部分是以后台进程的等待事件来进行排序的，让我们知道后台等待事件哪些占用的比例高。</p><h4 id="3-8-6-Service-Statistics"><a href="#3-8-6-Service-Statistics" class="headerlink" title="3.8.6 Service Statistics"></a>3.8.6 Service Statistics</h4><p><img src="https://pic-1258215793.cos.ap-shanghai.myqcloud.com/content/20211201/202112010120.png"></p><p>这部分是根据服务名称来所消耗的DB Time进行排序的。<code>SYS$USERS</code> 指的是用户连接是没有制定服务名称时默认的服务名。</p><h4 id="3-8-7-Service-Wait-Class-Stats"><a href="#3-8-7-Service-Wait-Class-Stats" class="headerlink" title="3.8.7 Service Wait Class Stats"></a>3.8.7 Service Wait Class Stats</h4><p><img src="https://pic-1258215793.cos.ap-shanghai.myqcloud.com/content/20211201/202112010121.png"></p><p>这部分是将上一部分的DB Time细分后展现。</p><h3 id="3-9-SQL-Statistics"><a href="#3-9-SQL-Statistics" class="headerlink" title="3.9 SQL Statistics"></a>3.9 SQL Statistics</h3><p>接下来是最重要的一块，能帮助我们定位占用相关资源的TOP SQL语句：</p><p><img src="https://pic-1258215793.cos.ap-shanghai.myqcloud.com/content/20211201/202112010111.png"></p><h4 id="3-9-1-SQL-ordered-by-Elapsed-Time"><a href="#3-9-1-SQL-ordered-by-Elapsed-Time" class="headerlink" title="3.9.1 SQL ordered by Elapsed Time"></a>3.9.1 SQL ordered by Elapsed Time</h4><p><img src="https://pic-1258215793.cos.ap-shanghai.myqcloud.com/content/20211201/202112010112.png"></p><p>上图为根据持续时间排序的SQL语句，所有栏位可根据字面上意思得出意义</p><ul><li>如executions过多可能会引起CPU占用率高</li><li>如executions低，而elapsed time很高，则需要优化该SQL，降低执行时间</li></ul><p>需要注意的是execution如果为0不代表未执行，代表在awr报告的持续范围内该语句未执行完成。</p><h4 id="3-9-2-SQL-ordered-by-CPU-Time"><a href="#3-9-2-SQL-ordered-by-CPU-Time" class="headerlink" title="3.9.2 SQL ordered by CPU Time"></a>3.9.2 SQL ordered by CPU Time</h4><p><img src="https://pic-1258215793.cos.ap-shanghai.myqcloud.com/content/20211201/202112010124.png"></p><p>这部分是按SQL语句消耗的CPU时间来排序的。</p><h4 id="3-9-3-SQL-ordered-by-Gets"><a href="#3-9-3-SQL-ordered-by-Gets" class="headerlink" title="3.9.3 SQL ordered by Gets"></a>3.9.3 SQL ordered by Gets</h4><p><img src="https://pic-1258215793.cos.ap-shanghai.myqcloud.com/content/20211201/202112010125.png"></p><p>该部分是按SQL语句的逻辑读来排序的。这里需要注意的是执行次数非常多的语句，可能会导致操作系统CPU使用率飙升。</p><h4 id="3-9-4-SQL-ordered-by-Reads"><a href="#3-9-4-SQL-ordered-by-Reads" class="headerlink" title="3.9.4 SQL ordered by Reads"></a>3.9.4 SQL ordered by Reads</h4><p><img src="https://pic-1258215793.cos.ap-shanghai.myqcloud.com/content/20211201/202112010126.png"></p><p>这部分是按SQL语句的物理读来排序的。</p><h4 id="3-9-5-SQL-ordered-by-Executions"><a href="#3-9-5-SQL-ordered-by-Executions" class="headerlink" title="3.9.5 SQL ordered by Executions"></a>3.9.5 SQL ordered by Executions</h4><p><img src="https://pic-1258215793.cos.ap-shanghai.myqcloud.com/content/20211201/202112010127.png"></p><p>这部分是按SQL语句的执行次数来进行排序的。这里需要注意的是执行次数非常多的语句，可能会导致操作系统CPU使用率飙升。</p><h4 id="3-9-6-SQL-ordered-by-Parse-Calls"><a href="#3-9-6-SQL-ordered-by-Parse-Calls" class="headerlink" title="3.9.6 SQL ordered by Parse Calls"></a>3.9.6 SQL ordered by Parse Calls</h4><p><img src="https://pic-1258215793.cos.ap-shanghai.myqcloud.com/content/20211201/202112010128.png"></p><p>这部分是按SQL语句的解析次数进行排序的.</p><ul><li><code>Parse Calls/Executions &gt; 1</code> ：说明每次执行需要多次解析。</li><li><code>Parse Calls/Executions &lt; 1</code> ：说明一次解析可供多次执行使用。</li></ul><p>越接近1说明解析没有被复用。</p><h4 id="3-9-7-SQL-ordered-by-Sharable-Memory"><a href="#3-9-7-SQL-ordered-by-Sharable-Memory" class="headerlink" title="3.9.7 SQL ordered by Sharable Memory"></a>3.9.7 SQL ordered by Sharable Memory</h4><p><img src="https://pic-1258215793.cos.ap-shanghai.myqcloud.com/content/20211201/202112010129.png"></p><p>该部分按SQL语句使用的共享内存排序。</p><h4 id="3-9-8-SQL-ordered-by-Version-Count"><a href="#3-9-8-SQL-ordered-by-Version-Count" class="headerlink" title="3.9.8 SQL ordered by Version Count"></a>3.9.8 SQL ordered by Version Count</h4><p><img src="https://pic-1258215793.cos.ap-shanghai.myqcloud.com/content/20211201/202112010130.png"></p><p>该部分按照SQL 语句的version count数量进行排序。version count 多说明相同语句在内存中shared pool没有被复用，需要查看具体原因。</p><h4 id="3-9-9-Complete-List-of-SQL-Text"><a href="#3-9-9-Complete-List-of-SQL-Text" class="headerlink" title="3.9.9 Complete List of SQL Text"></a>3.9.9 Complete List of SQL Text</h4><p>这里列出了上面提到的所有SQL语句的全部语句。</p><hr><p>参考：</p><p>🔗 《<a href="http://www.zhaibibei.cn/awr/">Oracle awr 报告全解析</a>》</p><p>🔗 《<a href="https://cloud.tencent.com/developer/article/1861840">Oracle-绑定变量binding variable解读 </a>》</p>]]></content>
    
    
    <summary type="html">整理Oracle-AWR报告相关内容，内容主要来自博主《宅必备》，包括：简述（什么是AWR、使用场景、如何生成AWR），相关知识点（硬解析和软解析），AWR解析等。</summary>
    
    
    
    <category term="技术文档" scheme="http://linyishui.top/categories/%E6%8A%80%E6%9C%AF%E6%96%87%E6%A1%A3/"/>
    
    
    <category term="sql" scheme="http://linyishui.top/tags/sql/"/>
    
    <category term="oracle" scheme="http://linyishui.top/tags/oracle/"/>
    
  </entry>
  
  <entry>
    <title>海量数据处理</title>
    <link href="http://linyishui.top/2021121801.html"/>
    <id>http://linyishui.top/2021121801.html</id>
    <published>2021-12-18T11:19:32.000Z</published>
    <updated>2021-12-27T07:01:22.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="海量数据处理"><a href="#海量数据处理" class="headerlink" title="海量数据处理"></a>海量数据处理</h1><h2 id="一-简述"><a href="#一-简述" class="headerlink" title="一. 简述"></a>一. 简述</h2><h2 id="二-常见方案"><a href="#二-常见方案" class="headerlink" title="二. 常见方案"></a>二. 常见方案</h2><ul><li>Hash方法</li><li>Bitmap方法</li><li>Bloom filter方法</li><li>数据库优化</li><li>倒排索引</li><li>外排序</li><li>Trie树</li><li>堆</li><li>双层桶</li><li>MapReduce</li></ul><h3 id="2-1-Hash"><a href="#2-1-Hash" class="headerlink" title="2.1 Hash"></a>2.1 Hash</h3><p>详细内容：《<a href="../2020070501.html" title="Title">散列表</a>》</p><p>Hash方法用来快速存取，因为其查找时间复杂度为 O(1) ，可以用来统计海量数据和分类等。</p><h3 id="2-2-Bitmap"><a href="#2-2-Bitmap" class="headerlink" title="2.2 Bitmap"></a>2.2 Bitmap</h3><p>Bitmap即位图，使用位数组来表示某些元素是否存在。适用于海量数据的快速查找、判重和删除等。</p><p>生成一个N位长的二进制串，假设集合为{2, 7, 4, 9, 1, 10}，则为10位的串，将值对应下标设置为1，结果为：1101001011，因为数组下标本身有序，所以最终相当于做了一次排序（时间复杂度为O(n)，以空间N换时间，并且要提前直到数组中取值范围）。</p><h3 id="2-3-Bloom-Filter"><a href="#2-3-Bloom-Filter" class="headerlink" title="2.3 Bloom Filter"></a>2.3 Bloom Filter</h3><p>判断元素是否存在于一个集合中，常规做法需要存储所有元素然后再进行比较查找，比如拦截垃圾邮件的功能，需要记录发送垃圾邮件的地址，假设发送者不断注册随机地址，每个地址需要16B，一亿个地址就需要1.6GB左右的空间。</p><p>Bloom Filter：</p><ul><li>可以用来检测一个元素是否属于某个集合。</li><li>结合了位图与散列函数，牺牲准确率来换取空间和时间效率的提高，判断不属于时绝对准确，但判断属于时则未必准确。</li><li>初始化为一个m位的位数组，定义k个不同的散列函数能把集合元素映射到位数组，当向集合中插入元素时，根据k个散列函数得到k个位，将这些位置为1。当需要查询元素是否属于集合时，只要根据散列函数计算出其对应的k个位，并判断：如果有任一位不为1就可以判断元素不在该集合；全为1则可能在集合中。</li><li>如何根据输入元素个数n，来确定位数组m的大小和Hash函数。<code>k = (ln2) * (m/n)</code> 时错误率最小，要求错误率不大于E时，m至少要等于 <code>n * lg(1/E)</code> 才能表示任意n个元素的集合。但m仍要取更大一些，因为要保证位数组至少一半为0，所以应该 <code>m &gt;= nlg(1/E) * lgE</code> ，大概就是nlg(1/E)的1.44倍。</li></ul><p>Bloom Filter只能判断插入元素，删除元素则会影响多个元素的检测。可以通过扩展方法支持元素的删除操作：</p><ul><li>CBF（Counting Bloom Filter）将位数组的位扩展为Counter</li><li>SBF（Spectral Bloom Filter）用counter中的最小值近似表示集合元素出现的次数。</li></ul><h3 id="2-4-数据库优化"><a href="#2-4-数据库优化" class="headerlink" title="2.4 数据库优化"></a>2.4 数据库优化</h3><ol><li><strong>数据分区</strong>：减少需要处理的数据规模。</li><li><strong>索引</strong>：正确的构建索引，大表索引本身比较占物理空间，创建和维护都比较耗费时间，要考虑索引的填充因子和聚集非聚集。</li><li><strong>批处理</strong>：对数据进行切分，最后将结果合并。</li><li><strong>临时表或中间表</strong>：大表变小表，保留中间数据。</li><li>……</li></ol><h3 id="2-5-倒排索引"><a href="#2-5-倒排索引" class="headerlink" title="2.5 倒排索引"></a>2.5 倒排索引</h3><p>倒排索引也叫反向索引，用来存储在全文搜索下某个单词在一个或一组文档的位置。</p><p>分类：</p><ul><li>一条记录的水平反向索引包含每个引用单词的文档的列表。</li><li>一个单词的水平反向索引又包含每个单词在一个文档中的位置。</li></ul><p>假设有文本内容：</p><figure class="highlight vbnet"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="symbol">D1:</span> The GDP increased</span><br><span class="line"><span class="symbol">D2:</span> The <span class="keyword">text</span> <span class="built_in">is</span> this</span><br><span class="line"><span class="symbol">D3:</span> My name <span class="built_in">is</span></span><br></pre></td></tr></table></figure><p>倒排索引：</p><ul><li>The：D1，D2</li><li>GDP：D1</li><li>increased：D1</li><li>text：D2</li><li>is：D2，D3</li><li>name：D3</li><li>…</li></ul><p>正向索引为文档到单词，反向则是单词到文档。在处理复杂的多关键字查询时，反向索引可以先完成查询的交、并逻辑运算，再对记录进行存取，把对记录的查询转换为对地址集合的查询。一般多应用于文档检索系统，常见的关系型数据库中的全文索引就是倒排索引。</p><h3 id="2-6-外排序"><a href="#2-6-外排序" class="headerlink" title="2.6 外排序"></a>2.6 外排序</h3><p>待排序元素数目较多，无法一次放入内存时，需要以文件的形式存放于外存，排序时分批调入内存处理。适用于大数据的排序和去重，效率很低且消耗大量I/O。</p><p>一般采用归并排序来实现：</p><ol><li>生成若干初始归并段，文件预处理。</li><li>把含有n个记录的文件，按内存大小划分为若干长度为L的子文件，分别将子文件调入内存，排序后送回外存。</li><li>进行多路归并，将初始段进行多遍归并，最后形成整个文件的单一归并段。</li></ol><h3 id="2-7-Trie树"><a href="#2-7-Trie树" class="headerlink" title="2.7 Trie树"></a>2.7 Trie树</h3><p>Trie树，又叫字典树或键树。用于快速字符串检索的多叉树结构，统计和排序大量的字符串，原理是利用字符串的公共前缀来减少时空开销，可以减少无谓的字符串比较，查询效率高于散列表。</p><p>基本特性：</p><ul><li>根节点不包含字符，除根节点外都只包含一个字符。</li><li>从根节点到某一阶段，路径上经过的字符串连接起来构成对应的字符串。</li><li>每个节点的所有子节点包含的字符都不相同。</li></ul><p>该结构重复度高比较消耗内存，当公共前缀率较低时不建议使用该方案。</p><h3 id="2-8-堆"><a href="#2-8-堆" class="headerlink" title="2.8 堆"></a>2.8 堆</h3><p>采用堆的数据结构，只需扫描一遍就可以得到所有前n元素，适合海量的数据处理。</p><p>求海量数据中前n大/小的值中位数：</p><table><thead><tr><th align="center">堆类型</th><th>作用</th></tr></thead><tbody><tr><td align="center">最大堆</td><td>求前n小</td></tr><tr><td align="center">最小堆</td><td>求前n大</td></tr><tr><td align="center">双堆</td><td>中位数</td></tr></tbody></table><h3 id="2-9-双层桶"><a href="#2-9-双层桶" class="headerlink" title="2.9 双层桶"></a>2.9 双层桶</h3><p>桶排序的思想是把[0, 1)划分为n个大小相同的子区间，每个子区间代表一个桶，将n个记录分配到各个桶中。关键字均匀分布在各个桶中，对关键字进行插入排序，将各非空桶中的记录连接起来。</p><p>桶排序的平均时间复杂度为 O(n) ，最坏情况为 O(n^2^) ，只适用于关键字取值范围小的情况，否则所需桶数目过多会浪费空间和计算时间。适合于寻找第K大的数、寻找中位数、寻找不重复或重复的数字等。</p><h3 id="2-10-MapReduce"><a href="#2-10-MapReduce" class="headerlink" title="2.10 MapReduce"></a>2.10 MapReduce</h3><p>MapReduce常用于云计算技术，是一种并行计算的分布式编程模型，支持大型分布式集群系统在大数据集上工作。</p><p>核心操作是：</p><ul><li>Map：映射，把一组键值对映射为一组新的键值对，通过Map程序将数据切割为不相干的区块，分配给大量的计算机达到分布式计算的效果。</li><li>Reduce：化简，通过指定并发的Reduce函数将结果汇总，保证所有的键值对共享相同的键组。</li></ul><p>Hadoop框架实现了MapReduce算法，把应用程序分割为许多很小的工作单元，每个单元可以在集群节点上重复执行。还提供了一个分布式文件系统GFS等。</p><p>分布式计算会导致网络间进行大量频繁的数据交换，输入数据保存在机器的本地磁盘上，系统划分数据段，将原始文件划分到各个段中，并进行备份分配到不同的机器上。从而可以保证大部分数据都可以本地读取，减少对网络带宽的占用。</p><h2 id="三-案例"><a href="#三-案例" class="headerlink" title="三. 案例"></a>三. 案例</h2><h3 id="3-1-Top-K-问题"><a href="#3-1-Top-K-问题" class="headerlink" title="3.1 Top K 问题"></a>3.1 Top K 问题</h3><p>在海量数据中找到出现频率最高的前K个数据。较好的方案为：分治 + Trie树/hash + 小顶堆。</p><p>将数据集通过Hash分解为多个小的数据集，然后使用Trie树或Hash统计每个小数据集中的query词频，之后用小顶堆求出每个数据集中频率最高的前K个数，最后合并所有数据集算出最终的Top K。</p><p>假设有1亿个浮点数，找出最大的10000个数？</p><ul><li><strong>全排序</strong>：全部数据一次排序，比较快的排序算法如快排一般为 O(nlogn)，每个浮点数占4B，1亿个大概需要400M内存。</li><li><strong>局部淘汰法</strong>：用一个容器放置前10000个数，依次与容器内最小数字相比，只要大于最小数字就交换。时间复杂度为 O(n + m^2^)，m为容器大小。</li><li><strong>分治法</strong>：将1亿条数据切分为100份，每份100万条，找出每份中最大的10000个（通过快排将数据分为两堆，大堆个数大于10000，继续对大堆快排成两堆；如果小于10000，则对小堆快排一次，找到第10000-n大的数字，递归该流程），最后在100*10000个中找到最终的最大10000。</li><li><strong>Hash法</strong>：先通过Hash去重，再通过分治或最小堆求出结果。</li><li><strong>最小堆</strong>：先读入前10000个数来创建大小为10000的小顶堆。建堆的时间复杂度为 O(mlogm) ，m即大小10000。遍历后续数字并与堆顶比较，当大于堆顶时则替换堆顶元素并重新调整小顶堆。最后按中序遍历输出堆中数字。时间复杂度为  O(mlogm) ，空间复杂度为m。</li></ul><p>解决该问题比较适合采用MapReduce框架来解决，只需编写一个Map函数和两个Reduce函数，然后提交到Hadoop上即可。</p><ul><li>通过Map将数据划分到不同机器处理。采用Hash算法，将Hash值相同的数据交给同一个Reduce Task。</li><li>每个机器通过Reduce算出各自出现次数最多的前N个数据，最后汇总。采用HashMap统计每个词的出现频率，第二个Reduce统计所有Reduce Task输出数据中的Top K。</li></ul><h3 id="3-2-重复问题"><a href="#3-2-重复问题" class="headerlink" title="3.2 重复问题"></a>3.2 重复问题</h3><p>可以使用Bitmap即位图法来实现。</p><p>如从文件中解析出不同号码个数，假设为8位，则存储8位整数需要99Mbit，约等于12MB内存。</p><h3 id="3-3-排序问题"><a href="#3-3-排序问题" class="headerlink" title="3.3 排序问题"></a>3.3 排序问题</h3><p>分治法或位图法。</p><hr><p>参考：</p><p>🔗 </p>]]></content>
    
    
    <summary type="html">海量数据优化。</summary>
    
    
    
    <category term="技术文档" scheme="http://linyishui.top/categories/%E6%8A%80%E6%9C%AF%E6%96%87%E6%A1%A3/"/>
    
    
    <category term="sql" scheme="http://linyishui.top/tags/sql/"/>
    
    <category term="mysql" scheme="http://linyishui.top/tags/mysql/"/>
    
    <category term="oracle" scheme="http://linyishui.top/tags/oracle/"/>
    
  </entry>
  
  <entry>
    <title>优化分页查询</title>
    <link href="http://linyishui.top/2021121201.html"/>
    <id>http://linyishui.top/2021121201.html</id>
    <published>2021-12-12T13:26:49.000Z</published>
    <updated>2021-12-20T11:19:00.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="优化分页查询"><a href="#优化分页查询" class="headerlink" title="优化分页查询"></a>优化分页查询</h1><h2 id="一-分页查询"><a href="#一-分页查询" class="headerlink" title="一. 分页查询"></a>一. 分页查询</h2><h3 id="1-1-使用场景"><a href="#1-1-使用场景" class="headerlink" title="1.1 使用场景"></a>1.1 使用场景</h3><p>当数据量较大时，不需要一次性全部展示给用户；又或者出于性能考虑需要对数据做分批处理。这类场景需要对查询做分页处理，将数据按页做切割依次返回单页结果。</p><h3 id="1-2-不同数据库的常见分页查询写法"><a href="#1-2-不同数据库的常见分页查询写法" class="headerlink" title="1.2 不同数据库的常见分页查询写法"></a>1.2 不同数据库的常见分页查询写法</h3><p>Oracle：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> RST2.<span class="operator">*</span> <span class="keyword">from</span> (</span><br><span class="line">    <span class="keyword">select</span> RST1.<span class="operator">*</span>, rownum RN <span class="keyword">from</span> (             </span><br><span class="line">        <span class="keyword">select</span> xxxx <span class="keyword">from</span> table_xxx <span class="keyword">where</span> XXXX</span><br><span class="line">        <span class="keyword">order</span> <span class="keyword">by</span> XXXX         </span><br><span class="line">    ) RST1 </span><br><span class="line"><span class="keyword">where</span> rownum <span class="operator">&lt;=</span> (<span class="number">0</span> <span class="operator">+</span> <span class="number">1</span>) <span class="operator">*</span> <span class="number">10000</span>) RST2 <span class="keyword">where</span> RST2.RN <span class="operator">&gt;</span> <span class="number">0</span> <span class="operator">*</span> <span class="number">10000</span>; </span><br></pre></td></tr></table></figure><p><strong>注意</strong>：如果rownum和order by写在同一层，sql会先生成rownum后执行order by子句，因而导致排序后结果不对。&lt;=写在内层在数据量大时要比外层效率高，因为在CBO优化模式下，Oracle可以将外层的查询条件推到内层查询中，以提高内层查询的执行效率。</p><p>MySQL：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> xxxx <span class="keyword">FROM</span> table_xxx LIMIT M,N</span><br></pre></td></tr></table></figure><h3 id="1-3-分页为何要加排序？什么是稳定分页？"><a href="#1-3-分页为何要加排序？什么是稳定分页？" class="headerlink" title="1.3 分页为何要加排序？什么是稳定分页？"></a>1.3 分页为何要加排序？什么是稳定分页？</h3><p>当表数据量为百万或者千万级时，随着偏移量增大，分页查询执行速度越来越慢，可以分析后发现主要由于Order By导致。那么分页为什么要加排序呢？</p><p>首先，如果分页查询使用的场景对数据一致/重复度不敏感的话，Order By不是必须的。但如果对此有要求就一定要添加排序操作。因为数据库提供的分页操作本身是不稳定的，不能保证查询按行顺序返回，除非排序能够保证唯一性，当ORDER BY的字段值相同时，数据的排序就会变得随机。</p><ul><li>如果没有指定ORDER BY语句，则数据库不保证以特定顺序返回结果。 有些人认为，如果没有指定order by子句，行总是以聚簇索引顺序或物理磁盘顺序返回。 然而，这是不正确的，因为在查询处理期间可以改变行顺序的许多因素，例如并行的HASH连接是更改行顺序的操作符的一个很好的例子。</li><li>如果指定ORDER BY语句，数据库将对行进行排序，并按请求的顺序返回。 但是，如果该顺序不是确定性的，即可能有重复的值，则在每个具有相同值的组中，由于与上述相同的原因，该顺序是“随机的”。确保确定性顺序的唯一方法是在ORDER BY子句中包含保证的唯一列或列组（例如主键）。</li></ul><p>但即使加上Order By，数据库的分页方法也不算稳定的数据库分页，因为无法应对分页查询时插入新行的场景。有一种实现稳定分页的方法，叫做<strong>键集分页</strong>。主要思想不是通过告诉数据库要跳过多少行来跳过 “看过的行”，并希望在这期间没有增加任何行，而是使用一个独特的标识来确定哪些行已经被看过哪些没有。</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> xxx</span><br><span class="line">  <span class="keyword">FROM</span> xxx</span><br><span class="line"> <span class="keyword">WHERE</span> xxx</span><br><span class="line">   <span class="keyword">AND</span> id <span class="operator">&lt;</span> ?last_seen_id</span><br><span class="line"> <span class="keyword">ORDER</span> <span class="keyword">BY</span> id <span class="keyword">DESC</span></span><br></pre></td></tr></table></figure><p>无论如何都需要一个建立明确顺序的ORDER BY。从而使用这些列来确定你之前收到数据的地方。</p><h2 id="二-Oracle优化"><a href="#二-Oracle优化" class="headerlink" title="二. Oracle优化"></a>二. Oracle优化</h2><p>首先是分页内的查询SQL先尽量优化到最优：</p><ul><li>正确的构建索引。</li><li>减少表之间的关联。</li><li>简化查询的字段。</li><li>等等。</li></ul><p>Oracle有多种方案可以实现类似分页的效果：</p><ul><li><p>偏移量：适用于Oracle12c或更高版本的数据库</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> fieldA, fieldB </span><br><span class="line"><span class="keyword">FROM</span> <span class="keyword">table</span> </span><br><span class="line"><span class="keyword">ORDER</span> <span class="keyword">BY</span> fieldA </span><br><span class="line"><span class="keyword">OFFSET</span> <span class="number">5</span> <span class="keyword">ROWS</span> <span class="keyword">FETCH</span> NEXT <span class="number">14</span> <span class="keyword">ROWS</span> <span class="keyword">ONLY</span></span><br></pre></td></tr></table></figure></li><li><p>函数：如果为Oracle11g或更低版本的数据库，请使用分析功能 <code>RowNumber()</code> </p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> fieldA, fieldB</span><br><span class="line"><span class="keyword">FROM</span> (</span><br><span class="line">    <span class="keyword">SELECT</span> fieldA, fieldB,</span><br><span class="line">        <span class="built_in">row_number</span>() <span class="keyword">over</span> (<span class="keyword">order</span> <span class="keyword">by</span> fieldA) rowRank</span><br><span class="line">    <span class="keyword">FROM</span> table_name</span><br><span class="line">)</span><br><span class="line"><span class="keyword">WHERE</span> rowRank <span class="keyword">BETWEEN</span> <span class="number">5</span> <span class="keyword">AND</span> <span class="number">14</span>;</span><br></pre></td></tr></table></figure></li><li><p>RowNum：适用于Oracle11g或更低版本的数据库</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> T.<span class="operator">*</span> <span class="keyword">FROM</span> ( </span><br><span class="line"><span class="keyword">SELECT</span> T.<span class="operator">*</span>, rowNum <span class="keyword">as</span> rowIndex</span><br><span class="line"><span class="keyword">FROM</span> (</span><br><span class="line">    <span class="keyword">SELECT</span> fieldA, fieldB,</span><br><span class="line">    <span class="keyword">FROM</span> table_name</span><br><span class="line">)T)T</span><br><span class="line"><span class="keyword">WHERE</span> rowIndex <span class="operator">&gt;</span> <span class="number">0</span> <span class="keyword">AND</span> rowIndex <span class="operator">&lt;=</span> <span class="number">20</span>;</span><br></pre></td></tr></table></figure></li></ul><p>高版本数据库建议使用方案1，否则可以采用方案三。</p><p><code>OFFSET n ROWS FETCH NEXT m ROWS ONLY</code> 或 <code>rownum</code> 语法上未要求一定配套Order By，但语义上还是要加上。如果不添加ORDER BY子句，数据库可能以任何顺序返回结果。因此需要在ORDER BY子句中建立一个明确的行的顺序（以便没有行与另一行是对等的）。实际使用中都应该在ORDER BY子句中包含一些唯一键，如 <code>ORDER BY time_stamp DESC, id DESC</code> 。</p><p>对于最常见的等值表连接查询，CBO一般可能会采用两种连接方式NESTED LOOP和HASH JOIN（MERGE JOIN效率比HASH JOIN效率低，一般CBO不会考虑）。在这里，由于使用了分页，因此指定了一个返回的最大记录数，NESTED LOOP在返回记录数超过最大值时可以马上停止并将结果返回给中间层，而HASH JOIN必须处理完所有结果集（MERGE JOIN也是）。那么在大部分的情况下，对于分页查询选择NESTED LOOP作为查询的连接方法具有较高的效率（分页查询的时候绝大部分的情况是查询前几页·的数据，越靠后面的页数访问几率越小）。</p><p>当数据量很大时就要考虑分库分表或者分区，以及历史数据归档等。</p><h2 id="三-MySQL优化"><a href="#三-MySQL优化" class="headerlink" title="三. MySQL优化"></a>三. MySQL优化</h2><h3 id="3-1-语法"><a href="#3-1-语法" class="headerlink" title="3.1 语法"></a>3.1 语法</h3><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> <span class="keyword">table</span> LIMIT [<span class="keyword">offset</span>,] <span class="keyword">rows</span> <span class="operator">|</span> `<span class="keyword">rows</span> <span class="keyword">OFFSET</span> <span class="keyword">offset</span> ` </span><br><span class="line">(LIMIT <span class="keyword">offset</span>, `length`)</span><br><span class="line"></span><br><span class="line"><span class="keyword">SELECT</span> XXX</span><br><span class="line"><span class="keyword">FROM</span> XXX</span><br><span class="line"><span class="keyword">where</span> XXX</span><br><span class="line"><span class="keyword">order</span> <span class="keyword">by</span> id <span class="keyword">asc</span> </span><br><span class="line">LIMIT <span class="number">2000</span> <span class="keyword">OFFSET</span> <span class="number">50000</span></span><br><span class="line"><span class="comment">-- LIMIT 2000,50000</span></span><br></pre></td></tr></table></figure><ul><li><p>参数1：指定返回记录行的偏移量。</p></li><li><p>参数2：指定返回记录行的最大数目。</p></li><li><p>只提供一个参数 <code>limit 5000</code> 表示最大行数。</p></li></ul><p>对于数据规模不算大的场景，只需要注意 WHERE 和 Order By 上使用组合索引。</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> table_XX <span class="keyword">WHERE</span> XXX_A <span class="operator">=</span> <span class="number">1</span> <span class="keyword">ORDER</span> <span class="keyword">BY</span> id LIMIT <span class="number">50</span>, <span class="number">10</span></span><br><span class="line"><span class="comment">-- 创建字段为(XXX_A, id)的组合索引</span></span><br></pre></td></tr></table></figure><p>当数据量越大，偏移量也就越大，LIMIT执行速度会缓慢下降：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> table_XX <span class="keyword">WHERE</span> XXX_A <span class="operator">=</span> <span class="number">1</span> <span class="keyword">ORDER</span> <span class="keyword">BY</span> id LIMIT <span class="number">100000</span>, <span class="number">10</span></span><br></pre></td></tr></table></figure><p>这条语句将会扫描10010条数据，如果数据量很大，每次取10条数据都得扫描远远超过10条的数据，甚至筛选上百万条数据后然后选择10条。</p><h3 id="3-2-优化"><a href="#3-2-优化" class="headerlink" title="3.2 优化"></a>3.2 优化</h3><p>分页有两类情况：</p><ol><li>固定一页一页顺序查询。</li><li>跳转页面只查指定页数据。</li></ol><p>固定按页查询，可以记住每次分页的最大最小值</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">-- 查询下一页</span></span><br><span class="line"><span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> message <span class="keyword">where</span> id <span class="operator">&gt;</span> <span class="number">100000</span> <span class="keyword">order</span> <span class="keyword">by</span> id <span class="keyword">asc</span> limit <span class="number">10</span>;</span><br><span class="line"><span class="comment">-- 查询上一页</span></span><br><span class="line"><span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> message <span class="keyword">where</span> id <span class="operator">&lt;</span> <span class="number">99990</span> <span class="keyword">order</span> <span class="keyword">by</span> id <span class="keyword">desc</span> limit <span class="number">10</span>;</span><br></pre></td></tr></table></figure><p>查询指定页：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">-- 从前向后跳</span></span><br><span class="line"><span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> message <span class="keyword">WHERE</span> id <span class="operator">&gt;</span> <span class="number">100000</span> <span class="keyword">ORDER</span> <span class="keyword">BY</span> id <span class="keyword">ASC</span> LIMIT <span class="number">10</span>,<span class="number">10</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">-- 从后向前条</span></span><br><span class="line"><span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> message <span class="keyword">WHERE</span> id <span class="operator">&lt;</span> <span class="number">99990</span> <span class="keyword">ORDER</span> <span class="keyword">BY</span> id <span class="keyword">DESC</span> LIMIT <span class="number">20</span>,<span class="number">10</span>;</span><br></pre></td></tr></table></figure><p>缺点：必须有一个数值型递增序列字段。</p><p>还可以通过子查询的方式来优化，仅限于主键排序：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> table_XX <span class="keyword">WHERE</span> id <span class="operator">&gt;=</span> </span><br><span class="line">(<span class="keyword">SELECT</span> id <span class="keyword">FROM</span> table_XX <span class="keyword">WHERE</span> XXX_A <span class="operator">=</span> <span class="number">1</span> <span class="keyword">ORDER</span> <span class="keyword">BY</span> id LIMIT <span class="number">100000</span>, <span class="number">1</span>) LIMIT <span class="number">10</span> </span><br></pre></td></tr></table></figure><p>或者使用JOIN分页的方式：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> `content` <span class="keyword">AS</span> t1   </span><br><span class="line"><span class="keyword">JOIN</span> (<span class="keyword">SELECT</span> id <span class="keyword">FROM</span> `content` <span class="keyword">ORDER</span> <span class="keyword">BY</span> id <span class="keyword">desc</span> LIMIT &quot;.($page-1)*$pagesize.&quot;, <span class="number">1</span>) <span class="keyword">AS</span> t2   </span><br><span class="line"><span class="keyword">WHERE</span> t1.id <span class="operator">&lt;=</span> t2.id <span class="keyword">ORDER</span> <span class="keyword">BY</span> t1.id <span class="keyword">desc</span> LIMIT $pagesize; </span><br></pre></td></tr></table></figure><p>子查询是在索引上完成的，而普通的查询时在数据文件上完成的，通常来说，索引文件要比数据文件小得多，所以操作起来也会更有效率。</p><p>可以利用类似策略模式的方式去处理分页，比如判断如果是一百页以内，就使用最基本的分页方式，大于一百页，则使用子查询的分页方式。</p><p>当数据规模达到百万或千万级，LIMIT分页会存在较大性能问题。</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">-- 平均用时6.6秒 </span></span><br><span class="line"><span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> `cdb_posts` <span class="keyword">ORDER</span> <span class="keyword">BY</span> pid LIMIT <span class="number">1000000</span> , <span class="number">30</span></span><br><span class="line"></span><br><span class="line"><span class="comment">-- 平均用时0.6秒 </span></span><br><span class="line"><span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> `cdb_posts` <span class="keyword">WHERE</span> pid <span class="operator">&gt;=</span> (<span class="keyword">SELECT</span> pid <span class="keyword">FROM</span>  </span><br><span class="line">`cdb_posts` <span class="keyword">ORDER</span> <span class="keyword">BY</span> pid LIMIT <span class="number">1000000</span> , <span class="number">1</span>) LIMIT <span class="number">30</span></span><br></pre></td></tr></table></figure><p>因为要<strong>取出所有字段内容</strong>，第一种需要跨越大量数据块并取出，而第二种基本通过直接根据索引字段定位后，才取出相应内容，效率自然大大提升。对limit的优化，不是直接使用limit，而是首先获取到offset的id，然后直接使用limit size来获取数据。</p><p>可以看出，越往后分页，LIMIT语句的偏移量就会越大，两者速度差距也会越明显。实际应用中，可以利用类似策略模式的方式去处理分页，比如判断如果是一百页以内，就使用最基本的分页方式，大于一百页，则使用子查询的分页方式。</p><p>总结优化步骤：</p><ol><li><p>使用索引字段或主键进行排序。</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> film_id, description <span class="keyword">from</span> film <span class="keyword">order</span> <span class="keyword">by</span> film_id limit <span class="number">50</span>,<span class="number">5</span>;</span><br></pre></td></tr></table></figure></li><li><p>记录上次返回的主键，在下次查询时使用主键过滤。</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> film_id, description <span class="keyword">from</span> film </span><br><span class="line"><span class="keyword">where</span> film_id <span class="operator">&gt;</span> <span class="number">55</span> <span class="keyword">and</span> film_id <span class="operator">&lt;=</span> <span class="number">60</span></span><br><span class="line"><span class="keyword">order</span> <span class="keyword">by</span> film_id </span><br><span class="line">limit <span class="number">1</span>,<span class="number">5</span>;</span><br></pre></td></tr></table></figure></li></ol><hr><p>参考：</p><p>🔗 《<a href="https://use-the-index-luke.com/no-offset">We need tool support for keyset pagination (use-the-index-luke.com)</a>》</p>]]></content>
    
    
    <summary type="html">海量数据分页查询时如何针对性优化。</summary>
    
    
    
    <category term="技术文档" scheme="http://linyishui.top/categories/%E6%8A%80%E6%9C%AF%E6%96%87%E6%A1%A3/"/>
    
    
    <category term="sql" scheme="http://linyishui.top/tags/sql/"/>
    
    <category term="mysql" scheme="http://linyishui.top/tags/mysql/"/>
    
    <category term="oracle" scheme="http://linyishui.top/tags/oracle/"/>
    
  </entry>
  
  <entry>
    <title>《高性能MySQL》（七）优化服务器设置</title>
    <link href="http://linyishui.top/2021112901.html"/>
    <id>http://linyishui.top/2021112901.html</id>
    <published>2021-11-29T13:22:16.000Z</published>
    <updated>2021-11-30T02:37:36.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="《高性能MySQL》（七）优化服务器设置"><a href="#《高性能MySQL》（七）优化服务器设置" class="headerlink" title="《高性能MySQL》（七）优化服务器设置"></a>《高性能MySQL》（七）优化服务器设置</h1><h2 id="一-引文"><a href="#一-引文" class="headerlink" title="一. 引文"></a>一. 引文</h2><p>“我的服务器有32GB内存，12核CPU，怎样配置会最好？”很可惜，优化配置并非只看硬件情况，需要符合工作负载、数据以及应用需求等。</p><p>MySQL有很多可修改的参数，大部分都不需要修改默认值，精力应该更多放在<strong>优化schema、索引以及查询设计上</strong>。确保基本的配置，如InnoDB的Buffer Pool和日志文件缓存大小等设置为安全值即可。</p><p>最好从查询语句和响应时间来分析问题，而不是由配置项入手，大部分人都是使用默认配置，也间接证明了默认值经过了大量的测试。</p><h2 id="二-MySQL配置原理"><a href="#二-MySQL配置原理" class="headerlink" title="二. MySQL配置原理"></a>二. MySQL配置原理</h2><h3 id="2-1-配置项"><a href="#2-1-配置项" class="headerlink" title="2.1 配置项"></a>2.1 配置项</h3><p>MySQL获取配置信息的方式：</p><ul><li><strong>命令行参数</strong>：启动时输入。</li><li><strong>配置文件</strong>：默认路径为 <code>/etc/my.cnf</code> 或 <code>/etc/mysql/my.cnf</code> 。</li></ul><p>查看当前使用的配置文件路径：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> <span class="built_in">which</span> mysqld</span></span><br><span class="line">/usr/sbin/mysqld</span><br><span class="line"><span class="meta">$</span><span class="bash"> /usr/sbin/mysqld --verbose --<span class="built_in">help</span> | grep -A 1 <span class="string">&#x27;Default options&#x27;</span></span></span><br><span class="line">Default options are read from the following files in the given order: /etc/mysql/my.cnf ~/.my.cnf /usr/etc/my.cnf</span><br></pre></td></tr></table></figure><p>配置项可以由多个作用域，有些是服务器级（全局作用域），有些是连接级的（会话作用域），剩下则是对象级的。改变会话级变量，只影响当前连接，并且关闭后会失效。</p><ul><li>query_cache_size变量为全局。</li><li>sort_buffer_size变量默认为全局相同，但每个线程也可以设置。</li><li>join_buffer_size变量也有全局默认且每个线程可以设置，但若一个查询中关联多张表，可以为每个关联分配一个关联缓冲（join buffer），所以每个查询可能有多个关联缓冲。</li></ul><h3 id="2-2-动态设置变量"><a href="#2-2-动态设置变量" class="headerlink" title="2.2 动态设置变量"></a>2.2 动态设置变量</h3><p>动态设置变量：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SET</span>           sort_buffer_size <span class="operator">=</span> <span class="operator">&lt;</span><span class="keyword">value</span><span class="operator">&gt;</span>;</span><br><span class="line"><span class="keyword">SET</span> <span class="keyword">GLOBAL</span>    sort_buffer_size <span class="operator">=</span> <span class="operator">&lt;</span><span class="keyword">value</span><span class="operator">&gt;</span>;</span><br><span class="line"><span class="keyword">SET</span>         @<span class="variable">@sort</span>_buffer_size <span class="operator">=</span> <span class="operator">&lt;</span><span class="keyword">value</span><span class="operator">&gt;</span>;</span><br><span class="line"><span class="keyword">SET</span> @<span class="variable">@session</span>.sort_buffer_size <span class="operator">=</span> <span class="operator">&lt;</span><span class="keyword">value</span><span class="operator">&gt;</span>;</span><br><span class="line"><span class="keyword">SET</span>  @<span class="variable">@global</span>.sort_buffer_size <span class="operator">=</span> <span class="operator">&lt;</span><span class="keyword">value</span><span class="operator">&gt;</span>;</span><br><span class="line"><span class="operator">/</span><span class="operator">/</span> 检查配置</span><br><span class="line"><span class="keyword">SHOW</span> <span class="keyword">GLOBAL</span> VARIABLES</span><br></pre></td></tr></table></figure><p>动态设置变量可能会导致意外的副作用，如从缓冲中刷新脏块，务必小心可以在线修改的设置，可能会导致数据库执行大量的工作。</p><ul><li>key_buffer_size：一次性为键缓冲区（key buffer / key cache）分配所有指定的空间。但操作系统不会真的立刻分配内存，而是使用时才分配。<ul><li>MySQL允许创建多个键缓存，若把非默认键缓存变量设置为0，MySQL会丢弃缓存在其上的索引转而使用默认键缓存，并在没有引用时删除该缓存。</li><li>为不存在的键设置变量，会创建新缓存。</li><li>对一个已存在键缓存设置非零值，会刷新其内容，但会阻塞所有操作直到刷新完毕。</li></ul></li><li>table_cache_size：不会立即生效，在线程打开表时检查此值，若大于缓存中表的数量，线程可以把新打开的表放入缓存，若小于则将缓存中不常用的删除。</li><li>thread_cache_size：不会立即生效，在下次有连接关闭时产生效果，检查缓存中是否还有空间来缓存线程，如果有则缓存改线程供后面重用；如果没有则销毁该线程。但缓存中线程数和使用的内存不会立即减少，只有在新连接删除缓存的一个现场并使用后才减少。<ul><li><strong>MySQL只在关闭连接时才在缓存中增加线程，只在创建新连接时才从缓存中删除线程</strong>。</li></ul></li><li>query_cache_size：MySQL在启动时一次性分配并且初始化这块内存。修改此变量会立即删除所有缓存的查询，重新分配这片缓存到指定大小，并且重新初始化内存。因为要逐个清理缓存的查询，可能会花费较长时间，在完成初始化前都无法提供服务。</li><li>read_buffer_size：只有在查询需要使用时才会为该缓存分配内存，并且一次性分配该参数指定大小的全部内存。</li><li>read_rnd_buffer_size：只会在有查询需要使用时才会为该缓存分配内存。只分配需要的内存大小、</li><li>sort_buffer_size：只会在有查询需要做排序操作时为该缓存分配内存，一旦排序立即分配指定大小的全部内存。</li><li>……</li></ul><p>对于一次性分配指定大小内存的配置项，很容易导致内存浪费，所以尽量不要使用，使用也尽量在查询需要时在连接级别单独调大。内存分配是一个极其昂贵的操作，包括了地址空间的分配。如果查询需要使用一个较大的排序缓存才能很好的执行，应该在查询前增加sort_buffer_size的值，执行后恢复为DEFAULT。</p><hr><p>参考：</p><p>🔗 《高性能MySQL》</p>]]></content>
    
    
    <summary type="html">《高性能MySQL》读书笔记，内容：等。</summary>
    
    
    
    <category term="技术文档" scheme="http://linyishui.top/categories/%E6%8A%80%E6%9C%AF%E6%96%87%E6%A1%A3/"/>
    
    
    <category term="mysql" scheme="http://linyishui.top/tags/mysql/"/>
    
  </entry>
  
  <entry>
    <title>执行计划（更新中）</title>
    <link href="http://linyishui.top/2021101401.html"/>
    <id>http://linyishui.top/2021101401.html</id>
    <published>2021-10-14T11:09:02.000Z</published>
    <updated>2021-11-16T02:26:08.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="执行计划"><a href="#执行计划" class="headerlink" title="执行计划"></a>执行计划</h1><h2 id="一-Oracle"><a href="#一-Oracle" class="headerlink" title="一. Oracle"></a>一. Oracle</h2><h3 id="1-1-什么是执行计划？"><a href="#1-1-什么是执行计划？" class="headerlink" title="1.1 什么是执行计划？"></a>1.1 什么是执行计划？</h3><p>执行计划是一条查询语句在Oracle中的执行过程或访问路径的描述。</p><p>执行计划描述了SQL引擎为执行SQL语句进行的操作；分析SQL语句相关的性能问题或仅仅质疑查询优化器的决定时，必须知道执行计划；所以执行计划常用于sql调优。</p><p>相关概念：</p><ul><li><p><strong>Rowid</strong>：r伪列，不是用户定义，而是系统加的。 每个表都有一个rowid，可以像使用其它列那样使用它，但是不能删除改列，也不能对该列的值进行修改、插入。一旦一行数据插入数据库，则rowid在该行的生命周期内是唯一的，即即使该行产生行迁移，行的rowid也不会改变。</p></li><li><p><strong>Recursive SQL</strong>：有时为了执行用户发出的一个sql语句，Oracle必须执行一些额外的语句称之为’’recursive calls’’或’’recursive SQL statements’’。</p><p>如当一个DDL语句发出后，ORACLE总是隐含的发出一些recursive SQL语句，来修改数据字典信息，以便用户可以成功的执行该DDL语句。</p><p>当需要的数据字典信息没有在共享内存中时，经常会发生Recursive calls，这些Recursive calls会将数据字典信息从硬盘读入内存中。</p><p>用户不比关心这些recursive SQL语句的执行情况，在需要的时候，ORACLE会自动的在内部执行这些语句。DML语句与SELECT都可能引起recursive SQL，简单的说，我们可以将触发器视为recursive SQL。</p></li><li><p><strong>Row Source（行源）</strong>：在查询中，由上一操作返回的符合条件的行的集合，可以是表的全部行数据的集合，也可以是表的部分行数据的集合，也可以为对上2个row source进行连接操作（如join连接）后得到的行数据集合。</p></li><li><p><strong>Predicate（谓词）</strong>：一个查询中的WHERE限制条件。</p></li><li><p><strong>Driving Table（驱动表）</strong>：又称为外层表（OUTER TABLE）。用于嵌套与HASH连接中。</p><p>如果该row source返回较多的行数据，则对所有的后续操作有负面影响。</p><p>一般说来，是应用查询的限制条件后，返回较少行源的表作为驱动表，所以如果一个大表在WHERE条件有有限制条件（如等值限 制），则该大表作为驱动表也是合适的，正确说法应该为应用查询的限制条件后，返回较少行源的表作为驱动表。</p></li><li><p><strong>Probed Table（被探查表）</strong>：又称为内层表（INNER TABLE）。在我们从驱动表中得到具体一行的数据后，在该表中寻找符合连接条件的行。所以该表应当为大表（实际上应该为返回较大row source的表）且相应的列上应该有索引。</p></li><li><p><strong>组合索引（concatenated index）</strong>：由多个列构成的索引。</p><p>如create index idx_emp on emp(col1, col2, col3, ……)，则我们称idx_emp索引为组合索引。</p><p>在组合索引中有一个重要的概念：<strong>引导列</strong>（leading column），在上面的例子中，col1列为引导列。</p><p>当我们进行查询时可以使用“where col1 = ？ ”，也可以使用“where col1 = ？ and col2 = ？”，这样的限制条件都会使用索引，但是“where col2 = ？ ”查询就不会使用该索引。</p><p>所以限制条件中包含先导列时，该限制条件才会使用该组合索引。</p></li><li><p><strong>可选择性（selectivity）</strong>：比较一下列中唯一键的数量和表中的行数，就可以判断该列的可选择性。 如果该列的“唯一键的数量/表中的行数”的比值越接近1，则该列的可选择性越高，该列就越适合创建索引，同样索引的可选择性也越高。在可选择性高的列上进 行查询时，返回的数据就较少，比较适合使用索引查询。</p></li></ul><h3 id="1-2-如何查看执行计划？"><a href="#1-2-如何查看执行计划？" class="headerlink" title="1.2 如何查看执行计划？"></a>1.2 如何查看执行计划？</h3><p>oracle要使用执行计划一般在sqlplus执行sql：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">explain plan <span class="keyword">for</span> <span class="keyword">select</span> <span class="number">1</span> <span class="keyword">from</span> t</span><br></pre></td></tr></table></figure><p>不过如果是使用PLSQL的话，那就可以使用PLSQL提供的查询执行计划了,也就是按F5打开PLSQL工具  -&gt;  首选项  -&gt;  窗口类型  -&gt;  计划窗口  ，在这里加入执行计划需要的参数：</p><p><img src="https://pic-1258215793.cos.ap-shanghai.myqcloud.com/content/20211001/202110010110.png"></p><p>执行结果：</p><p><img src="https://pic-1258215793.cos.ap-shanghai.myqcloud.com/content/20211001/202110010111.png"></p><p>参数含义：</p><ul><li>基数(Rows)：Oracle估计的当前步骤的返回结果集行数</li><li>字节(Bytes)：执行SQL对应步骤返回的字节数</li><li>耗费(COST)：CPU耗费：Oracle估计的该步骤的执行耗费和CPU耗费</li><li>时间(Time)：Oracle估计的执行sql对于步骤需要的时间</li></ul><h3 id="1-3-查看真实的执行计划"><a href="#1-3-查看真实的执行计划" class="headerlink" title="1.3 查看真实的执行计划"></a>1.3 查看真实的执行计划</h3><p>sqlplus窗口执行：</p><ul><li>step1：set statistics_level</li></ul><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">alter</span> session <span class="keyword">set</span> statistics_level<span class="operator">=</span><span class="keyword">ALL</span>;</span><br></pre></td></tr></table></figure><ul><li>step2：执行业务sql</li></ul><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> <span class="comment">/*+ monitor */</span> <span class="operator">*</span> <span class="keyword">from</span> ... <span class="keyword">where</span> ....;</span><br></pre></td></tr></table></figure><ul><li>step3：为了样式，设置linesize</li></ul><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">set</span> linesize <span class="number">200</span> pagesize <span class="number">300</span>;</span><br></pre></td></tr></table></figure><ul><li>step4：查询真实执行计划</li></ul><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> <span class="keyword">table</span>(dbms_xplan.display_cursor(<span class="keyword">null</span>, <span class="keyword">null</span>, <span class="string">&#x27;iostats last&#x27;</span>));</span><br></pre></td></tr></table></figure><p>sqlplus一般要数据库管理员才可以使用，如果你不是dba，只能使用plsql developer的话，只能用下面的方法。</p><p>使用存储过程，SQL：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">declare</span></span><br><span class="line">  b1 <span class="type">date</span>;</span><br><span class="line"><span class="keyword">begin</span></span><br><span class="line">  <span class="keyword">execute</span> immediate <span class="string">&#x27;alter session set statistics_level=ALL&#x27;</span>;</span><br><span class="line">  b1 :<span class="operator">=</span> sysdate <span class="operator">-</span> <span class="number">1</span>;</span><br><span class="line">  <span class="keyword">for</span> test <span class="keyword">in</span> (</span><br><span class="line">               <span class="comment">/*业务SQL(sql后面不需要加&quot;;&quot;)*/</span></span><br><span class="line">               <span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> t) loop</span><br><span class="line">    <span class="keyword">null</span>;</span><br><span class="line">  <span class="keyword">end</span> loop;</span><br><span class="line">  <span class="keyword">for</span> x <span class="keyword">in</span> (<span class="keyword">select</span> p.plan_table_output</span><br><span class="line">              <span class="keyword">from</span> <span class="keyword">table</span>(dbms_xplan.display_cursor(<span class="keyword">null</span>,</span><br><span class="line">                                                   <span class="keyword">null</span>,</span><br><span class="line">                                                   <span class="string">&#x27;advanced -bytes -PROJECTION allstats last&#x27;</span>)) p) loop</span><br><span class="line">    dbms_output.put_line(x.plan_table_output);</span><br><span class="line">  <span class="keyword">end</span> loop;</span><br><span class="line">  <span class="keyword">rollback</span>;</span><br><span class="line"><span class="keyword">end</span>;</span><br><span class="line"><span class="operator">/</span></span><br></pre></td></tr></table></figure><p>两种窗口：</p><ul><li>1、SQL窗口的，执行SQL后只能去output查看；</li><li>2、command window的，需要先设置<code>set serveroutput on size unlimited</code>，然后再执行存储过程</li></ul><p>output或者命令窗口查看的真实执行计划和统计信息：</p><p><img src="https://pic-1258215793.cos.ap-shanghai.myqcloud.com/content/20211001/202110010112.png"></p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line">SQL_ID  abk3ghv9u1tvb, child number <span class="number">0</span></span><br><span class="line"><span class="comment">-------------------------------------</span></span><br><span class="line"><span class="keyword">SELECT</span> <span class="comment">/*+ monitor */</span> <span class="operator">*</span> <span class="keyword">FROM</span> APPR_HANDLE_INFO</span><br><span class="line"> </span><br><span class="line">Plan hash <span class="keyword">value</span>: <span class="number">885170757</span></span><br><span class="line"> </span><br><span class="line"><span class="comment">------------------------------------------------------------------------------------------------------------------------</span></span><br><span class="line"><span class="operator">|</span> Id  <span class="operator">|</span> Operation         <span class="operator">|</span> Name             <span class="operator">|</span> Starts <span class="operator">|</span> E<span class="operator">-</span><span class="keyword">Rows</span> <span class="operator">|</span> Cost (<span class="operator">%</span>CPU)<span class="operator">|</span> E<span class="operator">-</span><span class="type">Time</span>   <span class="operator">|</span> A<span class="operator">-</span><span class="keyword">Rows</span> <span class="operator">|</span>   A<span class="operator">-</span><span class="type">Time</span>   <span class="operator">|</span> Buffers <span class="operator">|</span></span><br><span class="line"><span class="comment">------------------------------------------------------------------------------------------------------------------------</span></span><br><span class="line"><span class="operator">|</span>   <span class="number">0</span> <span class="operator">|</span> <span class="keyword">SELECT</span> STATEMENT  <span class="operator">|</span>                  <span class="operator">|</span>      <span class="number">1</span> <span class="operator">|</span>        <span class="operator">|</span>   <span class="number">210</span> (<span class="number">100</span>)<span class="operator">|</span>          <span class="operator">|</span>  <span class="number">72059</span> <span class="operator">|</span><span class="number">00</span>:<span class="number">00</span>:<span class="number">00.06</span> <span class="operator">|</span>    <span class="number">2460</span> <span class="operator">|</span></span><br><span class="line"><span class="operator">|</span>   <span class="number">1</span> <span class="operator">|</span>  <span class="keyword">TABLE</span> ACCESS <span class="keyword">FULL</span><span class="operator">|</span> APPR_HANDLE_INFO <span class="operator">|</span>      <span class="number">1</span> <span class="operator">|</span>  <span class="number">32752</span> <span class="operator">|</span>   <span class="number">210</span>   (<span class="number">1</span>)<span class="operator">|</span> <span class="number">00</span>:<span class="number">00</span>:<span class="number">03</span> <span class="operator">|</span>  <span class="number">72059</span> <span class="operator">|</span><span class="number">00</span>:<span class="number">00</span>:<span class="number">00.06</span> <span class="operator">|</span>    <span class="number">2460</span> <span class="operator">|</span></span><br><span class="line"><span class="comment">------------------------------------------------------------------------------------------------------------------------</span></span><br><span class="line"> </span><br><span class="line">Query Block Name <span class="operator">/</span> Object Alias (identified <span class="keyword">by</span> operation id):</span><br><span class="line"><span class="comment">-------------------------------------------------------------</span></span><br><span class="line"> </span><br><span class="line">   <span class="number">1</span> <span class="operator">-</span> SEL$<span class="number">1</span> <span class="operator">/</span> APPR_HANDLE_INFO<span class="variable">@SEL</span>$<span class="number">1</span></span><br><span class="line"> </span><br><span class="line">Outline Data</span><br><span class="line"><span class="comment">-------------</span></span><br><span class="line"> </span><br><span class="line">  <span class="comment">/*+</span></span><br><span class="line"><span class="comment">      BEGIN_OUTLINE_DATA</span></span><br><span class="line"><span class="comment">      IGNORE_OPTIM_EMBEDDED_HINTS</span></span><br><span class="line"><span class="comment">      OPTIMIZER_FEATURES_ENABLE(&#x27;11.2.0.4&#x27;)</span></span><br><span class="line"><span class="comment">      DB_VERSION(&#x27;11.2.0.4&#x27;)</span></span><br><span class="line"><span class="comment">      ALL_ROWS</span></span><br><span class="line"><span class="comment">      OUTLINE_LEAF(@&quot;SEL$1&quot;)</span></span><br><span class="line"><span class="comment">      FULL(@&quot;SEL$1&quot; &quot;APPR_HANDLE_INFO&quot;@&quot;SEL$1&quot;)</span></span><br><span class="line"><span class="comment">      END_OUTLINE_DATA</span></span><br><span class="line"><span class="comment">  */</span></span><br></pre></td></tr></table></figure><p>关键信息解释：</p><ul><li>Starts：该SQL执行的次数</li><li>E-Rows：为执行计划预计的行数</li><li>A-Rows：实际返回的行数，E-Rows和A-Rows作比较，就可以看出具体那一步执行计划出问题了</li><li>A-Time：每一步实际执行的时间，可以看出耗时的SQL</li><li>Buffers：每一步实际执行的逻辑读或一致性读</li></ul><h3 id="1-4-分析执行计划"><a href="#1-4-分析执行计划" class="headerlink" title="1.4 分析执行计划"></a>1.4 分析执行计划</h3><h4 id="1-4-1-查看explain"><a href="#1-4-1-查看explain" class="headerlink" title="1.4.1 查看explain"></a>1.4.1 查看explain</h4><p>找一条比较复杂的SQL，执行：</p><p><img src="https://pic-1258215793.cos.ap-shanghai.myqcloud.com/content/20211001/202110010113.png"></p><p> set statistics_level=ALL方式：</p><p><img src="https://pic-1258215793.cos.ap-shanghai.myqcloud.com/content/20211001/202110010114.png"></p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br></pre></td><td class="code"><pre><span class="line">SQL_ID  <span class="number">4</span>qfq3t2ukm0y1, child number <span class="number">0</span></span><br><span class="line"><span class="comment">-------------------------------------</span></span><br><span class="line"><span class="keyword">SELECT</span> <span class="comment">/*+ monitor*/</span> A.USER_CODE, A.FULL_NAME, A.USER_PWD, C.UNIT_CODE, </span><br><span class="line">C.UNIT_NAME <span class="keyword">FROM</span> BASE_USER A <span class="keyword">LEFT</span> <span class="keyword">JOIN</span> (<span class="keyword">SELECT</span> UR.USER_CODE, </span><br><span class="line">UR.UNIT_CODE <span class="keyword">FROM</span> APPR_USER_ROLE UR <span class="keyword">WHERE</span> UR.USER_ROLE <span class="operator">&lt;</span> <span class="number">10</span>) B <span class="keyword">ON</span> </span><br><span class="line">A.USER_CODE <span class="operator">=</span> B.USER_CODE <span class="keyword">LEFT</span> <span class="keyword">JOIN</span> LZCITY_APPROVE_UNIT_INFO C <span class="keyword">ON</span> </span><br><span class="line">B.UNIT_CODE <span class="operator">=</span> C.UNIT_CODE <span class="keyword">WHERE</span> C.UNIT_CODE <span class="operator">=</span><span class="string">&#x27;15803&#x27;</span></span><br><span class="line"> </span><br><span class="line">Plan hash <span class="keyword">value</span>: <span class="number">3288287052</span></span><br><span class="line"> </span><br><span class="line"><span class="comment">------------------------------------------------------------------------------------------------------------------------------------------------</span></span><br><span class="line"><span class="operator">|</span> Id  <span class="operator">|</span> Operation                      <span class="operator">|</span> Name                        <span class="operator">|</span> Starts <span class="operator">|</span> E<span class="operator">-</span><span class="keyword">Rows</span> <span class="operator">|</span> Cost (<span class="operator">%</span>CPU)<span class="operator">|</span> E<span class="operator">-</span><span class="type">Time</span>   <span class="operator">|</span> A<span class="operator">-</span><span class="keyword">Rows</span> <span class="operator">|</span>   A<span class="operator">-</span><span class="type">Time</span>   <span class="operator">|</span> Buffers <span class="operator">|</span></span><br><span class="line"><span class="comment">------------------------------------------------------------------------------------------------------------------------------------------------</span></span><br><span class="line"><span class="operator">|</span>   <span class="number">0</span> <span class="operator">|</span> <span class="keyword">SELECT</span> STATEMENT               <span class="operator">|</span>                             <span class="operator">|</span>      <span class="number">1</span> <span class="operator">|</span>        <span class="operator">|</span>     <span class="number">3</span> (<span class="number">100</span>)<span class="operator">|</span>          <span class="operator">|</span>     <span class="number">16</span> <span class="operator">|</span><span class="number">00</span>:<span class="number">00</span>:<span class="number">00.01</span> <span class="operator">|</span>      <span class="number">38</span> <span class="operator">|</span></span><br><span class="line"><span class="operator">|</span>   <span class="number">1</span> <span class="operator">|</span>  NESTED LOOPS                  <span class="operator">|</span>                             <span class="operator">|</span>      <span class="number">1</span> <span class="operator">|</span>      <span class="number">1</span> <span class="operator">|</span>     <span class="number">3</span>   (<span class="number">0</span>)<span class="operator">|</span> <span class="number">00</span>:<span class="number">00</span>:<span class="number">01</span> <span class="operator">|</span>     <span class="number">16</span> <span class="operator">|</span><span class="number">00</span>:<span class="number">00</span>:<span class="number">00.01</span> <span class="operator">|</span>      <span class="number">38</span> <span class="operator">|</span></span><br><span class="line"><span class="operator">|</span>   <span class="number">2</span> <span class="operator">|</span>   NESTED LOOPS                 <span class="operator">|</span>                             <span class="operator">|</span>      <span class="number">1</span> <span class="operator">|</span>      <span class="number">1</span> <span class="operator">|</span>     <span class="number">3</span>   (<span class="number">0</span>)<span class="operator">|</span> <span class="number">00</span>:<span class="number">00</span>:<span class="number">01</span> <span class="operator">|</span>     <span class="number">16</span> <span class="operator">|</span><span class="number">00</span>:<span class="number">00</span>:<span class="number">00.01</span> <span class="operator">|</span>      <span class="number">22</span> <span class="operator">|</span></span><br><span class="line"><span class="operator">|</span>   <span class="number">3</span> <span class="operator">|</span>    NESTED LOOPS                <span class="operator">|</span>                             <span class="operator">|</span>      <span class="number">1</span> <span class="operator">|</span>      <span class="number">1</span> <span class="operator">|</span>     <span class="number">2</span>   (<span class="number">0</span>)<span class="operator">|</span> <span class="number">00</span>:<span class="number">00</span>:<span class="number">01</span> <span class="operator">|</span>     <span class="number">16</span> <span class="operator">|</span><span class="number">00</span>:<span class="number">00</span>:<span class="number">00.01</span> <span class="operator">|</span>       <span class="number">5</span> <span class="operator">|</span></span><br><span class="line"><span class="operator">|</span>   <span class="number">4</span> <span class="operator">|</span>     <span class="keyword">TABLE</span> ACCESS <span class="keyword">BY</span> INDEX ROWID<span class="operator">|</span> LZCITY_APPROVE_UNIT_INFO    <span class="operator">|</span>      <span class="number">1</span> <span class="operator">|</span>      <span class="number">1</span> <span class="operator">|</span>     <span class="number">1</span>   (<span class="number">0</span>)<span class="operator">|</span> <span class="number">00</span>:<span class="number">00</span>:<span class="number">01</span> <span class="operator">|</span>      <span class="number">1</span> <span class="operator">|</span><span class="number">00</span>:<span class="number">00</span>:<span class="number">00.01</span> <span class="operator">|</span>       <span class="number">3</span> <span class="operator">|</span></span><br><span class="line"><span class="operator">|</span><span class="operator">*</span>  <span class="number">5</span> <span class="operator">|</span>      INDEX <span class="keyword">UNIQUE</span> SCAN         <span class="operator">|</span> PK_LZCITY_APPROVE_UNIT_INFO <span class="operator">|</span>      <span class="number">1</span> <span class="operator">|</span>      <span class="number">1</span> <span class="operator">|</span>     <span class="number">0</span>   (<span class="number">0</span>)<span class="operator">|</span>          <span class="operator">|</span>      <span class="number">1</span> <span class="operator">|</span><span class="number">00</span>:<span class="number">00</span>:<span class="number">00.01</span> <span class="operator">|</span>       <span class="number">2</span> <span class="operator">|</span></span><br><span class="line"><span class="operator">|</span><span class="operator">*</span>  <span class="number">6</span> <span class="operator">|</span>     INDEX <span class="keyword">RANGE</span> SCAN           <span class="operator">|</span> PK_APPR_USER_ROLE           <span class="operator">|</span>      <span class="number">1</span> <span class="operator">|</span>      <span class="number">1</span> <span class="operator">|</span>     <span class="number">1</span>   (<span class="number">0</span>)<span class="operator">|</span> <span class="number">00</span>:<span class="number">00</span>:<span class="number">01</span> <span class="operator">|</span>     <span class="number">16</span> <span class="operator">|</span><span class="number">00</span>:<span class="number">00</span>:<span class="number">00.01</span> <span class="operator">|</span>       <span class="number">2</span> <span class="operator">|</span></span><br><span class="line"><span class="operator">|</span><span class="operator">*</span>  <span class="number">7</span> <span class="operator">|</span>    INDEX <span class="keyword">UNIQUE</span> SCAN           <span class="operator">|</span> PK_BASE_USER                <span class="operator">|</span>     <span class="number">16</span> <span class="operator">|</span>      <span class="number">1</span> <span class="operator">|</span>     <span class="number">0</span>   (<span class="number">0</span>)<span class="operator">|</span>          <span class="operator">|</span>     <span class="number">16</span> <span class="operator">|</span><span class="number">00</span>:<span class="number">00</span>:<span class="number">00.01</span> <span class="operator">|</span>      <span class="number">17</span> <span class="operator">|</span></span><br><span class="line"><span class="operator">|</span>   <span class="number">8</span> <span class="operator">|</span>   <span class="keyword">TABLE</span> ACCESS <span class="keyword">BY</span> INDEX ROWID  <span class="operator">|</span> BASE_USER                   <span class="operator">|</span>     <span class="number">16</span> <span class="operator">|</span>      <span class="number">1</span> <span class="operator">|</span>     <span class="number">1</span>   (<span class="number">0</span>)<span class="operator">|</span> <span class="number">00</span>:<span class="number">00</span>:<span class="number">01</span> <span class="operator">|</span>     <span class="number">16</span> <span class="operator">|</span><span class="number">00</span>:<span class="number">00</span>:<span class="number">00.01</span> <span class="operator">|</span>      <span class="number">16</span> <span class="operator">|</span></span><br><span class="line"><span class="comment">------------------------------------------------------------------------------------------------------------------------------------------------</span></span><br><span class="line"> </span><br><span class="line">Query Block Name <span class="operator">/</span> Object Alias (identified <span class="keyword">by</span> operation id):</span><br><span class="line"><span class="comment">-------------------------------------------------------------</span></span><br><span class="line"> </span><br><span class="line">   <span class="number">1</span> <span class="operator">-</span> SEL$E3445A69</span><br><span class="line">   <span class="number">4</span> <span class="operator">-</span> SEL$E3445A69 <span class="operator">/</span> C<span class="variable">@SEL</span>$<span class="number">4</span></span><br><span class="line">   <span class="number">5</span> <span class="operator">-</span> SEL$E3445A69 <span class="operator">/</span> C<span class="variable">@SEL</span>$<span class="number">4</span></span><br><span class="line">   <span class="number">6</span> <span class="operator">-</span> SEL$E3445A69 <span class="operator">/</span> UR<span class="variable">@SEL</span>$<span class="number">2</span></span><br><span class="line">   <span class="number">7</span> <span class="operator">-</span> SEL$E3445A69 <span class="operator">/</span> A<span class="variable">@SEL</span>$<span class="number">3</span></span><br><span class="line">   <span class="number">8</span> <span class="operator">-</span> SEL$E3445A69 <span class="operator">/</span> A<span class="variable">@SEL</span>$<span class="number">3</span></span><br><span class="line"> </span><br><span class="line">Outline Data</span><br><span class="line"><span class="comment">-------------</span></span><br><span class="line"> </span><br><span class="line">  <span class="comment">/*+</span></span><br><span class="line"><span class="comment">      BEGIN_OUTLINE_DATA</span></span><br><span class="line"><span class="comment">      IGNORE_OPTIM_EMBEDDED_HINTS</span></span><br><span class="line"><span class="comment">      OPTIMIZER_FEATURES_ENABLE(&#x27;11.2.0.4&#x27;)</span></span><br><span class="line"><span class="comment">      DB_VERSION(&#x27;11.2.0.4&#x27;)</span></span><br><span class="line"><span class="comment">      ALL_ROWS</span></span><br><span class="line"><span class="comment">      OUTLINE_LEAF(@&quot;SEL$E3445A69&quot;)</span></span><br><span class="line"><span class="comment">      MERGE(@&quot;SEL$2&quot;)</span></span><br><span class="line"><span class="comment">      OUTLINE(@&quot;SEL$A2E96217&quot;)</span></span><br><span class="line"><span class="comment">      OUTER_JOIN_TO_INNER(@&quot;SEL$E9F4A6F9&quot; &quot;B&quot;@&quot;SEL$1&quot;)</span></span><br><span class="line"><span class="comment">      OUTER_JOIN_TO_INNER(@&quot;SEL$E9F4A6F9&quot; &quot;C&quot;@&quot;SEL$4&quot;)</span></span><br><span class="line"><span class="comment">      OUTLINE(@&quot;SEL$2&quot;)</span></span><br><span class="line"><span class="comment">      OUTLINE(@&quot;SEL$E9F4A6F9&quot;)</span></span><br><span class="line"><span class="comment">      MERGE(@&quot;SEL$80808B20&quot;)</span></span><br><span class="line"><span class="comment">      OUTLINE(@&quot;SEL$6&quot;)</span></span><br><span class="line"><span class="comment">      OUTLINE(@&quot;SEL$80808B20&quot;)</span></span><br><span class="line"><span class="comment">      MERGE(@&quot;SEL$4&quot;)</span></span><br><span class="line"><span class="comment">      MERGE(@&quot;SEL$F1D6E378&quot;)</span></span><br><span class="line"><span class="comment">      OUTLINE(@&quot;SEL$5&quot;)</span></span><br><span class="line"><span class="comment">      OUTLINE(@&quot;SEL$4&quot;)</span></span><br><span class="line"><span class="comment">      OUTLINE(@&quot;SEL$F1D6E378&quot;)</span></span><br><span class="line"><span class="comment">      MERGE(@&quot;SEL$1&quot;)</span></span><br><span class="line"><span class="comment">      OUTLINE(@&quot;SEL$3&quot;)</span></span><br><span class="line"><span class="comment">      OUTLINE(@&quot;SEL$1&quot;)</span></span><br><span class="line"><span class="comment">      INDEX_RS_ASC(@&quot;SEL$E3445A69&quot; &quot;C&quot;@&quot;SEL$4&quot; (&quot;LZCITY_APPROVE_UNIT_INFO&quot;.&quot;UNIT_CODE&quot;))</span></span><br><span class="line"><span class="comment">      INDEX(@&quot;SEL$E3445A69&quot; &quot;UR&quot;@&quot;SEL$2&quot; (&quot;APPR_USER_ROLE&quot;.&quot;UNIT_CODE&quot; &quot;APPR_USER_ROLE&quot;.&quot;USER_CODE&quot; &quot;APPR_USER_ROLE&quot;.&quot;AREA_SEQ&quot; </span></span><br><span class="line"><span class="comment">              &quot;APPR_USER_ROLE&quot;.&quot;USER_ROLE&quot;))</span></span><br><span class="line"><span class="comment">      INDEX(@&quot;SEL$E3445A69&quot; &quot;A&quot;@&quot;SEL$3&quot; (&quot;BASE_USER&quot;.&quot;USER_CODE&quot;))</span></span><br><span class="line"><span class="comment">      LEADING(@&quot;SEL$E3445A69&quot; &quot;C&quot;@&quot;SEL$4&quot; &quot;UR&quot;@&quot;SEL$2&quot; &quot;A&quot;@&quot;SEL$3&quot;)</span></span><br><span class="line"><span class="comment">      USE_NL(@&quot;SEL$E3445A69&quot; &quot;UR&quot;@&quot;SEL$2&quot;)</span></span><br><span class="line"><span class="comment">      USE_NL(@&quot;SEL$E3445A69&quot; &quot;A&quot;@&quot;SEL$3&quot;)</span></span><br><span class="line"><span class="comment">      NLJ_BATCHING(@&quot;SEL$E3445A69&quot; &quot;A&quot;@&quot;SEL$3&quot;)</span></span><br><span class="line"><span class="comment">      END_OUTLINE_DATA</span></span><br><span class="line"><span class="comment">  */</span></span><br><span class="line"> </span><br><span class="line">Predicate Information (identified <span class="keyword">by</span> operation id):</span><br><span class="line"><span class="comment">---------------------------------------------------</span></span><br><span class="line"> </span><br><span class="line">   <span class="number">5</span> <span class="operator">-</span> access(&quot;C&quot;.&quot;UNIT_CODE&quot;<span class="operator">=</span><span class="string">&#x27;15803&#x27;</span>)</span><br><span class="line">   <span class="number">6</span> <span class="operator">-</span> access(&quot;UR&quot;.&quot;UNIT_CODE&quot;<span class="operator">=</span><span class="string">&#x27;15803&#x27;</span> <span class="keyword">AND</span> &quot;UR&quot;.&quot;USER_ROLE&quot;<span class="operator">&lt;</span><span class="number">10</span>)</span><br><span class="line">       <span class="keyword">filter</span>(&quot;UR&quot;.&quot;USER_ROLE&quot;<span class="operator">&lt;</span><span class="number">10</span>)</span><br><span class="line">   <span class="number">7</span> <span class="operator">-</span> access(&quot;A&quot;.&quot;USER_CODE&quot;<span class="operator">=</span>&quot;UR&quot;.&quot;USER_CODE&quot;)</span><br></pre></td></tr></table></figure><h4 id="1-4-2-explain执行顺序"><a href="#1-4-2-explain执行顺序" class="headerlink" title="1.4.2 explain执行顺序"></a>1.4.2 explain执行顺序</h4><p>不管是用F5方式还是set statistics_level=ALL方式，都有Operation参数，Operation表示sql执行过程，查看怎么执行的，有两个规则：</p><ul><li>根据Operation缩进判断，缩进最多的最先执行；</li><li>Operation缩进相同时，最上面的是最先执行的；</li></ul><p>如图执行计划，根据规则，可以得出<strong>执行顺序</strong>：INDEX UNIQUE SCAN-&gt;TABLE ACCESS BY INDEX ROWID-&gt;INDEX RANGE SCAN -&gt;NESTED LOOPS -&gt;INDEX UNIQUE SCAN-&gt;NESTED LOOPS   -&gt;TABLE ACCESS BY INDEX ROWID-&gt;NESTED LOOPS-&gt; SELECT STATEMENT 。</p><p><img src="https://pic-1258215793.cos.ap-shanghai.myqcloud.com/content/20211001/202110010115.png"></p><h4 id="1-4-3-访问数据方式"><a href="#1-4-3-访问数据方式" class="headerlink" title="1.4.3 访问数据方式"></a>1.4.3 访问数据方式</h4><p>Oracle访问表中数据的方法有两种：</p><ul><li><p>访问表数据：直接表中访问数据。</p></li><li><p>索引扫描：先访问索引，如果索引数据不符合目标SQL，就回表，符合就不回表，直接访问索引就可以。</p><p>先通过index查找到数据对应的rowid值（对于非唯一索引可能返回多个rowid值），然后根据rowid直接从表中得到具体的数据。该行对应的数据块是通过一次i/o得到的，在此情况下该次i/o只会读取一个数据库块。</p></li></ul><p>Oracle直接<strong>访问表中数据</strong>的方法又分为两种：</p><ul><li><strong>全表扫描（TABLE ACCESS FULL）</strong></li><li><strong>ROWID扫描（TABLE ACCESS BY ROWID）</strong></li></ul><p>访问索引的种类更多（TABLE ACCESS BY INDEX SCAN）：</p><ul><li><strong>索引唯一扫描（INDEX UNIQUE SCAN）</strong></li><li><strong>索引范围扫描（INDEX RANGE SCAN）</strong></li><li><strong>索引全扫描（INDEX FULL SCAN）</strong></li><li><strong>索引快速全扫描（INDEX FAST FULL SCAN）</strong></li><li><strong>索引跳跃式扫描（INDEX SKIP SCAN）</strong></li></ul><p>索引扫描可以由2步组成：</p><ol><li>扫描索引得到对应的rowid值。 </li><li> 通过找到的rowid从表中读出具体的数据。</li></ol><p>每步都是单独的一次I/O，但是对于索引，由于经常使用，绝大多数都已经CACHE到内存中，所以第1步的 I/O经常是逻辑I/O，即数据可以从内存中得到。</p><p>但是对于第2步来说，如果表比较大，则其数据不可能全在内存中，所以其I/O很有可能是物理I/O，这是一个机械操作，相对逻辑I/O来说，是极其费时间的。</p><p>所以如果多大表进行索引扫描，取出的数据如果大于总量的5% —— 10%，使用索引扫描会效率下降很多。如下列所示：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">explain plan <span class="keyword">for</span> <span class="keyword">select</span> empno， ename <span class="keyword">from</span> emp <span class="keyword">where</span> empno<span class="operator">=</span><span class="number">10</span>；</span><br><span class="line">　　Query Plan</span><br><span class="line"></span><br><span class="line"><span class="comment">------------------------------------</span></span><br><span class="line"><span class="keyword">SELECT</span> STATEMENT [CHOOSE] Cost<span class="operator">=</span><span class="number">1</span></span><br><span class="line"><span class="keyword">TABLE</span> ACCESS <span class="keyword">BY</span> ROWID EMP [ANALYZED]</span><br><span class="line">INDEX <span class="keyword">UNIQUE</span> SCAN EMP_I1</span><br></pre></td></tr></table></figure><p>如果查询的数据能全在索引中找到，就可以避免进行第2步操作，避免了不必要的I/O，此时即使通过索引扫描取出的数据比较多，效率还是很高的：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">explain plan <span class="keyword">for</span> <span class="keyword">select</span> empno <span class="keyword">from</span> emp <span class="keyword">where</span> empno<span class="operator">=</span><span class="number">10</span>;<span class="comment">-- 只查询empno列值</span></span><br><span class="line"></span><br><span class="line">Query Plan</span><br><span class="line"><span class="comment">------------------------------------</span></span><br><span class="line"><span class="keyword">SELECT</span> STATEMENT [CHOOSE] Cost<span class="operator">=</span><span class="number">1</span></span><br><span class="line">INDEX <span class="keyword">UNIQUE</span> SCAN EMP_I1</span><br></pre></td></tr></table></figure><p>如果sql语句中对索引列进行排序，因为索引已经预先排序好了，所以在执行计划中不需要再对索引列进行排序：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">explain plan <span class="keyword">for</span> <span class="keyword">select</span> empno, ename <span class="keyword">from</span> emp <span class="keyword">where</span> empno <span class="operator">&gt;</span> <span class="number">7876</span> <span class="keyword">order</span> <span class="keyword">by</span> empno;</span><br><span class="line"></span><br><span class="line">Query Plan</span><br><span class="line"><span class="comment">--------------------------------------------------------------------------------</span></span><br><span class="line"><span class="keyword">SELECT</span> STATEMENT[CHOOSE] Cost<span class="operator">=</span><span class="number">1</span></span><br><span class="line"><span class="keyword">TABLE</span> ACCESS <span class="keyword">BY</span> ROWID EMP [ANALYZED]</span><br><span class="line">INDEX <span class="keyword">RANGE</span> SCAN EMP_I1 [ANALYZED]</span><br></pre></td></tr></table></figure><h5 id="（1）全表扫描（TABLE-ACCESS-FULL）"><a href="#（1）全表扫描（TABLE-ACCESS-FULL）" class="headerlink" title="（1）全表扫描（TABLE ACCESS FULL）"></a>（1）全表扫描（TABLE ACCESS FULL）</h5><ul><li>全表扫描时从第一个区(EXTENT)的第一个块(BLOCK)开始扫描，一直扫描的到表的高水位线(High Water Mark)，这个范围内的数据块都会扫描到。</li><li>全表扫描是采用多数据块一起扫的，并不是一个个数据库扫的，也不是只读取一个数据块，减少了I/O总次数，提高了系统的吞吐量。</li><li>全表扫描慢是针对数据量很多的情况，数据量少的话，全表扫描并不慢的，不过随着数据量越多，高水位线也就越高，也就是说需要扫描的数据库越多，自然扫描所需要的IO越多，时间也越多。</li></ul><p>注意：数据量越多，全表扫描所需要的时间就越多，然后直接删了表数据呢？查询速度会变快？其实并不会的，因为即使我们删了数据，高位水线并不会改变，也就是同样需要扫描那么多数据块。</p><p><strong>使用场景：</strong>在较大的表上不建议使用全表扫描，除非取出数据的比较多，超过总量的5%到10%，以及想使用并行查询功能时。</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SQL</span><span class="operator">&gt;</span> explain plan <span class="keyword">for</span> <span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> dual;</span><br><span class="line">Query Plan</span><br><span class="line"><span class="comment">-----------------------------------------</span></span><br><span class="line"><span class="keyword">SELECT</span> STATEMENT[CHOOSE] Cost<span class="operator">=</span></span><br><span class="line"><span class="keyword">TABLE</span> ACCESS <span class="keyword">FULL</span> DUAL</span><br></pre></td></tr></table></figure><h5 id="（2）ROWID扫描（TABLE-ACCESS-BY-ROWID）"><a href="#（2）ROWID扫描（TABLE-ACCESS-BY-ROWID）" class="headerlink" title="（2）ROWID扫描（TABLE ACCESS BY ROWID）"></a>（2）ROWID扫描（TABLE ACCESS BY ROWID）</h5><p>ROWID也就是表数据行所在的物理存储地址，所谓的ROWID扫描是通过ROWID所在的数据行记录去定位。ROWID是一个伪列，数据库里并没有这个列，它是数据库查询过程中获取的一个物理地址，用于表示数据对应的行数。 <strong>Oracle存取单行数据的最快方法。</strong></p><p>这种存取方法不会用到多块读操作，一次I/O只能读取一个数据块。我们会经常在执行计划中看到该存取方法，如通过索引查询数据。</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">explain plan <span class="keyword">for</span> <span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> dept <span class="keyword">where</span> rowid <span class="operator">=</span> <span class="string">&#x27;&#x27;</span>AAAAyGAADAAAAATAAF<span class="string">&#x27;&#x27;</span>；</span><br><span class="line"> </span><br><span class="line">Query Plan</span><br><span class="line"><span class="comment">------------------------------------</span></span><br><span class="line"><span class="keyword">SELECT</span> STATEMENT [CHOOSE] Cost<span class="operator">=</span><span class="number">1</span></span><br><span class="line"><span class="keyword">TABLE</span> ACCESS <span class="keyword">BY</span> ROWID DEPT [ANALYZED]</span><br></pre></td></tr></table></figure><p>可以用sql查询rowid：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> t.<span class="operator">*</span>,rowid <span class="keyword">from</span> 表格</span><br></pre></td></tr></table></figure><p>随意获取一个ROWID序列：AAAWSJAAFAAAWwUAAA</p><ul><li>前6位表示对象编号(Data Object number)</li><li>其后3位文件编号(Relative file number)</li><li>再后6位表示块编号(Block number)</li><li>最后3位表示行编号(Row number)</li></ul><p><img src="https://pic-1258215793.cos.ap-shanghai.myqcloud.com/content/20211001/202110010116.jpeg"></p><p><strong>ROWID编码方法是：A ~ Z表示0到25；a ~ z表示26到51；0~9表示52到61；+表示62；/表示63；刚好64个字符。</strong></p><p>随意找张表查一下文件编号、区编号、行编号，查询后会返回rowid的一系列物理地址和文件编号(rowid_relative_fno(rowid))、块编号(rowid_block_number(rowid))、行编号(rowid_row_number(rowid))：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> t.seq,</span><br><span class="line">       rowid,</span><br><span class="line">       dbms_rowid.rowid_relative_fno(rowid),</span><br><span class="line">       dbms_rowid.rowid_block_number(rowid),</span><br><span class="line">       dbms_rowid.rowid_row_number(rowid)</span><br><span class="line">  <span class="keyword">from</span> t_info t</span><br></pre></td></tr></table></figure><p>SQL查询一下表格名称为TABLE的对象编码</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> owner,object_id,data_object_id,status <span class="keyword">from</span> dba_objects <span class="keyword">where</span> </span><br></pre></td></tr></table></figure><p><strong>相对文件id和绝对文件编码</strong>：相对文件id是指相对于表空间，在表空间唯一;绝对文件编码是指相当于全局数据库而言的，全局唯一。</p><p>查询一下相对文件id和绝对文件编码：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> file_name,file_id,relative_fno <span class="keyword">from</span> dba_data_files;</span><br></pre></td></tr></table></figure><h5 id="（3）索引唯一扫描（INDEX-UNIQUE-SCAN）"><a href="#（3）索引唯一扫描（INDEX-UNIQUE-SCAN）" class="headerlink" title="（3）索引唯一扫描（INDEX UNIQUE SCAN）"></a>（3）索引唯一扫描（INDEX UNIQUE SCAN）</h5><ul><li>索引唯一性扫描（INDEX UNIQUE SCAN）是针对唯一性索引（UNIQUE INDEX）来说的，也就是建立唯一性索引才能索引唯一性扫描。</li><li>唯一性扫描，其结果集只会返回一条记录。</li></ul><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">explain plan <span class="keyword">for</span> <span class="keyword">select</span> empno，ename <span class="keyword">from</span> emp <span class="keyword">where</span> empno<span class="operator">=</span><span class="number">10</span>；</span><br><span class="line"></span><br><span class="line">Query Plan</span><br><span class="line"><span class="comment">------------------------------------</span></span><br><span class="line"><span class="keyword">SELECT</span> STATEMENT [CHOOSE] Cost<span class="operator">=</span><span class="number">1</span></span><br><span class="line"><span class="keyword">TABLE</span> ACCESS <span class="keyword">BY</span> ROWID EMP [ANALYZED]</span><br><span class="line">INDEX <span class="keyword">UNIQUE</span> SCAN EMP_I1</span><br></pre></td></tr></table></figure><h5 id="（4）索引范围扫描（INDEX-RANGE-SCAN）"><a href="#（4）索引范围扫描（INDEX-RANGE-SCAN）" class="headerlink" title="（4）索引范围扫描（INDEX RANGE SCAN）"></a>（4）索引范围扫描（INDEX RANGE SCAN）</h5><ul><li>当扫描的对象是非唯一性索引的情况，where谓词条件为Between、=、&lt;、&gt;等等的情况就是索引范围扫描，注意，可以是等值查询，也可以是范围查询。</li><li>适用于所有类型的B树索引，一般不包括唯一性索引，因为唯一性索引走索引唯一性扫描。</li></ul><p>使用index rang scan的3种情况：</p><ul><li>在唯一索引列上使用了range操作符（&gt; &lt; &lt;&gt; &gt;= &lt;= between）</li><li>在组合索引上，只使用部分列进行查询，导致查询出多行</li><li>对非唯一索引列上进行的任何查询</li></ul><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">explain plan <span class="keyword">for</span> <span class="keyword">select</span> empno，ename <span class="keyword">from</span> emp <span class="keyword">where</span> empno <span class="operator">&gt;</span> <span class="number">7876</span> <span class="keyword">order</span> <span class="keyword">by</span> empno；</span><br><span class="line"></span><br><span class="line">Query Plan</span><br><span class="line"><span class="comment">--------------------------------------------------------------------------------</span></span><br><span class="line"><span class="keyword">SELECT</span> STATEMENT[CHOOSE] Cost<span class="operator">=</span><span class="number">1</span></span><br><span class="line"><span class="keyword">TABLE</span> ACCESS <span class="keyword">BY</span> ROWID EMP [ANALYZED]</span><br><span class="line">INDEX <span class="keyword">RANGE</span> SCAN EMP_I1 [ANALYZED]</span><br></pre></td></tr></table></figure><p><strong>如果where条件里有一个索引键值列没限定为非空的，那就可以走索引范围扫描，如果改索引列是非空的，那就走索引全扫描。</strong></p><p>前面说了，同样的SQL建的索引不同，就可能是走索引唯一性扫描，也有可能走索引范围扫描。在同等的条件下，索引范围扫描所需要的逻辑读和索引唯一性扫描对比，逻辑读如何？索引范围扫描可能返回多条记录，所以优化器为了确认，肯定会多扫描，<strong>所以在同等条件，索引范围扫描所需要的逻辑读至少会比相应的唯一性扫描的逻辑读多1。</strong></p><h5 id="（5）索引全扫描（INDEX-FULL-SCAN）"><a href="#（5）索引全扫描（INDEX-FULL-SCAN）" class="headerlink" title="（5）索引全扫描（INDEX FULL SCAN）"></a>（5）索引全扫描（INDEX FULL SCAN）</h5><ul><li>适用于所有类型的B树索引(包括唯一性索引和非唯一性索引)。</li><li>查询出的数据都必须从索引中可以直接得到。</li><li>索引全扫描是指扫描目标索引所有叶子块的索引行，但不意思着需要扫描所有的分支块，索引全扫描时只需要访问必要的分支块，然后定位到位于改索引最左边的叶子块的第一行索引行，就可以利用改索引叶子块之间的双向指针链表，从左往右依次顺序扫描所有的叶子块的索引行。</li></ul><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">An Index <span class="keyword">full</span> scan will <span class="keyword">not</span> perform single block i<span class="operator">/</span>o<span class="string">&#x27;&#x27;</span>s <span class="keyword">and</span> so it may prove <span class="keyword">to</span> be inefficient. </span><br><span class="line">e.g.</span><br><span class="line"></span><br><span class="line">Index BE_IX <span class="keyword">is</span> a concatenated index <span class="keyword">on</span> big_emp(empno, ename)</span><br><span class="line"></span><br><span class="line">explain plan <span class="keyword">for</span> <span class="keyword">select</span> empno， ename <span class="keyword">from</span> big_emp <span class="keyword">order</span> <span class="keyword">by</span> empno，ename；</span><br><span class="line"></span><br><span class="line">Query Plan</span><br><span class="line"><span class="comment">--------------------------------------------------------------------------------</span></span><br><span class="line"><span class="keyword">SELECT</span> STATEMENT[CHOOSE] Cost<span class="operator">=</span><span class="number">26</span></span><br><span class="line">INDEX <span class="keyword">FULL</span> SCAN BE_IX [ANALYZED]</span><br></pre></td></tr></table></figure><h5 id="（6）索引快速全扫描（INDEX-FAST-FULL-SCAN）"><a href="#（6）索引快速全扫描（INDEX-FAST-FULL-SCAN）" class="headerlink" title="（6）索引快速全扫描（INDEX FAST FULL SCAN）"></a>（6）索引快速全扫描（INDEX FAST FULL SCAN）</h5><ul><li>索引快速全扫描和索引全扫描很类似，也适用于所有类型的B树索引(包括唯一性索引和非唯一性索引)。</li><li>和索引全扫描类似，也是扫描所有叶子块的索引行，这些都是索引快速全扫描和索引全扫描的相同点。</li><li>它不对查询出的数据进行排序，即数据不是以排序顺序被返回。</li><li>可以使用多块读功能，也可以使用并行读入，以便获得最大吞吐量与缩短执行时间。</li></ul><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"># BE_IX索引是一个多列索引： big_emp(empno, ename)</span><br><span class="line"></span><br><span class="line">explain plan <span class="keyword">for</span> <span class="keyword">select</span> empno，ename <span class="keyword">from</span> big_emp；</span><br><span class="line"></span><br><span class="line">Query Plan</span><br><span class="line"><span class="comment">------------------------------------------</span></span><br><span class="line"><span class="keyword">SELECT</span> STATEMENT[CHOOSE] Cost<span class="operator">=</span><span class="number">1</span></span><br><span class="line">INDEX FAST <span class="keyword">FULL</span> SCAN BE_IX [ANALYZED]</span><br><span class="line"></span><br><span class="line"># 只选择多列索引的第<span class="number">2</span>列：</span><br><span class="line">explain plan <span class="keyword">for</span> <span class="keyword">select</span> ename <span class="keyword">from</span> big_emp；</span><br><span class="line"></span><br><span class="line">Query Plan</span><br><span class="line"><span class="comment">------------------------------------------</span></span><br><span class="line"><span class="keyword">SELECT</span> STATEMENT[CHOOSE] Cost<span class="operator">=</span><span class="number">1</span></span><br><span class="line">INDEX FAST <span class="keyword">FULL</span> SCAN BE_IX [ANALYZED]</span><br></pre></td></tr></table></figure><p>索引快速全扫描和索引全扫描区别：</p><ul><li>索引快速全扫描只适应于CBO(基于成本的优化器)</li><li>索引快速全扫描可以使用多块读，也可以并行执行</li><li>索引全扫描会按照叶子块排序返回，而索引快速全扫描则是按照索引段内存储块顺序返回</li><li>索引快速全扫描的执行结果不一定是有序的，而索引全扫描的执行结果是有序的，因为索引快速全扫描是根据索引行在磁盘的物理存储顺序来扫描的，不是根据索引行的逻辑顺序来扫描的</li></ul><h5 id="（7）索引跳跃式扫描（INDEX-SKIP-SCAN）"><a href="#（7）索引跳跃式扫描（INDEX-SKIP-SCAN）" class="headerlink" title="（7）索引跳跃式扫描（INDEX SKIP SCAN）"></a>（7）索引跳跃式扫描（INDEX SKIP SCAN）</h5><p>索引跳跃式扫描(INDEX SKIP SCAN)适用于所有类型的<em><strong>复合B树索引</strong></em>(包括唯一性索引和非唯一性索引)，索引跳跃式扫描可以使那些在where条件中没有目标索引的前导列指定查询条件但是有索引的非前导列指定查询条件的目标SQL依然可以使用跳跃索引。</p><p>如图执行计划就有INDEX RANGE SCAN、 INDEX UNIQUE SCAN 等等：</p><p><img src="https://pic-1258215793.cos.ap-shanghai.myqcloud.com/content/20211001/202110010117.png"></p><h4 id="1-4-4-表连接方式"><a href="#1-4-4-表连接方式" class="headerlink" title="1.4.4 表连接方式"></a>1.4.4 表连接方式</h4><p>如图，执行计划中有如下NESTED LOOPS等，是Oracle中表连接的方法：</p><p><img src="https://pic-1258215793.cos.ap-shanghai.myqcloud.com/content/20211001/202110010118.png"></p><ul><li>Join是一种试图将两个表结合在一起的谓词，一次只能连接2个表，表连接也可以被称为表关联。</li><li>使用row source来代替表的描述更准确，将参与连接的2个row source分别称为row source1和row source 2。</li><li>Join过程的各个步骤经常是串行操作，即使相关的row source可以被并行访问，即可以并行的读取做join连接的两个row source的数据，但是在将表中符合限制条件的数据读入到内存形成row source后，join的其它步骤一般是串行的。</li></ul><p>row source之间的<strong>连接顺序对于查询的效率</strong>有非常大的影响。通过首先存取特定的表，即将该表作为驱动表，这样可以先应用某些限制条件，从而得到一个较小的row source，使连接的效率较高，这也就是我们常说的要先执行限制条件的原因。一般是在将表读入内存时，应用where子句中对该表的限制条件。</p><p>表连接方式：</p><ul><li><strong>排序合并连接（sort merge join）</strong> ：先将关联表的关联列各自做排序，然后从各自的排序表中抽取数据，到另一个排序表中做匹配。<ul><li> 对于非等值连接，这种连接方式的效率是比较高的。</li><li>如果在关联的列上都有索引，效果更好。</li><li>对于将2个较大的row source做连接，该连接方法比NL连接要好一些。</li><li>但是如果sort merge返回的row source过大，则又会导致使用过多的rowid在表中查询数据时，数据库性能下降，因为过多的I/O。</li></ul></li><li><strong>嵌套循环连接（Nested loop join）</strong>：Nested loops 工作方式是循环从一张表中读取数据(驱动表outer table)，然后访问另一张表（被查找表 inner table,通常有索引）。驱动表中的每一行与inner表中的相应记录JOIN。类似一个嵌套的循环。<strong>对于被连接的数据子集较小的情况，nested loop连接是个较好的选择</strong>。<ul><li>如果driving row source（外部表）比较小，并且在inner row source（内部表）上有唯一索引，或有高选择性非唯一索引时，使用这种方法可以得到较好的效率。</li><li>NESTED LOOPS有其它连接方法没有的的一个优点是：可以先返回已经连接的行，而不必等待所有的连接操作处理完才返回数据，这可以实现快速的响应时间。</li></ul></li><li><strong>哈希连接（Hash join）</strong>：散列连接是CBO 做<a href="https://cloud.tencent.com/solution/bigdata?from=10680">大数据</a>集连接时的常用方式，优化器使用两个表中较小的表（或数据源）利用连接键在内存中建立散列表，然后扫描较大的表并探测散列表，找出与散列表匹配的行。 <ul><li>这种方法是在oracle7后来引入的，使用了比较先进的连接理论，一般来说，其效率应该好于其它2种连接，但是这种连接只能用在CBO优化器中，而且需要设置合适的hash_area_size参数，才能取得较好的性能。</li><li>在2个较大的row source之间连接时会取得相对较好的效率，在一个row source较小时则能取得更好的效率。</li><li>只能用于等值连接中</li></ul></li><li><strong>笛卡尔连接（Cross join）</strong>：如果两个表做表连接而没有连接条件，而会产生笛卡尔积，在实际工作中应该尽可能避免笛卡尔积。</li></ul><h5 id="（1）排序合并连接（sort-merge-join）"><a href="#（1）排序合并连接（sort-merge-join）" class="headerlink" title="（1）排序合并连接（sort merge join）"></a>（1）排序合并连接（sort merge join）</h5><p>内部连接过程：</p><ol><li>首先生成row source1需要的数据，然后对这些数据按照连接操作关联列（如A.col3）进行排序。</li><li>随后生成row source2需要的数据，然后对这些数据按照与sort source1对应的连接操作关联列（如B.col4）进行排序。</li><li>最后两边已排序的行被放在一起执行合并操作，即将2个row source按照连接条件连接起来。</li></ol><p>如果row source已经在连接关联列上被排序，则该连接操作就不需要再进行sort操作，这样可以大大提高这种连接操作的连接速度，因为排序是个极其费资源的操作，特别是对于较大的表。</p><p>预先排序的row source包括已经被索引的列（如a.col3或b.col4上有索引）或row source已经在前面的步骤中被排序了。</p><p>尽管合并两个row source的过程是串行的，但是可以并行访问这两个row source（如并行读入数据，并行排序）。</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">explain plan <span class="keyword">for</span></span><br><span class="line"><span class="keyword">select</span> <span class="comment">/*+ ordered */</span> e.deptno， d.deptno</span><br><span class="line"><span class="keyword">from</span> emp e， dept d</span><br><span class="line"><span class="keyword">where</span> e.deptno <span class="operator">=</span> d.deptno</span><br><span class="line"><span class="keyword">order</span> <span class="keyword">by</span> e.deptno， d.deptno；</span><br><span class="line"></span><br><span class="line">Query Plan</span><br><span class="line"><span class="comment">-------------------------------------</span></span><br><span class="line"><span class="keyword">SELECT</span> STATEMENT [CHOOSE] Cost<span class="operator">=</span><span class="number">17</span></span><br><span class="line"><span class="keyword">MERGE</span> <span class="keyword">JOIN</span></span><br><span class="line">SORT <span class="keyword">JOIN</span></span><br><span class="line"><span class="keyword">TABLE</span> ACCESS <span class="keyword">FULL</span> EMP [ANALYZED]</span><br><span class="line">SORT <span class="keyword">JOIN</span></span><br><span class="line"><span class="keyword">TABLE</span> ACCESS <span class="keyword">FULL</span> DEPT [ANALYZED]</span><br></pre></td></tr></table></figure><p>排序是一个费时、费资源的操作，特别对于大表。基于这个原因，SMJ经常不是一个特别有效的连接方法，但是如果2个row source都已经预先排序，则这种连接方法的效率也是蛮高的。</p><h5 id="（2）嵌套循环连接（Nested-loop-join）"><a href="#（2）嵌套循环连接（Nested-loop-join）" class="headerlink" title="（2）嵌套循环连接（Nested loop join）"></a>（2）嵌套循环连接（Nested loop join）</h5><p>这个连接方法有驱动表（外部表）的概念。其实，该连接过程就是一个2层嵌套循环，所以外层循环的次数越少越好，这也就是我们为什么将小表或返回较小row source的表作为驱动表（用于外层循环）的理论依据。</p><p>但是这个理论只是一般指导原则，因为遵循这个理论并不能总保证使语句产生的I/O次数最少。有时不遵守这个理论依据，反而会获得更好的效率。如果使用这种方法，决定使用哪个表作为驱动表很重要。有时如果驱动表选择不正确，将会导致语句的性能很差。</p><p>内部连接过程：</p><ul><li>Row source1的Row 1 —— Probe -&gt;Row source 2</li><li>Row source1的Row 2 —— Probe -&gt;Row source 2</li><li>Row source1的Row 3 —— Probe -&gt;Row source 2</li><li>……</li><li>Row source1的Row n —— Probe -&gt;Row source 2</li></ul><p>从内部连接过程来看，需要用row source1中的每一行，去匹配row source2中的所有行，所以此时保持row source1尽可能的小与高效的访问row source2（一般通过索引实现）是影响这个连接效率的关键问题。</p><p>这只是理论指导原则，目的是使整个连接操作产生最少的物理I/O次数，而且如果遵守这个原则，一般也会使总的物理I/O数最少。但是如果不遵从这个指导原则，反而能用更少的物理I/O实现连接操作，那尽管违反指导原则吧！因为最少的物理 I/O次数才是我们应该遵从的真正的指导原则。</p><p>在NESTED LOOPS连接中，Oracle读取row source1中的每一行，然后在row sourc2中检查是否有匹配的行，所有被匹配的行都被放到结果集中，然后处理row source1中的下一行。这个过程一直继续，直到row source1中的所有行都被处理。这是从连接操作中可以得到第一个匹配行的最快的方法之一，这种类型的连接可以用在需要快速响应的语句中，以响应速度为主要目标。</p><p>如果driving row source（外部表）比较小，并且在inner row source（内部表）上有唯一索引，或有高选择性非唯一索引时，使用这种方法可以得到较好的效率。</p><p>NESTED LOOPS有其它连接方法没有的的一个优点是：可以先返回已经连接的行，而不必等待所有的连接操作处理完才返回数据，这可以实现快速的响应时间。</p><p>如果不使用并行操作，最好的驱动表是那些应用了where限制条件后，可以返回较少行数据的的表，所以大表也可能称为驱动表，关键看限制条件。</p><p>对于并行查询，我们经常选择大表作为驱动表，因为大表可以充分利用并行功能。当然，有时对查询使用并行操作并不一定会比查询不使用并行操作效率高，因为最后可能每个表只有很少的行符合限制条件，而且还要看你的硬件配置是否 可以支持并行（如是否有多个CPU，多个硬盘控制器），所以要具体问题具体对待。</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">explain plan <span class="keyword">for</span></span><br><span class="line"><span class="keyword">select</span> a.dname，b.sql</span><br><span class="line"><span class="keyword">from</span> dept a，emp b</span><br><span class="line"><span class="keyword">where</span> a.deptno <span class="operator">=</span> b.deptno；</span><br><span class="line"></span><br><span class="line">Query Plan</span><br><span class="line"><span class="comment">-------------------------</span></span><br><span class="line"><span class="keyword">SELECT</span> STATEMENT [CHOOSE] Cost<span class="operator">=</span><span class="number">5</span></span><br><span class="line">NESTED LOOPS</span><br><span class="line"><span class="keyword">TABLE</span> ACCESS <span class="keyword">FULL</span> DEPT [ANALYZED]</span><br><span class="line"><span class="keyword">TABLE</span> ACCESS <span class="keyword">FULL</span> EMP [ANALYZED]</span><br></pre></td></tr></table></figure><h5 id="（3）哈希连接（Hash-join）"><a href="#（3）哈希连接（Hash-join）" class="headerlink" title="（3）哈希连接（Hash join）"></a>（3）哈希连接（Hash join）</h5><p>这种连接是在oracle 7.3以后引入的，从理论上来说比NL与SMJ更高效，而且只用在CBO优化器中。</p><p>较小的row source被用来构建hash table与bitmap，第2个row source被用来被hansed，并与第一个row source生成的hash table进行匹配，以便进行进一步的连接。</p><p>内部连接过程：</p><ul><li>取出 row source 1（驱动表，在HASH JOIN中又称为Build Table） 的数据集，然后将其构建成内存中的一个 Hash Table（Hash函数的Hash KEY就是连接操作关联列），创建Hash位图（bitmap）</li><li>取出 row source 2（匹配表）的数据集，对其中的每一条数据的连接操作关联列使用相同的Hash函数并找到对应的 a) 里的数据在 Hash Table 中的位置，在该位置上检查能否找到匹配的数据</li></ul><p>Bitmap被用来作为一种比较快的查找方法，来检查在hash table中是否有匹配的行。特别的，当hash table比较大而不能全部容纳在内存中时，这种查找方法更为有用。</p><p>这种连接方法也有NL连接中所谓的驱动表的概念，被构建为hash table与bitmap的表为驱动表，当被构建的hash table与bitmap能被容纳在内存中时，这种连接方式的效率极高。</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">explain plan <span class="keyword">for</span></span><br><span class="line"><span class="keyword">select</span> <span class="comment">/*+ use_hash（emp） */</span> empno</span><br><span class="line"><span class="keyword">from</span> emp, dept</span><br><span class="line"><span class="keyword">where</span> emp.deptno <span class="operator">=</span> dept.deptno；</span><br><span class="line"></span><br><span class="line">Query Plan</span><br><span class="line"><span class="comment">----------------------------</span></span><br><span class="line"><span class="keyword">SELECT</span> STATEMENT[CHOOSE] Cost<span class="operator">=</span><span class="number">3</span></span><br><span class="line">HASH <span class="keyword">JOIN</span></span><br><span class="line"><span class="keyword">TABLE</span> ACCESS <span class="keyword">FULL</span> DEPT</span><br><span class="line"><span class="keyword">TABLE</span> ACCESS <span class="keyword">FULL</span> EMP</span><br></pre></td></tr></table></figure><p>要使哈希连接有效，需要设置HASH_JOIN_ENABLED=TRUE，缺省情况下该参数为TRUE，另外，不要忘了还要设置 hash_area_size参数，以使哈希连接高效运行，因为哈希连接会在该参数指定大小的内存中运行，过小的参数会使哈希连接的性能比其他连接方式还要低。</p><h5 id="（4）笛卡尔连接（Cross-join）"><a href="#（4）笛卡尔连接（Cross-join）" class="headerlink" title="（4）笛卡尔连接（Cross join）"></a>（4）笛卡尔连接（Cross join）</h5><p>当两个row source做连接，但是它们之间没有关联条件时，就会在两个row source中做笛卡儿乘积，这通常由编写代码疏漏造成（即程序员忘了写关联条件）。</p><p>笛卡尔乘积是一个表的每一行依次与另一个表中的所有行匹配。在特殊情况下我们可以使用笛卡儿乘积，如在星形连接中，除此之外，我们要尽量不使用笛卡儿乘积。</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">explain plan <span class="keyword">for</span></span><br><span class="line"><span class="keyword">select</span> emp.deptno，dept，deptno</span><br><span class="line"><span class="keyword">from</span> emp，dept</span><br><span class="line"></span><br><span class="line">Query Plan</span><br><span class="line"><span class="comment">------------------------</span></span><br><span class="line"><span class="keyword">SELECT</span> STATEMENT [CHOOSE] Cost<span class="operator">=</span><span class="number">5</span></span><br><span class="line"><span class="keyword">MERGE</span> <span class="keyword">JOIN</span> CARTESIAN</span><br><span class="line"><span class="keyword">TABLE</span> ACCESS <span class="keyword">FULL</span> DEPT</span><br><span class="line">SORT <span class="keyword">JOIN</span></span><br><span class="line"><span class="keyword">TABLE</span> ACCESS <span class="keyword">FULL</span> EMP</span><br></pre></td></tr></table></figure><p>CARTESIAN关键字指出了在2个表之间做笛卡尔乘积。假如表emp有n行，dept表有m行，笛卡尔乘积的结果就是得到n * m行结果。</p><h4 id="1-4-5-explain参数信息"><a href="#1-4-5-explain参数信息" class="headerlink" title="1.4.5 explain参数信息"></a>1.4.5 explain参数信息</h4><p>执行计划关键信息介绍：</p><ul><li>Starts：该SQL执行的次数</li><li>E-Rows：为执行计划预计的行数</li><li><a href="http://www.itpub.net/forum.php?mod=viewthread&tid=1264620&highlight=">Cost (%CPU)</a>：CPU cost在整个cost中占的百分比</li><li>A-Rows：实际返回的行数，E-Rows和A-Rows作比较，就可以看出具体那一步执行计划出问题了</li><li>A-Time：每一步实际执行的时间，可以看出耗时的SQL</li><li>Buffers：每一步实际执行的逻辑读或一致性读</li></ul><p><img src="https://pic-1258215793.cos.ap-shanghai.myqcloud.com/content/20211001/202110010119.png"></p><h2 id="二-MySQL"><a href="#二-MySQL" class="headerlink" title="二. MySQL"></a>二. MySQL</h2><h3 id="2-1-使用explain"><a href="#2-1-使用explain" class="headerlink" title="2.1 使用explain"></a>2.1 使用explain</h3><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">mysql<span class="operator">&gt;</span> explain <span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> actor;</span><br><span class="line"><span class="operator">+</span><span class="comment">----+-------------+-------+------+---------------+------+---------+------+------+-------+</span></span><br><span class="line"><span class="operator">|</span> id <span class="operator">|</span> select_type <span class="operator">|</span> <span class="keyword">table</span> <span class="operator">|</span> type <span class="operator">|</span> possible_keys <span class="operator">|</span> key  <span class="operator">|</span> key_len <span class="operator">|</span> <span class="keyword">ref</span>  <span class="operator">|</span> <span class="keyword">rows</span> <span class="operator">|</span> Extra <span class="operator">|</span></span><br><span class="line"><span class="operator">+</span><span class="comment">----+-------------+-------+------+---------------+------+---------+------+------+-------+</span></span><br><span class="line"><span class="operator">|</span>  <span class="number">1</span> <span class="operator">|</span> SIMPLE      <span class="operator">|</span> actor <span class="operator">|</span> <span class="keyword">ALL</span>  <span class="operator">|</span> <span class="keyword">NULL</span>          <span class="operator">|</span> <span class="keyword">NULL</span> <span class="operator">|</span> <span class="keyword">NULL</span>    <span class="operator">|</span> <span class="keyword">NULL</span> <span class="operator">|</span>    <span class="number">2</span> <span class="operator">|</span> <span class="keyword">NULL</span>  <span class="operator">|</span></span><br><span class="line"><span class="operator">+</span><span class="comment">----+-------------+-------+------+---------------+------+---------+------+------+-------+</span></span><br></pre></td></tr></table></figure><p>explain有两个变种：</p><ul><li><strong>explain extended</strong>：额外提供一些查询优化的信息，并且紧随使用 <code>show warnings</code> 命令可以得到优化后的查询语句。filtered列表示估算出将要和explain中前一个表进行连接的行数、</li><li><strong>explain partitions</strong>：当查询基于分区表会显示查询将访问的分区。</li></ul><h3 id="2-2-返回列"><a href="#2-2-返回列" class="headerlink" title="2.2 返回列"></a>2.2 返回列</h3><h4 id="（1）id"><a href="#（1）id" class="headerlink" title="（1）id"></a>（1）id</h4><p>表示select的序列号，有几个select就有几个id，id顺序即select的出现顺序。</p><ul><li><p>简单查询。</p></li><li><p>复杂查询：</p><ul><li><p>简单子查询：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">mysql<span class="operator">&gt;</span> explain <span class="keyword">select</span> (<span class="keyword">select</span> <span class="number">1</span> <span class="keyword">from</span> actor limit <span class="number">1</span>) <span class="keyword">from</span> film;</span><br><span class="line"><span class="operator">+</span><span class="comment">----+-------------+-------+-------+---------------+----------+---------+------+------+-------------+</span></span><br><span class="line"><span class="operator">|</span> id <span class="operator">|</span> select_type <span class="operator">|</span> <span class="keyword">table</span> <span class="operator">|</span> type  <span class="operator">|</span> possible_keys <span class="operator">|</span> key      <span class="operator">|</span> key_len <span class="operator">|</span> <span class="keyword">ref</span>  <span class="operator">|</span> <span class="keyword">rows</span> <span class="operator">|</span> Extra       <span class="operator">|</span></span><br><span class="line"><span class="operator">+</span><span class="comment">----+-------------+-------+-------+---------------+----------+---------+------+------+-------------+</span></span><br><span class="line"><span class="operator">|</span>  <span class="number">1</span> <span class="operator">|</span> <span class="keyword">PRIMARY</span>     <span class="operator">|</span> film  <span class="operator">|</span> index <span class="operator">|</span> <span class="keyword">NULL</span>          <span class="operator">|</span> idx_name <span class="operator">|</span> <span class="number">32</span>      <span class="operator">|</span> <span class="keyword">NULL</span> <span class="operator">|</span>    <span class="number">1</span> <span class="operator">|</span> <span class="keyword">Using</span> index <span class="operator">|</span></span><br><span class="line"><span class="operator">|</span>  <span class="number">2</span> <span class="operator">|</span> SUBQUERY    <span class="operator">|</span> actor <span class="operator">|</span> index <span class="operator">|</span> <span class="keyword">NULL</span>          <span class="operator">|</span> <span class="keyword">PRIMARY</span>  <span class="operator">|</span> <span class="number">4</span>       <span class="operator">|</span> <span class="keyword">NULL</span> <span class="operator">|</span>    <span class="number">2</span> <span class="operator">|</span> <span class="keyword">Using</span> index <span class="operator">|</span></span><br><span class="line"><span class="operator">+</span><span class="comment">----+-------------+-------+-------+---------------+----------+---------+------+------+-------------+ </span></span><br></pre></td></tr></table></figure></li><li><p>派生表（from语句中的子查询）：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">mysql<span class="operator">&gt;</span> explain <span class="keyword">select</span> id <span class="keyword">from</span> (<span class="keyword">select</span> id <span class="keyword">from</span> film) <span class="keyword">as</span> der;</span><br><span class="line"><span class="operator">+</span><span class="comment">----+-------------+------------+-------+---------------+----------+---------+------+------+-------------+</span></span><br><span class="line"><span class="operator">|</span> id <span class="operator">|</span> select_type <span class="operator">|</span> <span class="keyword">table</span>      <span class="operator">|</span> type  <span class="operator">|</span> possible_keys <span class="operator">|</span> key      <span class="operator">|</span> key_len <span class="operator">|</span> <span class="keyword">ref</span>  <span class="operator">|</span> <span class="keyword">rows</span> <span class="operator">|</span> Extra       <span class="operator">|</span></span><br><span class="line"><span class="operator">+</span><span class="comment">----+-------------+------------+-------+---------------+----------+---------+------+------+-------------+</span></span><br><span class="line"><span class="operator">|</span>  <span class="number">1</span> <span class="operator">|</span> <span class="keyword">PRIMARY</span>     <span class="operator">|</span> <span class="operator">&lt;</span>derived2<span class="operator">&gt;</span> <span class="operator">|</span> <span class="keyword">ALL</span>   <span class="operator">|</span> <span class="keyword">NULL</span>          <span class="operator">|</span> <span class="keyword">NULL</span>     <span class="operator">|</span> <span class="keyword">NULL</span>    <span class="operator">|</span> <span class="keyword">NULL</span> <span class="operator">|</span>    <span class="number">2</span> <span class="operator">|</span> <span class="keyword">NULL</span>        <span class="operator">|</span></span><br><span class="line"><span class="operator">|</span>  <span class="number">2</span> <span class="operator">|</span> DERIVED     <span class="operator">|</span> film       <span class="operator">|</span> index <span class="operator">|</span> <span class="keyword">NULL</span>          <span class="operator">|</span> idx_name <span class="operator">|</span> <span class="number">32</span>      <span class="operator">|</span> <span class="keyword">NULL</span> <span class="operator">|</span>    <span class="number">1</span> <span class="operator">|</span> <span class="keyword">Using</span> index <span class="operator">|</span></span><br><span class="line"><span class="operator">+</span><span class="comment">----+-------------+------------+-------+---------------+----------+---------+------+------+-------------+</span></span><br></pre></td></tr></table></figure></li><li><p>union查询：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">mysql<span class="operator">&gt;</span> explain <span class="keyword">select</span> <span class="number">1</span> <span class="keyword">union</span> <span class="keyword">all</span> <span class="keyword">select</span> <span class="number">1</span>;</span><br><span class="line"><span class="operator">+</span><span class="comment">----+--------------+------------+------+---------------+------+---------+------+------+-----------------+</span></span><br><span class="line"><span class="operator">|</span> id <span class="operator">|</span> select_type  <span class="operator">|</span> <span class="keyword">table</span>      <span class="operator">|</span> type <span class="operator">|</span> possible_keys <span class="operator">|</span> key  <span class="operator">|</span> key_len <span class="operator">|</span> <span class="keyword">ref</span>  <span class="operator">|</span> <span class="keyword">rows</span> <span class="operator">|</span> Extra           <span class="operator">|</span></span><br><span class="line"><span class="operator">+</span><span class="comment">----+--------------+------------+------+---------------+------+---------+------+------+-----------------+</span></span><br><span class="line"><span class="operator">|</span>  <span class="number">1</span> <span class="operator">|</span> <span class="keyword">PRIMARY</span>      <span class="operator">|</span> <span class="keyword">NULL</span>       <span class="operator">|</span> <span class="keyword">NULL</span> <span class="operator">|</span> <span class="keyword">NULL</span>          <span class="operator">|</span> <span class="keyword">NULL</span> <span class="operator">|</span> <span class="keyword">NULL</span>    <span class="operator">|</span> <span class="keyword">NULL</span> <span class="operator">|</span> <span class="keyword">NULL</span> <span class="operator">|</span> <span class="keyword">No</span> tables used  <span class="operator">|</span></span><br><span class="line"><span class="operator">|</span>  <span class="number">2</span> <span class="operator">|</span> <span class="keyword">UNION</span>        <span class="operator">|</span> <span class="keyword">NULL</span>       <span class="operator">|</span> <span class="keyword">NULL</span> <span class="operator">|</span> <span class="keyword">NULL</span>          <span class="operator">|</span> <span class="keyword">NULL</span> <span class="operator">|</span> <span class="keyword">NULL</span>    <span class="operator">|</span> <span class="keyword">NULL</span> <span class="operator">|</span> <span class="keyword">NULL</span> <span class="operator">|</span> <span class="keyword">No</span> tables used  <span class="operator">|</span></span><br><span class="line"><span class="operator">|</span> <span class="keyword">NULL</span> <span class="operator">|</span> <span class="keyword">UNION</span> <span class="keyword">RESULT</span> <span class="operator">|</span> <span class="operator">&lt;</span>union1,<span class="number">2</span><span class="operator">&gt;</span> <span class="operator">|</span> <span class="keyword">ALL</span>  <span class="operator">|</span> <span class="keyword">NULL</span>          <span class="operator">|</span> <span class="keyword">NULL</span> <span class="operator">|</span> <span class="keyword">NULL</span>    <span class="operator">|</span> <span class="keyword">NULL</span> <span class="operator">|</span> <span class="keyword">NULL</span> <span class="operator">|</span> <span class="keyword">Using</span> temporary <span class="operator">|</span></span><br><span class="line"><span class="operator">+</span><span class="comment">----+--------------+------------+------+---------------+------+---------+------+------+-----------------+</span></span><br></pre></td></tr></table></figure><p>union结果总是放在一个匿名临时表中，临时表不在SQL总出现，因此它的id是NULL。</p></li></ul></li></ul><h4 id="（2）select-type"><a href="#（2）select-type" class="headerlink" title="（2）select_type"></a>（2）select_type</h4><p>表示对应行是是简单还是复杂的查询，如果是复杂的查询，又是上述三种复杂查询中的哪一种。</p><ul><li><p><strong>simple</strong>：简单查询，查询不包含子查询和union。</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">mysql<span class="operator">&gt;</span> explain <span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> film <span class="keyword">where</span> id <span class="operator">=</span> <span class="number">2</span>;</span><br><span class="line"><span class="operator">+</span><span class="comment">----+-------------+-------+-------+---------------+---------+---------+-------+------+-------+</span></span><br><span class="line"><span class="operator">|</span> id <span class="operator">|</span> select_type <span class="operator">|</span> <span class="keyword">table</span> <span class="operator">|</span> type  <span class="operator">|</span> possible_keys <span class="operator">|</span> key     <span class="operator">|</span> key_len <span class="operator">|</span> <span class="keyword">ref</span>   <span class="operator">|</span> <span class="keyword">rows</span> <span class="operator">|</span> Extra <span class="operator">|</span></span><br><span class="line"><span class="operator">+</span><span class="comment">----+-------------+-------+-------+---------------+---------+---------+-------+------+-------+</span></span><br><span class="line"><span class="operator">|</span>  <span class="number">1</span> <span class="operator">|</span> SIMPLE      <span class="operator">|</span> film  <span class="operator">|</span> const <span class="operator">|</span> <span class="keyword">PRIMARY</span>       <span class="operator">|</span> <span class="keyword">PRIMARY</span> <span class="operator">|</span> <span class="number">4</span>       <span class="operator">|</span> const <span class="operator">|</span>    <span class="number">1</span> <span class="operator">|</span> <span class="keyword">NULL</span>  <span class="operator">|</span></span><br><span class="line"><span class="operator">+</span><span class="comment">----+-------------+-------+-------+---------------+---------+---------+-------+------+-------+</span></span><br></pre></td></tr></table></figure></li><li><p><strong>primary</strong>：复杂查询中最外层的 select。</p></li><li><p><strong>subquery</strong>：包含在 select 中的子查询（不在 from 子句中）。</p></li><li><p><strong>derived</strong>：包含在 from 子句中的子查询。MySQL会将结果存放在一个临时表中，也称为派生表（derived的英文含义）。</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">mysql<span class="operator">&gt;</span> explain <span class="keyword">select</span> (<span class="keyword">select</span> <span class="number">1</span> <span class="keyword">from</span> actor <span class="keyword">where</span> id <span class="operator">=</span> <span class="number">1</span>) <span class="keyword">from</span> (<span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> film <span class="keyword">where</span> id <span class="operator">=</span> <span class="number">1</span>) der;</span><br><span class="line"><span class="operator">+</span><span class="comment">----+-------------+------------+--------+---------------+---------+---------+-------+------+-------------+</span></span><br><span class="line"><span class="operator">|</span> id <span class="operator">|</span> select_type <span class="operator">|</span> <span class="keyword">table</span>      <span class="operator">|</span> type   <span class="operator">|</span> possible_keys <span class="operator">|</span> key     <span class="operator">|</span> key_len <span class="operator">|</span> <span class="keyword">ref</span>   <span class="operator">|</span> <span class="keyword">rows</span> <span class="operator">|</span> Extra       <span class="operator">|</span></span><br><span class="line"><span class="operator">+</span><span class="comment">----+-------------+------------+--------+---------------+---------+---------+-------+------+-------------+</span></span><br><span class="line"><span class="operator">|</span>  <span class="number">1</span> <span class="operator">|</span> <span class="keyword">PRIMARY</span>     <span class="operator">|</span> <span class="operator">&lt;</span>derived3<span class="operator">&gt;</span> <span class="operator">|</span> <span class="keyword">system</span> <span class="operator">|</span> <span class="keyword">NULL</span>          <span class="operator">|</span> <span class="keyword">NULL</span>    <span class="operator">|</span> <span class="keyword">NULL</span>    <span class="operator">|</span> <span class="keyword">NULL</span>  <span class="operator">|</span>    <span class="number">1</span> <span class="operator">|</span> <span class="keyword">NULL</span>        <span class="operator">|</span></span><br><span class="line"><span class="operator">|</span>  <span class="number">3</span> <span class="operator">|</span> DERIVED     <span class="operator">|</span> film       <span class="operator">|</span> const  <span class="operator">|</span> <span class="keyword">PRIMARY</span>       <span class="operator">|</span> <span class="keyword">PRIMARY</span> <span class="operator">|</span> <span class="number">4</span>       <span class="operator">|</span> const <span class="operator">|</span>    <span class="number">1</span> <span class="operator">|</span> <span class="keyword">NULL</span>        <span class="operator">|</span></span><br><span class="line"><span class="operator">|</span>  <span class="number">2</span> <span class="operator">|</span> SUBQUERY    <span class="operator">|</span> actor      <span class="operator">|</span> const  <span class="operator">|</span> <span class="keyword">PRIMARY</span>       <span class="operator">|</span> <span class="keyword">PRIMARY</span> <span class="operator">|</span> <span class="number">4</span>       <span class="operator">|</span> const <span class="operator">|</span>    <span class="number">1</span> <span class="operator">|</span> <span class="keyword">Using</span> index <span class="operator">|</span></span><br><span class="line"><span class="operator">+</span><span class="comment">----+-------------+------------+--------+---------------+---------+---------+-------+------+-------------+ </span></span><br></pre></td></tr></table></figure></li><li><p><strong>union</strong>：在 union 中的第二个和随后的 select。</p></li><li><p><strong>union result</strong>：从 union 临时表检索结果的 select</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">mysql<span class="operator">&gt;</span> explain <span class="keyword">select</span> <span class="number">1</span> <span class="keyword">union</span> <span class="keyword">all</span> <span class="keyword">select</span> <span class="number">1</span>;</span><br><span class="line"><span class="operator">+</span><span class="comment">----+--------------+------------+------+---------------+------+---------+------+------+-----------------+</span></span><br><span class="line"><span class="operator">|</span> id <span class="operator">|</span> select_type  <span class="operator">|</span> <span class="keyword">table</span>      <span class="operator">|</span> type <span class="operator">|</span> possible_keys <span class="operator">|</span> key  <span class="operator">|</span> key_len <span class="operator">|</span> <span class="keyword">ref</span>  <span class="operator">|</span> <span class="keyword">rows</span> <span class="operator">|</span> Extra           <span class="operator">|</span></span><br><span class="line"><span class="operator">+</span><span class="comment">----+--------------+------------+------+---------------+------+---------+------+------+-----------------+</span></span><br><span class="line"><span class="operator">|</span>  <span class="number">1</span> <span class="operator">|</span> <span class="keyword">PRIMARY</span>      <span class="operator">|</span> <span class="keyword">NULL</span>       <span class="operator">|</span> <span class="keyword">NULL</span> <span class="operator">|</span> <span class="keyword">NULL</span>          <span class="operator">|</span> <span class="keyword">NULL</span> <span class="operator">|</span> <span class="keyword">NULL</span>    <span class="operator">|</span> <span class="keyword">NULL</span> <span class="operator">|</span> <span class="keyword">NULL</span> <span class="operator">|</span> <span class="keyword">No</span> tables used  <span class="operator">|</span></span><br><span class="line"><span class="operator">|</span>  <span class="number">2</span> <span class="operator">|</span> <span class="keyword">UNION</span>        <span class="operator">|</span> <span class="keyword">NULL</span>       <span class="operator">|</span> <span class="keyword">NULL</span> <span class="operator">|</span> <span class="keyword">NULL</span>          <span class="operator">|</span> <span class="keyword">NULL</span> <span class="operator">|</span> <span class="keyword">NULL</span>    <span class="operator">|</span> <span class="keyword">NULL</span> <span class="operator">|</span> <span class="keyword">NULL</span> <span class="operator">|</span> <span class="keyword">No</span> tables used  <span class="operator">|</span></span><br><span class="line"><span class="operator">|</span> <span class="keyword">NULL</span> <span class="operator">|</span> <span class="keyword">UNION</span> <span class="keyword">RESULT</span> <span class="operator">|</span> <span class="operator">&lt;</span>union1,<span class="number">2</span><span class="operator">&gt;</span> <span class="operator">|</span> <span class="keyword">ALL</span>  <span class="operator">|</span> <span class="keyword">NULL</span>          <span class="operator">|</span> <span class="keyword">NULL</span> <span class="operator">|</span> <span class="keyword">NULL</span>    <span class="operator">|</span> <span class="keyword">NULL</span> <span class="operator">|</span> <span class="keyword">NULL</span> <span class="operator">|</span> <span class="keyword">Using</span> temporary <span class="operator">|</span></span><br><span class="line"><span class="operator">+</span><span class="comment">----+--------------+------------+------+---------------+------+---------+------+------+-----------------+</span></span><br></pre></td></tr></table></figure></li></ul><h4 id="（3）table"><a href="#（3）table" class="headerlink" title="（3）table"></a>（3）table</h4><p>表示 explain 的一行正在访问哪个表。</p><ul><li>当 from 子句中有子查询时，table列是 <code>&lt;derivenN&gt;</code> 格式，表示当前查询依赖 id=N 的查询，于是先执行 id=N 的查询。</li><li>当有 union 时，UNION RESULT 的 table 列的值为 <code>&lt;union1,2&gt;</code> ，1和2表示参与 union 的 select 行id。</li></ul><h4 id="（4）type"><a href="#（4）type" class="headerlink" title="（4）type"></a>（4）type</h4><p>这一列表示<strong>关联类型</strong>或<strong>访问类型</strong>，即MySQL决定如何查找表中的行。</p><p>从最优到最差分别为：system &gt; const &gt; eq_ref &gt; ref &gt; fulltext &gt; ref_or_null &gt; index_merge &gt; unique_subquery &gt; index_subquery &gt; range &gt; index &gt; ALL</p><ul><li><p><strong>NULL</strong>：mysql能够在优化阶段分解查询语句，在执行阶段用不着再访问表或索引。例如：在索引列中选取最小值，可以单独查找索引来完成，不需要在执行时访问表。</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">mysql<span class="operator">&gt;</span> explain <span class="keyword">select</span> <span class="built_in">min</span>(id) <span class="keyword">from</span> film;</span><br><span class="line"><span class="operator">+</span><span class="comment">----+-------------+-------+------+---------------+------+---------+------+------+------------------------------+</span></span><br><span class="line"><span class="operator">|</span> id <span class="operator">|</span> select_type <span class="operator">|</span> <span class="keyword">table</span> <span class="operator">|</span> type <span class="operator">|</span> possible_keys <span class="operator">|</span> key  <span class="operator">|</span> key_len <span class="operator">|</span> <span class="keyword">ref</span>  <span class="operator">|</span> <span class="keyword">rows</span> <span class="operator">|</span> Extra                        <span class="operator">|</span></span><br><span class="line"><span class="operator">+</span><span class="comment">----+-------------+-------+------+---------------+------+---------+------+------+------------------------------+</span></span><br><span class="line"><span class="operator">|</span>  <span class="number">1</span> <span class="operator">|</span> SIMPLE      <span class="operator">|</span> <span class="keyword">NULL</span>  <span class="operator">|</span> <span class="keyword">NULL</span> <span class="operator">|</span> <span class="keyword">NULL</span>          <span class="operator">|</span> <span class="keyword">NULL</span> <span class="operator">|</span> <span class="keyword">NULL</span>    <span class="operator">|</span> <span class="keyword">NULL</span> <span class="operator">|</span> <span class="keyword">NULL</span> <span class="operator">|</span> <span class="keyword">Select</span> tables optimized away <span class="operator">|</span></span><br><span class="line"><span class="operator">+</span><span class="comment">----+-------------+-------+------+---------------+------+---------+------+------+------------------------------+</span></span><br></pre></td></tr></table></figure></li><li><p><strong>const / system</strong>：mysql能对查询的某部分进行优化并将其转化成一个常量（可以看show warnings 的结果）。用于 primary key 或 unique key 的所有列与常数比较时，所以表最多有一个匹配行，读取1次，速度比较快。</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">mysql<span class="operator">&gt;</span> explain extended <span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> (<span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> film <span class="keyword">where</span> id <span class="operator">=</span> <span class="number">1</span>) tmp;</span><br><span class="line"><span class="operator">+</span><span class="comment">----+-------------+------------+--------+---------------+---------+---------+-------+------+----------+-------+</span></span><br><span class="line"><span class="operator">|</span> id <span class="operator">|</span> select_type <span class="operator">|</span> <span class="keyword">table</span>      <span class="operator">|</span> type   <span class="operator">|</span> possible_keys <span class="operator">|</span> key     <span class="operator">|</span> key_len <span class="operator">|</span> <span class="keyword">ref</span>   <span class="operator">|</span> <span class="keyword">rows</span> <span class="operator">|</span> filtered <span class="operator">|</span> Extra <span class="operator">|</span></span><br><span class="line"><span class="operator">+</span><span class="comment">----+-------------+------------+--------+---------------+---------+---------+-------+------+----------+-------+</span></span><br><span class="line"><span class="operator">|</span>  <span class="number">1</span> <span class="operator">|</span> <span class="keyword">PRIMARY</span>     <span class="operator">|</span> <span class="operator">&lt;</span>derived2<span class="operator">&gt;</span> <span class="operator">|</span> <span class="keyword">system</span> <span class="operator">|</span> <span class="keyword">NULL</span>          <span class="operator">|</span> <span class="keyword">NULL</span>    <span class="operator">|</span> <span class="keyword">NULL</span>    <span class="operator">|</span> <span class="keyword">NULL</span>  <span class="operator">|</span>    <span class="number">1</span> <span class="operator">|</span>   <span class="number">100.00</span> <span class="operator">|</span> <span class="keyword">NULL</span>  <span class="operator">|</span></span><br><span class="line"><span class="operator">|</span>  <span class="number">2</span> <span class="operator">|</span> DERIVED     <span class="operator">|</span> film       <span class="operator">|</span> const  <span class="operator">|</span> <span class="keyword">PRIMARY</span>       <span class="operator">|</span> <span class="keyword">PRIMARY</span> <span class="operator">|</span> <span class="number">4</span>       <span class="operator">|</span> const <span class="operator">|</span>    <span class="number">1</span> <span class="operator">|</span>   <span class="number">100.00</span> <span class="operator">|</span> <span class="keyword">NULL</span>  <span class="operator">|</span></span><br><span class="line"><span class="operator">+</span><span class="comment">----+-------------+------------+--------+---------------+---------+---------+-------+------+----------+-------+</span></span><br><span class="line"></span><br><span class="line">mysql<span class="operator">&gt;</span> <span class="keyword">show</span> warnings;</span><br><span class="line"><span class="operator">+</span><span class="comment">-------+------+---------------------------------------------------------------+</span></span><br><span class="line"><span class="operator">|</span> Level <span class="operator">|</span> Code <span class="operator">|</span> Message                                                       <span class="operator">|</span></span><br><span class="line"><span class="operator">+</span><span class="comment">-------+------+---------------------------------------------------------------+</span></span><br><span class="line"><span class="operator">|</span> Note  <span class="operator">|</span> <span class="number">1003</span> <span class="operator">|</span> <span class="comment">/* select#1 */</span> <span class="keyword">select</span> <span class="string">&#x27;1&#x27;</span> <span class="keyword">AS</span> `id`,<span class="string">&#x27;film1&#x27;</span> <span class="keyword">AS</span> `name` <span class="keyword">from</span> dual <span class="operator">|</span></span><br><span class="line"><span class="operator">+</span><span class="comment">-------+------+---------------------------------------------------------------+</span></span><br></pre></td></tr></table></figure></li><li><p><strong>eq_ref</strong>：primary key 或 unique key 索引的所有部分被连接使用 ，最多只会返回一条符合条件的记录。这可能是在 const 之外最好的联接类型了，简单的 select 查询不会出现这种 type。</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">mysql<span class="operator">&gt;</span> explain <span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> film_actor <span class="keyword">left</span> <span class="keyword">join</span> film <span class="keyword">on</span> film_actor.film_id <span class="operator">=</span> film.id;</span><br><span class="line"><span class="operator">+</span><span class="comment">----+-------------+------------+--------+---------------+-------------------+---------+-------------------------+------+-------------+</span></span><br><span class="line"><span class="operator">|</span> id <span class="operator">|</span> select_type <span class="operator">|</span> <span class="keyword">table</span>      <span class="operator">|</span> type   <span class="operator">|</span> possible_keys <span class="operator">|</span> key               <span class="operator">|</span> key_len <span class="operator">|</span> <span class="keyword">ref</span>                     <span class="operator">|</span> <span class="keyword">rows</span> <span class="operator">|</span> Extra       <span class="operator">|</span></span><br><span class="line"><span class="operator">+</span><span class="comment">----+-------------+------------+--------+---------------+-------------------+---------+-------------------------+------+-------------+</span></span><br><span class="line"><span class="operator">|</span>  <span class="number">1</span> <span class="operator">|</span> SIMPLE      <span class="operator">|</span> film_actor <span class="operator">|</span> index  <span class="operator">|</span> <span class="keyword">NULL</span>          <span class="operator">|</span> idx_film_actor_id <span class="operator">|</span> <span class="number">8</span>       <span class="operator">|</span> <span class="keyword">NULL</span>                    <span class="operator">|</span>    <span class="number">3</span> <span class="operator">|</span> <span class="keyword">Using</span> index <span class="operator">|</span></span><br><span class="line"><span class="operator">|</span>  <span class="number">1</span> <span class="operator">|</span> SIMPLE      <span class="operator">|</span> film       <span class="operator">|</span> eq_ref <span class="operator">|</span> <span class="keyword">PRIMARY</span>       <span class="operator">|</span> <span class="keyword">PRIMARY</span>           <span class="operator">|</span> <span class="number">4</span>       <span class="operator">|</span> test.film_actor.film_id <span class="operator">|</span>    <span class="number">1</span> <span class="operator">|</span> <span class="keyword">NULL</span>        <span class="operator">|</span></span><br><span class="line"><span class="operator">+</span><span class="comment">----+-------------+------------+--------+---------------+-------------------+---------+-------------------------+------+-------------+</span></span><br></pre></td></tr></table></figure></li><li><p><strong>ref</strong>：相比 <code>eq_ref</code> ，不使用唯一索引，而是使用普通索引或者唯一性索引的部分前缀，索引要和某个值相比较，可能会找到多个符合条件的行。</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">1.</span> 简单 <span class="keyword">select</span> 查询，name是普通索引（非唯一索引）</span><br><span class="line">mysql<span class="operator">&gt;</span> explain <span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> film <span class="keyword">where</span> name <span class="operator">=</span> &quot;film1&quot;;</span><br><span class="line"><span class="operator">+</span><span class="comment">----+-------------+-------+------+---------------+----------+---------+-------+------+--------------------------+</span></span><br><span class="line"><span class="operator">|</span> id <span class="operator">|</span> select_type <span class="operator">|</span> <span class="keyword">table</span> <span class="operator">|</span> type <span class="operator">|</span> possible_keys <span class="operator">|</span> key      <span class="operator">|</span> key_len <span class="operator">|</span> <span class="keyword">ref</span>   <span class="operator">|</span> <span class="keyword">rows</span> <span class="operator">|</span> Extra                    <span class="operator">|</span></span><br><span class="line"><span class="operator">+</span><span class="comment">----+-------------+-------+------+---------------+----------+---------+-------+------+--------------------------+</span></span><br><span class="line"><span class="operator">|</span>  <span class="number">1</span> <span class="operator">|</span> SIMPLE      <span class="operator">|</span> film  <span class="operator">|</span> <span class="keyword">ref</span>  <span class="operator">|</span> idx_name      <span class="operator">|</span> idx_name <span class="operator">|</span> <span class="number">33</span>      <span class="operator">|</span> const <span class="operator">|</span>    <span class="number">1</span> <span class="operator">|</span> <span class="keyword">Using</span> <span class="keyword">where</span>; <span class="keyword">Using</span> index <span class="operator">|</span></span><br><span class="line"><span class="operator">+</span><span class="comment">----+-------------+-------+------+---------------+----------+---------+-------+------+--------------------------+</span></span><br><span class="line"></span><br><span class="line"><span class="number">2.</span>关联表查询，idx_film_actor_id是film_id和actor_id的联合索引，这里使用到了film_actor的左边前缀film_id部分。</span><br><span class="line">mysql<span class="operator">&gt;</span> explain <span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> film <span class="keyword">left</span> <span class="keyword">join</span> film_actor <span class="keyword">on</span> film.id <span class="operator">=</span> film_actor.film_id;</span><br><span class="line"><span class="operator">+</span><span class="comment">----+-------------+------------+-------+-------------------+-------------------+---------+--------------+------+-------------+</span></span><br><span class="line"><span class="operator">|</span> id <span class="operator">|</span> select_type <span class="operator">|</span> <span class="keyword">table</span>      <span class="operator">|</span> type  <span class="operator">|</span> possible_keys     <span class="operator">|</span> key               <span class="operator">|</span> key_len <span class="operator">|</span> <span class="keyword">ref</span>          <span class="operator">|</span> <span class="keyword">rows</span> <span class="operator">|</span> Extra       <span class="operator">|</span></span><br><span class="line"><span class="operator">+</span><span class="comment">----+-------------+------------+-------+-------------------+-------------------+---------+--------------+------+-------------+</span></span><br><span class="line"><span class="operator">|</span>  <span class="number">1</span> <span class="operator">|</span> SIMPLE      <span class="operator">|</span> film       <span class="operator">|</span> index <span class="operator">|</span> <span class="keyword">NULL</span>              <span class="operator">|</span> idx_name          <span class="operator">|</span> <span class="number">33</span>      <span class="operator">|</span> <span class="keyword">NULL</span>         <span class="operator">|</span>    <span class="number">3</span> <span class="operator">|</span> <span class="keyword">Using</span> index <span class="operator">|</span></span><br><span class="line"><span class="operator">|</span>  <span class="number">1</span> <span class="operator">|</span> SIMPLE      <span class="operator">|</span> film_actor <span class="operator">|</span> <span class="keyword">ref</span>   <span class="operator">|</span> idx_film_actor_id <span class="operator">|</span> idx_film_actor_id <span class="operator">|</span> <span class="number">4</span>       <span class="operator">|</span> test.film.id <span class="operator">|</span>    <span class="number">1</span> <span class="operator">|</span> <span class="keyword">Using</span> index <span class="operator">|</span></span><br><span class="line"><span class="operator">+</span><span class="comment">----+-------------+------------+-------+-------------------+-------------------+---------+--------------+------+-------------+</span></span><br></pre></td></tr></table></figure></li><li><p><strong>ref_or_null</strong>：类似<code>ref</code>，但是可以搜索值为NULL的行。</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">mysql<span class="operator">&gt;</span> explain <span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> film <span class="keyword">where</span> name <span class="operator">=</span> &quot;film1&quot; <span class="keyword">or</span> name <span class="keyword">is</span> <span class="keyword">null</span>;</span><br><span class="line"><span class="operator">+</span><span class="comment">----+-------------+-------+-------------+---------------+----------+---------+-------+------+--------------------------+</span></span><br><span class="line"><span class="operator">|</span> id <span class="operator">|</span> select_type <span class="operator">|</span> <span class="keyword">table</span> <span class="operator">|</span> type        <span class="operator">|</span> possible_keys <span class="operator">|</span> key      <span class="operator">|</span> key_len <span class="operator">|</span> <span class="keyword">ref</span>   <span class="operator">|</span> <span class="keyword">rows</span> <span class="operator">|</span> Extra                    <span class="operator">|</span></span><br><span class="line"><span class="operator">+</span><span class="comment">----+-------------+-------+-------------+---------------+----------+---------+-------+------+--------------------------+</span></span><br><span class="line"><span class="operator">|</span>  <span class="number">1</span> <span class="operator">|</span> SIMPLE      <span class="operator">|</span> film  <span class="operator">|</span> ref_or_null <span class="operator">|</span> idx_name      <span class="operator">|</span> idx_name <span class="operator">|</span> <span class="number">33</span>      <span class="operator">|</span> const <span class="operator">|</span>    <span class="number">2</span> <span class="operator">|</span> <span class="keyword">Using</span> <span class="keyword">where</span>; <span class="keyword">Using</span> index <span class="operator">|</span></span><br><span class="line"><span class="operator">+</span><span class="comment">----+-------------+-------+-------------+---------------+----------+---------+-------+------+--------------------------+</span></span><br></pre></td></tr></table></figure></li><li><p><strong>index_merge</strong>：表示使用了索引合并的优化方法。 例如下表：id是主键，tenant_id是普通索引。or 的时候没有用 primary key，而是使用了 primary key(id) 和 tenant_id 索引</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">mysql<span class="operator">&gt;</span> explain <span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> role <span class="keyword">where</span> id <span class="operator">=</span> <span class="number">11011</span> <span class="keyword">or</span> tenant_id <span class="operator">=</span> <span class="number">8888</span>;</span><br><span class="line"><span class="operator">+</span><span class="comment">----+-------------+-------+-------------+-----------------------+-----------------------+---------+------+------+-------------------------------------------------+</span></span><br><span class="line"><span class="operator">|</span> id <span class="operator">|</span> select_type <span class="operator">|</span> <span class="keyword">table</span> <span class="operator">|</span> type        <span class="operator">|</span> possible_keys         <span class="operator">|</span> key                   <span class="operator">|</span> key_len <span class="operator">|</span> <span class="keyword">ref</span>  <span class="operator">|</span> <span class="keyword">rows</span> <span class="operator">|</span> Extra                                           <span class="operator">|</span></span><br><span class="line"><span class="operator">+</span><span class="comment">----+-------------+-------+-------------+-----------------------+-----------------------+---------+------+------+-------------------------------------------------+</span></span><br><span class="line"><span class="operator">|</span>  <span class="number">1</span> <span class="operator">|</span> SIMPLE      <span class="operator">|</span> role  <span class="operator">|</span> index_merge <span class="operator">|</span> <span class="keyword">PRIMARY</span>,idx_tenant_id <span class="operator">|</span> <span class="keyword">PRIMARY</span>,idx_tenant_id <span class="operator">|</span> <span class="number">4</span>,<span class="number">4</span>     <span class="operator">|</span> <span class="keyword">NULL</span> <span class="operator">|</span>  <span class="number">134</span> <span class="operator">|</span> <span class="keyword">Using</span> <span class="keyword">union</span>(<span class="keyword">PRIMARY</span>,idx_tenant_id); <span class="keyword">Using</span> <span class="keyword">where</span> <span class="operator">|</span></span><br><span class="line"><span class="operator">+</span><span class="comment">----+-------------+-------+-------------+-----------------------+-----------------------+---------+------+------+-------------------------------------------------+</span></span><br></pre></td></tr></table></figure></li><li><p><strong>range</strong>：范围扫描通常出现在 in, between ,&gt; ,&lt;, &gt;= 等操作中。使用一个索引来检索给定范围的行。</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">mysql<span class="operator">&gt;</span> explain <span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> actor <span class="keyword">where</span> id <span class="operator">&gt;</span> <span class="number">1</span>;</span><br><span class="line"><span class="operator">+</span><span class="comment">----+-------------+-------+-------+---------------+---------+---------+------+------+-------------+</span></span><br><span class="line"><span class="operator">|</span> id <span class="operator">|</span> select_type <span class="operator">|</span> <span class="keyword">table</span> <span class="operator">|</span> type  <span class="operator">|</span> possible_keys <span class="operator">|</span> key     <span class="operator">|</span> key_len <span class="operator">|</span> <span class="keyword">ref</span>  <span class="operator">|</span> <span class="keyword">rows</span> <span class="operator">|</span> Extra       <span class="operator">|</span></span><br><span class="line"><span class="operator">+</span><span class="comment">----+-------------+-------+-------+---------------+---------+---------+------+------+-------------+</span></span><br><span class="line"><span class="operator">|</span>  <span class="number">1</span> <span class="operator">|</span> SIMPLE      <span class="operator">|</span> actor <span class="operator">|</span> <span class="keyword">range</span> <span class="operator">|</span> <span class="keyword">PRIMARY</span>       <span class="operator">|</span> <span class="keyword">PRIMARY</span> <span class="operator">|</span> <span class="number">4</span>       <span class="operator">|</span> <span class="keyword">NULL</span> <span class="operator">|</span>    <span class="number">2</span> <span class="operator">|</span> <span class="keyword">Using</span> <span class="keyword">where</span> <span class="operator">|</span></span><br><span class="line"><span class="operator">+</span><span class="comment">----+-------------+-------+-------+---------------+---------+---------+------+------+-------------+</span></span><br></pre></td></tr></table></figure></li><li><p><strong>index</strong>：和ALL一样，不同就是mysql只需扫描索引树，这通常比ALL快一些。</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">mysql<span class="operator">&gt;</span> explain <span class="keyword">select</span> <span class="built_in">count</span>(<span class="operator">*</span>) <span class="keyword">from</span> film;</span><br><span class="line"><span class="operator">+</span><span class="comment">----+-------------+-------+-------+---------------+----------+---------+------+------+-------------+</span></span><br><span class="line"><span class="operator">|</span> id <span class="operator">|</span> select_type <span class="operator">|</span> <span class="keyword">table</span> <span class="operator">|</span> type  <span class="operator">|</span> possible_keys <span class="operator">|</span> key      <span class="operator">|</span> key_len <span class="operator">|</span> <span class="keyword">ref</span>  <span class="operator">|</span> <span class="keyword">rows</span> <span class="operator">|</span> Extra       <span class="operator">|</span></span><br><span class="line"><span class="operator">+</span><span class="comment">----+-------------+-------+-------+---------------+----------+---------+------+------+-------------+</span></span><br><span class="line"><span class="operator">|</span>  <span class="number">1</span> <span class="operator">|</span> SIMPLE      <span class="operator">|</span> film  <span class="operator">|</span> index <span class="operator">|</span> <span class="keyword">NULL</span>          <span class="operator">|</span> idx_name <span class="operator">|</span> <span class="number">33</span>      <span class="operator">|</span> <span class="keyword">NULL</span> <span class="operator">|</span>    <span class="number">3</span> <span class="operator">|</span> <span class="keyword">Using</span> index <span class="operator">|</span></span><br><span class="line"><span class="operator">+</span><span class="comment">----+-------------+-------+-------+---------------+----------+---------+------+------+-------------+</span></span><br></pre></td></tr></table></figure></li><li><p><strong>ALL</strong>：即全表扫描，意味着mysql需要从头到尾去查找所需要的行。通常情况下这需要增加索引来进行优化了。</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">mysql<span class="operator">&gt;</span> explain <span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> actor;</span><br><span class="line"><span class="operator">+</span><span class="comment">----+-------------+-------+------+---------------+------+---------+------+------+-------+</span></span><br><span class="line"><span class="operator">|</span> id <span class="operator">|</span> select_type <span class="operator">|</span> <span class="keyword">table</span> <span class="operator">|</span> type <span class="operator">|</span> possible_keys <span class="operator">|</span> key  <span class="operator">|</span> key_len <span class="operator">|</span> <span class="keyword">ref</span>  <span class="operator">|</span> <span class="keyword">rows</span> <span class="operator">|</span> Extra <span class="operator">|</span></span><br><span class="line"><span class="operator">+</span><span class="comment">----+-------------+-------+------+---------------+------+---------+------+------+-------+</span></span><br><span class="line"><span class="operator">|</span>  <span class="number">1</span> <span class="operator">|</span> SIMPLE      <span class="operator">|</span> actor <span class="operator">|</span> <span class="keyword">ALL</span>  <span class="operator">|</span> <span class="keyword">NULL</span>          <span class="operator">|</span> <span class="keyword">NULL</span> <span class="operator">|</span> <span class="keyword">NULL</span>    <span class="operator">|</span> <span class="keyword">NULL</span> <span class="operator">|</span>    <span class="number">2</span> <span class="operator">|</span> <span class="keyword">NULL</span>  <span class="operator">|</span></span><br><span class="line"><span class="operator">+</span><span class="comment">----+-------------+-------+------+---------------+------+---------+------+------+-------+</span></span><br></pre></td></tr></table></figure></li></ul><h4 id="（5）possible-keys"><a href="#（5）possible-keys" class="headerlink" title="（5）possible_keys"></a>（5）possible_keys</h4><p>这一列显示查询可能使用哪些索引来查找。 </p><ul><li>explain 时可能出现 possible_keys 有列，而 key 显示 NULL 的情况，这种情况是因为表中数据不多，mysql认为索引对此查询帮助不大，选择了全表查询。 </li><li>如果该列是NULL，则没有相关的索引。在这种情况下，可以通过检查 where 子句看是否可以创造一个适当的索引来提高查询性能，然后用 explain 查看效果。</li></ul><h4 id="（6）key"><a href="#（6）key" class="headerlink" title="（6）key"></a>（6）key</h4><p>这一列显示mysql实际采用哪个索引来优化对该表的访问。</p><ul><li>如果没有使用索引，则该列是 NULL。</li><li>如果想强制mysql使用或忽视possible_keys列中的索引，在查询中使用 force index、ignore index。</li></ul><h4 id="（7）key-len"><a href="#（7）key-len" class="headerlink" title="（7）key_len"></a>（7）key_len</h4><p>这一列显示了mysql在索引里使用的字节数，通过这个值可以算出具体使用了索引中的哪些列。 </p><p>举例来说，film_actor的联合索引 idx_film_actor_id 由 film_id 和 actor_id 两个int列组成，并且每个int是4字节。通过结果中的key_len=4可推断出查询使用了第一个列：film_id列来执行索引查找。</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">mysql<span class="operator">&gt;</span> explain <span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> film_actor <span class="keyword">where</span> film_id <span class="operator">=</span> <span class="number">2</span>;</span><br><span class="line"><span class="operator">+</span><span class="comment">----+-------------+------------+------+-------------------+-------------------+---------+-------+------+-------------+</span></span><br><span class="line"><span class="operator">|</span> id <span class="operator">|</span> select_type <span class="operator">|</span> <span class="keyword">table</span>      <span class="operator">|</span> type <span class="operator">|</span> possible_keys     <span class="operator">|</span> key               <span class="operator">|</span> key_len <span class="operator">|</span> <span class="keyword">ref</span>   <span class="operator">|</span> <span class="keyword">rows</span> <span class="operator">|</span> Extra       <span class="operator">|</span></span><br><span class="line"><span class="operator">+</span><span class="comment">----+-------------+------------+------+-------------------+-------------------+---------+-------+------+-------------+</span></span><br><span class="line"><span class="operator">|</span>  <span class="number">1</span> <span class="operator">|</span> SIMPLE      <span class="operator">|</span> film_actor <span class="operator">|</span> <span class="keyword">ref</span>  <span class="operator">|</span> idx_film_actor_id <span class="operator">|</span> idx_film_actor_id <span class="operator">|</span> <span class="number">4</span>       <span class="operator">|</span> const <span class="operator">|</span>    <span class="number">1</span> <span class="operator">|</span> <span class="keyword">Using</span> index <span class="operator">|</span></span><br><span class="line"><span class="operator">+</span><span class="comment">----+-------------+------------+------+-------------------+-------------------+---------+-------+------+-------------+</span></span><br></pre></td></tr></table></figure><p>key_len计算规则如下：</p><ul><li>字符串 <ul><li>char(n)：n字节长度</li><li>varchar(n)：2字节存储字符串长度，如果是utf-8，则长度 3n + 2</li></ul></li><li>数值类型 <ul><li>tinyint：1字节</li><li>smallint：2字节</li><li>int：4字节</li><li>bigint：8字节　　</li></ul></li><li>时间类型　 <ul><li>date：3字节</li><li>timestamp：4字节</li><li>datetime：8字节</li></ul></li><li>如果字段允许为 NULL，需要1字节记录是否为 NULL</li></ul><p>索引最大长度是768字节，当字符串过长时，mysql会做一个类似左前缀索引的处理，将前半部分的字符提取出来做索引。</p><h4 id="（8）ref"><a href="#（8）ref" class="headerlink" title="（8）ref"></a>（8）ref</h4><p>这一列显示了在key列记录的索引中，表查找值所用到的列或常量，常见的有：const（常量），func，NULL，字段名（例：film.id）</p><h4 id="（9）rows"><a href="#（9）rows" class="headerlink" title="（9）rows"></a>（9）rows</h4><p>这一列是mysql估计要读取并检测的行数，注意这个不是结果集里的行数。</p><h4 id="（10）Extra"><a href="#（10）Extra" class="headerlink" title="（10）Extra"></a>（10）Extra</h4><p>这一列展示的是额外信息。常见的重要值如下： </p><ul><li><p><strong>distinct</strong>：一旦mysql找到了与行相联合匹配的行，就不再搜索了</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">mysql<span class="operator">&gt;</span> explain <span class="keyword">select</span> <span class="keyword">distinct</span> name <span class="keyword">from</span> film <span class="keyword">left</span> <span class="keyword">join</span> film_actor <span class="keyword">on</span> film.id <span class="operator">=</span> film_actor.film_id;</span><br><span class="line"><span class="operator">+</span><span class="comment">----+-------------+------------+-------+-------------------+-------------------+---------+--------------+------+------------------------------+</span></span><br><span class="line"><span class="operator">|</span> id <span class="operator">|</span> select_type <span class="operator">|</span> <span class="keyword">table</span>      <span class="operator">|</span> type  <span class="operator">|</span> possible_keys     <span class="operator">|</span> key               <span class="operator">|</span> key_len <span class="operator">|</span> <span class="keyword">ref</span>          <span class="operator">|</span> <span class="keyword">rows</span> <span class="operator">|</span> Extra                        <span class="operator">|</span></span><br><span class="line"><span class="operator">+</span><span class="comment">----+-------------+------------+-------+-------------------+-------------------+---------+--------------+------+------------------------------+</span></span><br><span class="line"><span class="operator">|</span>  <span class="number">1</span> <span class="operator">|</span> SIMPLE      <span class="operator">|</span> film       <span class="operator">|</span> index <span class="operator">|</span> idx_name          <span class="operator">|</span> idx_name          <span class="operator">|</span> <span class="number">33</span>      <span class="operator">|</span> <span class="keyword">NULL</span>         <span class="operator">|</span>    <span class="number">3</span> <span class="operator">|</span> <span class="keyword">Using</span> index; <span class="keyword">Using</span> temporary <span class="operator">|</span></span><br><span class="line"><span class="operator">|</span>  <span class="number">1</span> <span class="operator">|</span> SIMPLE      <span class="operator">|</span> film_actor <span class="operator">|</span> <span class="keyword">ref</span>   <span class="operator">|</span> idx_film_actor_id <span class="operator">|</span> idx_film_actor_id <span class="operator">|</span> <span class="number">4</span>       <span class="operator">|</span> test.film.id <span class="operator">|</span>    <span class="number">1</span> <span class="operator">|</span> <span class="keyword">Using</span> index; <span class="keyword">Distinct</span>        <span class="operator">|</span></span><br><span class="line"><span class="operator">+</span><span class="comment">----+-------------+------------+-------+-------------------+-------------------+---------+--------------+------+------------------------------+</span></span><br></pre></td></tr></table></figure></li><li><p><strong>Using index</strong>：这发生在对表的请求列都是同一索引的部分的时候，返回的列数据只使用了索引中的信息，而没有再去访问表中的行记录。是性能高的表现。</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">mysql<span class="operator">&gt;</span> explain <span class="keyword">select</span> id <span class="keyword">from</span> film <span class="keyword">order</span> <span class="keyword">by</span> id;</span><br><span class="line"><span class="operator">+</span><span class="comment">----+-------------+-------+-------+---------------+---------+---------+------+------+-------------+</span></span><br><span class="line"><span class="operator">|</span> id <span class="operator">|</span> select_type <span class="operator">|</span> <span class="keyword">table</span> <span class="operator">|</span> type  <span class="operator">|</span> possible_keys <span class="operator">|</span> key     <span class="operator">|</span> key_len <span class="operator">|</span> <span class="keyword">ref</span>  <span class="operator">|</span> <span class="keyword">rows</span> <span class="operator">|</span> Extra       <span class="operator">|</span></span><br><span class="line"><span class="operator">+</span><span class="comment">----+-------------+-------+-------+---------------+---------+---------+------+------+-------------+</span></span><br><span class="line"><span class="operator">|</span>  <span class="number">1</span> <span class="operator">|</span> SIMPLE      <span class="operator">|</span> film  <span class="operator">|</span> index <span class="operator">|</span> <span class="keyword">NULL</span>          <span class="operator">|</span> <span class="keyword">PRIMARY</span> <span class="operator">|</span> <span class="number">4</span>       <span class="operator">|</span> <span class="keyword">NULL</span> <span class="operator">|</span>    <span class="number">3</span> <span class="operator">|</span> <span class="keyword">Using</span> index <span class="operator">|</span></span><br><span class="line"><span class="operator">+</span><span class="comment">----+-------------+-------+-------+---------------+---------+---------+------+------+-------------+ </span></span><br></pre></td></tr></table></figure></li><li><p><strong>Using where</strong>：mysql服务器将在存储引擎检索行后再进行过滤。就是先读取整行数据，再按 where 条件进行检查，符合就留下，不符合就丢弃</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">mysql<span class="operator">&gt;</span> explain <span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> film <span class="keyword">where</span> id <span class="operator">&gt;</span> <span class="number">1</span>;</span><br><span class="line"><span class="operator">+</span><span class="comment">----+-------------+-------+-------+---------------+----------+---------+------+------+--------------------------+</span></span><br><span class="line"><span class="operator">|</span> id <span class="operator">|</span> select_type <span class="operator">|</span> <span class="keyword">table</span> <span class="operator">|</span> type  <span class="operator">|</span> possible_keys <span class="operator">|</span> key      <span class="operator">|</span> key_len <span class="operator">|</span> <span class="keyword">ref</span>  <span class="operator">|</span> <span class="keyword">rows</span> <span class="operator">|</span> Extra                    <span class="operator">|</span></span><br><span class="line"><span class="operator">+</span><span class="comment">----+-------------+-------+-------+---------------+----------+---------+------+------+--------------------------+</span></span><br><span class="line"><span class="operator">|</span>  <span class="number">1</span> <span class="operator">|</span> SIMPLE      <span class="operator">|</span> film  <span class="operator">|</span> index <span class="operator">|</span> <span class="keyword">PRIMARY</span>       <span class="operator">|</span> idx_name <span class="operator">|</span> <span class="number">33</span>      <span class="operator">|</span> <span class="keyword">NULL</span> <span class="operator">|</span>    <span class="number">3</span> <span class="operator">|</span> <span class="keyword">Using</span> <span class="keyword">where</span>; <span class="keyword">Using</span> index <span class="operator">|</span></span><br><span class="line"><span class="operator">+</span><span class="comment">----+-------------+-------+-------+---------------+----------+---------+------+------+--------------------------+</span></span><br></pre></td></tr></table></figure></li><li><p><strong>Using temporary</strong>：mysql需要创建一张临时表来处理查询。出现这种情况一般是要进行优化的，首先是想到用索引来优化。</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">1.</span> actor.name没有索引，此时创建了张临时表来<span class="keyword">distinct</span></span><br><span class="line">mysql<span class="operator">&gt;</span> explain <span class="keyword">select</span> <span class="keyword">distinct</span> name <span class="keyword">from</span> actor;</span><br><span class="line"><span class="operator">+</span><span class="comment">----+-------------+-------+------+---------------+------+---------+------+------+-----------------+</span></span><br><span class="line"><span class="operator">|</span> id <span class="operator">|</span> select_type <span class="operator">|</span> <span class="keyword">table</span> <span class="operator">|</span> type <span class="operator">|</span> possible_keys <span class="operator">|</span> key  <span class="operator">|</span> key_len <span class="operator">|</span> <span class="keyword">ref</span>  <span class="operator">|</span> <span class="keyword">rows</span> <span class="operator">|</span> Extra           <span class="operator">|</span></span><br><span class="line"><span class="operator">+</span><span class="comment">----+-------------+-------+------+---------------+------+---------+------+------+-----------------+</span></span><br><span class="line"><span class="operator">|</span>  <span class="number">1</span> <span class="operator">|</span> SIMPLE      <span class="operator">|</span> actor <span class="operator">|</span> <span class="keyword">ALL</span>  <span class="operator">|</span> <span class="keyword">NULL</span>          <span class="operator">|</span> <span class="keyword">NULL</span> <span class="operator">|</span> <span class="keyword">NULL</span>    <span class="operator">|</span> <span class="keyword">NULL</span> <span class="operator">|</span>    <span class="number">2</span> <span class="operator">|</span> <span class="keyword">Using</span> temporary <span class="operator">|</span></span><br><span class="line"><span class="operator">+</span><span class="comment">----+-------------+-------+------+---------------+------+---------+------+------+-----------------+</span></span><br><span class="line"></span><br><span class="line"><span class="number">2.</span> film.name建立了idx_name索引，此时查询时extra是<span class="keyword">using</span> index,没有用临时表</span><br><span class="line">mysql<span class="operator">&gt;</span> explain <span class="keyword">select</span> <span class="keyword">distinct</span> name <span class="keyword">from</span> film;</span><br><span class="line"><span class="operator">+</span><span class="comment">----+-------------+-------+-------+---------------+----------+---------+------+------+-------------+</span></span><br><span class="line"><span class="operator">|</span> id <span class="operator">|</span> select_type <span class="operator">|</span> <span class="keyword">table</span> <span class="operator">|</span> type  <span class="operator">|</span> possible_keys <span class="operator">|</span> key      <span class="operator">|</span> key_len <span class="operator">|</span> <span class="keyword">ref</span>  <span class="operator">|</span> <span class="keyword">rows</span> <span class="operator">|</span> Extra       <span class="operator">|</span></span><br><span class="line"><span class="operator">+</span><span class="comment">----+-------------+-------+-------+---------------+----------+---------+------+------+-------------+</span></span><br><span class="line"><span class="operator">|</span>  <span class="number">1</span> <span class="operator">|</span> SIMPLE      <span class="operator">|</span> film  <span class="operator">|</span> index <span class="operator">|</span> idx_name      <span class="operator">|</span> idx_name <span class="operator">|</span> <span class="number">33</span>      <span class="operator">|</span> <span class="keyword">NULL</span> <span class="operator">|</span>    <span class="number">3</span> <span class="operator">|</span> <span class="keyword">Using</span> index <span class="operator">|</span></span><br><span class="line"><span class="operator">+</span><span class="comment">----+-------------+-------+-------+---------------+----------+---------+------+------+-------------+</span></span><br></pre></td></tr></table></figure></li><li><p><strong>Using filesort</strong>：mysql 会对结果使用一个外部索引排序，而不是按索引次序从表里读取行。此时mysql会根据联接类型浏览所有符合条件的记录，并保存排序关键字和行指针，然后排序关键字并按顺序检索行信息。这种情况下一般也是要考虑使用索引来优化的。</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">1.</span> actor.name未创建索引，会浏览actor整个表，保存排序关键字name和对应的id，然后排序name并检索行记录</span><br><span class="line">mysql<span class="operator">&gt;</span> explain <span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> actor <span class="keyword">order</span> <span class="keyword">by</span> name;</span><br><span class="line"><span class="operator">+</span><span class="comment">----+-------------+-------+------+---------------+------+---------+------+------+----------------+</span></span><br><span class="line"><span class="operator">|</span> id <span class="operator">|</span> select_type <span class="operator">|</span> <span class="keyword">table</span> <span class="operator">|</span> type <span class="operator">|</span> possible_keys <span class="operator">|</span> key  <span class="operator">|</span> key_len <span class="operator">|</span> <span class="keyword">ref</span>  <span class="operator">|</span> <span class="keyword">rows</span> <span class="operator">|</span> Extra          <span class="operator">|</span></span><br><span class="line"><span class="operator">+</span><span class="comment">----+-------------+-------+------+---------------+------+---------+------+------+----------------+</span></span><br><span class="line"><span class="operator">|</span>  <span class="number">1</span> <span class="operator">|</span> SIMPLE      <span class="operator">|</span> actor <span class="operator">|</span> <span class="keyword">ALL</span>  <span class="operator">|</span> <span class="keyword">NULL</span>          <span class="operator">|</span> <span class="keyword">NULL</span> <span class="operator">|</span> <span class="keyword">NULL</span>    <span class="operator">|</span> <span class="keyword">NULL</span> <span class="operator">|</span>    <span class="number">2</span> <span class="operator">|</span> <span class="keyword">Using</span> filesort <span class="operator">|</span></span><br><span class="line"><span class="operator">+</span><span class="comment">----+-------------+-------+------+---------------+------+---------+------+------+----------------+</span></span><br><span class="line"></span><br><span class="line"><span class="number">2.</span> film.name建立了idx_name索引,此时查询时extra是<span class="keyword">using</span> index</span><br><span class="line">mysql<span class="operator">&gt;</span> explain <span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> film <span class="keyword">order</span> <span class="keyword">by</span> name;</span><br><span class="line"><span class="operator">+</span><span class="comment">----+-------------+-------+-------+---------------+----------+---------+------+------+-------------+</span></span><br><span class="line"><span class="operator">|</span> id <span class="operator">|</span> select_type <span class="operator">|</span> <span class="keyword">table</span> <span class="operator">|</span> type  <span class="operator">|</span> possible_keys <span class="operator">|</span> key      <span class="operator">|</span> key_len <span class="operator">|</span> <span class="keyword">ref</span>  <span class="operator">|</span> <span class="keyword">rows</span> <span class="operator">|</span> Extra       <span class="operator">|</span></span><br><span class="line"><span class="operator">+</span><span class="comment">----+-------------+-------+-------+---------------+----------+---------+------+------+-------------+</span></span><br><span class="line"><span class="operator">|</span>  <span class="number">1</span> <span class="operator">|</span> SIMPLE      <span class="operator">|</span> film  <span class="operator">|</span> index <span class="operator">|</span> <span class="keyword">NULL</span>          <span class="operator">|</span> idx_name <span class="operator">|</span> <span class="number">33</span>      <span class="operator">|</span> <span class="keyword">NULL</span> <span class="operator">|</span>    <span class="number">3</span> <span class="operator">|</span> <span class="keyword">Using</span> index <span class="operator">|</span></span><br><span class="line"><span class="operator">+</span><span class="comment">----+-------------+-------+-------+---------------+----------+---------+------+------+-------------+</span></span><br></pre></td></tr></table></figure></li><li><p><strong>Using index condition</strong>：表的读取是通过访问索引图元并首先测试它们来确定是否要读取全表的行。通过这种方式，索引信息被用来推迟(“push down”) 读取全表的行，除非有必要。</p><ul><li>详细参考： <a href="https://dev.mysql.com/doc/refman/8.0/en/index-condition-pushdown-optimization.html">Section 8.2.1.6, “Index Condition Pushdown Optimization” </a>。</li><li>存储引擎根据索引尽可能的过滤数据，然后在返回给服务器层根据where其他条件进行过滤。</li><li>假设有联合索引 <code>XXX_index(a, b, c) </code> ，查询的时候 <code>where a=&#39;xxx&#39; and c=1</code> ，没有按顺序与索引字段一直，就导致后面条件c无法命中索引。</li><li>type值为range、 ref、 eq_ref或者ref_or_null的时候 , 会使用到索引条件下推技术。</li></ul></li></ul><p>上述SQL使用到的表和数据：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">DROP</span> <span class="keyword">TABLE</span> IF <span class="keyword">EXISTS</span> `actor`;</span><br><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> `actor` (</span><br><span class="line">  `id` <span class="type">int</span>(<span class="number">11</span>) <span class="keyword">NOT</span> <span class="keyword">NULL</span>,</span><br><span class="line">  `name` <span class="type">varchar</span>(<span class="number">45</span>) <span class="keyword">DEFAULT</span> <span class="keyword">NULL</span>,</span><br><span class="line">  `update_time` datetime <span class="keyword">DEFAULT</span> <span class="keyword">NULL</span>,</span><br><span class="line">  <span class="keyword">PRIMARY</span> KEY (`id`)</span><br><span class="line">) ENGINE<span class="operator">=</span>InnoDB <span class="keyword">DEFAULT</span> CHARSET<span class="operator">=</span>utf8;</span><br><span class="line"></span><br><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> `actor` (`id`, `name`, `update_time`) <span class="keyword">VALUES</span> (<span class="number">1</span>,<span class="string">&#x27;a&#x27;</span>,<span class="string">&#x27;2017-12-22 15:27:18&#x27;</span>), (<span class="number">2</span>,<span class="string">&#x27;b&#x27;</span>,<span class="string">&#x27;2017-12-22 15:27:18&#x27;</span>), (<span class="number">3</span>,<span class="string">&#x27;c&#x27;</span>,<span class="string">&#x27;2017-12-22 15:27:18&#x27;</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">DROP</span> <span class="keyword">TABLE</span> IF <span class="keyword">EXISTS</span> `film`;</span><br><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> `film` (</span><br><span class="line">  `id` <span class="type">int</span>(<span class="number">11</span>) <span class="keyword">NOT</span> <span class="keyword">NULL</span> AUTO_INCREMENT,</span><br><span class="line">  `name` <span class="type">varchar</span>(<span class="number">10</span>) <span class="keyword">DEFAULT</span> <span class="keyword">NULL</span>,</span><br><span class="line">  <span class="keyword">PRIMARY</span> KEY (`id`),</span><br><span class="line">  KEY `idx_name` (`name`)</span><br><span class="line">) ENGINE<span class="operator">=</span>InnoDB <span class="keyword">DEFAULT</span> CHARSET<span class="operator">=</span>utf8;</span><br><span class="line"></span><br><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> `film` (`id`, `name`) <span class="keyword">VALUES</span> (<span class="number">3</span>,<span class="string">&#x27;film0&#x27;</span>),(<span class="number">1</span>,<span class="string">&#x27;film1&#x27;</span>),(<span class="number">2</span>,<span class="string">&#x27;film2&#x27;</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">DROP</span> <span class="keyword">TABLE</span> IF <span class="keyword">EXISTS</span> `film_actor`;</span><br><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> `film_actor` (</span><br><span class="line">  `id` <span class="type">int</span>(<span class="number">11</span>) <span class="keyword">NOT</span> <span class="keyword">NULL</span>,</span><br><span class="line">  `film_id` <span class="type">int</span>(<span class="number">11</span>) <span class="keyword">NOT</span> <span class="keyword">NULL</span>,</span><br><span class="line">  `actor_id` <span class="type">int</span>(<span class="number">11</span>) <span class="keyword">NOT</span> <span class="keyword">NULL</span>,</span><br><span class="line">  <span class="keyword">PRIMARY</span> KEY (`id`),</span><br><span class="line">  KEY `idx_film_actor_id` (`film_id`,`actor_id`)</span><br><span class="line">) ENGINE<span class="operator">=</span>InnoDB <span class="keyword">DEFAULT</span> CHARSET<span class="operator">=</span>utf8;</span><br><span class="line"></span><br><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> `film_actor` (`id`, `film_id`, `actor_id`) <span class="keyword">VALUES</span> (<span class="number">1</span>,<span class="number">1</span>,<span class="number">1</span>),(<span class="number">2</span>,<span class="number">1</span>,<span class="number">2</span>),(<span class="number">3</span>,<span class="number">2</span>,<span class="number">1</span>);</span><br></pre></td></tr></table></figure><hr><p>参考：</p><p>🔗 《<a href="https://cloud.tencent.com/developer/article/1648496">Oracle调优之看懂SQL执行计划explain</a>》</p><p>🔗 《<a href="https://blog.csdn.net/p6620582/article/details/74181523">Oracle执行计划详细解读</a>》</p><p>🔗 《<a href="https://www.cnblogs.com/Dreamer-1/p/6076440.html">看懂Oracle执行计划</a>》</p><p>🔗 《<a href="https://blog.csdn.net/u014427391/article/details/89604262">Orace SQL调优系列之执行计划学习笔记</a>》</p><p>🔗 《<a href="https://dev.mysql.com/doc/refman/8.0/en/explain-output.html">MySQL :: MySQL 8.0 Reference Manual :: 8.8.2 EXPLAIN Output Format</a>》</p><p>🔗 《<a href="https://cloud.tencent.com/developer/article/1093229">mysql explain详解》</a></p><p>🔗 《<a href="https://blog.csdn.net/u014427391/article/details/94862797">《收获，不止SQL优化》读书笔记</a>》</p>]]></content>
    
    
    <summary type="html">整理Oracle和MySQL执行计划相关内容，包括：什么是执行计划，如何查看和分析执行计划，访问数据方式，表连接方式等。</summary>
    
    
    
    <category term="技术文档" scheme="http://linyishui.top/categories/%E6%8A%80%E6%9C%AF%E6%96%87%E6%A1%A3/"/>
    
    
    <category term="updating" scheme="http://linyishui.top/tags/updating/"/>
    
    <category term="mysql" scheme="http://linyishui.top/tags/mysql/"/>
    
    <category term="oracle" scheme="http://linyishui.top/tags/oracle/"/>
    
  </entry>
  
  <entry>
    <title>Oracle锁 &lt;转&gt;</title>
    <link href="http://linyishui.top/2021101301.html"/>
    <id>http://linyishui.top/2021101301.html</id>
    <published>2021-10-13T06:16:34.000Z</published>
    <updated>2021-10-15T08:35:06.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Oracle锁"><a href="#Oracle锁" class="headerlink" title="Oracle锁"></a>Oracle锁</h1><h2 id="一-简述"><a href="#一-简述" class="headerlink" title="一. 简述"></a>一. 简述</h2><p>数据库是一个多用户使用的共享资源。当多个用户并发地存取数据时，在数据库中就会产生多个事务同时存取同一数据的情况。若对并发操作不加控制就可能会读取和存储不正确的数据，破坏数据库的一致性。Oracle 利用其锁机制来实现事务间的数据并发访问及数据一致性。</p><p>当事务在对某个数据对象进行操作前，先向系统发出请求，对其加锁。加锁后事务就对该数据对象有了一定的控制，在该事务释放锁之前，其他的事务不能对此数据对象进行更新操作。</p><p>Oracle的锁机制是一种轻量级的锁定机制，不是通过构建锁列表来进行数据的锁定管理，而是<strong>直接将锁作为数据块的属性，存储在数据块首部</strong>。在oracle数据库中，不存在真正意义上属于某个对象或数据的锁。oracle锁的信息是数据块的一个<strong>物理属性</strong>，而不是逻辑上属于某个表或某个行。</p><p>在 Oracle 数据库中，它并不是对某个表加上锁或者某几行加上锁， 锁是以数据块的一个属性存在的。 也就是说， 每个数据块本身就存储着自己数据块中数据的信息，这个地方叫 ITL（Interested Transaction List）， 凡是在这个数据块上有活动的事务，它的信息就会记录在这里面供后续的操作查询，以保证事务的一致性。</p><h2 id="二-锁类别"><a href="#二-锁类别" class="headerlink" title="二. 锁类别"></a>二. 锁类别</h2><h3 id="2-1-自动锁和显示锁"><a href="#2-1-自动锁和显示锁" class="headerlink" title="2.1 自动锁和显示锁"></a>2.1 自动锁和显示锁</h3><p>按用户和系统分可以分为自动锁和显示锁</p><ul><li><p>自动锁（ Automatic Locks）：当进行一项数据库操作时，缺省情况下，系统自动为此数据库操作获得所有有必要的锁。</p><p>分为三种：</p><ul><li>DML 锁</li><li>DDL 锁</li><li>systemlocks</li></ul></li><li><p>显示锁（ Manual Data Locks）：某些情况下，需要用户显示的锁定数据库操作要用到的数据，才能使数据库操作执行得更好，显示锁是用户为数据库对象设定的。</p></li></ul><h3 id="2-2-排它锁和共享锁"><a href="#2-2-排它锁和共享锁" class="headerlink" title="2.2 排它锁和共享锁"></a>2.2 排它锁和共享锁</h3><p>按锁级别分可以分为排它锁和共享锁：</p><ul><li><strong>排他锁（exclusive lock，即X锁）</strong>：事务设置排它锁后，该事务单独获得此资源，另一事务不能在此事务提交之前获得相同对象的共享锁或排它锁。</li><li><strong>共享锁（share lock，即S锁）</strong>：共享锁使一个事务对特定数据库资源进行共享访问——另一事务也可对此资源进行访问或获得相同共享锁。共享锁为事务提供高并发性，但如拙劣的事务设计+共享锁容易造成死锁或数据更新丢失。</li></ul><h3 id="2-3-DML锁、DLL锁和System-Locks"><a href="#2-3-DML锁、DLL锁和System-Locks" class="headerlink" title="2.3 DML锁、DLL锁和System Locks"></a>2.3 DML锁、DLL锁和System Locks</h3><p>按操作分可以分为DML锁、DLL锁和System Locks。</p><h4 id="（1）DML锁"><a href="#（1）DML锁" class="headerlink" title="（1）DML锁"></a>（1）DML锁</h4><p><strong>DML锁：</strong>用于控制并发事务中的数据操纵，保证数据的一致性和完整性，保护并发情况下的数据完整性。DML 语句能够自动地获得所需的表级锁（TM）与行级（事务）锁（TX）。</p><p>又分为：</p><ul><li>TM 锁（表级锁）</li><li>TX 锁（事务锁或行级锁）</li></ul><p>当 Oracle 执行 DML 语句时，系统自动在所要操作的表上申请 TM 类型的锁。当 TM 锁获得后，系统再自动申请 TX 类型的锁，并将实际锁定的数据行的锁标志位进行置位。</p><p>这样在事务加锁前检查 TX锁相容性时就不用再逐行检查锁标志，而只需检查 TM 锁模式的相容性即可，大大提高了系统的效率。</p><p>在数据行上只有 X 锁（排他锁）。</p><p>在 Oracle 数据库中，当一个事务首次发起一个 DML 语句时就获得一个 TX 锁，该锁保持到事务被提交或回滚。当两个或多个会话在表的同一条记录上执行 DML 语句时，第一个会话在该条记录上加锁，其他的会话处于等待状态。当第一个会话提交后， TX 锁被释放，其他会话才可以加锁。</p><p>当 Oracle 数据库发生 TX 锁等待时，如果不及时处理常常会引起 Oracle 数据库挂起，或导致死锁的发生，产生ORA-600 的错误。这些现象都会对实际应用产生极大的危害，如长时间未响应，大量事务失败等。</p><p>DML 锁有如下三种加锁方式：</p><ul><li>共享锁方式（ SHARE）</li><li>独占锁方式（ EXCLUSIVE）</li><li>共享更新锁（ SHARE UPDATE）  其中：  SHARE， EXCLUSIVE 用于 TM 锁（表级锁）  SHARE UPDATE 用于 TX 锁（ 行级锁）</li></ul><h5 id="表级锁"><a href="#表级锁" class="headerlink" title="表级锁"></a>表级锁</h5><p><strong>TM 锁（表级锁）：</strong>TM 锁用于确保在修改表的内容时，表的结构不会改变，例如防止在 DML 语句执行期间相关的表被移除。当用户对表执行 DDL 或 DML 操作时，将获取一个此表的表级锁。</p><p>当事务获得行锁后，此事务也将自动获得该行的表锁(共享锁),以防止其它事务进行 DDL 语句影响记录行的更新。</p><p>事务也可以在进行过程中获得共享锁或排它锁，只有当事务显示使用 LOCK TABLE 语句显示的定义一个排它锁时，事务才会获得表上的排它锁,也可使用 LOCK TABLE 显示的定义一个表级的共享锁。</p><p>TM 锁包括了 SS、 SX、 S、 X 等多种模式，在数据库中用 0－6 来表示。不同的 SQL 操作产生不同类型的 TM 锁.</p><p><img src="https://pic-1258215793.cos.ap-shanghai.myqcloud.com/content/20211001/202110010101.png"></p><h5 id="行级锁"><a href="#行级锁" class="headerlink" title="行级锁"></a>行级锁</h5><p><strong>TX 锁（事务锁或行级锁）：</strong></p><p>当事务执行数据库插入、更新、删除操作时，该事务自动获得操作表中操作行的排它锁。</p><p>事务发起第一个修改时会得到TX 锁（事务锁），而且会一直持有这个锁，直至事务执行提交（COMMIT）或回滚（ROLLBACK）。</p><p>对用户的数据操纵， Oracle 可以自动为操纵的数据进行加锁，但如果有操纵授权，则为满足并发操纵的需要另外实施加锁。</p><p>DML 锁可由一个用户进程以显式的方式加锁，也可通过某些 SQL 语句隐含方式实现。 这部分属于 Manual Data Locks。</p><p>原理：一个事务要修改块中的数据，必须获得该块中的一个itl，通过 itl 和 undo  segment header 中的 transaction table，可以知道事务是否处于活动阶段。事务在修改块时（其实就是在修改行）会检查行中 row header 中的标志位，如果该标志位为0（该行没有被活动的事务锁住），就把该标志位修改为事务在该块获得的itl的序号，这样当前事务就获得了对记录的锁定，然后就可以修改行数据了，这也就是 oracle 行锁实现的原理。</p><h5 id="共享方式的表级锁（-Share）"><a href="#共享方式的表级锁（-Share）" class="headerlink" title="共享方式的表级锁（ Share）"></a><strong>共享方式的表级锁（ Share）</strong></h5><p>共享方式的表级锁是对表中的所有数据进行加锁，该锁用于保护查询数据的一致性，防止其它用户对已加锁的表进行更新。</p><p>其它用户只能对该表再施加共享方式的锁，而不能再对该表施加独占方式的锁，共享更新锁可以再施加，但不允许持有共享更新封锁的进程做更新。</p><p>共享该表的所有用户只能查询表中的数据，但不能更新。</p><p>共享方式的表级锁只能由用户用 SQL 语句来设置.</p><p>语句格式如下：</p><figure class="highlight r"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">LOCK TABLE &lt;表名&gt;[,&lt;表名&gt;]... IN SHARE MODE [NOWAIT]</span><br></pre></td></tr></table></figure><p>执行该语句，对一个或多个表施加共享方式的表封锁。</p><p>当指定了选择项NOWAIT，若该锁暂时不能施加成功，则返回并由用户决定是进行等待，还是先去执行别的语句。</p><p>持有共享锁的事务，在出现如下之一的条件时，便释放其共享锁：</p><ul><li>A、执行 COMMIT 或 ROLLBACK 语句。</li><li>B、退出数据库（ LOG OFF）。</li><li>C、程序停止运行。</li></ul><p>共享方式表级锁常用于一致性查询过程，即在查询数据期间表中的数据不发生改变。</p><h5 id="独占方式表级锁（-Exclusive）"><a href="#独占方式表级锁（-Exclusive）" class="headerlink" title="独占方式表级锁（ Exclusive）"></a><strong>独占方式表级锁（ Exclusive）</strong></h5><p>独占方式表级锁是用于加锁表中的所有数据，拥有该独占方式表封锁的用户，即可以查询该表，又可以更新该表，其它的用户不能再对该表施加任何加锁（包括共享、独占或共享更新封锁）。</p><p>其它用户虽然不能更新该表，但可以查询该表。</p><p>独占方式的表封锁可通过如下的 SQL 语句来显示地获得：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">LOCK <span class="keyword">TABLE</span> <span class="operator">&lt;</span>表名<span class="operator">&gt;</span>[,<span class="operator">&lt;</span>表名<span class="operator">&gt;</span>].... <span class="keyword">IN</span> EXCLUSIVE MODE [NOWAIT]</span><br></pre></td></tr></table></figure><p>独占方式的表级锁也可以在用户执行 DML 语句 INSERT、UPDATE、DELETE时隐含获得。</p><p>拥有独占方式表封锁的事务，在出现如下条件之一时，便释放该封锁：</p><ul><li>（ 1）执行 COMMIT 或 ROLLBACK 语句。</li><li>（ 2）退出数据库（ LOG OFF）</li><li>（ 3）程序停止运行。</li></ul><p>独占方式封锁通常用于更新数据，当某个更新事务涉及多个表时，可减少发生死锁.</p><h5 id="共享更新加锁方式（-Share-Update）"><a href="#共享更新加锁方式（-Share-Update）" class="headerlink" title="共享更新加锁方式（ Share Update）"></a><strong>共享更新加锁方式（ Share Update）</strong></h5><p>共享更新加锁是对一个表的一行或多行进行加锁，因而也称作行级加锁。表级加锁虽然保证了数据的一致性，但却减弱了操作数据的并行性。</p><p>行级加锁确保在用户取得被更新的行到该行进行更新这段时间内不被其它用户所修改。  因而行级锁即可保证数据的一致性又能提高数据操作的迸发性。</p><p>可通过如下的两种方式来获得行级封锁：  （ 1）、执行如下的 SQL 封锁语句，以显示的方式获得：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">LOCK <span class="keyword">TABLE</span> <span class="operator">&lt;</span> 表 名 <span class="operator">&gt;</span>[,<span class="operator">&lt;</span> 表 名 <span class="operator">&gt;</span>].... <span class="keyword">IN</span> SHARE UPDATE MODE[NOWAIT]</span><br></pre></td></tr></table></figure><p>（ 2）、用如下的 SELECT …FOR UPDATE 语句获得：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">SELECT &lt;列名 &gt;[,&lt;列名 &gt;]...FROM &lt;表名 &gt; WHERE &lt;条件 &gt; FORUPDATE OF &lt;列名&gt;[,&lt;列名&gt;].....[NOWAIT]</span><br></pre></td></tr></table></figure><p>一旦用户对某个行施加了行级加锁，则该用户可以查询也可以更新被加锁的数据行，其它用户只能查询但不能更新被加锁的数据行．</p><p>如果其它用户想更新该表中的数据行，则也必须对该表施加行级锁．即使多个用户对一个表均使用了共享更新，但也不允许两个事务同时对一个表进行更新，真正对表进行更新时，是以独占方式锁表，一直到提交或复原该事务为止。</p><p>行锁永远是独占方式锁。</p><p>当出现如下之一的条件，便释放共享更新锁：</p><ul><li>（ 1）执行提交（ COMMIT）语句；</li><li>（ 2）退出数据库（ LOG OFF）</li><li>（ 3）程序停止运行。</li></ul><p>执行 ROLLBACK 操作不能释放行锁。</p><h4 id="（2）DLL锁（dictionary-locks）"><a href="#（2）DLL锁（dictionary-locks）" class="headerlink" title="（2）DLL锁（dictionary locks）"></a>（2）DLL锁（dictionary locks）</h4><p>DDL 锁用于保护数据库对象的结构，如表、索引等的结构定义。</p><p>DDL 锁又可以分为：</p><ul><li>排它 DDL 锁</li><li>共享 DDL 锁</li><li>分析锁</li></ul><h5 id="排它-DDL-锁"><a href="#排它-DDL-锁" class="headerlink" title="排它 DDL 锁"></a>排它 DDL 锁</h5><p>创建、修改、删除一个数据库对象的 DDL 语句获得操作对象的 排它锁。</p><p>如使用 alter table 语句时，为了维护数据的完成性、一致性、合法性，该事务获得一排它 DDL 锁。</p><h5 id="共享-DDL-锁"><a href="#共享-DDL-锁" class="headerlink" title="共享 DDL 锁"></a>共享 DDL 锁</h5><p>需在数据库对象之间建立相互依赖关系的 DDL 语句通常需共享获得 DDL锁。</p><p>如创建一个包，该包中的过程与函数引用了不同的数据库表，当编译此包时该事务就获得了引用表的共享 DDL 锁。</p><h5 id="分析锁"><a href="#分析锁" class="headerlink" title="分析锁"></a>分析锁</h5><p>ORACLE 使用共享池存储分析与优化过的 SQL 语句及 PL/SQL 程序，使运行相同语句的应用速度更快。</p><p>一个在共享池中缓存的对象获得它所引用数据库对象的分析锁。</p><p>分析锁是一种独特的 DDL 锁类型， ORACLE 使用它追踪共享池对象及它所引用数据库对象之间的依赖关系。</p><p>当一个事务修改或删除了共享池持有分析锁的数据库对象时， ORACLE 使共享池中的对象作废，下次在引用这条SQL/PLSQL 语 句时， ORACLE 重新分析编译此语句。</p><p>DDL 级加锁也是由 ORACLE RDBMS 来控制，它用于保护数据字典和数据定义改变时的一致性和完整性。 它是系统在对 SQL 定义语句作语法分析时自动地加锁，无需用户干予。</p><p>字典/语法分析加锁共分三类：</p><ul><li>（ 1）字典操作锁：  用于对字典操作时，锁住数据字典，此封锁是独占的，从而保护任何一个时刻仅能对一个字典操作。</li><li>（ 2） 字典定义锁：  用于防止在进行字典操作时又进行语法分析，这样可以避免在查询字典的同时改动某个表的结构。</li><li>（ 3）表定义锁：  用于一个 SQL 语句正当访问某个表时，防止字典中与该表有关的项目被修改。</li></ul><h5 id="悲观封锁"><a href="#悲观封锁" class="headerlink" title="悲观封锁"></a>悲观封锁</h5><p>锁在用户修改之前就发挥作用：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">Select</span> .. <span class="keyword">for</span> update [nowait] <span class="keyword">Select</span> <span class="operator">*</span> <span class="keyword">from</span> tab1 <span class="keyword">for</span> update </span><br></pre></td></tr></table></figure><p>用户发出这条命令之后，oracle将会对返回集中的数据建立行级封锁，以防止其他用户的修改。</p><p>如果此时其他用户对上面返回结果集的数据进行dml或ddl操作都会返回一个错误信息或发生阻塞。</p><ul><li>1：对返回结果集进行update或delete操作会发生阻塞。 左下角的时间执行了很久。 </li></ul><p><img src="https://ask.qcloudimg.com/http-save/yehe-3489346/a151h62mmr.gif" alt="img"></p><ul><li>2：对该表进行ddl操作将会报： Ora-00054:resource busy and acquire with nowait specified.</li></ul><p><img src="https://ask.qcloudimg.com/http-save/yehe-3489346/iocr2chkp6.png?imageView2/2/w/1620" alt="img"></p><p>原因分析 ：  此时Oracle已经对返回的结果集上加了排它的行级锁，所有其他对这些数据进行的修改或删除操作都必须等待这个锁的释放，产生的外在现象就是其他的操作将发生阻塞，这个这个操作commit或rollback.</p><p>同样这个查询的事务将会对该表加表级锁，不允许对该表的任何ddl操作，否则将会报出ora-00054错误：:resource busy and acquire with nowait specified.</p><p>悲观的缺陷是，加锁的时间可能会很长，这样可能会长时间的限制其他用户的访问，也就是说悲观锁的并 发访问性不好.</p><p>会话A：</p><p>在这里新开一个plsql窗口模拟会话A</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">--建表create table xgj (name varchar2(20));--新增数据insert into xgj values(&#x27;xiaogongjiang&#x27;);--提交数据commit ;--使用for update方式获取排他行级锁select * from xgj where name=&#x27;xiaogongjiang&#x27; for update ;</span></span><br></pre></td></tr></table></figure><p>会话B：</p><p>在这里是在plsql中另外新开了一个窗口模拟会话B，不能在同一个会话窗口，否则测试不出来。</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">alter</span> <span class="keyword">table</span> xgj <span class="keyword">add</span>(salary  number(<span class="number">5</span>));</span><br></pre></td></tr></table></figure><p>注意看左下角的时间，会看到已经执行时间了很长时间，如果会话A不提交则会一直等待，A提交后，马上执行成功。 </p><p><img src="https://ask.qcloudimg.com/http-save/yehe-3489346/y3likjg8r8.gif" alt="img"></p><h5 id="乐观封锁"><a href="#乐观封锁" class="headerlink" title="乐观封锁"></a>乐观封锁</h5><p>乐观的认为数据在select出来到update数据并提交的这段时间数据不会被更改。乐观锁多个会话可以同时操作数据。这里面有一种潜在的危险就是由于被选出的结果集并没有被锁定，是存在一种可能被其他用户更改的可能。因此Oracle仍然建议是用悲观封锁，因为这样会更安全。</p><p>比较常见的方式使用版本列来，每次更新时都和旧版本的数据比较。</p><h4 id="（3）System-Locks"><a href="#（3）System-Locks" class="headerlink" title="（3）System Locks"></a>（3）System Locks</h4><p>oracle使用不同类型的系统锁来保护内部数据库和内存结构。</p><p>这些机制是用户无法访问的。</p><h2 id="三-死锁"><a href="#三-死锁" class="headerlink" title="三. 死锁"></a>三. 死锁</h2><p>当两个用户希望持有对方的资源时就会发生死锁。</p><p>即两个用户互相等待对方释放资源时，oracle认定为产生了死锁,在这种情况下,将以牺牲一个用户作为代价,另一个用户继续执行,牺牲的用户的事务将回滚。</p><h3 id="3-1-场景"><a href="#3-1-场景" class="headerlink" title="3.1 场景"></a>3.1 场景</h3><p>1：用户 1 对 A 表进行 Update，没有提交。  2：用户 2 对 B 表进行 Update，没有提交。</p><p>此时双反不存在资源共享的问题。</p><p>3：如果用户 2 此时对 A 表作 update,则会发生阻塞，需要等到用户一的事物结束。  4：如果此时用户 1 又对 B 表作 update，则产生死锁。此时 Oracle 会选择其中一个用户进行会滚，使另一个用户继续执行操作。</p><h3 id="3-2-起因分析"><a href="#3-2-起因分析" class="headerlink" title="3.2 起因分析"></a>3.2 起因分析</h3><p>Oracle 的死锁问题实际上很少见，如果发生，基本上都是不正确的程序设计造成的，经过调整后，基本上都会避免死锁的发生。</p><p>在 Oracle 系统中能自动发现死锁，并选择代价最小的，即完成工作量最少的事务予以撤消，释放该事务所拥有的全部锁，记其它的事务继续工作下去。</p><p>从系统性能上考虑，应该尽可能减少资源竞争，增大吞吐量，因此用户在给并发操作加锁时，应注意以下几点：</p><ul><li>1、 对于 UPDATE 和 DELETE 操作，应只锁要做改动的行，在完成修改后立即提交。</li><li>2、 当多个事务正利用共享更新的方式进行更新，则不要使用共享封锁，而应采用共享更新锁，这样其它用户就能使用行级锁，以增加并行性。</li><li>3、 尽可能将对一个表的操作的并发事务施加共享更新锁，从而可提高并行性。</li><li>4、 在应用负荷较高的期间，不宜对基础数据结构（表、索引、簇和视图）进行修改</li></ul><h3 id="3-3-死锁后的解决办法"><a href="#3-3-死锁后的解决办法" class="headerlink" title="3.3 死锁后的解决办法"></a>3.3 死锁后的解决办法</h3><p>死锁不能自动释放，需要手动杀死会话。</p><p>1.查看有无死锁对象。</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> <span class="string">&#x27;alter system kill session &#x27;&#x27;&#x27;</span> <span class="operator">||</span> sid <span class="operator">||</span> <span class="string">&#x27;,&#x27;</span> <span class="operator">||</span> serial# <span class="operator">||</span> <span class="string">&#x27;&#x27;&#x27;;&#x27;</span> &quot;Deadlock&quot;  <span class="keyword">FROM</span> v$session <span class="keyword">WHERE</span> sid <span class="keyword">IN</span> (<span class="keyword">SELECT</span> sid <span class="keyword">FROM</span> v$lock <span class="keyword">WHERE</span> block <span class="operator">=</span> <span class="number">1</span>);</span><br></pre></td></tr></table></figure><p>2.手动杀死会话。</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">alter</span> <span class="keyword">system</span> kill session <span class="string">&#x27;646,3953&#x27;</span>;</span><br></pre></td></tr></table></figure><p><img src="https://pic-1258215793.cos.ap-shanghai.myqcloud.com/content/20211001/202110010102.png"></p><p>查看导致死锁的 SQL：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> s.sid, q.sql_textFROM v$sqltext q, v$session sWHERE q.address <span class="operator">=</span> s.sql_address <span class="keyword">AND</span> s.sid <span class="operator">=</span> <span class="operator">&amp;</span>sid</span><br></pre></td></tr></table></figure><p>执行后，输入对应的sid即可查看对应的sql。</p><p><img src="https://pic-1258215793.cos.ap-shanghai.myqcloud.com/content/20211001/202110010103.png"></p><p>如果上述找不到对应的sql，可以先执行查看谁锁了谁（2）的sql，查到另外一个sid，根据另外一个sid，会查到对应的sql：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> s1.username<span class="operator">||</span> <span class="string">&#x27;@&#x27;</span><span class="operator">||</span> s1.machine<span class="operator">||</span> <span class="string">&#x27; ( SID=&#x27;</span><span class="operator">||</span> s1.sid<span class="operator">||</span> <span class="string">&#x27; ) is blocking &#x27;</span><span class="operator">||</span> s2.username<span class="operator">||</span> <span class="string">&#x27;@&#x27;</span><span class="operator">||</span> s2.machine<span class="operator">||</span> <span class="string">&#x27; ( SID=&#x27;</span><span class="operator">||</span> s2.sid<span class="operator">||</span> <span class="string">&#x27; ) &#x27;</span><span class="keyword">AS</span> blocking_statusFROM v$lock l1,v$session s1,v$lock l2,v$session s2WHERE s1.sid <span class="operator">=</span> l1.sidAND s2.sid <span class="operator">=</span> l2.sidAND l1.BLOCK <span class="operator">=</span> <span class="number">1</span><span class="keyword">AND</span> l2.request <span class="operator">&gt;</span> <span class="number">0</span><span class="keyword">AND</span> l1.id1 <span class="operator">=</span> l2.id1AND l2.id2 <span class="operator">=</span> l2.id2;</span><br></pre></td></tr></table></figure><p><img src="https://pic-1258215793.cos.ap-shanghai.myqcloud.com/content/20211001/202110010104.png"></p><p>或者</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> LPAD (<span class="string">&#x27; &#x27;</span>, DECODE (l.xidusn, <span class="number">0</span>, <span class="number">3</span>, <span class="number">0</span>))<span class="operator">||</span> l.oracle_usernameUser_name,o.owner,o.object_name,o.object_type,s.sid,s.serial#<span class="keyword">FROM</span> v$locked_object l, dba_objects o, v$session sWHERE l.object_id <span class="operator">=</span> o.object_id <span class="keyword">AND</span> l.session_id <span class="operator">=</span> s.sidORDER <span class="keyword">BY</span> o.object_id, xidusn <span class="keyword">DESC</span>;</span><br></pre></td></tr></table></figure><p><img src="https://pic-1258215793.cos.ap-shanghai.myqcloud.com/content/20211001/202110010105.png"></p><h2 id="四-锁和阻塞"><a href="#四-锁和阻塞" class="headerlink" title="四. 锁和阻塞"></a>四. 锁和阻塞</h2><h3 id="4-1-概念"><a href="#4-1-概念" class="headerlink" title="4.1 概念"></a>4.1 概念</h3><p>通常来讲，系统如果平时运行正常，突然会停止不动，多半是被阻塞（Blocked）住了。 我们可以通过 v$lock 这张视图，看查看阻塞的信息。</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">desc</span> v$lockName Type   Nullable <span class="keyword">Default</span> Comments <span class="comment">------- ----------- -------- ------- -------- ADDR RAW(8) Y                        KADDR RAW(8) Y                        SID  NUMBER Y                        TYPE VARCHAR2(2) Y                        ID1  NUMBER Y                        ID2  NUMBER Y                        LMODE NUMBER Y                        REQUEST NUMBER Y                        CTIME NUMBER Y                        BLOCK NUMBER Y                        SQL&gt; </span></span><br></pre></td></tr></table></figure><p><img src="https://pic-1258215793.cos.ap-shanghai.myqcloud.com/content/20211001/202110010106.png"></p><p>我们关注的比较多的是 request 和 block 字段。  如果某个 request 列是一个非 0 值，那么它就是在等待一个锁。 如果 block 列是1，这个 SID 就持有了一个锁，并且阻塞别人获得这个锁。</p><p>这个锁的类型由 TYPE字段定义。锁的模式有 LMODE 字段定义， ID1 和 ID2 字段定义了这个锁的相关信息。</p><p>ID1 相同，就代表指向同一个资源。 这样就有可能有加锁者和等待者。</p><p>LMODE 的 6 中模式参考上面的 TM 锁类型表。</p><p><img src="https://pic-1258215793.cos.ap-shanghai.myqcloud.com/content/20211001/202110010107.png"></p><p>可以结合 <code>v$lock</code> 和 <code>v$session</code> 视图来查询相关的信息：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> sn.username,       m.SID,       sn.SERIAL#,       m.TYPE,       DECODE(m.lmode,              <span class="number">0</span>,              <span class="string">&#x27;None&#x27;</span>,              <span class="number">1</span>,              <span class="string">&#x27;Null&#x27;</span>,              <span class="number">2</span>,              <span class="string">&#x27;Row Share&#x27;</span>,              <span class="number">3</span>,              <span class="string">&#x27;Row Excl.&#x27;</span>,              <span class="number">4</span>,              <span class="string">&#x27;Share&#x27;</span>,              <span class="number">5</span>,              <span class="string">&#x27;S/Row Excl.&#x27;</span>,              <span class="number">6</span>,              <span class="string">&#x27;Exclusive&#x27;</span>,              lmode,              LTRIM(TO_CHAR(lmode, <span class="string">&#x27;990&#x27;</span>))) lmode,       DECODE(m.request,              <span class="number">0</span>,              <span class="string">&#x27;None&#x27;</span>,              <span class="number">1</span>,              <span class="string">&#x27;Null&#x27;</span>,              <span class="number">2</span>,              <span class="string">&#x27;Row Share&#x27;</span>,              <span class="number">3</span>,              <span class="string">&#x27;Row Excl.&#x27;</span>,              <span class="number">4</span>,              <span class="string">&#x27;Share&#x27;</span>,              <span class="number">5</span>,              <span class="string">&#x27;S/Row Excl.&#x27;</span>,              <span class="number">6</span>,              <span class="string">&#x27;Exclusive&#x27;</span>,              request,              LTRIM(TO_CHAR(m.request, <span class="string">&#x27;990&#x27;</span>))) request,       m.id1,       m.id2  <span class="keyword">FROM</span> v$session sn, v$lock m <span class="keyword">WHERE</span> (sn.SID <span class="operator">=</span> m.SID <span class="keyword">AND</span> m.request <span class="operator">!=</span> <span class="number">0</span>)      <span class="comment">--存在锁请求，即被阻塞    OR (sn.SID = m.SID       --不存在锁请求，但是锁定的对象被其他会话请求锁定       AND m.request = 0 AND lmode != 4 AND       (id1, id2) IN (SELECT s.id1, s.id2                         FROM v$lock s                        WHERE request != 0                          AND s.id1 = m.id1                          AND s.id2 = m.id2)) ORDER BY id1, id2, m.request;</span></span><br></pre></td></tr></table></figure><p>或者</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> <span class="comment">/*+ rule */</span> s.username, DECODE(l.TYPE, <span class="string">&#x27;TM&#x27;</span>, <span class="string">&#x27;TABLE LOCK&#x27;</span>, <span class="string">&#x27;TX&#x27;</span>, <span class="string">&#x27;ROW LOCK&#x27;</span>, <span class="keyword">NULL</span>) lock_level, o.owner, o.object_name, o.object_type, s.sid, s.serial#, s.terminal, s.machine, s.program, s.osuser  <span class="keyword">FROM</span> v$session s, v$lock l, dba_objects o <span class="keyword">WHERE</span> l.sid <span class="operator">=</span> s.sid   <span class="keyword">AND</span> l.id1 <span class="operator">=</span> o.object_id(<span class="operator">+</span>)   <span class="keyword">AND</span> s.username <span class="keyword">IS</span> <span class="keyword">NOT</span> <span class="keyword">NULL</span>;</span><br></pre></td></tr></table></figure><h3 id="4-2-引起阻塞的几种常见情况"><a href="#4-2-引起阻塞的几种常见情况" class="headerlink" title="4.2 引起阻塞的几种常见情况"></a>4.2 引起阻塞的几种常见情况</h3><h4 id="4-2-1-DML-语句引起阻塞"><a href="#4-2-1-DML-语句引起阻塞" class="headerlink" title="4.2.1 DML 语句引起阻塞"></a>4.2.1 DML 语句引起阻塞</h4><p>当一个会话保持另一个会话正在请求的资源上的锁定时，就会发生阻塞。被阻塞的会话将一直挂起，直到持有锁的会话放弃锁定的资源为止。</p><p>4 个常见的 dml 语句会产生阻塞:</p><ul><li><p><strong>INSERT</strong>：唯一情况就是用户拥有一个建有主键约束的表。当 2 个会话同时试图向表中插入相同的数据时，其中的一个会话将被阻塞，直到另外一个会话提交或会滚。一个会话提交时，另一个会话将收到主键重复的错误。回滚时，被阻塞的会话将继续执行。</p></li><li><p><strong>UPDATE</strong>：当执行 Update 和 delete 操作的数据行已经被另外的会话锁定时，将会发生阻塞，直到另一个会话提交或会滚。</p></li><li><p><strong>DELETE</strong>：同UPDATE。</p></li><li><p><strong>SELECT … FOR UPDATE</strong>：</p><p>当一个用户执行 select..for update 对返回的结果集进行修改时，如  果结果集已经被另一个会话锁定，此时 Oracle 已经对返回的结果集上加了排它的行级锁， 所有其他对这些数据进行的修改或删除操作都必须等待这个锁的释放(操作 commit 或 rollback.)，产生的外在现象就是其他的操作将发生阻塞。</p><p>同样这个查询的事务将会对该表加表级锁，不允许对该表的任何 ddl 操作，否则将会报出 <code>Ora-00054:resource busy and acquire with nowait specified.</code> 。</p><p>可以通过发出 <code>select ... for update nowait</code> 的语句来避免发生阻塞，如果资源已经被另一个会话锁定，则会返回以下错误：<code>Ora-00054:resource busy and acquire with nowait specified.</code> 。</p></li></ul><h4 id="4-2-2-外键没有创建索引"><a href="#4-2-2-外键没有创建索引" class="headerlink" title="4.2.2 外键没有创建索引"></a>4.2.2 外键没有创建索引</h4><p>如果系统中有主，外键引用关系，并且满足一下三个条件中的任意一个，那么就应该考虑给外键字段创建索引，否则系统的性能可能会下降甚至阻塞。</p><ul><li>主表上有频繁的删除操作。</li><li>主键上有频繁的修改操作。</li><li>业务上经常会出现主表和从表做关联查询的情况。</li></ul><p>第一和第二个条件操作的时候，主表会在从表上创建一个锁定，以保证主表主键的修改不会导致从表的数据在引用上出现问题，这是一个数据引用完整性的要求。</p><p>如果主表上经常出现这样的删除或者是对主键列进行修改的操作，或者每次操作的记录数很多，都将会造成从表长时间被锁定，而影响其他用户的正常操作。</p><p>比如主表每次删除 1000 行数据，它就需要扫描从表 1000 次，以确定每一行记录的改变都不会造成从表数据在引用上的不完整。</p><p>特别是在 OLAP 系统中，从表经常会是非常巨大的表，在这种情况下，如果从表没有索引，那么查询几乎是不可想象的。</p><h2 id="五-Latch"><a href="#五-Latch" class="headerlink" title="五. Latch"></a>五. Latch</h2><h3 id="5-1-概述"><a href="#5-1-概述" class="headerlink" title="5.1 概述"></a>5.1 概述</h3><ul><li>Latch属于 System Lock, 用于保护 SGA区中共享数据结构的一种串行化锁定机制。</li><li>Latch 的实现是与操作系统相关的，尤其和一个进程是否需要等待一个latch、需要等待多长时间有关。</li><li>Latch 是 Oracle 提供的轻量级锁资源， 是一种能够极快地被获取和释放的锁，能快速，短时间的锁定资源。</li><li>Latch用于防止多个并发进程同时修改访问某个共享资源， 它只工作在 SGA 中， 通常用于保护描述 buffer cache 中 block 的数据结构。</li></ul><p>比如 SGA 中，各种数据被反复从磁盘读取到内存，又被重新写回到磁盘上，如果有并发的用户做相同的事情， Oracle 必须使用一种机制，来保证数据在读取的时候，只能由一个会话来完成，这种保护机制就是 Latch。</p><ul><li>并发（ concurrency）： 是说有超过两个以上的用户对同样的数据做修改（可能包括插入，删除和修改）。</li><li>并行（ parallel）： 是说将一件事情分成很多小部分，让每一部分同时执行，最后将执行结果汇总成最终结果。</li></ul><p>与每个 latch 相联系的还有一个清除过程，当持有 latch 的进程成为死进程时，该清除过程就会被调用。</p><p>Latch 还具有相关级别，用于防止死锁，一旦一个进程在某个级别上得到一个 latch，它就不可能再获得等同或低于该级别的 latch。</p><p>Latch 不会造成阻塞，只会导致等待。 阻塞是一种系统设计上的问题，等待是一种系统资源争用的问题。</p><h3 id="5-2-spin"><a href="#5-2-spin" class="headerlink" title="5.2 spin"></a>5.2 spin</h3><p>比如数据缓存中的某个块要被读取，我们会获得这个块的 latch， 这个过程叫做 spin，另外一个进程恰好要修改这个块，他也要 spin 这个块，此时他必须等待，当前一个进程释放 latch 后才能 spin 住，然后修改， 如果多个进程同时请求的话，他们之间将出现竞争，没有一个入队机制，一旦前面进程释放所定，后面的进程就蜂拥而上，没有先来后到的概念， 并且这一切都发生的非常快，因为Latch 的特点是快而短暂。</p><p>SPIN 与休眠（ sleep）  Oracle 选择了 spin，让进程继续占有 CPU，运行一些空指令，之后继续请求，继续 spin，直到达到_spin_count 值，这时会放弃 CPU，进行短暂的休眠，再继续刚才的动作。</p><p>进程休眠的时间也是存在算法的.休眠的阀值限制由隐含参数_max_exponential_sleep控制， 默认是 2 秒。</p><p>如果当前进程已经占用了别的 Latch，则他的休眠时间不会太长(过长会引起别的进程的 Latch 等待)，此时的休眠最大时间有隐含参数_max_sleep_holding_latch 决定， 默认是 4 厘秒。</p><p>总之，Latch 获取的流程： 请求-SPIN-休眠-请求-SPIN-休眠 … … 占用。</p><h3 id="5-3-Latch-和-Lock"><a href="#5-3-Latch-和-Lock" class="headerlink" title="5.3 Latch 和 Lock"></a>5.3 Latch 和 Lock</h3><p>从某种意义上说， Latch 是内存中的资源锁，数据库对象(表，索引等)的锁叫Lock。</p><p>Latch 和 Lock 的区别:</p><ul><li>Latch 是对内存数据结构提供互斥访问的一种机制，而 Lock 是以不同的模式来套取共享资源对象，各个模式间存在着兼容或排斥，从这点看出， Latch的访问，包括查询也是互斥的，任何时候，只能有一个进程能 spin 住内存的某一块，幸好这个过程是相当的短暂，否则系统性能将没的保障，从 9I 开始，允许多个进程同时查询相同的内存块。</li><li>Latch 只作用于内存中，他只能被当前实例访问，而 Lock 作用于数据库对象，在 RAC 体系中实例间允许 Lock 检测与访问</li><li>Latch 是瞬间的占用，释放， Lock 的释放需要等到事务正确的结束，他占用的时间长短由事务大小决定</li><li>Latch 是非入队的，而 Lock 是入队的</li><li>Latch 不存在死锁，而 Lock 中存在。</li></ul><h3 id="5-4-Latch-争用"><a href="#5-4-Latch-争用" class="headerlink" title="5.4 Latch 争用"></a>5.4 Latch 争用</h3><p>如果发现系统中经常由于 Lock 导致用户等待，这时需要考虑系统在逻辑设计上是否有问题，比如多用户对主键的删除或者修改，是否有用户使用 select … for update 这样的语法，外键是否创建索引的因素。 这些因素是需要结合系统的业务逻辑性来进行数据库对象设计的。</p><p>如果发现系统慢是因为很多的 Latch 争用，就要考虑系统及数据库自身设计上是否存在问题，比如是否使用绑定变量，是否存在热快，数据存储参数设计是否合理等因素。  导致 Latch 争用而等待的原因非常多，内存中很多资源都可能存在争用。</p><p>最常见的两类 latch 争用如下：</p><ol><li>共享池中的 Latch 争用。 </li><li>数据缓冲池中的 latch 争用。</li></ol><h4 id="（1）共享池中的-Latch-争用"><a href="#（1）共享池中的-Latch-争用" class="headerlink" title="（1）共享池中的 Latch 争用"></a>（1）共享池中的 Latch 争用</h4><p>共享池中如果存在大量的 SQL 被反复分析，就会造成很大的 Latch 争用和长时间的等待， 最常见的现象就是没有绑定变量。</p><p><strong>最常见的集中共享池里的 Latch 是 library cache。</strong></p><p>可以通过一下 SQL 来查询：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> v$latchname <span class="keyword">where</span> name <span class="keyword">like</span> <span class="string">&#x27;library cache%&#x27;</span>;</span><br></pre></td></tr></table></figure><p><img src="https://pic-1258215793.cos.ap-shanghai.myqcloud.com/content/20211001/202110010108.png"></p><p>在分析系统性能时，如果看到有 library cache 这样的 Latch 争用，就可以断定是共享池中出现了问题，这种问题基本是由 SQL 语句导致的，比如没有绑定变量 或者一些存储过程被反复分析。</p><p><strong>资源的争用可以通过如下 SQL 来查看</strong>：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> event,<span class="built_in">count</span>(<span class="operator">*</span>) <span class="keyword">from</span> v$session_wait <span class="keyword">group</span> <span class="keyword">by</span> event;</span><br></pre></td></tr></table></figure><p><img src="https://pic-1258215793.cos.ap-shanghai.myqcloud.com/content/20211001/202110010109.png"></p><h4 id="（2）数据缓冲池中的-latch-争用"><a href="#（2）数据缓冲池中的-latch-争用" class="headerlink" title="（2）数据缓冲池中的 latch 争用"></a>（2）数据缓冲池中的 latch 争用</h4><p>访问频率非常高的数据块被称为热快（ Hot Block），当很多用户一起去访问某几个数据块时，就会导致一些 Latch 争用。</p><p>最常见的 latch 争用有：</p><ul><li> buffer busy waits</li><li> cache buffer chain</li></ul><p>这两个 Latch 的争用分别发生在访问数据块的不同时刻。</p><p>产生这些 Latch 争用的直接原因是太多的会话去访问相同的数据块导致热快问题， 造成热快的原因可能是数据库设置导致或者重复执行的 SQL 频繁访问一些相同的数据块导致。</p><hr><p>参考：</p><p>🔗 《<a href="https://cloud.tencent.com/developer/article/1451003">Oracle数据库各种”锁”</a>》</p>]]></content>
    
    
    <summary type="html">内容包括：简述，锁类别（自动锁和显示锁、排他锁和共享锁、DML锁、DLL锁和System Locks），死锁，锁和阻塞，Latch。</summary>
    
    
    
    <category term="技术文档" scheme="http://linyishui.top/categories/%E6%8A%80%E6%9C%AF%E6%96%87%E6%A1%A3/"/>
    
    
    <category term="lock" scheme="http://linyishui.top/tags/lock/"/>
    
    <category term="oracle" scheme="http://linyishui.top/tags/oracle/"/>
    
  </entry>
  
  <entry>
    <title>Spring AMQP</title>
    <link href="http://linyishui.top/2021092601.html"/>
    <id>http://linyishui.top/2021092601.html</id>
    <published>2021-09-26T06:22:55.000Z</published>
    <updated>2021-11-04T11:49:16.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Spring-AMQP"><a href="#Spring-AMQP" class="headerlink" title="Spring AMQP"></a>Spring AMQP</h1><h2 id="一-简介"><a href="#一-简介" class="headerlink" title="一. 简介"></a>一. 简介</h2><h3 id="1-1-什么是Spring-AMQP"><a href="#1-1-什么是Spring-AMQP" class="headerlink" title="1.1 什么是Spring AMQP"></a>1.1 什么是Spring AMQP</h3><p>Advanced Message Queuing Protocol，即高级消息队列协议，旨在提供一种跨平台跨语言的消息服务，AMQP是一种应用层协议，不同于JMS(API接口)，使用 TCP 提供可靠投递的应用层协议。</p><p>Spring AMQP则是Spring方便开发RabbitMQ程序集成的一个第三方类库。</p><ul><li>提供“模板”作为用于发送和接收消息的高级抽象。</li><li>还为消息驱动的 POJO 提供支持。</li></ul><h3 id="1-2-简单使用"><a href="#1-2-简单使用" class="headerlink" title="1.2 简单使用"></a>1.2 简单使用</h3><h4 id="（1）Maven依赖"><a href="#（1）Maven依赖" class="headerlink" title="（1）Maven依赖"></a>（1）Maven依赖</h4><p>引入Maven依赖：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.amqp<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-rabbit<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">version</span>&gt;</span>2.1.2.RELEASE<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure><p>此包同时包含：</p><ul><li>spring-context</li><li>spring-tx</li><li>spring-web</li><li>spring-messaging</li><li>spring-retry</li><li>spring-amqp</li><li>amqp-client</li></ul><h4 id="（2）快速上手"><a href="#（2）快速上手" class="headerlink" title="（2）快速上手"></a>（2）快速上手</h4><p>基于默认配置：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">ConnectionFactory connectionFactory = <span class="keyword">new</span> CachingConnectionFactory();</span><br><span class="line">AmqpAdmin admin = <span class="keyword">new</span> RabbitAdmin(connectionFactory);</span><br><span class="line">admin.declareQueue(<span class="keyword">new</span> Queue(<span class="string">&quot;myqueue&quot;</span>));</span><br><span class="line">AmqpTemplate template = <span class="keyword">new</span> RabbitTemplate(connectionFactory);</span><br><span class="line">template.convertAndSend(<span class="string">&quot;myqueue&quot;</span>, <span class="string">&quot;foo&quot;</span>);</span><br><span class="line">String foo = (String) template.receiveAndConvert(<span class="string">&quot;myqueue&quot;</span>);</span><br></pre></td></tr></table></figure><h4 id="（3）XML配置"><a href="#（3）XML配置" class="headerlink" title="（3）XML配置"></a>（3）XML配置</h4><p>基于XML配置：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">ApplicationContext context = <span class="keyword">new</span> GenericXmlApplicationContext(<span class="string">&quot;classpath:/rabbit-context.xml&quot;</span>);</span><br><span class="line">AmqpTemplate template = context.getBean(AmqpTemplate.class);</span><br><span class="line">template.convertAndSend(<span class="string">&quot;myqueue&quot;</span>, <span class="string">&quot;foo&quot;</span>);</span><br><span class="line">String foo = (String) template.receiveAndConvert(<span class="string">&quot;myqueue&quot;</span>);</span><br></pre></td></tr></table></figure><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">beans</span> <span class="attr">xmlns</span>=<span class="string">&quot;http://www.springframework.org/schema/beans&quot;</span></span></span><br><span class="line"><span class="tag">       <span class="attr">xmlns:xsi</span>=<span class="string">&quot;http://www.w3.org/2001/XMLSchema-instance&quot;</span></span></span><br><span class="line"><span class="tag">       <span class="attr">xmlns:rabbit</span>=<span class="string">&quot;http://www.springframework.org/schema/rabbit&quot;</span></span></span><br><span class="line"><span class="tag">       <span class="attr">xsi:schemaLocation</span>=<span class="string">&quot;http://www.springframework.org/schema/rabbit</span></span></span><br><span class="line"><span class="string"><span class="tag">           http://www.springframework.org/schema/rabbit/spring-rabbit.xsd</span></span></span><br><span class="line"><span class="string"><span class="tag">           http://www.springframework.org/schema/beans</span></span></span><br><span class="line"><span class="string"><span class="tag">           http://www.springframework.org/schema/beans/spring-beans.xsd&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">rabbit:connection-factory</span> <span class="attr">id</span>=<span class="string">&quot;connectionFactory&quot;</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">rabbit:template</span> <span class="attr">id</span>=<span class="string">&quot;amqpTemplate&quot;</span> <span class="attr">connection-factory</span>=<span class="string">&quot;connectionFactory&quot;</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">rabbit:admin</span> <span class="attr">connection-factory</span>=<span class="string">&quot;connectionFactory&quot;</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">rabbit:queue</span> <span class="attr">name</span>=<span class="string">&quot;myqueue&quot;</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">beans</span>&gt;</span></span><br></pre></td></tr></table></figure><h4 id="（4）Java配置"><a href="#（4）Java配置" class="headerlink" title="（4）Java配置"></a>（4）Java配置</h4><p>同样的示例使用 Java 中的外部配置：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line">ApplicationContext context = <span class="keyword">new</span> AnnotationConfigApplicationContext(RabbitConfiguration.class);</span><br><span class="line">AmqpTemplate template = context.getBean(AmqpTemplate.class);</span><br><span class="line">template.convertAndSend(<span class="string">&quot;myqueue&quot;</span>, <span class="string">&quot;foo&quot;</span>);</span><br><span class="line">String foo = (String) template.receiveAndConvert(<span class="string">&quot;myqueue&quot;</span>);</span><br><span class="line"></span><br><span class="line">........</span><br><span class="line"></span><br><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">RabbitConfiguration</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> ConnectionFactory <span class="title">connectionFactory</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> CachingConnectionFactory(<span class="string">&quot;localhost&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> AmqpAdmin <span class="title">amqpAdmin</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> RabbitAdmin(connectionFactory());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> RabbitTemplate <span class="title">rabbitTemplate</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> RabbitTemplate(connectionFactory());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Queue <span class="title">myQueue</span><span class="params">()</span> </span>&#123;</span><br><span class="line">       <span class="keyword">return</span> <span class="keyword">new</span> Queue(<span class="string">&quot;myqueue&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="二-使用"><a href="#二-使用" class="headerlink" title="二. 使用"></a>二. 使用</h2><h3 id="2-1-ConnectionFactory默认配置"><a href="#2-1-ConnectionFactory默认配置" class="headerlink" title="2.1 ConnectionFactory默认配置"></a>2.1 ConnectionFactory默认配置</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MqProducerConfig</span> </span>&#123;</span><br><span class="line">    </span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> ConnectionFactory <span class="title">amqpConnectionFactory</span><span class="params">(ConnectionListener connectionListener,</span></span></span><br><span class="line"><span class="params"><span class="function">                                                  RecoveryListener recoveryListener,</span></span></span><br><span class="line"><span class="params"><span class="function">                                                  ChannelListener channelListener)</span> </span>&#123;</span><br><span class="line">        CachingConnectionFactory connectionFactory = <span class="keyword">new</span> CachingConnectionFactory();</span><br><span class="line">        <span class="comment">// 配置rabbitmq的地址、端口，集群部署的情况下可填写多个，“,”分隔</span></span><br><span class="line">        connectionFactory.setAddresses(<span class="string">&quot;localhost:5672&quot;</span>);</span><br><span class="line">        <span class="comment">// 用户名</span></span><br><span class="line">        connectionFactory.setUsername(<span class="string">&quot;guest&quot;</span>);</span><br><span class="line"><span class="comment">// 密码</span></span><br><span class="line">        connectionFactory.setPassword(<span class="string">&quot;guest&quot;</span>);</span><br><span class="line"><span class="comment">// 虚拟主机</span></span><br><span class="line">        connectionFactory.setVirtualHost(<span class="string">&quot;/&quot;</span>);</span><br><span class="line">        <span class="comment">// 设置缓存模式，共有两种，CHANNEL和CONNECTION模式</span></span><br><span class="line">        connectionFactory.setCacheMode(CachingConnectionFactory.CacheMode.CHANNEL);</span><br><span class="line"><span class="comment">// 设置每个Connection中可以缓存的Channel的数量，非数量上限，获取Channel前会先尝试从缓存中找到一个闲置的，若无则会创建新的，当数量超过缓存数量时，多出来的会被关闭。该值修改只会影响后创建的Connection</span></span><br><span class="line">        connectionFactory.setChannelCacheSize(<span class="number">25</span>);</span><br><span class="line">        <span class="comment">// 设置Channel等待时间，大于0时setChannelCacheSize会同时变为数量上限，从缓存取不到可用的Channel时不会创建新的，而是等待该值指定的毫秒时间，若到点仍无可用的Channel会抛出AmqpTimeoutException异常；Connection模式下，该值也同样是Connection的获取超时时间</span></span><br><span class="line">        connectionFactory.setChannelCheckoutTimeout(<span class="number">0</span>);</span><br><span class="line">        <span class="comment">// Producer端消息确认机制开关，return机制</span></span><br><span class="line">        connectionFactory.setPublisherReturns(<span class="keyword">false</span>);</span><br><span class="line">        <span class="comment">// Producer端消息确认机制开关，confirm机制</span></span><br><span class="line">        connectionFactory.setPublisherConfirms(<span class="keyword">false</span>);</span><br><span class="line">        <span class="comment">// 配置ConnectionListener</span></span><br><span class="line">        connectionFactory.addConnectionListener(connectionListener);</span><br><span class="line">        <span class="comment">// 配置ChannelListener</span></span><br><span class="line">        connectionFactory.addChannelListener(channelListener);</span><br><span class="line">        <span class="comment">// 配置RecoveryListener</span></span><br><span class="line">        connectionFactory.setRecoveryListener(recoveryListener);</span><br><span class="line">        <span class="comment">// 仅在Connection模式下使用，设置Connection的缓存数量</span></span><br><span class="line">        <span class="comment">//connectionFactory.setConnectionCacheSize(1);</span></span><br><span class="line">        <span class="comment">// 仅在Connection模式下使用，设置Connection的数量上限</span></span><br><span class="line">        <span class="comment">//connectionFactory.setConnectionLimit(Integer.MAX_VALUE);</span></span><br><span class="line">        <span class="keyword">return</span> connectionFactory;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li><strong>Channel模式：</strong>程序运行期间ConnectionFactory会维护一个Connection，所有的操作都使用此Connection，但一个Connection中可以有多个Channel，操作rabbitmq之前都必须先获取到一个Channel，否则就会阻塞（可以通过 <code>setChannelCheckoutTimeout()</code> 设置等待时间），这些Channel会被缓存（缓存的数量可以通过 <code>setChannelCacheSize()</code> 设置）；</li><li><strong>Connection模式：</strong>这个模式下允许创建多个Connection，会缓存一定数量的Connection，每个Connection中同样会缓存一些Channel，除了可以有多个Connection，其它都跟CHANNEL模式一样。</li></ul><h3 id="2-2-com-rabbitmq-client-ConnectionFactory自定义配置"><a href="#2-2-com-rabbitmq-client-ConnectionFactory自定义配置" class="headerlink" title="2.2 com.rabbitmq.client.ConnectionFactory自定义配置"></a>2.2 com.rabbitmq.client.ConnectionFactory自定义配置</h3><p>ConnectionFactory类连接MQ节点的Connection配置：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/** Default user name */</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> String DEFAULT_USER = <span class="string">&quot;guest&quot;</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/** Default password */</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> String DEFAULT_PASS = <span class="string">&quot;guest&quot;</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/** Default virtual host */</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> String DEFAULT_VHOST = <span class="string">&quot;/&quot;</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/** Default maximum channel number;</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">*  zero for unlimited */</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span>    DEFAULT_CHANNEL_MAX = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/** Default maximum frame size;</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">*  zero means no limit */</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span>    DEFAULT_FRAME_MAX = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/** Default heart-beat interval;</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">*  60 seconds */</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span>    DEFAULT_HEARTBEAT = <span class="number">60</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/** The default host */</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> String DEFAULT_HOST = <span class="string">&quot;localhost&quot;</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/** &#x27;Use the default port&#x27; port */</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span>    USE_DEFAULT_PORT = -<span class="number">1</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/** The default non-ssl port */</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span>    DEFAULT_AMQP_PORT = AMQP.PROTOCOL.PORT;</span><br><span class="line"></span><br><span class="line"><span class="comment">/** The default ssl port */</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span>    DEFAULT_AMQP_OVER_SSL_PORT = <span class="number">5671</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/** The default TCP connection timeout: 60 seconds */</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span>    DEFAULT_CONNECTION_TIMEOUT = <span class="number">60000</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">* The default AMQP 0-9-1 connection handshake timeout. See DEFAULT_CONNECTION_TIMEOUT</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">* for TCP (socket) connection timeout.</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span>    DEFAULT_HANDSHAKE_TIMEOUT = <span class="number">10000</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/** The default shutdown timeout;</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">*  zero means wait indefinitely */</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span>    DEFAULT_SHUTDOWN_TIMEOUT = <span class="number">10000</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/** The default continuation timeout for RPC calls in channels: 10 minutes */</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span>    DEFAULT_CHANNEL_RPC_TIMEOUT = (<span class="keyword">int</span>) MINUTES.toMillis(<span class="number">10</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">/** The default network recovery interval: 5000 millis */</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">long</span>  DEFAULT_NETWORK_RECOVERY_INTERVAL = <span class="number">5000</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> String PREFERRED_TLS_PROTOCOL = <span class="string">&quot;TLSv1.2&quot;</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> String FALLBACK_TLS_PROTOCOL = <span class="string">&quot;TLSv1&quot;</span>;</span><br></pre></td></tr></table></figure><p>修改默认连接配置：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Bean</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> ConnectionFactory <span class="title">connectionFactory</span><span class="params">(com.rabbitmq.client.ConnectionFactory rabbitConnectionFactory)</span> </span>&#123;</span><br><span class="line">    CachingConnectionFactory connectionFactory = <span class="keyword">new</span> CachingConnectionFactory(rabbitConnectionFactory);</span><br><span class="line">    <span class="keyword">return</span> connectionFactory;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Bean</span></span><br><span class="line"><span class="keyword">public</span> com.rabbitmq.client.<span class="function">ConnectionFactory <span class="title">rabbitConnectionFactory</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    com.rabbitmq.client.ConnectionFactory connectionFactory = <span class="keyword">new</span> com.rabbitmq.client.ConnectionFactory();</span><br><span class="line">    connectionFactory.setAutomaticRecoveryEnabled(<span class="keyword">false</span>);</span><br><span class="line">    connectionFactory.setUsername(<span class="string">&quot;guest&quot;</span>);</span><br><span class="line">    connectionFactory.setPassword(<span class="string">&quot;guest&quot;</span>);</span><br><span class="line">    connectionFactory.setVirtualHost(<span class="string">&quot;/&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span> connectionFactory;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="2-3-AmqpTemplate配置"><a href="#2-3-AmqpTemplate配置" class="headerlink" title="2.3 AmqpTemplate配置"></a>2.3 AmqpTemplate配置</h3><p>若消费者端通过 <code>@RabbitListener</code> 注解的方式接收消息，则用不到此Bean。不建议直接使用ConnectionFactory获取Channel操作MQ，而是使用AmqpTemplate。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Bean</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> AmqpTemplate <span class="title">amqpTemplate</span><span class="params">(ConnectionFactory amqpConnectionFactory,</span></span></span><br><span class="line"><span class="params"><span class="function">                                RabbitTemplate.ReturnCallback returnCallback,</span></span></span><br><span class="line"><span class="params"><span class="function">                                RabbitTemplate.ConfirmCallback confirmCallback,</span></span></span><br><span class="line"><span class="params"><span class="function">                                RetryTemplate retryTemplate,</span></span></span><br><span class="line"><span class="params"><span class="function">                                MessageConverter messageConverter)</span></span>&#123;</span><br><span class="line">    RabbitTemplate rabbitTemplate = <span class="keyword">new</span> RabbitTemplate();</span><br><span class="line">    <span class="comment">// 设置spring-amqp的ConnectionFactory</span></span><br><span class="line">    rabbitTemplate.setConnectionFactory(amqpConnectionFactory);</span><br><span class="line">    <span class="comment">// 设置重试机制</span></span><br><span class="line">    rabbitTemplate.setRetryTemplate(retryTemplate);</span><br><span class="line">    <span class="comment">// 设置MessageConverter，用于java对象与Message对象（实际发送和接收的消息对象）之间的相互转换</span></span><br><span class="line">    rabbitTemplate.setMessageConverter(messageConverter);</span><br><span class="line">    <span class="comment">// 打开或关闭Channel的事务</span></span><br><span class="line">    rabbitTemplate.setChannelTransacted(<span class="keyword">false</span>);</span><br><span class="line">    <span class="comment">// return机制的回调接口</span></span><br><span class="line">    rabbitTemplate.setReturnCallback(returnCallback);</span><br><span class="line">    <span class="comment">// confirm机制的回调接口</span></span><br><span class="line">    rabbitTemplate.setConfirmCallback(confirmCallback);</span><br><span class="line">    <span class="comment">// 设为true使ReturnCallback生效</span></span><br><span class="line">    rabbitTemplate.setMandatory(<span class="keyword">false</span>);</span><br><span class="line">    <span class="keyword">return</span> rabbitTemplate;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="2-4-RabbitListenerContainerFactory配置"><a href="#2-4-RabbitListenerContainerFactory配置" class="headerlink" title="2.4 RabbitListenerContainerFactory配置"></a>2.4 RabbitListenerContainerFactory配置</h3><p>这个bean仅在消费者端通过 <code>@RabbitListener</code> 注解的方式接收消息时使用，每一个 <code>@RabbitListener</code> 注解的方法都会由这个RabbitListenerContainerFactory创建一个MessageListenerContainer，负责接收消息。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">  <span class="meta">@Bean</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> SimpleRabbitListenerContainerFactory <span class="title">rabbitListenerContainerFactory</span><span class="params">(CachingConnectionFactory cachingConnectionFactory, ErrorHandler errorHandler, MessageConverter messageConverter)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">      SimpleRabbitListenerContainerFactory factory = <span class="keyword">new</span> SimpleRabbitListenerContainerFactory();</span><br><span class="line"><span class="comment">// 设置spring-amqp的ConnectionFactory</span></span><br><span class="line">      factory.setConnectionFactory(cachingConnectionFactory);</span><br><span class="line"><span class="comment">// 对于消费者端，MessageConverter也可以在这里配置</span></span><br><span class="line">      factory.setMessageConverter(messageConverter);</span><br><span class="line"><span class="comment">// 设置消费者端的应答模式，共有三种：NONE、AUTO、MANUAL</span></span><br><span class="line">      factory.setAcknowledgeMode(AcknowledgeMode.AUTO);</span><br><span class="line"><span class="comment">// 设置每个MessageListenerContainer将会创建的Consumer的最小数量，默认是1个</span></span><br><span class="line">      factory.setConcurrentConsumers(<span class="number">1</span>);</span><br><span class="line"><span class="comment">// 设置每个MessageListenerContainer将会创建的Consumer的最大数量，默认等于最小数量</span></span><br><span class="line">      factory.setMaxConcurrentConsumers(<span class="number">1</span>);</span><br><span class="line"><span class="comment">// 设置每次请求发送给每个Consumer的消息数量</span></span><br><span class="line">      factory.setPrefetchCount(<span class="number">250</span>);</span><br><span class="line"><span class="comment">// 设置Channel的事务</span></span><br><span class="line">      factory.setChannelTransacted(<span class="keyword">false</span>);</span><br><span class="line"><span class="comment">// 设置事务当中可以处理的消息数量</span></span><br><span class="line">      factory.setTxSize(<span class="number">1</span>);</span><br><span class="line"><span class="comment">// 设置当rabbitmq收到nack/reject确认信息时的处理方式，设为true，扔回queue头部，设为false，丢弃</span></span><br><span class="line">      factory.setDefaultRequeueRejected(<span class="keyword">true</span>);</span><br><span class="line"><span class="comment">// 实现ErrorHandler接口设置进去，所有未catch的异常都会由ErrorHandler处理</span></span><br><span class="line">      factory.setErrorHandler(errorHandler);</span><br><span class="line">      <span class="keyword">return</span> factory;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure><p>消费者端的应答模式：</p><ul><li><strong>NONE：</strong>无应答，这种模式下rabbitmq默认consumer能正确处理所有发出的消息，所以不管消息有没有被consumer收到，有没有正确处理都不会恢复。</li><li><strong>AUTO：</strong>由Container自动应答，正确处理发出ack信息，处理失败发出nack信息，rabbitmq发出消息后将会等待consumer端的应答，只有收到ack确认信息才会把消息清除掉，收到nack信息的处理办法由setDefaultRequeueRejected()方法设置，所以在这种模式下，发生错误的消息是可以恢复的。</li><li><strong>MANUAL：</strong>基本同AUTO模式，区别是需要人为调用方法给应答。</li></ul><h3 id="2-5-发送消息"><a href="#2-5-发送消息" class="headerlink" title="2.5 发送消息"></a>2.5 发送消息</h3><p>AmqpTamplate的发送消息接口：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">send</span><span class="params">(Message message)</span> <span class="keyword">throws</span> AmqpException</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">send</span><span class="params">(String routingKey, Message message)</span> <span class="keyword">throws</span> AmqpException</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">send</span><span class="params">(String exchange, String routingKey, Message message)</span> <span class="keyword">throws</span> AmqpException</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">convertAndSend</span><span class="params">(Object message)</span> <span class="keyword">throws</span> AmqpException</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">convertAndSend</span><span class="params">(String routingKey, Object message)</span> <span class="keyword">throws</span> AmqpException</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">convertAndSend</span><span class="params">(String exchange, String routingKey, Object message)</span></span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function">    <span class="keyword">throws</span> AmqpException</span>;</span><br></pre></td></tr></table></figure><p>如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">amqpTemplate.send(exchange, routingKey, <span class="keyword">new</span> Message(JSON.toJSONString(event).getBytes(), MessagePropertiesBuilder.newInstance().build()));</span><br></pre></td></tr></table></figure><h3 id="2-6-接收消息"><a href="#2-6-接收消息" class="headerlink" title="2.6 接收消息"></a>2.6 接收消息</h3><h4 id="（1）拉模式"><a href="#（1）拉模式" class="headerlink" title="（1）拉模式"></a>（1）拉模式</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 轮询调用方法一次获取一条</span></span><br><span class="line"><span class="function">Message <span class="title">receive</span><span class="params">()</span> <span class="keyword">throws</span> AmqpException</span>;</span><br><span class="line"></span><br><span class="line"><span class="function">Message <span class="title">receive</span><span class="params">(String queueName)</span> <span class="keyword">throws</span> AmqpException</span>;</span><br><span class="line"></span><br><span class="line"><span class="function">Message <span class="title">receive</span><span class="params">(<span class="keyword">long</span> timeoutMillis)</span> <span class="keyword">throws</span> AmqpException</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 如果queue里面没有消息，会立刻返回null；传入timeoutMillis参数后可阻塞等待一段时间</span></span><br><span class="line"><span class="function">Message <span class="title">receive</span><span class="params">(String queueName, <span class="keyword">long</span> timeoutMillis)</span> <span class="keyword">throws</span> AmqpException</span>;</span><br></pre></td></tr></table></figure><p>直接转换为Java对象：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">Object <span class="title">receiveAndConvert</span><span class="params">()</span> <span class="keyword">throws</span> AmqpException</span>;</span><br><span class="line"></span><br><span class="line"><span class="function">Object <span class="title">receiveAndConvert</span><span class="params">(String queueName)</span> <span class="keyword">throws</span> AmqpException</span>;</span><br><span class="line"></span><br><span class="line"><span class="function">Object <span class="title">receiveAndConvert</span><span class="params">(<span class="keyword">long</span> timeoutMillis)</span> <span class="keyword">throws</span> AmqpException</span>;</span><br><span class="line"></span><br><span class="line"><span class="function">Object <span class="title">receiveAndConvert</span><span class="params">(String queueName, <span class="keyword">long</span> timeoutMillis)</span> <span class="keyword">throws</span> AmqpException</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 这四个方法需要配置org.springframework.amqp.support.converter.SmartMessageConverter，这是一个接口，Jackson2JsonMessageConverter已经实现了这个接口，所以只要将Jackson2JsonMessageConverter设置到RabbitTemplate中即可。</span></span><br><span class="line">&lt;T&gt; <span class="function">T <span class="title">receiveAndConvert</span><span class="params">(ParameterizedTypeReference&lt;T&gt; type)</span> <span class="keyword">throws</span> AmqpException</span>;</span><br><span class="line"></span><br><span class="line">&lt;T&gt; <span class="function">T <span class="title">receiveAndConvert</span><span class="params">(String queueName, ParameterizedTypeReference&lt;T&gt; type)</span> <span class="keyword">throws</span> AmqpException</span>;</span><br><span class="line"></span><br><span class="line">&lt;T&gt; <span class="function">T <span class="title">receiveAndConvert</span><span class="params">(<span class="keyword">long</span> timeoutMillis, ParameterizedTypeReference&lt;T&gt; type)</span> <span class="keyword">throws</span> AmqpException</span>;</span><br><span class="line"></span><br><span class="line">&lt;T&gt; <span class="function">T <span class="title">receiveAndConvert</span><span class="params">(String queueName, <span class="keyword">long</span> timeoutMillis, ParameterizedTypeReference&lt;T&gt; type)</span></span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function"><span class="keyword">throws</span> AmqpException</span>;</span><br><span class="line"></span><br><span class="line">Foo&lt;Bar&lt;Baz, Qux&gt;&gt; foo = rabbitTemplate.receiveAndConvert(<span class="keyword">new</span> ParameterizedTypeReference&lt;Foo&lt;Bar&lt;Baz, Qux&gt;&gt;&gt;() &#123; &#125;);</span><br></pre></td></tr></table></figure><h4 id="（2）推模式"><a href="#（2）推模式" class="headerlink" title="（2）推模式"></a>（2）推模式</h4><p>通过方法 <code>channel.basicConsume()</code> 实现推模式，或者使用注解 <code>@RabbitListener</code> 。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">RabbitMqListener</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@RabbitListener(queues = &quot;queueName&quot;)</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">listen</span><span class="params">(Message message)</span> </span>&#123;</span><br><span class="line">        JSON.parseObject(<span class="keyword">new</span> String(message.getBody()), typeReference);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如果在@RabbitListener注解中指明binding信息，就能自动创建queue、exchange并建立binding关系。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// direct和topic类型的exchange需要routingKey</span></span><br><span class="line"><span class="meta">@RabbitListener(bindings = @QueueBinding(</span></span><br><span class="line"><span class="meta">        value = @Queue(value = &quot;myQueue&quot;, durable = &quot;true&quot;),</span></span><br><span class="line"><span class="meta">        exchange = @Exchange(value = &quot;auto.exch&quot;, durable = &quot;true&quot;),</span></span><br><span class="line"><span class="meta">        key = &quot;orderRoutingKey.#&quot;)</span></span><br><span class="line"><span class="meta">)</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// fanout类型的exchange</span></span><br><span class="line"><span class="meta">@RabbitListener(bindings = @QueueBinding(</span></span><br><span class="line"><span class="meta">        value = @Queue(value = &quot;myQueue&quot;, durable = &quot;true&quot;),</span></span><br><span class="line"><span class="meta">        exchange = @Exchange(value = &quot;auto.exch&quot;, durable = &quot;true&quot;, type = ExchangeTypes.FANOUT))</span></span><br><span class="line"><span class="meta">)</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 2.0版本之后，可以指定多个routingKey：key = &#123; &quot;red&quot;, &quot;yellow&quot; &#125; </span></span><br><span class="line"><span class="comment">// 并且支持arguments属性，可用于headers类型的exchange</span></span><br><span class="line"><span class="meta">@RabbitListener(bindings = @QueueBinding(</span></span><br><span class="line"><span class="meta">        value = @Queue(value = &quot;auto.headers&quot;, autoDelete = &quot;true&quot;,</span></span><br><span class="line"><span class="meta">                        arguments = @Argument(name = &quot;x-message-ttl&quot;, value = &quot;10000&quot;,</span></span><br><span class="line"><span class="meta">                                                type = &quot;java.lang.Integer&quot;)),</span></span><br><span class="line"><span class="meta">        exchange = @Exchange(value = &quot;auto.headers&quot;, type = ExchangeTypes.HEADERS, autoDelete = &quot;true&quot;),</span></span><br><span class="line"><span class="meta">        arguments = &#123;</span></span><br><span class="line"><span class="meta">                @Argument(name = &quot;x-match&quot;, value = &quot;all&quot;),</span></span><br><span class="line"><span class="meta">                @Argument(name = &quot;foo&quot;, value = &quot;bar&quot;),</span></span><br><span class="line"><span class="meta">                @Argument(name = &quot;baz&quot;)</span></span><br><span class="line"><span class="meta">        &#125;)</span></span><br><span class="line"><span class="meta">)</span></span><br></pre></td></tr></table></figure><p>@Queue有两个参数：</p><ul><li><p>exclusive：排他队列，只对创建这个queue的Connection可见，Connection关闭则queue删除；</p></li><li><p>autoDelete：没有consumer对这个queue消费时删除。</p></li></ul><p>对于这两种队列，durable=true是不起作用的。另外，如果注解申明的queue和exchange及binding关系都已经存在，但与已存在的设置不同，比如，已存在的exchange的是direct类型，这里尝试改为fanout类型，结果是不会有任何影响，不论是修改或者新增参数都不会生效。</p><p>如果queue存在，exchange存在，但没有binding，那么程序启动后会自动建立起binding关系。</p><p>消费者消息处理：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 手动ACK消息，后一个参数用于多条ACK，&lt;=deliveryTag同时ACK掉。</span></span><br><span class="line">channel.basicAck(deliveryTag, <span class="keyword">false</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 不确认deliveryTag对应的消息</span></span><br><span class="line"><span class="comment">// 第二个参数是否应用于多消息</span></span><br><span class="line"><span class="comment">// 第三个参数是否重新放入队列requeue，与basic.reject区别就是同时支持多个消息，可以nack该消费者先前接收未ack的所有消息，nack后的消息也会被自己消费到。</span></span><br><span class="line">channel.basicNack(deliveryTag, <span class="keyword">false</span>, <span class="keyword">true</span>);</span><br><span class="line"><span class="comment">// 抛弃此消息</span></span><br><span class="line">channel.basicNack(deliveryTag, <span class="keyword">false</span>, <span class="keyword">false</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 拒绝deliveryTag对应的消息</span></span><br><span class="line"><span class="comment">// 第二个参数是否requeue，true则重新入队列，否则丢弃或者进入死信队列。该方法reject后，该消费者还是会消费到该条被reject的消息。</span></span><br><span class="line">channel.basicReject(deliveryTag, <span class="keyword">true</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 是否恢复消息到队列，参数为是否requeue，true则重新入队列，并且尽可能的将之前recover的消息投递给其他消费者消费，而不是自己再次消费。false则消息会重新被投递给自己。</span></span><br><span class="line">channel.basicRecover(<span class="keyword">true</span>);</span><br></pre></td></tr></table></figure><h3 id="2-7-MessageConverter"><a href="#2-7-MessageConverter" class="headerlink" title="2.7 MessageConverter"></a>2.7 MessageConverter</h3><p>在发送和接收消息时自动完成Message和Java对象的转换。</p><p>MessageConverter 接口：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">MessageConverter</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Nullable</span></span><br><span class="line">    <span class="function">Object <span class="title">fromMessage</span><span class="params">(Message&lt;?&gt; message, Class&lt;?&gt; targetClass)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Nullable</span></span><br><span class="line">    Message&lt;?&gt; toMessage(Object payload, <span class="meta">@Nullable</span> MessageHeaders headers);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>即使不手动配置MessageConverter，也会有一个默认的SimpleMessageConverter，它会直接将java对象序列化。</p><p>官方文档不建议使用这个MessageConverter，因为SimpleMessageConverter是将java对象在producer端序列化，然后在consumer端反序列化，这会将producer和consumer紧密地耦合在一起，并且仅限于java平台。</p><p>推荐用JsonMessageConverter、Jackson2JsonMessageConverter，这两个是都将java对象转化为json再转为 <code>byte[]</code> 来构造Message对象，前一个用的是jackson json lib，后一个用的是jackson 2 json lib。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Bean</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> MessageConverter <span class="title">jsonMessageConverter</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> Jackson2JsonMessageConverter();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Bean</span></span><br><span class="line"><span class="meta">@Autowired</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> RabbitTemplate <span class="title">rabbitTemplate</span><span class="params">(ConnectionFactory connectionFactory,</span></span></span><br><span class="line"><span class="params"><span class="function">                                    MessageConverter messageConverter)</span> </span>&#123;</span><br><span class="line">    RabbitTemplate template = <span class="keyword">new</span> RabbitTemplate(connectionFactory);</span><br><span class="line">    template.setMessageConverter(messageConverter);</span><br><span class="line">    <span class="keyword">return</span> template;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="2-8-异常处理"><a href="#2-8-异常处理" class="headerlink" title="2.8 异常处理"></a>2.8 异常处理</h3><p><code>spring-rabbit</code> 暴露了两个接口可供实现用来处理 <code>@RabbitListener</code> 注解方法抛出的异常：</p><ul><li>RabbitListenerErrorHandler</li><li>org.springframework.util.ErrorHandler</li></ul><p>RabbitListenerErrorHandler，设置在 <code>@RabbitListener</code> 注解上，只对当前注解的方法生效（当前方法抛异常时被调用）：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Bean</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> RabbitListenerErrorHandler <span class="title">rabbitListenerErrorHandler</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> RabbitListenerErrorHandler() &#123;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> Object <span class="title">handleError</span><span class="params">(Message amqpMessage,</span></span></span><br><span class="line"><span class="params"><span class="function">                                  org.springframework.messaging.Message&lt;?&gt; message,</span></span></span><br><span class="line"><span class="params"><span class="function">                                  ListenerExecutionFailedException exception)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">            System.out.println(message);</span><br><span class="line">            <span class="keyword">throw</span> exception;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@RabbitListener(queues = &quot;test_queue_1&quot;, errorHandler = &quot;rabbitListenerErrorHandler&quot;)</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">listen</span><span class="params">(Message message)</span></span>&#123;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure><p>ErrorHandler，是 <code>spring-core</code> 包下面的 <code>ErrorHandler</code> ，可实现这个接口设置在 <code>RabbitListenerContainerFactory</code> 里面，示例：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Bean</span></span><br><span class="line"><span class="meta">@Autowired</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> RabbitListenerContainerFactory <span class="title">rabbitListenerContainerFactory</span><span class="params">(CachingConnectionFactory cachingConnectionFactory,</span></span></span><br><span class="line"><span class="params"><span class="function">                                                                     MessageConverter messageConverter)</span></span>&#123;</span><br><span class="line">    SimpleRabbitListenerContainerFactory factory = <span class="keyword">new</span> SimpleRabbitListenerContainerFactory();</span><br><span class="line">    factory.setConnectionFactory(cachingConnectionFactory);</span><br><span class="line">    factory.setMessageConverter(messageConverter);</span><br><span class="line">    factory.setConcurrentConsumers(<span class="number">1</span>);</span><br><span class="line">    factory.setMaxConcurrentConsumers(<span class="number">1</span>);</span><br><span class="line">    factory.setPrefetchCount(<span class="number">1</span>);</span><br><span class="line">    factory.setErrorHandler(<span class="keyword">new</span> ErrorHandler() &#123;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">handleError</span><span class="params">(Throwable t)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> AmqpRejectAndDontRequeueException(t);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;);</span><br><span class="line">    factory.setDefaultRequeueRejected(<span class="keyword">false</span>);</span><br><span class="line">    <span class="keyword">return</span> factory;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>这个ErrorHandler对所有@RabbitListener注解方法生效。</p><p>二者对比：</p><ul><li><strong>作用范围：</strong>RabbitListenerErrorHandler只对当前 <code>@RabbitListener</code> 注解方法生效，ErrorHandler对所有 <code>@RabbitListener</code> 注解方法生效；</li><li>调用顺序：RabbitListenerErrorHandler先被调用，ErrorHandler后被调用；</li><li>处理粒度：RabbitListenerErrorHandler粒度比较细，可以获取到当前Message，以便做细致处理，ErrorHandler只能获取到Throwable参数；</li><li>默认配置：RabbitListenerErrorHandler没有默认配置，ErrorHandler有默认值ConditionalRejectingErrorHandler。</li></ul><p>ConditionalRejectingErrorHandler的作用：</p><ul><li>打印日志；</li><li>部分异常导致的失败不会requeue消息（默认处理失败的消息会requeue，AcknowledgeMode.NONE模式除外）。</li></ul><h3 id="2-9-事务"><a href="#2-9-事务" class="headerlink" title="2.9 事务"></a>2.9 事务</h3><p>amqp事务仅仅适用于publish和ack，rabbitmq增加了reject的事务。其它操作都不具备事务特性。</p><p>也就是说，rabbitmq本身的事务可以保证producer端发出的消息成功被broker收到（不能保证一定会进入queue），consumer端发出的确认信息成功被broker收到，其它诸如consumer端具体的消费逻辑之类如果想要获得事务功能，需要引入外部事务。</p><p>引入rabbitmq事务很简单，将RabbitTemplate或者RabbitListenerContainerFactory的channelTransacted属性设为true即可，示例：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="meta">@Bean</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> AmqpTemplate <span class="title">amqpTemplate</span><span class="params">(ConnectionFactory amqpConnectionFactory)</span></span>&#123;</span><br><span class="line">    RabbitTemplate rabbitTemplate = <span class="keyword">new</span> RabbitTemplate();</span><br><span class="line">    rabbitTemplate.setConnectionFactory(amqpConnectionFactory);</span><br><span class="line">    rabbitTemplate.setChannelTransacted(<span class="keyword">true</span>);</span><br><span class="line">    <span class="keyword">return</span> rabbitTemplate;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>也可以直接操作Channel：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">Channel channel = cachingConnectionFactory.createConnection().createChannel(<span class="keyword">true</span>);</span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">    <span class="comment">//channel.txSelect();上面createChannel已经设为true了，这句可以去掉</span></span><br><span class="line">    channel.basicPublish(<span class="string">&quot;xxx&quot;</span>, <span class="string">&quot;xxx&quot;</span>, <span class="keyword">new</span> AMQP.BasicProperties(), JSON.toJSONString(event).getBytes());</span><br><span class="line">    channel.txCommit();</span><br><span class="line">&#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        channel.txRollback();</span><br><span class="line">    &#125; <span class="keyword">catch</span> (IOException e1) &#123;</span><br><span class="line">    &#125;</span><br><span class="line">&#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        channel.close()</span><br><span class="line">    &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>需要注意的是，直接通过Connection获取的Channel需要手动close。</p><p>对于producer端，同样的发送一条消息到一个不存在的exchange：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">amqpTemplate.convertAndSend(<span class="string">&quot;notExistExchange&quot;</span>, <span class="string">&quot;routingKey&quot;</span>, object);</span><br></pre></td></tr></table></figure><ul><li>如果关闭事务，CachingConnectionFactory会打出一条错误日志，但程序会正常运行。</li><li>如果打开事务，由于消息没有到达broker，这里会抛出异常。</li></ul><p>对于consumer端，当consumer正在处理一条消息时：</p><ul><li>如果broker挂掉，程序会不断尝试重连，当broker恢复时，会重新收到这条消息；</li><li>如果程序挂掉，broker发现还没有收到consumer的确认信息但consumer没了，会将这条消息恢复；</li><li>长时间没有收到consumer端的确认信息，也会将消息从unacked状态变成ready状态；</li><li>如果程序处理消息期间抛异常，broker会收到一个nack或者reject，也会将这条消息恢复。</li></ul><p>所以，rabbitmq是可以将没有成功消费的消息恢复的，consumer端使用rabbitmq事务的意义并不是很大，也许可以用于consumer端消息去重：</p><ul><li>consumer处理成功向rabbitmq发出了ack，consumer默认rabbitmq收到了这个ack所以consumer认为这条消息处理结束，但实际可能rabbitmq没有收到ack又将这条消息放回queue然后重新发给consumer导致消息重复处理。如果开启了事务，能保证rabbitmq一定能收到确认信息，否则事务提交失败。</li></ul><p>另外，需要注意的是，开启事务会大幅降低消息发送及接收效率，因为当已经有一个事务存在时，后面的消息是不能被发送或者接收（对同一个consumer而言）的，所以以上两种场景都不推荐使用事务来解决。</p><h3 id="2-10-Listeners"><a href="#2-10-Listeners" class="headerlink" title="2.10 Listeners"></a>2.10 Listeners</h3><p>ChannelListener接口，监听Channel的创建和异常关闭：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Bean</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> ChannelListener <span class="title">channelListener</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> ChannelListener() &#123;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onCreate</span><span class="params">(Channel channel, <span class="keyword">boolean</span> transactional)</span> </span>&#123;</span><br><span class="line">            logger.info(<span class="string">&quot;channel number:&#123;&#125;, nextPublishSqlNo:&#123;&#125;&quot;</span>,</span><br><span class="line">                    channel.getChannelNumber(),</span><br><span class="line">                    channel.getNextPublishSeqNo());</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onShutDown</span><span class="params">(ShutdownSignalException signal)</span> </span>&#123;</span><br><span class="line">            logger.error(<span class="string">&quot;channel shutdown, reason:&#123;&#125;, errorLevel:&#123;&#125;&quot;</span>,</span><br><span class="line">                    signal.getReason().protocolMethodName(),</span><br><span class="line">                    signal.isHardError() ? <span class="string">&quot;connection&quot;</span> : <span class="string">&quot;channel&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>BlockedListener监听Connection的block和unblock：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Bean</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> BlockedListener <span class="title">blockedListener</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> BlockedListener() &#123;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">handleBlocked</span><span class="params">(String reason)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">            logger.info(<span class="string">&quot;connection blocked, reason:&#123;&#125;&quot;</span>, reason);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">handleUnblocked</span><span class="params">()</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">            logger.info(<span class="string">&quot;connection unblocked&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>ConnectionListener监听Connection的创建、关闭和异常终止：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Bean</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> ConnectionListener <span class="title">connectionListener</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> ConnectionListener() &#123;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onCreate</span><span class="params">(Connection connection)</span> </span>&#123;</span><br><span class="line">            logger.info(<span class="string">&quot;connection created.&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onClose</span><span class="params">(Connection connection)</span> </span>&#123;</span><br><span class="line">            logger.info(<span class="string">&quot;connection closed.&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onShutDown</span><span class="params">(ShutdownSignalException signal)</span> </span>&#123;</span><br><span class="line">            logger.error(<span class="string">&quot;connection shutdown, reason:&#123;&#125;, errorLevel:&#123;&#125;&quot;</span>,</span><br><span class="line">                    signal.getReason().protocolMethodName(),</span><br><span class="line">                    signal.isHardError() ? <span class="string">&quot;connection&quot;</span> : <span class="string">&quot;channel&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>RecoveryListener监听开始自动恢复Connection、自动恢复连接完成：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Bean</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> RecoveryListener <span class="title">recoveryListener</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> RecoveryListener() &#123;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">handleRecovery</span><span class="params">(Recoverable recoverable)</span> </span>&#123;</span><br><span class="line">            logger.info(<span class="string">&quot;automatic recovery completed&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">handleRecoveryStarted</span><span class="params">(Recoverable recoverable)</span> </span>&#123;</span><br><span class="line">            logger.info(<span class="string">&quot;automatic recovery started&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>ConnectionListener、ChannelListener、RecoveryListener设置到ConnectionFactory即可。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Bean</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> CachingConnectionFactory <span class="title">cachingConnectionFactory</span><span class="params">(ConnectionListener connectionListener,  ChannelListener channelListener, RecoveryListener recoveryListener)</span> </span>&#123;</span><br><span class="line">    CachingConnectionFactory connectionFactory = <span class="keyword">new</span> CachingConnectionFactory();</span><br><span class="line">    connectionFactory.setAddresses(mqConfigBean.getAddresses());</span><br><span class="line">    connectionFactory.setUsername(mqConfigBean.getUsername());</span><br><span class="line">    connectionFactory.setPassword(mqConfigBean.getPassword());</span><br><span class="line">    connectionFactory.setVirtualHost(mqConfigBean.getVirtualHost());</span><br><span class="line">    connectionFactory.addConnectionListener(connectionListener);</span><br><span class="line">    connectionFactory.addChannelListener(channelListener);</span><br><span class="line">    connectionFactory.setRecoveryListener(recoveryListener);</span><br><span class="line">    connectionFactory.setChannelCacheSize(<span class="number">3</span>);</span><br><span class="line">    <span class="keyword">return</span> connectionFactory;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>通过ConnectionListener和ChannelListener可以debug看出Connection和Channel都是有缓存的，因为 <code>onCreate()</code> 方法不会每次都调用。并且Connection和Channel的创建都是lazy的，程序启动时不会创建Connection和Channel，在第一次用到的时候才会创建。</p><h3 id="2-11-多个-RabbitListener消费一个queue"><a href="#2-11-多个-RabbitListener消费一个queue" class="headerlink" title="2.11 多个@RabbitListener消费一个queue"></a>2.11 多个@RabbitListener消费一个queue</h3><p>一个服务中可以有多个@RabbitListener注解的方法消费一个queue，如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="meta">@RabbitListener(queues = &quot;queueName&quot;)</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">listener1</span><span class="params">(Message message)</span> </span>&#123;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@RabbitListener(queues = &quot;queueName&quot;)</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">listener2</span><span class="params">(Message message)</span> </span>&#123;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这样写使用的仍是同一个Connection，一条消息也不会被两个方法都调用，如果RabbitListenerContainerFactory中设置concurrentConsumer为3，意味着每个方法产生3个consumer，一共会有6个consumer对这个queue进行消费。也可以分布在不同的应用程序中，那样会在不同的Connection中。</p><p>一个服务中有如上的两个方法消费同一个queue，另一个服务中有一个方法消费同一个queue，则会有两个消费者Connection，一个有3个Channel，一个有6个Channel。</p><h3 id="2-12-生产者消息确认机制confirm-and-return"><a href="#2-12-生产者消息确认机制confirm-and-return" class="headerlink" title="2.12 生产者消息确认机制confirm and return"></a>2.12 生产者消息确认机制confirm and return</h3><p>为了能让producer端知道消息是否成功进入了queue，并且避免使用事务大幅降低消息发送效率，可以用confirm和return机制来代替事务。</p><p>首先实现两个Callback，ReturnCallback和ConfirmCallback，需要哪个实现哪个，不一定都需要：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> RabbitTemplate.<span class="function">ReturnCallback <span class="title">returnCallback</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> RabbitTemplate.ReturnCallback() &#123;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">returnedMessage</span><span class="params">(Message message, <span class="keyword">int</span> replyCode, String replyText, String exchange, String routingKey)</span> </span>&#123;</span><br><span class="line">            logger.info(<span class="string">&quot;return call back&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> RabbitTemplate.<span class="function">ConfirmCallback <span class="title">confirmCallback</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> RabbitTemplate.ConfirmCallback() &#123;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">confirm</span><span class="params">(CorrelationData correlationData, <span class="keyword">boolean</span> ack, String cause)</span> </span>&#123;</span><br><span class="line">            logger.info(<span class="string">&quot;confirm call back&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>然后将这两个Callback设置到RabbitTemplate中，将mandatory属性设为true（ReturnCallback需要，ConfirmCallback不需要）：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">rabbitTemplate.setReturnCallback(returnCallback);</span><br><span class="line">rabbitTemplate.setConfirmCallback(confirmCallback);</span><br><span class="line">rabbitTemplate.setMandatory(<span class="keyword">true</span>);</span><br></pre></td></tr></table></figure><p>然后在ConnectionFactory中将这Confirm和Return机制打开：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">connectionFactory.setPublisherReturns(<span class="keyword">true</span>);</span><br><span class="line">connectionFactory.setPublisherConfirms(<span class="keyword">true</span>);</span><br></pre></td></tr></table></figure><p>调用条件：</p><ul><li><p>ConfirmCallback：每一条发出的消息都会调用ConfirmCallback；</p></li><li><p>ReturnCallback：只有在消息进入exchange但没有进入queue时才会调用。</p></li></ul><p>参数：</p><ul><li>correlationData：RabbitTemplate的send系列方法中有带这个参数的，如果传了这个参数，会在回调时拿到；</li><li>ack：消息进入exchange，为true，未能进入exchange，为false，由于Connection中断发出的消息进入exchange但没有收到confirm信息的情况，也会是false；</li><li>cause：消息发送失败时的失败原因信息。</li></ul><p>关于confirm和return官方文档上有下面这段信息，有必要了解一下：</p><blockquote><p> When a rabbit template send operation completes, the channel is closed; this would preclude the reception of confirms or returns in the case when the connection factory cache is full (when there is space in the cache, the channel is not physically closed and the returns/confirms will proceed as normal). When the cache is full, the framework defers the close for up to 5 seconds, in order to allow time for the confirms/returns to be received. When using confirms, the channel will be closed when the last confirm is received. When using only returns, the channel will remain open for the full 5 seconds. It is generally recommended to set the connection factory’s channelCacheSize to a large enough value so that the channel on which a message is published is returned to the cache instead of being closed. You can monitor channel usage using the RabbitMQ management plugin; if you see channels being opened/closed rapidly you should consider increasing the cache size to reduce overhead on the server.</p><p>当RabbitTemplate发送操作完成后，通道被关闭；这将排斥了在连接工厂缓存已满的情况下接收确认或返回（当缓存有空间时，通道不会被物理关闭，返回/确认将正常进行）。当缓存已满时，框架会将关闭时间推迟5秒，以便有时间接收确认/返回信息。</p><ul><li>当使用确认时，通道将在收到最后一个确认时被关闭。</li><li>当只使用返回时，通道将保持完整的5秒开放。</li></ul><p>通常建议将连接工厂的 channelCacheSize 设置为足够大的值，以便将发布消息的通道返回到缓存中而不是关闭。您可以使用 RabbitMQ 管理插件监控通道的使用情况；如果您看到通道被快速打开/关闭，您应该考虑增加缓存大小以减少服务器上的开销。</p></blockquote><p>异步的接收confirm和return时仍然需要走原来发送消息用到的那个Channel，如果那个Channel被关闭了，是收不到confirm/return信息的。好在根据以上说明，Channel会等到最后一个confirm接收到时才会close，所以应该也不用担心Channel被关闭而接收不到confirm的问题（异常会导致Channel提前关闭吗）。</p><h3 id="2-13-重试机制"><a href="#2-13-重试机制" class="headerlink" title="2.13 重试机制"></a>2.13 重试机制</h3><p>重试机制主要是解决网络不稳导致连接中断的问题。所以其实并不是重新发送消息，而是重新建立。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="meta">@Bean</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> RetryTemplate <span class="title">retryTemplate</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    RetryTemplate retryTemplate = <span class="keyword">new</span> RetryTemplate();</span><br><span class="line">    SimpleRetryPolicy simpleRetryPolicy = <span class="keyword">new</span> SimpleRetryPolicy(Integer.MAX_VALUE);</span><br><span class="line">    retryTemplate.setRetryPolicy(simpleRetryPolicy);</span><br><span class="line">    <span class="keyword">return</span> retryTemplate;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如上，配置一个RetryTemplate，再设置到AmqpTemplate即可。</p><p>RetryTemplate与 <code>spring-amqp</code> 及rabbitmq都没有关系，这是 <code>spring-retry</code> 中的类。以上示例中使用了最简单的重试策略，不断重试，直到 <code>Integer.MAX_VALUE</code> 次为止。</p><p>对producer端而言，如果Connection正常，但发送消息失败是不会重试的，<strong>如指定的exchange不存在的情况</strong>：</p><figure class="highlight oxygene"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">第<span class="number">1</span>条发送完毕</span><br><span class="line"></span><br><span class="line">收到第<span class="number">1</span>条confirm，ack:<span class="keyword">false</span>, correlationData:null</span><br><span class="line"></span><br><span class="line"><span class="number">17</span>:<span class="number">26</span>:<span class="number">09.544</span> [AMQP Connection <span class="number">127.0</span>.<span class="number">0.1</span>:<span class="number">5672</span>] ERROR [CachingConnectionFactory.java:<span class="number">1344</span>] - Channel shutdown: channel error; protocol <span class="function"><span class="keyword">method</span>:</span> #<span class="function"><span class="keyword">method</span>&lt;<span class="title">channel</span>.<span class="title">close</span>&gt;<span class="params">(reply-code=404, reply-text=NOT_FOUND - no exchange <span class="string">&#x27;xxx&#x27;</span> <span class="keyword">in</span> vhost <span class="string">&#x27;vhost&#x27;</span>, <span class="keyword">class</span>-id=60, <span class="keyword">method</span>-id=40)</span></span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function">第2条发送完毕</span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function">收到第2条<span class="title">confirm</span>，<span class="title">ack</span>:</span><span class="keyword">false</span>, correlationData:null</span><br><span class="line"></span><br><span class="line"><span class="number">17</span>:<span class="number">26</span>:<span class="number">10.552</span> [AMQP Connection <span class="number">127.0</span>.<span class="number">0.1</span>:<span class="number">5672</span>] ERROR [CachingConnectionFactory.java:<span class="number">1344</span>] - Channel shutdown: channel error; protocol <span class="function"><span class="keyword">method</span>:</span> #<span class="function"><span class="keyword">method</span>&lt;<span class="title">channel</span>.<span class="title">close</span>&gt;<span class="params">(reply-code=404, reply-text=NOT_FOUND - no exchange <span class="string">&#x27;xxx&#x27;</span> <span class="keyword">in</span> vhost <span class="string">&#x27;vhost&#x27;</span>, <span class="keyword">class</span>-id=60, <span class="keyword">method</span>-id=40)</span></span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function">第3条发送完毕</span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function">收到第3条<span class="title">confirm</span>，<span class="title">ack</span>:</span><span class="keyword">false</span>, correlationData:null</span><br><span class="line"></span><br><span class="line"><span class="number">17</span>:<span class="number">26</span>:<span class="number">11.559</span> [AMQP Connection <span class="number">127.0</span>.<span class="number">0.1</span>:<span class="number">5672</span>] ERROR [CachingConnectionFactory.java:<span class="number">1344</span>] - Channel shutdown: channel error; protocol <span class="function"><span class="keyword">method</span>:</span> #<span class="function"><span class="keyword">method</span>&lt;<span class="title">channel</span>.<span class="title">close</span>&gt;<span class="params">(reply-code=404, reply-text=NOT_FOUND - no exchange <span class="string">&#x27;xxx&#x27;</span> <span class="keyword">in</span> vhost <span class="string">&#x27;vhost&#x27;</span>, <span class="keyword">class</span>-id=60, <span class="keyword">method</span>-id=40)</span></span></span><br></pre></td></tr></table></figure><p><strong>由Connection中断导致的发送消息失败，会进行重试</strong>：</p><figure class="highlight oxygene"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line">第<span class="number">7</span>条发送完毕</span><br><span class="line"></span><br><span class="line">收到第<span class="number">7</span>条confirm，ack:<span class="keyword">true</span>, correlationData:null</span><br><span class="line"></span><br><span class="line">第<span class="number">8</span>条发送完毕</span><br><span class="line"></span><br><span class="line">收到第<span class="number">8</span>条confirm，ack:<span class="keyword">true</span>, correlationData:null</span><br><span class="line"></span><br><span class="line">第<span class="number">9</span>条发送完毕</span><br><span class="line"></span><br><span class="line">收到第<span class="number">9</span>条confirm，ack:<span class="keyword">true</span>, correlationData:null</span><br><span class="line"></span><br><span class="line">第<span class="number">10</span>条发送完毕</span><br><span class="line"></span><br><span class="line">收到第<span class="number">10</span>条confirm，ack:<span class="keyword">true</span>, correlationData:null</span><br><span class="line"></span><br><span class="line">第<span class="number">11</span>条发送完毕</span><br><span class="line"></span><br><span class="line">收到第<span class="number">11</span>条confirm，ack:<span class="keyword">true</span>, correlationData:null</span><br><span class="line"></span><br><span class="line"><span class="number">17</span>:<span class="number">01</span>:<span class="number">44.000</span> [AMQP Connection <span class="number">127.0</span>.<span class="number">0.1</span>:<span class="number">5672</span>] ERROR [CachingConnectionFactory.java:<span class="number">1344</span>] - Channel shutdown: connection error; protocol <span class="function"><span class="keyword">method</span>:</span> #<span class="function"><span class="keyword">method</span>&lt;<span class="title">connection</span>.<span class="title">close</span>&gt;<span class="params">(reply-code=320, reply-text=CONNECTION_FORCED - broker forced connection closure <span class="keyword">with</span> reason <span class="string">&#x27;shutdown&#x27;</span>, <span class="keyword">class</span>-id=0, <span class="keyword">method</span>-id=0)</span></span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function">17:</span><span class="number">01</span>:<span class="number">44.005</span> [AMQP Connection <span class="number">127.0</span>.<span class="number">0.1</span>:<span class="number">5672</span>] WARN  [ForgivingExceptionHandler.java:<span class="number">115</span>] - An unexpected connection driver error occured (Exception message: Connection reset)</span><br><span class="line"></span><br><span class="line"><span class="number">17</span>:<span class="number">01</span>:<span class="number">44.602</span> [http-nio-<span class="number">8080</span>-exec-<span class="number">2</span>] INFO  [AbstractConnectionFactory.java:<span class="number">455</span>] - Attempting <span class="keyword">to</span> connect <span class="keyword">to</span>: [localhost:<span class="number">5672</span>]</span><br><span class="line"></span><br><span class="line">...</span><br><span class="line"></span><br><span class="line"><span class="number">17</span>:<span class="number">02</span>:<span class="number">23.076</span> [http-nio-<span class="number">8080</span>-exec-<span class="number">2</span>] INFO  [AbstractConnectionFactory.java:<span class="number">455</span>] - Attempting <span class="keyword">to</span> connect <span class="keyword">to</span>: [localhost:<span class="number">5672</span>]</span><br><span class="line"></span><br><span class="line"><span class="number">17</span>:<span class="number">02</span>:<span class="number">24.578</span> [http-nio-<span class="number">8080</span>-exec-<span class="number">2</span>] INFO  [AbstractConnectionFactory.java:<span class="number">471</span>] - Created <span class="keyword">new</span> connection: amqpConnectionFactory<span class="string">#3412</span>a3fd:<span class="number">20</span>/SimpleConnection@<span class="number">41298</span>ed [<span class="keyword">delegate</span>=amqp:<span class="comment">//guest@0:0:0:0:0:0:0:1:5672/test, localPort= 55092]</span></span><br><span class="line"></span><br><span class="line">第<span class="number">12</span>条发送完毕</span><br><span class="line"></span><br><span class="line">收到第<span class="number">12</span>条confirm，ack:<span class="keyword">true</span>, correlationData:null</span><br><span class="line"></span><br><span class="line">第<span class="number">13</span>条发送完毕</span><br><span class="line"></span><br><span class="line">收到第<span class="number">13</span>条confirm，ack:<span class="keyword">true</span>, correlationData:null</span><br><span class="line"></span><br><span class="line">第<span class="number">14</span>条发送完毕</span><br><span class="line"></span><br><span class="line">收到第<span class="number">14</span>条confirm，ack:<span class="keyword">true</span>, correlationData:null</span><br><span class="line"></span><br><span class="line">第<span class="number">15</span>条发送完毕</span><br><span class="line"></span><br><span class="line">收到第<span class="number">15</span>条confirm，ack:<span class="keyword">true</span>, correlationData:null</span><br></pre></td></tr></table></figure><p><strong>没有配置重试，或到达了重试次数依然失败，会抛出异常</strong>：</p><figure class="highlight oxygene"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">第<span class="number">15</span>条发送完毕</span><br><span class="line"></span><br><span class="line">收到第<span class="number">15</span>条confirm，ack:<span class="keyword">false</span>, correlationData:null</span><br><span class="line"></span><br><span class="line"><span class="number">17</span>:<span class="number">41</span>:<span class="number">13.571</span> [AMQP Connection <span class="number">127.0</span>.<span class="number">0.1</span>:<span class="number">5672</span>] ERROR [CachingConnectionFactory.java:<span class="number">1344</span>] - Channel shutdown: channel error; protocol <span class="function"><span class="keyword">method</span>:</span> #<span class="function"><span class="keyword">method</span>&lt;<span class="title">channel</span>.<span class="title">close</span>&gt;<span class="params">(reply-code=404, reply-text=NOT_FOUND - no exchange <span class="string">&#x27;xxx&#x27;</span> <span class="keyword">in</span> vhost <span class="string">&#x27;paas_v3_vhost&#x27;</span>, <span class="keyword">class</span>-id=60, <span class="keyword">method</span>-id=40)</span></span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function">第16条发送完毕</span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function">收到第16条<span class="title">confirm</span>，<span class="title">ack</span>:</span><span class="keyword">false</span>, correlationData:null</span><br><span class="line"></span><br><span class="line"><span class="number">17</span>:<span class="number">41</span>:<span class="number">14.583</span> [AMQP Connection <span class="number">127.0</span>.<span class="number">0.1</span>:<span class="number">5672</span>] ERROR [CachingConnectionFactory.java:<span class="number">1344</span>] - Channel shutdown: channel error; protocol <span class="function"><span class="keyword">method</span>:</span> #<span class="function"><span class="keyword">method</span>&lt;<span class="title">channel</span>.<span class="title">close</span>&gt;<span class="params">(reply-code=404, reply-text=NOT_FOUND - no exchange <span class="string">&#x27;xxx&#x27;</span> <span class="keyword">in</span> vhost <span class="string">&#x27;paas_v3_vhost&#x27;</span>, <span class="keyword">class</span>-id=60, <span class="keyword">method</span>-id=40)</span></span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function">17:</span><span class="number">41</span>:<span class="number">15.322</span> [AMQP Connection <span class="number">127.0</span>.<span class="number">0.1</span>:<span class="number">5672</span>] WARN  [ForgivingExceptionHandler.java:<span class="number">115</span>] - An unexpected connection driver error occured (Exception message: Connection reset)</span><br><span class="line"></span><br><span class="line"><span class="number">17</span>:<span class="number">41</span>:<span class="number">15.579</span> [http-nio-<span class="number">8080</span>-exec-<span class="number">1</span>] INFO  [AbstractConnectionFactory.java:<span class="number">455</span>] - Attempting <span class="keyword">to</span> connect <span class="keyword">to</span>: [localhost:<span class="number">5672</span>]</span><br><span class="line"></span><br><span class="line"><span class="number">17</span>:<span class="number">41</span>:<span class="number">17.609</span> [http-nio-<span class="number">8080</span>-exec-<span class="number">1</span>] ERROR [ExceptionHandler.java:<span class="number">41</span>] - unknown error</span><br><span class="line"></span><br><span class="line">org.springframework.amqp.AmqpConnectException: java.net.ConnectException: Connection refused: connect</span><br><span class="line"></span><br><span class="line">at org.springframework.amqp.rabbit.support.RabbitExceptionTranslator.convertRabbitAccessException(RabbitExceptionTranslator.java:<span class="number">62</span>)</span><br><span class="line"></span><br><span class="line">at org.springframework.amqp.rabbit.connection.AbstractConnectionFactory.createBareConnection(AbstractConnectionFactory.java:<span class="number">484</span>)</span><br><span class="line"></span><br><span class="line">at org.springframework.amqp.rabbit.connection.CachingConnectionFactory.createConnection(CachingConnectionFactory.java:<span class="number">626</span>)</span><br><span class="line"></span><br><span class="line">at org.springframework.amqp.rabbit.connection.CachingConnectionFactory.createBareChannel(CachingConnectionFactory.java:<span class="number">576</span>)</span><br></pre></td></tr></table></figure><p>对Consumer端，如果采用的是 <code>@RabbitListener</code> 或其它类似异步接收消息的方式，则没必要配置重试。Consumer端有Ack机制，Connection中断导致RabbitMq收不到Ack信息，消息会重新入队（可能会导致同一条消息重复消费）。</p><p>对于直接调用RabbitTemplate的Receive系列方法获取消息的消费方式，则同消息发送端，没有Retry或Retry次数达到，则抛异常。</p><h3 id="2-14-发送端的消息丢失"><a href="#2-14-发送端的消息丢失" class="headerlink" title="2.14 发送端的消息丢失"></a>2.14 发送端的消息丢失</h3><p>讨论两种情况可能产生的消息丢失：</p><ol><li>RabbitMq没挂，只是短暂的网络异常，连接可以恢复，消息发送出去但没有到exchange。</li><li>RabbitMq挂了且长时间无法恢复，消息没有发出去；</li></ol><h4 id="（1）可恢复的Connection中断"><a href="#（1）可恢复的Connection中断" class="headerlink" title="（1）可恢复的Connection中断"></a>（1）可恢复的Connection中断</h4><p>配置开启Retry情况下，Connection中断会根据配置的retry策略尝试重连，但即使重新连上了，消息依然可能会丢失。</p><ul><li>本地测试，单线程间隔1毫秒循环发送1万条消息，模拟一个不断有消息发出的场景，在发送过程中手动关闭Rabbitmq服务再重新启动，模拟Connection短暂中断的场景。</li><li>因为每一条消息都带有唯一的messageId（实际上是“线程名-序号”的形式），所以能轻易地从消费端读出所有消息之后找到丢失的消息。</li><li>测试结果：发送1万条消息，实际收到9999条，丢失1条。</li></ul><p>发送端通过ConfirmCallback打印出所有ack=false的消息：</p><figure class="highlight subunit"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">----------打印ack=false的消息----------</span><br><span class="line"></span><br><span class="line">size:4</span><br><span class="line"></span><br><span class="line">pool<span class="string">-5</span>-thread<span class="string">-1</span><span class="string">-5881</span></span><br><span class="line"></span><br><span class="line">pool<span class="string">-5</span>-thread<span class="string">-1</span><span class="string">-5882</span></span><br><span class="line"></span><br><span class="line">pool<span class="string">-5</span>-thread<span class="string">-1</span><span class="string">-5883</span></span><br><span class="line"></span><br><span class="line">pool<span class="string">-5</span>-thread<span class="string">-1</span><span class="string">-5884</span></span><br></pre></td></tr></table></figure><p>消费端读出所有消息后，找出丢失的消息：</p><figure class="highlight brainfuck"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">--<span class="literal">-</span><span class="literal">-</span><span class="literal">-</span><span class="literal">-</span><span class="literal">-</span><span class="literal">-</span><span class="comment">total:10000</span>--<span class="literal">-</span><span class="literal">-</span><span class="literal">-</span><span class="literal">-</span><span class="literal">-</span><span class="literal">-</span><span class="literal">-</span></span><br><span class="line"></span><br><span class="line">--<span class="literal">-</span><span class="literal">-</span><span class="literal">-</span><span class="literal">-</span><span class="literal">-</span><span class="literal">-</span><span class="literal">-</span><span class="literal">-</span><span class="comment">contain</span> <span class="comment">size:</span> <span class="comment">9999</span>--<span class="literal">-</span><span class="literal">-</span><span class="literal">-</span><span class="literal">-</span><span class="literal">-</span><span class="literal">-</span><span class="literal">-</span><span class="literal">-</span></span><br><span class="line"></span><br><span class="line">--<span class="literal">-</span><span class="literal">-</span><span class="literal">-</span><span class="literal">-</span><span class="literal">-</span><span class="literal">-</span><span class="literal">-</span><span class="literal">-</span><span class="comment">absent</span> <span class="comment">size:</span> <span class="comment">1</span>--<span class="literal">-</span><span class="literal">-</span><span class="literal">-</span><span class="literal">-</span><span class="literal">-</span><span class="literal">-</span><span class="literal">-</span><span class="literal">-</span></span><br><span class="line"></span><br><span class="line"><span class="comment">pool</span><span class="literal">-</span><span class="comment">5</span><span class="literal">-</span><span class="comment">thread</span><span class="literal">-</span><span class="comment">1</span><span class="literal">-</span><span class="comment">5883</span></span><br></pre></td></tr></table></figure><p>可以看到，ack=false的消息有4条，但实际上只丢了一条。因为消息的发送和Confirm是异步进行的，如果在消息发送出去之后，异步的confirm回来之前，Connection中断，那么ConfirmCallback会立即被调用，并且ack=false，原因是Channel被关闭了。</p><ul><li>单线程情况下应该最多只会丢失一条，也有可能不会丢。</li><li>多线程的情况下丢消息的现象就很严重了。本地测试5个线程发消息的情况，一共50000条消息，丢失了1500多条。但其实如果把这5个线程分到5个请求，一个请求只跑一个线程，情况会好很多，类似于上面单线程的情况。</li><li><strong>解决方案</strong>：首先可以想到的解决方案是事务，但事务一般不建议使用，为了rabbitmq的效率，退而求其次，采用confirm机制。</li></ul><p>从上面的测试可以看到，在ConfirmCallback中ack=false的消息未必真的没有到达exchange，但没有到达exchange的消息ack一定是false，所以只需要将ack=false的消息重新发送一遍即可（这种方案会导致消息重复发送，后面再解决这一问题）。</p><p><strong>ConfirmCallback的回调方法中没有Message对象</strong>，你可能会想从ConfirmCallback中拿到Message对象，当ack=false的时候将这个Message再重新发出去，但方法入参中没有Message对象：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ReissueMessageConfirmCallback</span> <span class="keyword">implements</span> <span class="title">RabbitTemplate</span>.<span class="title">ConfirmCallback</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> Logger logger = LoggerFactory.getLogger(ReissueMessageConfirmCallback.class);</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">confirm</span><span class="params">(CorrelationData correlationData, <span class="keyword">boolean</span> ack, String cause)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (correlationData <span class="keyword">instanceof</span> MessageCorrelationData) &#123;</span><br><span class="line">            MessageCorrelationData messageCorrelationData = (MessageCorrelationData) correlationData;</span><br><span class="line">            logger.info(<span class="string">&quot;------------messageId: &quot;</span> + messageCorrelationData.getMessage().getMessageProperties().getMessageId() +</span><br><span class="line">                    <span class="string">&quot;, ack: &quot;</span> + ack + <span class="string">&quot;, cause:&quot;</span> + cause + <span class="string">&quot;--------------&quot;</span>);</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (!ack) &#123;</span><br><span class="line">                SendFailedMessageHolder.add(messageCorrelationData);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>注意到入参中有一个<strong>CorrelationData</strong>对象，同时在RabbitTemplate中有相应的send方法：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">   <span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">send</span><span class="params">(<span class="keyword">final</span> String exchange, <span class="keyword">final</span> String routingKey, <span class="keyword">final</span> Message message, <span class="keyword">final</span> CorrelationData correlationData)</span> <span class="keyword">throws</span> AmqpException </span>&#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这个方法AmqpTemplate中是没有的，是RabbitTemplate扩展的。所以，虽然ConfirmCallback不能直接拿到Message，但可以拿到CorrelationData，于是问题就解决了。</p><p><strong>直接在ConfirmCallback中调用RabbitTemplate发送消息导致死锁</strong>，现在我们可以通过CorrelationData在ConfirmCallback中拿到Message对象了，我们也有办法拿到RabbitTemplate，为了避免bean的循环依赖，我是这样做的：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="meta">@Bean</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> RabbitTemplate <span class="title">amqpTemplate</span><span class="params">(ConnectionFactory amqpConnectionFactory,</span></span></span><br><span class="line"><span class="params"><span class="function">                                  RetryTemplate retryTemplate,</span></span></span><br><span class="line"><span class="params"><span class="function">                                  MessageConverter messageConverter,</span></span></span><br><span class="line"><span class="params"><span class="function">                                  //RabbitTemplate.ConfirmCallback confirmCallback,</span></span></span><br><span class="line"><span class="params"><span class="function">                                  RabbitTemplate.ReturnCallback returnCallback)</span></span>&#123;</span><br><span class="line">    RabbitTemplate rabbitTemplate = <span class="keyword">new</span> RabbitTemplate();</span><br><span class="line">    rabbitTemplate.setConnectionFactory(amqpConnectionFactory);</span><br><span class="line">    rabbitTemplate.setRetryTemplate(retryTemplate);</span><br><span class="line">    rabbitTemplate.setMessageConverter(messageConverter);</span><br><span class="line">    <span class="comment">//rabbitTemplate.setChannelTransacted(true);</span></span><br><span class="line">    rabbitTemplate.setReturnCallback(returnCallback);</span><br><span class="line">    rabbitTemplate.setConfirmCallback(<span class="keyword">new</span> ReissueMessageConfirmCallback(rabbitTemplate));</span><br><span class="line">    rabbitTemplate.setMandatory(<span class="keyword">true</span>);</span><br><span class="line">    <span class="keyword">return</span> rabbitTemplate;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>ReissueMessageConfirmCallback是自己写的一个实现类，将RabbitTemplate bean自己设置进去。然后我们在ConfirmCallback中发送消息：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ReissueMessageConfirmCallback</span> <span class="keyword">implements</span> <span class="title">RabbitTemplate</span>.<span class="title">ConfirmCallback</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> Logger logger = LoggerFactory.getLogger(ReissueMessageConfirmCallback.class);</span><br><span class="line">    <span class="keyword">private</span> RabbitTemplate rabbitTemplate;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">ReissueMessageConfirmCallback</span><span class="params">(RabbitTemplate rabbitTemplate)</span></span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.rabbitTemplate = rabbitTemplate;</span><br><span class="line">    &#125;   </span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">confirm</span><span class="params">(CorrelationData correlationData, <span class="keyword">boolean</span> ack, String cause)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (correlationData <span class="keyword">instanceof</span> MessageCorrelationData) &#123;</span><br><span class="line">            MessageCorrelationData messageCorrelationData = (MessageCorrelationData) correlationData;</span><br><span class="line">            String exchange = messageCorrelationData.getExchange();</span><br><span class="line">            String routingKey = messageCorrelationData.getRoutingKey();</span><br><span class="line">            Message message = messageCorrelationData.getMessage();</span><br><span class="line">            <span class="keyword">if</span> (!ack) &#123;</span><br><span class="line">                rabbitTemplate.send(exchange, routingKey, message, messageCorrelationData);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>MessageCorrelationData是自己写的CorrelationData扩展类，增加了Message、exchange、routingKey属性。</p><p>在请求主线程发送1万条消息的过程中，将rabbitmq关闭，这时请求主线程和ConfirmCallback线程都在等待Connection恢复，然后重新启动rabbitmq，当程序重新建立Connection之后，这两个线程会死锁。</p><p><strong>可行的方案：定时任务重发</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ReissueMessageSchedule</span> <span class="keyword">implements</span> <span class="title">InitializingBean</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> RabbitTemplate rabbitTemplate;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> ScheduledExecutorService scheduledExecutorService = Executors.newScheduledThreadPool(<span class="number">2</span>);</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">start</span><span class="params">()</span></span>&#123;</span><br><span class="line">        scheduledExecutorService.scheduleWithFixedDelay(<span class="keyword">new</span> ReissueTask(rabbitTemplate), <span class="number">10</span>, <span class="number">10</span>, TimeUnit.SECONDS);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">afterPropertiesSet</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ReissueTask</span> <span class="keyword">implements</span> <span class="title">Runnable</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> Logger logger = LoggerFactory.getLogger(ReissueTask.class);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> RabbitTemplate rabbitTemplate;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">ReissueTask</span><span class="params">(RabbitTemplate rabbitTemplate)</span></span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.rabbitTemplate = rabbitTemplate;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        List&lt;MessageCorrelationData&gt; messageCorrelationDataList = <span class="keyword">new</span> ArrayList&lt;&gt;(SendFailedMessageHolder.getAll());</span><br><span class="line">        logger.info(<span class="string">&quot;------------------获取到&quot;</span> + messageCorrelationDataList.size() + <span class="string">&quot;条ack=false的消息，准备重发------------------&quot;</span>);</span><br><span class="line">        SendFailedMessageHolder.clear();</span><br><span class="line">        <span class="keyword">int</span> i = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span> (MessageCorrelationData messageCorrelationData : messageCorrelationDataList) &#123;</span><br><span class="line">            Message message = messageCorrelationData.getMessage();</span><br><span class="line">            String messageId = message.getMessageProperties().getMessageId();</span><br><span class="line">            logger.info(<span class="string">&quot;------------------重发第&quot;</span> + i + <span class="string">&quot;条消息，id: &quot;</span> + messageId + <span class="string">&quot;------------------&quot;</span>);</span><br><span class="line">            i++;</span><br><span class="line">            message.getMessageProperties().setMessageId(messageId + <span class="string">&quot;-重发&quot;</span>);</span><br><span class="line">            rabbitTemplate.send(messageCorrelationData.getExchange(), messageCorrelationData.getRoutingKey(),</span><br><span class="line">            messageCorrelationData.getMessage(), messageCorrelationData);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        logger.info(<span class="string">&quot;------------------重发完成------------------&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>重发的消息会在原消息id后面跟上“重发”二字。</p><p>本地测试打印出的相关信息，发送端：</p><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="number">15</span>:<span class="number">07</span>:<span class="number">36.063</span> <span class="selector-attr">[pool-3-thread-1]</span> INFO  c<span class="selector-class">.l</span><span class="selector-class">.l</span><span class="selector-class">.r</span><span class="selector-class">.p</span><span class="selector-class">.schedule</span><span class="selector-class">.task</span><span class="selector-class">.ReissueTask</span> <span class="selector-attr">[ReissueTask.java:29]</span> - ------------------获取到<span class="number">13</span>条发送失败的消息，准备重发------------------</span><br><span class="line"></span><br><span class="line"><span class="number">15</span>:<span class="number">07</span>:<span class="number">36.063</span> <span class="selector-attr">[pool-3-thread-1]</span> INFO  c<span class="selector-class">.l</span><span class="selector-class">.l</span><span class="selector-class">.r</span><span class="selector-class">.p</span><span class="selector-class">.schedule</span><span class="selector-class">.task</span><span class="selector-class">.ReissueTask</span> <span class="selector-attr">[ReissueTask.java:35]</span> - ------------------重发第<span class="number">1</span>条消息，id: reactor-http-nio-<span class="number">3</span>-<span class="number">7439</span>------------------</span><br><span class="line"></span><br><span class="line"><span class="number">15</span>:<span class="number">07</span>:<span class="number">38.030</span> <span class="selector-attr">[pool-3-thread-1]</span> INFO  o<span class="selector-class">.s</span><span class="selector-class">.a</span><span class="selector-class">.r</span><span class="selector-class">.c</span><span class="selector-class">.CachingConnectionFactory</span> <span class="selector-attr">[AbstractConnectionFactory.java:455]</span> - Attempting to connect to: <span class="selector-attr">[localhost:5672]</span></span><br><span class="line"></span><br><span class="line"><span class="number">15</span>:<span class="number">07</span>:<span class="number">40.036</span> <span class="selector-attr">[reactor-http-nio-3]</span> INFO  o<span class="selector-class">.s</span><span class="selector-class">.a</span><span class="selector-class">.r</span><span class="selector-class">.c</span><span class="selector-class">.CachingConnectionFactory</span> <span class="selector-attr">[AbstractConnectionFactory.java:455]</span> - Attempting to connect to: <span class="selector-attr">[localhost:5672]</span></span><br><span class="line"></span><br><span class="line">...</span><br><span class="line"></span><br><span class="line"><span class="number">15</span>:<span class="number">08</span>:<span class="number">14.188</span> <span class="selector-attr">[pool-3-thread-1]</span> INFO  o<span class="selector-class">.s</span><span class="selector-class">.a</span><span class="selector-class">.r</span><span class="selector-class">.c</span><span class="selector-class">.CachingConnectionFactory</span> <span class="selector-attr">[AbstractConnectionFactory.java:455]</span> - Attempting to connect to: <span class="selector-attr">[localhost:5672]</span></span><br><span class="line"></span><br><span class="line"><span class="number">15</span>:<span class="number">08</span>:<span class="number">16.190</span> <span class="selector-attr">[reactor-http-nio-3]</span> INFO  o<span class="selector-class">.s</span><span class="selector-class">.a</span><span class="selector-class">.r</span><span class="selector-class">.c</span><span class="selector-class">.CachingConnectionFactory</span> <span class="selector-attr">[AbstractConnectionFactory.java:455]</span> - Attempting to connect to: <span class="selector-attr">[localhost:5672]</span></span><br><span class="line"></span><br><span class="line"><span class="number">15</span>:<span class="number">08</span>:<span class="number">16.710</span> <span class="selector-attr">[reactor-http-nio-3]</span> INFO  o<span class="selector-class">.s</span><span class="selector-class">.a</span><span class="selector-class">.r</span><span class="selector-class">.c</span><span class="selector-class">.CachingConnectionFactory</span> <span class="selector-attr">[AbstractConnectionFactory.java:471]</span> - Created new connection: amqpConnectionFactory<span class="number">#2127e6</span>6e:<span class="number">25</span>/SimpleConnection@ee0d88b <span class="selector-attr">[delegate=amqp://guest@127.0.0.1:5672/test, localPort= 57212]</span></span><br><span class="line"></span><br><span class="line"><span class="number">15</span>:<span class="number">08</span>:<span class="number">16.716</span> <span class="selector-attr">[pool-3-thread-1]</span> INFO  c<span class="selector-class">.l</span><span class="selector-class">.l</span><span class="selector-class">.r</span><span class="selector-class">.p</span><span class="selector-class">.schedule</span><span class="selector-class">.task</span><span class="selector-class">.ReissueTask</span> <span class="selector-attr">[ReissueTask.java:35]</span> - ------------------重发第<span class="number">2</span>条消息，id: reactor-http-nio-<span class="number">3</span>-<span class="number">7440</span>------------------</span><br><span class="line"></span><br><span class="line"><span class="number">15</span>:<span class="number">08</span>:<span class="number">16.716</span> <span class="selector-attr">[reactor-http-nio-3]</span> INFO  c<span class="selector-class">.l</span><span class="selector-class">.l</span><span class="selector-class">.r</span><span class="selector-class">.p</span><span class="selector-class">.c</span><span class="selector-class">.RabbitmqController</span> <span class="selector-attr">[RabbitmqController.java:102]</span> - send message, id: reactor-http-nio-<span class="number">3</span>-<span class="number">7452</span></span><br><span class="line"></span><br><span class="line">send message: reactor-http-nio-<span class="number">3</span>-<span class="number">7452</span></span><br><span class="line"></span><br><span class="line"><span class="number">15</span>:<span class="number">08</span>:<span class="number">16.717</span> <span class="selector-attr">[pool-3-thread-1]</span> INFO  c<span class="selector-class">.l</span><span class="selector-class">.l</span><span class="selector-class">.r</span><span class="selector-class">.p</span><span class="selector-class">.schedule</span><span class="selector-class">.task</span><span class="selector-class">.ReissueTask</span> <span class="selector-attr">[ReissueTask.java:35]</span> - ------------------重发第<span class="number">3</span>条消息，id: reactor-http-nio-<span class="number">3</span>-<span class="number">7441</span>------------------</span><br><span class="line"></span><br><span class="line"><span class="number">15</span>:<span class="number">08</span>:<span class="number">16.718</span> <span class="selector-attr">[pool-3-thread-1]</span> INFO  c<span class="selector-class">.l</span><span class="selector-class">.l</span><span class="selector-class">.r</span><span class="selector-class">.p</span><span class="selector-class">.schedule</span><span class="selector-class">.task</span><span class="selector-class">.ReissueTask</span> <span class="selector-attr">[ReissueTask.java:35]</span> - ------------------重发第<span class="number">4</span>条消息，id: reactor-http-nio-<span class="number">3</span>-<span class="number">7442</span>------------------</span><br><span class="line"></span><br><span class="line"><span class="number">15</span>:<span class="number">08</span>:<span class="number">16.718</span> <span class="selector-attr">[reactor-http-nio-3]</span> INFO  c<span class="selector-class">.l</span><span class="selector-class">.l</span><span class="selector-class">.r</span><span class="selector-class">.p</span><span class="selector-class">.c</span><span class="selector-class">.RabbitmqController</span> <span class="selector-attr">[RabbitmqController.java:102]</span> - send message, id: reactor-http-nio-<span class="number">3</span>-<span class="number">7453</span></span><br><span class="line"></span><br><span class="line">send message: reactor-http-nio-<span class="number">3</span>-<span class="number">7453</span></span><br><span class="line"></span><br><span class="line"><span class="number">15</span>:<span class="number">08</span>:<span class="number">16.718</span> <span class="selector-attr">[pool-3-thread-1]</span> INFO  c<span class="selector-class">.l</span><span class="selector-class">.l</span><span class="selector-class">.r</span><span class="selector-class">.p</span><span class="selector-class">.schedule</span><span class="selector-class">.task</span><span class="selector-class">.ReissueTask</span> <span class="selector-attr">[ReissueTask.java:35]</span> - ------------------重发第<span class="number">5</span>条消息，id: reactor-http-nio-<span class="number">3</span>-<span class="number">7443</span>------------------</span><br><span class="line"></span><br><span class="line"><span class="number">15</span>:<span class="number">08</span>:<span class="number">16.719</span> <span class="selector-attr">[pool-3-thread-1]</span> INFO  c<span class="selector-class">.l</span><span class="selector-class">.l</span><span class="selector-class">.r</span><span class="selector-class">.p</span><span class="selector-class">.schedule</span><span class="selector-class">.task</span><span class="selector-class">.ReissueTask</span> <span class="selector-attr">[ReissueTask.java:35]</span> - ------------------重发第<span class="number">6</span>条消息，id: reactor-http-nio-<span class="number">3</span>-<span class="number">7444</span>------------------</span><br><span class="line"></span><br><span class="line"><span class="number">15</span>:<span class="number">08</span>:<span class="number">16.719</span> <span class="selector-attr">[pool-3-thread-1]</span> INFO  c<span class="selector-class">.l</span><span class="selector-class">.l</span><span class="selector-class">.r</span><span class="selector-class">.p</span><span class="selector-class">.schedule</span><span class="selector-class">.task</span><span class="selector-class">.ReissueTask</span> <span class="selector-attr">[ReissueTask.java:35]</span> - ------------------重发第<span class="number">7</span>条消息，id: reactor-http-nio-<span class="number">3</span>-<span class="number">7445</span>------------------</span><br><span class="line"></span><br><span class="line"><span class="number">15</span>:<span class="number">08</span>:<span class="number">16.719</span> <span class="selector-attr">[pool-3-thread-1]</span> INFO  c<span class="selector-class">.l</span><span class="selector-class">.l</span><span class="selector-class">.r</span><span class="selector-class">.p</span><span class="selector-class">.schedule</span><span class="selector-class">.task</span><span class="selector-class">.ReissueTask</span> <span class="selector-attr">[ReissueTask.java:35]</span> - ------------------重发第<span class="number">8</span>条消息，id: reactor-http-nio-<span class="number">3</span>-<span class="number">7446</span>------------------</span><br><span class="line"></span><br><span class="line"><span class="number">15</span>:<span class="number">08</span>:<span class="number">16.720</span> <span class="selector-attr">[reactor-http-nio-3]</span> INFO  c<span class="selector-class">.l</span><span class="selector-class">.l</span><span class="selector-class">.r</span><span class="selector-class">.p</span><span class="selector-class">.c</span><span class="selector-class">.RabbitmqController</span> <span class="selector-attr">[RabbitmqController.java:102]</span> - send message, id: reactor-http-nio-<span class="number">3</span>-<span class="number">7454</span></span><br><span class="line"></span><br><span class="line">send message: reactor-http-nio-<span class="number">3</span>-<span class="number">7454</span></span><br><span class="line"></span><br><span class="line"><span class="number">15</span>:<span class="number">08</span>:<span class="number">16.720</span> <span class="selector-attr">[pool-3-thread-1]</span> INFO  c<span class="selector-class">.l</span><span class="selector-class">.l</span><span class="selector-class">.r</span><span class="selector-class">.p</span><span class="selector-class">.schedule</span><span class="selector-class">.task</span><span class="selector-class">.ReissueTask</span> <span class="selector-attr">[ReissueTask.java:35]</span> - ------------------重发第<span class="number">9</span>条消息，id: reactor-http-nio-<span class="number">3</span>-<span class="number">7447</span>------------------</span><br><span class="line"></span><br><span class="line"><span class="number">15</span>:<span class="number">08</span>:<span class="number">16.720</span> <span class="selector-attr">[pool-3-thread-1]</span> INFO  c<span class="selector-class">.l</span><span class="selector-class">.l</span><span class="selector-class">.r</span><span class="selector-class">.p</span><span class="selector-class">.schedule</span><span class="selector-class">.task</span><span class="selector-class">.ReissueTask</span> <span class="selector-attr">[ReissueTask.java:35]</span> - ------------------重发第<span class="number">10</span>条消息，id: reactor-http-nio-<span class="number">3</span>-<span class="number">7448</span>------------------</span><br><span class="line"></span><br><span class="line"><span class="number">15</span>:<span class="number">08</span>:<span class="number">16.720</span> <span class="selector-attr">[AMQP Connection 127.0.0.1:5672]</span> INFO  c<span class="selector-class">.l</span><span class="selector-class">.l</span><span class="selector-class">.r</span><span class="selector-class">.p</span><span class="selector-class">.r</span><span class="selector-class">.ReissueMessageConfirmCallback</span> <span class="selector-attr">[ReissueMessageConfirmCallback.java:21]</span> - ------------messageId: reactor-http-nio-<span class="number">3</span>-<span class="number">7451</span>, ack: true, cause:null--------------</span><br><span class="line"></span><br><span class="line"><span class="number">15</span>:<span class="number">08</span>:<span class="number">16.721</span> <span class="selector-attr">[pool-3-thread-1]</span> INFO  c<span class="selector-class">.l</span><span class="selector-class">.l</span><span class="selector-class">.r</span><span class="selector-class">.p</span><span class="selector-class">.schedule</span><span class="selector-class">.task</span><span class="selector-class">.ReissueTask</span> <span class="selector-attr">[ReissueTask.java:35]</span> - ------------------重发第<span class="number">11</span>条消息，id: reactor-http-nio-<span class="number">3</span>-<span class="number">7449</span>------------------</span><br><span class="line"></span><br><span class="line"><span class="number">15</span>:<span class="number">08</span>:<span class="number">16.721</span> <span class="selector-attr">[reactor-http-nio-3]</span> INFO  c<span class="selector-class">.l</span><span class="selector-class">.l</span><span class="selector-class">.r</span><span class="selector-class">.p</span><span class="selector-class">.c</span><span class="selector-class">.RabbitmqController</span> <span class="selector-attr">[RabbitmqController.java:102]</span> - send message, id: reactor-http-nio-<span class="number">3</span>-<span class="number">7455</span></span><br><span class="line"></span><br><span class="line">send message: reactor-http-nio-<span class="number">3</span>-<span class="number">7455</span></span><br><span class="line"></span><br><span class="line"><span class="number">15</span>:<span class="number">08</span>:<span class="number">16.721</span> <span class="selector-attr">[pool-3-thread-1]</span> INFO  c<span class="selector-class">.l</span><span class="selector-class">.l</span><span class="selector-class">.r</span><span class="selector-class">.p</span><span class="selector-class">.schedule</span><span class="selector-class">.task</span><span class="selector-class">.ReissueTask</span> <span class="selector-attr">[ReissueTask.java:35]</span> - ------------------重发第<span class="number">12</span>条消息，id: reactor-http-nio-<span class="number">3</span>-<span class="number">7450</span>------------------</span><br><span class="line"></span><br><span class="line"><span class="number">15</span>:<span class="number">08</span>:<span class="number">16.722</span> <span class="selector-attr">[reactor-http-nio-3]</span> INFO  c<span class="selector-class">.l</span><span class="selector-class">.l</span><span class="selector-class">.r</span><span class="selector-class">.p</span><span class="selector-class">.c</span><span class="selector-class">.RabbitmqController</span> <span class="selector-attr">[RabbitmqController.java:102]</span> - send message, id: reactor-http-nio-<span class="number">3</span>-<span class="number">7456</span></span><br><span class="line"></span><br><span class="line">send message: reactor-http-nio-<span class="number">3</span>-<span class="number">7456</span></span><br><span class="line"></span><br><span class="line"><span class="number">15</span>:<span class="number">08</span>:<span class="number">16.723</span> <span class="selector-attr">[pool-3-thread-1]</span> INFO  c<span class="selector-class">.l</span><span class="selector-class">.l</span><span class="selector-class">.r</span><span class="selector-class">.p</span><span class="selector-class">.schedule</span><span class="selector-class">.task</span><span class="selector-class">.ReissueTask</span> <span class="selector-attr">[ReissueTask.java:35]</span> - ------------------重发第<span class="number">13</span>条消息，id: reactor-http-nio-<span class="number">3</span>-<span class="number">7451</span>------------------</span><br><span class="line"></span><br><span class="line"><span class="number">15</span>:<span class="number">08</span>:<span class="number">16.723</span> <span class="selector-attr">[pool-3-thread-1]</span> INFO  c<span class="selector-class">.l</span><span class="selector-class">.l</span><span class="selector-class">.r</span><span class="selector-class">.p</span><span class="selector-class">.schedule</span><span class="selector-class">.task</span><span class="selector-class">.ReissueTask</span> <span class="selector-attr">[ReissueTask.java:41]</span> - ------------------重发完成------------------</span><br></pre></td></tr></table></figure><p>reactor-http-nio-3是请求主线程，pool-3-thread-1是执行重发消息定时任务的线程。</p><p>从以上日志信息可以看出，当rabbitmq关闭的时候，主线程与重发线程都在尝试重连，直到rabbitmq重启完成恢复Connection。重发的消息有13条：reactor-http-nio-3-7439 ~ reactor-http-nio-3-7451。</p><p>再看消费端整理并打印出来的接收到的所有消息：</p><figure class="highlight subunit"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">--------should receive:10000---------</span><br><span class="line"></span><br><span class="line">----------actually receive: 10013----------</span><br><span class="line"></span><br><span class="line">----------absent messages:0---------</span><br><span class="line"></span><br><span class="line">----------resend messages: 13----------</span><br><span class="line"></span><br><span class="line">reactor-http-nio<span class="string">-3</span><span class="string">-7439</span>-重发</span><br><span class="line"></span><br><span class="line">reactor-http-nio<span class="string">-3</span><span class="string">-7440</span>-重发</span><br><span class="line"></span><br><span class="line">reactor-http-nio<span class="string">-3</span><span class="string">-7441</span>-重发</span><br><span class="line"></span><br><span class="line">reactor-http-nio<span class="string">-3</span><span class="string">-7442</span>-重发</span><br><span class="line"></span><br><span class="line">reactor-http-nio<span class="string">-3</span><span class="string">-7443</span>-重发</span><br><span class="line"></span><br><span class="line">reactor-http-nio<span class="string">-3</span><span class="string">-7444</span>-重发</span><br><span class="line"></span><br><span class="line">reactor-http-nio<span class="string">-3</span><span class="string">-7446</span>-重发</span><br><span class="line"></span><br><span class="line">reactor-http-nio<span class="string">-3</span><span class="string">-7447</span>-重发</span><br><span class="line"></span><br><span class="line">reactor-http-nio<span class="string">-3</span><span class="string">-7445</span>-重发</span><br><span class="line"></span><br><span class="line">reactor-http-nio<span class="string">-3</span><span class="string">-7449</span>-重发</span><br><span class="line"></span><br><span class="line">reactor-http-nio<span class="string">-3</span><span class="string">-7448</span>-重发</span><br><span class="line"></span><br><span class="line">reactor-http-nio<span class="string">-3</span><span class="string">-7450</span>-重发</span><br><span class="line"></span><br><span class="line">reactor-http-nio<span class="string">-3</span><span class="string">-7451</span>-重发</span><br></pre></td></tr></table></figure><p>可以看到，我们正确收到了上面那重发的13条消息。不过这次运气比较好，没有消息遗漏。同时，这里注意到一件事，消费端代码没有对重发的消息做排序，收到的重发消息的顺序与发送端重发消息的顺序是不匹配的，所以rabbitmq可能不保证先发出的消息一定先被接收。</p><p>下面是5个线程同时发送消息的测试结果，发送端：</p><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">15</span>:<span class="number">42</span>:<span class="number">40.602</span> <span class="selector-attr">[pool-3-thread-1]</span> INFO  c<span class="selector-class">.l</span><span class="selector-class">.l</span><span class="selector-class">.r</span><span class="selector-class">.p</span><span class="selector-class">.schedule</span><span class="selector-class">.task</span><span class="selector-class">.ReissueTask</span> <span class="selector-attr">[ReissueTask.java:29]</span> - ------------------获取到<span class="number">642</span>条发送失败的消息，准备重发------------------</span><br><span class="line"></span><br><span class="line"><span class="number">15</span>:<span class="number">42</span>:<span class="number">40.602</span> <span class="selector-attr">[pool-3-thread-1]</span> INFO  c<span class="selector-class">.l</span><span class="selector-class">.l</span><span class="selector-class">.r</span><span class="selector-class">.p</span><span class="selector-class">.schedule</span><span class="selector-class">.task</span><span class="selector-class">.ReissueTask</span> <span class="selector-attr">[ReissueTask.java:35]</span> - ------------------重发第<span class="number">1</span>条消息，id: pool-<span class="number">5</span>-thread-<span class="number">4</span>-<span class="number">6951</span>------------------</span><br><span class="line"></span><br><span class="line">...</span><br><span class="line"></span><br><span class="line">省略重连过程</span><br><span class="line"></span><br><span class="line">...</span><br><span class="line"></span><br><span class="line"><span class="number">15</span>:<span class="number">43</span>:<span class="number">07.628</span> <span class="selector-attr">[pool-3-thread-1]</span> INFO  c<span class="selector-class">.l</span><span class="selector-class">.l</span><span class="selector-class">.r</span><span class="selector-class">.p</span><span class="selector-class">.schedule</span><span class="selector-class">.task</span><span class="selector-class">.ReissueTask</span> <span class="selector-attr">[ReissueTask.java:35]</span> - ------------------重发第<span class="number">2</span>条消息，id: pool-<span class="number">5</span>-thread-<span class="number">5</span>-<span class="number">6605</span>------------------</span><br><span class="line"></span><br><span class="line">...</span><br><span class="line"></span><br><span class="line">省略中间<span class="number">600</span>多条消息的重发</span><br><span class="line"></span><br><span class="line">...</span><br><span class="line"></span><br><span class="line"><span class="number">15</span>:<span class="number">43</span>:<span class="number">07.794</span> <span class="selector-attr">[pool-3-thread-1]</span> INFO  c<span class="selector-class">.l</span><span class="selector-class">.l</span><span class="selector-class">.r</span><span class="selector-class">.p</span><span class="selector-class">.schedule</span><span class="selector-class">.task</span><span class="selector-class">.ReissueTask</span> <span class="selector-attr">[ReissueTask.java:35]</span> - ------------------重发第<span class="number">641</span>条消息，id: pool-<span class="number">5</span>-thread-<span class="number">1</span>-<span class="number">6704</span>------------------</span><br><span class="line"></span><br><span class="line"><span class="number">15</span>:<span class="number">43</span>:<span class="number">07.794</span> <span class="selector-attr">[pool-3-thread-1]</span> INFO  c<span class="selector-class">.l</span><span class="selector-class">.l</span><span class="selector-class">.r</span><span class="selector-class">.p</span><span class="selector-class">.schedule</span><span class="selector-class">.task</span><span class="selector-class">.ReissueTask</span> <span class="selector-attr">[ReissueTask.java:35]</span> - ------------------重发第<span class="number">642</span>条消息，id: pool-<span class="number">5</span>-thread-<span class="number">4</span>-<span class="number">7088</span>------------------</span><br><span class="line"></span><br><span class="line"><span class="number">15</span>:<span class="number">43</span>:<span class="number">07.794</span> <span class="selector-attr">[pool-3-thread-1]</span> INFO  c<span class="selector-class">.l</span><span class="selector-class">.l</span><span class="selector-class">.r</span><span class="selector-class">.p</span><span class="selector-class">.schedule</span><span class="selector-class">.task</span><span class="selector-class">.ReissueTask</span> <span class="selector-attr">[ReissueTask.java:41]</span> - ------------------重发完成------------------</span><br></pre></td></tr></table></figure><p>消费端：</p><figure class="highlight subunit"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br></pre></td><td class="code"><pre><span class="line">--------should receive:50000---------</span><br><span class="line"></span><br><span class="line">----------actually receive: 50014----------</span><br><span class="line"></span><br><span class="line">----------absent messages:628---------</span><br><span class="line"></span><br><span class="line">pool<span class="string">-5</span>-thread<span class="string">-1</span><span class="string">-6583</span></span><br><span class="line"></span><br><span class="line">pool<span class="string">-5</span>-thread<span class="string">-1</span><span class="string">-6584</span></span><br><span class="line"></span><br><span class="line">...</span><br><span class="line"></span><br><span class="line">pool<span class="string">-5</span>-thread<span class="string">-1</span><span class="string">-6705</span></span><br><span class="line"></span><br><span class="line">pool<span class="string">-5</span>-thread<span class="string">-2</span><span class="string">-6538</span></span><br><span class="line"></span><br><span class="line">...</span><br><span class="line"></span><br><span class="line">pool<span class="string">-5</span>-thread<span class="string">-2</span><span class="string">-6653</span></span><br><span class="line"></span><br><span class="line">pool<span class="string">-5</span>-thread<span class="string">-3</span><span class="string">-6093</span></span><br><span class="line"></span><br><span class="line">...</span><br><span class="line"></span><br><span class="line">pool<span class="string">-5</span>-thread<span class="string">-3</span><span class="string">-6218</span></span><br><span class="line"></span><br><span class="line">pool<span class="string">-5</span>-thread<span class="string">-4</span><span class="string">-6955</span></span><br><span class="line"></span><br><span class="line">...</span><br><span class="line"></span><br><span class="line">pool<span class="string">-5</span>-thread<span class="string">-4</span><span class="string">-7087</span></span><br><span class="line"></span><br><span class="line">pool<span class="string">-5</span>-thread<span class="string">-5</span><span class="string">-6605</span></span><br><span class="line"></span><br><span class="line">...</span><br><span class="line"></span><br><span class="line">pool<span class="string">-5</span>-thread<span class="string">-5</span><span class="string">-6733</span></span><br><span class="line"></span><br><span class="line">pool<span class="string">-5</span>-thread<span class="string">-5</span><span class="string">-6734</span></span><br><span class="line"></span><br><span class="line">----------resend messages: 642----------</span><br><span class="line"></span><br><span class="line">pool<span class="string">-5</span>-thread<span class="string">-1</span><span class="string">-6580</span>-重发</span><br><span class="line"></span><br><span class="line">pool<span class="string">-5</span>-thread<span class="string">-1</span><span class="string">-6581</span>-重发</span><br><span class="line"></span><br><span class="line">...</span><br><span class="line"></span><br><span class="line">pool<span class="string">-5</span>-thread<span class="string">-1</span><span class="string">-6705</span>-重发</span><br><span class="line"></span><br><span class="line">pool<span class="string">-5</span>-thread<span class="string">-1</span><span class="string">-6706</span>-重发</span><br><span class="line"></span><br><span class="line">pool<span class="string">-5</span>-thread<span class="string">-2</span><span class="string">-6537</span>-重发</span><br><span class="line"></span><br><span class="line">...</span><br><span class="line"></span><br><span class="line">pool<span class="string">-5</span>-thread<span class="string">-2</span><span class="string">-6654</span>-重发</span><br><span class="line"></span><br><span class="line">pool<span class="string">-5</span>-thread<span class="string">-3</span><span class="string">-6093</span>-重发</span><br><span class="line"></span><br><span class="line">...</span><br><span class="line"></span><br><span class="line">pool<span class="string">-5</span>-thread<span class="string">-3</span><span class="string">-6219</span>-重发</span><br><span class="line"></span><br><span class="line">pool<span class="string">-5</span>-thread<span class="string">-4</span><span class="string">-6951</span>-重发</span><br><span class="line"></span><br><span class="line">...</span><br><span class="line"></span><br><span class="line">pool<span class="string">-5</span>-thread<span class="string">-4</span><span class="string">-7088</span>-重发</span><br><span class="line"></span><br><span class="line">pool<span class="string">-5</span>-thread<span class="string">-5</span><span class="string">-6604</span>-重发</span><br><span class="line"></span><br><span class="line">...</span><br><span class="line"></span><br><span class="line">pool<span class="string">-5</span>-thread<span class="string">-5</span><span class="string">-6734</span>-重发</span><br><span class="line"></span><br><span class="line">pool<span class="string">-5</span>-thread<span class="string">-5</span><span class="string">-6735</span>-重发</span><br></pre></td></tr></table></figure><p>可以看到，丢失的消息被完美地包含在重发的消息里面了。</p><h4 id="（2）长时间无法恢复的Connection中断"><a href="#（2）长时间无法恢复的Connection中断" class="headerlink" title="（2）长时间无法恢复的Connection中断"></a>（2）长时间无法恢复的Connection中断</h4><p>上面讨论了retry之后可以恢复Connection的情况，也有可能长时间retry之后依然不能恢复Connection，如rabbitmq挂掉的情况，不能一直retry下去阻塞接口调用。</p><p>这种情况是没有confirm的，因为消息都没有发出去。所以处理就更简单了：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">    rabbitTemplate.send(messageCorrelationData.getExchange(), messageCorrelationData.getRoutingKey(), messageCorrelationData.getMessage(), messageCorrelationData);</span><br><span class="line">&#125; <span class="keyword">catch</span> (AmqpConnectException e) &#123;</span><br><span class="line">    SendFailedMessageHolder.add(messageCorrelationData);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>retry失败或者没有retry机制都会抛出AmqpConnectException，catch之后将消息保存起来即可。</p><h3 id="2-15-消费端的消息去重"><a href="#2-15-消费端的消息去重" class="headerlink" title="2.15 消费端的消息去重"></a>2.15 消费端的消息去重</h3><p>如果发送端采用confirm机制来做丢失消息的重发，上面提到，可能会出现没有丢失的消息也被重发了，导致消息重复。</p><p>这个问题很容易解决，MessageProperties中是有messageId属性的，每条消息设置一个唯一的messageId即可。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Message message = messageConverter.toMessage(messageId, <span class="keyword">new</span> MessageProperties());</span><br><span class="line">message.getMessageProperties().setMessageId(messageId);</span><br></pre></td></tr></table></figure><h3 id="2-16-消息发送和接收使用不同的Connection"><a href="#2-16-消息发送和接收使用不同的Connection" class="headerlink" title="2.16 消息发送和接收使用不同的Connection"></a>2.16 消息发送和接收使用不同的Connection</h3><p>当一个服务同时作为消息发送端和接收端时，建议使用不同的Connection以避免一方出现故障影响到另一方。</p><p>并不需要做很多事情，只需RabbitTemplate配置中加一个属性设置即可：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">rabbitTemplate.setUsePublisherConnection(<span class="keyword">true</span>);</span><br></pre></td></tr></table></figure><p>RabbitTemplate在创建Connection时，会根据这个boolean参数选择使用ConnectionFactory本身或者ConnectionFactory中的publisherConnectionFactory（也是一个ConnectionFactory）来创建，相关源码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">   <span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Create a connection with this connection factory and/or its publisher factory.</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> connectionFactory the connection factory.</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> publisherConnectionIfPossible true to use the publisher factory, if present.</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> the connection.</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@since</span> 2.0.2</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Connection <span class="title">createConnection</span><span class="params">(<span class="keyword">final</span> ConnectionFactory connectionFactory, <span class="keyword">final</span> <span class="keyword">boolean</span> publisherConnectionIfPossible)</span> </span>&#123;</span><br><span class="line">       <span class="keyword">if</span> (publisherConnectionIfPossible) &#123;</span><br><span class="line">           ConnectionFactory publisherFactory = connectionFactory.getPublisherConnectionFactory();</span><br><span class="line">           <span class="keyword">if</span> (publisherFactory != <span class="keyword">null</span>) &#123;</span><br><span class="line">               <span class="keyword">return</span> publisherFactory.createConnection();</span><br><span class="line">           &#125;</span><br><span class="line">       &#125;</span><br><span class="line">       </span><br><span class="line">       <span class="keyword">return</span> connectionFactory.createConnection();</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure><h3 id="2-17-消息过期"><a href="#2-17-消息过期" class="headerlink" title="2.17 消息过期"></a>2.17 消息过期</h3><p>在发送端，可通过如下方式设置消息过期时间：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">message.getMessageProperties().setExpiration(<span class="string">&quot;30000&quot;</span>);</span><br></pre></td></tr></table></figure><p>这样，这条消息的有效期是30秒，30秒没有被消费掉会被丢弃。</p><h3 id="2-18-Dead-letter-exchange"><a href="#2-18-Dead-letter-exchange" class="headerlink" title="2.18 Dead letter exchange"></a>2.18 Dead letter exchange</h3><p>这个与spring-amqp无关，是rabbitmq的设置。将一个queue设置了 <code>x-dead-letter-exchange</code> 及 <code>x-dead-letter-routing-key</code> 两个参数后，这个queue里丢弃的消息将会进入 <code>dead letter exchange</code> ，并route到相应的queue里去。</p><p>这里，被丢弃的消息包括：</p><figure class="highlight ada"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">The message <span class="keyword">is</span> rejected (basic.reject <span class="keyword">or</span> basic.nack) <span class="keyword">with</span> <span class="keyword">requeue</span>=<span class="literal">false</span>,</span><br><span class="line"></span><br><span class="line">The TTL <span class="keyword">for</span> the message expires; <span class="keyword">or</span></span><br><span class="line"></span><br><span class="line">The queue length limit <span class="keyword">is</span> exceeded.</span><br></pre></td></tr></table></figure><h2 id="三-原理"><a href="#三-原理" class="headerlink" title="三. 原理"></a>三. 原理</h2><h3 id="3-1-架构"><a href="#3-1-架构" class="headerlink" title="3.1 架构"></a>3.1 架构</h3><p>Spring AMQP的构成：</p><ul><li>spring-amqp：包含 <code>org.springframework.amqp.core</code>软件包，提供不依赖任何特定 AMQP 代理实现或 Client 端库的通用抽象。最终用户代码将只能在抽象层上开发，因此在各个供应商的实现中将更具可移植性。</li><li>spring-rabbit：RabbitMQ实现。</li></ul><h3 id="3-2-核心类"><a href="#3-2-核心类" class="headerlink" title="3.2 核心类"></a>3.2 核心类</h3><h4 id="（1）Message"><a href="#（1）Message" class="headerlink" title="（1）Message"></a>（1）Message</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Message</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> MessageProperties messageProperties;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">byte</span>[] body;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Message</span><span class="params">(<span class="keyword">byte</span>[] body, MessageProperties messageProperties)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.body = body;</span><br><span class="line">        <span class="keyword">this</span>.messageProperties = messageProperties;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">byte</span>[] getBody() &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">this</span>.body;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> MessageProperties <span class="title">getMessageProperties</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">this</span>.messageProperties;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>MessageProperties</code> 接口定义了一些常用属性（如Header、exchange、routing key、消息创建时间timestamp等），也可以通过header扩展：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MessageProperties</span> <span class="keyword">implements</span> <span class="title">Serializable</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">long</span> serialVersionUID = <span class="number">1619000546531112290L</span>;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> String CONTENT_TYPE_BYTES = <span class="string">&quot;application/octet-stream&quot;</span>;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> String CONTENT_TYPE_TEXT_PLAIN = <span class="string">&quot;text/plain&quot;</span>;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> String CONTENT_TYPE_SERIALIZED_OBJECT = <span class="string">&quot;application/x-java-serialized-object&quot;</span>;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> String CONTENT_TYPE_JSON = <span class="string">&quot;application/json&quot;</span>;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> String CONTENT_TYPE_JSON_ALT = <span class="string">&quot;text/x-json&quot;</span>;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> String CONTENT_TYPE_XML = <span class="string">&quot;application/xml&quot;</span>;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> String SPRING_BATCH_FORMAT = <span class="string">&quot;springBatchFormat&quot;</span>;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> String BATCH_FORMAT_LENGTH_HEADER4 = <span class="string">&quot;lengthHeader4&quot;</span>;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> String SPRING_AUTO_DECOMPRESS = <span class="string">&quot;springAutoDecompress&quot;</span>;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> String X_DELAY = <span class="string">&quot;x-delay&quot;</span>;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> String DEFAULT_CONTENT_TYPE = <span class="string">&quot;application/octet-stream&quot;</span>;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> MessageDeliveryMode DEFAULT_DELIVERY_MODE;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> Integer DEFAULT_PRIORITY;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> Map&lt;String, Object&gt; headers = <span class="keyword">new</span> HashMap();</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">volatile</span> Date timestamp;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">volatile</span> String messageId;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">volatile</span> String userId;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">volatile</span> String appId;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">volatile</span> String clusterId;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">volatile</span> String type;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">volatile</span> <span class="keyword">byte</span>[] correlationId;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">volatile</span> String correlationIdString;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">volatile</span> String replyTo;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">volatile</span> String contentType = <span class="string">&quot;application/octet-stream&quot;</span>;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">volatile</span> String contentEncoding;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">volatile</span> <span class="keyword">long</span> contentLength;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">volatile</span> <span class="keyword">boolean</span> contentLengthSet;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">volatile</span> MessageDeliveryMode deliveryMode;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">volatile</span> String expiration;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">volatile</span> Integer priority;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">volatile</span> Boolean redelivered;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">volatile</span> String receivedExchange;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">volatile</span> String receivedRoutingKey;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">volatile</span> String receivedUserId;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">volatile</span> <span class="keyword">long</span> deliveryTag;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">volatile</span> <span class="keyword">boolean</span> deliveryTagSet;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">volatile</span> Integer messageCount;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">volatile</span> String consumerTag;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">volatile</span> String consumerQueue;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">volatile</span> Integer receivedDelay;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">volatile</span> MessageDeliveryMode receivedDeliveryMode;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">transient</span> <span class="keyword">volatile</span> Type inferredArgumentType;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">transient</span> <span class="keyword">volatile</span> Method targetMethod;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">transient</span> <span class="keyword">volatile</span> Object targetBean;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 扩展属性</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setHeader</span><span class="params">(String key, Object value)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.headers.put(key, value);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="（2）Exchange"><a href="#（2）Exchange" class="headerlink" title="（2）Exchange"></a>（2）Exchange</h4><p><code>Exchange</code> 接口表示一个 AMQP 交换器：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Exchange</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 名称</span></span><br><span class="line">    <span class="function">String <span class="title">getName</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 交换器类型</span></span><br><span class="line">    <span class="function">String <span class="title">getExchangeType</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 是否持久化</span></span><br><span class="line">    <span class="function"><span class="keyword">boolean</span> <span class="title">isDurable</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 是否自动删除</span></span><br><span class="line">    <span class="function"><span class="keyword">boolean</span> <span class="title">isAutoDelete</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 其他一些结构化参数</span></span><br><span class="line">    <span class="function">Map&lt;String, Object&gt; <span class="title">getArguments</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Exchange：<code>Direct</code> ，<code>Topic</code> ，<code>Fanout</code> 和 <code>Headers</code> 。库中可以找到每种类型的<code>Exchange</code> 接口的实现。不同交换器类型可以参考：<a href="http://linyishui.top/2020091901.html">RabbitMQ（一）简介和入门</a>。</p><h4 id="（3）Queue"><a href="#（3）Queue" class="headerlink" title="（3）Queue"></a>（3）Queue</h4><p><code>Queue</code> 类表示消息队列：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Queue</span>  </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 队列名称</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> String name;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 是否持久化</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">volatile</span> <span class="keyword">boolean</span> durable;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 是否排他，仅对首次声明它的连接可见，并在连接断开时自动删除，适用于一个客户端同时发送和读取消息的应用场景。</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">volatile</span> <span class="keyword">boolean</span> exclusive;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 是否自动删除</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">volatile</span> <span class="keyword">boolean</span> autoDelete;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 其他一些参数</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">volatile</span> Map&lt;String, Object&gt; arguments;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * The queue is durable, non-exclusive and non auto-delete.</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> name the name of the queue.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Queue</span><span class="params">(String name)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>(name, <span class="keyword">true</span>, <span class="keyword">false</span>, <span class="keyword">false</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Getters and Setters omitted for brevity</span></span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>构造函数采用队列名称。取决于实现方式，Management 模板可以提供用于生成唯一命名的队列的方法。这样的队列可用作“答复”地址或其他“临时”情况。因此，自动生成的 Queue 的  exclusive 和 autoDelete 属性都将设置为 true 。</p><h4 id="（4）Binding"><a href="#（4）Binding" class="headerlink" title="（4）Binding"></a>（4）Binding</h4><p>生产者发送到 Exchange，而消费者从队列接收，将队列连接到 Exchange 的绑定至关重要。Spring AMQP 中定义了一个 <code>Binding</code> 类来表示这些连接。</p><p>可以使用固定的路由键将队列绑定到 DirectExchange。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">new</span> Binding(someQueue, someDirectExchange, <span class="string">&quot;foo.bar&quot;</span>)</span><br></pre></td></tr></table></figure><p>可以使用路由模式将队列绑定到 TopicExchange。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">new</span> Binding(someQueue, someTopicExchange, <span class="string">&quot;foo.*&quot;</span>)</span><br></pre></td></tr></table></figure><p>可以使用路由键将队列绑定到 FanoutExchange。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">new</span> Binding(someQueue, someFanoutExchange)</span><br></pre></td></tr></table></figure><p>还提供 <code>BindingBuilder</code> 以促进“Fluent 的 API”样式。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 对bind()方法使用静态导入样式效果很好</span></span><br><span class="line">Binding b = BindingBuilder.bind(someQueue).to(someTopicExchange).with(<span class="string">&quot;foo.*&quot;</span>);</span><br></pre></td></tr></table></figure><p><code>AmqpAdmin</code> 类可以使用绑定实例来实际触发代理上的绑定操作，可以在<code>@Configuration</code> 类中使用 Spring 的 <code>@Bean</code> -style 定义 Binding 实例。</p><h3 id="3-3-连接和资源Management"><a href="#3-3-连接和资源Management" class="headerlink" title="3.3 连接和资源Management"></a>3.3 连接和资源Management</h3><p>这一部分区别于核心类是基于具体实现的，RabbitMQ是目前唯一支持的实现。</p><h4 id="（1）ConnectionFactory-连接工厂类"><a href="#（1）ConnectionFactory-连接工厂类" class="headerlink" title="（1）ConnectionFactory-连接工厂类"></a>（1）ConnectionFactory-连接工厂类</h4><ul><li><code>ConnectionFactory</code> 接口是用于 Management 与 RabbitMQ 代理的连接的中央组件。 </li><li><code>ConnectionFactory</code> 的职责是提供<code>org.springframework.amqp.rabbit.connection.Connection</code> 的实例，该实例是 <code>com.rabbitmq.client.Connection</code> 的包装器。</li><li>提供的唯一具体实现是 <code>CachingConnectionFactory</code> ，默认情况下，它构建一个可以由应用程序共享的单个连接代理。</li><li>可以共享连接，因为与 AMQP 进行消息传递的“工作单元”实际上是一个“通道”(在某些方面，这类似于 JMS 中的 Connection 和 Session 之间的关系)。可以想象，连接实例提供了 <code>createChannel</code> 方法。 </li><li><code>CachingConnectionFactory</code> 实现支持这些通道的缓存，并且根据它们是否是事务性的，为通道维护单独的缓存。创建 <code>CachingConnectionFactory</code> 的实例时，可以通过构造函数提供hostname。还应该提供username和password属性。如果要配置通道缓存的大小(默认值为25)，则也可以在此处调用 <code>setChannelCacheSize()</code> 方法。</li><li>从1.3版本开始，可以将 <code>CachingConnectionFactory</code> 配置为缓存连接以及通道。在这种情况下，每次对 <code>createConnection()</code> 的调用都会创建一个新连接(或从缓存中检索一个空闲的连接)。关闭连接会将其返回到缓存(如果尚未达到缓存大小)。在此类连接上创建的通道也将被缓存。</li><li>在某些环境中，使用单独的连接可能很有用，例如从 HA 群集中使用负载，并与负载均衡器一起连接到不同的群集成员。将 <code>cacheMode</code> 设置为<code>CacheMode.CONNECTION</code> 。</li><li>从1.5.5版本开始，提供了一个新属性 <code>connectionLimit</code> 。设置此选项后，它将限制允许的连接总数。设置后，如果达到限制，则使用 <code>channelCheckoutTimeLimit</code> await 连接变为空闲。如果超过时间，则抛出 <code>AmqpTimeoutException</code> 。</li><li>当使用大量连接时，应考虑在 <code>CachingConnectionFactory</code> 上设置自定义<code>executor</code> 。然后，所有连接将使用同一执行程序，并且可以共享其线程。执行程序的线程池应该是无界的，或者应为预期的使用率进行适当设置(通常每个连接至少一个线程)。如果在每个连接上创建多个通道，则池大小将影响并发性，因此，变量(或简单缓存)线程池执行程序将是最合适的。</li><li>从1.6版本开始，默认的通道缓存大小已从1增加到25。在大容量，多线程的环境中，小的缓存意味着将以较高的速率创建和关闭通道。增加默认缓存大小将避免这种开销。您应该通过 RabbitMQ Admin UI 监视正在使用的通道，如果看到许多正在创建和关闭的通道，请考虑进一步增加缓存大小。缓存将仅按需增长(以适应应用程序的并发要求)，因此此更改不会影响现有的小批量应用程序。</li><li>从1.4.2版本开始，<code>CachingConnectionFactory</code> 具有属性<code>channelCheckoutTimeout</code> 。当此属性大于零时，<code>channelCacheSize</code> 成为可在连接上创建的通道数的限制。如果达到限制，则调用线程将阻塞，直到某个通道可用或达到此超时为止，在这种情况下将引发 <code>AmqpTimeoutException</code> 。</li><li>框架内使用的通道(例如<code>RabbitTemplate</code>)将可靠地返回到缓存。如果您在框架外部创建通道(例如，通过直接访问连接并调用 <code>createChannel()</code> )，则必须(通过关闭)可靠地返回它们(可能在 <code>finally</code> 块中)，以避免耗尽通道。</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">CachingConnectionFactory connectionFactory = <span class="keyword">new</span> CachingConnectionFactory(<span class="string">&quot;somehost&quot;</span>);</span><br><span class="line">connectionFactory.setUsername(<span class="string">&quot;guest&quot;</span>);</span><br><span class="line">connectionFactory.setPassword(<span class="string">&quot;guest&quot;</span>);</span><br><span class="line"></span><br><span class="line">Connection connection = connectionFactory.createConnection();</span><br></pre></td></tr></table></figure><p> XML ：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;connectionFactory&quot;</span></span></span><br><span class="line"><span class="tag">      <span class="attr">class</span>=<span class="string">&quot;org.springframework.amqp.rabbit.connection.CachingConnectionFactory&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">constructor-arg</span> <span class="attr">value</span>=<span class="string">&quot;somehost&quot;</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;username&quot;</span> <span class="attr">value</span>=<span class="string">&quot;guest&quot;</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;password&quot;</span> <span class="attr">value</span>=<span class="string">&quot;guest&quot;</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br></pre></td></tr></table></figure><p>可以使用 Rabbit 名称空间快速便捷地创建<code>ConnectionFactory</code>：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">rabbit:connection-factory</span> <span class="attr">id</span>=<span class="string">&quot;connectionFactory&quot;</span>/&gt;</span></span><br></pre></td></tr></table></figure><p>在大多数情况下，这是可取的，因为框架可以为您选择最佳的默认值。创建的实例将是 <code>CachingConnectionFactory</code> 。请记住，通道的默认缓存大小为 25。如果要缓存更多通道，请通过channelCacheSize属性设置一个较大的值。在 XML 中，它看起来像这样：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;connectionFactory&quot;</span></span></span><br><span class="line"><span class="tag">      <span class="attr">class</span>=<span class="string">&quot;org.springframework.amqp.rabbit.connection.CachingConnectionFactory&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">constructor-arg</span> <span class="attr">value</span>=<span class="string">&quot;somehost&quot;</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;username&quot;</span> <span class="attr">value</span>=<span class="string">&quot;guest&quot;</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;password&quot;</span> <span class="attr">value</span>=<span class="string">&quot;guest&quot;</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;channelCacheSize&quot;</span> <span class="attr">value</span>=<span class="string">&quot;50&quot;</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br></pre></td></tr></table></figure><h4 id="（2）ConnectionNameStrategy-连接命名"><a href="#（2）ConnectionNameStrategy-连接命名" class="headerlink" title="（2）ConnectionNameStrategy-连接命名"></a>（2）ConnectionNameStrategy-连接命名</h4><p>从1.7 版本开始，提供了 <code>ConnectionNameStrategy</code> 以便注入<code>AbstractionConnectionFactory</code> 。生成的名称用于目标 RabbitMQ 连接的特定于应用程序的标识。如果 RabbitMQ 服务器支持，则连接名称将显示在 ManagementUI 中。此值不必是唯一的，也不能用作连接标识符，例如在 HTTP API 请求中。该值应该是人类可读的，并且是<code>connection_name</code>键下<code>ClientProperties</code>的一部分。</p><p>可以使用一个简单的 Lambda：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">connectionFactory.setConnectionNameStrategy(connectionFactory -&gt; &quot;MY_CONNECTION&quot;);</span><br></pre></td></tr></table></figure><p><code>ConnectionFactory</code> 参数可用于通过某些逻辑来区分目标连接名称。默认情况下，<code>AbstractConnectionFactory</code> 的 <code>beanName</code> ，代表对象的十六进制字符串和内部计数器用于生成 <code>connection_name</code> 。 <code>&lt;rabbit:connection-factory&gt; </code>名称空间组件也随 <code>connection-name-strategy</code> 属性一起提供。</p><p>提供了实现 <code>SimplePropertyValueConnectionNameStrategy</code> ，该实现将连接名称设置为应用程序属性。将其声明为 <code>@Bean</code> 并将其注入连接工厂：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Bean</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> ConnectionNameStrategy <span class="title">cns</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> SimplePropertyValueConnectionNameStrategy(<span class="string">&quot;spring.application.name&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Bean</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> ConnectionFactory <span class="title">rabbitConnectionFactory</span><span class="params">(ConnectionNameStrategy cns)</span> </span>&#123;</span><br><span class="line">    CachingConnectionFactory connectionFactory = <span class="keyword">new</span> CachingConnectionFactory();</span><br><span class="line">    ...</span><br><span class="line">    connectionFactory.setConnectionNameStrategy(cns);</span><br><span class="line">    <span class="keyword">return</span> connectionFactory;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>使用 Spring Boot 及其自动配置的连接工厂时，仅需要声明 <code>ConnectionNameStrategy</code> 的 <code>@Bean</code>。引导程序将自动检测到该 bean，并将其连接到工厂。</p><h4 id="（3）阻止的连接和资源限制"><a href="#（3）阻止的连接和资源限制" class="headerlink" title="（3）阻止的连接和资源限制"></a>（3）阻止的连接和资源限制</h4><p>RabbitMQ内存警告（Memory Alarm）连接可能被阻止与 Broker 进行交互。从2.0开始，提供 <code>com.rabbitmq.client.BlockedListener</code> ，以通知连接被阻止和未被阻止的事件。此外，<code>AbstractConnectionFactory</code> 通过其内部<code>BlockedListener</code> 实现分别发出 <code>ConnectionBlockedEvent</code> 和 <code>ConnectionUnblockedEvent</code> 。这些使您能够提供应用程序逻辑，以对代理程序上的问题做出适当反应，并采取一些纠正措施。</p><p>当应用程序配置有单个 <code>CachingConnectionFactory</code> 时(默认情况下使用 Spring Boot 自动配置)，当代理阻止连接时，应用程序将停止工作。当它被 broker 阻止时，它的任何 Client 都会停止工作。如果我们在同一应用程序中具有生产者和消费者，那么当生产者阻塞连接时，由于代理上不再有资源，并且由于连接被阻塞，消费者也无法释放它们，我们可能最终陷入阻塞。</p><p>为了缓解该问题，建议再使用一个具有相同选项的单独的 <code>CachingConnectionFactory</code> 实例：一个用于生产者，一个用于消费者。对于在消费者线程上执行的事务生产者，不可能使用单独的 <code>CachingConnectionFactory</code> ，因为他们应该重用与消费者事务相关联的<code>Channel</code> 。</p><p>从版本2.0.2开始，<code>RabbitTemplate</code> 具有配置选项，以自动使用第二个连接工厂，除非正在使用事务。发布者连接的 <code>ConnectionNameStrategy</code> 与主要策略相同，在调用方法的结果后附加 <code>.publisher</code> 。</p><p>从1.7.7开始，提供了一个 <code>AmqpResourceNotAvailableException</code> ，例如当<code>SimpleConnection.createChannel()</code> 无法创建<code>Channel</code>时抛出该<code>AmqpResourceNotAvailableException</code> ，因为达到了 <code>channelMax</code> 的限制并且缓存中没有可用的通道。可以在 <code>RetryPolicy</code> 中使用此异常，以在某些回退之后恢复操作。</p><h4 id="（4）配置基础-Client-端连接工厂"><a href="#（4）配置基础-Client-端连接工厂" class="headerlink" title="（4）配置基础 Client 端连接工厂"></a>（4）配置基础 Client 端连接工厂</h4><p><code>CachingConnectionFactory</code> 使用 RabbitClient 端 <code>ConnectionFactory</code> 的实例；在 <code>CachingConnectionFactory</code> 上设置等效属性时，会传递许多配置属性(例如<code>host, port, userName, password, requestedHeartBeat, connectionTimeout</code>)。要设置其他属性(例如<code>clientProperties</code>)，请定义 Rabbit 工厂的实例，并使用<code>CachingConnectionFactory</code>的适当构造函数为其提供引用。如上所述使用命名空间时，请在<code>connection-factory</code>属性中提供对已配置工厂的引用。为方便起见，提供了工厂 bean 来帮助在 Spring 应用程序上下文中配置连接工厂，如下一节所述。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&lt;rabbit:connection-factory</span><br><span class="line">      id=&quot;connectionFactory&quot; connection-factory=&quot;rabbitConnectionFactory&quot;/&gt;</span><br></pre></td></tr></table></figure><ul><li>4.0.x客户端默认启用了自动恢复功能；虽然与此功能兼容，但Spring AMQP有自己的恢复机制，一般不需要客户端的恢复功能。</li><li>建议禁用amqp-client自动恢复功能，以避免在代理可用但连接尚未恢复的情况下得到AutoRecoverConnectionNotCurrentlyOpenException。您可能会注意到这种异常，例如，当RabbitTemplate中配置了RetryTemplate时，甚至在故障转移到集群中的另一个代理时也是如此。</li><li>由于自动恢复连接是在一个计时器上恢复的，因此使用 Spring AMQP 的恢复机制可以更快地恢复连接。从 1.7.1 版开始，Spring AMQP 禁用它，除非您明确创建自己的 RabbitMQ 连接工厂并将其提供给 CachingConnectionFactory。由 RabbitConnectionFactoryBean 创建的 RabbitMQ ConnectionFactory 实例也将默认禁用该选项。</li></ul><h4 id="（5）RabbitConnectionFactoryBean-和配置-SSL"><a href="#（5）RabbitConnectionFactoryBean-和配置-SSL" class="headerlink" title="（5）RabbitConnectionFactoryBean 和配置 SSL"></a>（5）RabbitConnectionFactoryBean 和配置 SSL</h4><p>从1.4开始，提供了一个方便的<code>RabbitConnectionFactoryBean</code>，以使用依赖注入的方式在Client端连接工厂上配置 SSL 属性。</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">rabbit:connection-factory</span> <span class="attr">id</span>=<span class="string">&quot;rabbitConnectionFactory&quot;</span></span></span><br><span class="line"><span class="tag">    <span class="attr">connection-factory</span>=<span class="string">&quot;clientConnectionFactory&quot;</span></span></span><br><span class="line"><span class="tag">    <span class="attr">host</span>=<span class="string">&quot;$&#123;host&#125;&quot;</span></span></span><br><span class="line"><span class="tag">    <span class="attr">port</span>=<span class="string">&quot;$&#123;port&#125;&quot;</span></span></span><br><span class="line"><span class="tag">    <span class="attr">virtual-host</span>=<span class="string">&quot;$&#123;vhost&#125;&quot;</span></span></span><br><span class="line"><span class="tag">    <span class="attr">username</span>=<span class="string">&quot;$&#123;username&#125;&quot;</span> <span class="attr">password</span>=<span class="string">&quot;$&#123;password&#125;&quot;</span> /&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;clientConnectionFactory&quot;</span></span></span><br><span class="line"><span class="tag">        <span class="attr">class</span>=<span class="string">&quot;org.springframework.amqp.rabbit.connection.RabbitConnectionFactoryBean&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;useSSL&quot;</span> <span class="attr">value</span>=<span class="string">&quot;true&quot;</span> /&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;sslPropertiesLocation&quot;</span> <span class="attr">value</span>=<span class="string">&quot;file:/secrets/rabbitSSL.properties&quot;</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br></pre></td></tr></table></figure><p>省略<code>keyStore</code>和<code>trustStore</code>配置以通过 SSL 进行连接而无需证书验证。密钥和信任库配置可以如下提供：</p><p><code>sslPropertiesLocation</code>属性是 Spring <code>Resource</code>，它指向包含以下键的属性文件：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">keyStore=file:/secret/keycert.p12</span><br><span class="line">trustStore=file:/secret/trustStore</span><br><span class="line">keyStore.passPhrase=secret</span><br><span class="line">trustStore.passPhrase=secret</span><br></pre></td></tr></table></figure><p><code>keyStore</code>和<code>truststore</code>是指向 Store 的 Spring <code>Resources</code>。通常，此属性文件将由 os 保护，并且应用程序具有读取访问权限。</p><p>从 Spring AMQP 版本 1.5 开始，可以直接在工厂 bean 上设置这些属性。如果同时提供了离散属性和<code>sslPropertiesLocation</code>，则后者中的属性将覆盖离散值。</p><h4 id="（6）路由连接工厂"><a href="#（6）路由连接工厂" class="headerlink" title="（6）路由连接工厂"></a>（6）路由连接工厂</h4><p>从1.3开始，引入了<code>AbstractRoutingConnectionFactory</code>。这提供了一种机制，可在运行时为多个<code>ConnectionFactories</code>配置 Map 并由某个<code>lookupKey</code>确定目标<code>ConnectionFactory</code>。</p><p>Spring AMQP 提供了<code>SimpleRoutingConnectionFactory</code>，它从<code>SimpleResourceHolder</code>获取当前线程绑定的<code>lookupKey</code>：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;connectionFactory&quot;</span></span></span><br><span class="line"><span class="tag">      <span class="attr">class</span>=<span class="string">&quot;org.springframework.amqp.rabbit.connection.SimpleRoutingConnectionFactory&quot;</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;targetConnectionFactories&quot;</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">map</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">entry</span> <span class="attr">key</span>=<span class="string">&quot;#&#123;connectionFactory1.virtualHost&#125;&quot;</span> <span class="attr">ref</span>=<span class="string">&quot;connectionFactory1&quot;</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">entry</span> <span class="attr">key</span>=<span class="string">&quot;#&#123;connectionFactory2.virtualHost&#125;&quot;</span> <span class="attr">ref</span>=<span class="string">&quot;connectionFactory2&quot;</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">map</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">rabbit:template</span> <span class="attr">id</span>=<span class="string">&quot;template&quot;</span> <span class="attr">connection-factory</span>=<span class="string">&quot;connectionFactory&quot;</span> /&gt;</span></span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyService</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> RabbitTemplate rabbitTemplate;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">service</span><span class="params">(String vHost, String payload)</span> </span>&#123;</span><br><span class="line">        SimpleResourceHolder.bind(rabbitTemplate.getConnectionFactory(), vHost);</span><br><span class="line">        rabbitTemplate.convertAndSend(payload);</span><br><span class="line">        <span class="comment">// 使用后解除绑定资源很重要</span></span><br><span class="line">        SimpleResourceHolder.unbind(rabbitTemplate.getConnectionFactory());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>从版本 1.4 开始，<code>RabbitTemplate</code>支持 SpEL <code>sendConnectionFactorySelectorExpression</code> 和 <code>receiveConnectionFactorySelectorExpression</code> 属性，这些属性在每个 AMQP 协议交互操作(<code>send</code>，<code>sendAndReceive</code>，<code>receive</code>或<code>receiveAndReply</code>)上进行评估，对于提供的<code>AbstractRoutingConnectionFactory</code> 解析为 <code>lookupKey</code> 值。表达式中可以使用 Bean 引用，例如<code>&quot;@vHostResolver.getVHost(#root)&quot;</code>。对于<code>send</code>操作，要发送的消息是根评估对象。对于<code>receive</code>操作，queueName 是根评估对象。</p><p>路由算法为：</p><ul><li>如果 selectors 表达式为null，或者计算为null，或者提供的ConnectionFactory不是<code>AbstractRoutingConnectionFactory</code>的实例，则所有操作都像以前一样，取决于提供的ConnectionFactory实现。</li><li>如果评估结果不是null，但是没有针对该lookupKey的目标ConnectionFactory，并且<code>AbstractRoutingConnectionFactory</code>配置为<code>lenientFallback = true</code>，则会发生相同的情况。</li><li>当然，在<code>AbstractRoutingConnectionFactory</code>的情况下，它会回退到基于<code>determineCurrentLookupKey()</code>的<code>routing</code>实现。但是，如果<code>lenientFallback = false</code>，则抛出<code>IllegalStateException</code>。</li></ul><p>命名空间支持还在<code>&lt;rabbit:template&gt;</code>组件上提供了<code>send-connection-factory-selector-expression</code>和<code>receive-connection-factory-selector-expression</code>属性。</p><p>同样从1.4开始，可以在侦听器容器中配置路由连接工厂。在这种情况下，队列名称列表将用作查找关键字。例如，如果您使用<code>setQueueNames(&quot;foo&quot;, &quot;bar&quot;)</code>配置容器，则查找键将为<code>&quot;[foo,bar]&quot;</code>(无空格)。</p><p>从版本 1.6.9 开始，可以使用侦听器容器上的<code>setLookupKeyQualifier</code>向查找键添加限定符。</p><p>例如，这将允许侦听具有相同名称但在不同虚拟主机中的队列(每个虚拟主机中都有一个连接工厂)。</p><p>例如，在使用查找键限定符<code>foo</code>和侦听队列<code>bar</code>的容器的情况下，用于注册目标连接工厂的查找键将是<code>foo[bar]</code>。</p><h4 id="（7）队列相似性和LocalizedQueueConnectionFactory"><a href="#（7）队列相似性和LocalizedQueueConnectionFactory" class="headerlink" title="（7）队列相似性和LocalizedQueueConnectionFactory"></a>（7）队列相似性和LocalizedQueueConnectionFactory</h4><p>在集群中使用HA队列时，为了获得最佳性能，可能需要连接到主队列所在的物理代理。 <code>CachingConnectionFactory</code>可以配置多个代理地址；这是为了进行故障转移，Client 端将尝试按 Sequences 连接。 </p><p><code>LocalizedQueueConnectionFactory</code>使用 Management 插件提供的 REST API 来确定要控制队列的节点。然后，它创建(或从缓存中检索)<code>CachingConnectionFactory</code>，该<code>CachingConnectionFactory</code>将仅连接到该节点。如果连接失败，那么将确定新的主节点，并且使用者将连接到该主节点。</p><p> <code>LocalizedQueueConnectionFactory</code>配置有默认的连接工厂，以防无法确定队列的物理位置，在这种情况下，它将正常连接到群集。</p><p><code>LocalizedQueueConnectionFactory</code>是<code>RoutingConnectionFactory</code>，而<code>SimpleMessageListenerContainer</code>使用队列名称作为查找关键字。</p><p>注意</p><ul><li>由于使用队列名称进行查找这个原因，只有在将容器配置为侦听单个队列时，才能使用<code>LocalizedQueueConnectionFactory</code>。</li><li>必须在每个节点上启用 RabbitMQManagement 插件。</li><li>此连接工厂用于长期连接，例如<code>SimpleMessageListenerContainer</code>使用的连接。它不适用于短连接，例如用于<code>RabbitTemplate</code>，因为在构建连接之前调用 REST API 会产生开销。同样，对于发布操作，队列是未知的，并且无论如何该消息都会发布给所有集群成员，因此查找节点的逻辑几乎没有价值。</li></ul><p>这是一个示例配置，使用 Spring Boot 的 RabbitProperties 配置工厂：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Autowired</span></span><br><span class="line"><span class="keyword">private</span> RabbitProperties props;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> String[] adminUris = &#123; <span class="string">&quot;http://host1:15672&quot;</span>, <span class="string">&quot;http://host2:15672&quot;</span> &#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> String[] nodes = &#123; <span class="string">&quot;[emailprotected]&quot;</span>, <span class="string">&quot;[emailprotected]&quot;</span> &#125;;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Bean</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> ConnectionFactory <span class="title">defaultConnectionFactory</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    CachingConnectionFactory cf = <span class="keyword">new</span> CachingConnectionFactory();</span><br><span class="line">    cf.setAddresses(<span class="keyword">this</span>.props.getAddresses());</span><br><span class="line">    cf.setUsername(<span class="keyword">this</span>.props.getUsername());</span><br><span class="line">    cf.setPassword(<span class="keyword">this</span>.props.getPassword());</span><br><span class="line">    cf.setVirtualHost(<span class="keyword">this</span>.props.getVirtualHost());</span><br><span class="line">    <span class="keyword">return</span> cf;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Bean</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> ConnectionFactory <span class="title">queueAffinityCF</span><span class="params">(</span></span></span><br><span class="line"><span class="params"><span class="function">        <span class="meta">@Qualifier(&quot;defaultConnectionFactory&quot;)</span> ConnectionFactory defaultCF)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> LocalizedQueueConnectionFactory(defaultCF,</span><br><span class="line">            StringUtils.commaDelimitedListToStringArray(<span class="keyword">this</span>.props.getAddresses()),</span><br><span class="line">            <span class="keyword">this</span>.adminUris, <span class="keyword">this</span>.nodes,</span><br><span class="line">            <span class="keyword">this</span>.props.getVirtualHost(), <span class="keyword">this</span>.props.getUsername(), <span class="keyword">this</span>.props.getPassword(),</span><br><span class="line">            <span class="keyword">false</span>, <span class="keyword">null</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>请注意，前三个参数是<code>addresses</code>，<code>adminUris</code>和<code>nodes</code>的数组。这些是适当的，因为当容器尝试连接到队列时，它确定队列在哪个节点上被控制，并连接到同一阵列位置中的地址。</p><h4 id="（8）发布者确认并return"><a href="#（8）发布者确认并return" class="headerlink" title="（8）发布者确认并return"></a>（8）发布者确认并return</h4><p>通过将<code>CachingConnectionFactory</code>的<code>publisherConfirms</code>和<code>publisherReturns</code>属性分别设置为’true’，可以支持确认和返回的消息。</p><p>设置这些选项后，工厂创建的<code>Channel</code>将被包装在<code>PublisherCallbackChannel</code>中，方便回调。当获得这样的 Channels 时，Client 端可以向<code>Channel</code>注册<code>PublisherCallbackChannel.Listener</code>。 <code>PublisherCallbackChannel</code>实现包含将确认/返回路由到适当的侦听器的逻辑。</p><h4 id="（9）连接和-Channels-监听器"><a href="#（9）连接和-Channels-监听器" class="headerlink" title="（9）连接和 Channels 监听器"></a>（9）连接和 Channels 监听器</h4><p>连接工厂支持注册<code>ConnectionListener</code>和<code>ChannelListener</code>实现。这使您可以接收有关连接和通道相关事件的通知。 (构建连接时，<code>RabbitAdmin</code>使用<code>ConnectionListener</code>来执行声明。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@FunctionalInterface</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">ConnectionListener</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">onCreate</span><span class="params">(Connection connection)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">default</span> <span class="keyword">void</span> <span class="title">onClose</span><span class="params">(Connection connection)</span> </span>&#123;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">default</span> <span class="keyword">void</span> <span class="title">onShutDown</span><span class="params">(ShutdownSignalException signal)</span> </span>&#123;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@FunctionalInterface</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">ChannelListener</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">onCreate</span><span class="params">(Channel channel, <span class="keyword">boolean</span> transactional)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">default</span> <span class="keyword">void</span> <span class="title">onShutDown</span><span class="params">(ShutdownSignalException signal)</span> </span>&#123;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="（10）记录-Channels-关闭事件"><a href="#（10）记录-Channels-关闭事件" class="headerlink" title="（10）记录 Channels 关闭事件"></a>（10）记录 Channels 关闭事件</h4><p>在 1.5 版中引入了一种使用户能够控制日志记录级别的机制。</p><p><code>CachingConnectionFactory</code>使用默认策略记录通道关闭，如下所示：</p><ul><li>正常通道关闭(200 OK)不会被记录。</li><li>如果通道由于被动队列声明失败而关闭，那么它将在调试级别记录。</li><li>如果通道由于<code>basic.consume</code>由于特殊的使用者条件而被拒绝而关闭，则它将以 INFO 级别记录。</li><li>其他所有日志均以 ERROR 级别记录。</li></ul><p>若要修改此行为，请在其<code>closeExceptionLogger</code>属性中将自定义<code>ConditionalExceptionLogger</code>注入到<code>CachingConnectionFactory</code>中。</p><h4 id="（11）运行时缓存属性"><a href="#（11）运行时缓存属性" class="headerlink" title="（11）运行时缓存属性"></a>（11）运行时缓存属性</h4><p>从1.6开始，<code>CachingConnectionFactory</code> 通过<code>getCacheProperties()</code>方法提供了缓存统计信息。这些统计信息可用于调整缓存以在 Producing 对其进行优化。例如，高水位标记可用于确定是否应增加缓存大小。如果等于缓存大小，则可能要考虑进一步增加。</p><p><strong>表 3.1. CacheMode.CHANNEL 的缓存属性</strong></p><table><thead><tr><th>Property</th><th>Meaning</th></tr></thead><tbody><tr><td><code>connectionName</code></td><td><code>ConnectionNameStrategy</code>生成的连接的名称。</td></tr><tr><td><code>channelCacheSize</code></td><td>当前配置的允许空闲的最大通道数。</td></tr><tr><td><code>localPort</code></td><td>连接的本地端口(如果有)。这可用于与 RabbitMQ Admin UI 上的连接/通道关联。</td></tr><tr><td><code>idleChannelsTx</code></td><td>当前空闲(缓存)的事务通道的数量。</td></tr><tr><td><code>idleChannelsNotTx</code></td><td>当前空闲(缓存)的非事务通道的数量。</td></tr><tr><td><code>idleChannelsTxHighWater</code></td><td>已同时空闲(缓存)的最大事务通道数。</td></tr><tr><td><code>idleChannelsNotTxHighWater</code></td><td>非事务通道的最大数量已被同时空闲(缓存)。</td></tr></tbody></table><p><strong>表 3.2. CacheMode.CONNECTION</strong> 的缓存属性</p><table><thead><tr><th>Property</th><th>Meaning</th></tr></thead><tbody><tr><td><code>connectionName:&lt;localPort&gt;</code></td><td><code>ConnectionNameStrategy</code>生成的连接的名称。</td></tr><tr><td><code>openConnections</code></td><td>表示与代理的连接的连接对象的数量。</td></tr><tr><td><code>channelCacheSize</code></td><td>当前配置的允许空闲的最大通道数。</td></tr><tr><td><code>connectionCacheSize</code></td><td>当前配置的允许空闲的最大连接数。</td></tr><tr><td><code>idleConnections</code></td><td>当前空闲的连接数。</td></tr><tr><td><code>idleConnectionsHighWater</code></td><td>并发空闲的最大连接数。</td></tr><tr><td><code>idleChannelsTx:&lt;localPort&gt;</code></td><td>该连接当前空闲(缓存)的事务通道的数量。属性名称的 localPort 部分可用于与 RabbitMQ Admin UI 上的连接/通道关联。</td></tr><tr><td><code>idleChannelsNotTx:&lt;localPort&gt;</code></td><td>该连接当前空闲(缓存)的非事务通道的数量。属性名称的 localPort 部分可用于与 RabbitMQ Admin UI 上的连接/通道关联。</td></tr><tr><td>idleChannelsTxHighWater:</td><td></td></tr><tr><td>&lt;localPort&gt;</td><td>同时空闲(缓存)的最大事务通道数。属性名称的 localPort 部分可用于与 RabbitMQ Admin UI 上的连接/通道关联。</td></tr><tr><td>idleChannelsNotTxHighWater: &lt;localPort&gt;</td><td>已同时空闲(缓存)的非事务通道的最大数量。属性名称的 localPort 部分可用于与 RabbitMQ Admin UI 上的连接/通道关联。</td></tr></tbody></table><p><code>cacheMode</code>属性(还包括<code>CHANNEL</code>或<code>CONNECTION</code>)。</p><p><strong>图 3.1. JVisualVM 示例</strong></p><p><img src="https://www.docs4dev.com/images/spring-amqp/2.1.2.RELEASE/cacheStats.png" alt="cacheStats"></p><h4 id="（12）RabbitMQ-自动连接-拓扑恢复"><a href="#（12）RabbitMQ-自动连接-拓扑恢复" class="headerlink" title="（12）RabbitMQ 自动连接/拓扑恢复"></a>（12）RabbitMQ 自动连接/拓扑恢复</h4><p>从 Spring AMQP 的第一个版本开始，该框架在代理发生故障的情况下提供了自己的连接和通道恢复。另外，<code>RabbitAdmin</code> 将在重新构建连接时重新声明任何基础结构Bean(队列等)。因此，它不依赖<code>amqp-client</code>库现在提供的<a href="https://www.rabbitmq.com/api-guide.html#recovery">Auto Recovery</a>。 </p><p>Spring AMQP 现在使用<code>amqp-client</code>的<code>4.0.x</code>版本，默认情况下启用了自动恢复。如果愿意，Spring AMQP 仍可以使用其自己的恢复机制，在 Client 端中将其禁用(通过将基础<code>RabbitMQ connectionFactory</code>设置为<code>false</code>的<code>automaticRecoveryEnabled</code>属性)。</p><p>但是，该框架与启用的自动恢复完全兼容。这意味着您在代码中创建的所有使用者(可能通过<code>RabbitTemplate.execute()</code>)都可以自动恢复。</p><h3 id="3-4-添加自定义-Client-端连接属性"><a href="#3-4-添加自定义-Client-端连接属性" class="headerlink" title="3.4 添加自定义 Client 端连接属性"></a>3.4 添加自定义 Client 端连接属性</h3><p><code>CachingConnectionFactory</code> 允许访问基础连接工厂，以允许例如设置自定义 Client 端属性：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">connectionFactory.getRabbitConnectionFactory().getClientProperties().put(<span class="string">&quot;foo&quot;</span>, <span class="string">&quot;bar&quot;</span>);</span><br></pre></td></tr></table></figure><p>查看连接时，这些属性会显示在 RabbitMQ Management  UI 中。</p><h3 id="3-5-AmqpTemplate"><a href="#3-5-AmqpTemplate" class="headerlink" title="3.5 AmqpTemplate"></a>3.5 AmqpTemplate</h3><p><code>AmqpTemplate</code>接口定义了用于发送和接收消息的所有基本操作。</p><p>未完待续。</p><h4 id="（1）添加重试功能"><a href="#（1）添加重试功能" class="headerlink" title="（1）添加重试功能"></a>（1）添加重试功能</h4><h4 id="（2）发布是异步的-如何检测成功和失败"><a href="#（2）发布是异步的-如何检测成功和失败" class="headerlink" title="（2）发布是异步的-如何检测成功和失败"></a>（2）发布是异步的-如何检测成功和失败</h4><h4 id="（3）发布者确认并return"><a href="#（3）发布者确认并return" class="headerlink" title="（3）发布者确认并return"></a>（3）发布者确认并return</h4><h4 id="（4）Scoped-Operations"><a href="#（4）Scoped-Operations" class="headerlink" title="（4）Scoped Operations"></a>（4）Scoped Operations</h4><h4 id="（5）Messaging-integration"><a href="#（5）Messaging-integration" class="headerlink" title="（5）Messaging integration"></a>（5）Messaging integration</h4><h4 id="（6）已验证的用户ID"><a href="#（6）已验证的用户ID" class="headerlink" title="（6）已验证的用户ID"></a>（6）已验证的用户ID</h4><h4 id="（7）使用单独的连接"><a href="#（7）使用单独的连接" class="headerlink" title="（7）使用单独的连接"></a>（7）使用单独的连接</h4><h3 id="3-6-发送消息"><a href="#3-6-发送消息" class="headerlink" title="3.6 发送消息"></a>3.6 发送消息</h3><h4 id="（1）Message-Builder"><a href="#（1）Message-Builder" class="headerlink" title="（1）Message Builder"></a>（1）Message Builder</h4><h4 id="（2）Publisher-Returns"><a href="#（2）Publisher-Returns" class="headerlink" title="（2）Publisher Returns"></a>（2）Publisher Returns</h4><h4 id="（3）Batching"><a href="#（3）Batching" class="headerlink" title="（3）Batching"></a>（3）Batching</h4><h3 id="3-7-接收消息"><a href="#3-7-接收消息" class="headerlink" title="3.7 接收消息"></a>3.7 接收消息</h3><h4 id="（1）Polling-Consumer"><a href="#（1）Polling-Consumer" class="headerlink" title="（1）Polling Consumer"></a>（1）Polling Consumer</h4><h4 id="（2）Asynchronous-Consumer"><a href="#（2）Asynchronous-Consumer" class="headerlink" title="（2）Asynchronous Consumer"></a>（2）Asynchronous Consumer</h4><h4 id="（3）Message-Listener"><a href="#（3）Message-Listener" class="headerlink" title="（3）Message Listener"></a>（3）Message Listener</h4><h4 id="（4）MessageListenerAdapter"><a href="#（4）MessageListenerAdapter" class="headerlink" title="（4）MessageListenerAdapter"></a>（4）MessageListenerAdapter</h4><h4 id="（5）Container"><a href="#（5）Container" class="headerlink" title="（5）Container"></a>（5）Container</h4><h4 id="（6）Consumer-Priority"><a href="#（6）Consumer-Priority" class="headerlink" title="（6）Consumer Priority"></a>（6）Consumer Priority</h4><h4 id="（7）auto-delete-Queues"><a href="#（7）auto-delete-Queues" class="headerlink" title="（7）auto-delete Queues"></a>（7）auto-delete Queues</h4><h4 id="（8）Batched-Messages"><a href="#（8）Batched-Messages" class="headerlink" title="（8）Batched Messages"></a>（8）Batched Messages</h4><h4 id="（9）Consumer-Events"><a href="#（9）Consumer-Events" class="headerlink" title="（9）Consumer Events"></a>（9）Consumer Events</h4><h4 id="（10）Consumer-Tags"><a href="#（10）Consumer-Tags" class="headerlink" title="（10）Consumer Tags"></a>（10）Consumer Tags</h4><h4 id="（11）注解驱动的监听器端点"><a href="#（11）注解驱动的监听器端点" class="headerlink" title="（11）注解驱动的监听器端点"></a>（11）注解驱动的监听器端点</h4><h2 id="四-源码剖析"><a href="#四-源码剖析" class="headerlink" title="四. 源码剖析"></a>四. 源码剖析</h2><h3 id="4-1-RabbitMQ消费流程"><a href="#4-1-RabbitMQ消费流程" class="headerlink" title="4.1 RabbitMQ消费流程"></a>4.1 RabbitMQ消费流程</h3><p><img src="https://pic-1258215793.cos.ap-shanghai.myqcloud.com/content/20211001/202110010120.png"></p><h4 id="（1）启动流程"><a href="#（1）启动流程" class="headerlink" title="（1）启动流程"></a>（1）启动流程</h4><ol><li><p>通过<strong>BeanPostProcessor</strong>扫描所有的Bean中存在的 <code>@RabbitListener</code> 注解及相应的Method；</p></li><li><p>由<strong>RabbitListenerContainerFactory</strong>根据配置为每一个 <code>@RabbitListener</code> 注解创建一个<strong>MessageListenerContainer</strong>，持有 <code>@RabbitListener</code> 注解及Method信息；</p></li><li><p>初始化MessageListenerContainer，主要是循环依次创建Consumer（<strong>AsyncMessageProcessingConsumer</strong>），并启动Consumer；</p><p>创建Consumer，过程包括：</p><ul><li>创建<strong>AMQConnection</strong>，仅第一次创建。</li><li>创建<strong>AMQChannel</strong>，每个Consumer都会创建。</li><li>发送消费queue的请求（basic.consume），接收并处理消息。</li></ul></li><li><p>AMQConnection持有连接到Rabbitmq Server的Socket，创建完成后启动MainLoop循环从Socket流中读取Frame，此时流中没有消息，因为Channel还没创建完成；</p></li><li><p>创建AMQChannel（一个AMQConnection中持有多个AMQChannel），并将创建完成的Channel注册到AMQConnection持有的<strong>ConsumerWorkService</strong>，实际就是添加到<strong>WorkPool</strong>的Map里面去，此时Socket流中也没有消息，因为Channel还没有与Queue绑定；<br>创建完成的AMQChannel的代理返回给Consumer，Consumer通过Channel发送消费Queue的请求到Rabbitmq Server（绑定成功），此时还没开始处理消息，但Socket流中已经有消息，并且已经被Connection读取到内存（即 <code>BlockingQueue&lt;Runnable&gt;</code> ）中，并且已经开始向 <code>BlockingQueue&lt;Delivery&gt;</code> 分发；</p></li><li><p>Consumer启动循环，从 <code>BlockingQueue&lt;Delivery&gt;</code> 中取消息，利用MessageListenerContainer中持有的Method反射调用 <code>@RabbitListener</code> 注解方法处理消息。</p></li></ol><h4 id="（2）消费流程"><a href="#（2）消费流程" class="headerlink" title="（2）消费流程"></a>（2）消费流程</h4><ol><li>Rabbitmq Server往Socket流中写入字节。</li><li>AMQConnection启动一个main loop thread来跑MainLoop，不断从Socket流中读取字节转换成Frame对象，这是每个connection唯一的数据来源。</li><li>Consumer启动后，Connection读取到Frame。从basic.deliver开始是消息的内容，每条消息分成三个Frame：<ul><li>第一个是method，basic.deliver代表这是一个消息，后面一定会再跟着两个Frame；</li><li>第二个是message header；</li><li>第三个是message body，body读取之后将三个Frame整合到一起转换成一条完整的deliver命令。</li></ul></li><li>AMQConnection根据读取到的Frame中的type决定要怎么处理这个Frame（ <code>heartbeat(8) do nothing</code> )其它的根据channel编号交给相应的AMQChannel去处理，（编号为0的是特殊的channel，消息相关的用的都是编号非0的channel），消息都会拿着这个编号到<strong>ChannelManager</strong>找对应的ChannelN处理。</li><li>ChannelN经过一系列中间过程由Frame（消息是三个Frame）得到了Runnable，将 <code>&lt;ChannelN, Runnable&gt;</code> put 到 <strong>ConsumerWorkService</strong> 持有的 WorkPool 里面的一个 <code>Map&lt;Channel, BlockingQueue&lt;Runnable&gt;&gt;</code> 里面去。这样这个Runnable就进入了与ChannelN对应的 <code>BlockingQueue&lt;Runnable&gt;</code>（写死的size=1000）里面了。</li><li>execute一个<strong>WorkPoolRunnable</strong>，执行的任务是：<ul><li>从WorkPool中找出一个<strong>ready</strong>状态的ChannelN，把这个ChannelN设为<strong>inProgress</strong>状态；</li><li>从对应的 <code>BlockingQueue&lt;Runnable&gt;</code> 中取最多16个Runnable（写死）在WorkPoolRunnable的线程里依次执行（注意：此处不再另开线程，所以可能会堵塞当前线程，导致这个ChannelN长时间处于inProgress状态），执行完后将当前ChannelN状态改为ready，并在当前线程execute另一个WorkPoolRunnable。</li></ul></li><li><code>BlockingQueue&lt;Runnable&gt;</code> 里面的Runnable执行的逻辑是：构造一个Delivery并put到与ChannelN对应的<strong>AsyncMessageProcessingConsumer</strong>持有的 <code>BlockingQueue&lt;Delivery&gt;</code>（size=prefetchCount可配置）里面去（如果消息处理速度太慢，<code>BlockingQueue&lt;Delivery&gt;</code> 已满，此处会堵塞）。</li><li>每个AsyncMessageProcessingConsumer都有一个独立的线程在循环从 <code>BlockingQueue&lt;Delivery&gt;</code> 一次读取一个Delivery转换成Message反射调用 <code>@RabbitListener</code> 注解方法来处理。</li></ol><p>Frame对象结构如下：</p><p><img src="https://pic-1258215793.cos.ap-shanghai.myqcloud.com/content/20211001/202110010121.png"></p><ul><li><strong>type</strong>：指定当前Frame的类型，如 <code>method(1)</code> 、<code>message header(2)</code> 、<code>message body(3)</code> 、<code>heartbeat(8)</code> 等；</li><li><strong>channel</strong>：channel的编号，从0~n排列，指定当前Frame需要交给哪个channel处理。channel-0为一类，channel-n为一类。<ul><li>channel-0是一个匿名类，用来处理特殊Frame，如connection.start。</li><li>channel-n都是ChannelN类，由ChannelManager类统一管理。</li></ul></li><li><strong>payload</strong>：当前Frame的具体内容。</li></ul><h4 id="（3）ack消费模式"><a href="#（3）ack消费模式" class="headerlink" title="（3）ack消费模式"></a>（3）ack消费模式</h4><p>根据以上对消费过程的分析，将无ack模式与ack模式进行对比。</p><ul><li><p><strong>无ack模式（AcknowledgeMode.NONE）</strong></p><ul><li>Server端行为：<ul><li>Rabbitmq Server默认推送的所有消息都已经消费成功，会不断地向消费端推送消息。</li><li>因为Rabbitmq Server认为推送的消息已被成功消费，所以推送出去的消息不会暂存在server端。</li></ul></li><li>消息丢失的风险：<ul><li>当 <code>BlockingQueue&lt;Runnable&gt;</code> 堆满时（ <code>BlockingQueue&lt;Delivery&gt;</code> 一定会先满），server端推送消息会失败，然后断开Connection。消费端从Socket读取Frame将会抛出SocketException，触发异常处理，shutdown掉Connection和所有的Channel，Channel shutdown后WorkPool中的Channel信息（包括Channel inProgress、channel ready以及Map）全部清空，所以 <code>BlockingQueue&lt;Runnable&gt;</code> 中的数据会全部丢失。</li><li>此外，服务重启时也需对内存中未处理完的消息做必要的处理，以免丢失。而在Rabbitmq Server，Connection断掉后就没有消费者去消费这个queue，因此在server端会看到消息堆积的现象。</li></ul></li></ul></li><li><p><strong>有ack模式（AcknowledgeMode.AUTO，AcknowledgeMode.MANUAL）</strong>：AcknowledgeMode.MANUAL模式需要人为地获取到Channel之后调用方法向Server发送ack（或消费失败时的nack）信息。AcknowledgeMode.AUTO模式下，由spring-rabbit依据消息处理逻辑是否抛出异常自动发送ack（无异常）或nack（异常）到server端。</p><ul><li>server端行为：<ul><li>Rabbitmq Server推送给每个Channel的消息数量有限制，会保证每个Channel没有收到ack的消息数量不会超过prefetchCount。</li><li>Server端会暂存没有收到ack的消息，等消费端ack后才会丢掉；</li><li>如果收到消费端的nack（消费失败的标识）或Connection断开没收到反馈，会将消息放回到原队列头部。</li></ul></li><li>性能：这种模式不会丢消息，但效率较低，因为server端需要等收到消费端的答复之后才会继续推送消息，当然，推送消息和等待答复是异步的，可适当增大prefetchCount提高效率。</li></ul></li></ul><p>注意，有ack的模式下，需要考虑 <code>setDefaultRequeueRejected(false)</code> ，否则当消费消息抛出异常没有catch住时，这条消息会被rabbitmq放回到queue头部，再被推送过来，然后再抛异常再放回…死循环了。设置false的作用是抛异常时不放回，而是直接丢弃，所以可能需要对这条消息做处理，以免丢失。</p><p>对比：</p><ul><li>无ack模式：效率高，存在丢失大量消息的风险。</li><li>有ack模式：效率低，不会丢消息。</li></ul><h3 id="4-2-RabbitTemplate"><a href="#4-2-RabbitTemplate" class="headerlink" title="4.2 RabbitTemplate"></a>4.2 RabbitTemplate</h3><h4 id="（1）接收消息"><a href="#（1）接收消息" class="headerlink" title="（1）接收消息"></a>（1）接收消息</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line">   <span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> Message <span class="title">receive</span><span class="params">(String queueName)</span> </span>&#123;</span><br><span class="line">       <span class="comment">// receiveTimeOut参数为0，直接获取消息，不等待，获取不到返回null；否则会等待一段时间。</span></span><br><span class="line">       <span class="keyword">return</span> <span class="keyword">this</span>.receiveTimeout == <span class="number">0L</span> ? <span class="keyword">this</span>.doReceiveNoWait(queueName) : <span class="keyword">this</span>.receive(queueName, <span class="keyword">this</span>.receiveTimeout);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">   <span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> Message <span class="title">receive</span><span class="params">(<span class="keyword">final</span> String queueName, <span class="keyword">final</span> <span class="keyword">long</span> timeoutMillis)</span> </span>&#123;</span><br><span class="line">       <span class="comment">// 通过execute传入Lambda表达式执行</span></span><br><span class="line">Message message = execute(channel -&gt; &#123;</span><br><span class="line">           <span class="comment">// 初始化Delivery</span></span><br><span class="line">Delivery delivery = consumeDelivery(channel, queueName, timeoutMillis);</span><br><span class="line"><span class="keyword">if</span> (delivery == <span class="keyword">null</span>) &#123;</span><br><span class="line"><span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> &#123;</span><br><span class="line"><span class="keyword">if</span> (isChannelLocallyTransacted(channel)) &#123;</span><br><span class="line">channel.basicAck(delivery.getEnvelope().getDeliveryTag(), <span class="keyword">false</span>);</span><br><span class="line">channel.txCommit();</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span> (isChannelTransacted()) &#123;</span><br><span class="line">ConnectionFactoryUtils.registerDeliveryTag(getConnectionFactory(), channel,</span><br><span class="line">delivery.getEnvelope().getDeliveryTag());</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> &#123;</span><br><span class="line">channel.basicAck(delivery.getEnvelope().getDeliveryTag(), <span class="keyword">false</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> buildMessageFromDelivery(delivery);</span><br><span class="line">&#125;</span><br><span class="line">&#125;);</span><br><span class="line">logReceived(message);</span><br><span class="line"><span class="keyword">return</span> message;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Message是通过调用execute方法得到的：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">   <span class="meta">@Override</span></span><br><span class="line"><span class="keyword">public</span> &lt;T&gt; <span class="function">T <span class="title">execute</span><span class="params">(ChannelCallback&lt;T&gt; action)</span> </span>&#123;</span><br><span class="line"><span class="keyword">return</span> execute(action, getConnectionFactory());</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@SuppressWarnings(&quot;unchecked&quot;)</span></span><br><span class="line"><span class="keyword">private</span> &lt;T&gt; <span class="function">T <span class="title">execute</span><span class="params">(<span class="keyword">final</span> ChannelCallback&lt;T&gt; action, <span class="keyword">final</span> ConnectionFactory connectionFactory)</span> </span>&#123;</span><br><span class="line">       <span class="comment">// 若启用RetryTemplate重试机制</span></span><br><span class="line"><span class="keyword">if</span> (<span class="keyword">this</span>.retryTemplate != <span class="keyword">null</span>) &#123;</span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line"><span class="keyword">return</span> <span class="keyword">this</span>.retryTemplate.execute(</span><br><span class="line">(RetryCallback&lt;T, Exception&gt;) context -&gt; doExecute(action, connectionFactory),</span><br><span class="line">(RecoveryCallback&lt;T&gt;) <span class="keyword">this</span>.recoveryCallback);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line"><span class="keyword">if</span> (e <span class="keyword">instanceof</span> RuntimeException) &#123;</span><br><span class="line"><span class="keyword">throw</span> (RuntimeException) e;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">throw</span> RabbitExceptionTranslator.convertRabbitAccessException(e);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">       <span class="comment">// 否则执行doExecute</span></span><br><span class="line"><span class="keyword">else</span> &#123;</span><br><span class="line"><span class="keyword">return</span> doExecute(action, connectionFactory);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 创建了Connection和Channel，执行action.doInRabbit()方法得到Message，关闭Channel和Connection。当然，这里Connection和Channel的创建和关闭都不一定是真的创建和关闭，与具体的实现有关，比如CachingConnectionFactory，它的实现就是有缓存的</span></span><br><span class="line"><span class="keyword">private</span> &lt;T&gt; <span class="function">T <span class="title">doExecute</span><span class="params">(ChannelCallback&lt;T&gt; action, ConnectionFactory connectionFactory)</span> </span>&#123;</span><br><span class="line">   </span><br><span class="line">       ...</span><br><span class="line">       <span class="keyword">if</span> (channel == <span class="keyword">null</span>) &#123;</span><br><span class="line">           <span class="comment">// 初始化channel和connection</span></span><br><span class="line"><span class="keyword">if</span> (isChannelTransacted()) &#123;</span><br><span class="line">resourceHolder = ConnectionFactoryUtils.</span><br><span class="line">getTransactionalResourceHolder(connectionFactory, <span class="keyword">true</span>, <span class="keyword">this</span>.usePublisherConnection);</span><br><span class="line">channel = resourceHolder.getChannel();</span><br><span class="line"><span class="keyword">if</span> (channel == <span class="keyword">null</span>) &#123;</span><br><span class="line">ConnectionFactoryUtils.releaseResources(resourceHolder);</span><br><span class="line"><span class="keyword">throw</span> <span class="keyword">new</span> IllegalStateException(<span class="string">&quot;Resource holder returned a null channel&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> &#123;</span><br><span class="line">connection = ConnectionFactoryUtils.createConnection(connectionFactory,</span><br><span class="line"><span class="keyword">this</span>.usePublisherConnection); <span class="comment">// NOSONAR - RabbitUtils closes</span></span><br><span class="line"><span class="keyword">if</span> (connection == <span class="keyword">null</span>) &#123;</span><br><span class="line"><span class="keyword">throw</span> <span class="keyword">new</span> IllegalStateException(<span class="string">&quot;Connection factory returned a null connection&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">channel = connection.createChannel(<span class="keyword">false</span>);</span><br><span class="line"><span class="keyword">if</span> (channel == <span class="keyword">null</span>) &#123;</span><br><span class="line"><span class="keyword">throw</span> <span class="keyword">new</span> IllegalStateException(<span class="string">&quot;Connection returned a null channel&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">catch</span> (RuntimeException e) &#123;</span><br><span class="line">RabbitUtils.closeConnection(connection);</span><br><span class="line"><span class="keyword">throw</span> e;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">...</span><br><span class="line"></span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">...</span><br><span class="line">           <span class="comment">// action.doInRabbit()方法的实现逻辑就要再回到上面的receive方法，这里的action就是在那个receive方法传入的一个ChannelCallback的匿名内部实现类。</span></span><br><span class="line"><span class="keyword">return</span> action.doInRabbit(channel);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">catch</span> (Exception ex) &#123;</span><br><span class="line">...</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">finally</span> &#123;</span><br><span class="line"><span class="keyword">if</span> (!invokeScope) &#123;</span><br><span class="line"><span class="keyword">if</span> (resourceHolder != <span class="keyword">null</span>) &#123;</span><br><span class="line">ConnectionFactoryUtils.releaseResources(resourceHolder);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> &#123;</span><br><span class="line">RabbitUtils.closeChannel(channel);</span><br><span class="line">RabbitUtils.closeConnection(connection);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure><p>可以看到最后返回的消息是从Delivery中得到的，那么看下Delivery是怎么来的：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">   <span class="function"><span class="keyword">private</span> Delivery <span class="title">consumeDelivery</span><span class="params">(Channel channel, String queueName, <span class="keyword">long</span> timeoutMillis)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">Delivery delivery = <span class="keyword">null</span>;</span><br><span class="line">RuntimeException exception = <span class="keyword">null</span>;</span><br><span class="line">       <span class="comment">// 异步执行</span></span><br><span class="line">CompletableFuture&lt;Delivery&gt; future = <span class="keyword">new</span> CompletableFuture&lt;&gt;();</span><br><span class="line">DefaultConsumer consumer = createConsumer(queueName, channel, future,</span><br><span class="line">timeoutMillis &lt; <span class="number">0</span> ? DEFAULT_CONSUME_TIMEOUT : timeoutMillis);</span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">           <span class="comment">// 阻塞式的等待返回结果，receive方法中传入的receiveTimeout参数也正是在这里用到的</span></span><br><span class="line"><span class="keyword">if</span> (timeoutMillis &lt; <span class="number">0</span>) &#123;</span><br><span class="line">delivery = future.get();</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> &#123;</span><br><span class="line">delivery = future.get(timeoutMillis, TimeUnit.MILLISECONDS);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">catch</span> (ExecutionException e) &#123;</span><br><span class="line">Throwable cause = e.getCause();</span><br><span class="line"><span class="keyword">this</span>.logger.error(<span class="string">&quot;Consumer failed to receive message: &quot;</span> + consumer, cause);</span><br><span class="line">exception = RabbitExceptionTranslator.convertRabbitAccessException(cause);</span><br><span class="line"><span class="keyword">throw</span> exception;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">Thread.currentThread().interrupt();</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">catch</span> (TimeoutException e) &#123;</span><br><span class="line"><span class="comment">// no result in time</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">finally</span> &#123;</span><br><span class="line"><span class="keyword">if</span> (exception == <span class="keyword">null</span> || !(exception <span class="keyword">instanceof</span> ConsumerCancelledException)) &#123;</span><br><span class="line">cancelConsumerQuietly(channel, consumer);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> delivery;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 异步注册消费者</span></span><br><span class="line">   <span class="function"><span class="keyword">private</span> DefaultConsumer <span class="title">createConsumer</span><span class="params">(<span class="keyword">final</span> String queueName, Channel channel,</span></span></span><br><span class="line"><span class="params"><span class="function">CompletableFuture&lt;Delivery&gt; future, <span class="keyword">long</span> timeoutMillis)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">       <span class="comment">// 之前初始化的channel，控制流量为1</span></span><br><span class="line">channel.basicQos(<span class="number">1</span>);</span><br><span class="line">       <span class="comment">// 等待其它线程完成</span></span><br><span class="line"><span class="keyword">final</span> CountDownLatch latch = <span class="keyword">new</span> CountDownLatch(<span class="number">1</span>);</span><br><span class="line">       <span class="comment">// 初始化消费者</span></span><br><span class="line">DefaultConsumer consumer = <span class="keyword">new</span> TemplateConsumer(channel) &#123;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">handleCancel</span><span class="params">(String consumerTag)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">future.completeExceptionally(<span class="keyword">new</span> ConsumerCancelledException());</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">           <span class="comment">// 执行完basicConsume，消费者注册成功会回调该函数</span></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">handleConsumeOk</span><span class="params">(String consumerTag)</span> </span>&#123;</span><br><span class="line"><span class="keyword">super</span>.handleConsumeOk(consumerTag);</span><br><span class="line">               <span class="comment">// latch-1</span></span><br><span class="line">latch.countDown();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">handleDelivery</span><span class="params">(String consumerTag, Envelope envelope, BasicProperties properties, <span class="keyword">byte</span>[] body)</span></span></span><br><span class="line"><span class="function"><span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">future.complete(<span class="keyword">new</span> Delivery(consumerTag, envelope, properties, body));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;;</span><br><span class="line">       <span class="comment">// 推模式消费消息</span></span><br><span class="line">channel.basicConsume(queueName, consumer);</span><br><span class="line">       <span class="comment">// 如果消费者注册超时</span></span><br><span class="line"><span class="keyword">if</span> (!latch.await(timeoutMillis, TimeUnit.MILLISECONDS)) &#123;</span><br><span class="line">           <span class="comment">// Cache模式关闭代理信道</span></span><br><span class="line"><span class="keyword">if</span> (channel <span class="keyword">instanceof</span> ChannelProxy) &#123;</span><br><span class="line">((ChannelProxy) channel).getTargetChannel().close();</span><br><span class="line">&#125;</span><br><span class="line">           <span class="comment">// 将过程中的异常抛出</span></span><br><span class="line">future.completeExceptionally(</span><br><span class="line"><span class="keyword">new</span> ConsumeOkNotReceivedException(<span class="string">&quot;Blocking receive, consumer failed to consume: &quot;</span> + consumer));</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> consumer;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="4-3-RabbitListener注解"><a href="#4-3-RabbitListener注解" class="headerlink" title="4.3 @RabbitListener注解"></a>4.3 @RabbitListener注解</h3><p>通过注解的方式方便地接收消息：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="meta">@RabbitListener(queues = &quot;test_queue_delay&quot;)</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">listen</span><span class="params">(Message message)</span></span>&#123;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>进入@RabbitListener注解源码，有一段注释说明了这个注解是怎么被处理的，通过注册一个RabbitListenerAnnotationBeanPostProcessor：</p><blockquote><p>Processing of {@code @RabbitListener} annotations is performed by registering a<br>{@link RabbitListenerAnnotationBeanPostProcessor}. This can be done manually or, more<br>conveniently, through the {@code rabbit:annotation-driven/} element or<br>{@link EnableRabbit} annotation.</p></blockquote><p>找到RabbitListenerAnnotationBeanPostProcessor：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">   <span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> Object <span class="title">postProcessAfterInitialization</span><span class="params">(<span class="keyword">final</span> Object bean, <span class="keyword">final</span> String beanName)</span> <span class="keyword">throws</span> BeansException </span>&#123;</span><br><span class="line">Class&lt;?&gt; targetClass = AopUtils.getTargetClass(bean);</span><br><span class="line"><span class="keyword">final</span> TypeMetadata metadata = <span class="keyword">this</span>.typeCache.computeIfAbsent(targetClass, <span class="keyword">this</span>::buildMetadata);</span><br><span class="line">       <span class="comment">// 当bean初始化完成后，在这里会获取到这个bean的类用户自己定义的所有添加了@RabbitListener注解的方法</span></span><br><span class="line"><span class="keyword">for</span> (ListenerMethod lm : metadata.listenerMethods) &#123;</span><br><span class="line"><span class="keyword">for</span> (RabbitListener rabbitListener : lm.annotations) &#123;</span><br><span class="line">               <span class="comment">// 然后调用processAmqpListener()方法对这些方法进行处理，实际上是对方法上的@RabbitListener进行处理，一个方法上可以有多个@RabbitListener，会处理多次</span></span><br><span class="line">processAmqpListener(rabbitListener, lm.method, bean, beanName);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">       <span class="comment">// 类级别注释处理</span></span><br><span class="line"><span class="keyword">if</span> (metadata.handlerMethods.length &gt; <span class="number">0</span>) &#123;</span><br><span class="line">processMultiMethodListeners(metadata.classAnnotations, metadata.handlerMethods, bean, beanName);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> bean;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>获取 <code>@RabbitListener</code> 注解方法的具体过程看 <code>buildMetadata()</code> 方法：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">//在这个方法里面，找出了所有加了@RabbitListener注解的方法</span></span><br><span class="line"><span class="comment">//可以在类上加@RabbitListener注解，然后在方法上加@RabbitHandler注解，如果采用这种方式会processMultiMethodListeners()方法来处理这些方法。</span></span><br><span class="line">   <span class="function"><span class="keyword">private</span> TypeMetadata <span class="title">buildMetadata</span><span class="params">(Class&lt;?&gt; targetClass)</span> </span>&#123;</span><br><span class="line">   <span class="comment">// 先找到类级别注释</span></span><br><span class="line">Collection&lt;RabbitListener&gt; classLevelListeners = findListenerAnnotations(targetClass);</span><br><span class="line"><span class="keyword">final</span> <span class="keyword">boolean</span> hasClassLevelListeners = classLevelListeners.size() &gt; <span class="number">0</span>;</span><br><span class="line"><span class="keyword">final</span> List&lt;ListenerMethod&gt; methods = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line"><span class="keyword">final</span> List&lt;Method&gt; multiMethods = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">ReflectionUtils.doWithMethods(targetClass, method -&gt; &#123;</span><br><span class="line">           <span class="comment">// 找到方法级别注释，记录对应方法</span></span><br><span class="line">Collection&lt;RabbitListener&gt; listenerAnnotations = findListenerAnnotations(method);</span><br><span class="line"><span class="keyword">if</span> (listenerAnnotations.size() &gt; <span class="number">0</span>) &#123;</span><br><span class="line">methods.add(<span class="keyword">new</span> ListenerMethod(method,</span><br><span class="line">listenerAnnotations.toArray(<span class="keyword">new</span> RabbitListener[listenerAnnotations.size()])));</span><br><span class="line">&#125;</span><br><span class="line">           <span class="comment">// 类级别注释找到对应方法</span></span><br><span class="line"><span class="keyword">if</span> (hasClassLevelListeners) &#123;</span><br><span class="line">RabbitHandler rabbitHandler = AnnotationUtils.findAnnotation(method, RabbitHandler.class);</span><br><span class="line"><span class="keyword">if</span> (rabbitHandler != <span class="keyword">null</span>) &#123;</span><br><span class="line">multiMethods.add(method);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;, ReflectionUtils.USER_DECLARED_METHODS);</span><br><span class="line"><span class="keyword">if</span> (methods.isEmpty() &amp;&amp; multiMethods.isEmpty()) &#123;</span><br><span class="line"><span class="keyword">return</span> TypeMetadata.EMPTY;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="keyword">new</span> TypeMetadata(</span><br><span class="line">methods.toArray(<span class="keyword">new</span> ListenerMethod[methods.size()]),</span><br><span class="line">multiMethods.toArray(<span class="keyword">new</span> Method[multiMethods.size()]),</span><br><span class="line">classLevelListeners.toArray(<span class="keyword">new</span> RabbitListener[classLevelListeners.size()]));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里我们只看processAmqpListener()方法，看它是怎么处理上面找到的这些方法的：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">processAmqpListener</span><span class="params">(RabbitListener rabbitListener, Method method, Object bean, String beanName)</span> </span>&#123;</span><br><span class="line">      <span class="comment">// 将每一个加@RabbitListener注解的方法构造一个MethodRabbitListenerEndpoint，然后调用processListener()</span></span><br><span class="line">      Method methodToUse = checkProxy(method, bean);</span><br><span class="line">      MethodRabbitListenerEndpoint endpoint = <span class="keyword">new</span> MethodRabbitListenerEndpoint();</span><br><span class="line">      endpoint.setMethod(methodToUse);</span><br><span class="line">      processListener(endpoint, rabbitListener, bean, methodToUse, beanName);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">   <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">processListener</span><span class="params">(MethodRabbitListenerEndpoint endpoint, RabbitListener rabbitListener, Object bean,</span></span></span><br><span class="line"><span class="params"><span class="function">    Object adminTarget, String beanName)</span> </span>&#123;</span><br><span class="line">   </span><br><span class="line">   <span class="comment">// 省略的部分是读取@RabbitListener注解中的值，设置到endpoint中去</span></span><br><span class="line">...</span><br><span class="line"></span><br><span class="line">       <span class="comment">// endpoint的属性都设置完了之后，获取我们配置的RabbitListenerContainerFactory bean，然后调用RabbitListenerEndpointRegistrar类的registerEndpoint()方法</span></span><br><span class="line">RabbitListenerContainerFactory&lt;?&gt; factory = <span class="keyword">null</span>;</span><br><span class="line">String containerFactoryBeanName = resolve(rabbitListener.containerFactory());</span><br><span class="line"><span class="keyword">if</span> (StringUtils.hasText(containerFactoryBeanName)) &#123;</span><br><span class="line">Assert.state(<span class="keyword">this</span>.beanFactory != <span class="keyword">null</span>, <span class="string">&quot;BeanFactory must be set to obtain container factory by bean name&quot;</span>);</span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">factory = <span class="keyword">this</span>.beanFactory.getBean(containerFactoryBeanName, RabbitListenerContainerFactory.class);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">catch</span> (NoSuchBeanDefinitionException ex) &#123;</span><br><span class="line"><span class="keyword">throw</span> <span class="keyword">new</span> BeanInitializationException(<span class="string">&quot;Could not register rabbit listener endpoint on [&quot;</span> +</span><br><span class="line">adminTarget + <span class="string">&quot;] for bean &quot;</span> + beanName + <span class="string">&quot;, no &quot;</span> + RabbitListenerContainerFactory.class.getSimpleName() + <span class="string">&quot; with id &#x27;&quot;</span> +</span><br><span class="line">containerFactoryBeanName + <span class="string">&quot;&#x27; was found in the application context&quot;</span>, ex);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">this</span>.registrar.registerEndpoint(endpoint, factory);</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">registerEndpoint</span><span class="params">(RabbitListenerEndpoint endpoint, RabbitListenerContainerFactory&lt;?&gt; factory)</span> </span>&#123;</span><br><span class="line">Assert.notNull(endpoint, <span class="string">&quot;Endpoint must be set&quot;</span>);</span><br><span class="line">Assert.hasText(endpoint.getId(), <span class="string">&quot;Endpoint id must be set&quot;</span>);</span><br><span class="line"><span class="comment">// Factory may be null, we defer the resolution right before actually creating the container</span></span><br><span class="line">AmqpListenerEndpointDescriptor descriptor = <span class="keyword">new</span> AmqpListenerEndpointDescriptor(endpoint, factory);</span><br><span class="line"><span class="keyword">synchronized</span> (<span class="keyword">this</span>.endpointDescriptors) &#123;</span><br><span class="line">           <span class="comment">// 根据startImmediately看是否需要立刻注册endpoint，或者先将其添加到一个List，稍后统一注册</span></span><br><span class="line"><span class="keyword">if</span> (<span class="keyword">this</span>.startImmediately) &#123; <span class="comment">// Register and start immediately</span></span><br><span class="line"><span class="keyword">this</span>.endpointRegistry.registerListenerContainer(descriptor.endpoint,</span><br><span class="line">resolveContainerFactory(descriptor), <span class="keyword">true</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> &#123;</span><br><span class="line"><span class="keyword">this</span>.endpointDescriptors.add(descriptor);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>对于统一注册的实现，RabbitListenerAnnotationBeanPostProcessor类除了实现BeanPostProcessor以外，还实现了SmartInitializingSingleton接口，所以当RabbitListenerAnnotationBeanPostProcessor这个bean实例化完成之后会调用它的 <code>afterSingletonsInstantiated()</code> 方法：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">   <span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">afterSingletonsInstantiated</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">...</span><br><span class="line"></span><br><span class="line"><span class="comment">// Actually register all listeners</span></span><br><span class="line">       <span class="comment">// 因为之前已经将所有的endpoint添加到了RabbitListenerEndpointRegistrar类中的一个List中了，所以这里调用RabbitListenerEndpointRegistrar类的afterPropertiesSet()方法进行统一注册</span></span><br><span class="line"><span class="keyword">this</span>.registrar.afterPropertiesSet();</span><br><span class="line"></span><br><span class="line">...</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">   <span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">afterPropertiesSet</span><span class="params">()</span> </span>&#123;</span><br><span class="line">       <span class="comment">// 不管是单独注册endpoint还是统一注册，调用的是同样的方法registerAllEndpoints()</span></span><br><span class="line">registerAllEndpoints();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">   <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">registerAllEndpoints</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="keyword">synchronized</span> (<span class="keyword">this</span>.endpointDescriptors) &#123;</span><br><span class="line">           <span class="comment">// for循环，一个一个注册</span></span><br><span class="line"><span class="keyword">for</span> (AmqpListenerEndpointDescriptor descriptor : <span class="keyword">this</span>.endpointDescriptors) &#123;</span><br><span class="line"><span class="keyword">this</span>.endpointRegistry.registerListenerContainer(</span><br><span class="line">descriptor.endpoint, resolveContainerFactory(descriptor));</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">this</span>.startImmediately = <span class="keyword">true</span>;  <span class="comment">// trigger immediate startup</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>跟踪 <code>registerListenerContainer()</code> 方法查看具体是怎么注册的，直到进入下面这个方法：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">registerListenerContainer</span><span class="params">(RabbitListenerEndpoint endpoint, RabbitListenerContainerFactory&lt;?&gt; factory,</span></span></span><br><span class="line"><span class="params"><span class="function">                                      <span class="keyword">boolean</span> startImmediately)</span> </span>&#123;</span><br><span class="line">Assert.notNull(endpoint, <span class="string">&quot;Endpoint must not be null&quot;</span>);</span><br><span class="line">Assert.notNull(factory, <span class="string">&quot;Factory must not be null&quot;</span>);</span><br><span class="line"></span><br><span class="line">String id = endpoint.getId();</span><br><span class="line">Assert.hasText(id, <span class="string">&quot;Endpoint id must not be empty&quot;</span>);</span><br><span class="line"><span class="keyword">synchronized</span> (<span class="keyword">this</span>.listenerContainers) &#123;</span><br><span class="line">Assert.state(!<span class="keyword">this</span>.listenerContainers.containsKey(id),</span><br><span class="line"><span class="string">&quot;Another endpoint is already registered with id &#x27;&quot;</span> + id + <span class="string">&quot;&#x27;&quot;</span>);</span><br><span class="line">MessageListenerContainer container = createListenerContainer(endpoint, factory);</span><br><span class="line"><span class="keyword">this</span>.listenerContainers.put(id, container);</span><br><span class="line"><span class="keyword">if</span> (StringUtils.hasText(endpoint.getGroup()) &amp;&amp; <span class="keyword">this</span>.applicationContext != <span class="keyword">null</span>) &#123;</span><br><span class="line">List&lt;MessageListenerContainer&gt; containerGroup;</span><br><span class="line"><span class="keyword">if</span> (<span class="keyword">this</span>.applicationContext.containsBean(endpoint.getGroup())) &#123;</span><br><span class="line">containerGroup = <span class="keyword">this</span>.applicationContext.getBean(endpoint.getGroup(), List.class);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> &#123;</span><br><span class="line">containerGroup = <span class="keyword">new</span> ArrayList&lt;MessageListenerContainer&gt;();</span><br><span class="line"><span class="keyword">this</span>.applicationContext.getBeanFactory().registerSingleton(endpoint.getGroup(), containerGroup);</span><br><span class="line">&#125;</span><br><span class="line">containerGroup.add(container);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> (startImmediately) &#123;</span><br><span class="line">startIfNecessary(container);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可见，注册endpoint，实际上就是RabbitListenerContainerFactory将每一个endpoint都创建成MessageListenerContainer（具体创建过程，由RabbitListenerContainerFactory类自己去完成），然后根据startImmediately参数判断是否调用startIfNecessary()方法立即启动MessageListenerContainer。</p><p>实际接收消息是由这个MessageListenerContainer来做的，而MessageListenerContainer接口中有一个接口方法来设置MessageListener：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">   <span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Setup the message listener to use. Throws an &#123;<span class="doctag">@link</span> IllegalArgumentException&#125;</span></span><br><span class="line"><span class="comment"> * if that message listener type is not supported.</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> messageListener the &#123;<span class="doctag">@code</span> object&#125; to wrapped to the &#123;<span class="doctag">@code</span> MessageListener&#125;.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">setupMessageListener</span><span class="params">(Object messageListener)</span></span>;</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure><p>MessageListener将会调用我们加了@RabbitListener注解的方法处理消息：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Listener interface to receive asynchronous delivery of Amqp Messages.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> Mark Pollack</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> Gary Russell</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@FunctionalInterface</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">MessageListener</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">onMessage</span><span class="params">(Message message)</span></span>;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure><p>或者是ChannelAwareMessageListener接口类来调用我们的方法：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * A message listener that is aware of the Channel on which the message was received.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> Mark Pollack</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> Gary Russell</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@FunctionalInterface</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">ChannelAwareMessageListener</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Callback for processing a received Rabbit message.</span></span><br><span class="line"><span class="comment"> * &lt;p&gt;Implementors are supposed to process the given Message,</span></span><br><span class="line"><span class="comment"> * typically sending reply messages through the given Session.</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> message the received AMQP message (never &lt;code&gt;null&lt;/code&gt;)</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> channel the underlying Rabbit Channel (never &lt;code&gt;null&lt;/code&gt;)</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@throws</span> Exception Any.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">onMessage</span><span class="params">(Message message, Channel channel)</span> <span class="keyword">throws</span> Exception</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>这样接收并处理消息的所有工作就完成了。</p><p>如果不立即启动MessageListenerContainer，RabbitListenerEndpointRegistry也实现了SmartLifecycle接口，所以在spring context refresh的最后一步会去调用start()方法：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">   <span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">start</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="keyword">for</span> (MessageListenerContainer listenerContainer : getListenerContainers()) &#123;</span><br><span class="line">startIfNecessary(listenerContainer);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>可以看到在这里统一启动了所有的MessageListenerContainer：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">   <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">startIfNecessary</span><span class="params">(MessageListenerContainer listenerContainer)</span> </span>&#123;</span><br><span class="line"><span class="keyword">if</span> (<span class="keyword">this</span>.contextRefreshed || listenerContainer.isAutoStartup()) &#123;</span><br><span class="line">listenerContainer.start();</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>所谓启动MessageListenerContainer其实就是调用MessageListenerContainer的start()方法。这也是SmartLifecycle的一个接口方法，它的实现必须保证调用了这个start()方法之后MessageListenerContainer将能够接受到消息。</p><p>所以对@RabbitListener注解的整个处理流程就是这样。</p><p>总结一下整个实现流程：</p><ul><li>@RabbitListener注解的方法所在的类首先是一个bean，因此，实现BeanPostProcessor接口对每一个初始化完成的bean进行处理。</li><li>遍历bean中由用户自己定义的所有的方法，找出其中添加了@RabbitListener注解的方法（也可以是@RabbitHandler注解，上面已经讲了，不再赘述）。</li><li>读取上面找出的所有方法上@RabbitListener注解中的值，并为每一个方法创建一个RabbitListenerEndpoint，保存在RabbitListenerEndpointRegistrar类中。</li><li>在所有的bean都初始化完成，即所有@RabbitListener注解的方法都创建了endpoint之后，由我们配置的RabbitListenerContainerFactory将每个endpoint创建MessageListenerContainer。</li><li>最后启动上面创建的MessageListenerContainer。</li><li>至此，全部完成，MessageListenerContainer启动后将能够接受到消息，再将消息交给它的MessageListener处理消息。</li></ul><p>下面还剩下几件事情才能真正实现上面的步骤：</p><ul><li>RabbitListenerContainerFactory只是个接口，它不会自己创建</li><li>MessageListenerContainer，所以需要一个RabbitListenerContainerFactory实现类，它必须能创建MessageListenerContainer。<br>MessageListenerContainer也只是一个接口，它不会自己接收消息，所以需要一个MessageListenerContainer实现类，它必须做到在启动后能够接收消息，同时它必须能设置MessageListener，用以处理消息。</li><li>MessageListener（或ChannelAwareMessageListener）也只是一个接口，所以还需要一个MessageListener实现类，它必须能调用我们加了@RabbitListener注解的方法。</li></ul><h3 id="4-5-SimpleMessageListenerContainer"><a href="#4-5-SimpleMessageListenerContainer" class="headerlink" title="4.5 SimpleMessageListenerContainer"></a>4.5 SimpleMessageListenerContainer</h3><h4 id="（1）概述"><a href="#（1）概述" class="headerlink" title="（1）概述"></a>（1）概述</h4><p><code>SimpleMessageListenerContainer</code>是<code>spring</code>在<code>rabbitmq</code>原生<code>api</code>基础上封装实现的一个消费工具类，该类非常强大，可以实现：</p><ul><li>监听单个或多个队列</li><li>自动启动</li><li>自动声明</li><li>还支持动态配置，如动态添加监听队列、动态调整并发数等等。</li></ul><p>基本上对<code>RabbitMQ</code>消费场景这个类都能满足。如<code>@RabbitListener</code>、cloud-stream中<code>StreamListener</code>中底层实现都是基于该类，所以理解<code>SimpleMessageListenerContainer</code>原理对理解<code>spring rabbitmq</code>中消费模型非常关键。</p><h4 id="（2）基本使用"><a href="#（2）基本使用" class="headerlink" title="（2）基本使用"></a>（2）基本使用</h4><p>运行时添加/移除监听队列：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 字符串集合动态添加到queueNames中</span></span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">addQueueNames</span><span class="params">(String... queueName)</span> </span>&#123;</span><br><span class="line">       <span class="keyword">super</span>.addQueueNames(queueName);</span><br><span class="line">       <span class="keyword">this</span>.queuesChanged();</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">removeQueueNames</span><span class="params">(String... queueName)</span> </span>&#123;</span><br><span class="line">       <span class="keyword">if</span> (<span class="keyword">super</span>.removeQueueNames(queueName)) &#123;</span><br><span class="line">           <span class="keyword">this</span>.queuesChanged();</span><br><span class="line">           <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">       &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">           <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">       &#125;</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="keyword">private</span> <span class="keyword">final</span> Object consumersMonitor = <span class="keyword">new</span> Object();</span><br><span class="line">   <span class="keyword">private</span> Set&lt;BlockingQueueConsumer&gt; consumers;</span><br><span class="line"></span><br><span class="line">   <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">queuesChanged</span><span class="params">()</span> </span>&#123;</span><br><span class="line">       <span class="comment">// 获取对象锁</span></span><br><span class="line">       <span class="keyword">synchronized</span>(<span class="keyword">this</span>.consumersMonitor) &#123;</span><br><span class="line">           <span class="keyword">if</span> (<span class="keyword">this</span>.consumers != <span class="keyword">null</span>) &#123;</span><br><span class="line">               <span class="keyword">int</span> count = <span class="number">0</span>;</span><br><span class="line">               <span class="comment">// 遍历消费者集合，依次取消订阅并移出集合</span></span><br><span class="line">               <span class="keyword">for</span>(Iterator consumerIterator = <span class="keyword">this</span>.consumers.iterator(); consumerIterator.hasNext(); ++count) &#123;</span><br><span class="line">                   BlockingQueueConsumer consumer = (BlockingQueueConsumer)consumerIterator.next();</span><br><span class="line">                   <span class="keyword">if</span> (<span class="keyword">this</span>.logger.isDebugEnabled()) &#123;</span><br><span class="line">                       <span class="keyword">this</span>.logger.debug(<span class="string">&quot;Queues changed; stopping consumer: &quot;</span> + consumer);</span><br><span class="line">                   &#125;</span><br><span class="line"></span><br><span class="line">                   <span class="comment">// 取消订阅</span></span><br><span class="line">                   consumer.basicCancel(<span class="keyword">true</span>);</span><br><span class="line">                   consumerIterator.remove();</span><br><span class="line">               &#125;</span><br><span class="line"></span><br><span class="line">               <span class="comment">// 再重新创建消费者</span></span><br><span class="line">               <span class="keyword">this</span>.addAndStartConsumers(count);</span><br><span class="line">           &#125;</span><br><span class="line"></span><br><span class="line">       &#125;</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">addAndStartConsumers</span><span class="params">(<span class="keyword">int</span> delta)</span> </span>&#123;</span><br><span class="line">       <span class="comment">// 获取对象锁</span></span><br><span class="line">       <span class="keyword">synchronized</span>(<span class="keyword">this</span>.consumersMonitor) &#123;</span><br><span class="line">           <span class="keyword">if</span> (<span class="keyword">this</span>.consumers != <span class="keyword">null</span>) &#123;</span><br><span class="line">               <span class="comment">// 创建指定数目的消费者</span></span><br><span class="line">               <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; delta &amp;&amp; (<span class="keyword">this</span>.maxConcurrentConsumers == <span class="keyword">null</span> || <span class="keyword">this</span>.consumers.size() &lt; <span class="keyword">this</span>.maxConcurrentConsumers); ++i) &#123;</span><br><span class="line">                   <span class="comment">// 使用该类默认值/创建模板时指定的参数来构建消费者</span></span><br><span class="line">                   BlockingQueueConsumer consumer = <span class="keyword">this</span>.createBlockingQueueConsumer();</span><br><span class="line">                   <span class="comment">// 加回集合</span></span><br><span class="line">                   <span class="keyword">this</span>.consumers.add(consumer);</span><br><span class="line">                   <span class="comment">// 异步启动消费者</span></span><br><span class="line">                   SimpleMessageListenerContainer.AsyncMessageProcessingConsumer processor = <span class="keyword">new</span> SimpleMessageListenerContainer.AsyncMessageProcessingConsumer(consumer);</span><br><span class="line">                   <span class="keyword">if</span> (<span class="keyword">this</span>.logger.isDebugEnabled()) &#123;</span><br><span class="line">                       <span class="keyword">this</span>.logger.debug(<span class="string">&quot;Starting a new consumer: &quot;</span> + consumer);</span><br><span class="line">                   &#125;</span><br><span class="line"></span><br><span class="line">                   <span class="keyword">this</span>.getTaskExecutor().execute(processor);</span><br><span class="line">                   <span class="keyword">if</span> (<span class="keyword">this</span>.getApplicationEventPublisher() != <span class="keyword">null</span>) &#123;</span><br><span class="line">                       <span class="comment">// 发布事件</span></span><br><span class="line">                       <span class="keyword">this</span>.getApplicationEventPublisher().publishEvent(<span class="keyword">new</span> AsyncConsumerStartedEvent(<span class="keyword">this</span>, consumer));</span><br><span class="line">                   &#125;</span><br><span class="line"></span><br><span class="line">                   <span class="keyword">try</span> &#123;</span><br><span class="line">                       <span class="comment">// 若启动流程有异常（getStartupException阻塞等待结果），则从集合移出消费者，并终止消费者</span></span><br><span class="line">                       FatalListenerStartupException startupException = processor.getStartupException();</span><br><span class="line">                       <span class="keyword">if</span> (startupException != <span class="keyword">null</span>) &#123;</span><br><span class="line">                           <span class="comment">// 多余的一行？</span></span><br><span class="line">                           <span class="keyword">this</span>.consumers.remove(consumer);</span><br><span class="line">                           <span class="keyword">throw</span> <span class="keyword">new</span> AmqpIllegalStateException(<span class="string">&quot;Fatal exception on listener startup&quot;</span>, startupException);</span><br><span class="line">                       &#125;</span><br><span class="line">                   &#125; <span class="keyword">catch</span> (InterruptedException var8) &#123;</span><br><span class="line">                       Thread.currentThread().interrupt();</span><br><span class="line">                   &#125; <span class="keyword">catch</span> (Exception var9) &#123;</span><br><span class="line">                       consumer.stop();</span><br><span class="line">                       <span class="keyword">this</span>.logger.error(<span class="string">&quot;Error starting new consumer&quot;</span>, var9);</span><br><span class="line">                       <span class="keyword">this</span>.cancellationLock.release(consumer);</span><br><span class="line">                       <span class="keyword">this</span>.consumers.remove(consumer);</span><br><span class="line">                   &#125;</span><br><span class="line">               &#125;</span><br><span class="line">           &#125;</span><br><span class="line"></span><br><span class="line">       &#125;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure><p>后置处理器 <code>setAfterReceivePostProcessors()</code> ：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 后置处理器，接收到的消息都添加了Header请求头</span></span><br><span class="line">container.setAfterReceivePostProcessors(message -&gt; &#123;</span><br><span class="line">       message.getMessageProperties().getHeaders().put(<span class="string">&quot;desc&quot;</span>, <span class="number">10</span>); </span><br><span class="line">       <span class="keyword">return</span> message;</span><br><span class="line">   &#125;);</span><br><span class="line"></span><br><span class="line">container.setMessageListener((MessageListener) message -&gt; &#123; </span><br><span class="line">       System.out.println(<span class="string">&quot;====接收到消息=====&quot;</span>);</span><br><span class="line">       System.out.println(message.getMessageProperties()); </span><br><span class="line">       System.out.println(<span class="keyword">new</span> String(message.getBody()));</span><br><span class="line">   &#125;);</span><br></pre></td></tr></table></figure><p>设置消费者的tag和Arguments：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 设置消费者的Consumer tag</span></span><br><span class="line">container.setConsumerTagStrategy(queue -&gt; <span class="string">&quot;order_queue_&quot;</span>+(++count));</span><br><span class="line"><span class="comment">// 设置消费者的Arguments</span></span><br><span class="line">Map args = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line">args.put(<span class="string">&quot;module&quot;</span>,<span class="string">&quot;订单模块&quot;</span>);</span><br><span class="line">args.put(<span class="string">&quot;fun&quot;</span>,<span class="string">&quot;发送消息&quot;</span>);</span><br><span class="line">container.setConsumerArguments(args);</span><br></pre></td></tr></table></figure><p><img src="https://res-static.hc-cdn.cn/fms/img/e30c505f6dfcc7704eb104d6169c202c1612517532882" alt="【RabbitMQ分析】01 SimpleMessageListenerContainer原理分析1"></p><p>设置并发消费者：</p><ul><li>setConcurrentConsumers设置多个并发消费者一起消费，并支持运行时动态修改。</li><li>setMaxConcurrentConsumers设置最多的并发消费者。</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Bean</span> </span><br><span class="line"><span class="function"><span class="keyword">public</span> SimpleMessageListenerContainer <span class="title">messageListenerContainer</span><span class="params">(ConnectionFactory connectionFactory)</span></span>&#123; </span><br><span class="line">       SimpleMessageListenerContainer container = <span class="keyword">new</span> SimpleMessageListenerContainer();</span><br><span class="line">       container.setConnectionFactory(connectionFactory);</span><br><span class="line">       container.setQueueNames(<span class="string">&quot;xxx&quot;</span>);</span><br><span class="line">       container.setConcurrentConsumers(<span class="number">5</span>); </span><br><span class="line">       container.setMaxConcurrentConsumers(<span class="number">10</span>);</span><br><span class="line">       container.setMessageListener((MessageListener) message -&gt; &#123;</span><br><span class="line">           System.out.println(<span class="string">&quot;====接收到消息=====&quot;</span>);</span><br><span class="line">           System.out.println(message.getMessageProperties()); </span><br><span class="line">           System.out.println(<span class="keyword">new</span> String(message.getBody())); </span><br><span class="line">       &#125;); </span><br><span class="line">       <span class="keyword">return</span> container; </span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure><h4 id="（3）核心原理"><a href="#（3）核心原理" class="headerlink" title="（3）核心原理"></a>（3）核心原理</h4><p>API结构：</p><p><code>SimpleMessageListenerContainer</code>类结构如下：</p><p><img src="https://res-static.hc-cdn.cn/fms/img/7f0590fab310e55f8ae8dc0d28d7fd161612517532882" alt="【RabbitMQ分析】01 SimpleMessageListenerContainer原理分析2"></p><p>方法入口：</p><p><code>SimpleMessageListenerContainer</code> 类启动的入口是 <code>start()</code> 方法，该方法位于父类 <code>AbstractMessageListenerContainer</code> 中：</p><h5 id="AbstractMessageListenerContainer-start"><a href="#AbstractMessageListenerContainer-start" class="headerlink" title="AbstractMessageListenerContainer#start"></a>AbstractMessageListenerContainer#start</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">start</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 已启动，则直接退出</span></span><br><span class="line">    <span class="keyword">if</span> (!<span class="keyword">this</span>.isRunning()) &#123;</span><br><span class="line">        <span class="comment">// initialized未执行初始化，则执行afterPropertiesSet()方法进行初始化，执行完成后initialized设置成true</span></span><br><span class="line">        <span class="keyword">if</span> (!<span class="keyword">this</span>.initialized) &#123;</span><br><span class="line">            <span class="keyword">synchronized</span>(<span class="keyword">this</span>.lifecycleMonitor) &#123;</span><br><span class="line">                <span class="keyword">if</span> (!<span class="keyword">this</span>.initialized) &#123;</span><br><span class="line">                    <span class="keyword">this</span>.afterPropertiesSet();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">if</span> (<span class="keyword">this</span>.logger.isDebugEnabled()) &#123;</span><br><span class="line">                <span class="keyword">this</span>.logger.debug(<span class="string">&quot;Starting Rabbit listener container.&quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 验证RabbitAdmin，mismatchedQueuesFatal=true时，spring context中RabbitAdmin数量不能大于1</span></span><br><span class="line">            <span class="keyword">this</span>.configureAdminIfNeeded();</span><br><span class="line">            <span class="comment">// 执行RabbitAdmin#initialize方法，spring context中注入的exchanges, queues and bindings执行声明式创建</span></span><br><span class="line">            <span class="keyword">this</span>.checkMismatchedQueues();</span><br><span class="line">            <span class="comment">// 启动核心</span></span><br><span class="line">            <span class="keyword">this</span>.doStart();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception var3) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">this</span>.convertRabbitAccessException(var3);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="SimpleMessageListenerContainer-doStart"><a href="#SimpleMessageListenerContainer-doStart" class="headerlink" title="SimpleMessageListenerContainer#doStart"></a>SimpleMessageListenerContainer#doStart</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 父类</span></span><br><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">doStart</span><span class="params">()</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">       <span class="keyword">synchronized</span>(<span class="keyword">this</span>.lifecycleMonitor) &#123;</span><br><span class="line">           <span class="keyword">this</span>.active = <span class="keyword">true</span>;</span><br><span class="line">           <span class="keyword">this</span>.running = <span class="keyword">true</span>;</span><br><span class="line">           <span class="keyword">this</span>.lifecycleMonitor.notifyAll();</span><br><span class="line">       &#125;</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 子类</span></span><br><span class="line">   <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">doStart</span><span class="params">()</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">       <span class="comment">// 如果MessageListener是ListenerContainerAware，则进行expectedQueueNames校验</span></span><br><span class="line">       <span class="keyword">if</span> (<span class="keyword">this</span>.getMessageListener() <span class="keyword">instanceof</span> ListenerContainerAware) &#123;</span><br><span class="line">           Collection&lt;String&gt; expectedQueueNames = ((ListenerContainerAware)<span class="keyword">this</span>.getMessageListener()).expectedQueueNames();</span><br><span class="line">           <span class="keyword">if</span> (expectedQueueNames != <span class="keyword">null</span>) &#123;</span><br><span class="line">               String[] queueNames = <span class="keyword">this</span>.getQueueNames();</span><br><span class="line">               Assert.state(expectedQueueNames.size() == queueNames.length, <span class="string">&quot;Listener expects us to be listening on &#x27;&quot;</span> + expectedQueueNames + <span class="string">&quot;&#x27;; our queues: &quot;</span> + Arrays.asList(queueNames));</span><br><span class="line">               <span class="keyword">boolean</span> found = <span class="keyword">false</span>;</span><br><span class="line">               String[] var4 = queueNames;</span><br><span class="line">               <span class="keyword">int</span> var5 = queueNames.length;</span><br><span class="line"></span><br><span class="line">               <span class="keyword">for</span>(<span class="keyword">int</span> var6 = <span class="number">0</span>; var6 &lt; var5; ++var6) &#123;</span><br><span class="line">                   String queueName = var4[var6];</span><br><span class="line">                   <span class="keyword">if</span> (!expectedQueueNames.contains(queueName)) &#123;</span><br><span class="line">                       found = <span class="keyword">false</span>;</span><br><span class="line">                       <span class="keyword">break</span>;</span><br><span class="line">                   &#125;</span><br><span class="line"></span><br><span class="line">                   found = <span class="keyword">true</span>;</span><br><span class="line">               &#125;</span><br><span class="line"></span><br><span class="line">               Assert.state(found, () -&gt; &#123;</span><br><span class="line">                   <span class="keyword">return</span> <span class="string">&quot;Listener expects us to be listening on &#x27;&quot;</span> + expectedQueueNames + <span class="string">&quot;&#x27;; our queues: &quot;</span> + Arrays.asList(queueNames);</span><br><span class="line">               &#125;);</span><br><span class="line">           &#125;</span><br><span class="line">       &#125;</span><br><span class="line"></span><br><span class="line">       <span class="comment">// 调用父类doStart()方法，主要是active和running都设置成true</span></span><br><span class="line">       <span class="keyword">super</span>.doStart();</span><br><span class="line">       <span class="keyword">synchronized</span>(<span class="keyword">this</span>.consumersMonitor) &#123;</span><br><span class="line">           <span class="keyword">if</span> (<span class="keyword">this</span>.consumers != <span class="keyword">null</span>) &#123;</span><br><span class="line">               <span class="keyword">throw</span> <span class="keyword">new</span> IllegalStateException(<span class="string">&quot;A stopped container should not have consumers&quot;</span>);</span><br><span class="line">           &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">               <span class="comment">// 创建BlockingQueueConsumer类型consumer，每个concurrentConsumers并发对应创建一个对象，并存储到Set consumers集合中，返回值就是创建consumer对象个数</span></span><br><span class="line">               <span class="comment">// 具体创建逻辑见：SimpleMessageListenerContainer#createBlockingQueueConsumer</span></span><br><span class="line">               <span class="comment">// 主要注意下prefetchCount计算： int actualPrefetchCount = getPrefetchCount() &gt; this.batchSize ? getPrefetchCount() : this.batchSize;</span></span><br><span class="line">               <span class="comment">// 即如果prefetchCount大于batchSize，则其就是实际值，否则prefetchCount等于batchSize值</span></span><br><span class="line">               <span class="keyword">int</span> newConsumers = <span class="keyword">this</span>.initializeConsumers();</span><br><span class="line">               <span class="keyword">if</span> (<span class="keyword">this</span>.consumers == <span class="keyword">null</span>) &#123;</span><br><span class="line">                   <span class="keyword">this</span>.logger.info(<span class="string">&quot;Consumers were initialized and then cleared (presumably the container was stopped concurrently)&quot;</span>);</span><br><span class="line">               &#125; <span class="keyword">else</span> <span class="keyword">if</span> (newConsumers &lt;= <span class="number">0</span>) &#123;</span><br><span class="line">                   <span class="keyword">if</span> (<span class="keyword">this</span>.logger.isInfoEnabled()) &#123;</span><br><span class="line">                       <span class="keyword">this</span>.logger.info(<span class="string">&quot;Consumers are already running&quot;</span>);</span><br><span class="line">                   &#125;</span><br><span class="line"></span><br><span class="line">               &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                   Set&lt;SimpleMessageListenerContainer.AsyncMessageProcessingConsumer&gt; processors = <span class="keyword">new</span> HashSet();</span><br><span class="line">                   Iterator var12 = <span class="keyword">this</span>.consumers.iterator();</span><br><span class="line"></span><br><span class="line">                   <span class="keyword">while</span>(var12.hasNext()) &#123;</span><br><span class="line">     <span class="comment">// 将BlockingQueueConsumer对象封装成AsyncMessageProcessingConsumer进行异步执行 </span></span><br><span class="line">                       BlockingQueueConsumer consumer = (BlockingQueueConsumer)var12.next();</span><br><span class="line">                       SimpleMessageListenerContainer.AsyncMessageProcessingConsumer processor = <span class="keyword">new</span> SimpleMessageListenerContainer.AsyncMessageProcessingConsumer(consumer);</span><br><span class="line">                       <span class="comment">// 存储到processors集合中 </span></span><br><span class="line">                       processors.add(processor);</span><br><span class="line">                       <span class="comment">// 将AsyncMessageProcessingConsumer丢到线程池中执行</span></span><br><span class="line">                       <span class="keyword">this</span>.getTaskExecutor().execute(processor);</span><br><span class="line">                       <span class="comment">// 事件发送</span></span><br><span class="line">                       <span class="keyword">if</span> (<span class="keyword">this</span>.getApplicationEventPublisher() != <span class="keyword">null</span>) &#123;</span><br><span class="line">                           <span class="keyword">this</span>.getApplicationEventPublisher().publishEvent(<span class="keyword">new</span> AsyncConsumerStartedEvent(<span class="keyword">this</span>, consumer));</span><br><span class="line">                       &#125;</span><br><span class="line">                   &#125;</span><br><span class="line"></span><br><span class="line">                   var12 = processors.iterator();</span><br><span class="line"></span><br><span class="line">                   <span class="comment">// 判断启动过程中是否存在异常</span></span><br><span class="line">                   FatalListenerStartupException startupException;</span><br><span class="line">                   <span class="keyword">do</span> &#123;</span><br><span class="line">                       <span class="keyword">if</span> (!var12.hasNext()) &#123;</span><br><span class="line">                           <span class="keyword">return</span>;</span><br><span class="line">                       &#125;</span><br><span class="line"></span><br><span class="line">                       SimpleMessageListenerContainer.AsyncMessageProcessingConsumer processor = (SimpleMessageListenerContainer.AsyncMessageProcessingConsumer)var12.next();</span><br><span class="line">                       startupException = processor.getStartupException();</span><br><span class="line">                   &#125; <span class="keyword">while</span>(startupException == <span class="keyword">null</span>);</span><br><span class="line"></span><br><span class="line">                   <span class="keyword">throw</span> <span class="keyword">new</span> AmqpIllegalStateException(<span class="string">&quot;Fatal exception on listener startup&quot;</span>, startupException);</span><br><span class="line">               &#125;</span><br><span class="line">           &#125;</span><br><span class="line">       &#125;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure><p>上面代码大致逻辑：<code>BlockingQueueConsumer</code> 对象可以看成 <code>consumer</code> ，然后将其包装成 <code>AsyncMessageProcessingConsumer</code> 异步任务丢入到线程池中运行。</p><p>异步任务：主要接口为AsyncMessageProcessingConsumer#run。</p><h5 id="AsyncMessageProcessingConsumer-run"><a href="#AsyncMessageProcessingConsumer-run" class="headerlink" title="AsyncMessageProcessingConsumer#run"></a>AsyncMessageProcessingConsumer#run</h5><ol><li>若当前consumer没有设置任何监听队列，则没必要启动</li><li>初始化：<ul><li>通过AmqpAdmin重新声明创建交换器、队列、绑定。</li><li></li></ul></li><li>死循环</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br></pre></td><td class="code"><pre><span class="line">     <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="comment">// 必须处于活跃状态</span></span><br><span class="line">         <span class="keyword">if</span> (SimpleMessageListenerContainer.<span class="keyword">this</span>.isActive()) &#123;</span><br><span class="line">             <span class="keyword">boolean</span> aborted = <span class="keyword">false</span>;</span><br><span class="line">             <span class="keyword">int</span> consecutiveIdles = <span class="number">0</span>;</span><br><span class="line">             <span class="keyword">int</span> consecutiveMessages = <span class="number">0</span>;</span><br><span class="line">             <span class="keyword">this</span>.consumer.setLocallyTransacted(SimpleMessageListenerContainer.<span class="keyword">this</span>.isChannelLocallyTransacted());</span><br><span class="line">             String routingLookupKey = SimpleMessageListenerContainer.<span class="keyword">this</span>.getRoutingLookupKey();</span><br><span class="line">             <span class="keyword">if</span> (routingLookupKey != <span class="keyword">null</span>) &#123;</span><br><span class="line">                 SimpleResourceHolder.bind(SimpleMessageListenerContainer.<span class="keyword">this</span>.getRoutingConnectionFactory(), routingLookupKey);</span><br><span class="line">             &#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 表示当前consumer没有设置任何监听队列，则没必要启动</span></span><br><span class="line">             <span class="keyword">if</span> (<span class="keyword">this</span>.consumer.getQueueCount() &lt; <span class="number">1</span>) &#123;</span><br><span class="line">                 <span class="keyword">if</span> (SimpleMessageListenerContainer.<span class="keyword">this</span>.logger.isDebugEnabled()) &#123;</span><br><span class="line">                     SimpleMessageListenerContainer.<span class="keyword">this</span>.logger.debug(<span class="string">&quot;Consumer stopping; no queues for &quot;</span> + <span class="keyword">this</span>.consumer);</span><br><span class="line">                 &#125;</span><br><span class="line">                 SimpleMessageListenerContainer.<span class="keyword">this</span>.cancellationLock.release(<span class="keyword">this</span>.consumer);</span><br><span class="line">                 <span class="keyword">if</span> (SimpleMessageListenerContainer.<span class="keyword">this</span>.getApplicationEventPublisher() != <span class="keyword">null</span>) &#123;</span><br><span class="line">                     SimpleMessageListenerContainer.<span class="keyword">this</span>.getApplicationEventPublisher().publishEvent(<span class="keyword">new</span> AsyncConsumerStoppedEvent(SimpleMessageListenerContainer.<span class="keyword">this</span>, <span class="keyword">this</span>.consumer));</span><br><span class="line">                 &#125;</span><br><span class="line"></span><br><span class="line">                 <span class="keyword">this</span>.start.countDown();</span><br><span class="line">             &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                 <span class="keyword">try</span> &#123;</span><br><span class="line"><span class="comment">// 1.初始化</span></span><br><span class="line">                     <span class="keyword">try</span> &#123;</span><br><span class="line">                         <span class="comment">// 通过AmqpAdmin重新声明创建交换器、队列、绑定</span></span><br><span class="line">                         SimpleMessageListenerContainer.<span class="keyword">this</span>.redeclareElementsIfNecessary();</span><br><span class="line">                         <span class="keyword">this</span>.consumer.start();</span><br><span class="line">                         <span class="keyword">this</span>.start.countDown();</span><br><span class="line">                     &#125; <span class="keyword">catch</span> (QueuesNotAvailableException var34) &#123;</span><br><span class="line">                         <span class="keyword">if</span> (SimpleMessageListenerContainer.<span class="keyword">this</span>.isMissingQueuesFatal()) &#123;</span><br><span class="line">                             <span class="keyword">throw</span> var34;</span><br><span class="line">                         &#125;</span><br><span class="line"></span><br><span class="line">                         <span class="keyword">this</span>.start.countDown();</span><br><span class="line">                         SimpleMessageListenerContainer.<span class="keyword">this</span>.handleStartupFailure(<span class="keyword">this</span>.consumer.getBackOffExecution());</span><br><span class="line">                         <span class="keyword">throw</span> var34;</span><br><span class="line">                     &#125; <span class="keyword">catch</span> (FatalListenerStartupException var35) &#123;</span><br><span class="line">                         <span class="keyword">if</span> (SimpleMessageListenerContainer.<span class="keyword">this</span>.isPossibleAuthenticationFailureFatal()) &#123;</span><br><span class="line">                             <span class="keyword">throw</span> var35;</span><br><span class="line">                         &#125;</span><br><span class="line"></span><br><span class="line">                         Throwable possibleAuthException = var35.getCause().getCause();</span><br><span class="line">                         <span class="keyword">if</span> (possibleAuthException != <span class="keyword">null</span> &amp;&amp; possibleAuthException <span class="keyword">instanceof</span> PossibleAuthenticationFailureException) &#123;</span><br><span class="line">                             <span class="keyword">this</span>.start.countDown();</span><br><span class="line">                             SimpleMessageListenerContainer.<span class="keyword">this</span>.handleStartupFailure(<span class="keyword">this</span>.consumer.getBackOffExecution());</span><br><span class="line">                             <span class="keyword">throw</span> possibleAuthException;</span><br><span class="line">                         &#125;</span><br><span class="line"></span><br><span class="line">                         <span class="keyword">throw</span> var35;</span><br><span class="line">                     &#125; <span class="keyword">catch</span> (Throwable var36) &#123;</span><br><span class="line">                         <span class="keyword">this</span>.start.countDown();</span><br><span class="line">                         SimpleMessageListenerContainer.<span class="keyword">this</span>.handleStartupFailure(<span class="keyword">this</span>.consumer.getBackOffExecution());</span><br><span class="line">                         <span class="keyword">throw</span> var36;</span><br><span class="line">                     &#125;</span><br><span class="line"></span><br><span class="line">                     <span class="keyword">if</span> (SimpleMessageListenerContainer.<span class="keyword">this</span>.getTransactionManager() != <span class="keyword">null</span>) &#123;</span><br><span class="line">                         ConsumerChannelRegistry.registerConsumerChannel(<span class="keyword">this</span>.consumer.getChannel(), SimpleMessageListenerContainer.<span class="keyword">this</span>.getConnectionFactory());</span><br><span class="line">                     &#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 死循环</span></span><br><span class="line">                     <span class="keyword">while</span>(SimpleMessageListenerContainer.<span class="keyword">this</span>.isActive(<span class="keyword">this</span>.consumer) || <span class="keyword">this</span>.consumer.hasDelivery() || !<span class="keyword">this</span>.consumer.cancelled()) &#123;</span><br><span class="line">                         <span class="keyword">try</span> &#123;</span><br><span class="line">                             <span class="keyword">boolean</span> receivedOk = SimpleMessageListenerContainer.<span class="keyword">this</span>.receiveAndExecute(<span class="keyword">this</span>.consumer);</span><br><span class="line">                             <span class="keyword">if</span> (SimpleMessageListenerContainer.<span class="keyword">this</span>.maxConcurrentConsumers != <span class="keyword">null</span>) &#123;</span><br><span class="line">                                 <span class="keyword">if</span> (receivedOk) &#123;</span><br><span class="line">                                     <span class="keyword">if</span> (SimpleMessageListenerContainer.<span class="keyword">this</span>.isActive(<span class="keyword">this</span>.consumer)) &#123;</span><br><span class="line">                                         consecutiveIdles = <span class="number">0</span>;</span><br><span class="line">                                         <span class="keyword">if</span> (consecutiveMessages++ &gt; SimpleMessageListenerContainer.<span class="keyword">this</span>.consecutiveActiveTrigger) &#123;</span><br><span class="line">                                             SimpleMessageListenerContainer.<span class="keyword">this</span>.considerAddingAConsumer();</span><br><span class="line">                                             consecutiveMessages = <span class="number">0</span>;</span><br><span class="line">                                         &#125;</span><br><span class="line">                                     &#125;</span><br><span class="line">                                 &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                                     consecutiveMessages = <span class="number">0</span>;</span><br><span class="line">                                     <span class="keyword">if</span> (consecutiveIdles++ &gt; SimpleMessageListenerContainer.<span class="keyword">this</span>.consecutiveIdleTrigger) &#123;</span><br><span class="line">                                         SimpleMessageListenerContainer.<span class="keyword">this</span>.considerStoppingAConsumer(<span class="keyword">this</span>.consumer);</span><br><span class="line">                                         consecutiveIdles = <span class="number">0</span>;</span><br><span class="line">                                     &#125;</span><br><span class="line">                                 &#125;</span><br><span class="line">                             &#125;</span><br><span class="line"></span><br><span class="line">                             <span class="keyword">long</span> idleEventInterval = SimpleMessageListenerContainer.<span class="keyword">this</span>.getIdleEventInterval();</span><br><span class="line">                             <span class="keyword">if</span> (idleEventInterval &gt; <span class="number">0L</span>) &#123;</span><br><span class="line">                                 <span class="keyword">if</span> (receivedOk) &#123;</span><br><span class="line">                                     SimpleMessageListenerContainer.<span class="keyword">this</span>.updateLastReceive();</span><br><span class="line">                                 &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                                     <span class="keyword">long</span> now = System.currentTimeMillis();</span><br><span class="line">                                     <span class="keyword">long</span> lastAlertAt = SimpleMessageListenerContainer.<span class="keyword">this</span>.lastNoMessageAlert.get();</span><br><span class="line">                                     <span class="keyword">long</span> lastReceive = SimpleMessageListenerContainer.<span class="keyword">this</span>.getLastReceive();</span><br><span class="line">                                     <span class="keyword">if</span> (now &gt; lastReceive + idleEventInterval &amp;&amp; now &gt; lastAlertAt + idleEventInterval &amp;&amp; SimpleMessageListenerContainer.<span class="keyword">this</span>.lastNoMessageAlert.compareAndSet(lastAlertAt, now)) &#123;</span><br><span class="line">                                         SimpleMessageListenerContainer.<span class="keyword">this</span>.publishIdleContainerEvent(now - lastReceive);</span><br><span class="line">                                     &#125;</span><br><span class="line">                                 &#125;</span><br><span class="line">                             &#125;</span><br><span class="line">                         &#125; <span class="keyword">catch</span> (ListenerExecutionFailedException var37) &#123;</span><br><span class="line">                             <span class="keyword">if</span> (var37.getCause() <span class="keyword">instanceof</span> NoSuchMethodException) &#123;</span><br><span class="line">                                 <span class="keyword">throw</span> <span class="keyword">new</span> FatalListenerExecutionException(<span class="string">&quot;Invalid listener&quot;</span>, var37);</span><br><span class="line">                             &#125;</span><br><span class="line">                         &#125; <span class="keyword">catch</span> (AmqpRejectAndDontRequeueException var38) &#123;</span><br><span class="line">                         &#125;</span><br><span class="line">                     &#125;</span><br><span class="line">                 &#125; <span class="keyword">catch</span> (InterruptedException var39) &#123;</span><br><span class="line">                     SimpleMessageListenerContainer.<span class="keyword">this</span>.logger.debug(<span class="string">&quot;Consumer thread interrupted, processing stopped.&quot;</span>);</span><br><span class="line">                     Thread.currentThread().interrupt();</span><br><span class="line">                     aborted = <span class="keyword">true</span>;</span><br><span class="line">                     SimpleMessageListenerContainer.<span class="keyword">this</span>.publishConsumerFailedEvent(<span class="string">&quot;Consumer thread interrupted, processing stopped&quot;</span>, <span class="keyword">true</span>, var39);</span><br><span class="line">                 &#125; <span class="keyword">catch</span> (QueuesNotAvailableException var40) &#123;</span><br><span class="line">                     SimpleMessageListenerContainer.<span class="keyword">this</span>.logger.error(<span class="string">&quot;Consumer received fatal=&quot;</span> + SimpleMessageListenerContainer.<span class="keyword">this</span>.isMismatchedQueuesFatal() + <span class="string">&quot; exception on startup&quot;</span>, var40);</span><br><span class="line">                     <span class="keyword">if</span> (SimpleMessageListenerContainer.<span class="keyword">this</span>.isMissingQueuesFatal()) &#123;</span><br><span class="line">                         <span class="keyword">this</span>.startupException = var40;</span><br><span class="line">                         aborted = <span class="keyword">true</span>;</span><br><span class="line">                     &#125;</span><br><span class="line"></span><br><span class="line">                     SimpleMessageListenerContainer.<span class="keyword">this</span>.publishConsumerFailedEvent(<span class="string">&quot;Consumer queue(s) not available&quot;</span>, aborted, var40);</span><br><span class="line">                 &#125; <span class="keyword">catch</span> (FatalListenerStartupException var41) &#123;</span><br><span class="line">                     SimpleMessageListenerContainer.<span class="keyword">this</span>.logger.error(<span class="string">&quot;Consumer received fatal exception on startup&quot;</span>, var41);</span><br><span class="line">                     <span class="keyword">this</span>.startupException = var41;</span><br><span class="line">                     aborted = <span class="keyword">true</span>;</span><br><span class="line">                     SimpleMessageListenerContainer.<span class="keyword">this</span>.publishConsumerFailedEvent(<span class="string">&quot;Consumer received fatal exception on startup&quot;</span>, <span class="keyword">true</span>, var41);</span><br><span class="line">                 &#125; <span class="keyword">catch</span> (FatalListenerExecutionException var42) &#123;</span><br><span class="line">                     SimpleMessageListenerContainer.<span class="keyword">this</span>.logger.error(<span class="string">&quot;Consumer received fatal exception during processing&quot;</span>, var42);</span><br><span class="line">                     aborted = <span class="keyword">true</span>;</span><br><span class="line">                     SimpleMessageListenerContainer.<span class="keyword">this</span>.publishConsumerFailedEvent(<span class="string">&quot;Consumer received fatal exception during processing&quot;</span>, <span class="keyword">true</span>, var42);</span><br><span class="line">                 &#125; <span class="keyword">catch</span> (PossibleAuthenticationFailureException var43) &#123;</span><br><span class="line">                     SimpleMessageListenerContainer.<span class="keyword">this</span>.logger.error(<span class="string">&quot;Consumer received fatal=&quot;</span> + SimpleMessageListenerContainer.<span class="keyword">this</span>.isPossibleAuthenticationFailureFatal() + <span class="string">&quot; exception during processing&quot;</span>, var43);</span><br><span class="line">                     <span class="keyword">if</span> (SimpleMessageListenerContainer.<span class="keyword">this</span>.isPossibleAuthenticationFailureFatal()) &#123;</span><br><span class="line">                         <span class="keyword">this</span>.startupException = <span class="keyword">new</span> FatalListenerStartupException(<span class="string">&quot;Authentication failure&quot;</span>, <span class="keyword">new</span> AmqpAuthenticationException(var43));</span><br><span class="line">                         aborted = <span class="keyword">true</span>;</span><br><span class="line">                     &#125;</span><br><span class="line"></span><br><span class="line">                     SimpleMessageListenerContainer.<span class="keyword">this</span>.publishConsumerFailedEvent(<span class="string">&quot;Consumer received PossibleAuthenticationFailure during startup&quot;</span>, aborted, var43);</span><br><span class="line">                 &#125; <span class="keyword">catch</span> (ShutdownSignalException var44) &#123;</span><br><span class="line">                     <span class="keyword">if</span> (RabbitUtils.isNormalShutdown(var44)) &#123;</span><br><span class="line">                         <span class="keyword">if</span> (SimpleMessageListenerContainer.<span class="keyword">this</span>.logger.isDebugEnabled()) &#123;</span><br><span class="line">                             SimpleMessageListenerContainer.<span class="keyword">this</span>.logger.debug(<span class="string">&quot;Consumer received Shutdown Signal, processing stopped: &quot;</span> + var44.getMessage());</span><br><span class="line">                         &#125;</span><br><span class="line">                     &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                         <span class="keyword">this</span>.logConsumerException(var44);</span><br><span class="line">                     &#125;</span><br><span class="line">                 &#125; <span class="keyword">catch</span> (AmqpIOException var45) &#123;</span><br><span class="line">                     <span class="keyword">if</span> (var45.getCause() <span class="keyword">instanceof</span> IOException &amp;&amp; var45.getCause().getCause() <span class="keyword">instanceof</span> ShutdownSignalException &amp;&amp; var45.getCause().getCause().getMessage().contains(<span class="string">&quot;in exclusive use&quot;</span>)) &#123;</span><br><span class="line">                         SimpleMessageListenerContainer.<span class="keyword">this</span>.getExclusiveConsumerExceptionLogger().log(SimpleMessageListenerContainer.<span class="keyword">this</span>.logger, <span class="string">&quot;Exclusive consumer failure&quot;</span>, var45.getCause().getCause());</span><br><span class="line">                         SimpleMessageListenerContainer.<span class="keyword">this</span>.publishConsumerFailedEvent(<span class="string">&quot;Consumer raised exception, attempting restart&quot;</span>, <span class="keyword">false</span>, var45);</span><br><span class="line">                     &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                         <span class="keyword">this</span>.logConsumerException(var45);</span><br><span class="line">                     &#125;</span><br><span class="line">                 &#125; <span class="keyword">catch</span> (Error var46) &#123;</span><br><span class="line">                     SimpleMessageListenerContainer.<span class="keyword">this</span>.logger.error(<span class="string">&quot;Consumer thread error, thread abort.&quot;</span>, var46);</span><br><span class="line">                     SimpleMessageListenerContainer.<span class="keyword">this</span>.publishConsumerFailedEvent(<span class="string">&quot;Consumer threw an Error&quot;</span>, <span class="keyword">true</span>, var46);</span><br><span class="line">                     aborted = <span class="keyword">true</span>;</span><br><span class="line">                 &#125; <span class="keyword">catch</span> (Throwable var47) &#123;</span><br><span class="line">                     <span class="keyword">if</span> (SimpleMessageListenerContainer.<span class="keyword">this</span>.isActive()) &#123;</span><br><span class="line">                         <span class="keyword">this</span>.logConsumerException(var47);</span><br><span class="line">                     &#125;</span><br><span class="line">                 &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">                     <span class="keyword">if</span> (SimpleMessageListenerContainer.<span class="keyword">this</span>.getTransactionManager() != <span class="keyword">null</span>) &#123;</span><br><span class="line">                         ConsumerChannelRegistry.unRegisterConsumerChannel();</span><br><span class="line">                     &#125;</span><br><span class="line"></span><br><span class="line">                 &#125;</span><br><span class="line"></span><br><span class="line">                 <span class="keyword">this</span>.start.countDown();</span><br><span class="line">                 <span class="keyword">if</span> (SimpleMessageListenerContainer.<span class="keyword">this</span>.isActive(<span class="keyword">this</span>.consumer) &amp;&amp; !aborted) &#123;</span><br><span class="line">                     SimpleMessageListenerContainer.<span class="keyword">this</span>.logger.info(<span class="string">&quot;Restarting &quot;</span> + <span class="keyword">this</span>.consumer);</span><br><span class="line">                     SimpleMessageListenerContainer.<span class="keyword">this</span>.restart(<span class="keyword">this</span>.consumer);</span><br><span class="line">                 &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                     SimpleMessageListenerContainer.<span class="keyword">this</span>.logger.debug(<span class="string">&quot;Cancelling &quot;</span> + <span class="keyword">this</span>.consumer);</span><br><span class="line"></span><br><span class="line">                     <span class="keyword">try</span> &#123;</span><br><span class="line">                         <span class="keyword">this</span>.consumer.stop();</span><br><span class="line">                         SimpleMessageListenerContainer.<span class="keyword">this</span>.cancellationLock.release(<span class="keyword">this</span>.consumer);</span><br><span class="line">                         <span class="keyword">if</span> (SimpleMessageListenerContainer.<span class="keyword">this</span>.getApplicationEventPublisher() != <span class="keyword">null</span>) &#123;</span><br><span class="line">                             SimpleMessageListenerContainer.<span class="keyword">this</span>.getApplicationEventPublisher().publishEvent(<span class="keyword">new</span> AsyncConsumerStoppedEvent(SimpleMessageListenerContainer.<span class="keyword">this</span>, <span class="keyword">this</span>.consumer));</span><br><span class="line">                         &#125;</span><br><span class="line">                     &#125; <span class="keyword">catch</span> (AmqpException var33) &#123;</span><br><span class="line">                         SimpleMessageListenerContainer.<span class="keyword">this</span>.logger.info(<span class="string">&quot;Could not cancel message consumer&quot;</span>, var33);</span><br><span class="line">                     &#125;</span><br><span class="line"></span><br><span class="line">                     <span class="keyword">if</span> (aborted &amp;&amp; SimpleMessageListenerContainer.<span class="keyword">this</span>.containerStoppingForAbort.compareAndSet((Object)<span class="keyword">null</span>, Thread.currentThread())) &#123;</span><br><span class="line">                         SimpleMessageListenerContainer.<span class="keyword">this</span>.logger.error(<span class="string">&quot;Stopping container from aborted consumer&quot;</span>);</span><br><span class="line">                         SimpleMessageListenerContainer.<span class="keyword">this</span>.stop();</span><br><span class="line">                         SimpleMessageListenerContainer.<span class="keyword">this</span>.containerStoppingForAbort.set((Object)<span class="keyword">null</span>);</span><br><span class="line">                         ListenerContainerConsumerFailedEvent event = <span class="keyword">null</span>;</span><br><span class="line"></span><br><span class="line">                         <span class="keyword">do</span> &#123;</span><br><span class="line">                             <span class="keyword">try</span> &#123;</span><br><span class="line">                                 event = (ListenerContainerConsumerFailedEvent)SimpleMessageListenerContainer.<span class="keyword">this</span>.abortEvents.poll(<span class="number">5L</span>, TimeUnit.SECONDS);</span><br><span class="line">                                 <span class="keyword">if</span> (event != <span class="keyword">null</span>) &#123;</span><br><span class="line">                                     SimpleMessageListenerContainer.<span class="keyword">this</span>.publishConsumerFailedEvent(event.getReason(), event.isFatal(), event.getThrowable());</span><br><span class="line">                                 &#125;</span><br><span class="line">                             &#125; <span class="keyword">catch</span> (InterruptedException var32) &#123;</span><br><span class="line">                                 Thread.currentThread().interrupt();</span><br><span class="line">                             &#125;</span><br><span class="line">                         &#125; <span class="keyword">while</span>(event != <span class="keyword">null</span>);</span><br><span class="line">                     &#125;</span><br><span class="line">                 &#125;</span><br><span class="line"></span><br><span class="line">                 <span class="keyword">if</span> (routingLookupKey != <span class="keyword">null</span>) &#123;</span><br><span class="line">                     SimpleResourceHolder.unbind(SimpleMessageListenerContainer.<span class="keyword">this</span>.getRoutingConnectionFactory());</span><br><span class="line">                 &#125;</span><br><span class="line"></span><br><span class="line">             &#125;</span><br><span class="line">         &#125;</span><br><span class="line">     &#125;</span><br></pre></td></tr></table></figure><h5 id="BlockingQueueConsumer-start"><a href="#BlockingQueueConsumer-start" class="headerlink" title="BlockingQueueConsumer#start"></a>BlockingQueueConsumer#start</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 主要完成与`Rabbit Broker`指令交互</span></span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">start</span><span class="params">()</span> <span class="keyword">throws</span> AmqpException </span>&#123;</span><br><span class="line">       <span class="keyword">if</span> (logger.isDebugEnabled()) &#123;</span><br><span class="line">           logger.debug(<span class="string">&quot;Starting consumer &quot;</span> + <span class="keyword">this</span>);</span><br><span class="line">       &#125;</span><br><span class="line"></span><br><span class="line">       <span class="keyword">this</span>.thread = Thread.currentThread();</span><br><span class="line"></span><br><span class="line">       <span class="keyword">try</span> &#123;</span><br><span class="line">           <span class="keyword">this</span>.resourceHolder = ConnectionFactoryUtils.getTransactionalResourceHolder(<span class="keyword">this</span>.connectionFactory, <span class="keyword">this</span>.transactional);</span><br><span class="line">           <span class="keyword">this</span>.channel = <span class="keyword">this</span>.resourceHolder.getChannel();</span><br><span class="line">           ClosingRecoveryListener.addRecoveryListenerIfNecessary(<span class="keyword">this</span>.channel);</span><br><span class="line">       &#125; <span class="keyword">catch</span> (AmqpAuthenticationException var8) &#123;</span><br><span class="line">           <span class="keyword">throw</span> <span class="keyword">new</span> FatalListenerStartupException(<span class="string">&quot;Authentication failure&quot;</span>, var8);</span><br><span class="line">       &#125;</span><br><span class="line"></span><br><span class="line">       <span class="keyword">this</span>.deliveryTags.clear();</span><br><span class="line">       <span class="keyword">this</span>.activeObjectCounter.add(<span class="keyword">this</span>);</span><br><span class="line">       <span class="keyword">int</span> passiveDeclareRetries = <span class="keyword">this</span>.declarationRetries;</span><br><span class="line">       <span class="keyword">this</span>.declaring = <span class="keyword">true</span>;</span><br><span class="line"></span><br><span class="line">       <span class="keyword">while</span>(!<span class="keyword">this</span>.cancelled()) &#123;</span><br><span class="line">           <span class="keyword">try</span> &#123;</span><br><span class="line"><span class="comment">// 校验监听队列是否存在</span></span><br><span class="line"><span class="comment">// `channel.queueDeclarePassive(queueName)`，最终会向`Rabbit Broker`发送`queue.declare`指令，并设置`passive=true`</span></span><br><span class="line">               <span class="keyword">this</span>.attemptPassiveDeclarations();</span><br><span class="line">               <span class="keyword">if</span> (passiveDeclareRetries &lt; <span class="keyword">this</span>.declarationRetries &amp;&amp; logger.isInfoEnabled()) &#123;</span><br><span class="line">                   logger.info(<span class="string">&quot;Queue declaration succeeded after retrying&quot;</span>);</span><br><span class="line">               &#125;</span><br><span class="line"></span><br><span class="line">               passiveDeclareRetries = <span class="number">0</span>;</span><br><span class="line">           &#125; <span class="keyword">catch</span> (BlockingQueueConsumer.DeclarationException var10) &#123;</span><br><span class="line">               <span class="keyword">if</span> (passiveDeclareRetries &gt; <span class="number">0</span> &amp;&amp; <span class="keyword">this</span>.channel.isOpen()) &#123;</span><br><span class="line">                   <span class="keyword">if</span> (logger.isWarnEnabled()) &#123;</span><br><span class="line">                       logger.warn(<span class="string">&quot;Queue declaration failed; retries left=&quot;</span> + passiveDeclareRetries, var10);</span><br><span class="line"></span><br><span class="line">                       <span class="keyword">try</span> &#123;</span><br><span class="line">                           Thread.sleep(<span class="keyword">this</span>.failedDeclarationRetryInterval);</span><br><span class="line">                       &#125; <span class="keyword">catch</span> (InterruptedException var7) &#123;</span><br><span class="line">                           <span class="keyword">this</span>.declaring = <span class="keyword">false</span>;</span><br><span class="line">                           Thread.currentThread().interrupt();</span><br><span class="line">                           <span class="keyword">this</span>.activeObjectCounter.release(<span class="keyword">this</span>);</span><br><span class="line">                           <span class="keyword">throw</span> RabbitExceptionTranslator.convertRabbitAccessException(var7);</span><br><span class="line">                       &#125;</span><br><span class="line">                   &#125;</span><br><span class="line">               &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                   <span class="keyword">if</span> (var10.getFailedQueues().size() &gt;= <span class="keyword">this</span>.queues.length) &#123;</span><br><span class="line">                       <span class="keyword">this</span>.declaring = <span class="keyword">false</span>;</span><br><span class="line">                       <span class="keyword">this</span>.activeObjectCounter.release(<span class="keyword">this</span>);</span><br><span class="line">                       <span class="keyword">throw</span> <span class="keyword">new</span> QueuesNotAvailableException(<span class="string">&quot;Cannot prepare queue for listener. Either the queue doesn&#x27;t exist or the broker will not allow us to use it.&quot;</span>, var10);</span><br><span class="line">                   &#125;</span><br><span class="line"></span><br><span class="line">                   <span class="keyword">if</span> (logger.isWarnEnabled()) &#123;</span><br><span class="line">                       logger.warn(<span class="string">&quot;Not all queues are available; only listening on those that are - configured: &quot;</span> + Arrays.asList(<span class="keyword">this</span>.queues) + <span class="string">&quot;; not available: &quot;</span> + var10.getFailedQueues());</span><br><span class="line">                   &#125;</span><br><span class="line"></span><br><span class="line">                   <span class="keyword">this</span>.missingQueues.addAll(var10.getFailedQueues());</span><br><span class="line">                   <span class="keyword">this</span>.lastRetryDeclaration = System.currentTimeMillis();</span><br><span class="line">               &#125;</span><br><span class="line">           &#125;</span><br><span class="line"></span><br><span class="line">           <span class="keyword">if</span> (passiveDeclareRetries-- &lt;= <span class="number">0</span> || <span class="keyword">this</span>.cancelled()) &#123;</span><br><span class="line">               <span class="keyword">break</span>;</span><br><span class="line">           &#125;</span><br><span class="line">       &#125;</span><br><span class="line"></span><br><span class="line">       <span class="keyword">this</span>.declaring = <span class="keyword">false</span>;</span><br><span class="line">       <span class="keyword">if</span> (!<span class="keyword">this</span>.acknowledgeMode.isAutoAck() &amp;&amp; !<span class="keyword">this</span>.cancelled()) &#123;</span><br><span class="line">           <span class="keyword">try</span> &#123;</span><br><span class="line"><span class="comment">// 最终会向`Rabbit Broker`发送`basic.qos`指令，并将`prefetch-size`、`prefetch-count`和`global`参数设置过去</span></span><br><span class="line">               <span class="keyword">this</span>.channel.basicQos(<span class="keyword">this</span>.prefetchCount);</span><br><span class="line">           &#125; <span class="keyword">catch</span> (IOException var6) &#123;</span><br><span class="line">               <span class="keyword">this</span>.activeObjectCounter.release(<span class="keyword">this</span>);</span><br><span class="line">               <span class="keyword">throw</span> <span class="keyword">new</span> AmqpIOException(var6);</span><br><span class="line">           &#125;</span><br><span class="line">       &#125;</span><br><span class="line"></span><br><span class="line">       <span class="keyword">try</span> &#123;</span><br><span class="line">           <span class="keyword">if</span> (!<span class="keyword">this</span>.cancelled()) &#123;</span><br><span class="line">               String[] var2 = <span class="keyword">this</span>.queues;</span><br><span class="line">               <span class="keyword">int</span> var3 = var2.length;</span><br><span class="line"></span><br><span class="line">               <span class="keyword">for</span>(<span class="keyword">int</span> var4 = <span class="number">0</span>; var4 &lt; var3; ++var4) &#123;</span><br><span class="line">                   String queueName = var2[var4];</span><br><span class="line">                   <span class="keyword">if</span> (!<span class="keyword">this</span>.missingQueues.contains(queueName)) &#123;</span><br><span class="line"><span class="comment">// 会使用`channel.basicConsume`方法订阅消息，最终会向`Rabbit Broker`发送`basic.consume`指令，并指定订阅消息的`queue`名称等参数消息</span></span><br><span class="line"><span class="comment">// 注意：`SimpleMessageListenerContainer`可能设置多个监听队列，则`BlockingQueueConsumer`这里会给每个监听队列都向Broker发送一个`basic.consume`订阅指令，并且是使用同一个`channel`：</span></span><br><span class="line">                       <span class="keyword">this</span>.consumeFromQueue(queueName);</span><br><span class="line">                   &#125;</span><br><span class="line">               &#125;</span><br><span class="line">           &#125;</span><br><span class="line"></span><br><span class="line">       &#125; <span class="keyword">catch</span> (IOException var9) &#123;</span><br><span class="line">           <span class="keyword">throw</span> RabbitExceptionTranslator.convertRabbitAccessException(var9);</span><br><span class="line">       &#125;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure><p>响应处理：</p><p>上面分析</p><ul><li><p><code>initialize()</code>初始化操作，客户端向<code>Broker</code>发送<code>basic.qos</code>和<code>basic.consume</code>指令就相当于告诉了服务器：我都准备好了，如果监听队列有消息你就把它推送给我，下面就来分析下<code>Broker</code>消息推送流程。</p></li><li><p>死循环：<code>Rabbit Broker</code>接收到<code>Basic.consume</code>指令后，会向客户端反馈<code>Basic.consume-ok</code>指令，表示服务端一切就绪准备给客户端推送消息，然后就通过<code>Basic.Deliver</code>指令类型将消息推送给客户端，一条消息对应一个<code>Deliver</code>反馈，客户端接收到服务端返回过来的指令类型后，在<code>ChannelN#processAsync</code>方法进行判断处理，它是<code>amqp-client</code>依赖包中类：</p><p><img src="https://res-static.hc-cdn.cn/fms/img/1cea2b3e1b552149cc102993db8107b01612517532884" alt="【RabbitMQ分析】01 SimpleMessageListenerContainer原理分析7"></p></li></ul><p>如果是Deliver类型指令，则调用 <code>processDelivery()</code> 方法进行处理：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">protected <span class="keyword">void</span> <span class="function"><span class="title">processDelivery</span>(<span class="params">Command command, Basic.Deliver method</span>)</span> &#123; Basic.Deliver m = method; <span class="comment">//根据Deliver的consumerTag获取到InternalConsumer对象，因为一个Channel上可能存在多个consumer，需要找到Broker是针对哪个consumer进行的响应 Consumer callback = _consumers.get(m.getConsumerTag()); if (callback == null) &#123; if (defaultConsumer == null) &#123; // No handler set. We should blow up as this message // needs acking, just dropping it is not enough. See bug // 22587 for discussion. throw new IllegalStateException(&quot;Unsolicited delivery -&quot; + &quot; see Channel.setDefaultConsumer to handle this&quot; + &quot; case.&quot;); &#125; else &#123; callback = defaultConsumer; &#125; &#125; Envelope envelope = new Envelope(m.getDeliveryTag(), m.getRedelivered(), m.getExchange(), m.getRoutingKey()); try &#123; // call metricsCollector before the dispatching (which is async anyway) // this way, the message is inside the stats before it is handled // in case a manual ack in the callback, the stats will be able to record the ack metricsCollector.consumedMessage(this, m.getDeliveryTag(), m.getConsumerTag()); this.dispatcher.handleDelivery(callback, m.getConsumerTag(), envelope, (BasicProperties) command.getContentHeader(), command.getContentBody()); &#125; catch (WorkPoolFullException e) &#123; // couldn&#x27;t enqueue in work pool, propagating throw e; &#125; catch (Throwable ex) &#123; getConnection().getExceptionHandler().handleConsumerException(this, ex, callback, m.getConsumerTag(), &quot;handleDelivery&quot;); &#125;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>processDelivery()</code>处理<code>Broker</code>返回的<code>Deliver</code>消息大致流程：</p><ul><li><p><code>Consumer callback = _consumers.get(m.getConsumerTag())</code>：根据<code>Deliver</code>的<code>consumerTag</code>获取到<code>InternalConsumer</code>对象，因为一个<code>Channel</code>上可能存在多个<code>consumer</code>，需要找到<code>Broker</code>是针对哪个<code>consumer</code>进行的响应</p></li><li><p>封装<code>Deliver</code>成<code>Envelope</code>：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Envelope envelope = <span class="keyword">new</span> Envelope(m.getDeliveryTag(), m.getRedelivered(), m.getExchange(), m.getRoutingKey());</span><br></pre></td></tr></table></figure></li><li><p><code>metricsCollector.consumedMessage(this, m.getDeliveryTag(), m.getConsumerTag())</code>:统计数据处理</p></li><li><p>调用<code>ConsumerDispatcher#handleDelivery</code>，其会创建任务丢到线程池中执行，任务：将数据交由具体的<code>consumer</code>处理，即调用<code>InternalConsumer#handleDelivery</code></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">this</span>.dispatcher.handleDelivery(callback, m.getConsumerTag(), envelope, (BasicProperties) command.getContentHeader(), command.getContentBody());</span><br></pre></td></tr></table></figure></li><li><p><code>InternalConsumer#handleDelivery()</code>方法：将<code>Broker</code>返回的<code>Deliver</code>数据放入到<code>BlockingQueueConsumer.queue</code>中：</p></li></ul><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">BlockingQueueConsumer.this.queue.put(<span class="keyword">new</span> Delivery(consumerTag, envelope, properties, body, <span class="built_in">this</span>.queueName));</span><br></pre></td></tr></table></figure><p>所以，如果<code>ListenerContainer</code>监听多个队列，则<code>BlockingQueueConsumer</code>中则对应多个<code>InternalConsumer</code>，每个<code>InternalConsumer</code>映射<code>Broker</code>上的一个，<code>BlockingQueueConsumer</code>下所有<code>InternalConsumer</code>共享同一个<code>queue</code>。</p><p>业务处理：</p><p>上面分析了消息订阅以及Broker推送过来的消息数据会被缓存到<code>BlockingQueueConsumer</code>对象的<code>queue</code>队列中，下面就来分析下从<code>queue</code>中提取消息到传递给用户业务逻辑这个流程。这就需要分析<code>AsyncMessageProcessingConsumer#run</code>方法中另一个非常重要操作：无限循环<code>mainLoop</code>操作，它主要就是完成从<code>queue</code>中提取消息数据然后经过一系列操作最终传递给用户逻辑<code>MessageListener</code>中。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">private <span class="keyword">void</span> mainLoop() throws Exception &#123; <span class="comment">// NOSONAR Exception</span></span><br><span class="line"> <span class="keyword">try</span> &#123;</span><br><span class="line">  boolean receivedOk = receiveAndExecute(<span class="built_in">this</span>.consumer); <span class="comment">// At least one message received</span></span><br><span class="line">  <span class="keyword">if</span> (SimpleMessageListenerContainer.this.maxConcurrentConsumers != <span class="literal">null</span>) &#123; checkAdjust(receivedOk);</span><br><span class="line">  &#125;</span><br><span class="line">  long idleEventInterval = getIdleEventInterval();</span><br><span class="line">  <span class="keyword">if</span> (idleEventInterval &gt; <span class="number">0</span>) &#123; <span class="keyword">if</span> (receivedOk) &#123; updateLastReceive(); &#125; <span class="keyword">else</span> &#123; long now = System.currentTimeMillis(); long lastAlertAt = SimpleMessageListenerContainer.this.lastNoMessageAlert.get(); long lastReceive = getLastReceive(); <span class="keyword">if</span> (now &gt; lastReceive + idleEventInterval &amp;&amp; now &gt; lastAlertAt + idleEventInterval &amp;&amp; SimpleMessageListenerContainer.this.lastNoMessageAlert .compareAndSet(lastAlertAt, now)) &#123; publishIdleContainerEvent(now - lastReceive); &#125; &#125;</span><br><span class="line">  &#125;</span><br><span class="line"> &#125;</span><br><span class="line"> <span class="keyword">catch</span> (ListenerExecutionFailedException ex) &#123;</span><br><span class="line">  <span class="comment">// Continue to process, otherwise re-throw</span></span><br><span class="line">  <span class="keyword">if</span> (ex.getCause() <span class="keyword">instanceof</span> NoSuchMethodException) &#123; <span class="keyword">throw</span> <span class="keyword">new</span> FatalListenerExecutionException(<span class="string">&quot;Invalid listener&quot;</span>, ex);</span><br><span class="line">  &#125;</span><br><span class="line"> &#125;</span><br><span class="line"> <span class="keyword">catch</span> (AmqpRejectAndDontRequeueException rejectEx) &#123;</span><br><span class="line">  <span class="comment">/* *  These will normally be wrapped by an LEFE if thrown by the *  listener, but we will also honor it if thrown by an</span></span><br><span class="line"><span class="comment">  *  error handler.</span></span><br><span class="line"><span class="comment">  */</span></span><br><span class="line"> &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>跟踪下<code>doReceiveAndExecute()</code>:</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">private boolean doReceiveAndExecute(BlockingQueueConsumer consumer) throws Exception &#123; <span class="comment">//NOSONAR</span></span><br><span class="line"></span><br><span class="line"> Channel channel = consumer.getChannel();</span><br><span class="line"></span><br><span class="line"> List messages = <span class="literal">null</span>;</span><br><span class="line"> long deliveryTag = <span class="number">0</span>; <span class="comment">//batchSize默认是1，用于指定一次从queue中提取消息数量</span></span><br><span class="line"> <span class="keyword">for</span> (int i = <span class="number">0</span>; i &lt; <span class="built_in">this</span>.batchsize; i++) &#123;&gt; afterReceivePostProcessors = getAfterReceivePostProcessors(); <span class="keyword">if</span> (afterReceivePostProcessors != <span class="literal">null</span>) &#123; Message original = message; deliveryTag = message.getMessageProperties().getDeliveryTag(); <span class="keyword">for</span> (MessagePostProcessor processor : getAfterReceivePostProcessors()) &#123; message = processor.postProcessMessage(message); <span class="keyword">if</span> (message == <span class="literal">null</span>) &#123; channel.basicAck(deliveryTag, <span class="literal">false</span>); <span class="keyword">if</span> (<span class="built_in">this</span>.logger.isDebugEnabled()) &#123; <span class="built_in">this</span>.logger.debug( <span class="string">&quot;Message Post Processor returned &#x27;null&#x27;, discarding message &quot;</span> + original); &#125; <span class="keyword">break</span>; &#125; &#125; &#125; <span class="keyword">if</span> (message != <span class="literal">null</span>) &#123; <span class="keyword">if</span> (messages == <span class="literal">null</span>) &#123; messages = <span class="keyword">new</span> ArrayList&lt;&gt;(<span class="built_in">this</span>.batchSize); &#125; <span class="keyword">if</span> (isDeBatchingEnabled() &amp;&amp; getBatchingStrategy().canDebatch(message.getMessageProperties())) &#123; final List messageList = messages; getBatchingStrategy().deBatch(message, fragment -&gt; messageList.add(fragment)); &#125; <span class="keyword">else</span> &#123; messages.add(message); &#125; &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">else</span> &#123; messages = debatch(message); <span class="keyword">if</span> (messages != <span class="literal">null</span>) &#123; <span class="keyword">break</span>; &#125; <span class="keyword">try</span> &#123; <span class="comment">//执行MessageListener executeListener(channel, message); &#125; catch (ImmediateAcknowledgeAmqpException e) &#123; if (this.logger.isDebugEnabled()) &#123; this.logger.debug(&quot;User requested ack for failed delivery &#x27;&quot; + e.getMessage() + &quot;&#x27;: &quot; + message.getMessageProperties().getDeliveryTag()); &#125; break; &#125; catch (Exception ex) &#123; if (causeChainHasImmediateAcknowledgeAmqpException(ex)) &#123; if (this.logger.isDebugEnabled()) &#123; this.logger.debug(&quot;User requested ack for failed delivery: &quot; + message.getMessageProperties().getDeliveryTag()); &#125; break; &#125; if (getTransactionManager() != null) &#123; if (getTransactionAttribute().rollbackOn(ex)) &#123; RabbitResourceHolder resourceHolder = (RabbitResourceHolder) TransactionSynchronizationManager .getResource(getConnectionFactory()); if (resourceHolder != null) &#123; consumer.clearDeliveryTags(); &#125; else &#123; /* * If we don&#x27;t actually have a transaction, we have to roll back * manually. See prepareHolderForRollback(). */ consumer.rollbackOnExceptionIfNecessary(ex); &#125; throw ex; // encompassing transaction will handle the rollback. &#125; else &#123; if (this.logger.isDebugEnabled()) &#123; this.logger.debug(&quot;No rollback for &quot; + ex); &#125; break; &#125; &#125; else &#123; consumer.rollbackOnExceptionIfNecessary(ex); throw ex; &#125; &#125; &#125;</span></span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">if</span> (messages != <span class="literal">null</span>) &#123; executeWithList(channel, messages, deliveryTag, consumer);</span><br><span class="line">  &#125; <span class="keyword">return</span> consumer.commitIfNecessary(isChannelLocallyTransacted());</span><br><span class="line"></span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure><p>总结：</p><p>上面对<code>SimpleMessageListenerContainer</code>核心源码进行分析，比较枯燥不太直观，总结下其最核心就是位于<code>AsyncMessageProcessingConsumer#run</code>方法中两个操作：<code>initialize()</code>和无限循环<code>mainLoop()</code>。</p><p><code>initialize()</code>方法主要完成：通过指令方式将需要监听队列信息告诉<code>Rabbit Broker</code>，<code>Broker</code>在监听队列中有消息数据时通过<code>Deliver</code>指令将消息推送给客户端，客户端接收的<code>Deliver</code>指令后，根据<code>consumerTag</code>分发(<code>dispatcher</code>)给具体<code>consumer</code>，然后<code>consumer</code>将其放入到其所属<code>BlockingQueueConsumer</code>对象的队列<code>queue</code>中，其逻辑可见下图：</p><p><img src="https://res-static.hc-cdn.cn/fms/img/58afc4c9952d12a7f18af4c48a0530d61612517532884" alt="【RabbitMQ分析】01 SimpleMessageListenerContainer原理分析8"></p><p><code>BlockingQueueConsumer</code>、<code>AsyncMessageProcessingConsumer</code>、监听队列等关系：</p><p>1、<code>BlockingQueueConsumer</code>相当于一个逻辑消费者，通过封装成<code>AsyncMessageProcessingConsumer</code>异步任务，然后丢到线程池中运行，线程池可以通过<code>SimpleMessageListenerContainer#setTaskExecutor</code>进行自定义配置，所以，<code>BlockingQueueConsumer</code>可以看成单独线程运行，且对应一个<code>Channel</code>；</p><p>2、<code>SimpleMessageListenerContainer</code>可以监听多个队列消息，每个队列又会创建一个<code>InternalConsumer</code>对象，用于映射<code>Broker</code>上的<code>consumer</code>概念，它们是共用同一个<code>channel</code>，即<code>channel</code>下存在多个<code>consumer</code>，它们之间通过<code>consumerTag</code>区分，另外，<code>Broker</code>推送消息也是根据<code>consumerTag</code>识别具体推送给哪个<code>consumer</code>进行处理；</p><p>案例，比如：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">container.setQueueNames(<span class="string">&quot;test01&quot;</span>, <span class="string">&quot;test02&quot;</span>);</span><br><span class="line">container.setConcurrentConsumers(<span class="number">3</span>);</span><br><span class="line">container.setConsumerTagStrategy(queue -&gt; <span class="string">&quot;consumer idx:&quot;</span>+consumerIdx.getAndIncrement());</span><br></pre></td></tr></table></figure><p>a、根据并发数<code>concurrentConsumers</code>创建对应数量的<code>BlockingQueueConsumer</code>，然后封装成<code>AsyncMessageProcessingConsumer</code>，再分配一个线程进行执行，这里设置成3，所以会有3个线程运行<code>AsyncMessageProcessingConsumer</code>，每个<code>AsyncMessageProcessingConsumer</code>对应一个channel，所以会创建3个channel，在Web UI上可以看到对应channel：</p><p><img src="https://res-static.hc-cdn.cn/fms/img/13fe637438a9c721adc6711b97ec6e821612517532885" alt="【RabbitMQ分析】01 SimpleMessageListenerContainer原理分析9"></p><p>b、每个监听队列创建一个<code>InternalConsumer</code>和Broker的consumer进行映射，这里有两个监听队列，所以每个channel下会存在2个consumer：</p><p><img src="https://res-static.hc-cdn.cn/fms/img/900030467c62c0b1f34878b69da926141612517532885" alt="【RabbitMQ分析】01 SimpleMessageListenerContainer原理分析10"></p><p><code>AsyncMessageProcessingConsumer</code>如何订阅：</p><p>a、首先发送<code>Basic.Qos</code>指令约定消息推送速率问题；</p><p>b、然后发送<code>Basic.Consume</code>指令告诉<code>Broker</code>客户端要开始订阅什么队列上的消息，以及把<code>consumerTag</code>带上，因为可能存在多个监听队列，则同一个<code>channel</code>上可能会发送多次<code>Basic.Consume</code>指令，<code>Broker</code>向<code>channel</code>推送消息时需要根据<code>consumerTag</code>找到对应<code>consumer</code>处理；</p><p>c、Broker通过Deliver指令类型方式向客户端推送消息，客户端接收到消息后，根据consumerTag找到对应consumer交由其进行处理，即分发dispatcher；</p><p>d、这里的consumer对应的是<code>InternalConsumer</code>，它处理逻辑就是放入到它所在的<code>BlockingQueueConsumer</code>对象中消息队列<code>queue</code>中；</p><p>mainLoop</p><hr><p>Broker推送过来的消息放入到了BlockingQueueConsumer对象的消息队列queue中，后续就是从queue中提取消息进行业务处理，逻辑见下图：</p><p><img src="https://res-static.hc-cdn.cn/fms/img/22d4831ca9b00a68417829fadee786621612517532886" alt="【RabbitMQ分析】01 SimpleMessageListenerContainer原理分析11"></p><p>a、<code>AsyncMessageProcessingConsumer</code>被丢入到线程池中执行，则其对应一个线程；</p><p>b、这个线程会一直循环执行<code>mainLoop()</code>方法；</p><p>c、<code>mainLoop()</code>方法中就会从<code>queue中</code>提取消息，根据<code>batchSize</code>确定每次提取消息数量，最后回调<code>MessageListener</code>，实现将消息传递到业务逻辑进行处理；</p><p>d、注意：所有的<code>AsyncMessageProcessingConsumer</code>共用同一个<code>MessageListener</code>对象，对象状态要注意线程安全问题；</p><p>总体流程</p><hr><p><img src="https://res-static.hc-cdn.cn/fms/img/57ad7c2ab6ba47794d532f6fca2a51201612517532886" alt="【RabbitMQ分析】01 SimpleMessageListenerContainer原理分析12"></p><p><a href="https://www.huaweicloud.com/articles/11961055.html">【RabbitMQ分析】01 SimpleMessageListenerContainer原理分析 - 华为云 (huaweicloud.com)</a></p><h4 id="MessageListenerContainer的创建"><a href="#MessageListenerContainer的创建" class="headerlink" title="MessageListenerContainer的创建"></a>MessageListenerContainer的创建</h4><p>首先看AbstractRabbitListenerContainerFactory抽象类的下面这个方法：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">   <span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> C <span class="title">createListenerContainer</span><span class="params">(RabbitListenerEndpoint endpoint)</span> </span>&#123;</span><br><span class="line">C instance = createContainerInstance();</span><br><span class="line">       ...</span><br><span class="line"></span><br><span class="line">endpoint.setupListenerContainer(instance);</span><br><span class="line">...</span><br><span class="line"></span><br><span class="line">initializeContainer(instance, endpoint);</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> instance;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure><p>注意里面两个方法，后面这个方法里面SimpleRabbitListenerContainerFactory会做一些它独有的属性设置，前一个方法执行结束，MessageListener就设置到MessageListenerContainer里面去了，可以跟踪这个方法，一直到AbstractRabbitListenerEndpoint类的下面这个方法：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">   <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">setupMessageListener</span><span class="params">(MessageListenerContainer container)</span> </span>&#123;</span><br><span class="line">MessageListener messageListener = createMessageListener(container);</span><br><span class="line">Assert.state(messageListener != <span class="keyword">null</span>, () -&gt; <span class="string">&quot;Endpoint [&quot;</span> + <span class="keyword">this</span> + <span class="string">&quot;] must provide a non null message listener&quot;</span>);</span><br><span class="line">container.setupMessageListener(messageListener);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure><p>可以看到在这个方法里创建了MessageListener，并将其设置到MessageListenerContainer里面去。</p><p>createMessageListener()方法有两个实现，实际调用的是MethodRabbitListenerEndpoint类里面的实现：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">   <span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">protected</span> MessagingMessageListenerAdapter <span class="title">createMessageListener</span><span class="params">(MessageListenerContainer container)</span> </span>&#123;</span><br><span class="line">...</span><br><span class="line"></span><br><span class="line">MessagingMessageListenerAdapter messageListener = createMessageListenerInstance();</span><br><span class="line">messageListener.setHandlerMethod(configureListenerAdapter(messageListener));</span><br><span class="line">...</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> messageListener;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure><p>看到setHandlerMethod(configureListenerAdapter(messageListener))这一行，这里创建并设置了一个HandlerAdapter，这个HandlerAdapter能够调用我们加了@RabbitListener注解的方法。</p><h4 id="SimpleMessageListenerContainer接收消息的实现"><a href="#SimpleMessageListenerContainer接收消息的实现" class="headerlink" title="SimpleMessageListenerContainer接收消息的实现"></a>SimpleMessageListenerContainer接收消息的实现</h4><p>SimpleRabbitListenerContainerFactory创建的MessageListenerContainer是SimpleMessageListenerContainer类，下面看它是怎么在启动后就能接收消息的。</p><p>上面讲过RabbitListenerEndpointRegistry类通过调用MessageListenerContainer的start()方法类启动这个MessageListenerContainer。</p><p>SimpleMessageListenerContainer类本身并没有实现start()方法，在它继承的抽象父类里面。进入AbstractMessageListenerContainer抽象类找到start()方法的实现</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">   <span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">start</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="keyword">if</span> (isRunning()) &#123;</span><br><span class="line"><span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> (!<span class="keyword">this</span>.initialized) &#123;</span><br><span class="line"><span class="keyword">synchronized</span> (<span class="keyword">this</span>.lifecycleMonitor) &#123;</span><br><span class="line"><span class="keyword">if</span> (!<span class="keyword">this</span>.initialized) &#123;</span><br><span class="line">afterPropertiesSet();</span><br><span class="line"><span class="keyword">this</span>.initialized = <span class="keyword">true</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line"><span class="keyword">if</span> (logger.isDebugEnabled()) &#123;</span><br><span class="line">logger.debug(<span class="string">&quot;Starting Rabbit listener container.&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line">configureAdminIfNeeded();</span><br><span class="line">checkMismatchedQueues();</span><br><span class="line">doStart();</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">catch</span> (Exception ex) &#123;</span><br><span class="line"><span class="keyword">throw</span> convertRabbitAccessException(ex);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure><p>真正的启动方法是doStart()，所以去SimpleMessageListenerContainer类中找这个类的doStart()实现：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">  <span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">doStart</span><span class="params">()</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">       ...</span><br><span class="line">       </span><br><span class="line">           <span class="keyword">int</span> newConsumers = initializeConsumers();</span><br><span class="line">       </span><br><span class="line">           ...</span><br><span class="line">       </span><br><span class="line">           <span class="keyword">for</span> (BlockingQueueConsumer consumer : <span class="keyword">this</span>.consumers) &#123;</span><br><span class="line">AsyncMessageProcessingConsumer processor = <span class="keyword">new</span> AsyncMessageProcessingConsumer(consumer);</span><br><span class="line">processors.add(processor);</span><br><span class="line">getTaskExecutor().execute(processor);</span><br><span class="line"><span class="keyword">if</span> (getApplicationEventPublisher() != <span class="keyword">null</span>) &#123;</span><br><span class="line">getApplicationEventPublisher().publishEvent(<span class="keyword">new</span> AsyncConsumerStartedEvent(<span class="keyword">this</span>, consumer));</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">...</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure><p>这个方法很长，细节就不去深究了，这里注意两个方法，一个是initializeConsumers()：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">   <span class="function"><span class="keyword">protected</span> <span class="keyword">int</span> <span class="title">initializeConsumers</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="keyword">int</span> count = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">synchronized</span> (<span class="keyword">this</span>.consumersMonitor) &#123;</span><br><span class="line"><span class="keyword">if</span> (<span class="keyword">this</span>.consumers == <span class="keyword">null</span>) &#123;</span><br><span class="line"><span class="keyword">this</span>.cancellationLock.reset();</span><br><span class="line"><span class="keyword">this</span>.consumers = <span class="keyword">new</span> HashSet&lt;BlockingQueueConsumer&gt;(<span class="keyword">this</span>.concurrentConsumers);</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="keyword">this</span>.concurrentConsumers; i++) &#123;</span><br><span class="line">BlockingQueueConsumer consumer = createBlockingQueueConsumer();</span><br><span class="line"><span class="keyword">this</span>.consumers.add(consumer);</span><br><span class="line">count++;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> count;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure><p>这个方法创建了BlockingQueueConsumer，数量等于concurrentConsumers参数的配置。</p><p>另一个方法是getTaskExecutor().execute(processor)，前面用BlockingQueueConsumer创建了AsyncMessageProcessingConsumer（实现了Runnable接口），这里获取到Executor来执行，每一个MessageListenerContainer都有各自的Executor。</p><p>在AsyncMessageProcessingConsumer类的run()方法里面可以找到下面这段代码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">   <span class="keyword">while</span> (isActive(<span class="keyword">this</span>.consumer) || <span class="keyword">this</span>.consumer.hasDelivery() || !<span class="keyword">this</span>.consumer.cancelled()) &#123;</span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line"><span class="keyword">boolean</span> receivedOk = receiveAndExecute(<span class="keyword">this</span>.consumer); <span class="comment">// At least one message received</span></span><br><span class="line"><span class="keyword">if</span> (SimpleMessageListenerContainer.<span class="keyword">this</span>.maxConcurrentConsumers != <span class="keyword">null</span>) &#123;</span><br><span class="line"><span class="keyword">if</span> (receivedOk) &#123;</span><br><span class="line"><span class="keyword">if</span> (isActive(<span class="keyword">this</span>.consumer)) &#123;</span><br><span class="line">consecutiveIdles = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">if</span> (consecutiveMessages++ &gt; SimpleMessageListenerContainer.<span class="keyword">this</span>.consecutiveActiveTrigger) &#123;</span><br><span class="line">considerAddingAConsumer();</span><br><span class="line">consecutiveMessages = <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">...</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">...</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">...</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>这里有两个地方需要注意。</p><p>一个是<code>this.consumer.hasDelivery()</code> ：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">boolean</span> <span class="title">hasDelivery</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="keyword">return</span> !<span class="keyword">this</span>.queue.isEmpty();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> BlockingQueue&lt;Delivery&gt; queue;</span><br></pre></td></tr></table></figure><p>另一个要注意的是<code>receiveAndExecute()</code>方法，跟踪进去：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">boolean</span> <span class="title">doReceiveAndExecute</span><span class="params">(BlockingQueueConsumer consumer)</span> <span class="keyword">throws</span> Throwable </span>&#123; <span class="comment">//NOSONAR</span></span><br><span class="line"></span><br><span class="line">Channel channel = consumer.getChannel();</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="keyword">this</span>.txSize; i++) &#123;</span><br><span class="line"></span><br><span class="line">logger.trace(<span class="string">&quot;Waiting for message from consumer.&quot;</span>);</span><br><span class="line">Message message = consumer.nextMessage(<span class="keyword">this</span>.receiveTimeout);</span><br><span class="line"><span class="keyword">if</span> (message == <span class="keyword">null</span>) &#123;</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">executeListener(channel, message);</span><br><span class="line">&#125;</span><br><span class="line">...</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>consumer.nextMessage(this.receiveTimeout);会从上面那个BlockingQueue里面拿一条消息出来。</p><p>所以SimpleMessageListenerContainer接收消息的实现方案是：用一个BlockingQueue保存rabbitmq发过来还未来得及处理的消息，然后向Executor提交执行Runnable，Runnable中循环从BlockingQueue里面取消息。</p><p>至于这个BlockingQueue里面的消息是怎么从rabbitmq获取到的，此处暂不讨论。</p><h4 id="MessageListener调用-RabbitListener注解方法处理消息的实现"><a href="#MessageListener调用-RabbitListener注解方法处理消息的实现" class="headerlink" title="MessageListener调用@RabbitListener注解方法处理消息的实现"></a>MessageListener调用@RabbitListener注解方法处理消息的实现</h4><p>上面的receiveAndExecute()方法接收消息的同时也将其处理了，继续跟踪，直到进入下面这个方法：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">executeListener</span><span class="params">(Channel channel, Message messageIn)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line"></span><br><span class="line">    ...</span><br><span class="line"></span><br><span class="line">    invokeListener(channel, message);</span><br><span class="line"></span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>在这个方法里面可以看到invokeListener()方法：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">   <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">invokeListener</span><span class="params">(Channel channel, Message message)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line"><span class="keyword">this</span>.proxy.invokeListener(channel, message);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里有个proxy，这个proxy是由下面这个方法创建的匿名类：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line">   <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">actualInvokeListener</span><span class="params">(Channel channel, Message message)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">Object listener = getMessageListener();</span><br><span class="line"><span class="keyword">if</span> (listener <span class="keyword">instanceof</span> ChannelAwareMessageListener) &#123;</span><br><span class="line">doInvokeListener((ChannelAwareMessageListener) listener, channel, message);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span> (listener <span class="keyword">instanceof</span> MessageListener) &#123;</span><br><span class="line"><span class="keyword">boolean</span> bindChannel = isExposeListenerChannel() &amp;&amp; isChannelLocallyTransacted();</span><br><span class="line"><span class="keyword">if</span> (bindChannel) &#123;</span><br><span class="line">RabbitResourceHolder resourceHolder = <span class="keyword">new</span> RabbitResourceHolder(channel, <span class="keyword">false</span>);</span><br><span class="line">resourceHolder.setSynchronizedWithTransaction(<span class="keyword">true</span>);</span><br><span class="line">TransactionSynchronizationManager.bindResource(<span class="keyword">this</span>.getConnectionFactory(),</span><br><span class="line">resourceHolder);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">doInvokeListener((MessageListener) listener, message);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">finally</span> &#123;</span><br><span class="line"><span class="keyword">if</span> (bindChannel) &#123;</span><br><span class="line"><span class="comment">// unbind if we bound</span></span><br><span class="line">TransactionSynchronizationManager.unbindResource(<span class="keyword">this</span>.getConnectionFactory());</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span> (listener != <span class="keyword">null</span>) &#123;</span><br><span class="line"><span class="keyword">throw</span> <span class="keyword">new</span> FatalListenerExecutionException(<span class="string">&quot;Only MessageListener and SessionAwareMessageListener supported: &quot;</span></span><br><span class="line">+ listener);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> &#123;</span><br><span class="line"><span class="keyword">throw</span> <span class="keyword">new</span> FatalListenerExecutionException(<span class="string">&quot;No message listener specified - see property &#x27;messageListener&#x27;&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure><p>这个方法里可以看到doInvokeListener()方法，已经差不多接近我们的@RabbitListener注解的方法了，继续跟踪：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">   <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">doInvokeListener</span><span class="params">(ChannelAwareMessageListener listener, Channel channel, Message message)</span></span></span><br><span class="line"><span class="function"><span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line"></span><br><span class="line">    ...</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">listener.onMessage(message, channelToUse);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line"><span class="keyword">throw</span> wrapToListenerExecutionFailedExceptionIfNeeded(e, message);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">...</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>跟踪listener.onMessage()方法，直到进入MessagingMessageListenerAdapter类的onMessage()方法：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">   <span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onMessage</span><span class="params">(org.springframework.amqp.core.Message amqpMessage, Channel channel)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">Message&lt;?&gt; message = toMessagingMessage(amqpMessage);</span><br><span class="line"><span class="keyword">if</span> (logger.isDebugEnabled()) &#123;</span><br><span class="line">logger.debug(<span class="string">&quot;Processing [&quot;</span> + message + <span class="string">&quot;]&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">Object result = invokeHandler(amqpMessage, channel, message);</span><br><span class="line"><span class="keyword">if</span> (result != <span class="keyword">null</span>) &#123;</span><br><span class="line">handleResult(result, amqpMessage, channel, message);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> &#123;</span><br><span class="line">logger.trace(<span class="string">&quot;No result object given - no result to handle&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">catch</span> (ListenerExecutionFailedException e) &#123;</span><br><span class="line"><span class="keyword">if</span> (<span class="keyword">this</span>.errorHandler != <span class="keyword">null</span>) &#123;</span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">Object result = <span class="keyword">this</span>.errorHandler.handleError(amqpMessage, message, e);</span><br><span class="line"><span class="keyword">if</span> (result != <span class="keyword">null</span>) &#123;</span><br><span class="line">handleResult(result, amqpMessage, channel, message);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> &#123;</span><br><span class="line">logger.trace(<span class="string">&quot;Error handler returned no result&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">catch</span> (Exception ex) &#123;</span><br><span class="line">returnOrThrow(amqpMessage, channel, message, ex, ex);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> &#123;</span><br><span class="line">returnOrThrow(amqpMessage, channel, message, e.getCause(), e);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>这里通过invokHandler()方法消费获取到的message，然后在catch里面处理异常，进入invokeHandler()方法：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> Object <span class="title">invokeHandler</span><span class="params">(org.springframework.amqp.core.Message amqpMessage, Channel channel,</span></span></span><br><span class="line"><span class="params"><span class="function">Message&lt;?&gt; message)</span> </span>&#123;</span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line"><span class="keyword">return</span> <span class="keyword">this</span>.handlerMethod.invoke(message, amqpMessage, channel);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">catch</span> (MessagingException ex) &#123;</span><br><span class="line"><span class="keyword">throw</span> <span class="keyword">new</span> ListenerExecutionFailedException(createMessagingErrorMessage(<span class="string">&quot;Listener method could not &quot;</span> +</span><br><span class="line"><span class="string">&quot;be invoked with the incoming message&quot;</span>, message.getPayload()), ex, amqpMessage);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">catch</span> (Exception ex) &#123;</span><br><span class="line"><span class="keyword">throw</span> <span class="keyword">new</span> ListenerExecutionFailedException(<span class="string">&quot;Listener method &#x27;&quot;</span> +</span><br><span class="line"><span class="keyword">this</span>.handlerMethod.getMethodAsString(message.getPayload()) + <span class="string">&quot;&#x27; threw exception&quot;</span>, ex, amqpMessage);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure><p>在这里可以看到catch了所有的异常，也就是说只要是我们消费消息的方法里面抛出来的异常全都会被包装成ListenerExecutionFailedException，并且这个Exception里面把消息也放进去了。</p><p>这里的this.handlerMethod其实就是上面提到的HandlerAdapter，跟踪它的invoke()方法，看它是怎么调用我们@RabbitListener注解的方法的。</p><p>最后我们跟踪到InvocableHandlerMethod类的下面这个方法：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">   <span class="meta">@Nullable</span></span><br><span class="line"><span class="function"><span class="keyword">protected</span> Object <span class="title">doInvoke</span><span class="params">(Object... args)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">ReflectionUtils.makeAccessible(getBridgedMethod());</span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line"><span class="keyword">return</span> getBridgedMethod().invoke(getBean(), args);</span><br><span class="line">&#125;</span><br><span class="line">...</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>这里通过getBridgedMethod()方法拿到的就是@RabbitListener注解的方法了，这是在刚开始处理@RabbitListener注解时就已经保存下来的，然后就可以利用反射来调用这个方法，这样就完成了接收并处理消息的整个流程。</p><h3 id="4-2-CachingConnectionFactory"><a href="#4-2-CachingConnectionFactory" class="headerlink" title="4.2 CachingConnectionFactory"></a>4.2 CachingConnectionFactory</h3><p>因为上一个项目中使用了RabbitMQ，但是当时没有考虑过性能的问题，今天觉得好像不对劲，大量的重复建立连接，造成了很大的性能浪费，于是我就找呀找，发现Spring提供了一种RabbitMQ连接池，所以今天我们来看一下它是如何设计的。</p><ul><li><p>CachingConnectionFactory</p><p>CachingConnectionFactory为我们提供了两种缓存的模式：</p><ul><li>CHANNEL模式：这也是CachingConnectionFactory的默认模式，在这种模式下，所有的createConnection（）方法实际上返回的都是同一个Connection，同样的Connection.close()方法是没用的，因为就一个，默认情况下，Connection中只缓存了一个Channel，在并发量不大的时候这种模式是完全够用的，当并发量较高的时候，我们可以setChannelCacheSize（）来增加Connection中缓存的Channel的数量。</li><li>CONNECTION模式：在CONNECTION模式下，每一次调用createConnection（）方法都会新建一个或者从缓存中获取，根据你设置的ConnectionCacheSize的大小，当小于的时候会采用新建的策略，当大于等于的时候会采用从缓存中获取的策略，与CHANNEL模式不同的是，CONNECTION模式对Connection和Channel都进行了缓存，最新版本的client中已经将Channel的缓存数量从1增加到了25，但是在并发量不是特别大的情况下，作用并不是特别明显。<br> <strong>使用CachingConnectionFactory需要注意的一点是：所有你获取的Channel对象必须要显式的关闭，所以finally中一定不要忘记释放资源，如果忘记释放，则可能造成连接池中没有资源可用</strong>。<br> 好了，我们来看一下创建Connection源码的实现：</li></ul></li><li><p>createConnection()</p></li></ul><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">    synchronized (<span class="keyword">this</span>.connectionMonitor) &#123;</span><br><span class="line"><span class="comment">// CHANNEL模式下，这里的connection是ChannelCachingConnectionProxy 代理对象</span></span><br><span class="line"><span class="comment">//这样做的目的是为Channel提供临时的存储空间（也就是缓存Channel），以便其他客户端调用 </span></span><br><span class="line">            <span class="keyword">if</span> (<span class="keyword">this</span>.cacheMode == CacheMode.CHANNEL) &#123;</span><br><span class="line"><span class="comment">//确保Connection对象不为null，target是真实的连接</span></span><br><span class="line">                <span class="keyword">if</span> (<span class="keyword">this</span>.connection.target == <span class="literal">null</span>) &#123;</span><br><span class="line"><span class="comment">//第一次调用 createConnection 方法时 connection.target 值为 null，因此会调用 createBareConnection 方法创建出 SimpleConnection 赋值给 connection.target</span></span><br><span class="line"><span class="comment">//SimpleConnection 中delegate属性是真正的RabbitMQ 连接（AMQConnection）</span></span><br><span class="line">                    <span class="keyword">this</span>.connection.target = <span class="keyword">super</span>.createBareConnection();</span><br><span class="line">                    <span class="comment">// invoke the listener *after* this.connection is assigned</span></span><br><span class="line">                    <span class="keyword">if</span> (!<span class="keyword">this</span>.checkoutPermits.containsKey(<span class="keyword">this</span>.connection)) &#123;</span><br><span class="line"><span class="comment">// Map&lt;Connection, Semaphore&gt; checkoutPermits 中存放了信道的许可数量，也就是默认的25，通过信号量来同步资源</span></span><br><span class="line">                        <span class="keyword">this</span>.checkoutPermits.put(<span class="keyword">this</span>.connection, new Semaphore(<span class="keyword">this</span>.channelCacheSize));</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="keyword">this</span>.connection.closeNotified.<span class="keyword">set</span>(<span class="literal">false</span>);</span><br><span class="line"><span class="comment">//向所有 ConnectionListener 发布 onCreate 事件</span></span><br><span class="line">                    getConnectionListener().onCreate(<span class="keyword">this</span>.connection);</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">this</span>.connection;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (<span class="keyword">this</span>.cacheMode == CacheMode.CONNECTION) &#123;</span><br><span class="line"><span class="comment">//直接从缓存中获取</span></span><br><span class="line">                <span class="keyword">return</span> connectionFromCache();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br></pre></td></tr></table></figure><p>创建Channel的源码实现：</p><ul><li>createChannel（）</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line">        Semaphore permits = null;</span><br><span class="line">//大于0的情况下才会通过 Semaphore 限制当前连接下可用的信道数量</span><br><span class="line">        if (this.channelCheckoutTimeout &gt; 0) &#123;</span><br><span class="line">//获取许可</span><br><span class="line">            permits = obtainPermits(connection);</span><br><span class="line">        &#125;</span><br><span class="line">//获取当前Connection的Channel代理集合</span><br><span class="line">        LinkedList&lt;ChannelProxy&gt; channelList = determineChannelList(connection, transactional);</span><br><span class="line">        ChannelProxy channel = null;</span><br><span class="line">        if (connection.isOpen()) &#123;</span><br><span class="line">//这里主要是从缓存中获取，在同步块中，先判断 channelList 是否为空，若不为空，则返回队列头部缓存的 ChannelProxy（要从队列中移除）。</span><br><span class="line">//如果没有可用的缓存信道，则通过 getCachedChannelProxy 方法创建新的 ChannelProxy。</span><br><span class="line">            channel = findOpenChannel(channelList, channel);</span><br><span class="line">            if (channel != null) &#123;</span><br><span class="line">                if (logger.isTraceEnabled()) &#123;</span><br><span class="line">                    logger.trace(&quot;Found cached Rabbit Channel: &quot; + channel.toString());</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        if (channel == null) &#123;</span><br><span class="line">            try &#123;</span><br><span class="line">//创建新Channel 的过程</span><br><span class="line">                channel = getCachedChannelProxy(connection, channelList, transactional);</span><br><span class="line">            &#125;</span><br><span class="line">            catch (RuntimeException e) &#123;</span><br><span class="line">                if (permits != null) &#123;</span><br><span class="line">                    permits.release();</span><br><span class="line">                    if (logger.isDebugEnabled()) &#123;</span><br><span class="line">                        logger.debug(&quot;Could not get channel; released permit for &quot; + connection + &quot;, remaining:&quot;</span><br><span class="line">                                + permits.availablePermits());</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">                throw e;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        return channel;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">    <span class="function"><span class="keyword">private</span> ChannelProxy <span class="title">getCachedChannelProxy</span><span class="params">(ChannelCachingConnectionProxy connection,</span></span></span><br><span class="line"><span class="params"><span class="function">            LinkedList&lt;ChannelProxy&gt; channelList, <span class="keyword">boolean</span> transactional)</span> </span>&#123; <span class="comment">//NOSONAR LinkedList for addLast()</span></span><br><span class="line"><span class="comment">//通过Connection中delegate创建Channel对象</span></span><br><span class="line">        Channel targetChannel = createBareChannel(connection, transactional);</span><br><span class="line">        <span class="keyword">if</span> (logger.isDebugEnabled()) &#123;</span><br><span class="line">            logger.debug(<span class="string">&quot;Creating cached Rabbit Channel from &quot;</span> + targetChannel);</span><br><span class="line">        &#125;</span><br><span class="line"><span class="comment">//向所有 ChannelListener 发布 onCreate 事件</span></span><br><span class="line">        getChannelListener().onCreate(targetChannel, transactional);</span><br><span class="line">        Class&lt;?&gt;[] interfaces;</span><br><span class="line"><span class="comment">//通过 Proxy.newProxyInstance创建一个实现了ChannelProxy接口的动态代理对象。</span></span><br><span class="line"><span class="comment">//所有对该实例的方法调用都会转交给CachedChannelInvocationHandler 的 invoke 方法处理</span></span><br><span class="line">        <span class="keyword">if</span> (<span class="keyword">this</span>.publisherConfirms || <span class="keyword">this</span>.publisherReturns) &#123;</span><br><span class="line">            interfaces = <span class="keyword">new</span> Class&lt;?&gt;[] &#123; ChannelProxy.class, PublisherCallbackChannel.class &#125;;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            interfaces = <span class="keyword">new</span> Class&lt;?&gt;[] &#123; ChannelProxy.class &#125;;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> (ChannelProxy) Proxy.newProxyInstance(ChannelProxy.class.getClassLoader(),</span><br><span class="line">                interfaces, <span class="keyword">new</span> CachedChannelInvocationHandler(connection, targetChannel, channelList,</span><br><span class="line">                        transactional));</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><h2 id="五-案例"><a href="#五-案例" class="headerlink" title="五. 案例"></a>五. 案例</h2><h3 id="5-1-自动重连"><a href="#5-1-自动重连" class="headerlink" title="5.1 自动重连"></a>5.1 自动重连</h3><p>Spring AMQP提供了一些高级特性来解决协议错误或者代理失败发生时的恢复与自动重连：</p><ul><li>主要通过CachingConnectionFactory来实现；</li><li>使用RabbitAdmin进行自动声明也很有用处；</li><li>如果你比较在乎发送的质量，以也许会使用RabbitTemplate和SimpleMessageListenerContainer的channelTransacted属性，还有 SimpleMessageListenerContainer的Acknowledge.AUTO属性。</li></ul><p>自动声明交换器、队列和绑定：</p><ul><li>RabbitAdmin在启动的时候会声明exchange，queues和binding。它是延迟完成的，是在ConnectionListener中，所以如果在应用启动的时候消息代理不可用也没关系。</li><li>Connection被第一次使用的时候，监听器会被触发，admin这一特色会被应用。</li><li>监听器中的自动声明的另外一个好处是如果连接由于某种原因断了(代理挂掉，或者网络失灵)，下次连接时候它又会被启用。</li><li>注意：以这种方式启动队列必须要有固定的名称。要么显示声明，要么通过框架为AnonymousQueues自动生成。 AnonymousQueues不可以持久化，专属的，自动删除。</li><li>重点：自动声明只能在CachingConnectionFactory缓存模式是CHANNEL时候启用。这个限制的存在是因为专属的或者自动删除的队列和连接绑定。</li></ul><p>同步操作失败和重试选项：</p><ul><li>如果在使用RabbitTemplate同步操作的过程中丢失了到代理的连接，Spring AMQP会抛出AmqpException(通常是AmqpIOException)。</li><li>所以我们不会隐藏这一问题，所以你必须能够捕获并且响应这一异常。最简单处理方式是你认为连接断开，不是你这面的问题，重试这些操作。你可以手动的做这些，或者你可以使用Spring Retry来完成这些。</li><li>Spring Retry提供了一些AOP拦截器，重试的许多参数来简化重试。</li><li>Spring AMQP也提供了一些工厂来方便Spring Retry的创建。给你提供了强类型回调接口来实现定制的恢复逻辑。参看StatefulRetryOperationsInterceptor和StatelessRetryOperationsInterceptor获得更详细的说明。</li><li>如果没有事务或者事务在重试回调中，无状态重试就可以。</li><li>对于存在正在进行的事务或者要进行回滚，无状态重试并不适合。</li><li>在事务之间断开连接和事务回滚有着同样的效果，在这种情况下，有状态重试是最佳选择。</li></ul><p>从1.3版本开始，一个创建器API提供来用于装配拦截器：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Bean</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> StatefulRetryOperationsInterceptor <span class="title">interceptor</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> RetryInterceptorBuilder.stateful()</span><br><span class="line">        .maxAttempts(<span class="number">5</span>)</span><br><span class="line">        .backOffOptions(<span class="number">1000</span>, <span class="number">2.0</span>, <span class="number">10000</span>) <span class="comment">// initialInterval, multiplier, maxInterval</span></span><br><span class="line">        .build();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>只有重试的一部分功能可以通过这种方式来配置，如果需要更为高级的功能，你可以通过RetryTemplate来完成。</p><p>报文监听器和异步场景：</p><ul><li>如果MessageListener由于业务而失败而抛出异常，那么这个异常将会被消息监听器容器处理，接着它会处理另外一条消息。</li><li>如果这个错误是因为连接断开导致，那么接收消息的消费者必须必须取消并且重新启动。SimpleMessageListenerContainer无缝的处理了这些，并且记录了监听器被重新启动的日志。事实上，它会进行无限的反复尝试来启动这个消费者，如果消费者行为很糟糕否则它不会放弃。一个副作用是如果代理挂掉，它会不断尝试直到连接重新建立。</li><li>业务异常的处理和协议错误，连接断开的处理不一样，需要更多的考虑或者配置，尤其是在事务或者容器应答被启用的时候。在RabbitMQ2.8.x版本以前，对于dead letter没有明确的定义，所以因为业务处理异常而导致的拒绝或者回滚将导致消息被无限的发送下去。为了限制客户端重新发送的数目，以种选择是在监听器上使用 StatefulRetryOperationsInterceptor拦截器增强。这个监听器有一个恢复回调，这个回调中实现dead letter的行为。</li><li>另外一种处理方式，是设置rejectRqueued属性为false，这将导致所有的错误消息被丢弃。当RabbitMQ的版本是2.8.x或者是更高,这将使得消息转发到Dead Letter Exchange。</li><li>或者你可以抛出AmqpRejectAndDontRequeueException，这样阻止消息被重新塞入队列，不管defaultRequeueRejected是否设置。</li></ul><p>通常，两种技术可以结合使用。在增强链中使用StatefulRetryOperationsInterceptor，它的MessageRecover会抛出AmqpRejectAndDontRequeueException异常。如果尝试已经耗尽 MessageRecover将会被调用。默认的 MessageRecover简单的消费错误的消息，并且释放出警告信息。在这种情况下，消息得到了应答，但是不会被发送到Dead Letter Exchange。</p><p>从1.3版本开始，RepublishMessageRecoverer被提供在重试耗尽的情况下，来重新发布消息。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Bean</span></span><br><span class="line"><span class="function">RetryOperationsInterceptor <span class="title">interceptor</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> RetryInterceptorBuilder.stateless()</span><br><span class="line">        .withMaxAttempts(<span class="number">5</span>)</span><br><span class="line">        .setRecoverer(newRepublishMessageRecoverer(amqpTemplate(), <span class="string">&quot;bar&quot;</span>, <span class="string">&quot;baz&quot;</span>))</span><br><span class="line">        .build();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>重试异常分类： </p><ul><li>Spring Retry拥有很大的灵活性来决定什么样的异常可以出发重试。默认的情况下，所有的异常都会出发重试。在用户异常被包装在ListenerExecutionFailedException里面的情况下，我们需要分类器检测到异常起因。默认情况下，分类器只查看顶级异常。</li><li>自从Spring1.0.3开始，分类器BinaryExceptionClassifier有一个traverseCauses属性。当设置为true时，它将横向查找匹配的异常源。</li><li>为了使用这个分类器进行重试，使用SimpleRetryPolicy，它的构造函数中有最大尝试次数，异常Map，还有 traverseCauses选项。你需要将这个策略注入到RetryTemplate中。</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ConsumerRabbitConfig</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Bean(name = &quot;consumerConnectionFactory&quot;)</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> CustomCachingConnectionFactory <span class="title">consumerConnectionFactory</span><span class="params">(<span class="meta">@Value(&quot;$&#123;spring.rabbitmq.consumer.addresses&#125;&quot;)</span> String addresses,</span></span></span><br><span class="line"><span class="params"><span class="function">                                                       <span class="meta">@Value(&quot;$&#123;spring.rabbitmq.consumer.username&#125;&quot;)</span> String username,</span></span></span><br><span class="line"><span class="params"><span class="function">                                                       <span class="meta">@Value(&quot;$&#123;spring.rabbitmq.consumer.password&#125;&quot;)</span> String password,</span></span></span><br><span class="line"><span class="params"><span class="function">                                                       <span class="meta">@Value(&quot;$&#123;spring.rabbitmq.consumer.virtual-host&#125;&quot;)</span> String virtualHost)</span> </span>&#123;</span><br><span class="line">        CustomCachingConnectionFactory connectionFactory = <span class="keyword">new</span> CustomCachingConnectionFactory();</span><br><span class="line">        connectionFactory.setAddresses(addresses);</span><br><span class="line">        connectionFactory.setUsername(username);</span><br><span class="line">        connectionFactory.setPassword(password);</span><br><span class="line">        connectionFactory.setVirtualHost(virtualHost);</span><br><span class="line">        connectionFactory.setPublisherConfirms(<span class="keyword">true</span>);</span><br><span class="line">        connectionFactory.setConnectionListeners(Arrays.asList(<span class="keyword">new</span> ConnectionListener() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onCreate</span><span class="params">(Connection connection)</span> </span>&#123;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    logger.info(<span class="string">&quot;**********************创建rabbitmq链接:&#123;&#125;&quot;</span>, connectionFactory.getReBindings().size());</span><br><span class="line">                    Channel channel = connectionFactory.createConnection().createChannel(<span class="keyword">false</span>);</span><br><span class="line">                    <span class="keyword">for</span> (CustomCachingConnectionFactory.ReBindingHandler reBinding : connectionFactory.getReBindings()) &#123;</span><br><span class="line">                        reBinding.reBinding(channel);</span><br><span class="line">                    &#125;</span><br><span class="line">                    channel.close();</span><br><span class="line">                &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125; <span class="keyword">catch</span> (TimeoutException e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onClose</span><span class="params">(Connection connection)</span> </span>&#123;</span><br><span class="line">                logger.info(<span class="string">&quot;----------------rabbitmq链接断开&quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;));</span><br><span class="line">        <span class="keyword">return</span> connectionFactory;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">CustomCachingConnectionFactory</span> <span class="keyword">extends</span> <span class="title">CachingConnectionFactory</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> List&lt;ReBindingHandler&gt; reBindings = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> List&lt;ReBindingHandler&gt; <span class="title">getReBindings</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> reBindings;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">CustomCachingConnectionFactory</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">addReBindingHandler</span><span class="params">(ReBindingHandler reBindingHandler)</span></span>&#123;</span><br><span class="line">        reBindings.add(reBindingHandler);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">ReBindingHandler</span> </span>&#123;</span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">         * 重新绑定队列，路由键绑定关系</span></span><br><span class="line"><span class="comment">         * <span class="doctag">@param</span> channel</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        <span class="function"><span class="keyword">void</span> <span class="title">reBinding</span><span class="params">(Channel channel)</span></span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Queue1ConsumerConfig</span> </span>&#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 消费者最小个数</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Value(&quot;$&#123;spring.rabbitmq.minnum.task.consumers&#125;&quot;)</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> minNumConsumers;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 消费者最大个数</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Value(&quot;$&#123;spring.rabbitmq.maxnum.task.consumers&#125;&quot;)</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> maxNumConsumers;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 交换器名称</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> String EXCHANGE = <span class="string">&quot;exchange&quot;</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 队列名称</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> String QUEUE = <span class="string">&quot;queue1&quot;</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 队列路由键值</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> String ROUTING_KEY = <span class="string">&quot;routing1&quot;</span>;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Bean(name = &quot;queue1ConsumerRabbitTemplate&quot;)</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> RabbitTemplate <span class="title">queue1ConsumerRabbitTemplate</span><span class="params">(</span></span></span><br><span class="line"><span class="params"><span class="function">            <span class="meta">@Qualifier(&quot;consumerConnectionFactory&quot;)</span> CustomCachingConnectionFactory connectionFactory)</span> </span>&#123;</span><br><span class="line">        RabbitTemplate clientRabbitTemplate = <span class="keyword">new</span> RabbitTemplate(connectionFactory);</span><br><span class="line">        Connection connection = <span class="keyword">null</span>;</span><br><span class="line">        Channel channel = <span class="keyword">null</span>;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            clientRabbitTemplate.setExchange(FUND_TASK_EXCHANGE);</span><br><span class="line">            connection = clientRabbitTemplate.getConnectionFactory().createConnection();</span><br><span class="line">            channel = connection.createChannel(<span class="keyword">false</span>);</span><br><span class="line">            beding(channel);</span><br><span class="line">            connectionFactory.addReBindingHandler((newchannel) -&gt; beding(newchannel));</span><br><span class="line">            logger.info(<span class="string">&quot;RabbitMQ连接成功(queue1)： exchange:&#123;&#125; queue:&#123;&#125; routing:&#123;&#125;&quot;</span>, EXCHANGE, ROUTING_KEY, ROUTING_KEY);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (AmqpException e) &#123;</span><br><span class="line">            logger.error(<span class="string">&quot;RabbitMQ连接异常(queue1)&quot;</span>, e);</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                <span class="keyword">if</span> (channel != <span class="keyword">null</span>) &#123;</span><br><span class="line">                    channel.close();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; <span class="keyword">catch</span> (IOException | TimeoutException e) &#123;</span><br><span class="line">                logger.error(<span class="string">&quot;RabbitMQ关闭异常(queue1)&quot;</span>, e);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (connection != <span class="keyword">null</span>) &#123;</span><br><span class="line">                connection.close();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> clientRabbitTemplate;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">beding</span><span class="params">(Channel channel)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            channel.exchangeDeclare(EXCHANGE, <span class="string">&quot;topic&quot;</span>, <span class="keyword">false</span>);</span><br><span class="line">            channel.queueDeclare(QUEUE, <span class="keyword">true</span>, <span class="keyword">false</span>, <span class="keyword">false</span>, <span class="keyword">null</span>);</span><br><span class="line">            channel.queueBind(QUEUE, EXCHANGE, ROUTING_KEY);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">            logger.error(<span class="string">&quot;RabbitMQ操作错误(queue1)&quot;</span>, e);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Bean(name = &quot;queue1ConsumerListenerContainerFactory&quot;)</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> SimpleRabbitListenerContainerFactory <span class="title">queue1ConsumerListenerContainerFactory</span><span class="params">(SimpleRabbitListenerContainerFactoryConfigurer configurer,</span></span></span><br><span class="line"><span class="params"><span class="function">                                                                                        <span class="meta">@Qualifier(&quot;consumerConnectionFactory&quot;)</span> ConnectionFactory connectionFactory)</span> </span>&#123;</span><br><span class="line">        SimpleRabbitListenerContainerFactory factory = <span class="keyword">new</span> SimpleRabbitListenerContainerFactory();</span><br><span class="line">        factory.setConcurrentConsumers(minNumConsumers);</span><br><span class="line">        factory.setMaxConcurrentConsumers(maxNumConsumers);</span><br><span class="line">        configurer.configure(factory, connectionFactory);</span><br><span class="line">        <span class="keyword">return</span> factory;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Queue1Consumer <span class="title">queue1Consumer</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> Queue1Consumer();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="5-2-解决消息幂等性问题"><a href="#5-2-解决消息幂等性问题" class="headerlink" title="5.2 解决消息幂等性问题"></a>5.2 解决消息幂等性问题</h3><p>MQ消费者的幂等性问题，在于MQ的重试机制，因为网络原因或客户端延迟消费导致重复消费。</p><h4 id="5-2-1-RabbitMQ自动重试机制"><a href="#5-2-1-RabbitMQ自动重试机制" class="headerlink" title="5.2.1 RabbitMQ自动重试机制"></a>5.2.1 RabbitMQ自动重试机制</h4><p>消费者在消费消息的时候，如果消费者业务逻辑出现程序异常，这个时候我们如何处理？</p><ul><li>使用重试机制，RabbitMQ默认开启重试机制。</li></ul><p>实现原理：</p><ul><li><code>@RabbitHandler</code> 注解底层使用Aop拦截，如果程序（消费者）没有抛出异常，自动提交事务。</li><li>如果Aop使用异常通知拦截获取到异常后，自动实现补偿机制，消息缓存在RabbitMQ服务器端。</li></ul><p>注意：</p><ul><li>默认会一直重试到消费者不抛异常为止，这样显然不好。我们需要修改重试机制策略，如间隔3s重试一次)</li></ul><p>配置：</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">spring:</span></span><br><span class="line">  <span class="attr">rabbitmq:</span></span><br><span class="line">    <span class="comment"># 连接地址</span></span><br><span class="line">    <span class="attr">host:</span> <span class="number">127.0</span><span class="number">.0</span><span class="number">.1</span></span><br><span class="line">    <span class="comment"># 端口号</span></span><br><span class="line">    <span class="attr">port:</span> <span class="number">5672</span></span><br><span class="line">    <span class="comment"># 账号</span></span><br><span class="line">    <span class="attr">username:</span> <span class="string">guest</span></span><br><span class="line">    <span class="comment"># 密码</span></span><br><span class="line">    <span class="attr">password:</span> <span class="string">guest</span></span><br><span class="line">    <span class="comment"># 地址(类似于数据库的概念)</span></span><br><span class="line">    <span class="attr">virtual-host:</span> <span class="string">/admin_vhost</span></span><br><span class="line">    <span class="comment"># 消费者监听相关配置</span></span><br><span class="line">    <span class="attr">listener:</span></span><br><span class="line">      <span class="attr">simple:</span></span><br><span class="line">        <span class="attr">retry:</span></span><br><span class="line">          <span class="comment"># 开启消费者(程序出现异常)重试机制，默认开启并一直重试</span></span><br><span class="line">          <span class="attr">enabled:</span> <span class="literal">true</span></span><br><span class="line">          <span class="comment"># 最大重试次数</span></span><br><span class="line">          <span class="attr">max-attempts:</span> <span class="number">5</span></span><br><span class="line">          <span class="comment"># 重试间隔时间(毫秒)</span></span><br><span class="line">          <span class="attr">initial-interval:</span> <span class="number">3000</span></span><br></pre></td></tr></table></figure><h4 id="5-2-2-如何合理选择重试机制？"><a href="#5-2-2-如何合理选择重试机制？" class="headerlink" title="5.2.2 如何合理选择重试机制？"></a>5.2.2 如何合理选择重试机制？</h4><ul><li>情况1：消费者获取到消息后，调用第三方接口，但接口暂时无法访问，是否需要重试？<ul><li>需要重试，可能是因为网络原因短暂不能访问。</li></ul></li><li>情况2：消费者获取到消息后，抛出数据转换异常，是否需要重试？<ul><li>不需要重试，因为属于程序bug，需要重新发布版本。</li></ul></li></ul><p>对于情况2，如果消费者代码抛出异常是需要发布新版本才能解决的问题，那么不需要重试，重试也无济于事。应该采用<strong>日志记录 + 定时任务job进行健康检查 + 人工进行补偿</strong>。</p><h4 id="5-2-3-调用第三方接口自动实现补偿机制"><a href="#5-2-3-调用第三方接口自动实现补偿机制" class="headerlink" title="5.2.3 调用第三方接口自动实现补偿机制"></a>5.2.3 调用第三方接口自动实现补偿机制</h4><p>我们知道RabbitMQ在消费者消费发生异常时，会自动进行补偿机制，所以我们（消费者）在调用第三方接口时，可以根据返回结果判断是否成功：</p><ul><li>成功：正常消费</li><li>失败：手动抛处一个异常，这时RabbitMQ自动给我们做重试 (补偿)。</li></ul><h4 id="5-2-4-如何解决消费者幂等性问题，防止重复消费"><a href="#5-2-4-如何解决消费者幂等性问题，防止重复消费" class="headerlink" title="5.2.4 如何解决消费者幂等性问题，防止重复消费"></a>5.2.4 如何解决消费者幂等性问题，防止重复消费</h4><ul><li>产生原因：网络延迟传输中，消费者出现异常或者消费者延迟消费，会造成进行MQ重试补偿，在重试过程中，可能会造成重复消费。</li><li>解决方案：<ol><li>使用全局MessageID判断消费者是否消费过，解决幂等性。</li><li>通过业务逻辑保证唯一，如订单编号。</li></ol></li></ul><p>生产者核心代码:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">FanoutProducer</span> </span>&#123;</span><br><span class="line"><span class="meta">@Autowired</span></span><br><span class="line"><span class="keyword">private</span> AmqpTemplate amqpTemplate;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">send</span><span class="params">(String queueName)</span> </span>&#123;</span><br><span class="line">String msg = <span class="string">&quot;my_fanout_msg:&quot;</span> + System.currentTimeMillis();</span><br><span class="line"><span class="comment">//请求头设置消息id（messageId）</span></span><br><span class="line">Message message = MessageBuilder.withBody(msg.getBytes()).setContentType(MessageProperties.CONTENT_TYPE_JSON)</span><br><span class="line">.setContentEncoding(<span class="string">&quot;utf-8&quot;</span>).setMessageId(UUID.randomUUID() + <span class="string">&quot;&quot;</span>).build();</span><br><span class="line">System.out.println(msg + <span class="string">&quot;:&quot;</span> + msg);</span><br><span class="line">amqpTemplate.convertAndSend(queueName, message);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>消费者核心代码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@RabbitListener(queues = &quot;fanout_email_queue&quot;)</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">process</span><span class="params">(Message message)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line"><span class="comment">// 获取消息Id</span></span><br><span class="line">String messageId = message.getMessageProperties().getMessageId();</span><br><span class="line">String msg = <span class="keyword">new</span> String(message.getBody(), <span class="string">&quot;UTF-8&quot;</span>);</span><br><span class="line"><span class="comment">//② 判断唯一Id是否被消费，消息消费成功后将id和状态保存在日志表中，我们从（①步骤）表中获取并判断messageId的状态即可</span></span><br><span class="line"><span class="comment">//从redis中获取messageId的value</span></span><br><span class="line">String value = redisUtils.get(messageId)+<span class="string">&quot;&quot;</span>;</span><br><span class="line"><span class="keyword">if</span>(value.equals(<span class="string">&quot;1&quot;</span>) )&#123; <span class="comment">//表示已经消费</span></span><br><span class="line"><span class="keyword">return</span>; <span class="comment">//结束</span></span><br><span class="line">&#125;</span><br><span class="line">System.out.println(<span class="string">&quot;邮件消费者获取生产者消息&quot;</span> + <span class="string">&quot;messageId:&quot;</span> + messageId + <span class="string">&quot;,消息内容:&quot;</span> + msg);</span><br><span class="line">JSONObject jsonObject = JSONObject.parseObject(msg);</span><br><span class="line"><span class="comment">// 获取email参数</span></span><br><span class="line">String email = jsonObject.getString(<span class="string">&quot;email&quot;</span>);</span><br><span class="line"><span class="comment">// 请求地址</span></span><br><span class="line">String emailUrl = <span class="string">&quot;http://127.0.0.1:8083/sendEmail?email=&quot;</span> + email;</span><br><span class="line">JSONObject result = HttpClientUtils.httpGet(emailUrl);</span><br><span class="line"><span class="keyword">if</span> (result == <span class="keyword">null</span>) &#123;</span><br><span class="line"><span class="comment">// 因为网络原因,造成无法访问,继续重试</span></span><br><span class="line"><span class="keyword">throw</span> <span class="keyword">new</span> Exception(<span class="string">&quot;调用接口失败!&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line">System.out.println(<span class="string">&quot;执行结束....&quot;</span>);</span><br><span class="line"><span class="comment">//① 执行到这里已经消费成功，我们可以修改messageId的状态，并存入日志表(可以存到redis中，key为消息Id、value为状态)</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="5-2-5-SpringBoot整合RabbitMQ应答模式-ACK"><a href="#5-2-5-SpringBoot整合RabbitMQ应答模式-ACK" class="headerlink" title="5.2.5 SpringBoot整合RabbitMQ应答模式(ACK)"></a>5.2.5 SpringBoot整合RabbitMQ应答模式(ACK)</h4><p>修改配置simple下添加 <code>acknowledge-mode: manual</code> ：</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">spring:</span></span><br><span class="line">  <span class="attr">rabbitmq:</span></span><br><span class="line">    <span class="comment"># 连接地址</span></span><br><span class="line">    <span class="attr">host:</span> <span class="number">127.0</span><span class="number">.0</span><span class="number">.1</span></span><br><span class="line">    <span class="comment"># 端口号</span></span><br><span class="line">    <span class="attr">port:</span> <span class="number">5672</span></span><br><span class="line">    <span class="comment"># 账号</span></span><br><span class="line">    <span class="attr">username:</span> <span class="string">guest</span></span><br><span class="line">    <span class="comment"># 密码</span></span><br><span class="line">    <span class="attr">password:</span> <span class="string">guest</span></span><br><span class="line">    <span class="comment"># 地址(类似于数据库的概念)</span></span><br><span class="line">    <span class="attr">virtual-host:</span> <span class="string">/admin_vhost</span></span><br><span class="line">    <span class="comment"># 消费者监听相关配置</span></span><br><span class="line">    <span class="attr">listener:</span></span><br><span class="line">      <span class="attr">simple:</span></span><br><span class="line">        <span class="attr">retry:</span></span><br><span class="line">          <span class="comment"># 开启消费者(程序出现异常)重试机制，默认开启并一直重试</span></span><br><span class="line">          <span class="attr">enabled:</span> <span class="literal">true</span></span><br><span class="line">          <span class="comment"># 最大重试次数</span></span><br><span class="line">          <span class="attr">max-attempts:</span> <span class="number">5</span></span><br><span class="line">          <span class="comment"># 重试间隔时间(毫秒)</span></span><br><span class="line">          <span class="attr">initial-interval:</span> <span class="number">3000</span></span><br><span class="line">        <span class="comment"># 开启手动ack</span></span><br><span class="line">        <span class="attr">acknowledge-mode:</span> <span class="string">manual</span></span><br></pre></td></tr></table></figure><p>消费者增加代码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Long deliveryTag = (Long) headers.get(AmqpHeaders.DELIVERY_TAG); <span class="comment">// 手动ack</span></span><br><span class="line">channel.basicAck(deliveryTag, <span class="keyword">false</span>); <span class="comment">//手动签收</span></span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//邮件队列</span></span><br><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">FanoutEamilConsumer</span> </span>&#123;</span><br><span class="line"><span class="meta">@RabbitListener(queues = &quot;fanout_email_queue&quot;)</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">process</span><span class="params">(Message message, <span class="meta">@Headers</span> Map&lt;String, Object&gt; headers, Channel channel)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">System.out</span><br><span class="line">.println(Thread.currentThread().getName() + <span class="string">&quot;,邮件消费者获取生产者消息msg:&quot;</span> + <span class="keyword">new</span> String(message.getBody(), <span class="string">&quot;UTF-8&quot;</span>)</span><br><span class="line">+ <span class="string">&quot;,messageId:&quot;</span> + message.getMessageProperties().getMessageId());</span><br><span class="line"><span class="comment">// 手动ack</span></span><br><span class="line">Long deliveryTag = (Long) headers.get(AmqpHeaders.DELIVERY_TAG);</span><br><span class="line"><span class="comment">// 手动签收</span></span><br><span class="line">channel.basicAck(deliveryTag, <span class="keyword">false</span>);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="5-3-限流"><a href="#5-3-限流" class="headerlink" title="5.3 限流"></a>5.3 限流</h3><p><strong>应用场景</strong>：如电商系统的抢购，瞬间有巨大流量生成，通过消息队列先进先出的特性，对请求进行削峰，控制消费的速度（限流）避免系统被挤爆。</p><h4 id="（1）通过配置文件实现"><a href="#（1）通过配置文件实现" class="headerlink" title="（1）通过配置文件实现"></a>（1）通过配置文件实现</h4><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">spring:</span></span><br><span class="line">  <span class="attr">rabbitmq:</span></span><br><span class="line">    <span class="attr">listener:</span></span><br><span class="line">      <span class="attr">simple:</span></span><br><span class="line">        <span class="attr">concurrency:</span> <span class="number">5</span></span><br><span class="line">        <span class="attr">max-concurrency:</span> <span class="number">10</span></span><br></pre></td></tr></table></figure><h4 id="（2）-RabbitListener"><a href="#（2）-RabbitListener" class="headerlink" title="（2）@RabbitListener"></a>（2）@RabbitListener</h4><p>利用 <code>@RabbitListener</code> 中的 <code>concurrency</code> 属性进行指定。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SpringBootMsqConsumer</span> </span>&#123;</span><br><span class="line">    <span class="meta">@RabbitListener(queues = &quot;spring-boot-direct-queue&quot;,concurrency = &quot;5-10&quot;)</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">receive</span><span class="params">(Message message)</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;receive message:&quot;</span> + <span class="keyword">new</span> String(message.getBody()));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>最小5个，最大10个消费者。</p><p>单个消费者如果收到消息过多也可能存在风险，可以通过设置预取 <code>prefetch count</code> 来控制。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SpringBootMsqConsumer</span> </span>&#123;</span><br><span class="line">    <span class="meta">@RabbitListener(queues = &quot;spring-boot-direct-queue&quot;,concurrency = &quot;5-10&quot;,containerFactory = &quot;mqConsumerlistenerContainer&quot;)</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">receive</span><span class="params">(Message message)</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;receive message:&quot;</span> + <span class="keyword">new</span> String(message.getBody()));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">RabbitMqConfig</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> CachingConnectionFactory connectionFactory;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Bean(name = &quot;mqConsumerlistenerContainer&quot;)</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> SimpleRabbitListenerContainerFactory <span class="title">mqConsumerlistenerContainer</span><span class="params">()</span></span>&#123;</span><br><span class="line">        SimpleRabbitListenerContainerFactory factory = <span class="keyword">new</span> SimpleRabbitListenerContainerFactory();</span><br><span class="line">        factory.setConnectionFactory(connectionFactory);</span><br><span class="line">        factory.setPrefetchCount(<span class="number">50</span>);</span><br><span class="line">        <span class="keyword">return</span> factory;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>配置成功后，<code>consumer</code> 单位时间内接收到消息就是50条。</p><hr><p>参考：</p><p>🔗 《<a href="https://www.docs4dev.com/docs/zh/spring-amqp/2.1.2.RELEASE/reference/_reference.html">Spring AMQP 中文文档</a>》</p><p>🔗 《<a href="https://blog.csdn.net/weixin_38380858/article/details/84258507">Spring整合rabbitmq实践（一）：基础使用配置</a>》</p><p>🔗 《<a href="https://blog.csdn.net/weixin_38380858/article/details/84258658">Spring整合rabbitmq实践（二）：扩展功能</a>》</p><p>🔗 《<a href="https://blog.csdn.net/qq_38252039/article/details/91409955">RabbitMQ解决消息幂等性问题</a>》</p><p>🔗 《<a href="https://blog.csdn.net/weixin_38380858/article/details/84963944">spring-rabbit消费过程解析及AcknowledgeMode选择</a>》</p><p>🔗 《<a href="https://www.jianshu.com/p/2e90f9070995">RabbitMQ连接池——CachingConnectionFactory</a>》</p>]]></content>
    
    
    <summary type="html">整理Spring AMQP相关文档。</summary>
    
    
    
    <category term="技术文档" scheme="http://linyishui.top/categories/%E6%8A%80%E6%9C%AF%E6%96%87%E6%A1%A3/"/>
    
    
    <category term="spring" scheme="http://linyishui.top/tags/spring/"/>
    
    <category term="distributed" scheme="http://linyishui.top/tags/distributed/"/>
    
    <category term="mom" scheme="http://linyishui.top/tags/mom/"/>
    
    <category term="rabbitmq" scheme="http://linyishui.top/tags/rabbitmq/"/>
    
    <category term="amqp" scheme="http://linyishui.top/tags/amqp/"/>
    
  </entry>
  
  <entry>
    <title>RabbitMQ（十）扩展-消息追踪和负载均衡</title>
    <link href="http://linyishui.top/2021092501.html"/>
    <id>http://linyishui.top/2021092501.html</id>
    <published>2021-09-25T06:16:34.000Z</published>
    <updated>2021-11-04T10:54:38.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="RabbitMQ（十）扩展"><a href="#RabbitMQ（十）扩展" class="headerlink" title="RabbitMQ（十）扩展"></a>RabbitMQ（十）扩展</h1><h2 id="一-消息追踪"><a href="#一-消息追踪" class="headerlink" title="一. 消息追踪"></a>一. 消息追踪</h2><p>使用消息中间件过程难免会遇到消息丢失的情况：</p><ul><li>可能是生产者与Broker断开了连接并且也没有任何重试机制；</li><li>可能是消费者在处理消息时发生了异常，但提前进行了ack；</li><li>可能是交换器没有与任何队列进行绑定，生产者感知不到或未采取相应的措施；</li><li>可能是RabbitMQ本身的集群策略导致消息的丢失。</li></ul><p>需要有一个好的机制来跟踪记录消息的投递过程，方便开发和运维人员快速定位问题。</p><h3 id="1-1-Firehose"><a href="#1-1-Firehose" class="headerlink" title="1.1 Firehose"></a>1.1 Firehose</h3><p>Firehose可以记录每一次发送或消费消息的记录。原理是将生产者投递给MQ的消息或MQ投递给消费者的消息按指定的格式发送到默认交换器 <code>amq.rabbitmq.trace</code> 上（topic类型）。路由键为 <code>publish.&#123;exchangename&#125;</code> 和 <code>deliver.&#123;queuename&#125;</code> 。前者对应生产者投递到交换器的消息，后者对应消费者从队列获取的消息。</p><p>开启/关闭Firehose：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> rabbitmqctl trace_on [-p vhost]</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> rabbitmqctl trace_off [-p vhost]</span></span><br></pre></td></tr></table></figure><p>Firehose（多少会影响一点性能）默认关闭，且重启MQ后重置为默认。</p><p>创建7个队列，2个交换器与其中两个队列绑定，最后将交换器 <code>amq.rabbitmq.trace</code> 与其余5个队列绑定：</p><p><img src="https://pic-1258215793.cos.ap-shanghai.myqcloud.com/content/20210901/202109010120.png"></p><p>分别用客户端向exchange和exchange.another发送一条消息”trace test payload”，然后再用客户端消费队列queue和queue.another的消息。</p><p>此时queue1中有2条消息，queue2中有2条消息，queue3中有4条消息，而queue4和queue5中只有一条消息。</p><ul><li>在向exchange发送一条消息后，<code>amq.rabbitmq.trace</code> 分别向queue1、queue3和queue4发送一条内部封装消息。</li><li>在向exchange.another发送一条消息后，queue1和queue3多出一条消息。</li><li>消费queue的时候，queue2、queue3和queue5多出一条消息。</li><li>消费queue.another时，queue2和queue3多出一条消息。</li></ul><p>综述：</p><ul><li><code>publish.#</code> 匹配发送到所有交换器的消息。</li><li><code>deliver.#</code> 匹配消费所有队列的消息。</li><li><code>#</code> 则包含前两者。</li></ul><p>当有客户端发送或消费消息时，Firehose会自动封装相应的消息体，并添加详细的headers属性：</p><p><img src="https://pic-1258215793.cos.ap-shanghai.myqcloud.com/content/20210901/202109010121.png"></p><p>消费queue时，消息会封装为：</p><p><img src="https://pic-1258215793.cos.ap-shanghai.myqcloud.com/content/20210901/202109010122.png"></p><p>headers：</p><ul><li>exchange_name：发送消息的交换器。</li><li>routing_keys：对应路由键列表。</li><li>properties：消息本身的属性，如delivery_mode为2表示消息需要持久化处理。</li></ul><h3 id="1-2-rabbitmq-tracing插件"><a href="#1-2-rabbitmq-tracing插件" class="headerlink" title="1.2 rabbitmq_tracing插件"></a>1.2 rabbitmq_tracing插件</h3><p>rabbitmq_tracing插件相当于Firehose的GUI版本，同样能跟踪MQ中的消息流入流出，同样对消息进行封装并存入trace文件之中。</p><p>开启/关闭：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> rabbitmq-plugins <span class="built_in">enable</span> rabbitmq_tracing</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> rabbitmq-plugins <span class="built_in">disable</span> rabbitmq_tracing</span></span><br></pre></td></tr></table></figure><p>Web管理界面Admin会多出一栏Tracing：</p><p><img src="https://pic-1258215793.cos.ap-shanghai.myqcloud.com/content/20210901/202109010123.png"></p><p>添加Trace：</p><p><img src="https://pic-1258215793.cos.ap-shanghai.myqcloud.com/content/20210901/202109010124.png"></p><ul><li>Name：trace任务名称。</li><li>Format：输出的消息日志格式，有Text和JSON。</li><li>Max payload bytes：每条消息的最大限制，单位为B，达到上限会被截断。</li><li>Pattern：设置匹配的模式，<code>#</code> 匹配所有消息流入流出，<code>publish.#</code> 匹配所有消息流入，<code>deliver.#</code> 匹配所有消息流出。</li></ul><p>TEXT格式：</p><p><img src="https://pic-1258215793.cos.ap-shanghai.myqcloud.com/content/20210901/202109010129.png"></p><p>JSON格式：</p><p><img src="https://pic-1258215793.cos.ap-shanghai.myqcloud.com/content/20210901/202109010130.png"></p><p>添加完毕后，根据匹配的规则将相应的消息日志输出到对应日志文件中，默认路径为 <code>/var/tmp/rabbitmq-tracing</code> ，也可以在页面直接点击Trace log files直接查看对应文件。</p><p>添加两个trace任务：</p><p><img src="https://pic-1258215793.cos.ap-shanghai.myqcloud.com/content/20210901/202109010125.png"></p><p>对应文件：</p><p><img src="https://pic-1258215793.cos.ap-shanghai.myqcloud.com/content/20210901/202109010126.png"></p><p>会多出两个队列：</p><p><img src="https://pic-1258215793.cos.ap-shanghai.myqcloud.com/content/20210901/202109010127.png"></p><p>查看第一个队列，绑定的交换器就是 <code>amq.rabbitmq.trace</code> ：</p><p><img src="https://pic-1258215793.cos.ap-shanghai.myqcloud.com/content/20210901/202109010128.png"></p><p>可以看出 rabbitmq_tracing插件和Firehose如出一辙，只是多了层GUI方便使用和管理。</p><h4 id="（1）开启Tracing日志"><a href="#（1）开启Tracing日志" class="headerlink" title="（1）开启Tracing日志"></a>（1）开启Tracing日志</h4><ol><li><p>使用comp用户连接linux服务器</p></li><li><p>输入指令 <code>rabbitmqctl status</code> 确认MQ状态</p><p><img src="https://pic-1258215793.cos.ap-shanghai.myqcloud.com/content/20210901/202109010101.png" alt="image-20210331171126692"></p><p><code>command not found</code>：不能识别命令，需要添加配置信息</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">vim .bash_profile</span><br><span class="line"></span><br><span class="line">export PATH=$PATH:/home/comp/rabbitmq/rabbitmq_server-3.7.5/sbin</span><br><span class="line"><span class="meta"></span></span><br><span class="line"><span class="meta">#</span><span class="bash"> 修改配置信息，后使其生效</span></span><br><span class="line">source .bash_profile</span><br></pre></td></tr></table></figure></li><li><p>通过指令 <code>rabbitmq-plugins list</code> 查看MQ安装的插件，<code>E*</code> 表示已启用。对应文件路径：<code>/home/comp/rabbitmq/rabbitmq_server-3.7.5/sbin</code> </p><p><img src="https://pic-1258215793.cos.ap-shanghai.myqcloud.com/content/20210901/202109010102.png" alt="image-20210331171303814"></p></li><li><p>找到 <code>rabbitmq_tracing</code> 确认是否启用，若未启用，则通过指令 <code>rabbitmq-plugins enable rabbitmq_tracing</code> 开启。</p><p><img src="https://pic-1258215793.cos.ap-shanghai.myqcloud.com/content/20210901/202109010103.png" alt="image-20210331171436966"></p></li><li><p>通过指令 <code>rabbitmqctl trace_on</code> 开启trace。</p></li><li><p>虚拟主机 server 开启trace：<code>rabbitmqctl trace_on -p server</code> ，添加完成后会多一个交换器：</p><p><img src="https://pic-1258215793.cos.ap-shanghai.myqcloud.com/content/20210901/202109010104.png" alt="image-20210331171813344"></p></li><li><p>RabbitMQ管理平台新建一个Trace，添加trace追踪文件信息：</p><p><img src="https://pic-1258215793.cos.ap-shanghai.myqcloud.com/content/20210901/202109010105.png" alt="image-20210331172359303"></p></li><li><p>创建的Trace文件：</p><p><img src="https://pic-1258215793.cos.ap-shanghai.myqcloud.com/content/20210901/202109010106.png" alt="image-20210331172219234"></p><p>若该步骤出错，如：</p><p><img src="https://pic-1258215793.cos.ap-shanghai.myqcloud.com/content/20210901/202109010107.png" alt="image-20210907173131624"></p><p>MQ的tracing插件默认使用guest用户，给它开下server权限应该就行了</p><p><img src="https://pic-1258215793.cos.ap-shanghai.myqcloud.com/content/20210901/202109010108.png" alt="image-20210907183235365"></p><p><img src="https://pic-1258215793.cos.ap-shanghai.myqcloud.com/content/20210901/202109010109.png" alt="image-20210907183453592"></p><p>MQ日志路径：<code>/home/comp/rabbitmq/log</code> 。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 日志表示账号密码有问题</span></span><br><span class="line">2021-09-07 17:55:17.143 [info] &lt;0.2303.0&gt; Enabling tracing for vhost &#x27;server&#x27;</span><br><span class="line">2021-09-07 17:55:17.173 [error] &lt;0.3847.0&gt; Supervisor &#123;&lt;0.3847.0&gt;,rabbit_tracing_consumer_sup&#125; had child consumer started with rabbit_tracing_consumer:start_link([&#123;vhost,&lt;&lt;&quot;server&quot;&gt;&gt;&#125;,&#123;name,&lt;&lt;&quot;server-trace-log&quot;&gt;&gt;&#125;,&#123;format,&lt;&lt;&quot;text&quot;&gt;&gt;&#125;,&#123;pattern,&lt;&lt;&quot;#&quot;&gt;&gt;&#125;,&#123;&lt;&lt;&quot;for...&quot;&gt;&gt;,...&#125;,...]) at undefined exit with reason no match of right hand value &#123;error,&#123;auth_failure,&quot;Refused&quot;&#125;&#125; in rabbit_tracing_consumer:init/1 line 58 in context start_error</span><br><span class="line">2021-09-07 17:55:17.173 [error] &lt;0.3848.0&gt; CRASH REPORT Process &lt;0.3848.0&gt; with 0 neighbours exited with reason: no match of right hand value &#123;error,&#123;auth_failure,&quot;Refused&quot;&#125;&#125; in rabbit_tracing_consumer:init/1 line 58 in gen_server:init_it/6 line 352</span><br></pre></td></tr></table></figure></li><li><p>重新核算，触发消息发送。</p></li><li><p>查看步骤8的Trace文件，确认消息是否发送。</p></li></ol><p>如果给guest增加权限server仍不能创建Trac，直接重建guest用户：</p><ol><li><p>删除用户guest</p><p><img src="https://pic-1258215793.cos.ap-shanghai.myqcloud.com/content/20210901/202109010110.png" alt="image-20210907194009362"></p></li><li><p>再创建用户guest，用户名密码相同。</p><p><img src="https://pic-1258215793.cos.ap-shanghai.myqcloud.com/content/20210901/%E5%BE%85%E4%B8%8A%E4%BC%A0/202109010111.png" alt="image-20210907194048653"></p><p><img src="C:\Users\hspcadmin\AppData\Roaming\Typora\typora-user-images\image-20210907194122446.png" alt="image-20210907194122446"></p></li><li><p>增加权限：</p><p><img src="https://pic-1258215793.cos.ap-shanghai.myqcloud.com/content/20210901/202109010112.png" alt="image-20210907194148405"></p></li><li><p>重新创建Tracing：</p><p><img src="https://pic-1258215793.cos.ap-shanghai.myqcloud.com/content/20210901/202109010113.png" alt="image-20210907194213958"></p><p>创建成功：</p><p><img src="https://pic-1258215793.cos.ap-shanghai.myqcloud.com/content/20210901/202109010114.png" alt="image-20210907194229913"></p></li></ol><h4 id="（2）测试队列"><a href="#（2）测试队列" class="headerlink" title="（2）测试队列"></a>（2）测试队列</h4><p>除了开启Tracing排查消息是否投递到MQ，还可以新加一个测试Queue，绑定相同的交换器和路由键。因为无消费者，所以消息都堆积在队列中，通过GetMessage(n) + nack来获取所有消息，也可以ack或purge清空消息。</p><h3 id="1-3-案例：可靠性检测"><a href="#1-3-案例：可靠性检测" class="headerlink" title="1.3 案例：可靠性检测"></a>1.3 案例：可靠性检测</h3><p>生产者将消息发送到交换器时，实际上是由生产者所连接的信道将消息上的路由键同交换器的绑定列表比较，之后再路由消息到相应的队列进程中。    </p><p>那么在信道对比完绑定列表后，将消息路由到队列并保存的过程，是否会因为MQ的内部缺陷而引起偶发性的消息丢失？我们可以使用消息追踪机制来验证这一疑问，一个交换器通过同一个路由键绑定多个队列，生产者客户端采用同一个路由键发送消息到交换器，检测绑定的队列是否有消息丢失。</p><h4 id="（1）前期准备"><a href="#（1）前期准备" class="headerlink" title="（1）前期准备"></a>（1）前期准备</h4><ol><li>开启tracing插件。</li><li>创建一个交换器exchange和三个队列，都由同一个路由键rk绑定。</li><li>创建三个trace分别采用 <code>#.queue1</code> ，<code>#.queue2</code> ，<code>#.queue3</code> 的Pattern追踪各个队列。</li><li>创建一个trace：trace_publish采用 <code>publish.exchange</code> 追踪流入交换器的消息。</li></ol><h4 id="（2）验证过程"><a href="#（2）验证过程" class="headerlink" title="（2）验证过程"></a>（2）验证过程</h4><p>开启一个生产者现场，持续发消息到交换器，消息格式为当前时间戳+自增计数，从而在数据丢失时可以快速在trace日志中定位到。注意设置mandatory参数，防止消息路由不到对应队列而造成对消息丢失的误判。</p><p>消息发送前以[msg, QUEUE_NUM]的形式存入一个全局msgMap中，用来在消费端做数据验证，为3表示创建了三个队列：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> HashMap&lt;String, Integer&gt; msgMap = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> BlockingQueue&lt;String&gt; log2disk = <span class="keyword">new</span> LinkedBlockingDeque&lt;&gt;();</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">ProducerThread</span> <span class="keyword">implements</span> <span class="title">Runnable</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> Connection connection;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">ProducerThread</span><span class="params">(Connection connection)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.connection = connection;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            Channel channel = connection.createChannel();</span><br><span class="line">            channel.addReturnListener((replyCode, replyText, exchange, routingKey, basicProperties, body) -&gt; &#123;</span><br><span class="line">                String errorInfo = <span class="string">&quot;Basic.Return: &quot;</span> + <span class="keyword">new</span> String(body) + <span class="string">&quot;\n&quot;</span>;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    log2disk.put(errorInfo);</span><br><span class="line">                &#125; <span class="keyword">catch</span> (InterruptedException ex) &#123;</span><br><span class="line">                    ex.printStackTrace();</span><br><span class="line">                &#125;</span><br><span class="line">                System.out.println(errorInfo);</span><br><span class="line">            &#125;);</span><br><span class="line">            <span class="keyword">int</span> count = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">while</span> (<span class="keyword">true</span>) &#123;</span><br><span class="line">                String message = System.currentTimeMillis() + <span class="string">&quot;-&quot;</span> + count++;</span><br><span class="line">                <span class="comment">// 存储消息一定要在发消息之前，否则消息被消费时msgMap中不一定会有相应的消息</span></span><br><span class="line">                <span class="keyword">synchronized</span> (msgMap) &#123;</span><br><span class="line">                    msgMap.put(message, QUEUE_NUM);</span><br><span class="line">                &#125;</span><br><span class="line">                channel.basicPublish(exchange, routingKey, <span class="keyword">true</span>, MessageProperties.PERSISTENT_TEXT_PLAIN, message.getBytes());</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    <span class="comment">// QPS=10，可以自适应调节，不宜过高防止队列堆积严重</span></span><br><span class="line">                    TimeUnit.MILLISECONDS.sleep(<span class="number">100</span>);</span><br><span class="line">                &#125; <span class="keyword">catch</span> (InterruptedException ex) &#123;</span><br><span class="line">                    ex.printStackTrace();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (IOException ex) &#123;</span><br><span class="line">            ex.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>然后，开启三个消费者线程分别消费是三个队列的消息，从存储的msgMap中寻找是否有相应消息，若有则计数减一并删除；若无，则报错：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">ConsumerThread</span> <span class="keyword">implements</span> <span class="title">Runnable</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> Connection connection;</span><br><span class="line">    <span class="keyword">private</span> String queue;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">ConsumerThread</span><span class="params">(Connection connection, String queue)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.connection = connection;</span><br><span class="line">        <span class="keyword">this</span>.queue = queue;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">final</span> Channel channel = connection.createChannel();</span><br><span class="line">            channel.basicQos(<span class="number">64</span>);</span><br><span class="line">            channel.basicConsume(<span class="keyword">this</span>.queue, <span class="keyword">new</span> DefaultConsumer(channel) &#123;</span><br><span class="line">                <span class="meta">@Override</span></span><br><span class="line">                <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">handleDelivery</span><span class="params">(String consumerTag, Envelope envelope, AMQP.BasicProperties properties, <span class="keyword">byte</span>[] body)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">                    String msg = <span class="keyword">new</span> String(body);</span><br><span class="line">                    <span class="keyword">synchronized</span> (msgMap) &#123;</span><br><span class="line">                        <span class="keyword">if</span> (msgMap.containsKey(msg)) &#123;</span><br><span class="line">                            <span class="keyword">int</span> count = msgMap.get(msg);</span><br><span class="line">                            count--;</span><br><span class="line">                            <span class="keyword">if</span> (count &gt; <span class="number">0</span>) &#123;</span><br><span class="line">                                msgMap.put(msg, count);</span><br><span class="line">                            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                                msgMap.remove(msg);</span><br><span class="line">                            &#125;</span><br><span class="line">                        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                            String errorInfo = <span class="string">&quot;unknown msg : &quot;</span> + msg + <span class="string">&quot;\n&quot;</span>;</span><br><span class="line">                            <span class="keyword">try</span> &#123;</span><br><span class="line">                                log2disk.put(errorInfo);</span><br><span class="line">                                System.out.println(errorInfo);</span><br><span class="line">                            &#125; <span class="keyword">catch</span> (InterruptedException ex) &#123;</span><br><span class="line">                                ex.printStackTrace();</span><br><span class="line">                            &#125;</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;</span><br><span class="line">                    </span><br><span class="line">                    channel.basicAck(envelope.getDeliveryTag(), <span class="keyword">false</span>);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (IOException ex) &#123;</span><br><span class="line">            ex.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>最后，开启一个检测进程，每隔10分钟检测一下msgMap中的数据。对比消息中的时间戳和当前时间，如果差值超过10分钟，则说明可能有消息丢失。（该结论的前提是队列没有消息堆积，且消费消息的速度不低于生产消息的速度）：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">DetectThread</span> <span class="keyword">implements</span> <span class="title">Runnable</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">while</span> (<span class="keyword">true</span>) &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                TimeUnit.MINUTES.sleep(<span class="number">10</span>);</span><br><span class="line">            &#125; <span class="keyword">catch</span> (InterruptedException ex) &#123;</span><br><span class="line">                ex.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">            </span><br><span class="line">            <span class="keyword">synchronized</span> (msgMap) &#123;</span><br><span class="line">                <span class="keyword">long</span> now = System.currentTimeMillis();</span><br><span class="line">                <span class="keyword">for</span> (Map.Entry&lt;String, Integer&gt; entry : msgMap.entrySet()) &#123;</span><br><span class="line">                    String msg = entry.getKey();</span><br><span class="line">                    <span class="keyword">if</span> (now - parseTime(msg) &gt;= <span class="number">10</span> * <span class="number">60</span> * <span class="number">1000</span>) &#123;</span><br><span class="line">                        String findLossInfo = <span class="string">&quot;We find loss msg: &quot;</span> +</span><br><span class="line">                                msg + <span class="string">&quot; , now the time is: &quot;</span> + </span><br><span class="line">                                now + <span class="string">&quot;, and this msg still has &quot;</span> +</span><br><span class="line">                                entry.getValue() + <span class="string">&quot; missed\n&quot;</span>;</span><br><span class="line">                        <span class="keyword">try</span> &#123;</span><br><span class="line">                            log2disk.put(findLossInfo);</span><br><span class="line">                            System.out.println(findLossInfo);</span><br><span class="line">                            msgMap.remove(msg);</span><br><span class="line">                        &#125; <span class="keyword">catch</span> (InterruptedException ex) &#123;</span><br><span class="line">                            ex.printStackTrace();</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Long <span class="title">parseTime</span><span class="params">(String msg)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> index = msg.indexOf(<span class="string">&#x27;-&#x27;</span>);</span><br><span class="line">    String timeStr = msg.substring(<span class="number">0</span>, index);</span><br><span class="line">    <span class="keyword">return</span> Long.parseLong(timeStr);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如果检测到msgMap有超过10分钟的未处理消息，还不能说明有消息丢失，使用trace，如果看到[msg, count]这条数据有如下情况：</p><ul><li><strong>考虑count=3的情况。</strong>需要检索trace文件trace_publish.log来进一步验证，如果其中没搜到相应的消息说明消息未发送到交换器；如果搜索到消息，则要进一步检索trace1.log、trace2.log和trace3.log。如果3个文件不是全部都有此消息，则说明消息丢失。</li><li><strong>考虑0&lt;count&lt;3的情况。</strong>检索trace1.log、trace2.log和trace3.log。如果3个文件不是全部都有此消息，则说明消息丢失。</li><li><strong>考虑count=0的情况。</strong>说明检查程序异常，可以忽略。</li></ul><p>主线程部分代码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">Connection connection = connectionFactory.newConnection();</span><br><span class="line"><span class="comment">// 用来读取log2disk这个BlockingQueue中存储的异常日志，然后进行存盘处理，可以用log4j等代替</span></span><br><span class="line">PrintLogThread printLogThread = <span class="keyword">new</span> PrintLogThread(logFileAddr);</span><br><span class="line">ProducerThread producerThread = <span class="keyword">new</span> ProducerThread(connection);</span><br><span class="line">ConsumerThread consumerThread1 = <span class="keyword">new</span> ConsumerThread(connection, <span class="string">&quot;queue1&quot;</span>);</span><br><span class="line">ConsumerThread consumerThread2 = <span class="keyword">new</span> ConsumerThread(connection, <span class="string">&quot;queue2&quot;</span>);</span><br><span class="line">ConsumerThread consumerThread3 = <span class="keyword">new</span> ConsumerThread(connection, <span class="string">&quot;queue3&quot;</span>);</span><br><span class="line">DetectThread detectThread = <span class="keyword">new</span> DetectThread();</span><br><span class="line">System.out.println(<span class="string">&quot;starting check msg loss...&quot;</span>);</span><br><span class="line">ExecutorService executorService = Executors.newCachedThreadPool();</span><br><span class="line">executorService.submit(printLogThread);</span><br><span class="line">executorService.submit(producerThread);</span><br><span class="line">executorService.submit(consumerThread1);</span><br><span class="line">executorService.submit(consumerThread2);</span><br><span class="line">executorService.submit(consumerThread3);</span><br><span class="line">executorService.submit(detectThread);</span><br><span class="line">executorService.shutdown();</span><br></pre></td></tr></table></figure><h2 id="二-负载均衡"><a href="#二-负载均衡" class="headerlink" title="二. 负载均衡"></a>二. 负载均衡</h2><p>大量业务访问、高并发请求的场景，需要用高性能的服务器来提升MQ的负载能力。假设一个集群中有3个节点，所有客户端都与node1建立TCP连接，则node1的网络负载会大大增加，其他节点又由于没有那么多负载而造成资源浪费。</p><p>对于RabbitMQ，客户端只会和集群中一个节点建立连接而不是整个集群。引入负载均衡后，各个客户端的连接会分摊到各个节点：</p><p><img src="https://pic-1258215793.cos.ap-shanghai.myqcloud.com/content/20210901/202109010131.png"></p><blockquote><p>负载均衡（Load Balance）是一种计算机网络技术，用于在多个计算机（集群）、网络连接、CPU、磁盘驱动器或其他资源中分配负载，以达到最佳资源使用、最大化吞吐率、最小响应时间及避免过载的目的。</p><p>使用带有负载均衡的多个服务器组件，取代单一的组件，可以通过冗余提高可靠性。</p><p>负载均衡分为：</p><ul><li><strong>软件负载均衡：</strong>在一个或多个交互的网络系统中的多台服务器上安装一个或多个相应的负载均衡软件来实现的一种均衡负载技术。软件安装比较方便，技术配置简单，操作方便，成本很低。</li><li><strong>硬件负载均衡：</strong>多台服务器间安装相应的负载均衡设备，即负载均衡器。相比软件会有更好的负载均衡效果，但成本较高，适用于流量较大的大型网站系统。</li></ul></blockquote><h3 id="2-1-客户端内部实现负载均衡"><a href="#2-1-客户端内部实现负载均衡" class="headerlink" title="2.1 客户端内部实现负载均衡"></a>2.1 客户端内部实现负载均衡</h3><p>客户端连接可以任选一种负载均衡算法实现。</p><h4 id="（1）轮询法"><a href="#（1）轮询法" class="headerlink" title="（1）轮询法"></a>（1）轮询法</h4><p>将请求按顺序轮流分配到后端服务器上，不关心每台服务器实际的连接数和当前系统负载，调用 <code>RoundRobin.getConnectionAddress()</code> 获取连接地址。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 轮询法</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">RoundRobin</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> List&lt;String&gt; list = <span class="keyword">new</span> ArrayList&lt;String&gt;()&#123;&#123;</span><br><span class="line">        add(<span class="string">&quot;192.168.0.2&quot;</span>);</span><br><span class="line">        add(<span class="string">&quot;192.168.0.3&quot;</span>);</span><br><span class="line">        add(<span class="string">&quot;192.168.0.4&quot;</span>);</span><br><span class="line">    &#125;&#125;;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">int</span> pos = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> Object lock = <span class="keyword">new</span> Object();</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> String <span class="title">getConnectionAddress</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        String ip = <span class="keyword">null</span>;</span><br><span class="line">        <span class="keyword">synchronized</span> (lock) &#123;</span><br><span class="line">            ip = list.get(pos);</span><br><span class="line">            <span class="keyword">if</span> (++pos &gt;= list.size()) &#123;</span><br><span class="line">                pos = <span class="number">0</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ip;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="（2）加权轮询法"><a href="#（2）加权轮询法" class="headerlink" title="（2）加权轮询法"></a>（2）加权轮询法</h4><p>不同服务器的配置可能和当前系统的负载不同，抗压能力也不相同。所以应该给配置高、负载低的机器配置更高的权重，让其处理更多请求；</p><h4 id="（3）随机法"><a href="#（3）随机法" class="headerlink" title="（3）随机法"></a>（3）随机法</h4><p>通过随机算法，根据服务器列表大小值来任选一台服务器访问。由概率理论可知，随着调用服务端次数增多，实际效果会越来越接近轮询法：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 随机法</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">RandomAccess</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> List&lt;String&gt; list = <span class="keyword">new</span> ArrayList&lt;String&gt;()&#123;&#123;</span><br><span class="line">        add(<span class="string">&quot;192.168.0.2&quot;</span>);</span><br><span class="line">        add(<span class="string">&quot;192.168.0.3&quot;</span>);</span><br><span class="line">        add(<span class="string">&quot;192.168.0.4&quot;</span>);</span><br><span class="line">    &#125;&#125;;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> String <span class="title">getConnectionAddress</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        Random random = <span class="keyword">new</span> Random();</span><br><span class="line">        <span class="keyword">int</span> pos = random.nextInt(list.size());</span><br><span class="line">        <span class="keyword">return</span> list.get(pos);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="（4）加权随机法"><a href="#（4）加权随机法" class="headerlink" title="（4）加权随机法"></a>（4）加权随机法</h4><p>与加权轮询法相同，根据机器配置和负载分配不同权重，区别是其按照权重随机分配而非顺序。</p><h4 id="（5）源地址哈希法"><a href="#（5）源地址哈希法" class="headerlink" title="（5）源地址哈希法"></a>（5）源地址哈希法</h4><p>根据获取的客户端IP地址，通过哈希函数计算得到的一个数值，用此数值对服务器列表的大小进行取模运算，得到的结果便是客户端要访问服务器的序号。</p><p>采用该方法，同一IP地址的客户端在服务器列表不变的情况下，每次都会分配给同一台服务器：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 源地址哈希法</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">IpHash</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> List&lt;String&gt; list = <span class="keyword">new</span> ArrayList&lt;String&gt;()&#123;&#123;</span><br><span class="line">        add(<span class="string">&quot;192.168.0.2&quot;</span>);</span><br><span class="line">        add(<span class="string">&quot;192.168.0.3&quot;</span>);</span><br><span class="line">        add(<span class="string">&quot;192.168.0.4&quot;</span>);</span><br><span class="line">    &#125;&#125;;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> String <span class="title">getConnectionAddress</span><span class="params">()</span> <span class="keyword">throws</span> UnknownHostException </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> ipHashCode = InetAddress.getLocalHost().getHostAddress().hashCode();</span><br><span class="line">        <span class="keyword">int</span> pos = ipHashCode &amp; list.size();</span><br><span class="line">        <span class="keyword">return</span> list.get(pos);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="（6）最小连接数法"><a href="#（6）最小连接数法" class="headerlink" title="（6）最小连接数法"></a>（6）最小连接数法</h4><p>由于服务器配置不尽相同，对于请求的处理有快有慢，根据服务器当前连接情况，动态的选取其中当前积压连接数最少的一台服务器来处理当前的请求，尽可能的提高对服务器的利用效率。</p><h3 id="2-2-使用HAProxy实现负载均衡"><a href="#2-2-使用HAProxy实现负载均衡" class="headerlink" title="2.2 使用HAProxy实现负载均衡"></a>2.2 使用HAProxy实现负载均衡</h3><p>HAProxy提供了高可用性、负载均衡及基于TCP和HTTP应用的代理，支持虚拟主机，是一种免费、快速且可靠的解决方案。实现了一种事件驱动、单一进程模型，支持较大的并发连接数。</p><h4 id="（1）安装"><a href="#（1）安装" class="headerlink" title="（1）安装"></a>（1）安装</h4><p><a href="http://www.haproxy.org/#down">官网下载</a>，<a href="http://www.haproxy.org/#doc1.7">官方文档</a>。</p><p>将下载的压缩包复制到 <code>/opt</code> 目录下，与RabbitMQ同一个目录，并解压：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> tar zxvf haproxy-1.7.8.tar.gz</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> <span class="built_in">cd</span> haproxy-1.7.8</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> make指令将其编译为可执行程序，TARGET选择目标平台</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> make TARGET=generic</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> 编译后目录下有名为haproxy的可执行文件</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> 修改系统配置</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> vi /etc/profile</span></span><br><span class="line">export PATH=$PATH:/opt/haproxy-1.7.8/haproxy</span><br><span class="line"><span class="meta">$</span><span class="bash"> <span class="built_in">source</span> /etc/profile</span></span><br></pre></td></tr></table></figure><h4 id="（2）配置"><a href="#（2）配置" class="headerlink" title="（2）配置"></a>（2）配置</h4><p>HAProxy使用单一配置文件来定义所有属性：</p><ul><li>HAProxy主机：192.168.0.9:5671</li><li>RabbitMQ1：192.168.0.2:5672</li><li>RabbitMQ2：192.168.0.3:5672</li><li>RabbitMQ3：192.168.0.4:5672</li></ul><figure class="highlight properties"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 全局配置</span></span><br><span class="line"><span class="attr">global</span></span><br><span class="line"><span class="comment"># 日志输出配置，所有日志都记录在本机，通过local0输出</span></span><br><span class="line"><span class="attr">log</span> <span class="string">127.0.0.1 local0 info</span></span><br><span class="line"><span class="comment"># 最大连接数</span></span><br><span class="line"><span class="attr">maxconn</span> <span class="string">4096</span></span><br><span class="line"><span class="comment"># 改变当前的工作目录</span></span><br><span class="line"><span class="attr">chroot</span> <span class="string">/opt/haproxy-1.7.8</span></span><br><span class="line"><span class="comment"># 以指定的UID运行</span></span><br><span class="line"><span class="attr">uid</span> <span class="string">99</span></span><br><span class="line"><span class="comment"># 以指定的GID运行</span></span><br><span class="line"><span class="attr">gid</span> <span class="string">99</span></span><br><span class="line"><span class="comment"># 以守护进程方式运行 #debug #quiet</span></span><br><span class="line"><span class="attr">daemon</span></span><br><span class="line"><span class="comment">#debug</span></span><br><span class="line"><span class="comment"># 当前进程pid文件</span></span><br><span class="line"><span class="attr">pidfile</span> <span class="string">/opt/haproxy-1.7.8/haproxy.pid</span></span><br><span class="line"><span class="comment"># 默认配置</span></span><br><span class="line"><span class="attr">defaults</span></span><br><span class="line"><span class="comment"># 应用全局的日志配置</span></span><br><span class="line"><span class="attr">log</span> <span class="string">global</span></span><br><span class="line"><span class="comment"># 默认的模式mode&#123;tcp|http|health&#125;</span></span><br><span class="line"><span class="attr">mode</span> <span class="string">tcp</span></span><br><span class="line"><span class="comment"># 日志类别tcplog</span></span><br><span class="line"><span class="attr">option</span> <span class="string">tcplog</span></span><br><span class="line"><span class="comment"># 不记录健康检查日志信息</span></span><br><span class="line"><span class="attr">option</span> <span class="string">dontlognull</span></span><br><span class="line"><span class="comment"># 3次失败则认为服务不可用</span></span><br><span class="line"><span class="meta">retries</span> <span class="string">3</span></span><br><span class="line"><span class="comment"># 每个进程可用的最大连接数</span></span><br><span class="line"><span class="attr">maxconn</span> <span class="string">2000</span></span><br><span class="line"><span class="comment"># 连接超时</span></span><br><span class="line"><span class="attr">timeout</span> <span class="string">connect 5s</span></span><br><span class="line"><span class="comment"># 客户端超时</span></span><br><span class="line"><span class="attr">timeout</span> <span class="string">client 120s</span></span><br><span class="line"><span class="comment"># 服务端超时</span></span><br><span class="line"><span class="attr">timeout</span> <span class="string">server 120s</span></span><br><span class="line"><span class="comment"># 绑定配置</span></span><br><span class="line"><span class="meta">listen</span> <span class="string">rabbitmq_cluster :5671</span></span><br><span class="line"><span class="comment"># 配置TCP模式</span></span><br><span class="line"><span class="attr">mode</span> <span class="string">tcp</span></span><br><span class="line"><span class="comment"># 简单的轮询</span></span><br><span class="line"><span class="attr">balance</span> <span class="string">roundrobin</span></span><br><span class="line"><span class="comment"># RabbitMQ集群节点配置</span></span><br><span class="line"><span class="meta">server</span> <span class="string">rmq_node1 192.168.0.2:5672 check inter 5000 rise 2 fall 3 weight 1</span></span><br><span class="line"><span class="meta">server</span> <span class="string">rmq_node2 192.168.0.3:5672 check inter 5000 rise 2 fall 3 weight 1</span></span><br><span class="line"><span class="meta">server</span> <span class="string">rmq_node3 192.168.0.4:5672 check inter 5000 rise 2 fall 3 weight 1</span></span><br><span class="line"><span class="comment">#haproxy监控页面地址</span></span><br><span class="line"><span class="meta">listen</span> <span class="string">monitor :8100</span></span><br><span class="line"><span class="attr">mode</span> <span class="string">http</span></span><br><span class="line"><span class="attr">option</span> <span class="string">httplog</span></span><br><span class="line"><span class="meta">stats</span> <span class="string">enabnle</span></span><br><span class="line"><span class="meta">stats</span> <span class="string">uri /stats</span></span><br><span class="line"><span class="meta">stats</span> <span class="string">refresh 5s</span></span><br></pre></td></tr></table></figure><p><code>server rmq_node1 192.168.0.2:5672 check inter 5000 rise 2 fall 3 weight 1</code> ：</p><ul><li><code>server &lt;name&gt;</code> ：定义RabbitMQ服务的内部标识，此处rmq_node1指有含义的字符串名称，而非节点名称。</li><li><code>&lt;ip&gt;:&lt;port&gt;</code> ：定义RabbitMQ服务连接的IP地址和端口号。</li><li><code>check inter &lt;value&gt;</code> ：定义每隔多少毫秒检查RabbitMQ服务是否可用。</li><li><code>rise &lt;value&gt;</code> ：定义RabbitMQ服务在发生故障后，需要多少次健康检查才能被再次确认可用。</li><li><code>fall &lt;value&gt;</code> ：定义需要经历多少次失败的健康检查后，HAProxy才会停止使用此RabbitMQ服务。</li><li><code>weight &lt;value&gt;</code>  ：定义当前RabbitMQ服务的权重。</li></ul><p>调用 <code>haproxy -f haproxy.cfg</code> 命令运行服务后，可以查看相关界面 <code>http://192.168.0.9:8100/stats</code> 。</p><p><img src="https://pic-1258215793.cos.ap-shanghai.myqcloud.com/content/20210901/202109010132.png"></p><h3 id="2-3-使用Keepalived实现高可靠负载均衡"><a href="#2-3-使用Keepalived实现高可靠负载均衡" class="headerlink" title="2.3 使用Keepalived实现高可靠负载均衡"></a>2.3 使用Keepalived实现高可靠负载均衡</h3><p>如果HAProxy主机突然宕机或网卡失效，MQ集群没有故障，但所有外界客户端的连接都会断开（单点问题），HAProxy无法保证负载均衡服务的可靠性。</p><p>通过Keepalived能够通过自身健康检查、资源接管功能做高可用（双机热备），实现故障转移。</p><p>Keepalived采用VRRP（Vistual Router Redundancy Protocol，虚拟路由冗余协议），以软件的形式实现服务的热备功能。通常将两台Linux服务器组出一个热备组（Master和Backup），同一时间内热备组只有一个Master提供服务，Master会虚拟出一个公用的虚拟IP地址（VIP），只存在于Master上并对外提供服务。当Keepalived检测到Master宕机或服务故障，备份服务器自动接管VIP并成为Master，原Master从热备组中被移除待恢复后再自动加入到热备组，默认再抢占成Master起到故障转移的功能。</p><p>Keepalived工作在OSI的：</p><ul><li>第三层：定期向热备组中的服务器发送一个ICMP数据包来判断某台服务器是否故障，如果故障则从热备组移除。</li><li>第四层：以TCP端口的状态判断服务器是否故障，比如检查MQ端口5672，如果故障则从热备组中移除。</li><li>第七层：根据用户设定的策略（通常是一个自定义的检测脚本）判断服务器上的程序是否正常运行，如果故障则从热备组中移除。</li></ul><h4 id="（1）安装-1"><a href="#（1）安装-1" class="headerlink" title="（1）安装"></a>（1）安装</h4><p><a href="http://keepalived.org/download.html">官网下载</a>。</p><p>解压并安装：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> tar zxvf keepalived-1.3.5.tar.gz</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> <span class="built_in">cd</span> keepalived-1.3.5</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> 根据系统选择对应的启动方式</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> ./configure --prefix=/opt/keepalived --with-init=SYSV</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> make</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> make install</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> 将安装后的keepalived加入系统服务（注意千万不要输错命令）</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> cp /opt/keepalived/etc/rc.d/init.d/keepalived /etc/init.d/</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> cp /opt/keepalived/etc/sysconfig/keepalived /etc/sysconfig</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> cp /opt/keepalived/sbin/keepalived /usr/sbin/</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> chmod +x /etc/init.d/keepalived</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> chkconfig --add keepalived</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> chkconfig keepalived on</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> keepalived会默认读取/etc/keepalived/keepalived.conf 配置文件</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> mkdir /etc/keepalived</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> cp /opt/keepalived/etc/keepalived/keepalived.conf /etc/keepalived</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> 之后就可以重启、启动、关闭和查看keepalived状态</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> service keepalived restart</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> service keepalived start</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> service keepalived stop</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> service keepalived status</span></span><br></pre></td></tr></table></figure><h4 id="（2）配置-1"><a href="#（2）配置-1" class="headerlink" title="（2）配置"></a>（2）配置</h4><p>安装流程已创建了 <code>/etc/keepalived</code> 目录，并将 <code>keepalived.conf </code> 文件复制到此供keepalived读取。更改此文件使keepalived与HAProxy结合。</p><p>两台keepalived服务器通过VRRP交互，对外虚拟出VIP，keepalived与HAProxy部署在同一台机器上，一一配对，从而通过keepalived来实现HAProxy的双机热备。</p><p><img src="https://pic-1258215793.cos.ap-shanghai.myqcloud.com/content/20210901/202109010133.png"></p><p>调用链路：</p><ul><li>客户端通过VIP创建通信链路；</li><li>通信链路通过keepalived的Master节点路由到对应的HAProxy上；</li><li>HAProxy通过负载均衡算法将负载分发到集群中各个节点上。</li></ul><p>修改配置文件：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"># keepalived配置文件</span><br><span class="line">global_defs &#123;</span><br><span class="line">router_id NodeA # 路由ID、主/备的ID不能相同</span><br><span class="line">&#125;</span><br><span class="line"># 自定义监控脚本</span><br><span class="line">vrrp_script chk_haproxy &#123;</span><br><span class="line">script &quot;/etc/keepalived/check_haproxy.sh&quot;</span><br><span class="line">interval 5</span><br><span class="line">weight 2</span><br><span class="line">&#125;</span><br><span class="line">vrrp_instance VI_1 &#123;</span><br><span class="line">state MASTER # keepalived的角色</span><br><span class="line">interface eth0 # 指定监测网卡</span><br><span class="line">virtual_router_id 1</span><br><span class="line">priority 100 # 优先级，BACKUP机器上优先级要小于此值</span><br><span class="line">advert_int 1 # 设置主备之间的检测时间，单位为s</span><br><span class="line">authentication &#123;</span><br><span class="line">auth_type PASS</span><br><span class="line">auth_pass root123</span><br><span class="line">&#125;</span><br><span class="line">track_script &#123;</span><br><span class="line">chk_haproxy</span><br><span class="line">&#125;</span><br><span class="line">virtual_ipaddress &#123; # VIP地址，可以设置多个</span><br><span class="line">192.168.0.10</span><br><span class="line">&#125;</span><br><span class="line">&#125; </span><br></pre></td></tr></table></figure><p>BACKUP机器大致相同，需要修改 <code>global_defs</code> 的 router_id 为如NodeB；修改 <code>vrrp_script chk_haproxy</code> 的state为BACKUP；最后将priority设置为小于100的值。注意virtual_router_id要保持一致。</p><p>为了防止HAProxy挂掉后，keepalived还在正常工作而未切换到Backup，需要补充一个脚本来检测HAProxy的状态。当服务挂掉，脚本自动重启服务，若不成功则关闭keepalived服务，从而可以切换到Backup。该脚本对应 <code>vrrp_script chk_haproxy</code> 中的 script ：</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#!/bin/bash</span></span><br><span class="line"><span class="keyword">if</span> [ $(ps -C haproxy --no-header | wc -l) -eq 0];<span class="keyword">then</span></span><br><span class="line">   haproxy -f /opt/haproxy-1.7.8/haproxy.cfg</span><br><span class="line"><span class="keyword">fi</span> </span><br><span class="line">sleep 2</span><br><span class="line"><span class="keyword">if</span> [ $(ps -C haproxy --no-header | wc -l) -eq 0];<span class="keyword">then</span></span><br><span class="line">       service keepalived stop</span><br><span class="line"><span class="keyword">fi</span></span><br></pre></td></tr></table></figure><p>如此配置后，使用 <code>service keepalived start</code> 启动两台服务。客户端通过VIP地址 <code>192.168.0.10</code> 来连接MQ服务。</p><h4 id="（3）查看运行情况"><a href="#（3）查看运行情况" class="headerlink" title="（3）查看运行情况"></a>（3）查看运行情况</h4><p>查看Keepalived日志输出：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> tail -f /var/<span class="built_in">log</span>/messages -n 200</span></span><br></pre></td></tr></table></figure><p>查看添加的VIP：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> ip add show</span></span><br></pre></td></tr></table></figure><p>一般情况下，双机热备已足够满足应用需求。</p><h3 id="2-4-使用Keepalived-LVS实现负载均衡"><a href="#2-4-使用Keepalived-LVS实现负载均衡" class="headerlink" title="2.4 使用Keepalived+LVS实现负载均衡"></a>2.4 使用Keepalived+LVS实现负载均衡</h3><p>LVS，Linux Virtual Server，即Linux虚拟服务器。LVS是4层负载均衡，建立在OSI模型的传输层之上。LVS支持TCP/UDP的负载均衡，相对于如DNS域名流转解析、应用层负载的调度、客户端的调度等更高效。</p><p>通过LVS可以实现高可伸缩的、高可用的网络服务。LVS主要由3部分组成：</p><ul><li><strong>负载调度器（Load Balancer/Director）：</strong>负责将客户请求发送到一组服务器上执行，客户则认为服务来自一个IP地址。</li><li><strong>服务器池（Server Pool / RealServer）：</strong>一组真正执行客户端请求的服务器。</li><li><strong>共享存储（Shared Storage）：</strong>为服务器池提供一个共享的存储区，方便其拥有相同内容，提供相同服务。</li></ul><p>LVS的负载均衡方式：</p><ul><li><strong>VS/NAT：</strong>Virtual Server via Network Address Translation 的简称，最简单的方式，<strong>所有RealServer只需将自己的网关指向Director</strong>。客户端可以是任意的OS，但该方式下一个Director只能带动有限的RealServer。</li><li><strong>VS/TUN：</strong>Virtual Server via Direct Routing 的简称，IP隧道（IP Tunneling）是将一个IP报文封装在另一个IP报文的技术，<strong>使目标为一个IP地址的数据报文能够封装和转发到另一个IP地址</strong>。IP隧道技术又叫IP封装技术（IP encapsulation）。</li><li><strong>VS/DR：</strong>Virtual Server via Direct Routing 的简称，通过改写报文中的MAC地址部分来实现。Director和RealServer必须在物理上有一个网卡通过不间断的局域网相连。RealServer上绑定的VIP配置在各自Non-ARP网络设备上，Director的VIP地址对外可见；而RealServer则不可见，其地址既可以是内部地址，也可以是真实地址。</li></ul><p>LVS可以代替HAProxy，不需要额外的配置文件，直接集成在Keepalived的配置中，修改 <code>/etc/keepalived/keepalived.conf</code> ：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br></pre></td><td class="code"><pre><span class="line"># keepalived配置文件（Master）</span><br><span class="line">global_defs &#123;</span><br><span class="line">router_id NodeA # 路由ID、主/备的ID不能相同</span><br><span class="line">&#125;</span><br><span class="line">vrrp_instance VI_1 &#123;</span><br><span class="line">state MASTER # keepalived的角色</span><br><span class="line">interface eth0 # 指定监测网卡</span><br><span class="line">virtual_router_id 1</span><br><span class="line">priority 100 # 优先级，BACKUP机器上优先级要小于此值</span><br><span class="line">advert_int 1 # 设置主备之间的检测时间，单位为s</span><br><span class="line">authentication &#123;</span><br><span class="line">auth_type PASS</span><br><span class="line">auth_pass root123</span><br><span class="line">&#125;</span><br><span class="line">track_script &#123;</span><br><span class="line">chk_haproxy</span><br><span class="line">&#125;</span><br><span class="line">virtual_ipaddress &#123; # VIP地址，可以设置多个</span><br><span class="line">192.168.0.10</span><br><span class="line">&#125;</span><br><span class="line">&#125; </span><br><span class="line"></span><br><span class="line">virtual_server 192.168.0.10 5672 &#123; # 设置虚拟服务器</span><br><span class="line">delay_loop 6 # 设置运行情况检查时间，单位为秒</span><br><span class="line"># 设置负载调度算法，有rr、wrr、lc、wlc、lblc、lblcr、dh、sh共8种</span><br><span class="line">lb_algo wrr # 加权轮询</span><br><span class="line">lb_kind DR # 设置LVS实现的负载均衡机制为VS/DR</span><br><span class="line"># 指定在一定的时间内来自统一IP的连接将会被转发到同一RealServer中</span><br><span class="line">persistence_timeout 50</span><br><span class="line">protocal TCP # 指定转发协议类型，包括TCP/UDP两种</span><br><span class="line"># LVS三大部分之一，此处特指RabbitMQ服务</span><br><span class="line">real_server 192.168.0.2 5672 &#123; # 配置服务节点</span><br><span class="line">weight 1 # 权重</span><br><span class="line">TCP_CHECK &#123;</span><br><span class="line">connect_timeout 3</span><br><span class="line">nb_get_retry 3</span><br><span class="line">delay_before_retry 3</span><br><span class="line">connect_port 5672</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">real_server 192.168.0.3 5672 &#123; </span><br><span class="line">weight 1 </span><br><span class="line">TCP_CHECK &#123;</span><br><span class="line">connect_timeout 3</span><br><span class="line">nb_get_retry 3</span><br><span class="line">delay_before_retry 3</span><br><span class="line">connect_port 5672</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">real_server 192.168.0.4 5672 &#123; </span><br><span class="line">weight 1 </span><br><span class="line">TCP_CHECK &#123;</span><br><span class="line">connect_timeout 3</span><br><span class="line">nb_get_retry 3</span><br><span class="line">delay_before_retry 3</span><br><span class="line">connect_port 5672</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"># 为RabbitMQ Management插件设置负载均衡</span><br><span class="line">virtual_server 192.168.0.10 15672 &#123;</span><br><span class="line">delay_loop 6</span><br><span class="line">lb_algo wrr</span><br><span class="line">lb_kind DR</span><br><span class="line">persistence_timeout 50</span><br><span class="line">protocal TCP</span><br><span class="line">real_server 192.168.0.2 5672 &#123;</span><br><span class="line">weight 1</span><br><span class="line">TCP_CHECK &#123;</span><br><span class="line">connect_timeout 3</span><br><span class="line">nb_get_retry 3</span><br><span class="line">delay_before_retry 3</span><br><span class="line">connect_port 15672</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">real_server 192.168.0.3 5672 &#123; </span><br><span class="line">weight 1 </span><br><span class="line">TCP_CHECK &#123;</span><br><span class="line">connect_timeout 3</span><br><span class="line">nb_get_retry 3</span><br><span class="line">delay_before_retry 3</span><br><span class="line">connect_port 15672</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">real_server 192.168.0.4 5672 &#123; </span><br><span class="line">weight 1 </span><br><span class="line">TCP_CHECK &#123;</span><br><span class="line">connect_timeout 3</span><br><span class="line">nb_get_retry 3</span><br><span class="line">delay_before_retry 3</span><br><span class="line">connect_port 15672</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Backup配置参考上一节。</p><ul><li>LVS主要工作是提供调度算法，把客户端请求按需求调度在RealServer中，</li><li>Keepalived主要工作是提供LVS控制器的一个冗余，并对RealServer进行健康检查，发现不健康的从集群剔除。</li><li>RealServer只负载提供服务。</li></ul><p>VS/DR模式下需要在RealServer上配置VIP，因为LVS把客户端的包转发给RealServer时，因为包的目的IP地址是VIP，在RealServer收到包后发现目的地址不是自己系统的IP会认为其不是发给自己的，就会丢弃此包，需要把这个IP地址绑定到网卡下。当发送应答包给客户端，RealServer就会把包的源和目的地址调换，直接恢复给客户端。</p><p>为所有RealServer的lo:0网卡创建启动脚本（vim /opt/realserver.sh）绑定VIP地址：</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#!/bin/bash</span></span><br><span class="line">VIP=192.168.0.10</span><br><span class="line">/etc/rc.d/init.d/<span class="built_in">functions</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">case</span> <span class="string">&quot;<span class="variable">$1</span>&quot;</span> <span class="keyword">in</span></span><br><span class="line">start)</span><br><span class="line">   /sbin/ipconfig lo:0 <span class="variable">$VIP</span> netmask 255.255.255.255 broadcast <span class="variable">$VIP</span></span><br><span class="line">   /sbin/route add -host <span class="variable">$VIP</span> dev lo:0</span><br><span class="line">   <span class="built_in">echo</span> <span class="string">&quot;1&quot;</span> &gt;/proc/sys/net/ipv4/conf/lo/arp_ignore</span><br><span class="line">   <span class="built_in">echo</span> <span class="string">&quot;2&quot;</span> &gt;/proc/sys/net/ipv4/conf/lo/arp_announce</span><br><span class="line">   <span class="built_in">echo</span> <span class="string">&quot;1&quot;</span> &gt;/proc/sys/net/ipv4/conf/all/arp_ignore</span><br><span class="line">   <span class="built_in">echo</span> <span class="string">&quot;2&quot;</span> &gt;/proc/sys/net/ipv4/conf/all/arp_announce</span><br><span class="line">   sysctl -p &gt;/dev/null 2&gt;&amp;1</span><br><span class="line">   <span class="built_in">echo</span> <span class="string">&quot;RealServer Start Ok&quot;</span></span><br><span class="line">;;</span><br><span class="line">stop)</span><br><span class="line">   /sbin/ipconfig lo:0 down</span><br><span class="line">   /sbin/route del -host <span class="variable">$VIP</span> dev lo:0</span><br><span class="line">   <span class="built_in">echo</span> <span class="string">&quot;0&quot;</span> &gt;/proc/sys/net/ipv4/conf/lo/arp_ignore</span><br><span class="line">   <span class="built_in">echo</span> <span class="string">&quot;0&quot;</span> &gt;/proc/sys/net/ipv4/conf/lo/arp_announce</span><br><span class="line">   <span class="built_in">echo</span> <span class="string">&quot;0&quot;</span> &gt;/proc/sys/net/ipv4/conf/all/arp_ignore</span><br><span class="line">   <span class="built_in">echo</span> <span class="string">&quot;0&quot;</span> &gt;/proc/sys/net/ipv4/conf/all/arp_announce</span><br><span class="line">;;</span><br><span class="line">status)</span><br><span class="line">   islothere=`/sbin/ipconfig lo:0 | grep <span class="variable">$VIP</span> | wc -l`</span><br><span class="line">   isrothere=`netstat -rn | grep <span class="string">&quot;lo:0&quot;</span> | grep <span class="variable">$VIP</span> | wc -l`</span><br><span class="line">   <span class="keyword">if</span> [ <span class="variable">$islothere</span> -eq 0]</span><br><span class="line">   <span class="keyword">then</span></span><br><span class="line">    <span class="keyword">if</span> [ <span class="variable">$isrothere</span> -eq 0]</span><br><span class="line">    <span class="keyword">then</span></span><br><span class="line">    <span class="built_in">echo</span> <span class="string">&quot;LVS of RealServer Stoped.&quot;</span></span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    <span class="built_in">echo</span> <span class="string">&quot;LVS of RealServer Running.&quot;</span></span><br><span class="line">    <span class="keyword">fi</span></span><br><span class="line">   <span class="keyword">else</span></span><br><span class="line">    <span class="built_in">echo</span> <span class="string">&quot;LVS of RealServer Running.&quot;</span></span><br><span class="line">   <span class="keyword">fi</span></span><br><span class="line">;;</span><br><span class="line">*)</span><br><span class="line">   <span class="built_in">echo</span> <span class="string">&quot;Usage:<span class="variable">$0</span>&#123;start|stop&#125;&quot;</span></span><br><span class="line">   <span class="built_in">exit</span> 1</span><br><span class="line">;;</span><br><span class="line"><span class="keyword">esac</span></span><br></pre></td></tr></table></figure><p>掩码为 <code>255.255.255.255 </code> 表示广播地址是自身，不会将ARP发送到实际自己该属于的广播域，防止与LVS的VIP冲突而导致IP地址冲突。</p><p>为 <code>/opt/realserver.sh</code> 文件添加可执行权限后，运行 <code>/opt/realserver.sh start</code> 命令后可以通过 <code>ip add show</code> 命令查看网卡lo:0的状态，注意与Keepalived节点的网卡状态进行区分。</p><hr><p>参考：</p><p>🔗 《RabbitMQ实战指南》</p>]]></content>
    
    
    <summary type="html">学习RabbitMQ，第十章《扩展》，内容来自于《RabbitMQ实战指南》，内容：消息追踪，负载均衡等。</summary>
    
    
    
    <category term="技术文档" scheme="http://linyishui.top/categories/%E6%8A%80%E6%9C%AF%E6%96%87%E6%A1%A3/"/>
    
    
    <category term="distributed" scheme="http://linyishui.top/tags/distributed/"/>
    
    <category term="mom" scheme="http://linyishui.top/tags/mom/"/>
    
    <category term="rabbitmq" scheme="http://linyishui.top/tags/rabbitmq/"/>
    
  </entry>
  
  <entry>
    <title>RabbitMQ（九）网络分区</title>
    <link href="http://linyishui.top/2021092201.html"/>
    <id>http://linyishui.top/2021092201.html</id>
    <published>2021-09-22T11:34:01.000Z</published>
    <updated>2021-09-26T06:14:38.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="RabbitMQ（九）网络分区"><a href="#RabbitMQ（九）网络分区" class="headerlink" title="RabbitMQ（九）网络分区"></a>RabbitMQ（九）网络分区</h1><h2 id="一-MQ与网络分区"><a href="#一-MQ与网络分区" class="headerlink" title="一. MQ与网络分区"></a>一. MQ与网络分区</h2><h3 id="1-1-网络分区对RabbitMQ的影响"><a href="#1-1-网络分区对RabbitMQ的影响" class="headerlink" title="1.1 网络分区对RabbitMQ的影响"></a>1.1 网络分区对RabbitMQ的影响</h3><p>网络分区可能会引起消息丢失或服务不可用，可以通过重启或配置自动化处理来解决。</p><p>RabbitMQ一般使用Federation或Shovel来解决广域网中的问题，对于网络分区的容错性不高。局域网环境下也可能会出现网络分区（如中继设备或网卡出现故障）。</p><p>不同分区中的节点会认为不属于自身所在分区的节点都已经挂了，对于队列、交换器、绑定的操作仅对当前分区有效。RabbitMQ 3.1版本后会自动探测网络分区，并提供了相应配置来解决该问题。</p><p>若原集群中配置了镜像队列，其又牵扯到两个或更多网络分区的节点时，每个网络分区都会出现一个master节点，导致每个分区的该队列都相互独立。即使网络恢复，该问题也不能解决。</p><h3 id="1-2-为什么要引入网络分区？"><a href="#1-2-为什么要引入网络分区？" class="headerlink" title="1.2 为什么要引入网络分区？"></a>1.2 为什么要引入网络分区？</h3><p>镜像队列是一种环形的逻辑结构，如下图某队列有4个镜像，假设需要ack一条消息，会先在master节点上执行确认命令，之后转向B节点，再然后是C和D节点，D节点将执行操作返回给A节点，从而真正完成一条消息的确认。</p><p><img src="https://pic-1258215793.cos.ap-shanghai.myqcloud.com/content/20210901/202109010115.png"></p><p>这种数据一致性复制原理于ZK的Quorum（用于保证数据冗余和最终一致性的投票算法）不同，可以保证更强的一致性，在此模型下出现网络波动或网络故障会使数据链的性能大大降低。比如C节点网络异常，则整个数据链会被阻塞，继而相关服务也会被阻塞，所以需要<strong>引入网络分区来将异常节点剥离出整个分区，以确保RabbitMQ的可用性及可靠性</strong>。等待网络恢复后，再将异常节点加入集群。</p><p>通常网络分区都是由单个节点网络故障导致，所以会形成一个大分区和一个单节点的分区，若之前还配置了镜像，就可以在不影响服务可用性、不丢失消息的情况下从网络分区的情形下恢复。</p><h2 id="二-网络分区的判定"><a href="#二-网络分区的判定" class="headerlink" title="二. 网络分区的判定"></a>二. 网络分区的判定</h2><h3 id="2-1-RabbitMQ内部如何判定出现分区"><a href="#2-1-RabbitMQ内部如何判定出现分区" class="headerlink" title="2.1 RabbitMQ内部如何判定出现分区"></a>2.1 RabbitMQ内部如何判定出现分区</h3><p>RabbitMQ集群节点内部通信端口默认为25672，两两节点间都会进行信息交互。当某个节点出现网络故障、端口不通，导致与此节点的交互中断，此处会有一个<strong>超时判定机制来判定是否网络分区</strong>。</p><ul><li>net_ticktime，默认为60秒。当发生超时会有 <code>net_tick_timeout</code> 的信息报出。<strong>集群内部每个节点间会每隔四分之一个net_ticktime记一次应答</strong>。若有任何数据被写入节点中就认为已应答；<strong>连续4次都未应答的节点认为已处于down状态，其余节点可以将其剥离出当前分区</strong>。</li><li>heartbeat_time指客户端与RabbitMQ服务间通信的心跳时间，注意和net_ticktime的区别。</li></ul><p>连续4次应答的总时间T的取值范围：<code>0.75*net_ticktime &lt; T &lt; 1.25*net_ticktime</code></p><p><img src="https://pic-1258215793.cos.ap-shanghai.myqcloud.com/content/20210901/202109010116.png"></p><p>默认情况下，可以再45s &lt; T &lt; 75s间判定出  <code>net_tick_timeout</code> 。</p><h3 id="2-2-判定出现网络分区的方法"><a href="#2-2-判定出现网络分区的方法" class="headerlink" title="2.2 判定出现网络分区的方法"></a>2.2 判定出现网络分区的方法</h3><h4 id="（1）查看RabbitMQ服务日志"><a href="#（1）查看RabbitMQ服务日志" class="headerlink" title="（1）查看RabbitMQ服务日志"></a>（1）查看RabbitMQ服务日志</h4><p>当Mnesia认定发生了网络分区后，会记录到RabbitMQ的服务日志中：</p><figure class="highlight excel"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">=ERROR REPORT==== <span class="number">16</span>-Oct-<span class="symbol">2017:</span><span class="symbol">:18</span><span class="symbol">:20</span><span class="symbol">:55</span> ===</span><br><span class="line">Mnesia(&#x27;rabbit@node1&#x27;)<span class="symbol">:</span> ** ERROR ** mnesia_event got &#123;inconsistent_database, running_partitioned_network, &#x27;rabbit@node2&#x27;&#125;</span><br></pre></td></tr></table></figure><h4 id="（2）使用rabbitmqctl工具"><a href="#（2）使用rabbitmqctl工具" class="headerlink" title="（2）使用rabbitmqctl工具"></a>（2）使用rabbitmqctl工具</h4><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> rabbitmqctl cluster_status</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> 未发生网络分区：集群有三个节点</span></span><br><span class="line">[</span><br><span class="line">&#123;nodes,[&#123;disc, [rabbit@node1,rabbit@node2,rabbit@node3]&#125;]&#125;,</span><br><span class="line">&#123;running_nodes, [rabbit@node2,rabbit@node3,rabbit@node1]&#125;,</span><br><span class="line">&#123;cluster_name,&lt;&lt;&quot;rabbit@node1&quot;&gt;&gt;&#125;,</span><br><span class="line">&#123;partitions,[]&#125;</span><br><span class="line">]</span><br><span class="line"><span class="meta">#</span><span class="bash"> 发生网络分区：partitions内有相关内容，以下表示节点1和3分别与2发生了分区</span></span><br><span class="line">[</span><br><span class="line">&#123;nodes,[&#123;disc, [rabbit@node1,rabbit@node2,rabbit@node3]&#125;]&#125;,</span><br><span class="line">&#123;running_nodes, [rabbit@node3,rabbit@node1]&#125;,</span><br><span class="line">&#123;cluster_name,&lt;&lt;&quot;rabbit@node1&quot;&gt;&gt;&#125;,</span><br><span class="line">&#123;partitions,[&#123;rabbit@node3,[rabbit@node2]&#125;,&#123;rabbit@node1,[rabbit@node2]&#125;]&#125;</span><br><span class="line">]</span><br></pre></td></tr></table></figure><h4 id="（3）通过Web管理界面"><a href="#（3）通过Web管理界面" class="headerlink" title="（3）通过Web管理界面"></a>（3）通过Web管理界面</h4><p><img src="https://pic-1258215793.cos.ap-shanghai.myqcloud.com/content/20210901/202109010117.png"></p><h4 id="（4）通过HTTP-API来获取节点信息"><a href="#（4）通过HTTP-API来获取节点信息" class="headerlink" title="（4）通过HTTP API来获取节点信息"></a>（4）通过HTTP API来获取节点信息</h4><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> curl -i -u root:root123 -H <span class="string">&quot;content-type:application/json&quot;</span> -X GET http://localhost:15672/api/nodes</span></span><br></pre></td></tr></table></figure><ul><li>localhost：RabbitMQ服务器地址</li><li>/api/nodes：返回一个JSON字符串，其中有partitions相关项，若其中有内容则表示发生了网络分区。</li></ul><h2 id="三-模拟网络分区"><a href="#三-模拟网络分区" class="headerlink" title="三. 模拟网络分区"></a>三. 模拟网络分区</h2><p>通常很难观察到网络分区的发生，所以需要模拟出网络分区，方案有三类：</p><ul><li>iptables封禁/解封IP地址或端口号。</li><li>关闭/开启网卡。</li><li>挂起/恢复操作系统。</li></ul><h3 id="3-1-iptables方式"><a href="#3-1-iptables方式" class="headerlink" title="3.1 iptables方式"></a>3.1 iptables方式</h3><p>RabbitMQ集群内部节点通信端口默认为25672，封禁该端口来模拟出 <code>net_tick_timeout</code> ，再开启此端口让集群判定网络分区的发生。</p><p>假设集群有三个节点，我们在node2上执行如下命令来封禁25672端口：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> iptables -A INPUT -p tcp --dport 25672 -j DROP</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> iptables -A OUTPUT -p tcp --dport 25672 -j DROP</span></span><br></pre></td></tr></table></figure><p>并同时监测各个节点的服务日志，当出现类似信息时表示已判定出 <code>net_tick_timeout</code> 。</p><figure class="highlight excel"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">=<span class="built_in">INFO</span> REPORT==== <span class="number">10</span>-Oct-<span class="symbol">2017:</span><span class="symbol">:11</span><span class="symbol">:53</span><span class="symbol">:03</span> ===</span><br><span class="line">rabbit on node rabbit@node2 down</span><br><span class="line"></span><br><span class="line">=<span class="built_in">INFO</span> REPORT==== <span class="number">10</span>-Oct-<span class="symbol">2017:</span><span class="symbol">:11</span><span class="symbol">:53</span><span class="symbol">:03</span> ===</span><br><span class="line">rabbit@node2 do<span class="symbol">wn:</span> net_tick_timeout</span><br></pre></td></tr></table></figure><p>或者可以等待75秒之后确保发生了 <code>net_tick_timeout</code> ，此时还需要等待node2网络恢复之后才会判定出现网络分区。</p><p>解封命令：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> iptables -D INPUT 1</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> iptables -D OUTPUT 1</span></span><br></pre></td></tr></table></figure><p>node2节点已恢复与其它节点的通信，此时查看集群状态就可以发现出现了两个独立的分区。</p><p>上述是封禁端口来模拟，也可以封禁IP地址：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 在node2上执行</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> iptables -I INPUT -s 192.168.0.2 -j DROP</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> iptables -I INPUT -s 192.168.0.4 -j DROP</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> 解封</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> iptables -D INPUT 1</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> iptables -D OUTPUT 1</span></span><br><span class="line"><span class="meta"></span></span><br><span class="line"><span class="meta">#</span><span class="bash"> 也可以分别在node1或3上执行</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> iptables -I INPUT -s 192.168.0.3 -j DROP</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> 解封</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> iptables -D INPUT 1</span></span><br></pre></td></tr></table></figure><p>如果集群的节点部署跨网段，也可以采用封禁整个网络段的方式来模拟：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> node1 102.168.0.2</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> node2 102.168.1.3</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> node3 102.168.0.4</span></span><br><span class="line"><span class="meta"></span></span><br><span class="line"><span class="meta">$</span><span class="bash"> iptables -I INPUT -s 192.168.0.0/24 -j DROP</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> 解封</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> iptables -D INPUT 1</span></span><br></pre></td></tr></table></figure><h3 id="3-2-封禁-解封网卡的方式"><a href="#3-2-封禁-解封网卡的方式" class="headerlink" title="3.2 封禁/解封网卡的方式"></a>3.2 封禁/解封网卡的方式</h3><p>与方式一同为模拟网络故障：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 先用ifconfig来查询当前网卡编号</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> ifconfig</span></span><br><span class="line">eth0 ...</span><br><span class="line"><span class="meta">#</span><span class="bash"> 在node2上关闭网卡</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> ifdown eth0</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> 等待出net_tick_timeout后，再开启网卡</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> ifup eth0</span></span><br><span class="line"><span class="meta"></span></span><br><span class="line"><span class="meta">#</span><span class="bash"> 也可以通过以下命令来模拟</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> service network stop</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> service network start</span></span><br></pre></td></tr></table></figure><h3 id="3-3-挂起-恢复操作系统的方式"><a href="#3-3-挂起-恢复操作系统的方式" class="headerlink" title="3.3 挂起/恢复操作系统的方式"></a>3.3 挂起/恢复操作系统的方式</h3><p>发生挂起的节点不会认为自己已经失败或停止工作，但其它节点会这样认为，比如集群中某个节点运行在一台笔记本上，当笔记本合上此节点就挂起。等待T时间后，出现 <code>net_tick_timeout</code> 后，再恢复挂起的节点即可复现网络分区。</p><h2 id="四-网络分区的影响"><a href="#四-网络分区的影响" class="headerlink" title="四. 网络分区的影响"></a>四. 网络分区的影响</h2><h3 id="4-1-未配置镜像"><a href="#4-1-未配置镜像" class="headerlink" title="4.1 未配置镜像"></a>4.1 未配置镜像</h3><h4 id="（1）对发送端的影响"><a href="#（1）对发送端的影响" class="headerlink" title="（1）对发送端的影响"></a>（1）对发送端的影响</h4><p>假设有三个节点，与交换器绑定关系如下：</p><table><thead><tr><th>节点名称</th><th>交换器</th><th>绑定</th><th>队列</th></tr></thead><tbody><tr><td>node1</td><td>exchange</td><td>rk1</td><td>queue1</td></tr><tr><td>node2</td><td>exchange</td><td>rk2</td><td>queue2</td></tr><tr><td>node3</td><td>exchange</td><td>rk3</td><td>queue3</td></tr></tbody></table><p>网络分区发生前，客户端1和2分别连接node1和node2并向对应队列发送消息，消息存入队列：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">channel.basicPublish(<span class="string">&quot;exchange&quot;</span>, <span class="string">&quot;rk1&quot;</span>, <span class="keyword">true</span>, MessageProperties.PERSISTENT_TEXT_PLAIN, message.getBytes());</span><br></pre></td></tr></table></figure><p>使用iptables模拟网络分区后（关闭网卡会关闭客户端连接），使node1和node2处于不同分区中，对于客户端来说没有影响。</p><p>如果客户端1连接node1，并向queue2发送消息。模拟分区后，如果客户端在发送消息时将mandatory设置为true，网络分区之后可以通过抓包工具看到有Basic.Return将发送的消息返回，表示<strong>发生网络分区后，client1不能正确的将消息发送到queue2中</strong>。</p><p><strong>保证消息可靠性的方案：客户端若设置了ReturnListener来监听Basic.Return的信息，并附带有消息重传机制，则整个网络分区前后过程可以保证发送端消息不丢失。</strong></p><p>在网络分区发生前，queue1进程存在于node1节点，queue2则于node2节点，网络分区发生后，node1不会创建新的node2，所以client1将消息发送到exchange后并不能路由到queue2。若没有采用上述方案，就会发生消息丢失。不过此时仍可以通过指令看到队列：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> rabbitmqctl list_queues name</span></span><br><span class="line">...</span><br><span class="line">queue2</span><br><span class="line">...</span><br></pre></td></tr></table></figure><h4 id="（2）对消费端的影响"><a href="#（2）对消费端的影响" class="headerlink" title="（2）对消费端的影响"></a>（2）对消费端的影响</h4><p>假设网络分区发生前，客户端3和4分别连接node1和2，但分别消费queue2和queue1（不交换的情况和发送端一样无影响）。在网络分区发生后，客户端虽然不会报错，也可以消费到内容。但会有如已消费消息的ack失效等现象发生，网络分区恢复后，数据不会丢失。</p><p>如果分区之后，重启client3或有个新的客户端连接node1来消费queue2，会有报错：</p><figure class="highlight oxygene"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">com.rabbitmq.client.ShutdownSignalException: channel error; protocol <span class="function"><span class="keyword">method</span>:</span> #<span class="function"><span class="keyword">method</span>&lt;<span class="title">channel</span>.<span class="title">close</span>&gt;<span class="params">(reply-code=404, reply-text=NOT_FOUND - home node <span class="string">&#x27;rabbit@node2&#x27;</span> <span class="keyword">of</span> durable queue <span class="string">&#x27;queue2&#x27;</span> <span class="keyword">in</span> vhost <span class="string">&#x27;/&#x27;</span> <span class="keyword">is</span> down <span class="keyword">or</span> inaccessible, <span class="keyword">class</span>-id=60, <span class="keyword">method</span>-id=20)</span></span></span><br></pre></td></tr></table></figure><p>node1的服务日志中也有相关记录：</p><figure class="highlight excel"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">=ERROR REPORT==== <span class="number">12</span>-Oct-<span class="symbol">2017:</span><span class="symbol">:14</span><span class="symbol">:14</span><span class="symbol">:48</span> ===</span><br><span class="line">Channel error on connection &lt;<span class="number">0.9538</span>.<span class="number">9</span>&gt; (<span class="number">192.168</span>.<span class="number">0.9</span><span class="symbol">:61294</span> -&gt; <span class="number">192.168</span>.<span class="number">0.2</span><span class="symbol">:5672</span>, vho<span class="symbol">st:</span> &#x27;/&#x27;, us<span class="symbol">er:</span> &#x27;root&#x27;), channel <span class="symbol">1:</span></span><br><span class="line">&#123;amqp_error,not_found,<span class="string">&quot;home node &#x27;rabbit@ndoe2&#x27; of durable queue &#x27;queue2&#x27; in vhost &#x27;/&#x27; is down or inaccessible&quot;</span>, &#x27;basic.consume&#x27;&#125;</span><br></pre></td></tr></table></figure><p>未配置镜像的集群，在网络分区发生后，队列也会随着节点而分散在各自的分区中。</p><ul><li>对于消息发送方，可以成功发送消息，但会有路由失败的现象，需要配合mandatory等机制保证消息的可靠性。</li><li>对于消息消费方，可能会有诡异、不可预知的现象发生，如已消费消息的ack失效。</li><li>如果网络分区发生后，客户端与某分区重新建立通信链路，其分区若没有对应得队列进程，则会由异常抛出。</li><li>如果从网络分区中恢复后，数据不会丢失，但客户端会重复消费。</li></ul><h3 id="4-2-已配置镜像"><a href="#4-2-已配置镜像" class="headerlink" title="4.2 已配置镜像"></a>4.2 已配置镜像</h3><p>已配置镜像队列的情况要比未配置复杂得多。假设集群有三个节点，采用iptables方式将集群模拟分裂为两个网络分区[node1, node3]和[node2]。</p><p>镜像队列：</p><figure class="highlight properties"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">ha-mode</span>:<span class="string">exactly</span></span><br><span class="line"><span class="meta">ha-param</span>:<span class="string">2</span></span><br><span class="line"><span class="meta">ha-sync-mode</span>:<span class="string">automatic</span></span><br></pre></td></tr></table></figure><p>分区之前：</p><table><thead><tr><th>队列</th><th>master</th><th>slave</th></tr></thead><tbody><tr><td>queue1</td><td>node1</td><td>node3</td></tr><tr><td>queue2</td><td>node2</td><td>node3</td></tr><tr><td>queue3</td><td>node3</td><td>node2</td></tr></tbody></table><p>分区之后，[node1, node3]分区中的队列有了新的部署，queue1未发生变化，queue2因为原宿主节点node2被剥离，所以node3提升为master，同时选择node1作为slave。queue3则重新选择node1为新的slave：</p><table border="1" style="margin-top:10">    <tr>        <td rowspan="2" align="center">队列</td>         <td colspan="2" align="center">[node1, node3]分区</td>         <td colspan="2" align="center">[node2]分区</td>    </tr>    <tr>        <td align="center">master</td>            <td align="center">slave</td>            <td align="center">master</td>            <td align="center">slave</td>        </tr>    <tr>        <td align="center">queue1</td>           <td align="center">node1</td>         <td align="center">node3</td>         <td align="center">node1</td>         <td align="center">node3</td>     </tr>    <tr>        <td align="center">queue2</td>           <td align="center">node3</td>         <td align="center">node1</td>         <td align="center">node2</td>         <td align="center">[]</td>     </tr>    <tr>        <td align="center">queue3</td>           <td align="center">node3</td>         <td align="center">node1</td>         <td align="center">node2</td>         <td align="center">[]</td>     </tr></table><p>对于queue1，网络分区前后不会对生产和消费造成影响。</p><p>对于queue2和queue3则会和未配置镜像一样，恢复后有可能会有数据丢失。</p><p>当有新的slave出现时，会自动同步master的数据，在同步的过程中，集群的整个服务都不可用，客户端连接会被阻塞。如果master中有大量的消息堆积，必然会造成slave的同步时间增长，进一步影响了集群服务的可用性。若配置了 <code>ha-sync-mode=manual</code> 在新的slave创建时不会同步master上旧的数据，若master节点发生了异常，则此部分数据会丢失。</p><h3 id="4-3-网络分区造成的消息丢失如何解决？"><a href="#4-3-网络分区造成的消息丢失如何解决？" class="headerlink" title="4.3 网络分区造成的消息丢失如何解决？"></a>4.3 网络分区造成的消息丢失如何解决？</h3><ul><li>首先，消息发送端要有处理 <code>Basic.Return</code> 的能力。</li><li>其次，检测到网络分区发生后，要迅速的挂起所有生产者进程。</li><li>之后，连接每个节点消费分区中的所有队列数据。在消费完之后再处理网络分区。</li><li>最后，再从网络分区中恢复生产者的进程。</li><li>需要注意整个过程会伴有大量的消息重复，消费者客户端要做好相应的幂等性处理。</li></ul><p>还有方案：<strong>集群迁移</strong>，将所有旧集群资源迁移到新集群来解决问题。</p><h2 id="五-如何处理网络分区"><a href="#五-如何处理网络分区" class="headerlink" title="五. 如何处理网络分区"></a>五. 如何处理网络分区</h2><h3 id="5-1-手动处理网络分区"><a href="#5-1-手动处理网络分区" class="headerlink" title="5.1 手动处理网络分区"></a>5.1 手动处理网络分区</h3><p>从网络分区中恢复，首先要挑选一个信任分区，该分区有决定Mnesia内容的权限，发生在其余分区的改变不会记录在Mnesia而直接丢弃。然后重启非信任分区中的节点，若此时还有网络分区的告警，则紧接着重启信任分区中的节点。</p><h4 id="（1）如何挑选信任分区？"><a href="#（1）如何挑选信任分区？" class="headerlink" title="（1）如何挑选信任分区？"></a>（1）如何挑选信任分区？</h4><p>挑选信任分区的优先级由高至低：</p><ul><li>分区中要有disc节点；</li><li>分区中节点数最多；</li><li>分区中队列数最多；</li><li>分区中客户端连接最多。</li></ul><p>（若有多个分区这些条件都相等，则随机挑选）</p><h4 id="（2）如何重启节点？"><a href="#（2）如何重启节点？" class="headerlink" title="（2）如何重启节点？"></a>（2）如何重启节点？</h4><p>重启RabbitMQ的方式：</p><ol><li><code>rabbitmqctl stop</code> 关闭，<code>rabbitmq-server -detached</code> 启动（同时重启Erlang虚拟机和RabbitMQ）；</li><li><code>rabbitmqctl stop_app</code> 关闭，<code>rabbitmqctl start_app</code> 启动（只重启RabbitMQ，从网络分区恢复推荐该种）。</li></ol><h4 id="（3）重启的顺序如何确定？"><a href="#（3）重启的顺序如何确定？" class="headerlink" title="（3）重启的顺序如何确定？"></a>（3）重启的顺序如何确定？</h4><p>配置镜像队列出现的漂移现象：依次关闭节点，导致master最终都漂移到一个节点上，之后重启节点只会增加slave的个数，而不会改变master的分布。对于RabbitMQ来说，除了发布消息其余操作都在master上完成，因此压力都集中到了单个节点，不能很好的负载均衡。</p><p>重启顺序的两种方式：</p><ol><li>停止其它非信任分区中的所有节点，然后再启动每一个节点，如果此时还有网络分区的告警，则再重启信任分区中的节点以清除告警。</li><li>关闭整个集群的节点，然后再启动每一个节点，需要确保第一个节点在信任分区。</li></ol><p>如果采用挨个节点重启的方式，会有Mnesia内容权限归属问题，也有可能引起二次网络分区。</p><p>解决镜像队列漂移问题，可以在重启前先删除镜像队列的配置（需要在每个队列上都删除镜像队列）：</p><ul><li><p>通过命令删除：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> rabbitmqctl clear_policy [-p vhost] &#123;mirror_queue_name&#125;</span></span><br></pre></td></tr></table></figure></li><li><p>通过HTTP API或WEB界面删除：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> curl -s -u &#123;username:password&#125; -X DELETE http://localhost:15672/api/policies/default/&#123;mirror_queue_name&#125;</span></span><br></pre></td></tr></table></figure></li></ul><h4 id="（4）如何判断已从网络分区恢复？"><a href="#（4）如何判断已从网络分区恢复？" class="headerlink" title="（4）如何判断已从网络分区恢复？"></a>（4）如何判断已从网络分区恢复？</h4><p>可以参考第二节的内容，如使用 <code>rabbitmqctl cluster_status</code> 命令检测输出的partitions是否有节点信息。也可以通过Web界面或HTTP API的方式。</p><h4 id="（5）总结步骤"><a href="#（5）总结步骤" class="headerlink" title="（5）总结步骤"></a>（5）总结步骤</h4><ol><li>挂起生产者和消费者进程，从而减少消息不必要的丢失，如果进程数过多且情况紧急，可以跳过该步骤。</li><li>删除镜像队列的配置。</li><li>挑选信任分区。</li><li>关闭非信任分区的节点，采用 <code>rabbitmqctl stop_app</code> 关闭。</li><li>启动非信任分区的节点，采用 <code>rabbitmqctl start_app</code> 启动。</li><li>检查网络分区是否恢复，如果已恢复则跳至步骤8，若还有网络分区报警则进行步骤7。</li><li>重启信任分区中的节点。</li><li>添加镜像队列的配置。</li><li>恢复生产者和消费者进程。</li></ol><h3 id="5-2-自动处理网络分区"><a href="#5-2-自动处理网络分区" class="headerlink" title="5.2 自动处理网络分区"></a>5.2 自动处理网络分区</h3><p>RabbitMQ提供了三种自动处理网络分区的方法：</p><ul><li>pause-minority模式</li><li>pause-if-all-down模式</li><li>autoheal模式</li><li>默认为ignore模式，即不自动处理。</li></ul><p>在配置文件 <code>rabbitmq.config</code> 中配置 <code>cluster_partition_handling</code> 参数：</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">[</span><br><span class="line">    &#123;</span><br><span class="line">        rabbit, [</span><br><span class="line">        &#123;cluster_partition_handling, igbore&#125;</span><br><span class="line">        ]</span><br><span class="line">    &#125;</span><br><span class="line">]</span><br></pre></td></tr></table></figure><h4 id="（1）pause-minority模式"><a href="#（1）pause-minority模式" class="headerlink" title="（1）pause-minority模式"></a>（1）pause-minority模式</h4><p>该模式下，发生网络分区时，集群中的节点观察到某些节点down掉时会自动检测自身是否处于少数派（分区中的节点小于或等于集群中一半的节点数），RabbitMQ会自动关闭这些节点的运作。</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">[</span><br><span class="line">    &#123;</span><br><span class="line">        rabbit, [</span><br><span class="line">        &#123;cluster_partition_handling, pause-minority&#125;</span><br><span class="line">        ]</span><br><span class="line">    &#125;</span><br><span class="line">]</span><br></pre></td></tr></table></figure><p>根据CAP原理，此处保证了分区耐受性P，确保在发生网络分区的情况下大多数同个分区的节点可以继续运行。少数派的节点在分区开始时关闭，分区结束后启动（只关闭RabbitMQ，不关闭Erlang）。处于关闭的节点每秒检测依次是否可连通到剩余集群，可以时启动自己。</p><p>当集群中只有两个节点时不适合采用该模式，因为任何一个节点失败发生网络分区时，两个节点都会关闭，在网络恢复时两个节点自动恢复网络分区，也有可能保持关闭状态。对于2V2和3V3等对等分裂的情况，在跨机器部署时很有可能发生，会关闭这些分区内所有节点。</p><h4 id="（2）pause-if-all-down模式"><a href="#（2）pause-if-all-down模式" class="headerlink" title="（2）pause-if-all-down模式"></a>（2）pause-if-all-down模式</h4><p>该模式下，集群中的节点在和所配置列表中任何节点不能交互时才会关闭，配置如下：</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">[</span><br><span class="line">    &#123;</span><br><span class="line">        rabbit, [</span><br><span class="line">        &#123;cluster_partition_handling, </span><br><span class="line">             &#123;pause_if_all_down, [&#x27;rabbit@node1&#x27;], ignore&#125;</span><br><span class="line">            &#125;</span><br><span class="line">        ]</span><br><span class="line">    &#125;</span><br><span class="line">]</span><br></pre></td></tr></table></figure><ul><li>如果一个节点与node1无法通信，则会关闭自身的RabbitMQ。</li><li>如果是node1本身发生了故障造成网络不可用，其它节点都是正常，则所有节点都要关闭RabbitMQ，等待node1恢复后，各个节点再启动MQ从网络分区中恢复。</li></ul><p>该模式下有ignore和autoheal两种配置，如果出现上一个所述的对等分裂，两台机器部署4个节点，机器间通信异常，但机器上两个节点保持通信，假设又配置了两个机器各一个节点，则这四个节点都不会自行关闭。此时把配置中的ignore改为autoheal可以处理这种情况。</p><h4 id="（3）autoheal模式"><a href="#（3）autoheal模式" class="headerlink" title="（3）autoheal模式"></a>（3）autoheal模式</h4><p>该模式下发生网络分区时，RabbitMQ会自动决定一个获胜的分区，然后重启不在这个分区中的节点来恢复网络分区。</p><p>获胜分区的选择优先级从高到低：</p><ul><li>客户端连接数最多；</li><li>节点数最多；</li><li>节点名称的字典序。</li></ul><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">[</span><br><span class="line">    &#123;</span><br><span class="line">        rabbit, [</span><br><span class="line">        &#123;cluster_partition_handling, autoheal&#125;</span><br><span class="line">        ]</span><br><span class="line">    &#125;</span><br><span class="line">]</span><br></pre></td></tr></table></figure><ul><li>对于pause-minority模式，关闭节点的状态是网络故障时（判断出net_tick_timout）会关闭少数派分区中的节点，等待网络恢复之后（即出现网络分区后）启动关闭的节点来从网络分区中恢复。</li><li>auto模式再判定出net_tick_timout时不做动作，要等到网络恢复后才重启非获胜分区的节点。</li></ul><h4 id="（4）挑选哪种模式"><a href="#（4）挑选哪种模式" class="headerlink" title="（4）挑选哪种模式"></a>（4）挑选哪种模式</h4><p>允许MQ自动处理网络分区并不一定会又正面的效果，如果MQ处于一个不可靠的网络环境下，需要使用Federation或Shovel，就算恢复后也要谨防二次网络分区。</p><ul><li>ignore：发生网络分区时不做任何动作，需要人工介入。</li><li>pause-minority：对于对等分区的处理不够优雅，可能会关闭所有的节点。可以应用于非跨机架、奇数节点数的集群中。</li><li>pause-if-all-down：对于受信节点的选择尤为考究，尤其是集群中所有节点配置相同的情况下，可以处理对等分区的情况。</li><li>autoheal：可以处理各种情况下的网络分区，但如果集群中有节点处于非运行状态，该模式会失效。</li></ul><h2 id="六-多分区的案例"><a href="#六-多分区的案例" class="headerlink" title="六. 多分区的案例"></a>六. 多分区的案例</h2><p>当集群中物理机是多网卡，当某个节点网卡发生故障可能会发生多个分区的情况。</p><p>假设集群有6个节点，每个节点的物理机都是4网卡（eth0到eth3），并采用bind0的绑定模式。当node6的eth0发生故障后，整个集群演变为6个分区，每个节点都是一个独立的分区。</p><p>网络分区前：</p><p><img src="https://pic-1258215793.cos.ap-shanghai.myqcloud.com/content/20210901/202109010118.png"></p><p><img src="https://pic-1258215793.cos.ap-shanghai.myqcloud.com/content/20210901/202109010119.png"></p><p>当node6网被关闭，对于bind0模式，交换机无法感知eth0网卡的故障，但node6节点能够感知本地eth0的故障。对于node3节点，其与node6的eth0网卡建立的长连接没有关闭，node3会向node6重试发送数据，但node6无法回应，除非主动关闭或等待长连接超时（默认7200s，即2小时）链路才会关闭。</p><p>node6网卡关闭后，node1、node3和node6发生变化：</p><ol><li><p>与node6的eth0链路不通，node3等待net_ticktime的超时。node3相关日志：</p><figure class="highlight crmsh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">rabbit on <span class="keyword">node</span> <span class="title">&#x27;rabbit</span>@node6&#x27; down</span><br><span class="line"><span class="keyword">node</span> <span class="title">&#x27;rabbit</span>@node6&#x27; down: net_tick_timeout</span><br></pre></td></tr></table></figure></li><li><p>待超时后，主动关闭连接。node3相关日志：</p><figure class="highlight crmsh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">node</span> <span class="title">&#x27;rabbit</span>@node6&#x27; down: connection_closed</span><br></pre></td></tr></table></figure><p>同时Erlang虚拟机尝试让node3与node6重新连接，因为node6其它网卡正常，所以连接可以正确建立。</p><figure class="highlight crmsh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">node</span> <span class="title">&#x27;rabbit</span>@node6&#x27; up</span><br></pre></td></tr></table></figure></li><li><p>判定node3和node6之间产生了网络分区。</p><figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Mnesia(<span class="string">&#x27;rabbit@node3&#x27;</span>): ** <span class="builtin-name">ERROR</span> ** mnesia_event got &#123;inconsistent_database, running_partitioned_network, <span class="string">&#x27;rabbit@node6&#x27;</span>&#125;</span><br></pre></td></tr></table></figure></li><li><p>此时node3和node1还处于连通状态，同样node6和node1也处于连通状态，node3日志：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Partial <span class="keyword">partition</span> detected:</span><br><span class="line"><span class="operator">*</span> We saw DOWN <span class="keyword">from</span> rabbit<span class="variable">@node6</span></span><br><span class="line"><span class="operator">*</span> We can still see rabbit<span class="variable">@node1</span> which can see rabbit<span class="variable">@node6</span></span><br><span class="line">We will therefore intentionally <span class="keyword">disconnect</span> <span class="keyword">from</span> rabbit<span class="variable">@node1</span></span><br></pre></td></tr></table></figure><p>表示node3和node6发生了网络分区，但node3发现node1和node6内部通信还未断，此时认为node1和node6处于同一个分区，node3准备主动关闭与node1的通信，所以node1和node3也发生了分区。</p></li><li><p>同时，对于node6来说，node1和node3还处于同一分区，所以node6也要讲node1置于node6本身分区之外，所以三个节点都将处于不同分区。</p><p>node1日志：</p><figure class="highlight excel"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">=ERROR REPORT==== <span class="number">16</span>-Oct-<span class="symbol">2017:</span><span class="symbol">:14</span><span class="symbol">:20</span><span class="symbol">:54</span> ===</span><br><span class="line">Partial partition detect<span class="symbol">ed:</span></span><br><span class="line">* We saw DOWN from rabbit@node3</span><br><span class="line">* We can still see rabbit@node4 which can see rabbit@node3</span><br><span class="line">We will therefore intentionally disconnect from rabbit@node4</span><br><span class="line">=<span class="built_in">INFO</span> REPORT==== <span class="number">16</span>-Oct-<span class="symbol">2017:</span><span class="symbol">:14</span><span class="symbol">:20</span><span class="symbol">:55</span> ===</span><br><span class="line">node &#x27;rabbit@node4&#x27; do<span class="symbol">wn:</span> disconnect</span><br><span class="line">=<span class="built_in">INFO</span> REPORT==== <span class="number">16</span>-Oct-<span class="symbol">2017:</span><span class="symbol">:14</span><span class="symbol">:20</span><span class="symbol">:55</span> ===</span><br><span class="line">node &#x27;rabbit@node4&#x27; up</span><br><span class="line">=ERROR REPORT==== <span class="number">16</span>-Oct-<span class="symbol">2017:</span><span class="symbol">:14</span><span class="symbol">:20</span><span class="symbol">:55</span> ===</span><br><span class="line">Mnesia(&#x27;rabbit@node1&#x27;)<span class="symbol">:</span> ** ERROR ** mnesia_event got &#123;inconsistent_database, running_partitioned_network, &#x27;rabbit@node4&#x27;&#125;</span><br></pre></td></tr></table></figure><p>此时node1察觉node4与node3还有内部通信交换，主动将node4剥离出自身分区。</p></li><li><p>以此下去直到每个节点都分离出自己的分区。</p></li></ol><p>对于这种情况采用自动模式的效果：</p><ul><li>pause_if_all_down：挑选一个节点作为受信节点，重启剩余5个节点恢复。</li><li>autoheal：同样，查看日志可以发现，会等网络分区判定之后罗列出所有分区信息，再重启非获胜分区节点（同样是5个）。</li><li>pause_minority：最优雅，当有节点检测到net_tick_timeout后自行重启当前节点，阻止了网络分区进一步演变，处理效率最高。</li></ul><hr><p>参考：</p><p>🔗 《RabbitMQ实战指南》</p>]]></content>
    
    
    <summary type="html">学习RabbitMQ，第九章《网络分区》，内容来自于《RabbitMQ实战指南》，内容：MQ与网络分区、如何判定网络分区、模拟网络分区、网络分区的影响、如何处理网络分区等。</summary>
    
    
    
    <category term="技术文档" scheme="http://linyishui.top/categories/%E6%8A%80%E6%9C%AF%E6%96%87%E6%A1%A3/"/>
    
    
    <category term="distributed" scheme="http://linyishui.top/tags/distributed/"/>
    
    <category term="mom" scheme="http://linyishui.top/tags/mom/"/>
    
    <category term="rabbitmq" scheme="http://linyishui.top/tags/rabbitmq/"/>
    
  </entry>
  
  <entry>
    <title>Java诊断工具-Arthas</title>
    <link href="http://linyishui.top/2021091601.html"/>
    <id>http://linyishui.top/2021091601.html</id>
    <published>2021-09-16T12:51:44.000Z</published>
    <updated>2021-09-22T11:21:54.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Java诊断工具-Arthas"><a href="#Java诊断工具-Arthas" class="headerlink" title="Java诊断工具-Arthas"></a>Java诊断工具-Arthas</h1><h2 id="一-简介"><a href="#一-简介" class="headerlink" title="一. 简介"></a>一. 简介</h2><ul><li>官网：<a href="https://arthas.aliyun.com/zh-cn/">Arthas 应用诊断利器</a></li><li>Alibaba开源的Java诊断工具；在线排查问题，无需重启；动态跟踪Java代码；实时监控JVM状态。</li><li>支持JDK6+；支持Linux/Mac/Windows;命令行式交互模式。</li></ul><p>解决如下问题：</p><ol><li>这个类从哪个 jar 包加载的？为什么会报各种类相关的 Exception？</li><li>我改的代码为什么没有执行到？难道是我没 commit？分支搞错了？</li><li>遇到问题无法在线上 debug，难道只能通过加日志再重新发布吗？</li><li>线上遇到某个用户的数据处理有问题，但线上同样无法 debug，线下无法重现！</li><li>是否有一个全局视角来查看系统的运行状况？</li><li>有什么办法可以监控到JVM的实时运行状态？</li><li>怎么快速定位应用的热点，生成火焰图？</li><li>怎样直接从JVM内查找某个类的实例？</li></ol><h2 id="二-教程"><a href="#二-教程" class="headerlink" title="二. 教程"></a>二. 教程</h2><p>内容全部来源自官网。</p><h3 id="2-1-入门"><a href="#2-1-入门" class="headerlink" title="2.1 入门"></a>2.1 入门</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 下载一个Jar包，并启动</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> wget https://arthas.aliyun.com/math-game.jar</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> java -jar math-game.jar</span></span><br><span class="line"><span class="meta"></span></span><br><span class="line"><span class="meta">#</span><span class="bash"> 新窗口下载Arthas的启动Jar包，并启动</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> wget https://arthas.aliyun.com/arthas-boot.jar</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> java -jar arthas-boot.jar</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> 启动后列出所有Java进程，输入对应</span></span><br><span class="line"><span class="meta"></span></span><br><span class="line"><span class="meta"></span></span><br><span class="line"><span class="meta">#</span><span class="bash"> dashboard 命令可以查看当前系统的实时数据面板</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> dashboard</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> 输入 Q 或者 Ctrl+C 可以退出dashboard命令。</span></span><br><span class="line"><span class="meta"></span></span><br><span class="line"><span class="meta"></span></span><br><span class="line"><span class="meta">#</span><span class="bash"> thread 1 命令会打印线程ID 1的栈。</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> thread 1</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> Arthas支持管道，可以用 thread 1 | grep <span class="string">&#x27;main(&#x27;</span> 查找到main class。</span></span><br><span class="line"><span class="meta"></span></span><br><span class="line"><span class="meta">#</span><span class="bash"> 可以看到main class是demo.MathGame：</span></span><br><span class="line"><span class="meta"></span></span><br><span class="line"><span class="meta">$</span><span class="bash"> thread 1 | grep <span class="string">&#x27;main(&#x27;</span></span></span><br><span class="line">    at demo.MathGame.main(MathGame.java:17)</span><br><span class="line"><span class="meta"></span></span><br><span class="line"><span class="meta">#</span><span class="bash"> 可以通过 sc 命令来查找JVM里已加载的类：</span></span><br><span class="line"><span class="meta"></span></span><br><span class="line"><span class="meta">$</span><span class="bash"> sc -d *MathGame</span></span><br><span class="line"><span class="meta"></span></span><br><span class="line"><span class="meta">#</span><span class="bash"> 可以通过 jad 命令来反编译代码：</span></span><br><span class="line"><span class="meta"></span></span><br><span class="line"><span class="meta">$</span><span class="bash"> jad demo.MathGame</span></span><br><span class="line"><span class="meta"></span></span><br><span class="line"><span class="meta">#</span><span class="bash"> 通过watch命令可以查看函数的参数/返回值/异常信息。</span></span><br><span class="line"><span class="meta"></span></span><br><span class="line"><span class="meta">$</span><span class="bash"> watch demo.MathGame primeFactors returnObj</span></span><br><span class="line"><span class="meta"></span></span><br><span class="line"><span class="meta">#</span><span class="bash"> 输入 Q 或者 Ctrl+C 退出watch命令。</span></span><br><span class="line"><span class="meta"></span></span><br><span class="line"><span class="meta">#</span><span class="bash"> 通过vmtool命令，可以搜索内存对象。</span></span><br><span class="line"><span class="meta"></span></span><br><span class="line"><span class="meta">$</span><span class="bash"> vmtool --action getInstances --className java.lang.String --<span class="built_in">limit</span> 10</span></span><br><span class="line"><span class="meta"></span></span><br><span class="line"><span class="meta"></span></span><br><span class="line"><span class="meta">#</span><span class="bash"> 用 <span class="built_in">exit</span> 或者 quit 命令可以退出Arthas。</span></span><br><span class="line"><span class="meta"></span></span><br><span class="line"><span class="meta">#</span><span class="bash"> 退出Arthas之后，还可以再次用 java -jar arthas-boot.jar 来连接。</span></span><br><span class="line"><span class="meta"></span></span><br><span class="line"><span class="meta">#</span><span class="bash"> <span class="built_in">exit</span>/quit命令只是退出当前session，arthas server还在目标进程中运行。</span></span><br><span class="line"><span class="meta"></span></span><br><span class="line"><span class="meta">#</span><span class="bash"> 想完全退出Arthas，可以执行 stop 命令。</span></span><br></pre></td></tr></table></figure><p>安装：<a href="https://arthas.aliyun.com/doc/install-detail.html">Arthas Install — Arthas 3.5.4 文档 (aliyun.com)</a></p><h3 id="2-2-进阶"><a href="#2-2-进阶" class="headerlink" title="2.2 进阶"></a>2.2 进阶</h3><h4 id="2-2-1-查看JVM信息"><a href="#2-2-1-查看JVM信息" class="headerlink" title="2.2.1 查看JVM信息"></a>2.2.1 查看JVM信息</h4><ul><li><p>sysprop：</p><p>可以打印所有的System Properties信息。</p><p>也可以指定单个key： <code>sysprop java.version</code></p><p>也可以通过<code>grep</code>来过滤： <code>sysprop | grep user</code></p><p>可以设置新的value： <code>sysprop testKey testValue</code></p></li><li><p>sysenv：<code>sysenv</code> 命令可以获取到环境变量。和<code>sysprop</code>命令类似。</p></li><li><p>jvm：<code>jvm</code> 命令会打印出<code>JVM</code>的各种详细信息。</p></li><li><p>dashboard：<code>dashboard</code> 命令可以查看当前系统的实时数据面板。输入 <code>Q</code> 或者 <code>Ctrl+C</code> 可以退出dashboard命令。</p></li></ul><h4 id="2-2-2-Tips"><a href="#2-2-2-Tips" class="headerlink" title="2.2.2 Tips"></a>2.2.2 Tips</h4><ul><li><p>help：Arthas里每一个命令都有详细的帮助信息。可以用<code>-h</code>来查看。帮助信息里有<code>EXAMPLES</code>和<code>WIKI</code>链接。比如：<code>sysprop -h</code></p></li><li><p>自动补全：Arthas支持丰富的自动补全功能，在使用有疑惑时，可以输入<code>Tab</code>来获取更多信息。</p><p>比如输入 <code>sysprop java.</code> 之后，再输入<code>Tab</code>，会补全出对应的key：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> sysprop java.</span></span><br><span class="line">java.runtime.name             java.protocol.handler.pkgs    java.vm.version</span><br><span class="line">java.vm.vendor                java.vendor.url               java.vm.name</span><br><span class="line">...</span><br></pre></td></tr></table></figure></li><li><p>readline的快捷键支持：</p><p>Arthas支持常见的命令行快捷键，比如<code>Ctrl + A</code>跳转行首，<code>Ctrl + E</code>跳转行尾。</p><p>更多的快捷键可以用 <code>keymap</code> 命令查看。</p></li><li><p>历史命令的补全：</p><p>如果想再执行之前的命令，可以在输入一半时，按<code>Up/↑</code> 或者 <code>Ddown/↓</code>，来匹配到之前的命令。</p><p>比如之前执行过<code>sysprop java.version</code>，那么在输入<code>sysprop ja</code>之后，可以输入<code>Up/↑</code>，就会自动补全为<code>sysprop java.version</code>。</p><p>如果想查看所有的历史命令，也可以通过 <code>history</code> 命令查看到。</p></li><li><p>pipeline：</p><p>Arthas支持在pipeline之后，执行一些简单的命令，比如：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> sysprop | grep java</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> sysprop | wc -l</span></span><br></pre></td></tr></table></figure></li></ul><h4 id="2-2-3-sc-sm-查看已加载的类"><a href="#2-2-3-sc-sm-查看已加载的类" class="headerlink" title="2.2.3 sc/sm 查看已加载的类"></a>2.2.3 sc/sm 查看已加载的类</h4><ul><li><p>sc：</p><p><code>sc</code> 命令可以查找到所有JVM已经加载到的类。</p><p>如果搜索的是接口，还会搜索所有的实现类。比如查看所有的<code>Filter</code>实现类：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> sc javax.servlet.Filter</span></span><br></pre></td></tr></table></figure><p>通过<code>-d</code>参数，可以打印出类加载的具体信息，很方便查找类加载问题。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> sc -d javax.servlet.Filter</span></span><br></pre></td></tr></table></figure><p><code>sc</code>支持通配，比如搜索所有的<code>StringUtils</code>：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> sc *StringUtils</span></span><br></pre></td></tr></table></figure></li><li><p>sm：</p><p><code>sm</code>命令则是查找类的具体函数。比如：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> sm java.math.RoundingMode</span></span><br></pre></td></tr></table></figure><p>通过<code>-d</code>参数可以打印函数的具体属性：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> sm -d java.math.RoundingMode</span></span><br></pre></td></tr></table></figure><p>也可以查找特定的函数，比如查找构造函数：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> sm java.math.RoundingMode &lt;init&gt;</span></span><br></pre></td></tr></table></figure></li></ul><h4 id="2-2-4-Jad反编译代码"><a href="#2-2-4-Jad反编译代码" class="headerlink" title="2.2.4 Jad反编译代码"></a>2.2.4 Jad反编译代码</h4><p>可以通过 <code>jad</code> 命令来反编译代码：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> jad com.example.demo.arthas.user.UserController</span></span><br></pre></td></tr></table></figure><p>通过<code>--source-only</code>参数可以只打印出在反编译的源代码：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> jad --source-only com.example.demo.arthas.user.UserController</span></span><br></pre></td></tr></table></figure><h4 id="2-2-5-Ognl动态执行代码"><a href="#2-2-5-Ognl动态执行代码" class="headerlink" title="2.2.5 Ognl动态执行代码"></a>2.2.5 Ognl动态执行代码</h4><p>在Arthas里，有一个单独的<code>ognl</code>命令，可以动态执行代码。</p><h5 id="调用static函数"><a href="#调用static函数" class="headerlink" title="调用static函数"></a>调用static函数</h5><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> ognl <span class="string">&#x27;@java.lang.System@out.println(&quot;hello ognl&quot;)&#x27;</span></span></span><br></pre></td></tr></table></figure><p>可以检查<code>Terminal 1</code>（不是arthas的Terminal 2）里的进程输出，可以发现打印出了<code>hello ognl</code>。</p><h5 id="查找UserController的ClassLoader"><a href="#查找UserController的ClassLoader" class="headerlink" title="查找UserController的ClassLoader"></a>查找UserController的ClassLoader</h5><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> sc -d com.example.demo.arthas.user.UserController | grep classLoaderHash</span></span><br><span class="line"> classLoaderHash   1be6f5c3</span><br></pre></td></tr></table></figure><p>注意hashcode是变化的，需要先查看当前的ClassLoader信息，提取对应ClassLoader的hashcode。</p><p>如果你使用<code>-c</code>，你需要手动输入hashcode：<code>-c &lt;hashcode&gt;</code></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ ognl -c 1be6f5c3 @com.example.demo.arthas.user.UserController@logger</span><br></pre></td></tr></table></figure><p>对于只有唯一实例的ClassLoader可以通过<code>--classLoaderClass</code>指定class name，使用起来更加方便：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">$ ognl --classLoaderClass org.springframework.boot.loader.LaunchedURLClassLoader  @org.springframework.boot.SpringApplication@logger</span><br><span class="line">@Slf4jLocationAwareLog[</span><br><span class="line">    FQCN=@String[org.apache.commons.logging.LogAdapter<span class="variable">$Slf4jLocationAwareLog</span>],</span><br><span class="line">    name=@String[org.springframework.boot.SpringApplication],</span><br><span class="line">    logger=@Logger[Logger[org.springframework.boot.SpringApplication]],</span><br><span class="line">]</span><br></pre></td></tr></table></figure><p><code>--classLoaderClass</code> 的值是ClassLoader的类名，只有匹配到唯一的ClassLoader实例时才能工作，目的是方便输入通用命令，而<code>-c &lt;hashcode&gt;</code>是动态变化的。</p><h5 id="获取静态类的静态字段"><a href="#获取静态类的静态字段" class="headerlink" title="获取静态类的静态字段"></a>获取静态类的静态字段</h5><p>获取<code>UserController</code>类里的<code>logger</code>字段：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> ognl --classLoaderClass org.springframework.boot.loader.LaunchedURLClassLoader @com.example.demo.arthas.user.UserController@logger</span></span><br></pre></td></tr></table></figure><p>还可以通过<code>-x</code>参数控制返回值的展开层数。比如：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> ognl --classLoaderClass org.springframework.boot.loader.LaunchedURLClassLoader -x 2 @com.example.demo.arthas.user.UserController@logger</span></span><br></pre></td></tr></table></figure><h5 id="执行多行表达式，赋值给临时变量，返回一个List"><a href="#执行多行表达式，赋值给临时变量，返回一个List" class="headerlink" title="执行多行表达式，赋值给临时变量，返回一个List"></a>执行多行表达式，赋值给临时变量，返回一个List</h5><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> ognl <span class="string">&#x27;#value1=@System@getProperty(&quot;java.home&quot;), #value2=@System@getProperty(&quot;java.runtime.name&quot;), &#123;#value1, #value2&#125;&#x27;</span></span></span><br><span class="line">@ArrayList[</span><br><span class="line">    @String[/Library/Java/JavaVirtualMachines/jdk1.8.0_162.jdk/Contents/Home/jre],</span><br><span class="line">    @String[Java(TM) SE Runtime Environment],</span><br><span class="line">]</span><br></pre></td></tr></table></figure><h5 id="更多"><a href="#更多" class="headerlink" title="更多"></a>更多</h5><p>在Arthas里<code>ognl</code>表达式是很重要的功能，在很多命令里都可以使用<code>ognl</code>表达式。</p><p>一些更复杂的用法，可以参考：</p><ul><li>OGNL特殊用法请参考：<a href="https://github.com/alibaba/arthas/issues/71">https://github.com/alibaba/arthas/issues/71</a></li><li>OGNL表达式官方指南：<a href="https://commons.apache.org/proper/commons-ognl/language-guide.html">https://commons.apache.org/proper/commons-ognl/language-guide.html</a></li></ul><h3 id="2-3-案例"><a href="#2-3-案例" class="headerlink" title="2.3 案例"></a>2.3 案例</h3><h4 id="2-3-1-案例-排查函数调用异常"><a href="#2-3-1-案例-排查函数调用异常" class="headerlink" title="2.3.1 案例: 排查函数调用异常"></a>2.3.1 案例: 排查函数调用异常</h4><h5 id="现象"><a href="#现象" class="headerlink" title="现象"></a>现象</h5><p>目前，访问 <a href="http://localhost/user/0">http://localhost/user/0</a> ，会返回500异常：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> curl http://localhost/user/0</span></span><br><span class="line">&#123;&quot;timestamp&quot;:1550223186170,&quot;status&quot;:500,&quot;error&quot;:&quot;Internal Server Error&quot;,&quot;exception&quot;:&quot;java.lang.IllegalArgumentException&quot;,&quot;message&quot;:&quot;id &lt; 1&quot;,&quot;path&quot;:&quot;/user/0&quot;&#125;</span><br></pre></td></tr></table></figure><p>但请求的具体参数，异常栈是什么呢？</p><h5 id="查看UserController的-参数-异常"><a href="#查看UserController的-参数-异常" class="headerlink" title="查看UserController的 参数/异常"></a>查看UserController的 参数/异常</h5><p>在Arthas里执行：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> watch com.example.demo.arthas.user.UserController * <span class="string">&#x27;&#123;params, throwExp&#125;&#x27;</span></span></span><br></pre></td></tr></table></figure><ol><li>第一个参数是类名，支持通配</li><li>第二个参数是函数名，支持通配</li></ol><p>访问 <code>curl http://localhost/user/0</code> ,<code>watch</code>命令会打印调用的参数和异常</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">$ watch com.example.demo.arthas.user.UserController * <span class="string">&#x27;&#123;params, throwExp&#125;&#x27;</span></span><br><span class="line">Press Q or Ctrl+C to abort.</span><br><span class="line">Affect(class-cnt:1 , method-cnt:2) cost <span class="keyword">in</span> 53 ms.</span><br><span class="line">ts=2019-02-15 01:35:25; [cost=0.996655ms] result=@ArrayList[</span><br><span class="line">    @Object[][isEmpty=<span class="literal">false</span>;size=1],</span><br><span class="line">    @IllegalArgumentException[java.lang.IllegalArgumentException: id &lt; 1],</span><br><span class="line">]</span><br></pre></td></tr></table></figure><p>可以看到实际抛出的异常是<code>IllegalArgumentException</code>。</p><p>可以输入 <code>Q</code> 或者 <code>Ctrl+C</code> 退出watch命令。</p><p>如果想把获取到的结果展开，可以用<code>-x</code>参数：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> watch com.example.demo.arthas.user.UserController * <span class="string">&#x27;&#123;params, throwExp&#125;&#x27;</span> -x 2</span></span><br></pre></td></tr></table></figure><h5 id="返回值表达式"><a href="#返回值表达式" class="headerlink" title="返回值表达式"></a>返回值表达式</h5><p>在上面的例子里，第三个参数是<code>返回值表达式</code>，它实际上是一个<code>ognl</code>表达式，它支持一些内置对象：</p><ul><li>loader</li><li>clazz</li><li>method</li><li>target</li><li>params</li><li>returnObj</li><li>throwExp</li><li>isBefore</li><li>isThrow</li><li>isReturn</li></ul><p>你可以利用这些内置对象来组成不同的表达式。比如返回一个数组：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> watch com.example.demo.arthas.user.UserController * <span class="string">&#x27;&#123;params[0], target, returnObj&#125;&#x27;</span></span></span><br></pre></td></tr></table></figure><p>更多参考： <a href="https://arthas.aliyun.com/doc/advice-class.html">https://arthas.aliyun.com/doc/advice-class.html</a></p><h5 id="条件表达式"><a href="#条件表达式" class="headerlink" title="条件表达式"></a>条件表达式</h5><p><code>watch</code>命令支持在第4个参数里写条件表达式，比如：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> watch com.example.demo.arthas.user.UserController * returnObj <span class="string">&#x27;params[0] &gt; 100&#x27;</span></span></span><br></pre></td></tr></table></figure><p>当访问 <a href="https://2886795326-80-host12nc.environments.katacoda.com/user/1">https://2886795326-80-host12nc.environments.katacoda.com/user/1</a> 时，<code>watch</code>命令没有输出</p><p>当访问 <a href="https://2886795326-80-host12nc.environments.katacoda.com/user/101">https://2886795326-80-host12nc.environments.katacoda.com/user/101</a> 时，<code>watch</code>会打印出结果。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">$ watch com.example.demo.arthas.user.UserController * returnObj <span class="string">&#x27;params[0] &gt; 100&#x27;</span></span><br><span class="line">Press Q or Ctrl+C to abort.</span><br><span class="line">Affect(class-cnt:1 , method-cnt:2) cost <span class="keyword">in</span> 47 ms.</span><br><span class="line">ts=2019-02-13 19:42:12; [cost=0.821443ms] result=@User[</span><br><span class="line">    id=@Integer[101],</span><br><span class="line">    name=@String[name101],</span><br><span class="line">]</span><br></pre></td></tr></table></figure><h5 id="当异常时捕获"><a href="#当异常时捕获" class="headerlink" title="当异常时捕获"></a>当异常时捕获</h5><p><code>watch</code>命令支持<code>-e</code>选项，表示只捕获抛出异常时的请求：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> watch com.example.demo.arthas.user.UserController * <span class="string">&quot;&#123;params[0],throwExp&#125;&quot;</span> -e</span></span><br></pre></td></tr></table></figure><h5 id="按照耗时进行过滤"><a href="#按照耗时进行过滤" class="headerlink" title="按照耗时进行过滤"></a>按照耗时进行过滤</h5><p>watch命令支持按请求耗时进行过滤，比如：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> watch com.example.demo.arthas.user.UserController * <span class="string">&#x27;&#123;params, returnObj&#125;&#x27;</span> <span class="string">&#x27;#cost&gt;200&#x27;</span></span></span><br></pre></td></tr></table></figure><h4 id="2-3-2-案例-热更新代码"><a href="#2-3-2-案例-热更新代码" class="headerlink" title="2.3.2 案例: 热更新代码"></a>2.3.2 案例: 热更新代码</h4><p>下面介绍通过<code>jad</code>/<code>mc</code>/<code>redefine</code> 命令实现动态更新代码的功能。</p><p>目前，访问 <a href="http://localhost/user/0">http://localhost/user/0</a> ，会返回500异常：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> curl http://localhost/user/0</span></span><br><span class="line">&#123;&quot;timestamp&quot;:1550223186170,&quot;status&quot;:500,&quot;error&quot;:&quot;Internal Server Error&quot;,&quot;exception&quot;:&quot;java.lang.IllegalArgumentException&quot;,&quot;message&quot;:&quot;id &lt; 1&quot;,&quot;path&quot;:&quot;/user/0&quot;&#125;</span><br></pre></td></tr></table></figure><p>下面通过热更新代码，修改这个逻辑。</p><h5 id="jad反编译UserController"><a href="#jad反编译UserController" class="headerlink" title="jad反编译UserController"></a>jad反编译UserController</h5><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> jad --source-only com.example.demo.arthas.user.UserController &gt; /tmp/UserController.java</span></span><br></pre></td></tr></table></figure><p>jad反编译的结果保存在 <code>/tmp/UserController.java</code>文件里了。</p><p>再打开一个<code>Terminal 3</code>，然后用vim来编辑<code>/tmp/UserController.java</code>：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">vim /tmp/UserController.java</span><br></pre></td></tr></table></figure><p>比如当 user id 小于1时，也正常返回，不抛出异常：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@GetMapping(value=&#123;&quot;/user/&#123;id&#125;&quot;&#125;)</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> User <span class="title">findUserById</span><span class="params">(<span class="meta">@PathVariable</span> Integer id)</span> </span>&#123;</span><br><span class="line">    logger.info(<span class="string">&quot;id: &#123;&#125;&quot;</span>, (Object)id);</span><br><span class="line">    <span class="keyword">if</span> (id != <span class="keyword">null</span> &amp;&amp; id &lt; <span class="number">1</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> User(id, <span class="string">&quot;name&quot;</span> + id);</span><br><span class="line">        <span class="comment">// throw new IllegalArgumentException(&quot;id &lt; 1&quot;);</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> User(id.intValue(), <span class="string">&quot;name&quot;</span> + id);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="sc查找加载UserController的ClassLoader"><a href="#sc查找加载UserController的ClassLoader" class="headerlink" title="sc查找加载UserController的ClassLoader"></a>sc查找加载UserController的ClassLoader</h5><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> sc -d *UserController | grep classLoaderHash</span></span><br><span class="line"> classLoaderHash   1be6f5c3</span><br></pre></td></tr></table></figure><p>可以发现是 spring boot <code>LaunchedURLClassLoader@1be6f5c3</code> 加载的。</p><p>请记下你的classLoaderHash，后面需要使用它。在这里，它是 <code>1be6f5c3</code>。</p><h5 id="mc"><a href="#mc" class="headerlink" title="mc"></a>mc</h5><p>保存好<code>/tmp/UserController.java</code>之后，使用<code>mc</code>(Memory Compiler)命令来编译，并且通过<code>-c</code>或者<code>--classLoaderClass</code>参数指定ClassLoader：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> mc --classLoaderClass org.springframework.boot.loader.LaunchedURLClassLoader /tmp/UserController.java -d /tmp</span></span><br><span class="line">Memory compiler output:</span><br><span class="line">/tmp/com/example/demo/arthas/user/UserController.class</span><br><span class="line">Affect(row-cnt:1) cost in 346 ms</span><br></pre></td></tr></table></figure><p>也可以通过<code>mc -c &lt;classLoaderHash&gt; /tmp/UserController.java -d /tmp</code>，使用<code>-c</code>参数指定ClassLoaderHash:</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ mc -c 1be6f5c3 /tmp/UserController.java -d /tmp</span><br></pre></td></tr></table></figure><h5 id="redefine"><a href="#redefine" class="headerlink" title="redefine"></a>redefine</h5><p>再使用<code>redefine</code>命令重新加载新编译好的<code>UserController.class</code>：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> redefine /tmp/com/example/demo/arthas/user/UserController.class</span></span><br><span class="line">redefine success, size: 1</span><br></pre></td></tr></table></figure><h5 id="热修改代码结果"><a href="#热修改代码结果" class="headerlink" title="热修改代码结果"></a>热修改代码结果</h5><p><code>redefine</code>成功之后，再次访问 <a href="https://2886795326-80-host12nc.environments.katacoda.com/user/0">https://2886795326-80-host12nc.environments.katacoda.com/user/0</a> ，结果是：</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  <span class="attr">&quot;id&quot;</span>: <span class="number">0</span>,</span><br><span class="line">  <span class="attr">&quot;name&quot;</span>: <span class="string">&quot;name0&quot;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="2-3-3-案例-动态更新应用Logger-Level"><a href="#2-3-3-案例-动态更新应用Logger-Level" class="headerlink" title="2.3.3 案例: 动态更新应用Logger Level"></a>2.3.3 案例: 动态更新应用Logger Level</h4><p>在这个案例里，动态修改应用的Logger Level。</p><h5 id="查找UserController的ClassLoader-1"><a href="#查找UserController的ClassLoader-1" class="headerlink" title="查找UserController的ClassLoader"></a>查找UserController的ClassLoader</h5><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> sc -d com.example.demo.arthas.user.UserController | grep classLoaderHash</span></span><br><span class="line"> classLoaderHash   1be6f5c3</span><br></pre></td></tr></table></figure><h5 id="用ognl获取logger"><a href="#用ognl获取logger" class="headerlink" title="用ognl获取logger"></a>用ognl获取logger</h5><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> ognl --classLoaderClass org.springframework.boot.loader.LaunchedURLClassLoader <span class="string">&#x27;@com.example.demo.arthas.user.UserController@logger&#x27;</span></span></span><br><span class="line">@Logger[</span><br><span class="line">    serialVersionUID=@Long[5454405123156820674],</span><br><span class="line">    FQCN=@String[ch.qos.logback.classic.Logger],</span><br><span class="line">    name=@String[com.example.demo.arthas.user.UserController],</span><br><span class="line">    level=null,</span><br><span class="line">    effectiveLevelInt=@Integer[20000],</span><br><span class="line">    parent=@Logger[Logger[com.example.demo.arthas.user]],</span><br><span class="line">    childrenList=null,</span><br><span class="line">    aai=null,</span><br><span class="line">    additive=@Boolean[true],</span><br><span class="line">    loggerContext=@LoggerContext[ch.qos.logback.classic.LoggerContext[default]],</span><br><span class="line">]</span><br></pre></td></tr></table></figure><p>可以知道<code>UserController@logger</code>实际使用的是logback。可以看到<code>level=null</code>，则说明实际最终的level是从<code>root</code> logger里来的。</p><h5 id="单独设置UserController的logger-level"><a href="#单独设置UserController的logger-level" class="headerlink" title="单独设置UserController的logger level"></a>单独设置UserController的logger level</h5><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> ognl --classLoaderClass org.springframework.boot.loader.LaunchedURLClassLoader <span class="string">&#x27;@com.example.demo.arthas.user.UserController@logger.setLevel(@ch.qos.logback.classic.Level@DEBUG)&#x27;</span></span></span><br></pre></td></tr></table></figure><p>再次获取<code>UserController@logger</code>，可以发现已经是<code>DEBUG</code>了：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> ognl --classLoaderClass org.springframework.boot.loader.LaunchedURLClassLoader <span class="string">&#x27;@com.example.demo.arthas.user.UserController@logger&#x27;</span></span></span><br><span class="line">@Logger[</span><br><span class="line">    serialVersionUID=@Long[5454405123156820674],</span><br><span class="line">    FQCN=@String[ch.qos.logback.classic.Logger],</span><br><span class="line">    name=@String[com.example.demo.arthas.user.UserController],</span><br><span class="line">    level=@Level[DEBUG],</span><br><span class="line">    effectiveLevelInt=@Integer[10000],</span><br><span class="line">    parent=@Logger[Logger[com.example.demo.arthas.user]],</span><br><span class="line">    childrenList=null,</span><br><span class="line">    aai=null,</span><br><span class="line">    additive=@Boolean[true],</span><br><span class="line">    loggerContext=@LoggerContext[ch.qos.logback.classic.LoggerContext[default]],</span><br><span class="line">]</span><br></pre></td></tr></table></figure><h5 id="修改logback的全局logger-level"><a href="#修改logback的全局logger-level" class="headerlink" title="修改logback的全局logger level"></a>修改logback的全局logger level</h5><p>通过获取<code>root</code> logger，可以修改全局的logger level：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> ognl --classLoaderClass org.springframework.boot.loader.LaunchedURLClassLoader <span class="string">&#x27;@org.slf4j.LoggerFactory@getLogger(&quot;root&quot;).setLevel(@ch.qos.logback.classic.Level@DEBUG)&#x27;</span></span></span><br></pre></td></tr></table></figure><h4 id="2-3-4-案例-排查logger冲突问题"><a href="#2-3-4-案例-排查logger冲突问题" class="headerlink" title="2.3.4 案例: 排查logger冲突问题"></a>2.3.4 案例: 排查logger冲突问题</h4><p>在这个案例里，展示排查logger冲突的方法。</p><h5 id="确认应用使用的logger系统"><a href="#确认应用使用的logger系统" class="headerlink" title="确认应用使用的logger系统"></a>确认应用使用的logger系统</h5><p>以<code>UserController</code>为例，它使用的是slf4j api，但实际使用到的logger系统是logback。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> ognl --classLoaderClass org.springframework.boot.loader.LaunchedURLClassLoader <span class="string">&#x27;@com.example.demo.arthas.user.UserController@logger&#x27;</span></span></span><br><span class="line">@Logger[</span><br><span class="line">    serialVersionUID=@Long[5454405123156820674],</span><br><span class="line">    FQCN=@String[ch.qos.logback.classic.Logger],</span><br><span class="line">    name=@String[com.example.demo.arthas.user.UserController],</span><br><span class="line">    level=null,</span><br><span class="line">    effectiveLevelInt=@Integer[20000],</span><br><span class="line">    parent=@Logger[Logger[com.example.demo.arthas.user]],</span><br><span class="line">    childrenList=null,</span><br><span class="line">    aai=null,</span><br><span class="line">    additive=@Boolean[true],</span><br><span class="line">    loggerContext=@LoggerContext[ch.qos.logback.classic.LoggerContext[default]],</span><br><span class="line">]</span><br></pre></td></tr></table></figure><h5 id="获取logback实际加载的配置文件"><a href="#获取logback实际加载的配置文件" class="headerlink" title="获取logback实际加载的配置文件"></a>获取logback实际加载的配置文件</h5><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> ognl --classLoaderClass org.springframework.boot.loader.LaunchedURLClassLoader <span class="string">&#x27;#map1=@org.slf4j.LoggerFactory@getLogger(&quot;root&quot;).loggerContext.objectMap, #map1.get(&quot;CONFIGURATION_WATCH_LIST&quot;)&#x27;</span></span></span><br></pre></td></tr></table></figure><h5 id="使用classloader命令查找可能存在的logger配置文件"><a href="#使用classloader命令查找可能存在的logger配置文件" class="headerlink" title="使用classloader命令查找可能存在的logger配置文件"></a>使用classloader命令查找可能存在的logger配置文件</h5><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> classloader --classLoaderClass org.springframework.boot.loader.LaunchedURLClassLoader -r logback-spring.xml</span></span><br><span class="line"> jar:file:/Users/hengyunabc/code/java/spring-boot-inside/demo-arthas-spring-boot/target/demo-arthas-spring-boot-0.0.1-SNAPSHOT.jar!/BOOT-INF/classes!/logback-spring.xml</span><br><span class="line"></span><br><span class="line">Affect(row-cnt:1) cost in 13 ms.</span><br></pre></td></tr></table></figure><p>可以知道加载的配置的具体来源。</p><p>可以尝试加载容易冲突的文件：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">classloader --classLoaderClass org.springframework.boot.loader.LaunchedURLClassLoader -r logback.xml</span><br><span class="line"></span><br><span class="line">classloader --classLoaderClass org.springframework.boot.loader.LaunchedURLClassLoader -r log4j.properties</span><br></pre></td></tr></table></figure><h4 id="2-3-5-案例-获取Spring-Context"><a href="#2-3-5-案例-获取Spring-Context" class="headerlink" title="2.3.5 案例: 获取Spring Context"></a>2.3.5 案例: 获取Spring Context</h4><p>在这个案例里，展示获取spring context，再获取bean，然后调用函数。</p><h5 id="使用tt命令获取到spring-context"><a href="#使用tt命令获取到spring-context" class="headerlink" title="使用tt命令获取到spring context"></a>使用tt命令获取到spring context</h5><p><code>tt</code>即 TimeTunnel，它可以记录下指定方法每次调用的入参和返回信息，并能对这些不同的时间下调用进行观测。</p><ul><li><a href="https://arthas.aliyun.com/doc/tt.html">https://arthas.aliyun.com/doc/tt.html</a></li></ul><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> tt -t org.springframework.web.servlet.mvc.method.annotation.RequestMappingHandlerAdapter invokeHandlerMethod</span></span><br></pre></td></tr></table></figure><p>访问：<a href="https://2886795326-80-host12nc.environments.katacoda.com/user/1">https://2886795326-80-host12nc.environments.katacoda.com/user/1</a></p><p>可以看到<code>tt</code>命令捕获到了一个请求：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">$ tt -t org.springframework.web.servlet.mvc.method.annotation.RequestMappingHandlerAdaptePress Q or Ctrl+C to abort.</span><br><span class="line">Affect(class-cnt:1 , method-cnt:1) cost <span class="keyword">in</span> 252 ms.</span><br><span class="line"> INDE  TIMESTAMP    COST(  IS-R  IS-  OBJECT     CLASS               METHOD</span><br><span class="line"> X                  ms)    ET    EXP</span><br><span class="line">-----------------------------------------------------------------------------------------</span><br><span class="line"> 1000  2019-02-15   4.583  <span class="literal">true</span>  fal  0xc93cf1a  RequestMappingHand  invokeHandlerMethod</span><br><span class="line">       15:38:32     923          se              lerAdapter</span><br></pre></td></tr></table></figure><h5 id="使用tt命令从调用记录里获取到spring-context"><a href="#使用tt命令从调用记录里获取到spring-context" class="headerlink" title="使用tt命令从调用记录里获取到spring context"></a>使用tt命令从调用记录里获取到spring context</h5><p>输入 <code>Q</code> 或者 <code>Ctrl + C</code> 退出上面的 <code>tt -t</code>命令。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> tt -i 1000 -w <span class="string">&#x27;target.getApplicationContext()&#x27;</span></span></span><br><span class="line">@AnnotationConfigEmbeddedWebApplicationContext[</span><br><span class="line">    reader=@AnnotatedBeanDefinitionReader[org.springframework.context.annotation.AnnotatedBeanDefinitionReader@2e457641],</span><br><span class="line">    scanner=@ClassPathBeanDefinitionScanner[org.springframework.context.annotation.ClassPathBeanDefinitionScanner@6eb38026],</span><br><span class="line">    annotatedClasses=null,</span><br><span class="line">    basePackages=null,</span><br><span class="line">]</span><br><span class="line">Affect(row-cnt:1) cost in 439 ms.</span><br></pre></td></tr></table></figure><h5 id="获取spring-bean，并调用函数"><a href="#获取spring-bean，并调用函数" class="headerlink" title="获取spring bean，并调用函数"></a>获取spring bean，并调用函数</h5><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$ tt -i 1000 -w <span class="string">&#x27;target.getApplicationContext().getBean(&quot;helloWorldService&quot;).getHelloMessage()&#x27;</span></span><br><span class="line">@String[Hello World]</span><br><span class="line">Affect(row-cnt:1) cost <span class="keyword">in</span> 52 ms.</span><br></pre></td></tr></table></figure><h4 id="2-3-6-案例-排查HTTP请求返回401"><a href="#2-3-6-案例-排查HTTP请求返回401" class="headerlink" title="2.3.6 案例: 排查HTTP请求返回401"></a>2.3.6 案例: 排查HTTP请求返回401</h4><p>访问： <a href="https://2886795326-80-host12nc.environments.katacoda.com/admin">https://2886795326-80-host12nc.environments.katacoda.com/admin</a></p><p>结果是：</p><figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="attribute">Something</span> went wrong: <span class="number">401</span> Unauthorized</span><br></pre></td></tr></table></figure><p>我们知道<code>401</code>通常是被权限管理的<code>Filter</code>拦截了，那么到底是哪个<code>Filter</code>处理了这个请求，返回了401？</p><h5 id="跟踪所有的Filter函数"><a href="#跟踪所有的Filter函数" class="headerlink" title="跟踪所有的Filter函数"></a>跟踪所有的Filter函数</h5><p>开始trace：</p><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">trace javax<span class="selector-class">.servlet</span><span class="selector-class">.Filter</span> *</span><br></pre></td></tr></table></figure><p>访问： <a href="https://2886795326-80-host12nc.environments.katacoda.com/admin">https://2886795326-80-host12nc.environments.katacoda.com/admin</a></p><p>可以在调用树的最深层，找到<code>AdminFilterConfig$AdminFilter</code>返回了<code>401</code>：</p><figure class="highlight reasonml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">+---<span class="literal">[<span class="number">3.806273</span><span class="identifier">ms</span>]</span> javax.servlet.FilterChain:<span class="keyword">do</span><span class="constructor">Filter()</span></span><br><span class="line"><span class="pattern-match">|   `---[3.447472ms] com.example.demo.arthas.<span class="constructor">AdminFilterConfig$AdminFilter</span>:<span class="keyword">do</span><span class="constructor">Filter()</span></span></span><br><span class="line"><span class="pattern-match">|       `---[0.17259ms] javax.servlet.http.<span class="constructor">HttpServletResponse</span>:send<span class="constructor">Error()</span></span></span><br></pre></td></tr></table></figure><h5 id="通过stack获取调用栈"><a href="#通过stack获取调用栈" class="headerlink" title="通过stack获取调用栈"></a>通过stack获取调用栈</h5><p>上面是通过<code>trace</code>命令来获取信息，从结果里，我们可以知道通过<code>stack</code>跟踪<code>HttpServletResponse:sendError()</code>，同样可以知道是哪个<code>Filter</code>返回了<code>401</code></p><p>执行：</p><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">stack javax<span class="selector-class">.servlet</span><span class="selector-class">.http</span><span class="selector-class">.HttpServletResponse</span> sendError <span class="string">&#x27;params[0]==401&#x27;</span></span><br></pre></td></tr></table></figure><p>访问： <a href="https://2886795326-80-host12nc.environments.katacoda.com/admin">https://2886795326-80-host12nc.environments.katacoda.com/admin</a></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">$ stack javax.servlet.http.HttpServletResponse sendError <span class="string">&#x27;params[0]==401&#x27;</span></span><br><span class="line">Press Q or Ctrl+C to abort.</span><br><span class="line">Affect(class-cnt:2 , method-cnt:4) cost <span class="keyword">in</span> 87 ms.</span><br><span class="line">ts=2019-02-15 16:44:06;thread_name=http-nio-8080-exec-6;id=16;is_daemon=<span class="literal">true</span>;priority=5;TCCL=org.springframework.boot.context.embedded.tomcat.TomcatEmbeddedWebappClassLoader@8546cd5</span><br><span class="line">    @org.apache.catalina.connector.ResponseFacade.sendError()</span><br><span class="line">        at com.example.demo.arthas.AdminFilterConfig<span class="variable">$AdminFilter</span>.doFilter(AdminFilterConfig.java:38)</span><br><span class="line">        at org.apache.catalina.core.ApplicationFilterChain.internalDoFilter(ApplicationFilterChain.java:193)</span><br><span class="line">        at org.apache.catalina.core.ApplicationFilterChain.doFilter(ApplicationFilterChain.java:166)</span><br><span class="line">        at org.springframework.web.filter.RequestContextFilter.doFilterInternal(RequestContextFilter.java:99)</span><br><span class="line">        at org.springframework.web.filter.OncePerRequestFilter.doFilter(OncePerRequestFilter.java:107)</span><br></pre></td></tr></table></figure><h4 id="2-3-7-案例-排查HTTP请求返回404"><a href="#2-3-7-案例-排查HTTP请求返回404" class="headerlink" title="2.3.7 案例: 排查HTTP请求返回404"></a>2.3.7 案例: 排查HTTP请求返回404</h4><p>访问： <a href="https://2886795326-80-host12nc.environments.katacoda.com/a.txt">https://2886795326-80-host12nc.environments.katacoda.com/a.txt</a></p><p>结果是：</p><figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="attribute">Something</span> went wrong: <span class="number">404</span> Not Found</span><br></pre></td></tr></table></figure><p>那么到底是哪个Servlet处理了这个请求，返回了404？</p><h5 id="跟踪所有的Servlet函数"><a href="#跟踪所有的Servlet函数" class="headerlink" title="跟踪所有的Servlet函数"></a>跟踪所有的Servlet函数</h5><p>开始trace：</p><figure class="highlight arcade"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">trace javax.servlet.Servlet * &gt; <span class="regexp">/tmp/</span>servlet.txt</span><br></pre></td></tr></table></figure><p>访问： <a href="https://2886795326-80-host12nc.environments.katacoda.com/a.txt">https://2886795326-80-host12nc.environments.katacoda.com/a.txt</a></p><p>在<code>Terminal 3</code>里，查看<code>/tmp/servlet.txt</code>的内容：</p><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">less <span class="regexp">/tmp/</span>servlet.txt</span><br></pre></td></tr></table></figure><p><code>/tmp/servlet.txt</code>里的内容会比较多，需要耐心找到调用树里最长的地方。</p><p>可以发现请求最终是被<code>freemarker</code>处理的：</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">`<span class="operator">---</span>[<span class="number">13</span>.974188ms] org.springframework.web.servlet.<span class="type">ViewResolver</span>:resolveViewName()    <span class="operator">+---</span>[<span class="number">0</span>.045561ms] javax.servlet.<span class="type">GenericServlet</span>:<span class="operator">&lt;</span><span class="keyword">init</span><span class="operator">&gt;</span>()    <span class="operator">+---</span>[min<span class="operator">=</span><span class="number">0</span>.045545ms,max<span class="operator">=</span><span class="number">0</span>.074342ms,total<span class="operator">=</span><span class="number">0</span>.119887ms,count<span class="operator">=</span><span class="number">2</span>] org.springframework.web.servlet.view.freemarker.<span class="type">FreeMarkerView</span><span class="variable">$GenericServletAdapter</span>:<span class="operator">&lt;</span><span class="keyword">init</span><span class="operator">&gt;</span>()    <span class="operator">+---</span>[<span class="number">0</span>.170895ms] javax.servlet.<span class="type">GenericServlet</span>:<span class="function"><span class="keyword">init</span>()</span>    <span class="operator">|</span>   `<span class="operator">---</span>[<span class="number">0</span>.068578ms] javax.servlet.<span class="type">GenericServlet</span>:<span class="function"><span class="keyword">init</span>()</span>    <span class="operator">|</span>       `<span class="operator">---</span>[<span class="number">0</span>.021793ms] javax.servlet.<span class="type">GenericServlet</span>:<span class="function"><span class="keyword">init</span>()</span>    `<span class="operator">---</span>[<span class="number">0</span>.164035ms] javax.servlet.<span class="type">GenericServlet</span>:getServletContext()</span><br></pre></td></tr></table></figure><h4 id="2-3-8-案例-理解Spring-Boot应用的ClassLoader结构"><a href="#2-3-8-案例-理解Spring-Boot应用的ClassLoader结构" class="headerlink" title="2.3.8 案例: 理解Spring Boot应用的ClassLoader结构"></a>2.3.8 案例: 理解Spring Boot应用的ClassLoader结构</h4><p>下面介绍<code>classloader</code>命令的功能。</p><p>先访问一个jsp网页，触发jsp的加载： <a href="https://2886795326-80-host12nc.environments.katacoda.com/hello">https://2886795326-80-host12nc.environments.katacoda.com/hello</a></p><h5 id="列出所有ClassLoader"><a href="#列出所有ClassLoader" class="headerlink" title="列出所有ClassLoader"></a>列出所有ClassLoader</h5><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">$ classloader -l</span><br><span class="line"> name                                                             loadedCount  hash      parent</span><br><span class="line"> BootstrapClassLoader                                             <span class="number">2724</span>         null      null</span><br><span class="line"> com<span class="selector-class">.taobao</span><span class="selector-class">.arthas</span><span class="selector-class">.agent</span>.ArthasClassloader@<span class="number">411</span>ce1ab               <span class="number">2009</span>         <span class="number">411</span>ce1ab  sun<span class="selector-class">.misc</span>.Launcher<span class="variable">$ExtClassLoader</span>@<span class="number">7494</span>e528</span><br><span class="line"> com<span class="selector-class">.taobao</span><span class="selector-class">.arthas</span><span class="selector-class">.agent</span>.ArthasClassloader@<span class="number">22</span>ae1234               <span class="number">1253</span>         <span class="number">22</span>ae1234  sun<span class="selector-class">.misc</span>.Launcher<span class="variable">$ExtClassLoader</span>@<span class="number">7494</span>e528</span><br><span class="line"> org<span class="selector-class">.apache</span><span class="selector-class">.jasper</span><span class="selector-class">.servlet</span>.JasperLoader@<span class="number">65361</span>d9a                  <span class="number">1</span>            <span class="number">65361</span>d9a  TomcatEmbeddedWebappClassLoader</span><br><span class="line">                                                                                           context: ROOT</span><br><span class="line">                                                                                           delegate: true</span><br><span class="line">                                                                                         ----------&gt; Parent Classloader:</span><br><span class="line">                                                                                         org<span class="selector-class">.springframework</span><span class="selector-class">.boot</span><span class="selector-class">.loader</span>.LaunchedURLClassLoader@<span class="number">1</span>be6f5c3</span><br><span class="line"></span><br><span class="line"> TomcatEmbeddedWebappClassLoader                                  <span class="number">0</span>            <span class="number">8546</span>cd5   org<span class="selector-class">.springframework</span><span class="selector-class">.boot</span><span class="selector-class">.loader</span>.LaunchedURLClassLoader@<span class="number">1</span>be6f5c3</span><br><span class="line">   context: ROOT</span><br><span class="line">   delegate: true</span><br><span class="line"> ----------&gt; Parent Classloader:</span><br><span class="line"> org<span class="selector-class">.springframework</span><span class="selector-class">.boot</span><span class="selector-class">.loader</span>.LaunchedURLClassLoader@<span class="number">1</span>be6f5c3</span><br><span class="line"></span><br><span class="line"> org<span class="selector-class">.springframework</span><span class="selector-class">.boot</span><span class="selector-class">.loader</span>.LaunchedURLClassLoader@<span class="number">1</span>be6f5c3  <span class="number">5416</span>         <span class="number">1</span>be6f5c3  sun<span class="selector-class">.misc</span>.Launcher<span class="variable">$AppClassLoader</span>@<span class="number">3</span>d4eac69</span><br><span class="line"> sun<span class="selector-class">.misc</span>.Launcher<span class="variable">$AppClassLoader</span>@<span class="number">3</span>d4eac69                        <span class="number">45</span>           <span class="number">3</span>d4eac69  sun<span class="selector-class">.misc</span>.Launcher<span class="variable">$ExtClassLoader</span>@<span class="number">7494</span>e528</span><br><span class="line"> sun<span class="selector-class">.misc</span>.Launcher<span class="variable">$ExtClassLoader</span>@<span class="number">7494</span>e528                        <span class="number">4</span>            <span class="number">7494</span>e528  null</span><br></pre></td></tr></table></figure><ul><li>TomcatEmbeddedWebappClassLoader 加载的class数量是0，所以在spring boot embedded tomcat里，它只是一个空壳，所有的类加载都是<code>LaunchedURLClassLoader</code>完成的</li></ul><h5 id="列出ClassLoader里加载的所有类"><a href="#列出ClassLoader里加载的所有类" class="headerlink" title="列出ClassLoader里加载的所有类"></a>列出ClassLoader里加载的所有类</h5><p>列出上面的<code>org.apache.jasper.servlet.JasperLoader</code>加载的类：</p><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">classloader -<span class="selector-tag">a</span> --classLoaderClass org<span class="selector-class">.apache</span><span class="selector-class">.jasper</span><span class="selector-class">.servlet</span><span class="selector-class">.JasperLoader</span></span><br><span class="line">$ classloader -<span class="selector-tag">a</span> --classLoaderClass apache<span class="selector-class">.jasper</span><span class="selector-class">.servlet</span><span class="selector-class">.JasperLoader</span></span><br><span class="line"> hash:<span class="number">1698045338</span>, org<span class="selector-class">.apache</span><span class="selector-class">.jasper</span><span class="selector-class">.servlet</span>.JasperLoader@<span class="number">65361</span>d9a</span><br><span class="line"> org<span class="selector-class">.apache</span><span class="selector-class">.jsp</span><span class="selector-class">.jsp</span>.hello_jsp</span><br></pre></td></tr></table></figure><ul><li>注：同ognl, 也可用<code>-c &lt;hashcode&gt;</code>而不用<code>--classLoaderClass</code>指定</li></ul><h5 id="反编译jsp的代码"><a href="#反编译jsp的代码" class="headerlink" title="反编译jsp的代码"></a>反编译jsp的代码</h5><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">jad org<span class="selector-class">.apache</span><span class="selector-class">.jsp</span><span class="selector-class">.jsp</span><span class="selector-class">.hello_jsp</span></span><br><span class="line">$ jad org<span class="selector-class">.apache</span><span class="selector-class">.jsp</span><span class="selector-class">.jsp</span><span class="selector-class">.hello_jsp</span></span><br><span class="line"></span><br><span class="line">ClassLoader:</span><br><span class="line">+-org<span class="selector-class">.apache</span><span class="selector-class">.jasper</span><span class="selector-class">.servlet</span>.JasperLoader@<span class="number">65361</span>d9a</span><br><span class="line">  +-TomcatEmbeddedWebappClassLoader</span><br><span class="line">      context: ROOT</span><br><span class="line">...</span><br></pre></td></tr></table></figure><h5 id="查看ClassLoader树"><a href="#查看ClassLoader树" class="headerlink" title="查看ClassLoader树"></a>查看ClassLoader树</h5><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">classloader -t</span><br><span class="line">$ classloader -t</span><br><span class="line">+-BootstrapClassLoader</span><br><span class="line">+-sun<span class="selector-class">.misc</span>.Launcher<span class="variable">$ExtClassLoader</span>@<span class="number">28</span>cbbddd</span><br><span class="line">  +-com<span class="selector-class">.taobao</span><span class="selector-class">.arthas</span><span class="selector-class">.agent</span>.ArthasClassloader@<span class="number">8</span>c25e55</span><br><span class="line">  +-sun<span class="selector-class">.misc</span>.Launcher<span class="variable">$AppClassLoader</span>@<span class="number">55</span>f96302</span><br><span class="line">    +-org<span class="selector-class">.springframework</span><span class="selector-class">.boot</span><span class="selector-class">.loader</span>.LaunchedURLClassLoader@<span class="number">1</span>be6f5c3</span><br><span class="line">      +-TomcatEmbeddedWebappClassLoader</span><br><span class="line">          context: ROOT</span><br><span class="line">          delegate: true</span><br><span class="line">        ----------&gt; Parent Classloader:</span><br><span class="line">        org<span class="selector-class">.springframework</span><span class="selector-class">.boot</span><span class="selector-class">.loader</span>.LaunchedURLClassLoader@<span class="number">1</span>be6f5c3</span><br><span class="line"></span><br><span class="line">        +-org<span class="selector-class">.apache</span><span class="selector-class">.jasper</span><span class="selector-class">.servlet</span>.JasperLoader@<span class="number">21</span>ae0fe2</span><br></pre></td></tr></table></figure><p>注意：请使用你的classLoaderHash值覆盖 <code>&lt;classLoaderHash&gt;</code> ，然后手动执行下面相关命令：</p><h5 id="列出ClassLoader的urls"><a href="#列出ClassLoader的urls" class="headerlink" title="列出ClassLoader的urls"></a>列出ClassLoader的urls</h5><p>比如上面查看到的spring LaunchedURLClassLoader的 hashcode是<code>1be6f5c3</code>，可以通过<code>-c</code>或者<code>--classLoaderClass</code>参数来列出它的所有urls：</p><figure class="highlight gradle"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">classloader --classLoaderClass org.springframework.boot.loader.LaunchedURLClassLoader</span><br><span class="line">$ classloader --classLoaderClass org.springframework.boot.loader.LaunchedURLClassLoader</span><br><span class="line">jar:<span class="keyword">file</span>:<span class="regexp">/home/</span>scrapbook<span class="regexp">/tutorial/</span>demo-arthas-spring-boot.jar!<span class="regexp">/BOOT-INF/</span>classes!/</span><br><span class="line">jar:<span class="keyword">file</span>:<span class="regexp">/home/</span>scrapbook<span class="regexp">/tutorial/</span>demo-arthas-spring-boot.jar!<span class="regexp">/BOOT-INF/</span>lib/spring-boot-starter-aop-<span class="number">1.5</span></span><br><span class="line">.<span class="number">13</span>.RELEASE.jar!/</span><br><span class="line">...</span><br></pre></td></tr></table></figure><h5 id="加载指定ClassLoader里的资源文件"><a href="#加载指定ClassLoader里的资源文件" class="headerlink" title="加载指定ClassLoader里的资源文件"></a>加载指定ClassLoader里的资源文件</h5><p>查找指定的资源文件： <code>classloader --classLoaderClass org.springframework.boot.loader.LaunchedURLClassLoader -r logback-spring.xml</code></p><figure class="highlight gradle"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ classloader --classLoaderClass org.springframework.boot.loader.LaunchedURLClassLoader -r logback-spring.xml</span><br><span class="line"> jar:<span class="keyword">file</span>:<span class="regexp">/home/</span>scrapbook<span class="regexp">/tutorial/</span>demo-arthas-spring-boot.jar!<span class="regexp">/BOOT-INF/</span>classes!/logback-spring.xml</span><br></pre></td></tr></table></figure><h5 id="尝试加载指定的类"><a href="#尝试加载指定的类" class="headerlink" title="尝试加载指定的类"></a>尝试加载指定的类</h5><p>比如用上面的spring LaunchedURLClassLoader 尝试加载 <code>java.lang.String</code> ：</p><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">classloader --classLoaderClass org<span class="selector-class">.springframework</span><span class="selector-class">.boot</span><span class="selector-class">.loader</span><span class="selector-class">.LaunchedURLClassLoader</span> --load java<span class="selector-class">.lang</span><span class="selector-class">.String</span></span><br><span class="line">$ classloader --classLoaderClass org<span class="selector-class">.springframework</span><span class="selector-class">.boot</span><span class="selector-class">.loader</span><span class="selector-class">.LaunchedURLClassLoader</span> --load java<span class="selector-class">.lang</span><span class="selector-class">.String</span></span><br><span class="line">load class success.</span><br><span class="line"> class-info        java<span class="selector-class">.lang</span><span class="selector-class">.String</span></span><br><span class="line"> code-source</span><br><span class="line"> name              java<span class="selector-class">.lang</span><span class="selector-class">.String</span></span><br><span class="line"> isInterface       false</span><br><span class="line"> isAnnotation      false</span><br><span class="line"> isEnum            false</span><br><span class="line"> isAnonymousClass  false</span><br><span class="line"> isArray           false</span><br><span class="line"> isLocalClass      false</span><br><span class="line"> isMemberClass     false</span><br><span class="line"> isPrimitive       false</span><br><span class="line"> isSynthetic       false</span><br><span class="line"> simple-name       String</span><br><span class="line"> modifier          final,public</span><br><span class="line"> annotation</span><br><span class="line"> interfaces        java<span class="selector-class">.io</span><span class="selector-class">.Serializable</span>,java<span class="selector-class">.lang</span><span class="selector-class">.Comparable</span>,java<span class="selector-class">.lang</span><span class="selector-class">.CharSequence</span></span><br><span class="line"> super-class       +-java<span class="selector-class">.lang</span><span class="selector-class">.Object</span></span><br><span class="line"> class-loader</span><br><span class="line"> classLoaderHash   null</span><br></pre></td></tr></table></figure><h4 id="2-3-9-案例：查找Top-N线程"><a href="#2-3-9-案例：查找Top-N线程" class="headerlink" title="2.3.9 案例：查找Top N线程"></a>2.3.9 案例：查找Top N线程</h4><h5 id="查看所有线程信息"><a href="#查看所有线程信息" class="headerlink" title="查看所有线程信息"></a>查看所有线程信息</h5><figure class="highlight autohotkey"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">thread</span></span><br></pre></td></tr></table></figure><h5 id="查看具体线程的栈"><a href="#查看具体线程的栈" class="headerlink" title="查看具体线程的栈"></a>查看具体线程的栈</h5><p>查看线程ID 16的栈：</p><figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="attribute">thread</span> <span class="number">16</span></span><br></pre></td></tr></table></figure><h5 id="查看CPU使用率top-n线程的栈"><a href="#查看CPU使用率top-n线程的栈" class="headerlink" title="查看CPU使用率top n线程的栈"></a>查看CPU使用率top n线程的栈</h5><figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="attribute">thread</span> -n <span class="number">3</span></span><br></pre></td></tr></table></figure><h5 id="查看5秒内的CPU使用率top-n线程栈"><a href="#查看5秒内的CPU使用率top-n线程栈" class="headerlink" title="查看5秒内的CPU使用率top n线程栈"></a>查看5秒内的CPU使用率top n线程栈</h5><figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="attribute">thread</span> -n <span class="number">3</span> -i <span class="number">5000</span></span><br></pre></td></tr></table></figure><h5 id="查找线程是否有阻塞"><a href="#查找线程是否有阻塞" class="headerlink" title="查找线程是否有阻塞"></a>查找线程是否有阻塞</h5><figure class="highlight autohotkey"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">thread</span> -b</span><br></pre></td></tr></table></figure><h3 id="2-4-Web-Console"><a href="#2-4-Web-Console" class="headerlink" title="2.4 Web Console"></a>2.4 Web Console</h3><p>Arthas支持通过Web Socket来连接。</p><h4 id="教程里的Web-Console"><a href="#教程里的Web-Console" class="headerlink" title="教程里的Web Console"></a>教程里的Web Console</h4><p><a href="http://2886795326-8563-host12nc.environments.katacoda.com/?ip=2886795326-8563-host12nc.environments.katacoda.com&amp;port=80">http://2886795326-8563-host12nc.environments.katacoda.com/?ip=2886795326-8563-host12nc.environments.katacoda.com&amp;port=80</a></p><blockquote><p>注意：教程里访问的是80端口，因为做了端口转发。在本地体验时，需要访问8563端口。</p></blockquote><h4 id="本地体验"><a href="#本地体验" class="headerlink" title="本地体验"></a>本地体验</h4><p>当在本地启动时，可以访问 <a href="http://127.0.0.1:8563/">http://127.0.0.1:8563/</a> ，通过浏览器来使用Arthas。</p><p><img src="https://katacoda.com/arthas/scenarios/common-resources/assets/web-console.png" alt="Arthas WebConsole"></p><p>推荐通过“快速入门”来体验： <a href="https://arthas.aliyun.com/doc/quick-start.html">https://arthas.aliyun.com/doc/quick-start.html</a></p><h3 id="2-5-Exit-Stop"><a href="#2-5-Exit-Stop" class="headerlink" title="2.5 Exit/Stop"></a>2.5 Exit/Stop</h3><ul><li><p>reset：Arthas在 watch/trace 等命令时，实际上是修改了应用的字节码，插入增强的代码。显式执行 <code>reset</code> 命令，可以清除掉这些增强代码。</p></li><li><p>退出Arthas：</p><p>用 <code>exit</code> 或者 <code>quit</code> 命令可以退出Arthas。</p><p>退出Arthas之后，还可以再次用 <code>java -jar arthas-boot.jar</code> 来连接。</p></li><li><p>彻底退出Arthas：</p><p><code>exit/quit</code>命令只是退出当前session，arthas server还在目标进程中运行。</p><p>想完全退出Arthas，可以执行 <code>stop</code> 命令。</p></li></ul><h3 id="2-6-arthas-boot支持的参数"><a href="#2-6-arthas-boot支持的参数" class="headerlink" title="2.6 arthas-boot支持的参数"></a>2.6 arthas-boot支持的参数</h3><p><code>arthas-boot.jar</code> 支持很多参数，可以执行 <code>java -jar arthas-boot.jar -h</code> 来查看。</p><ul><li><p>允许外部访问：</p><p>默认情况下， arthas server侦听的是 <code>127.0.0.1</code> 这个IP，如果希望远程可以访问，可以使用<code>--target-ip</code>的参数。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> java -jar arthas-boot.jar --target-ip</span></span><br></pre></td></tr></table></figure></li><li><p>列出所有的版本：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> java -jar arthas-boot.jar --versions</span></span><br></pre></td></tr></table></figure><p>使用指定版本：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> java -jar arthas-boot.jar --use-version 3.1.0</span></span><br></pre></td></tr></table></figure></li><li><p>只侦听Telnet端口，不侦听HTTP端口：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> java -jar arthas-boot.jar --telnet-port 9999 --http-port -1</span></span><br></pre></td></tr></table></figure></li><li><p>打印运行的详情：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> java -jar arthas-boot.jar -v</span></span><br></pre></td></tr></table></figure></li></ul><hr><p>参考：</p><p>🔗 <a href="https://arthas.aliyun.com/">Arthas官网</a></p><p>🔗 <a href="https://arthas.aliyun.com/doc/index.html">Arthas 用户文档 — Arthas 3.5.4 文档 (aliyun.com)</a></p>]]></content>
    
    
    <summary type="html">内容包括：简介，教程（入门、进阶、案例）等。</summary>
    
    
    
    <category term="技术文档" scheme="http://linyishui.top/categories/%E6%8A%80%E6%9C%AF%E6%96%87%E6%A1%A3/"/>
    
    
    <category term="jvm" scheme="http://linyishui.top/tags/jvm/"/>
    
    <category term="Arthas" scheme="http://linyishui.top/tags/Arthas/"/>
    
  </entry>
  
  <entry>
    <title>Oracle优化器hint</title>
    <link href="http://linyishui.top/2021090601.html"/>
    <id>http://linyishui.top/2021090601.html</id>
    <published>2021-09-06T12:51:44.000Z</published>
    <updated>2022-01-19T09:17:26.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Oracle优化器hint"><a href="#Oracle优化器hint" class="headerlink" title="Oracle优化器hint"></a>Oracle优化器hint</h1><h2 id="一-简介"><a href="#一-简介" class="headerlink" title="一. 简介"></a>一. 简介</h2><p>优化器hint可以与SQL语句一起使用来改变执行计划。在SQL中使用hint来提高性能。hints（除了RULE-hint）会使Oracle使用基于成本的优化器，提示实际是SQL语句中的注释，语法格式：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"># 其中HINT被hint文本所取代，当hint文本的语法不正确时，hint文本被忽略，不会被使用。若没有<span class="operator">+</span>号就仅仅是注释。</span><br><span class="line"><span class="keyword">select</span> <span class="comment">/*+ HINT */</span> name</span><br><span class="line"><span class="keyword">from</span> emp</span><br><span class="line"><span class="keyword">where</span> id <span class="operator">=</span><span class="number">1</span>;</span><br></pre></td></tr></table></figure><p>hint可以让你做一些通常由优化器做出的决定。作为开发者，你可能知道一些优化器不知道的数据信息。hint提供了一种机制，指示优化器根据特定的标准选择某种查询执行计划。</p><p>例如，你可能知道某个索引对某些查询更有选择性。基于这些信息，你可能会选择一个比优化器更有效的执行计划。在这种情况下，可以使用hint来指示优化器使用最佳执行计划。</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"># 优化器选择employees.department_id列上的一个索引，来查找其部门ID 超过<span class="number">50</span>的雇员中的前<span class="number">25</span>行。优化器使用从索引中检索到的rowid，从雇员表中检索相应记录，并将其返回给客户端。第一条记录的检索通常几乎是在瞬间即可完成的。</span><br><span class="line"><span class="keyword">SELECT</span> <span class="comment">/*+ FIRST_ROWS(25) */</span> employee_id, department_id</span><br><span class="line"><span class="keyword">FROM</span> hr.employees</span><br><span class="line"><span class="keyword">WHERE</span> department_id <span class="operator">&gt;</span> <span class="number">50</span>;</span><br><span class="line"><span class="comment">------------------------------------------------------------------------</span></span><br><span class="line"><span class="operator">|</span> Id <span class="operator">|</span> Operation <span class="operator">|</span> Name <span class="operator">|</span> <span class="keyword">Rows</span> <span class="operator">|</span> Bytes</span><br><span class="line"><span class="comment">------------------------------------------------------------------------</span></span><br><span class="line"><span class="operator">|</span>  <span class="number">0</span> <span class="operator">|</span> <span class="keyword">SELECT</span> STATEMENT <span class="operator">|</span> <span class="operator">|</span> <span class="number">26</span> <span class="operator">|</span> <span class="number">182</span></span><br><span class="line"><span class="operator">|</span>  <span class="number">1</span> <span class="operator">|</span> <span class="keyword">TABLE</span> ACCESS <span class="keyword">BY</span> INDEX ROWID <span class="operator">|</span> EMPLOYEES <span class="operator">|</span> <span class="number">26</span> <span class="operator">|</span> <span class="number">182</span></span><br><span class="line"><span class="operator">|</span><span class="operator">*</span> <span class="number">2</span> <span class="operator">|</span> INDEX <span class="keyword">RANGE</span> SCAN <span class="operator">|</span> EMP_DEPARTMENT_IX <span class="operator">|</span> <span class="operator">|</span></span><br><span class="line"><span class="comment">------------------------------------------------------------------------</span></span><br><span class="line"></span><br><span class="line"># 无提示<span class="keyword">SELECT</span>语句的执行计划</span><br><span class="line"><span class="keyword">SELECT</span> employee_id, department_id</span><br><span class="line"><span class="keyword">FROM</span> hr.employees</span><br><span class="line"><span class="keyword">WHERE</span> department_id <span class="operator">&gt;</span> <span class="number">50</span>;</span><br><span class="line"><span class="comment">------------------------------------------------------------------------</span></span><br><span class="line"><span class="operator">|</span> Id <span class="operator">|</span> Operation <span class="operator">|</span> Name <span class="operator">|</span> <span class="keyword">Rows</span> <span class="operator">|</span> Bytes <span class="operator">|</span> Cos</span><br><span class="line"><span class="comment">------------------------------------------------------------------------</span></span><br><span class="line"><span class="operator">|</span>  <span class="number">0</span> <span class="operator">|</span> <span class="keyword">SELECT</span> STATEMENT <span class="operator">|</span> <span class="operator">|</span> <span class="number">50</span> <span class="operator">|</span> <span class="number">350</span> <span class="operator">|</span></span><br><span class="line"><span class="operator">|</span><span class="operator">*</span> <span class="number">1</span> <span class="operator">|</span> <span class="keyword">VIEW</span> <span class="operator">|</span> index$_join$_001 <span class="operator">|</span> <span class="number">50</span> <span class="operator">|</span> <span class="number">350</span> <span class="operator">|</span></span><br><span class="line"><span class="operator">|</span><span class="operator">*</span> <span class="number">2</span> <span class="operator">|</span> HASH <span class="keyword">JOIN</span> <span class="operator">|</span> <span class="operator">|</span> <span class="operator">|</span> <span class="operator">|</span></span><br><span class="line"><span class="operator">|</span><span class="operator">*</span> <span class="number">3</span> <span class="operator">|</span> INDEX <span class="keyword">RANGE</span> SCAN <span class="operator">|</span> EMP_DEPARTMENT_IX <span class="operator">|</span> <span class="number">50</span> <span class="operator">|</span> <span class="number">350</span> <span class="operator">|</span></span><br><span class="line"><span class="operator">|</span>  <span class="number">4</span> <span class="operator">|</span> INDEX FAST <span class="keyword">FULL</span> SCAN<span class="operator">|</span> EMP_EMP_ID_PK <span class="operator">|</span> <span class="number">50</span> <span class="operator">|</span> <span class="number">350</span> <span class="operator">|</span></span><br><span class="line"></span><br><span class="line">将两个索引联接以尽可能快的返回请求的记录。优化器并不像上述hint那样多次在表和索引间倒腾，而是在EMP_DEPARTMENT_IX索引上使用范围扫描，找出所有部门ID超过<span class="number">50</span>的行，并将这些行放在一个哈希表中。然后优化器读取EMP_EMP_ID_PK索引。对该索引中的每一行，它探测一次该哈希表，以查找相应的部门id。</span><br><span class="line"></span><br><span class="line">在这种情况下，数据库不能在完成对EMP_DEPARTMENT_IX索引的范围扫描之前向客户端返回第一行。因此，此生成的计划将需要更长的时间返回第一条记录。与示例中按索引rowid访问表的计划不同，计划使用多数据块 I<span class="operator">/</span>O，导致大量读取操作。这种读取使得整个结果集的最后一行会更快地返回。</span><br></pre></td></tr></table></figure><h2 id="二-Hint种类"><a href="#二-Hint种类" class="headerlink" title="二. Hint种类"></a>二. Hint种类</h2><h3 id="2-1-几种hint类别"><a href="#2-1-几种hint类别" class="headerlink" title="2.1 几种hint类别"></a>2.1 几种hint类别</h3><ul><li><p>Single-table：</p><p>单表hint是在一个表或视图上指定的，如：<code>INDEX</code> ，<code>USE_NL</code>。</p></li><li><p>Multi-table</p><p>多表hint与单表hint一样，只是hint可以指定一个或多个表或视图。如： <code>LEADING</code> ，<code>USE_NL(table1 table2)</code> ，<code>USE_NL(table1)</code> ，<code>USE_NL(table2)</code> 。</p></li><li><p>Query block</p><p>查询块hint对单个查询块进行操作，如：<code>STAR_TRANSFORMATION</code> ，<code>UNNEST</code> 。</p></li><li><p>Statement</p><p>语句hint适用于整个SQL语句，如 <code>ALL_ROWS</code> 。</p></li></ul><h3 id="2-2-常见hint"><a href="#2-2-常见hint" class="headerlink" title="2.2 常见hint"></a>2.2 常见hint</h3><p>优化器的hint分为以下几类:</p><ul><li><a href="https://docs.oracle.com/cd/B19306_01/server.102/b14211/hintsref.htm#CHDFIAJD">Hints for Optimization Approaches and Goals</a>：优化方法和目标的hint<ul><li><code>ALL_ROWS</code>：明确地选择了基于成本的方法来优化语句块，目标是最佳吞吐量（即最小的总资源消耗）。</li><li><code>FIRST_ROWS(n)</code>：明确地选择了基于成本的方法来优化语句块，目标是最佳响应时间（返回第一行的最小资源占用）。在较新的Oracle版本中，你应该给这个提示一个参数：<code>FIRST_ROWS(n)</code> 意味着优化器将确定一个执行计划，为返回前n行提供快速响应。</li><li><code>CHOOSE</code>：使优化器在基于规则的方法和基于成本的方法之间选择一个SQL语句，基于该语句所访问的表的统计信息的存在。</li><li><code>RULE</code>：为一个语句块明确地选择了基于规则的优化。这个提示也导致优化器忽略了为语句块指定的任何其他提示。RULE提示在Oracle 10g中不再起作用。</li></ul></li><li><a href="https://docs.oracle.com/cd/B19306_01/server.102/b14211/hintsref.htm#CHDJDIAH">Hints for Access Paths</a>：访问路径的hint<ul><li><code>FULL</code>：明确地选择了对指定表进行全表扫描。FULL提示的语法是FULL(table)，其中table指定了要进行全表扫描的表的别名（如果别名不存在，则是表名）。</li><li><code>ROWID</code>：明确地选择了对指定表进行ROWID扫描。ROWID提示的语法是 <code>ROWID(table)</code> ，其中table指定了要进行ROWID表访问的表的名称或别名。(这个提示在Oracle 10g中被废弃)</li><li><code>CLUSTER</code>：明确地选择了集群扫描来访问指定的表。CLUSTER提示的语法是 <code>CLUSTER(table)</code> ，其中table指定了要被集群扫描访问的表的名称或别名。</li><li><code>HASH</code>：明确地选择了一个散列扫描来访问指定的表。HASH提示的语法是 <code>HASH(table)</code> ，其中table指定要通过散列扫描访问的表的名称或别名。</li><li><code>HASH_AJ</code>：将一个NOT IN子查询转换为一个哈希反连接，以访问指定的表。HASH_AJ提示的语法是 <code>HASH_AJ(table)</code> ，其中table指定了要访问的表的名称或别名（在Oracle 10g中被废弃）。</li><li><code>INDEX</code>：明确地选择了对指定表的索引扫描。INDEX提示的语法是 <code>INDEX(table index)</code> ，其中:table指定与要扫描的索引相关的表的名称或别名，index指定要进行索引扫描的索引。这个提示可以选择性地指定一个或多个索引。</li><li><code>NO_INDEX</code>：明确地禁止为指定的表建立一组索引。NO_INDEX提示的语法是NO_INDEX(表索引)</li><li><code>INDEX_ASC</code>：明确地选择了对指定表的索引扫描。如果语句使用索引范围扫描，Oracle会按照索引值的升序扫描索引条目。</li><li><code>INDEX_COMBINE</code>：如果没有索引作为INDEX_COMBINE提示的参数，优化器将在表上使用位图索引的任何布尔组合，具有最佳成本估计。如果给出了某些索引作为参数，优化器将尝试使用这些特定位图索引的一些布尔组合。INDEX_COMBINE的语法是INDEX_COMBINE(表索引)。</li><li><code>INDEX_JOIN</code>：明确指示优化器使用一个索引连接作为访问路径。为了使提示产生积极的效果，必须存在足够少的索引，包含解决查询所需的所有列。</li><li><code>INDEX_DESC</code>：明确地选择了对指定表的索引扫描。如果语句使用索引范围扫描，Oracle会按照索引值的降序扫描索引条目。</li><li><code>INDEX_FFS</code>：这个提示导致执行快速的全索引扫描，而不是全表扫描。</li><li><code>NO_INDEX_FFS</code>：不要使用快速全索引扫描（来自Oracle 10g）。</li><li><code>INDEX_SS</code>：从查询计划中排除范围扫描（来自Oracle 10g）。</li><li><code>INDEX_SS_ASC</code>：从查询计划中排除范围扫描（来自Oracle 10g）。</li><li><code>INDEX_SS_DESC</code>：从查询计划中排除范围扫描（来自Oracle 10g）。</li><li><code>NO_INDEX_SS</code>：导致优化器排除对指定表的指定索引进行跳过扫描（来自Oracle 10g）。</li></ul></li><li><a href="https://docs.oracle.com/cd/B19306_01/server.102/b14211/hintsref.htm#CHDEHFHG">Hints for Query Transformations</a>：查询转换的hint<ul><li><code>NO_QUERY_TRANSFORMATION</code>：防止优化器进行查询转换（来自Oracle 10g）。</li><li><code>USE_CONCAT</code>：强制将查询的WHERE子句中的组合OR条件转化为使用UNION ALL集合操作符的复合查询。通常情况下，只有当使用连接条件的查询成本比不使用连接条件的查询成本低时，才会发生这种转换。</li><li><code>NO_EXPAND</code>：阻止优化器对WHERE子句中具有OR条件或IN列表的查询考虑OR扩展。通常情况下，优化器会考虑使用OR扩展，如果它认为成本比不使用它低，就会使用这种方法。</li><li><code>REWRITE</code>：强制优化器在可能的情况下以物化视图的方式重写查询，而不考虑成本。无论是否有视图列表，都可以使用REWRITE提示。如果你使用REWRITE和一个视图列表，并且该列表包含一个合格的物化视图，那么Oracle会使用该视图，而不考虑其成本。</li><li><code>NOREWRITE / NO_REWRITE</code>：在Oracle 10g中改名为NO_REWRITE。NOREWRITE/NO_REWRITE提示禁用了查询块的查询重写，覆盖了参数 <code>QUERY_REWRITE_ENABLED</code> 的设置。</li><li><code>MERGE</code>：可以让你在一个查询中合并视图。</li><li><code>NO_MERGE</code>：使Oracle不合并可合并的视图。这个提示最常被用来减少查询的可能排列组合的数量，使优化更快。</li><li><code>FACT</code>：表示该表应该被认为是一个事实表。这是在星形转换的背景下使用的。</li><li><code>NO_FACT</code>：在星形转换的上下文中使用，向转换表明提示的表不应该被视为事实表。</li><li><code>STAR_TRANSFORMATION</code>：使优化器使用已使用转换的最佳计划。如果没有这个提示，优化器可以做出查询优化的决定，使用没有转换的最佳计划，而不是转换后的查询的最佳计划。</li><li><code>NO_STAR_TRANSFORMATION</code>：不使用星形转换（来自Oracle 10g）。</li><li><code>UNNEST</code>：指定子查询的不嵌套。</li><li><code>NO_UNNEST</code>：可以关闭特定子查询块的不嵌套。</li></ul></li><li><a href="https://docs.oracle.com/cd/B19306_01/server.102/b14211/hintsref.htm#CHDGGCHC">Hints for Join Orders</a>：联接顺序的hint<ul><li><code>LEADING</code>：给出这个hint以指示连接中的主导表，将只表示1个表。可以使用ORDERED指定整个表的顺序。语法：<code>LEADING(table)</code> 。</li><li><code>ORDERED</code>：使Oracle按照表在FROM子句中出现的顺序连接表。如果你在执行连接的SQL语句中省略了ORDERED提示，优化器会选择连接表的顺序。如果你知道一些优化器不知道的从每个表中选择的行数，你可能想使用ORDERED提示来指定一个连接顺序。这些信息可以让你比优化器更好地选择内表和外表。</li></ul></li><li><a href="https://docs.oracle.com/cd/B19306_01/server.102/b14211/hintsref.htm#CHDBAFID">Hints for Join Operations</a>：连接操作的hint<ul><li><code>USE_NL</code>：使Oracle以嵌套循环连接的方式将每个指定的表与另一个记录源连接起来，并以指定的表作为内表。USE_NL提示的语法是 <code>USE_NL(table table)</code> ，其中table是一个表的名称或别名，将被用作嵌套循环连接的内表。</li><li><code>NO_USE_NL</code>：不要使用嵌套循环（来自Oracle 10g）。</li><li><code>USE_NL_WITH_INDEX</code>：指定一个嵌套的循环连接（来自Oracle 10g）。</li><li><code>USE_MERGE</code>：会使Oracle以排序合并连接的方式将每个指定的表与另一个行源连接起来。USE_MERGE提示的语法是 <code>USE_MERGE(table)</code> ，其中table是一个要连接到行源的表，这个行源是用排序合并连接的方式连接前面的表而得到的。</li><li><code>NO_USE_MERGE</code>：不要使用合并（来自Oracle 10g）。</li><li><code>USE_HASH</code>：使Oracle以散列连接的方式将每个指定的表与另一个行源连接。USE_HASH提示的语法是 <code>USE_HASH(table table)</code> ，其中table是一个要连接到行源的表，这个行源是用散列连接的方式连接前面的表而得到的。</li><li><code>NO_USE_HASH</code>：不要使用哈希（来自Oracle 10g）。</li></ul></li><li><a href="https://docs.oracle.com/cd/B19306_01/server.102/b14211/hintsref.htm#CHDJIGDG">Hints for Parallel Execution</a>：并行执行的hint<ul><li><code>PARALLEL</code>：允许你指定可用于查询的并发查询服务器的数量。语法是PARALLEL(表号数)。如果在查询中指定了别名，PARALLEL提示必须使用表的别名。然后，PARALLEL提示可以取两个值，在表名后面用逗号分隔。第一个值指定给定表的并行程度，第二个值指定该表如何在并行服务器的实例中被分割。指定DEFAULT或没有值表示查询协调器应该检查初始化参数的设置（在后面的章节中描述）以确定默认的并行程度。</li><li><code>NOPARALLEL / NO_PARALLEL</code>：允许你禁用一个表的并行扫描，即使该表是用PARALLEL子句创建的。在Oracle 10g中，这个提示被重新命名为NO_PARALLEL。</li><li><code>PQ_DISTRIBUTE</code>：提高了并行连接操作的性能。通过指定连接表的行应该如何在生产者和消费者查询服务器之间分配来做到这一点。使用这个提示会覆盖优化器通常会做出的决定。</li><li><code>NO_PARALLEL_INDEX</code>：覆盖了一个索引上的PARALLEL属性设置，以避免平行索引扫描操作。</li></ul></li><li><a href="https://docs.oracle.com/cd/B19306_01/server.102/b14211/hintsref.htm#CHDIDIDI">Additional Hints</a>：其他hint<ul><li><code>APPEND</code>：当APPEND提示与INSERT语句一起使用时，数据被追加到表中。区块中现有的自由空间不被使用。如果一个表或索引被指定为nologging，这个提示与一个插入语句一起使用会产生一个直接的路径插入，从而减少重做的产生。</li><li><code>NOAPPEND</code>：覆盖附加模式。</li><li><code>CACHE</code>：指定当进行全表扫描时，为提示中的表检索的块被放置在缓冲区缓存的LRU列表中最近使用的一端。这个选项对于小的查询表很有用。在下面的例子中，CACHE提示覆盖了表的默认缓存规范。</li><li><code>NOCACHE</code>：当执行全表扫描时，为该表检索的块被放在缓冲区缓存中LRU列表的最近使用的一端。这是缓冲区缓存中块的正常行为。</li><li><code>PUSH_PRED</code>：强制将连接谓词推入视图。</li><li><code>NO_PUSH_PRED</code>：防止将连接谓词推入视图。</li><li><code>PUSH_SUBQ</code>：使非合并子查询在执行计划中尽可能早地被评估。</li><li><code>NO_PUSH_SUBQ</code>：导致非合并子查询作为执行计划的最后一步被评估。</li><li><code>QB_NAME</code>：为一个查询块指定一个名称（来自Oracle 10g）。</li><li><code>CURSOR_SHARING_EXACT</code>：如果安全的话，Oracle可以用绑定变量替换SQL语句中的字面意思。这是由CURSOR_SHARING启动参数控制的。CURSOR_SHARING_EXACT提示使这种行为被关闭。换句话说，Oracle在执行SQL语句时，不会试图用绑定变量替换字面意义。</li><li><code>DRIVING_SITE</code>：强制在与Oracle选择的站点不同的站点上对表执行查询。</li><li><code>DYNAMIC_SAMPLING</code>：可以让你控制动态采样，通过确定表和索引的更精确的谓词选择性和统计数据来提高服务器性能。你可以将DYNAMIC_SAMPLING的值设置为0到10的数值。级别越高，编译器在动态采样方面投入的精力越多，应用也越广泛。除非你指定一个表，否则采样的默认值是游标级。</li><li><code>SPREAD_MIN_ANALYSIS</code>：这个提示省略了一些规则的编译时间优化，主要是详细的依赖图分析，在电子表格上。一些优化，如创建过滤器以有选择地填充电子表格访问结构和有限的规则修剪仍然被使用（来自Oracle 10g）。</li></ul></li><li>Hints with unknown status：hint<ul><li><code>MERGE_AJ</code>：将一个NOT IN子查询转换为一个合并反连接，以访问指定的表。MERGE_AJ提示的语法是 <code>MERGE_AJ(table)</code> ，其中table指定要访问的表的名称或别名。</li><li><code>AND_EQUAL</code>：明确地选择了一个执行计划，该计划使用一个访问路径，合并了几个单列索引的扫描。AND_EQUAL提示的语法是 <code>AND_EQUAL(table index index)</code> ，其中table指定了与要合并的索引相关的表的名称或别名，index指定了一个要进行索引扫描的索引。你必须至少指定两个索引。你不能指定超过五个。(在Oracle 10g中被废弃)</li><li><code>STAR</code>：迫使大表使用索引上的嵌套循环连接最后被连接。优化器将考虑小表的不同排列组合。(在Oracle 10g中被废弃)</li><li><code>BITMAP</code>：<code>BITMAP(table_name index_name)</code> 使用一个位图索引来访问表。(depricated ?)</li><li><code>HASH_SJ</code>：使用 <code>Hash Anti-Join</code> 来评估一个NOT IN子查询。在子查询中使用这个提示，而不是在主查询中。当你的大量NOT IN子查询使用FILTER或NESTED LOOPS连接时，使用这个提示。如果HASH_AJ拒绝工作，请尝试MERGE_AJ。（在Oracle 10g中被废弃）</li><li><code>NL_SJ</code>：在一个子查询中使用嵌套循环。(在Oracle 10g中被废弃)</li><li><code>NL_AJ</code>：在一个子查询中使用反连接。(在Oracle 10g中被废弃)</li><li><code>ORDERED_PREDICATES</code>：(在Oracle 10g中被废弃)</li><li><code>EXPAND_GSET_TO_UNION</code>：(在Oracle 10g中被废弃)</li></ul></li></ul><h2 id="三-hint语句归纳"><a href="#三-hint语句归纳" class="headerlink" title="三. hint语句归纳"></a>三. hint语句归纳</h2><h3 id="3-1-使用列表"><a href="#3-1-使用列表" class="headerlink" title="3.1 使用列表"></a>3.1 使用列表</h3><ol><li> <code>/*+ ALL_ROWS*/</code>：表明对语句块选择基于开销的优化方法，并获得最佳吞吐量，使资源消耗最小化。</li></ol>   <figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> <span class="comment">/*+ ALL_ROWS*/</span> EMP_NO,EMP_NAM,DAT_IN <span class="keyword">FROM</span> BSEMPMS <span class="keyword">WHERE</span> EMP_NO<span class="operator">=</span>’SCOTT’;</span><br></pre></td></tr></table></figure><ol start="2"><li><p><code>/*+ FIRST_ROWS*/</code>：表明对语句块选择基于开销的优化方法，并获得最佳响应时间，使资源消耗最小化。</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> <span class="comment">/*+ FIRST_ROWS*/</span> EMP_NO,EMP_NAM,DAT_IN <span class="keyword">FROM</span> BSEMPMS <span class="keyword">WHERE</span> EMP_NO<span class="operator">=</span>’SCOTT’;</span><br></pre></td></tr></table></figure></li><li><p><code>/*+ CHOOSE*/</code>：表明如果数据字典中有访问表的统计信息，将基于开销的优化方法，并获得最佳的吞吐量;表明如果数据字典中没有访问表的统计信息，将基于规则开销的优化方法。</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> <span class="comment">/*+ CHOOSE*/</span> EMP_NO,EMP_NAM,DAT_IN <span class="keyword">FROM</span> BSEMPMS <span class="keyword">WHERE</span> EMP_NO<span class="operator">=</span>’SCOTT’;</span><br></pre></td></tr></table></figure></li><li><p><code>/*+ RULE*/</code>：表明对语句块选择基于规则的优化方法。</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> <span class="comment">/*+ RULE*/</span> EMP_NO,EMP_NAM,DAT_IN <span class="keyword">FROM</span> BSEMPMS <span class="keyword">WHERE</span> EMP_NO<span class="operator">=</span>’SCOTT’;</span><br></pre></td></tr></table></figure></li><li><p><code>/*+ FULL(TABLE)*/</code>：表明对表选择全局扫描的方法。</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> <span class="comment">/*+ FULL(A)*/</span> EMP_NO,EMP_NAM <span class="keyword">FROM</span> BSEMPMS A <span class="keyword">WHERE</span> EMP_NO<span class="operator">=</span>’SCOTT’;</span><br></pre></td></tr></table></figure></li><li><p><code>/*+ ROWID(TABLE)*/</code>：提示明确表明对指定表根据ROWID进行访问。</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> <span class="comment">/*+ ROWID(BSEMPMS)*/</span> <span class="keyword">FROM</span> BSEMPMS <span class="keyword">WHERE</span> ROWID<span class="operator">&gt;=</span>’AAAAAAAAAAAAAA’ <span class="keyword">AND</span> EMP_NO<span class="operator">=</span>’SCOTT’;</span><br></pre></td></tr></table></figure></li><li><p><code>/*+ CLUSTER(TABLE)*/</code>：提示明确表明对指定表选择簇扫描的访问方法，它只对簇对象有效。</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> <span class="comment">/*+ CLUSTER*/</span> BSEMPMS.EMP_NO,DPT_NO <span class="keyword">FROM</span> BSEMPMS,BSDPTMS <span class="keyword">WHERE</span> DPT_NO<span class="operator">=</span>’TEC304′ <span class="keyword">AND</span> BSEMPMS.DPT_NO<span class="operator">=</span>BSDPTMS.DPT_NO;</span><br></pre></td></tr></table></figure></li><li><p><code>/*+ INDEX(TABLE INDEX_NAME)*/</code>：表明对表选择索引的扫描方法。</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> <span class="comment">/*+ INDEX(BSEMPMS SEX_INDEX) USE SEX_INDEX BECAUSE THERE ARE FEWMALE BSEMPMS */</span> <span class="keyword">FROM</span> BSEMPMS <span class="keyword">WHERE</span> SEX<span class="operator">=</span>’M<span class="string">&#x27;;</span></span><br></pre></td></tr></table></figure></li><li><p><code>/*+ INDEX_ASC(TABLE INDEX_NAME)*/</code>：表明对表选择索引升序的扫描方法。</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> <span class="comment">/*+ INDEX_ASC(BSEMPMS PK_BSEMPMS) */</span> <span class="keyword">FROM</span> BSEMPMS <span class="keyword">WHERE</span> DPT_NO<span class="operator">=</span>’SCOTT’;</span><br></pre></td></tr></table></figure></li><li><p><code>/*+ INDEX_COMBINE*/</code>：为指定表选择位图访问路经，如果INDEX_COMBINE中没有提供作为参数的索引，将选择出位图索引的布尔组合方式。</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> <span class="comment">/*+ INDEX_COMBINE(BSEMPMS SAL_BMI HIREDATE_BMI)*/</span> <span class="operator">*</span> <span class="keyword">FROM</span> BSEMPMS <span class="keyword">WHERE</span> SAL<span class="operator">&lt;</span><span class="number">5000000</span> <span class="keyword">AND</span> HIREDATE</span><br></pre></td></tr></table></figure></li><li><p><code>/*+ INDEX_JOIN(TABLE INDEX_NAME)*/</code>：提示明确命令优化器使用索引作为访问路径。</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> <span class="comment">/*+ INDEX_JOIN(BSEMPMS SAL_HMI HIREDATE_BMI)*/</span> SAL,HIREDATE <span class="keyword">FROM</span> BSEMPMS <span class="keyword">WHERE</span> SAL<span class="operator">&lt;</span><span class="number">60000</span>;</span><br></pre></td></tr></table></figure></li><li><p><code>/*+ INDEX_DESC(TABLE INDEX_NAME)*/</code>：表明对表选择索引降序的扫描方法。</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> <span class="comment">/*+ INDEX_DESC(BSEMPMS PK_BSEMPMS)*/</span> <span class="keyword">FROM</span> BSEMPMS <span class="keyword">WHERE</span> DPT_NO<span class="operator">=</span><span class="string">&#x27;SCOTT&#x27;</span>;</span><br></pre></td></tr></table></figure></li><li><p><code>/*+ INDEX_FFS(TABLE INDEX_NAME)*/</code>：对指定的表执行快速全索引扫描,而不是全表扫描的办法。</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> <span class="comment">/*+ INDEX_FFS(BSEMPMS IN_EMPNAM)*/</span>  <span class="keyword">FROM</span> BSEMPMS <span class="keyword">WHERE</span> DPT_NO<span class="operator">=</span><span class="string">&#x27;TEC305&#x27;</span>;</span><br></pre></td></tr></table></figure></li><li><p><code>/*+ ADD_EQUAL TABLE INDEX_NAM1,INDEX_NAM2,...*/</code>：提示明确进行执行规划的选择，将几个单列索引的扫描合起来。</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> <span class="comment">/*+ ADD_EQUAL(BSEMPMS IN_DPTNO,IN_EMPNO,IN_SEX)*/</span> <span class="operator">*</span> <span class="keyword">FROM</span> BSEMPMS <span class="keyword">WHERE</span> EMP_NO<span class="operator">=</span><span class="string">&#x27;SCOTT&#x27;</span> <span class="keyword">AND</span> DPT_NO<span class="operator">=</span><span class="string">&#x27;TDC306&#x27;</span>;</span><br></pre></td></tr></table></figure></li><li><p><code>/*+ USE_CONCAT*/</code>：对查询中的WHERE后面的OR条件进行转换为UNION ALL的组合查询。</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> <span class="comment">/*+ USE_CONCAT*/</span> <span class="keyword">FROM</span> BSEMPMS <span class="keyword">WHERE</span> DPT_NO<span class="operator">=</span><span class="string">&#x27;TDC506&#x27;</span> <span class="keyword">AND</span> SEX<span class="operator">=</span><span class="string">&#x27;M&#x27;</span>;</span><br></pre></td></tr></table></figure></li><li><p><code>/*+ NO_EXPAND*/</code>：对于WHERE后面的OR 或者IN-LIST的查询语句，NO_EXPAND将阻止其基于优化器对其进行扩展。</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> <span class="comment">/*+ NO_EXPAND*/</span> <span class="keyword">FROM</span> BSEMPMS <span class="keyword">WHERE</span> DPT_NO<span class="operator">=</span><span class="string">&#x27;TDC506&#x27;</span> <span class="keyword">AND</span> SEX<span class="operator">=</span><span class="string">&#x27;M&#x27;</span>;</span><br></pre></td></tr></table></figure></li><li><p><code>/*+ NOWRITE*/</code>：禁止对查询块的查询重写操作。</p></li><li><p><code>/*+ REWRITE*/</code>：可以将视图作为参数。</p></li><li><p><code>/*+ MERGE(TABLE)*/</code>：能够对视图的各个查询进行相应的合并。</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> <span class="comment">/*+ MERGE(V) */</span> A.EMP_NO,A.EMP_NAM,B.DPT_NO </span><br><span class="line"><span class="keyword">FROM</span> BSEMPMS A, (SELET DPT_NO,<span class="built_in">AVG</span>(SAL) <span class="keyword">AS</span> AVG_SAL </span><br><span class="line">                 <span class="keyword">FROM</span> BSEMPMS B </span><br><span class="line">                 <span class="keyword">GROUP</span> <span class="keyword">BY</span> DPT_NO) V </span><br><span class="line"><span class="keyword">WHERE</span> A.DPT_NO<span class="operator">=</span>V.DPT_NO </span><br><span class="line">  <span class="keyword">AND</span> A.SAL<span class="operator">&gt;</span>V.AVG_SAL;</span><br></pre></td></tr></table></figure></li><li><p><code>/*+ NO_MERGE(TABLE)*/</code>：对于有可合并的视图不再合并。</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> <span class="comment">/*+ NO_MERGE(V)*/</span> A.EMP_NO,A.EMP_NAM,B.DPT_NO </span><br><span class="line"><span class="keyword">FROM</span> BSEMPMS A, (<span class="keyword">SELECT</span> DPT_NO,<span class="built_in">AVG</span>(SAL) <span class="keyword">AS</span> AVG_SAL </span><br><span class="line">                 <span class="keyword">FROM</span> BSEMPMS B </span><br><span class="line">                 <span class="keyword">GROUP</span> <span class="keyword">BY</span> DPT_NO) V </span><br><span class="line"><span class="keyword">WHERE</span> A.DPT_NO<span class="operator">=</span>V.DPT_NO </span><br><span class="line">  <span class="keyword">AND</span> A.SAL<span class="operator">&gt;</span>V.AVG_SAL;</span><br></pre></td></tr></table></figure></li><li><p><code>/*+ ORDERED*/</code>：根据表出现在FROM中的顺序，ORDERED使ORACLE依此顺序对其连接。</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> <span class="comment">/*+ ORDERED*/</span> A.COL1,B.COL2,C.COL3 </span><br><span class="line"><span class="keyword">FROM</span> TABLE1 A,TABLE2 B,TABLE3 C </span><br><span class="line"><span class="keyword">WHERE</span> A.COL1<span class="operator">=</span>B.COL1 <span class="keyword">AND</span> B.COL1<span class="operator">=</span>C.COL1;</span><br></pre></td></tr></table></figure></li><li><p><code>/*+ USE_NL(TABLE)*/</code>：将指定表与嵌套的连接的行源进行连接，并把指定表作为内部表。</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> <span class="comment">/*+ORDERED USE_NL(BSEMPMS)*/</span> BSDPTMS.DPT_NO,BSEMPMS.EMP_NO,BSEMPMS.EMP_NAM </span><br><span class="line"><span class="keyword">FROM</span> BSEMPMS,BSDPTMS </span><br><span class="line"><span class="keyword">WHERE</span> BSEMPMS.DPT_NO<span class="operator">=</span>BSDPTMS.DPT_NO;</span><br></pre></td></tr></table></figure></li><li><p><code>/*+ USE_MERGE(TABLE)*/</code>：将指定的表与其他行源通过合并排序连接方式连接起来。</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> <span class="comment">/*+USE_MERGE(BSEMPMS,BSDPTMS)*/</span> </span><br><span class="line"><span class="keyword">FROM</span> BSEMPMS,BSDPTMS </span><br><span class="line"><span class="keyword">WHERE</span> BSEMPMS.DPT_NO<span class="operator">=</span>BSDPTMS.DPT_NO;</span><br></pre></td></tr></table></figure></li><li><p><code>/*+ USE_HASH(TABLE)*/</code>：将指定的表与其他行源通过哈希连接方式连接起来。</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> <span class="comment">/*+USE_HASH(BSEMPMS,BSDPTMS)*/</span> </span><br><span class="line"><span class="keyword">FROM</span> BSEMPMS,BSDPTMS </span><br><span class="line"><span class="keyword">WHERE</span> BSEMPMS.DPT_NO<span class="operator">=</span>BSDPTMS.DPT_NO;</span><br></pre></td></tr></table></figure></li><li><p><code>/*+ DRIVING_SITE(TABLE)*/</code>：强制与ORACLE所选择的位置不同的表进行查询执行。</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> <span class="comment">/*+DRIVING_SITE(DEPT)*/</span>  </span><br><span class="line"><span class="keyword">FROM</span> BSEMPMS,DEPT<span class="variable">@BSDPTMS</span> </span><br><span class="line"><span class="keyword">WHERE</span> BSEMPMS.DPT_NO<span class="operator">=</span>DEPT.DPT_NO;</span><br></pre></td></tr></table></figure></li><li><p><code>/*+ LEADING(TABLE)*/</code>：将指定的表作为连接次序中的首表。</p></li><li><p><code>/*+ CACHE(TABLE)*/</code>：当进行全表扫描时，CACHE提示能够将表的检索块放置在缓冲区缓存中最近最少列表LRU的最近使用端。</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> <span class="comment">/*+ FULL(BSEMPMS) CAHE(BSEMPMS) */</span> EMP_NAM <span class="keyword">FROM</span> BSEMPMS;</span><br></pre></td></tr></table></figure></li><li><p><code>/*+ NOCACHE(TABLE)*/</code>：当进行全表扫描时，CACHE提示能够将表的检索块放置在缓冲区缓存中最近最少列表LRU的最近使用端。</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> <span class="comment">/*+ FULL(BSEMPMS) NOCAHE(BSEMPMS) */</span> EMP_NAM <span class="keyword">FROM</span> BSEMPMS;</span><br></pre></td></tr></table></figure></li><li><p><code>/*+ APPEND*/</code>：直接插入到表的最后，可以提高速度。</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">insert</span> <span class="comment">/*+ append*/</span> <span class="keyword">into</span> test1 <span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> test4;</span><br></pre></td></tr></table></figure></li><li><p><code>/*+ NOAPPEND*/</code>：通过在插入语句生存期内停止并行模式来启动常规插入。</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">insert</span> <span class="comment">/*+ noappend*/</span> <span class="keyword">into</span> test1 <span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> test4;</span><br></pre></td></tr></table></figure></li></ol><table><thead><tr><th align="center"><strong>Optimization Approaches</strong></th><th align="center"><strong>Access Methods</strong></th></tr></thead><tbody><tr><td align="center">ALL_ROWS</td><td align="center">AND_EQUAL</td></tr><tr><td align="center">CHOOSE</td><td align="center">CLUSTER</td></tr><tr><td align="center">FIRST RULES</td><td align="center">FULL</td></tr><tr><td align="center">RULE</td><td align="center">HASH</td></tr><tr><td align="center">Parallel Execution</td><td align="center">HASH_AJ</td></tr><tr><td align="center">APPEND*ORDERED</td><td align="center">HASH_SJ ***</td></tr><tr><td align="center">STAR**</td><td align="center">INDEX</td></tr><tr><td align="center">STAR_TRANSFORMATION*</td><td align="center">INDEX_ASC</td></tr><tr><td align="center">Join Operations</td><td align="center">INDEX_COMBINE*</td></tr><tr><td align="center">DRIVING_SITE*</td><td align="center">INDEX_DESC</td></tr><tr><td align="center">USE_HASH**</td><td align="center">INDEX_FFS*</td></tr><tr><td align="center">USE_MERGE</td><td align="center">MERGE_AJ**</td></tr><tr><td align="center">USE_NL</td><td align="center">MERGE_SJ***</td></tr><tr><td align="center"><strong>Additional Hints</strong></td><td align="center">ROW_ID</td></tr><tr><td align="center">CACHE</td><td align="center">USE_CONCAT</td></tr><tr><td align="center">NOCACHE</td><td align="center">NO_EXPAND***</td></tr><tr><td align="center">PUSH_SUBQ</td><td align="center">REWRITE***</td></tr><tr><td align="center">MERGE***</td><td align="center">NOREWRITE***</td></tr><tr><td align="center">NO_MERGE*</td><td align="center">Join Orders</td></tr><tr><td align="center">PUSH_JOIN_PRED***</td><td align="center"></td></tr><tr><td align="center">NO_PUSH_JOIN_PRED***</td><td align="center">NOAPPEND*</td></tr><tr><td align="center">ORDERED PREDICATES***</td><td align="center">NOPARALLEL</td></tr><tr><td align="center"></td><td align="center">PARALLEL</td></tr><tr><td align="center"></td><td align="center">PARALLEL_INDEX*</td></tr><tr><td align="center"></td><td align="center">NO_PARALLEL_INDEX***</td></tr></tbody></table><h3 id="3-2-使用注意"><a href="#3-2-使用注意" class="headerlink" title="3.2 使用注意"></a>3.2 使用注意</h3><p>使用提示需要遵循的原则：</p><ol><li>仔细检查提示语法。尽量使用完整注释语法 <code>/*+ hint */</code> 。</li><li>使用表别名。如果在查询中指定了表别名，那么提示必须也使用表别名。例如：<code>select /*+ index(e,dept_idx) */ from emp e;</code> 。</li><li>不要在提示中使用模式名称：如果在提示中指定了模式的所有者，那么提示将被忽略。例如：<code>select /*+ index(scott.emp,dept_idx) */ from emp;</code> 。</li><li>检验提示。如果提示指定了不可用的访问路径，那么这个提示将被忽略。</li></ol><p>导致提示无效的条件：</p><table><thead><tr><th>提示</th><th>被忽略的条件</th></tr></thead><tbody><tr><td>cluster</td><td>与非簇表一同使用</td></tr><tr><td>hash</td><td>与非簇表一同使用</td></tr><tr><td>hash_aj</td><td>不存在子查询</td></tr><tr><td>index</td><td>指定的索引不存在</td></tr><tr><td>index_combine</td><td>不存在位图索引</td></tr><tr><td>merge_aj</td><td>不存在子查询</td></tr><tr><td>parallel</td><td>调用的不是TABLE ACCESS FULL计划</td></tr><tr><td>push_subq</td><td>不存在子查询</td></tr><tr><td>star</td><td>事实表中存在不恰当的索引</td></tr><tr><td>use_concat</td><td>在where子句中不存在多个or条件</td></tr><tr><td>use_nl</td><td>表中不存在索引</td></tr></tbody></table><p>几种主要的优化模式：</p><ol><li>all_rows：all_rows是基于成本的优化方法，目的是提供整体最佳的吞吐量和最小的资源消耗。all_rows提示倾向使用全表扫描，而且不适用于OLTP数据库。使用all_rows提示应该保障查询中涉及的表和索引拥有使用analyze命令分析得到的统计资料。</li><li>rule：rule提示使Oracle为查询提供基于规则的优化模式。在怀疑CBO生成了非优化的执行计划时，通常首先尝试使用rule提示。Rule提示忽略表和索引的统计资料，并且使用基本的试探法生成执行计划。</li><li>first_rows：这个提示是基于成本的优化方法，目的是提供最快的反应时间。使用first_rows提示应该保障查询中涉及的表和索引拥有使用analyze命令分析得到的统计资料。</li><li>表的连接提示<ul><li>use_hash提示：use_hash 提示对指定的表进行散列连接。散列连接是Oracle用以驱动表（最小的表）向RAM区中装载记录的方法，RAM区由HASH_AREA_SIZE定义。散列连接适合中间结果比较大的情况。使用散列连接时,HASH_AREA_SIZE对速度影响非常大，如果驱动表不能一次装入内存，那么需要使用TEMP表空间，这种情况下速度比较慢。这个参数可以在session级别动态修改，需要进行散列连接时可以临时增大，速度可能显着增加。</li><li>use_merge 提示：use_merge 提示强制执行一个排序合并操作。排序合并操作通常与并行查询结合使用，因为排序合并操作倾向于全表扫描。该提示适合于生成大型结果集的查询。</li><li>use_nl：use_nl提示将强制对目标表执行嵌套循环连接。use_nl提示很少用于SQL调整，因为CBO和RBO更倾向于使用循环嵌套连接。</li><li>star提示：star 提示强制使用星型查询计划。前提是查询中至少三个表，而且在事实表中存在恰当的索引</li></ul></li><li>表反连接提示：SQL反连接是指在语句中包含NOT IN 或者NOT EXISTS子句时执行的操作。<ul><li>merge_aj：在使用全表访问比索引访问更好的情况下，可以在NOT IN子查询中使用merge_aj提示以便执行反连接。</li><li>hash_aj：hash_aj 提示放在NOT IN 子查询中用来希望执行散列连接时，执行散列反连接。hash_aj和merge_aj要求子查询列非空。</li></ul></li><li>INDEX提示：<ul><li>INDEX提示简介：INDEX提示被用于显示指定表名或表名与索引。如果只指定了表名，那么优化器将使用表中的”最优”索引。在永久优化SQL语句中，建议指定表和索引。</li><li>index_join 提示：index_join 提示明确要求优化器使用索引连接来作为访问路径。</li><li>and_equal 提示：and_equal 提示可以使多个非唯一的索引合并索引，并且使这些索引操作时就象单个连续索引一样。该提示如果被应用，在查询计划中显示的是AND-EQUAL</li><li>index_asc 提示：index_asc 提示使用升序索引。这是默认的优化器行为</li><li>no_index 提示：该提示忽略索引存在，类似full</li><li>index_combine提示：index_combine 提示用来强制使用位图索引作为表的访问路径。</li><li>index_ffs提示：索引快速完全扫描可以在不访问任何记录的情况下完成查询。</li><li>use_concat提示：use_concat提示要求为所有的OR条件使用UNION ALL执行计划，并将这个查询重新书写为多个查询。如果在WHERE子句中存在大量OR条件，可以考虑使用use_concat提示。</li></ul></li></ol><p>总结：</p><ol><li>因为提示放在注释中，所以如果提示通现存的执行计划不兼容，或者提示不正确，有可能被忽略。</li><li>在使用RBO时，可以通过提示将指定的查询更改为CBO。切记要对查询中涉及的所有表和索引进行分析</li><li>在使用CBO的时候，可以通过添加RULE提示或者FIRST_ROWS提示来开始调整一个可以的SQL语句</li><li>提示可以在子查询中使用，但是外部查询的提示不会带入子查询。</li><li>如果在查询计划中发现卡笛尔积（CARTESIAN），则要尽量解决。</li></ol><h2 id="四-深入剖析"><a href="#四-深入剖析" class="headerlink" title="四. 深入剖析"></a>四. 深入剖析</h2><h3 id="4-1-表连接hint"><a href="#4-1-表连接hint" class="headerlink" title="4.1 表连接hint"></a>4.1 表连接hint</h3><p>Oracle提供了各种类型的表连接：</p><ul><li><p>嵌套循环连接（nested loops join）：可以看作两层嵌套的for循环</p><ul><li><strong>访问次数：</strong>驱动表返回几条，被驱动表访问多少次。</li><li><strong>驱动表是否有顺序：</strong>有。</li><li><strong>是否要排序：</strong>否。</li><li><strong>应用场景：</strong><ol><li>关联中有一个表比较小；</li><li>被关联表的关联字段上有索引；</li><li>索引的键值不应该重复率很高</li></ol></li></ul></li><li><p>排序合并连接（sort merge join）</p><ul><li><p><strong>访问次数：</strong>两张表都只会访问0次或1次。</p></li><li><p><strong>驱动表是否有顺序：</strong>无。</p></li><li><p><strong>是否要排序：</strong>是。</p></li><li><p><strong>应用场景：</strong>当结果集已经排过序。</p></li><li><p>如果A表的数据为（2,1,4,5,2）,B表的数据为(2,2,1,3,1) ,首先将A表和B表全扫描后排序，如下：</p><pre><code>          A    B                    1     1                    2     1                    2     2                    4     2                    5     3</code></pre><p>因为没有驱动表，所以oracle会随机选择一张表驱动，如果选择了A扫描到1，然后扫描B，当扫描=1的时候则管理，当扫描到B=2时，再以B=2为驱动扫描A表，不是从1开始扫，而是从2开始扫描，交替的进行扫描、关联。</p></li></ul></li><li><p>哈希连接（hash join）：先把驱动表的关联字段hash到PGA中（rowid也在PGA中），然后扫描被驱动表，取第一条数据，将关联的字段hash一下探测PGA中的小表，如果匹配则关联，再取第二条…。</p><ul><li><strong>访问次数：</strong>驱动表和被驱动表都只会访问0次或1次。</li><li><strong>驱动表是否有顺序：</strong>有。</li><li><strong>是否要排序：</strong>否。</li><li><strong>应用场景：</strong> <ol><li>一个大表，一个小表的关联；</li><li>表上没有索引；</li><li>返回结果集比较大。</li></ol></li></ul></li><li><p>星形连接（star join）等。</p></li></ul><p>因为表连接是所有Oracle SQL执行步骤中最耗时的，Oracle对表连接的hint经常被用来测试各种连接技术的执行速度。</p><h4 id="（1）use-hash"><a href="#（1）use-hash" class="headerlink" title="（1）use_hash"></a>（1）use_hash</h4><p>use_hash提示要求对指定的表进行散列连接。从本质上讲，散列连接是一种Oracle将驱动表（最小的表，在where子句之后的第一个表）中的行加载到由hash_area_size初始化参数定义的RAM区域的技术。</p><p>Oracle使用散列技术来定位较大的第二个表中的记录。在两个表都非常大的情况下，散列连接经常与并行查询相结合。</p><p>下面的查询是一个被提示强制使用散列连接和并行查询的例子：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> <span class="comment">/*+ use_hash(e,b) parallel(e, 4) parallel(b, 4) */</span></span><br><span class="line">   e.ename, hiredate, b.comm</span><br><span class="line"><span class="keyword">from</span> emp e, bonus b</span><br><span class="line"><span class="keyword">where</span> e.ename <span class="operator">=</span> b.ename;</span><br><span class="line"># 下面是哈希连接的执行计划。注意这个连接中的两个表都使用并行查询来获得它们的记录。</span><br><span class="line">OPERATION</span><br><span class="line"><span class="comment">----------------------------------------------------------------------</span></span><br><span class="line">OPTIONS                        OBJECT_NAME                    POSITION</span><br><span class="line"><span class="comment">------------------------------ ---------------------------- ----------</span></span><br><span class="line"> <span class="keyword">SELECT</span> STATEMENT                                                    <span class="number">3</span></span><br><span class="line">  HASH <span class="keyword">JOIN</span>                                                          <span class="number">1</span></span><br><span class="line">PARALLEL_TO_SERIAL</span><br><span class="line">    <span class="keyword">TABLE</span> ACCESS <span class="keyword">FULL</span>           EMP                                  <span class="number">1</span></span><br><span class="line">PARALLEL_TO_PARALLEL</span><br><span class="line">    <span class="keyword">TABLE</span> ACCESS <span class="keyword">FULL</span>           BONUS                                <span class="number">2</span></span><br></pre></td></tr></table></figure><p>哈希连接通常比嵌套的循环连接更快，特别是在查询的where子句中，驱动表被过滤成少数行的情况下。</p><p>use_hash提示是非常微妙的，有许多条件必须得到满足。发现use_hash提示被忽略的情况并不少见，下面是造成这个问题的一些常见原因：</p><ul><li><strong>检查初始化参数</strong>：确保你对 <code>optimizer_index_cost_adj</code> 、<code>hash_multiblock_io_count</code> 、<code>optimizer_max_permutations</code> 和 <code>hash_area_size</code> 有进行适当的设置。</li><li><strong>验证驱动表</strong>：确保较小的表是驱动表（从句中的第一个表）。这是因为哈希连接使用驱动表建立内存阵列。</li><li><strong>分析CBO统计数据</strong>：检查表的和/或连接的关联表的列是否得到了适当的分析。</li><li><strong>检查偏斜的列（skewed columns ）</strong>：Histograms只建议用于非均匀的列分布。如果有必要，你可以使用 <code>ordered</code> 提示覆盖基于成本的优化器选择的连接顺序。</li><li><strong>检查RAM区域：</strong>确保 <code>hash_area_size</code> 足够大，以便在内存中容纳较小的表。否则，Oracle必须写到TEMP表空间，减慢散列连接的速度。</li></ul><h4 id="（2）use-merge"><a href="#（2）use-merge" class="headerlink" title="（2）use_merge"></a>（2）use_merge</h4><p>use_merge提示强制进行分类合并操作。排序合并操作经常与并行查询一起使用，因为排序合并连接总是对表进行全表扫描。排序合并连接通常最适合于产生非常大的结果集的查询，例如每日报告或表的细节汇总查询，或者在连接键上不具有索引的表。</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"># 通过对两个表的并行查询来执行分类合并的</span><br><span class="line"><span class="keyword">select</span> <span class="comment">/*+ use_merge(e,b) parallel(e, 4) parallel(b, 4) */</span></span><br><span class="line">   e.ename, hiredate, b.comm</span><br><span class="line"><span class="keyword">from</span> emp e, bonus b</span><br><span class="line"><span class="keyword">where</span> e.ename <span class="operator">=</span> b.ename;</span><br><span class="line"># 注意全表扫描和排序合并操作。</span><br><span class="line">OPERATION</span><br><span class="line"><span class="comment">----------------------------------------------------------------------</span></span><br><span class="line">OPTIONS                        OBJECT_NAME                    POSITION</span><br><span class="line"><span class="comment">------------------------------ ---------------------------- ----------</span></span><br><span class="line"> <span class="keyword">SELECT</span> STATEMENT                                                    <span class="number">5</span></span><br><span class="line">  <span class="keyword">MERGE</span> <span class="keyword">JOIN</span>                                                         <span class="number">1</span></span><br><span class="line">PARALLEL_TO_SERIAL</span><br><span class="line">    SORT <span class="keyword">JOIN</span>                                                        <span class="number">1</span></span><br><span class="line">PARALLEL_COMBINED_WITH_PARENT</span><br><span class="line">      <span class="keyword">TABLE</span> ACCESS <span class="keyword">FULL</span>         EMP                                  <span class="number">1</span></span><br><span class="line">PARALLEL_TO_PARALLEL</span><br><span class="line">    SORT <span class="keyword">JOIN</span>                                                        <span class="number">2</span></span><br><span class="line">PARALLEL_COMBINED_WITH_PARENT</span><br><span class="line">      <span class="keyword">TABLE</span> ACCESS <span class="keyword">FULL</span>         BONUS                                <span class="number">1</span></span><br><span class="line">PARALLEL_TO_PARALLEL</span><br></pre></td></tr></table></figure><p>值得注意的是，排序合并连接并不使用索引来连接表。在大多数情况下，索引访问更快，但是排序合并连接可能适合于没有where子句的大型表连接，或者没有可用索引连接表的查询。</p><h3 id="4-2-表反连接hint（Anti-Join）"><a href="#4-2-表反连接hint（Anti-Join）" class="headerlink" title="4.2 表反连接hint（Anti-Join）"></a>4.2 表反连接hint（Anti-Join）</h3><p>SQL的反连接是一种操作，一般在SQL语句中指定 <code>NOT IN</code> 或 <code>NOT EXISTS</code> 子句时使用。</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span></span><br><span class="line">   customer_name</span><br><span class="line"><span class="keyword">from</span></span><br><span class="line">   customer</span><br><span class="line"><span class="keyword">where</span></span><br><span class="line">   customer_number <span class="keyword">NOT</span> <span class="keyword">IN</span></span><br><span class="line">   (</span><br><span class="line">    <span class="keyword">select</span></span><br><span class="line">       customer_number</span><br><span class="line">    <span class="keyword">from</span></span><br><span class="line">       bad_credit_history</span><br><span class="line">   )</span><br><span class="line">;</span><br></pre></td></tr></table></figure><p>一般不建议使用NOT IN（调用子查询），而是使用NOT EXISTS（调用相关的子查询），因为如果子查询返回的任何记录包含空值，则查询不返回任何记录。</p><h4 id="（1）merge-aj"><a href="#（1）merge-aj" class="headerlink" title="（1）merge_aj"></a>（1）merge_aj</h4><p>merge_aj用于NOT IN子查询中，来执行反连接，表示全表访问优先于索引访问。</p><p>一个NOT IN案例：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"># 查询所有没有销售员的部门的名称。</span><br><span class="line"><span class="keyword">select</span> dname</span><br><span class="line"><span class="keyword">from</span> dept</span><br><span class="line"><span class="keyword">where</span> deptno <span class="keyword">NOT</span> <span class="keyword">IN</span></span><br><span class="line">   (<span class="keyword">select</span> deptno</span><br><span class="line">    <span class="keyword">from</span> emp</span><br><span class="line">    <span class="keyword">where</span> job <span class="operator">=</span> <span class="string">&#x27;SALESMAN&#x27;</span>);</span><br><span class="line"># 当子查询中的数据列允许为空值时，这种类型的查询的性能会非常差。子查询对于外部查询块中的每一条记录都要重新执行一次<span class="operator">!</span> 下面是执行计划：</span><br><span class="line">OPERATION</span><br><span class="line"><span class="comment">----------------------------------------------------------------------</span></span><br><span class="line">OPTIONS                        OBJECT_NAME                    POSITION</span><br><span class="line"><span class="comment">------------------------------ ---------------------------- ----------</span></span><br><span class="line"> <span class="keyword">SELECT</span> STATEMENT                                                    <span class="number">1</span></span><br><span class="line">  <span class="keyword">FILTER</span>                                                             <span class="number">1</span></span><br><span class="line">    <span class="keyword">TABLE</span> ACCESS <span class="keyword">FULL</span>             DEPT                               <span class="number">1</span></span><br><span class="line">    <span class="keyword">TABLE</span> ACCESS <span class="keyword">BY</span> INDEX ROWID   EMP                                <span class="number">2</span></span><br><span class="line">      INDEX <span class="keyword">RANGE</span> SCAN            JOB_IDX                            <span class="number">1</span></span><br></pre></td></tr></table></figure><p>NOT IN子查询有替代方法，它不会为外层查询块中的每条记录重新生成一次子查询；当外层查询块产生大量的记录时，应该考虑这种方法。</p><p>这个方法只能在子查询列上存在NOT NULL谓词并且你在子查询块中有一个hint时使用。根据所需的连接类型，反连接可以通过hash_aj或merge_aj的hint来执行。</p><p>注意：<strong>反连接提示merge_aj和hash_aj只有在not in子句中要求的列有NOT NULL约束时才会起作用。</strong></p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"># 优化后：</span><br><span class="line"><span class="keyword">select</span> dname</span><br><span class="line"><span class="keyword">from</span> dept</span><br><span class="line"><span class="keyword">where</span> deptno <span class="keyword">NOT</span> <span class="keyword">IN</span></span><br><span class="line">   (<span class="keyword">select</span> <span class="comment">/*+ merge_aj */</span> deptno</span><br><span class="line">    <span class="keyword">from</span> emp</span><br><span class="line">    <span class="keyword">where</span> job <span class="operator">=</span> <span class="string">&#x27;SALESMAN&#x27;</span>);</span><br><span class="line"># 查询的执行计划发生了变化，合并反连接被调用，代替了过滤操作。</span><br><span class="line">OPERATION</span><br><span class="line"><span class="comment">----------------------------------------------------------------------</span></span><br><span class="line">OPTIONS                        OBJECT_NAME                    POSITION</span><br><span class="line"><span class="comment">------------------------------ ---------------------------- ----------</span></span><br><span class="line"> <span class="keyword">SELECT</span> STATEMENT                                                    <span class="number">5</span></span><br><span class="line">  <span class="keyword">MERGE</span> <span class="keyword">JOIN</span> ANTI                                                    <span class="number">1</span></span><br><span class="line">    SORT <span class="keyword">JOIN</span>                                                        </span><br><span class="line">      <span class="keyword">TABLE</span> ACCESS <span class="keyword">FULL</span>                  DEPT                        <span class="number">1</span></span><br><span class="line">    SORT <span class="keyword">UNIQUE</span>                                                      <span class="number">2</span></span><br><span class="line">      <span class="keyword">VIEW</span>                               VW_NSO_1                    <span class="number">1</span></span><br><span class="line">        <span class="keyword">TABLE</span> ACCESS <span class="keyword">BY</span> INDEX ROWID      EMP                         <span class="number">1</span></span><br><span class="line">          INDEX <span class="keyword">RANGE</span> SCAN               JOB_IDX                     <span class="number">1</span></span><br></pre></td></tr></table></figure><h4 id="（2）hash-aj"><a href="#（2）hash-aj" class="headerlink" title="（2）hash_aj"></a>（2）hash_aj</h4><p>hash_aj提示被放置在一个not in子查询中，以便在需要散列连接的情况下执行散列反连接。</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> dname</span><br><span class="line"><span class="keyword">from</span> dept</span><br><span class="line"><span class="keyword">where</span> deptno <span class="keyword">NOT</span> <span class="keyword">IN</span></span><br><span class="line">   (<span class="keyword">select</span> <span class="comment">/*+ hash_aj */</span> deptno</span><br><span class="line">    <span class="keyword">from</span> emp</span><br><span class="line">    <span class="keyword">where</span> job <span class="operator">=</span> <span class="string">&#x27;SALESMAN&#x27;</span>);</span><br><span class="line"># 执行计划指定了一个散列连接，并对部门表进行全表扫描：</span><br><span class="line">OPERATION</span><br><span class="line"><span class="comment">----------------------------------------------------------------------</span></span><br><span class="line">OPTIONS                        OBJECT_NAME                    POSITION</span><br><span class="line"><span class="comment">------------------------------ ---------------------------- ----------</span></span><br><span class="line"> <span class="keyword">SELECT</span> STATEMENT                                                    <span class="number">3</span></span><br><span class="line">  HASH <span class="keyword">JOIN</span> ANTI                                                     <span class="number">1</span></span><br><span class="line">    <span class="keyword">TABLE</span> ACCESS <span class="keyword">FULL</span>               DEPT                             <span class="number">1</span></span><br><span class="line">    <span class="keyword">VIEW</span>                            VW_NSO_1                         <span class="number">2</span></span><br><span class="line">      <span class="keyword">TABLE</span> ACCESS <span class="keyword">BY</span> INDEX ROWID   EMP                              <span class="number">1</span></span><br><span class="line">        INDEX <span class="keyword">RANGE</span> SCAN            JOB_IDX                          <span class="number">1</span></span><br></pre></td></tr></table></figure><p>总之，merge_aj和hash_aj提示可以极大地提高NOT IN子查询的性能，前提是子查询的列是NOT NULL。</p><h2 id="五-案例"><a href="#五-案例" class="headerlink" title="五. 案例"></a>五. 案例</h2><h3 id="5-1-NOT-EXISTS优化"><a href="#5-1-NOT-EXISTS优化" class="headerlink" title="5.1 NOT EXISTS优化"></a>5.1 NOT EXISTS优化</h3><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> e.col_a, e.col_b, e.col_c, e.col_d, e.col_e, e.col_f, e.col_g,e.col_h</span><br><span class="line"><span class="keyword">from</span> Table_A e </span><br><span class="line"><span class="keyword">where</span> e.col_a <span class="operator">=</span> :col_a</span><br><span class="line">  <span class="keyword">and</span> e.col_b <span class="operator">&lt;=</span> :trade_date</span><br><span class="line">  <span class="keyword">and</span> e.col_b <span class="operator">&gt;</span> (:trade_date <span class="operator">-</span> <span class="number">31</span>)</span><br><span class="line">  <span class="keyword">and</span> e.col_c <span class="keyword">in</span> (<span class="keyword">select</span> a.col_c</span><br><span class="line">      <span class="keyword">from</span> Table_A a</span><br><span class="line">                      <span class="keyword">where</span> a.col_a <span class="operator">=</span> :col_a </span><br><span class="line">    <span class="keyword">and</span> a.col_b <span class="operator">&lt;=</span> :trade_date</span><br><span class="line">                        <span class="keyword">and</span> a.col_b <span class="operator">&gt;</span> (:trade_date <span class="operator">-</span> <span class="number">31</span>)</span><br><span class="line">                        <span class="keyword">and</span> a.col_d <span class="keyword">in</span> (<span class="string">&#x27;1&#x27;</span>, <span class="string">&#x27;2&#x27;</span>, <span class="string">&#x27;3&#x27;</span>, <span class="string">&#x27;4&#x27;</span>)</span><br><span class="line">    <span class="keyword">and</span> <span class="keyword">not</span> <span class="keyword">exists</span> (</span><br><span class="line">                            <span class="keyword">select</span> <span class="number">1</span> <span class="keyword">from</span> Table_B b </span><br><span class="line">                            <span class="keyword">where</span> b.col_a <span class="operator">=</span> :col_a </span><br><span class="line">                              <span class="keyword">and</span> a.col_c <span class="operator">=</span> b.col_c </span><br><span class="line">                              <span class="keyword">and</span> a.col_b <span class="operator">=</span> b.col_b </span><br><span class="line">                              <span class="keyword">and</span> b.trade_type <span class="keyword">in</span> (<span class="number">6</span>,<span class="number">7</span>))</span><br><span class="line"></span><br><span class="line"># 修改为：</span><br><span class="line">                  </span><br><span class="line"><span class="keyword">select</span> <span class="comment">/*+LEADING(D) NO_MERGE(D)*/</span></span><br><span class="line">   e.col_a, e.col_b, e.col_c,e.col_d, e.col_e, e.col_f, e.col_g, e.col_h</span><br><span class="line"><span class="keyword">from</span> Table_A e, (<span class="keyword">select</span> <span class="keyword">DISTINCT</span> a.col_c</span><br><span class="line"> <span class="keyword">from</span> Table_A a</span><br><span class="line"> <span class="keyword">where</span> a.col_a <span class="operator">=</span> :col_a</span><br><span class="line">   <span class="keyword">and</span> a.col_b <span class="operator">&lt;=</span> :trade_date</span><br><span class="line">   <span class="keyword">and</span> a.col_b <span class="operator">&gt;</span> (:trade_date <span class="operator">-</span> <span class="number">31</span>)</span><br><span class="line">                   <span class="keyword">and</span> a.col_d <span class="keyword">in</span> (<span class="string">&#x27;1&#x27;</span>, <span class="string">&#x27;2&#x27;</span>, <span class="string">&#x27;3&#x27;</span>, <span class="string">&#x27;4&#x27;</span>)</span><br><span class="line">                   <span class="keyword">and</span> <span class="keyword">not</span> <span class="keyword">exists</span> (<span class="keyword">select</span> <span class="comment">/*+ HASH_AJ*/</span><span class="number">1</span></span><br><span class="line">               <span class="keyword">from</span> Table_B b</span><br><span class="line">                                   <span class="keyword">where</span> b.col_a <span class="operator">=</span> :col_a</span><br><span class="line">                                     <span class="keyword">and</span> a.col_c <span class="operator">=</span> b.col_c</span><br><span class="line">                                     <span class="keyword">and</span> a.col_b <span class="operator">=</span> b.col_b</span><br><span class="line">                                     <span class="keyword">and</span> b.trade_type <span class="keyword">in</span> (<span class="number">6</span>,<span class="number">7</span>))) D</span><br><span class="line"><span class="keyword">where</span> e.col_a <span class="operator">=</span> :col_a</span><br><span class="line">  <span class="keyword">and</span> e.col_b <span class="operator">&lt;=</span> :trade_date</span><br><span class="line">  <span class="keyword">and</span> e.col_b <span class="operator">&gt;</span> (:trade_date <span class="operator">-</span> <span class="number">31</span>)</span><br><span class="line">  <span class="keyword">AND</span> e.col_c <span class="operator">=</span> D.col_c;</span><br></pre></td></tr></table></figure><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> c.col_a,c.col_b,c.col_c,c.col_e,c.col_g,c.col_f,c.col_i,</span><br><span class="line">c.col_d,c.col_j,c.col_k,c.col_l</span><br><span class="line"><span class="keyword">from</span> Table_A c</span><br><span class="line"><span class="keyword">where</span> c.col_a <span class="operator">=</span> :col_a </span><br><span class="line">  <span class="keyword">and</span> c.col_b <span class="operator">&gt;=</span> (:trade_date <span class="operator">-</span> <span class="number">31</span>) </span><br><span class="line">  <span class="keyword">and</span> c.col_b <span class="operator">&lt;=</span> :trade_date </span><br><span class="line">  <span class="keyword">and</span> c.col_c <span class="keyword">in</span> (<span class="keyword">select</span> col_c </span><br><span class="line">                  <span class="keyword">from</span> Table_A a</span><br><span class="line">  <span class="keyword">where</span> a.col_a <span class="operator">=</span> :col_a </span><br><span class="line">                    <span class="keyword">and</span> a.col_b <span class="operator">&gt;=</span> (:trade_date <span class="operator">-</span> <span class="number">31</span>)</span><br><span class="line">                    <span class="keyword">and</span> a.col_b <span class="operator">&lt;=</span> :trade_date</span><br><span class="line">                    <span class="keyword">and</span> a.col_j <span class="operator">=</span> <span class="number">38</span></span><br><span class="line">                    <span class="keyword">and</span> a.col_d <span class="operator">=</span> <span class="string">&#x27;64&#x27;</span></span><br><span class="line"><span class="keyword">and</span> a.col_h <span class="keyword">in</span> (<span class="string">&#x27;15&#x27;</span>,<span class="string">&#x27;16&#x27;</span>)</span><br><span class="line"><span class="keyword">and</span> <span class="keyword">not</span> <span class="keyword">exists</span> (</span><br><span class="line"><span class="keyword">select</span> <span class="number">1</span> <span class="keyword">from</span> Table_B b </span><br><span class="line">                            <span class="keyword">where</span> b.col_a <span class="operator">=</span> :col_a </span><br><span class="line">                              <span class="keyword">and</span> a.col_c <span class="operator">=</span> b.col_c </span><br><span class="line">                              <span class="keyword">and</span> a.col_b <span class="operator">=</span> b.col_b </span><br><span class="line">                              <span class="keyword">and</span> b.trade_type <span class="keyword">in</span> (<span class="number">6</span>,<span class="number">7</span>)</span><br><span class="line">                    )</span><br><span class="line">                 )</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"># 修改为：</span><br><span class="line"></span><br><span class="line"><span class="keyword">SELECT</span> <span class="comment">/*+LEADING(D) NO_MERGE(D)*/</span> </span><br><span class="line">       C.col_a,</span><br><span class="line">       C.col_b,</span><br><span class="line">       C.col_c,</span><br><span class="line">       C.col_e,</span><br><span class="line">       C.col_g,</span><br><span class="line">       C.col_f,</span><br><span class="line">       C.col_i,</span><br><span class="line">       C.col_d,</span><br><span class="line">       C.col_j,</span><br><span class="line">       C.col_k,</span><br><span class="line">       C.col_l</span><br><span class="line"><span class="keyword">FROM</span> Table_A C,(<span class="keyword">SELECT</span> <span class="keyword">DISTINCT</span> col_c</span><br><span class="line">                <span class="keyword">FROM</span> Table_A A</span><br><span class="line">                <span class="keyword">WHERE</span> A.col_a <span class="operator">=</span> :col_a</span><br><span class="line">                  <span class="keyword">AND</span> A.col_b <span class="operator">&gt;=</span> (:trade_date <span class="operator">-</span> <span class="number">31</span>)</span><br><span class="line">                <span class="keyword">AND</span> A.col_b <span class="operator">&lt;=</span> :trade_date</span><br><span class="line">                <span class="keyword">AND</span> A.col_j <span class="operator">=</span> <span class="number">38</span></span><br><span class="line">                <span class="keyword">AND</span> A.col_d <span class="operator">=</span> <span class="string">&#x27;64&#x27;</span></span><br><span class="line">                <span class="keyword">AND</span> A.col_h <span class="keyword">IN</span> (<span class="string">&#x27;15&#x27;</span>, <span class="string">&#x27;16&#x27;</span>)</span><br><span class="line">                <span class="keyword">AND</span> <span class="keyword">NOT</span> <span class="keyword">EXISTS</span> (</span><br><span class="line">                    <span class="keyword">SELECT</span> <span class="comment">/*+ HASH_AJ*/</span><span class="number">1</span></span><br><span class="line">                    <span class="keyword">FROM</span> Table_B B</span><br><span class="line">                    <span class="keyword">WHERE</span> B.col_a <span class="operator">=</span> :col_a</span><br><span class="line">                      <span class="keyword">AND</span> A.col_c <span class="operator">=</span> B.col_c</span><br><span class="line">                      <span class="keyword">AND</span> A.col_b <span class="operator">=</span> B.col_b</span><br><span class="line">                      <span class="keyword">AND</span> B.TRADE_TYPE <span class="keyword">IN</span> (<span class="number">6</span>,<span class="number">7</span>))) D</span><br><span class="line"><span class="keyword">WHERE</span> C.col_a <span class="operator">=</span> :col_a</span><br><span class="line">  <span class="keyword">AND</span> C.col_b <span class="operator">&gt;=</span> (:trade_date <span class="operator">-</span> <span class="number">31</span>)</span><br><span class="line">  <span class="keyword">AND</span> C.col_b <span class="operator">&lt;=</span> :trade_date</span><br><span class="line">  <span class="keyword">AND</span> C.col_c <span class="operator">=</span> D.col_c</span><br></pre></td></tr></table></figure><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> e.col_a, e.col_b, e.col_c, e.col_m, e.col_e, e.col_g, e.col_f, e.col_i,e.col_n, e.col_o, e.col_d, e.col_p, e.col_q, e.col_r, e.col_s, e.col_t, e.col_u, e.col_j, e.col_v, e.col_w, e.col_k, e.col_x</span><br><span class="line"><span class="keyword">from</span> Table_A e</span><br><span class="line"><span class="keyword">where</span> e.col_a <span class="operator">=</span> :col_a</span><br><span class="line">  <span class="keyword">and</span> e.col_b <span class="operator">&lt;=</span> :trade_date</span><br><span class="line">  <span class="keyword">and</span> e.col_b <span class="operator">&gt;</span> (:trade_date <span class="operator">-</span> <span class="number">31</span>)</span><br><span class="line">  <span class="keyword">and</span> e.col_j <span class="keyword">in</span> (<span class="number">1</span>,<span class="number">2</span>,<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>,<span class="number">7</span>,<span class="number">10</span>,<span class="number">11</span>,<span class="number">18</span>,<span class="number">37</span>)</span><br><span class="line">  <span class="keyword">and</span> <span class="keyword">not</span> <span class="keyword">exists</span> (</span><br><span class="line">      <span class="keyword">select</span> <span class="number">1</span> </span><br><span class="line">      <span class="keyword">from</span> Table_B b </span><br><span class="line">      <span class="keyword">where</span> b.col_a <span class="operator">=</span> :col_a </span><br><span class="line">        <span class="keyword">and</span> e.col_c <span class="operator">=</span> b.col_c </span><br><span class="line">        <span class="keyword">and</span> e.col_b <span class="operator">=</span> b.col_b</span><br><span class="line">        <span class="keyword">and</span> b.trade_type <span class="keyword">in</span> (<span class="number">6</span>,<span class="number">7</span>))</span><br><span class="line"><span class="keyword">order</span> <span class="keyword">by</span> e.col_a, e.col_b, e.col_c, e.col_m, e.col_y</span><br><span class="line"></span><br><span class="line"># 修改为： </span><br><span class="line"></span><br><span class="line"><span class="keyword">select</span> e.col_a, e.col_b, e.col_c, e.col_m, e.col_e,e.col_g, e.col_f, e.col_i,e.col_n, e.col_o, e.col_d, e.col_p,e.col_q, e.col_r, e.col_s, e.col_t,e.col_u, e.col_j, e.col_v, e.col_w, e.col_k, e.col_x</span><br><span class="line"><span class="keyword">from</span> Table_A e</span><br><span class="line"><span class="keyword">where</span> e.col_a <span class="operator">=</span> :col_a</span><br><span class="line">  <span class="keyword">and</span> e.col_b <span class="operator">&lt;=</span> :trade_date</span><br><span class="line">  <span class="keyword">and</span> e.col_b <span class="operator">&gt;</span> (:trade_date <span class="operator">-</span> <span class="number">31</span>)</span><br><span class="line">  <span class="keyword">and</span> e.col_j <span class="keyword">in</span> (<span class="number">1</span>,<span class="number">2</span>,<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>,<span class="number">7</span>,<span class="number">10</span>,<span class="number">11</span>,<span class="number">18</span>,<span class="number">37</span>)</span><br><span class="line">  <span class="keyword">and</span> <span class="keyword">not</span> <span class="keyword">exists</span> ( </span><br><span class="line">      <span class="keyword">select</span> <span class="comment">/*+ HASH_AJ*/</span> <span class="number">1</span></span><br><span class="line">      <span class="keyword">from</span> Table_B b</span><br><span class="line">      <span class="keyword">where</span> b.col_a <span class="operator">=</span> :col_a</span><br><span class="line">        <span class="keyword">and</span> e.col_c <span class="operator">=</span> b.col_c</span><br><span class="line">        <span class="keyword">and</span> e.col_b <span class="operator">=</span> b.col_b</span><br><span class="line">        <span class="keyword">and</span> b.trade_type <span class="keyword">in</span> (<span class="number">6</span>,<span class="number">7</span>))</span><br><span class="line"><span class="keyword">order</span> <span class="keyword">by</span> e.col_a, e.col_b, e.col_c, e.col_m, e.col_y</span><br></pre></td></tr></table></figure><hr><p>参考：</p><p>🔗 <a href="https://docs.oracle.com/cd/B19306_01/server.102/b14211/hintsref.htm#i17496">Using Optimizer Hints</a></p><p>🔗 <a href="https://www.oradev.com/hints.jsp">Hints for Oracle sql performance</a></p><p>🔗 <a href="https://www.cnblogs.com/sopost/archive/2010/10/11/2190076.html">ORACLE常用SQL优化hint语句</a></p><p>🔗 <a href="https://www.cnblogs.com/emilyyoucan/p/7844795.html">oracle中hint 详解</a></p><p>🔗 <a href="http://www.remote-dba.net/t_op_sql_join_hints.htm">Table Join Hints</a></p><p>🔗 <a href="http://www.remote-dba.net/t_op_sql_anti_join_hints.htm">Table Anti-Join Hints</a></p><p>🔗 <a href="https://blog.csdn.net/stevendbaguo/article/details/13775915">嵌套循环连接(nested loops join)原理</a></p>]]></content>
    
    
    <summary type="html">内容包括：等。</summary>
    
    
    
    <category term="技术文档" scheme="http://linyishui.top/categories/%E6%8A%80%E6%9C%AF%E6%96%87%E6%A1%A3/"/>
    
    
    <category term="oracle" scheme="http://linyishui.top/tags/oracle/"/>
    
  </entry>
  
  <entry>
    <title>MySql临时表</title>
    <link href="http://linyishui.top/2021082701.html"/>
    <id>http://linyishui.top/2021082701.html</id>
    <published>2021-08-27T03:19:24.000Z</published>
    <updated>2021-08-31T01:14:34.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="临时表"><a href="#临时表" class="headerlink" title="临时表"></a>临时表</h1><h2 id="一-简介"><a href="#一-简介" class="headerlink" title="一. 简介"></a>一. 简介</h2><p>非压缩的，用户创建的临时表和磁盘内部临时表共享一个存储空间，通过 <code>innodb_temp_data_file_path</code> 变量定义临时表空间数据文件的相对路径、名称、大小和属性。默认为 <code>innodb_data_home_dir</code> 目录下创建一个名为ibtmp1的自动扩展的数据文件，该文件略大于12MB。</p><p><strong>临时表空间会在正常关机或初始化中止时被移除，并在每次服务器启动时被重新创建。如果服务器意外停止，临时表空间不会被删除。在这种情况下，数据库管理员可以手动删除临时表空间，或者重新启动服务器，服务器会自动删除并重新创建临时表空间。</strong></p><p><em>（5.6版本，非压缩的临时表是在临时文件目录中的每个文件的表空间中创建的，在MySQL 5.7中引入的共享临时表空间消除了与为每个临时表创建和删除逐个文件表空间有关的性能成本）</em></p><p>在 MySQL 5.7 之前， SQL 运行中产生的临时表是 MYISAM，而且只能是 MYISAM。MySQL 从 5.7 开始提供了参数 <code>Internal_tmp_mem_storage_engine</code> 来定义内部的临时表引擎，可选值为 MYISAM 和 INNODB 。内部的临时表默认保存在临时表空间 ibtmp1 (可以用参数 <code>innodb_temp_data_file_path</code> 设置大小等)。需要注意控制 ibtmp1 的大小，防止把磁盘撑爆。</p><p>但是MySQL 5.7 之前都没有解决如下问题：</p><ul><li>VARCHAR的变长存储。如果临时表的字段定义是 <code>VARCHAR(200)</code> ，映射到内存里处理的字段变为<code>CHAR(200)</code> ，假设 <code>VARCHAR(200)</code> 只存一个字符会造成浪费。</li><li>大对象的默认磁盘存储，比如 TEXT，BLOB， JSON等，不管里面存放了什么，直接转化为磁盘存储。</li></ul><p>MySQL 8.0 开始，专门实现了一个临时表的引擎 TempTable , 解决了 VARCHAR 字段的边长存储以及大对象的内存存储。由变量 <code>interal_tmp_mem_storage_engine</code> 来控制，可选值为 <code>TempTable</code>（默认）和 <code>Memory</code> ；新引擎的大小由参数 <code>temp_table_max_ram</code> 来控制，默认为1G。超过了则存储在磁盘上（ibtmp1）。并且计数器由性能字典的表 <code>memory_summary_global_by_event_name</code> 来存储。</p><h2 id="二-查看当前临时表信息"><a href="#二-查看当前临时表信息" class="headerlink" title="二. 查看当前临时表信息"></a>二. 查看当前临时表信息</h2><p><code>INFORMATION_SCHEMA.FILES</code> 提供关于InnoDB临时表空间的元数据，这些临时表目前在InnoDB实例中是活跃的。</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> INFORMATION_SCHEMA.FILES <span class="keyword">WHERE</span> TABLESPACE_NAME<span class="operator">=</span><span class="string">&#x27;innodb_temporary&#x27;</span>;</span><br></pre></td></tr></table></figure><p>那么这两种临时表的计数器通常用 <code>show global status like &#39;%tmp_%tables%&#39;</code>  来查看。</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">show</span> <span class="keyword">global</span> status <span class="keyword">like</span> <span class="string">&#x27;%tmp_%tables%&#x27;</span>;</span><br><span class="line"></span><br><span class="line">mysql<span class="operator">&gt;</span> <span class="keyword">show</span> status <span class="keyword">like</span> <span class="string">&#x27;%tmp_%tables%&#x27;</span>;</span><br><span class="line"><span class="operator">+</span><span class="comment">-------------------------+-------+</span></span><br><span class="line"><span class="operator">|</span> Variable_name <span class="operator">|</span> <span class="keyword">Value</span> <span class="operator">|</span></span><br><span class="line"><span class="operator">+</span><span class="comment">-------------------------+-------+</span></span><br><span class="line"><span class="operator">|</span> Created_tmp_disk_tables <span class="operator">|</span> <span class="number">0</span>     <span class="operator">|</span></span><br><span class="line"><span class="operator">|</span> Created_tmp_tables      <span class="operator">|</span> <span class="number">0</span>     <span class="operator">|</span></span><br><span class="line"><span class="operator">+</span><span class="comment">-------------------------+-------+</span></span><br><span class="line"><span class="number">2</span> <span class="keyword">rows</span> <span class="keyword">in</span> <span class="keyword">set</span> (<span class="number">0.00</span> sec)</span><br></pre></td></tr></table></figure><p>以上结果分别代表，只创建磁盘上的临时表计数以及临时表的总计数。这两个计数器由参数 <code>tmp_table_size</code> 和 <code>max_heap_table_size</code> 两个取最小值来控制。</p><p><code>memory/ temptable/physical_disk</code> 代表放入磁盘上的临时表计数情况，<code>memory/temptable/physical_ram</code>  代表放入内存的临时表计数情况。</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">mysql<span class="operator">&gt;</span> <span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> performance_schema. memory_summary_global_by_event_name <span class="keyword">WHERE</span> event_name <span class="keyword">like</span> <span class="string">&#x27;%temptable%&#x27;</span>G</span><br><span class="line"><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span> <span class="number">1.</span> <span class="type">row</span> <span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span>                  EVENT_NAME: <span class="operator">*</span><span class="operator">*</span>memory<span class="operator">/</span>temptable<span class="operator">/</span>physical_disk<span class="operator">*</span><span class="operator">*</span>                 </span><br><span class="line">COUNT_ALLOC: <span class="number">0</span>                  </span><br><span class="line">COUNT_FREE: <span class="number">0</span>   </span><br><span class="line">SUM_NUMBER_OF_BYTES_ALLOC: <span class="number">0</span>    </span><br><span class="line">SUM_NUMBER_OF_BYTES_FREE: <span class="number">0</span>              </span><br><span class="line">LOW_COUNT_USED: <span class="number">0</span>          </span><br><span class="line">CURRENT_COUNT_USED: <span class="number">0</span>             </span><br><span class="line">HIGH_COUNT_USED: <span class="number">0</span>    </span><br><span class="line">LOW_NUMBER_OF_BYTES_USED: <span class="number">0</span></span><br><span class="line">CURRENT_NUMBER_OF_BYTES_USED: <span class="number">0</span>   </span><br><span class="line">HIGH_NUMBER_OF_BYTES_USED: <span class="number">0</span></span><br><span class="line"><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span> <span class="number">2.</span> <span class="type">row</span> <span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span>                  EVENT_NAME: <span class="operator">*</span><span class="operator">*</span>memory<span class="operator">/</span>temptable<span class="operator">/</span>physical_ram<span class="operator">*</span><span class="operator">*</span>                 </span><br><span class="line">COUNT_ALLOC: <span class="number">1</span>                  </span><br><span class="line">COUNT_FREE: <span class="number">0</span>   </span><br><span class="line">SUM_NUMBER_OF_BYTES_ALLOC: <span class="number">1048576</span>    </span><br><span class="line">SUM_NUMBER_OF_BYTES_FREE: <span class="number">0</span>              </span><br><span class="line">LOW_COUNT_USED: <span class="number">0</span>          </span><br><span class="line">CURRENT_COUNT_USED: <span class="number">1</span>             </span><br><span class="line">HIGH_COUNT_USED: <span class="number">1</span>    </span><br><span class="line">LOW_NUMBER_OF_BYTES_USED: <span class="number">0</span></span><br><span class="line">CURRENT_NUMBER_OF_BYTES_USED: <span class="number">1048576</span>   </span><br><span class="line">HIGH_NUMBER_OF_BYTES_USED: <span class="number">1048576</span></span><br><span class="line"><span class="number">2</span> <span class="keyword">rows</span> <span class="keyword">in</span> <span class="keyword">set</span> (<span class="number">0.03</span> sec)</span><br></pre></td></tr></table></figure><h2 id="三-临时表空间大小"><a href="#三-临时表空间大小" class="headerlink" title="三. 临时表空间大小"></a>三. 临时表空间大小</h2><p>默认情况下，临时表空间数据文件是自动扩展的，并根据需要增加大小以适应磁盘上的临时表。例如，如果一个操作创建了一个大小为20MB的临时表，临时表空间数据文件在创建时默认为12MB大小，它的大小会扩展以适应它。当临时表被丢弃时，释放的空间可以重新用于新的临时表，但是<strong>数据文件仍然是扩展的大小</strong>。</p><p>在使用大型临时表或广泛使用临时表的环境中，<strong>自动扩展的临时表空间数据文件可能变得很大</strong>。一个大的数据文件也可能来自使用临时表的长期运行的查询。</p><p>通过检查 <code>innodb_temp_data_file_path</code> 设置确认一个临时表空间数据文件是否是自动扩展的：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">mysql<span class="operator">&gt;</span> <span class="keyword">SELECT</span> @<span class="variable">@innodb</span>_temp_data_file_path;</span><br><span class="line"><span class="operator">+</span><span class="comment">------------------------------+</span></span><br><span class="line"><span class="operator">|</span> @<span class="variable">@innodb</span>_temp_data_file_path <span class="operator">|</span></span><br><span class="line"><span class="operator">+</span><span class="comment">------------------------------+</span></span><br><span class="line"><span class="operator">|</span> ibtmp1:<span class="number">12</span>M:autoextend        <span class="operator">|</span></span><br><span class="line"><span class="operator">+</span><span class="comment">------------------------------+</span></span><br></pre></td></tr></table></figure><p>检查临时表空间数据文件的大小：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> FILE_NAME, TABLESPACE_NAME, ENGINE, INITIAL_SIZE, TOTAL_EXTENTS<span class="operator">*</span>EXTENT_SIZE</span><br><span class="line">       <span class="keyword">AS</span> TotalSizeBytes, DATA_FREE, MAXIMUM_SIZE <span class="keyword">FROM</span> INFORMATION_SCHEMA.FILES</span><br><span class="line">       <span class="keyword">WHERE</span> TABLESPACE_NAME <span class="operator">=</span> <span class="string">&#x27;innodb_temporary&#x27;</span>\G</span><br><span class="line"><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span> <span class="number">1.</span> <span class="type">row</span> <span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span></span><br><span class="line">      FILE_NAME: .<span class="operator">/</span>ibtmp1</span><br><span class="line">TABLESPACE_NAME: innodb_temporary</span><br><span class="line">         ENGINE: InnoDB</span><br><span class="line">   INITIAL_SIZE: <span class="number">12582912</span></span><br><span class="line"> TotalSizeBytes: <span class="number">12582912</span></span><br><span class="line">      DATA_FREE: <span class="number">6291456</span></span><br><span class="line">   MAXIMUM_SIZE: <span class="keyword">NULL</span></span><br></pre></td></tr></table></figure><p><code>TotalSizeBytes</code> 表示临时表空间数据文件的当前大小。</p><p>临时表相关配置：</p><ul><li><code>tmp_table_size</code> ：指定系统创建的内存临时表最大大小； </li><li><code>max_heap_table_size</code> : 指定用户创建的内存表的最大大小；</li></ul><p>注意：最终的系统创建的内存临时表大小是取上述两个配置值的最小值。</p><h2 id="四-MySQL创建临时表的场景"><a href="#四-MySQL创建临时表的场景" class="headerlink" title="四. MySQL创建临时表的场景"></a>四. MySQL创建临时表的场景</h2><p>MySQL临时表分为<strong>内存临时表</strong>和<strong>磁盘临时表</strong>，其中内存临时表使用MySQL的MEMORY存储引擎，磁盘临时表使用MySQL的MyISAM存储引擎；</p><p>一般情况下，MySQL会先创建内存临时表，但内存临时表超过配置指定的值后，MySQL会将内存临时表导出到磁盘临时表；Linux平台上缺省是/tmp目录，/tmp目录小的系统需要注意。</p><h3 id="4-1-内存临时表"><a href="#4-1-内存临时表" class="headerlink" title="4.1 内存临时表"></a>4.1 内存临时表</h3><p><strong>MySQL在以下几种情况会创建临时表：</strong></p><ol><li>UNION查询；</li><li>用到TEMPTABLE算法或者是UNION查询中的视图；</li><li>ORDER BY和GROUP BY的子句不一样时， 例如：<code>ORDERY BY price GROUP BY name</code> ；</li><li>表连接中，ORDER BY的列不是驱动表中的。在JOIN查询中，ORDER BY或者GROUP BY使用了不是第一个表的列，例如：<code>SELECT * from TableA, TableB ORDER BY TableA.price GROUP by TableB.name</code> ；</li><li>ORDER BY中使用了DISTINCT关键字 <code>ORDERY BY DISTINCT(price)</code> ；</li><li>SQL中用到SQL_SMALL_RESULT选项时，SELECT语句中指定了SQL_SMALL_RESULT关键字，意思就是告诉MySQL结果会很小，请直接使用内存临时表，不需要使用索引排序 SQL_SMALL_RESULT必须和GROUP BY、DISTINCT或DISTINCTROW一起使用 一般情况下，我们没有必要使用这个选项，让MySQL服务器选择即可。</li><li>FROM中的子查询；</li><li>子查询或者semi-join时创建的表；</li></ol><p>EXPLAIN 查看执行计划结果的 Extra 列中，如果包含 <a href="http://imysql.com/2015/06/14/mysql-faq-what-important-information-in-explain.shtml">Using Temporary</a> 就表示会用到临时表。</p><p>当然了，如果临时表中需要存储的数据量超过了上限（ <a href="https://dev.mysql.com/doc/refman/5.6/en/server-system-variables.html#sysvar_tmp_table_size">tmp-table-size</a> 或 <a href="https://dev.mysql.com/doc/refman/5.6/en/server-system-variables.html#sysvar_max_heap_table_size">max-heap-table-size</a> 中取其大者），这时候就需要生成基于磁盘的临时表了。</p><h3 id="4-2-磁盘临时表"><a href="#4-2-磁盘临时表" class="headerlink" title="4.2 磁盘临时表"></a>4.2 磁盘临时表</h3><p><strong>在以下几种情况下，会创建磁盘临时表：</strong></p><ol><li>数据表中包含BLOB/TEXT列；</li><li>在 <code>GROUP BY</code> 或者 <code>DISTINCT</code> 的列中有超过512字符的字符类型列（或者超过 512字节的二进制类型列，在5.6.15之前只管是否超过512字节）；</li><li>在 <code>SELECT</code> 、<code>UNION</code> 、<code>UNION ALL</code> 查询中，SELECT子句存在最大长度超过512的列（对于字符串类型是512个字符，对于二进制类型则是512字节）；</li><li>执行 <code>SHOW COLUMNS</code> / <code>FIELDS</code> 、<code>DESCRIBE</code> 等SQL命令，因为它们的执行结果用到了BLOB列类型。</li></ol><p>从5.7.5开始，新增一个系统选项 <a href="https://dev.mysql.com/doc/refman/5.7/en/server-system-variables.html#sysvar_internal_tmp_disk_storage_engine">internal_tmp_disk_storage_engine</a> 可定义磁盘临时表的引擎类型为 InnoDB，而在这以前，只能使用MyISAM。而在5.6.3以后新增的系统选项 <a href="https://dev.mysql.com/doc/refman/5.6/en/server-system-variables.html#sysvar_default_tmp_storage_engine">default_tmp_storage_engine</a> 是控制 <code>CREATE TEMPORARY TABLE</code> 创建的临时表的引擎类型，在以前默认是MEMORY，不要把这二者混淆了。</p><p>见下例：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">mysql<span class="operator">&gt;</span> <span class="keyword">set</span> default_tmp_storage_engine <span class="operator">=</span> &quot;InnoDB&quot;;</span><br><span class="line"><span class="operator">-</span>rw<span class="operator">-</span>rw<span class="comment">----   1 mysql mysql  8558 Jul  7 15:22 #sql4b0e_10_0.frm -- InnoDB引擎的临时表</span></span><br><span class="line"><span class="operator">-</span>rw<span class="operator">-</span>rw<span class="comment">----   1 mysql mysql 98304 Jul  7 15:22 #sql4b0e_10_0.ibd</span></span><br><span class="line"><span class="operator">-</span>rw<span class="operator">-</span>rw<span class="comment">----   1 mysql mysql  8558 Jul  7 15:25 #sql4b0e_10_2.frm</span></span><br><span class="line"></span><br><span class="line">mysql<span class="operator">&gt;</span> <span class="keyword">set</span> default_tmp_storage_engine <span class="operator">=</span> &quot;MyISAM&quot;;</span><br><span class="line"><span class="operator">-</span>rw<span class="operator">-</span>rw<span class="comment">----   1 mysql mysql     0 Jul  7 15:25 #sql4b0e_10_2.MYD -- MyISAM引擎的临时表</span></span><br><span class="line"><span class="operator">-</span>rw<span class="operator">-</span>rw<span class="comment">----   1 mysql mysql  1024 Jul  7 15:25 #sql4b0e_10_2.MYI</span></span><br><span class="line"></span><br><span class="line">mysql<span class="operator">&gt;</span> <span class="keyword">set</span> default_tmp_storage_engine <span class="operator">=</span> &quot;MEMORY&quot;;</span><br><span class="line"><span class="operator">-</span>rw<span class="operator">-</span>rw<span class="comment">----   1 mysql mysql  8558 Jul  7 15:26 #sql4b0e_10_3.frm -- MEMORY引擎的临时表</span></span><br></pre></td></tr></table></figure><p>用户自定义的临时表，比如：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">create</span> temporary <span class="keyword">table</span> (id <span class="type">int</span>, str1 <span class="type">varchar</span>(<span class="number">100</span>));</span><br></pre></td></tr></table></figure><p>SQL执行过程中产生的内部临时表，比如：<code>UNION</code>  , 聚合类 <code>ORDER BY</code> ，派生表，大对象字段的查询，子查询或者半连接的固化等场景。</p><h2 id="五-临时表优化"><a href="#五-临时表优化" class="headerlink" title="五. 临时表优化"></a>五. 临时表优化</h2><p><strong>表的设计原则：</strong>使用临时表一般都意味着性能比较低，特别是使用磁盘临时表，性能更慢，因此我们在实际应用中应该尽量避免临时表的使用。 常见的避免临时表的方法有：</p><ol><li>创建索引：在ORDER BY或者GROUP BY的列上创建索引；</li><li>分拆很长的列：一般情况下，TEXT、BLOB，大于512字节的字符串，基本上都是为了显示信息，而不会用于查询条件， 因此表设计的时候，应该将这些列独立到另外一张表。</li></ol><p><strong>SQL优化：</strong>如果表的设计已经确定，修改比较困难，那么也可以通过优化SQL语句来减少临时表的大小，以提升SQL执行效率。</p><p><strong>常见的优化SQL语句方法如下：</strong></p><ol><li>拆分SQL语句：临时表主要是用于排序和分组，很多业务都是要求排序后再取出详细的分页数据，这种情况下可以将排序和取出详细数据拆分成不同的SQL，以降低排序或分组时临时表的大小，提升排序和分组的效率，我们的案例就是采用这种方法。</li><li>优化业务，去掉排序分组等操作：有时候业务其实并不需要排序或分组，仅仅是为了好看或者阅读方便而进行了排序，例如数据导出、数据查询等操作，这种情况下去掉排序和分组对业务也没有多大影响。</li></ol><p>如何判断使用了临时表？使用 <code>explain</code> 查看执行计划，Extra列看到 <code>Using temporary</code> 就意味着使用了临时表。</p><p>案例：</p><ol><li><p>【问题描述】：定位到一个慢查询，查询时服务器IO飙升，IO占用率达到100%， 执行时间长达7s左右。</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> <span class="keyword">DISTINCT</span> g.<span class="operator">*</span>, cp.name <span class="keyword">AS</span> cp_name, c.name <span class="keyword">AS</span> category_name, t.name <span class="keyword">AS</span> type_name </span><br><span class="line"><span class="keyword">FROM</span> gm_game g </span><br><span class="line"><span class="keyword">LEFT</span> <span class="keyword">JOIN</span> gm_cp cp </span><br><span class="line"><span class="keyword">ON</span> cp.id <span class="operator">=</span> g.cp_id <span class="keyword">AND</span> cp.deleted <span class="operator">=</span> <span class="number">0</span> </span><br><span class="line"><span class="keyword">LEFT</span> <span class="keyword">JOIN</span> gm_category c </span><br><span class="line"><span class="keyword">ON</span> c.id <span class="operator">=</span> g.category_id <span class="keyword">AND</span> c.deleted <span class="operator">=</span> <span class="number">0</span> </span><br><span class="line"><span class="keyword">LEFT</span> <span class="keyword">JOIN</span> gm_type t </span><br><span class="line"><span class="keyword">ON</span> t.id <span class="operator">=</span> g.type_id <span class="keyword">AND</span> t.deleted <span class="operator">=</span> <span class="number">0</span> </span><br><span class="line"><span class="keyword">WHERE</span> g.deleted <span class="operator">=</span> <span class="number">0</span> </span><br><span class="line"><span class="keyword">ORDER</span> <span class="keyword">BY</span> g.modify_time <span class="keyword">DESC</span> LIMIT <span class="number">20</span>;</span><br></pre></td></tr></table></figure></li><li><p>【问题分析】：使用explain查看执行计划，结果：<code>Using temporary</code> 和 <code>Using filesort</code> 。这条sql语句的问题其实还是比较明显的：查询了大量数据(包括数据条数、以及g.* )，然后使用临时表order by，但最终又只返回了20条数据。观察到的IO高，是因为sql语句生成了一个巨大的临时表，内存放不下，于是全部拷贝到磁盘，导致IO飙升。</p></li><li><p>【优化方案】：优化的总体思路是拆分sql，将排序操作和查询所有信息的操作分开。</p><ol><li><p>第一条语句：查询符合条件的数据，只需要查询g.id即可：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> <span class="keyword">DISTINCT</span> g.id </span><br><span class="line"><span class="keyword">FROM</span> gm_game g </span><br><span class="line"><span class="keyword">LEFT</span> <span class="keyword">JOIN</span> gm_cp cp <span class="keyword">ON</span> cp.id <span class="operator">=</span> g.cp_id <span class="keyword">AND</span> cp.deleted <span class="operator">=</span> <span class="number">0</span> </span><br><span class="line"><span class="keyword">LEFT</span> <span class="keyword">JOIN</span> gm_category c <span class="keyword">ON</span> c.id <span class="operator">=</span> g.category_id <span class="keyword">AND</span> c.deleted <span class="operator">=</span> <span class="number">0</span> </span><br><span class="line"><span class="keyword">LEFT</span> <span class="keyword">JOIN</span> gm_type t <span class="keyword">ON</span> t.id <span class="operator">=</span> g.type_id <span class="keyword">AND</span> t.deleted <span class="operator">=</span> <span class="number">0</span> </span><br><span class="line"><span class="keyword">WHERE</span> g.deleted <span class="operator">=</span> <span class="number">0</span> </span><br><span class="line"><span class="keyword">ORDER</span> <span class="keyword">BY</span> g.modify_time <span class="keyword">DESC</span> LIMIT <span class="number">20</span> ;</span><br></pre></td></tr></table></figure></li><li><p>第二条语句：查询符合条件的详细数据，将第一条sql的结果使用in操作拼接到第二条的sql：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> <span class="keyword">DISTINCT</span> g.<span class="operator">*</span>, cp.name <span class="keyword">AS</span> cp_name,c.name <span class="keyword">AS</span> category_name,t.name <span class="keyword">AS</span> type_name </span><br><span class="line"><span class="keyword">FROM</span> gm_game g </span><br><span class="line"><span class="keyword">LEFT</span> <span class="keyword">JOIN</span> gm_cp cp <span class="keyword">ON</span> cp.id <span class="operator">=</span> g.cp_id <span class="keyword">AND</span> cp.deleted <span class="operator">=</span> <span class="number">0</span> </span><br><span class="line"><span class="keyword">LEFT</span> <span class="keyword">JOIN</span> gm_category c <span class="keyword">ON</span> c.id <span class="operator">=</span> g.category_id <span class="keyword">AND</span> c.deleted <span class="operator">=</span> <span class="number">0</span> </span><br><span class="line"><span class="keyword">LEFT</span> <span class="keyword">JOIN</span> gm_type t <span class="keyword">ON</span> t.id <span class="operator">=</span> g.type_id <span class="keyword">AND</span> t.deleted <span class="operator">=</span> <span class="number">0</span> </span><br><span class="line"><span class="keyword">WHERE</span> g.deleted <span class="operator">=</span> <span class="number">0</span> <span class="keyword">and</span> g.id <span class="keyword">in</span>(…………………) </span><br><span class="line"><span class="keyword">ORDER</span> <span class="keyword">BY</span> g.modify_time <span class="keyword">DESC</span> ;</span><br></pre></td></tr></table></figure></li></ol></li><li><p>【实测效果】：在SATA机器上测试，优化前大约需要50s，优化后第一条0.3s，第二条0.1s，优化后执行速度是原来的100倍以上，IO从100%降到不到1%；在SSD机器上测试，优化前大约需要7s，优化后第一条0.3s，第二条0.1s，优化后执行速度是原来的10倍以上，IO从100%降到不到1%。可以看出，优化前磁盘io是性能瓶颈，SSD的速度要比SATA明显要快，优化后磁盘不再是瓶颈，SSD和SATA性能没有差别。</p></li><li><p>【理论分析】：MySQL在执行SQL查询时可能会用到临时表，一般情况下，用到临时表就意味着性能较低。</p></li></ol><h2 id="六-扩展"><a href="#六-扩展" class="headerlink" title="六. 扩展"></a>六. 扩展</h2><h3 id="6-1-INFORMATION-SCHEMA-FILES-介绍"><a href="#6-1-INFORMATION-SCHEMA-FILES-介绍" class="headerlink" title="6.1 INFORMATION_SCHEMA.FILES 介绍"></a>6.1 INFORMATION_SCHEMA.FILES 介绍</h3><p>表结构:</p><ul><li><p><code>FILE_ID</code> ：</p><ul><li>For <code>InnoDB</code> ：表空间ID，也被称为 <code>space_id</code> 或 <code>fil_space_t::id</code> 。</li><li>For <code>NDB</code> ：一个文件标识符。<code>FILE_ID</code> 列的值是自动生成的。</li></ul></li><li><p><code>FILE_NAME</code> ：</p><ul><li>For <code>InnoDB</code> ：数据文件的名称。<ul><li>表空间包含单个InnoDB表的数据和索引（File-per-table）和一般表空间的文件名扩展名为 <code>.ibd</code> 。</li><li>Undo 表空间的前缀是 <code>undo</code> 。 </li><li>系统表空间的前缀是 <code>ibdata</code> 。 </li><li>临时表空间的前缀是 <code>ibtmp</code> 。 </li><li>文件名包括文件路径，可以是相对于MySQL数据目录 （the value of the <code>datadir</code> system variable）。</li></ul></li><li>For <code>NDB</code> ：由 <code>CREATE LOGFILE GROUP</code> 或 <code>ALTER LOGFILE GROUP</code> 创建的 <code>UNDO</code> 日志文件名； 或由 <code>CREATE TABLESPACE</code> 或 <code>ALTER TABLESPACE</code> 创建的数据文件名。</li></ul></li><li><p><code>FILE_TYPE</code> ：</p><ul><li><p>For <code>InnoDB</code> ：表空间文件的类型。<code>InnoDB</code> 文件有三种可能的文件类型：</p><ul><li><p><code>TABLESPACE</code> 是任何系统的、一般的、或 <code>file-per-table</code> 文件的表空间文件的文件类型，它持有表、索引、或其他形式的用户数据。</p></li><li><p><code>TEMPORARY</code> 是临时表空间的文件类型。</p></li><li><p><code>UNDO LOG</code> 是UNDO表空间的文件类型，用于保存撤销记录。</p></li></ul></li><li><p>For <code>NDB</code> ： <code>UNDO LOG</code> 、<code>DATAFILE</code> 或 <code>TABLESPACE</code> 中的一个。</p></li></ul></li><li><p><code>TABLESPACE_NAME</code> ：与该文件相关的表空间的名称。</p></li><li><p><code>TABLE_CATALOG</code> ：这个值总是空的。</p></li><li><p><code>TABLE_SCHEMA</code> ：这个值总是 <code>NULL</code> 。</p></li><li><p><code>TABLE_NAME</code> ：这个值总是 <code>NULL</code> 。</p></li><li><p><code>LOGFILE_GROUP_NAME</code> ：</p><ul><li>For <code>InnoDB</code> ：这个值总是 <code>NULL</code> 。</li><li>For <code>NDB</code> ：日志文件或数据文件所属的日志文件组的名称。</li></ul></li><li><p><code>LOGFILE_GROUP_NUMBER</code> ：</p><ul><li><p>For <code>InnoDB</code> ：这个值总是 <code>NULL</code> 。</p></li><li><p>For <code>NDB</code> ：对于磁盘数据UNDO日志文件，自动生成的日志文件组的ID号码，该日志文件属于该组。这与 <code>ndbinfo.dict_obj_info</code>表中的 <code>id</code> 列以及 <code>ndbinfo.logspaces</code> 和 <code>ndbinfo.logspaces</code> 表中的 <code>log_id</code> 列所显示的该UNDO日志文件的值相同。</p></li></ul></li><li><p><code>ENGINE</code> ：</p><ul><li>For <code>InnoDB</code> ：这个值总是 <code>InnoDB</code> 。</li><li>For <code>NDB</code> ：这个值总是 <code>ndbcluster</code> 。</li></ul></li><li><p><code>FULLTEXT_KEYS</code> ：这个值总是 <code>NULL</code> 。</p></li><li><p><code>DELETED_ROWS</code> ：这个值总是 <code>NULL</code> 。</p></li><li><p><code>UPDATE_COUNT</code> ：这个值总是 <code>NULL</code> 。</p></li><li><p><code>FREE_EXTENTS</code> ：</p><ul><li>For <code>InnoDB</code> ：当前数据文件中完全空闲的扩展数。</li><li>For <code>NDB</code> ：文件尚未使用的extents的数量。</li></ul></li><li><p><code>TOTAL_EXTENTS</code> ：</p><ul><li>For <code>InnoDB</code> ：在当前数据文件中使用的完整扩展的数量。文件末尾的任何部分范围都不计算在内。</li><li>For <code>NDB</code> ：分配给文件的总扩展数。</li></ul></li><li><p><code>EXTENT_SIZE</code> ：</p><ul><li><p>For <code>InnoDB</code> ：</p><ul><li>对于页面大小为4KB、8KB或16KB的文件，其Extent大小为1048576（1MB）。</li><li>对于页面大小为32KB的文件，Extent大小为2097152字节（2MB）。</li><li>对于页面大小为64KB的文件，Extent大小为4194304字节（4MB）。</li></ul><p><code>FILES</code> 不包括 <code>InnoDB</code> 的页面大小。页面大小是由 <code>innodb_page_size</code> 系统变量统计。也可以从 <code>INNODB_SYS_TABLESPACES</code> 表中检索Extent的大小信息，其中 <code>FILES.FILE_ID = INNODB_SYS_TABLESPACES.SPACE</code> 。</p></li><li><p>For <code>NDB</code> ：文件的范围大小，以字节为单位。</p></li></ul></li><li><p><code>INITIAL_SIZE</code> ：</p><ul><li>For <code>InnoDB</code> ：文件的初始大小，以字节为单位。</li><li>For <code>NDB</code> ：文件的大小，单位是字节。用于创建文件的 <code>CREATE LOGFILE GROUP</code> 、<code>ALTER LOGFILE GROUP</code> 、<code>CREATE TABLESPACE</code> 或 <code>ALTER TABLESPACE</code> 语句的 <code>INITIAL_SIZE</code> 子句中使用的值相同。</li></ul></li><li><p><code>MAXIMUM_SIZE</code> ：</p><ul><li><p>For <code>InnoDB</code> ：文件中允许的最大字节数。除了预定义的系统表空间数据文件，所有数据文件的值都是<code>NULL</code> 。</p><ul><li>最大的系统表空间文件大小是由 <code>innodb_data_file_path</code> 定义的。</li><li>最大的临时表空间文件大小是由 <code>innodb_temp_data_file_path</code> 定义的。</li><li>一个预定义的系统表空间数据文件的 <code>NULL</code> 值表示没有明确定义文件的大小限制。</li></ul></li><li><p>For <code>NDB</code> ：这个值总是与 <code>INITIAL_SIZE</code> 值相同。</p></li></ul></li><li><p><code>AUTOEXTEND_SIZE</code> ：表空间的自动扩展大小。对于<code>NDB</code>，<code>AUTOEXTEND_SIZE</code> 总是 <code>NULL</code> 。</p></li><li><p><code>CREATION_TIME</code> ：这个值总是 <code>NULL</code> 。</p></li><li><p><code>LAST_UPDATE_TIME</code> ：这个值总是 <code>NULL</code> 。</p></li><li><p><code>LAST_ACCESS_TIME</code> ：这个值总是 <code>NULL</code> 。</p></li><li><p><code>RECOVER_TIME</code> ：这个值总是 <code>NULL</code> 。</p></li><li><p><code>TRANSACTION_COUNTER</code> ：这个值总是 <code>NULL</code> 。</p></li><li><p><code>VERSION</code> ：</p><ul><li><p>For <code>InnoDB</code> ：这个值总是 <code>NULL</code> 。</p></li><li><p>For <code>NDB</code> ：文件的版本号。</p></li></ul></li><li><p><code>ROW_FORMAT</code></p><ul><li><p>For <code>InnoDB</code> ：这个值总是 <code>NULL</code> 。</p></li><li><p>For <code>NDB</code> ：<code>FIXED</code> 或 <code>DYNAMIC</code> 其中一个。</p></li></ul></li><li><p><code>TABLE_ROWS</code> ：这个值总是 <code>NULL</code> 。</p></li><li><p><code>AVG_ROW_LENGTH</code> ：这个值总是 <code>NULL</code> 。</p></li><li><p><code>DATA_LENGTH</code> ：这个值总是 <code>NULL</code> 。</p></li><li><p><code>MAX_DATA_LENGTH</code> ：这个值总是 <code>NULL</code> 。</p></li><li><p><code>INDEX_LENGTH</code> ：这个值总是 <code>NULL</code> 。</p></li><li><p><code>DATA_FREE</code> ：</p><ul><li><p>For <code>InnoDB</code> ：整个表空间的空闲空间总量（以字节为单位）。预定义的系统表空间，包括系统表空间和临时表空间，可以有一个或多个数据文件。</p></li><li><p>For <code>NDB</code> ：这个值总是 <code>NULL</code> 。</p></li></ul></li><li><p><code>CREATE_TIME</code> ：这个值总是 <code>NULL</code> 。</p></li><li><p><code>UPDATE_TIME</code> ：这个值总是 <code>NULL</code> 。</p></li><li><p><code>CHECK_TIME</code> ：这个值总是 <code>NULL</code> 。</p></li><li><p><code>CHECKSUM</code> ：这个值总是 <code>NULL</code> 。</p></li><li><p><code>STATUS</code> ：</p><ul><li><p>For <code>InnoDB</code> ：这个值默认为 <code>NORMAL</code> 。<code>InnoDB</code> 的 <code>file-per-table</code> 表空间可能为 <code>IMPORTING</code> ，这表明表空间尚未可用。</p></li><li><p>For <code>NDB</code> ：这个值总是 <code>NORMAL</code> 。</p></li></ul></li><li><p><code>EXTRA</code> ：</p><ul><li><p>For <code>InnoDB</code> ：这个值总是 <code>NULL</code> 。</p></li><li><p>For <code>NDB</code>：这一列显示了数据文件或 undo 日志文件属于哪个数据节点（每个数据节点都有每个文件的副本）； 对于 undo 日志文件，它还显示了撤销日志缓冲区的大小。假设你在一个有四个数据节点的NDB集群上使用这个语句：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> LOGFILE <span class="keyword">GROUP</span> mygroup</span><br><span class="line">    <span class="keyword">ADD</span> UNDOFILE <span class="string">&#x27;new_undo.dat&#x27;</span></span><br><span class="line">    INITIAL_SIZE <span class="number">2</span>G</span><br><span class="line">    ENGINE NDB;</span><br></pre></td></tr></table></figure><p>在成功运行 <code>CREATE LOGFILE GROUP</code> 语句后，你应该看到一个类似于，这里显示为针对 <code>FILES</code> 表的查询结果：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">mysql<span class="operator">&gt;</span> <span class="keyword">SELECT</span> LOGFILE_GROUP_NAME, FILE_TYPE, EXTRA</span><br><span class="line">         <span class="keyword">FROM</span> INFORMATION_SCHEMA.FILES</span><br><span class="line">         <span class="keyword">WHERE</span> FILE_NAME <span class="operator">=</span> <span class="string">&#x27;new_undo.dat&#x27;</span>;</span><br><span class="line"></span><br><span class="line"><span class="operator">+</span><span class="comment">--------------------+-----------+-----------------------------------------+</span></span><br><span class="line"><span class="operator">|</span> LOGFILE_GROUP_NAME <span class="operator">|</span> FILE_TYPE <span class="operator">|</span> EXTRA                                   <span class="operator">|</span></span><br><span class="line"><span class="operator">+</span><span class="comment">--------------------+-----------+-----------------------------------------+</span></span><br><span class="line"><span class="operator">|</span> mygroup            <span class="operator">|</span> UNDO LOG  <span class="operator">|</span> CLUSTER_NODE<span class="operator">=</span><span class="number">5</span>;UNDO_BUFFER_SIZE<span class="operator">=</span><span class="number">8388608</span> <span class="operator">|</span></span><br><span class="line"><span class="operator">|</span> mygroup            <span class="operator">|</span> UNDO LOG  <span class="operator">|</span> CLUSTER_NODE<span class="operator">=</span><span class="number">6</span>;UNDO_BUFFER_SIZE<span class="operator">=</span><span class="number">8388608</span> <span class="operator">|</span></span><br><span class="line"><span class="operator">|</span> mygroup            <span class="operator">|</span> UNDO LOG  <span class="operator">|</span> CLUSTER_NODE<span class="operator">=</span><span class="number">7</span>;UNDO_BUFFER_SIZE<span class="operator">=</span><span class="number">8388608</span> <span class="operator">|</span></span><br><span class="line"><span class="operator">|</span> mygroup            <span class="operator">|</span> UNDO LOG  <span class="operator">|</span> CLUSTER_NODE<span class="operator">=</span><span class="number">8</span>;UNDO_BUFFER_SIZE<span class="operator">=</span><span class="number">8388608</span> <span class="operator">|</span></span><br><span class="line"><span class="operator">+</span><span class="comment">--------------------+-----------+-----------------------------------------+</span></span><br></pre></td></tr></table></figure></li></ul></li></ul><p><code>FILES</code> 是一个非标准的 <code>INFORMATION_SCHEMA</code> 表。</p><h4 id=""><a href="#" class="headerlink" title=""></a></h4><p>适用于 <code>InnoDB</code> 数据文件的注意事项：</p><ul><li><p><code>FILES</code> 报告的数据来自于 <code>InnoDB</code> 的内存缓存中的开放文件。相比之下， <code>INNODB_SYS_DATAFILES</code> 报告的数据来自 <code>InnoDB</code> <code>SYS_DATAFILES</code> 内部数据字典表。</p></li><li><p><code>FILES</code>报告的数据包括临时表空间数据。这些数据在 <code>InnoDB</code> 的 <code>SYS_DATAFILES</code> 内部数据字典表中是不可用的，因此  <code>INNODB_SYS_DATAFILES</code> 不会报告。</p></li><li><p>Undo 的表空间数据由 <code>FILES</code> 报告。</p></li><li><p>下面的查询返回所有与 <code>InnoDB</code> 表空间有关的数据：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span></span><br><span class="line">  FILE_ID, FILE_NAME, FILE_TYPE, TABLESPACE_NAME, FREE_EXTENTS,</span><br><span class="line">  TOTAL_EXTENTS, EXTENT_SIZE, INITIAL_SIZE, MAXIMUM_SIZE,</span><br><span class="line">  AUTOEXTEND_SIZE, DATA_FREE, STATUS</span><br><span class="line"><span class="keyword">FROM</span> INFORMATION_SCHEMA.FILES <span class="keyword">WHERE</span> ENGINE<span class="operator">=</span><span class="string">&#x27;InnoDB&#x27;</span>\G</span><br></pre></td></tr></table></figure></li></ul><hr><p>参考：</p><p>🔗 <a href="https://dev.mysql.com/doc/refman/5.7/en/innodb-temporary-tablespace.html">MySQL :: MySQL 5.7 Reference Manual :: 14.6.3.5 The Temporary Tablespace</a></p><p>🔗 <a href="https://dev.mysql.com/doc/refman/5.7/en/information-schema-files-table.html">MySQL :: MySQL 5.7 Reference Manual :: 24.3.9 The INFORMATION_SCHEMA FILES Table</a></p><p>🔗 <a href="https://programmer.help/blogs/from-mysql-s-ibtmp1-file-is-too-big.html">From MYSQL’s ibtmp1 file is too big (programmer.help)</a></p><p>🔗 <a href="https://blog.csdn.net/yunhua_lee/article/details/12064477">优化临时表使用</a></p>]]></content>
    
    
    <summary type="html">内容包括：临时表简介，查看数据库临时表信息，临时表空间大小，创建临时表的场景，临时表优化，扩展等。</summary>
    
    
    
    <category term="技术文档" scheme="http://linyishui.top/categories/%E6%8A%80%E6%9C%AF%E6%96%87%E6%A1%A3/"/>
    
    
    <category term="mysql" scheme="http://linyishui.top/tags/mysql/"/>
    
  </entry>
  
  <entry>
    <title>Bean验证——Hibernate Validator</title>
    <link href="http://linyishui.top/2021072201.html"/>
    <id>http://linyishui.top/2021072201.html</id>
    <published>2021-07-22T08:11:09.000Z</published>
    <updated>2021-07-28T10:42:48.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Hibernate-Validator"><a href="#Hibernate-Validator" class="headerlink" title="Hibernate Validator"></a>Hibernate Validator</h1><h2 id="一-Bean验证"><a href="#一-Bean验证" class="headerlink" title="一. Bean验证"></a>一. Bean验证</h2><h3 id="1-1-什么是Bean验证"><a href="#1-1-什么是Bean验证" class="headerlink" title="1.1 什么是Bean验证"></a>1.1 什么是Bean验证</h3><p>常见的业务校验场景：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (employee.getFirstName() == <span class="keyword">null</span> || employee.getFirstName().trim().length() == <span class="number">0</span>)</span><br><span class="line">       <span class="keyword">throw</span> <span class="keyword">new</span> ValidationException(<span class="string">&quot;validate.employee.firstName&quot;</span>);</span><br><span class="line">   ...</span><br></pre></td></tr></table></figure><p>当业务规则复杂时，类似的条件判断需要很多才能实现。</p><p>Bean验证是一个Java EE的API，用来自动验证在Java bean上声明的业务逻辑。其包含一个元数据模型（一个注解的集合），其中为指定的类声明了业务规则和一个使用验证工具的API。</p><p>通过为字段、方法等添加注解的方式，指定如何在被标注的目标上使用特定的约束。</p><h3 id="1-2-为什么选用Hibernate-Validator"><a href="#1-2-为什么选用Hibernate-Validator" class="headerlink" title="1.2 为什么选用Hibernate Validator"></a>1.2 为什么选用Hibernate Validator</h3><p>Hibernate Validator 5.0 是 JSR 349的参考实现，它兼容于此规范，是Bean验证实现中应用最广泛的。</p><p>Spring Framework自动为使用 Java Bean 验证的、由Spring管理的bean创建代理。它将拦截对添加了注解的方法的调用并进行适当的验证，检查使用者是否提供了有效的参数或该实现的返回值是否有效（常用注解 <code>@javax.validation.Valid</code> ）。</p><h2 id="二-在Spring-Framework容器中配置验证"><a href="#二-在Spring-Framework容器中配置验证" class="headerlink" title="二. 在Spring Framework容器中配置验证"></a>二. 在Spring Framework容器中配置验证</h2><p>手动验证：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">ValidatorFactory factory = Validation.buildDefaultValidatorFactory();</span><br><span class="line">Validator validator = factory.getValidator();</span><br><span class="line">Set&lt;ConstraintViolation&lt;Employee&gt; violations = validator.validate(employee);</span><br><span class="line"><span class="keyword">if</span> (violations.size() &gt; <span class="number">0</span>)</span><br><span class="line">       <span class="keyword">throw</span> <span class="keyword">new</span> ConstraintViolationException(violations);</span><br></pre></td></tr></table></figure><p>配置Spring Framework开启自动验证，使用依赖注入和代理支持，完成4个配置：</p><ul><li>验证器</li><li>验证器消息的本地化</li><li>方法验证处理器</li><li>Spring MVC表单验证</li></ul><p>Spring Framework在Bean Validation出现之前就提供了 <code>org.springframework.validation.Validator</code> 接口支持对象自动验证，通过注解约束指定验证对象的工具。</p><p>验证错误会使用 <code>org.springframework.validation.Errors</code> 接口，而不是返回一个 <code>Set&lt;javax.validation.ObjectError&gt;</code> 。该接口提供了对一个或多个 <code>ObjectError</code> 和 <code>FieldError</code> 的访问。</p><p>配置Spring Framework的验证时，需要同时实现Validator和Spring Validator，即继承了 <code>org.springframework.validation.beanvalidation.SpringValidatorAdapter</code> 的类，可选：</p><ul><li><code>javax.validation.beanvalidation.CustomValidatorBean</code> </li><li><code>javax.validation.beanvalidation.LocalValidatorFactoryBean</code> ：支持获取底层的Validator，且支持使用应用程序的其他代码用于国际化的相同MessageSource和资源包文件。</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// LocalValidatorFactoryBean将自动检测到类路径上的Bean Validation实现，使用ValidatorFactory作为支持工厂，如果有多个实现类则会随机挑选。</span></span><br><span class="line"><span class="meta">@Bean</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> LocalValidatorFactoryBean <span class="title">localValidatorFactoryBean</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 最简单的返回</span></span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> LocalValidatorFactoryBean();</span><br><span class="line">    <span class="comment">// 动态加载的写法</span></span><br><span class="line">    LocalValidatorFactoryBean validator = <span class="keyword">new</span> LocalValidatorFactoryBean();</span><br><span class="line">    validator.setProvider(Class.forName(<span class="string">&quot;org.hibernate.validator.HibernateValidator&quot;</span>));</span><br><span class="line">    <span class="keyword">return</span> validator;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>通过LocalValidatorFactoryBean设置有效的MessageSource，自动提供一个由MessageSource作为支持的插值器。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 指定错误代码和错误消息</span></span><br><span class="line"><span class="meta">@Bean</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> MessageSource <span class="title">messageSource</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    ReloadableResourceBundleMessageSource messageSource = <span class="keyword">new</span> ReloadableResourceBundleMessageSource();</span><br><span class="line">    messageSource.setCacheSeconds(-<span class="number">1</span>);</span><br><span class="line">    messageSource.setDefaultEncoding(StandardCharsets.UTF_8.name());</span><br><span class="line">    messageSource.setBasenames(<span class="string">&quot;/WEB-INF/il8n/titles&quot;</span>, <span class="string">&quot;/WEB-INF/il8n/messages&quot;</span>, <span class="string">&quot;/WEB-INF/il8n/errors&quot;</span>, <span class="string">&quot;/WEB-INF/il8n/validation&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span> messageSource;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Bean</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> LocalValidatorFactoryBean <span class="title">localValidatorFactoryBean</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    LocalValidatorFactoryBean validator = <span class="keyword">new</span> LocalValidatorFactoryBean();</span><br><span class="line">    validator.setValidationMessageSource(<span class="keyword">this</span>.messageSource());</span><br><span class="line">    <span class="keyword">return</span> validator;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>使用方法验证Bean后处理器，可以在容器完成启动过程之前配置、自定义和替换配置中的bean。</p><h2 id="三-为bean添加约束验证注解"><a href="#三-为bean添加约束验证注解" class="headerlink" title="三. 为bean添加约束验证注解"></a>三. 为bean添加约束验证注解</h2><h2 id="四-为方法验证配置Spring-bean"><a href="#四-为方法验证配置Spring-bean" class="headerlink" title="四. 为方法验证配置Spring bean"></a>四. 为方法验证配置Spring bean</h2><h2 id="五-编写自定义验证约束"><a href="#五-编写自定义验证约束" class="headerlink" title="五. 编写自定义验证约束"></a>五. 编写自定义验证约束</h2><h2 id="六-在客户支持应用程序中集成验证"><a href="#六-在客户支持应用程序中集成验证" class="headerlink" title="六. 在客户支持应用程序中集成验证"></a>六. 在客户支持应用程序中集成验证</h2><h2 id="七-使用"><a href="#七-使用" class="headerlink" title="七. 使用"></a>七. 使用</h2><h3 id="7-1-使用Hibernate-Validate"><a href="#7-1-使用Hibernate-Validate" class="headerlink" title="7.1 使用Hibernate Validate"></a>7.1 使用Hibernate Validate</h3><p><strong>引入依赖</strong>：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.hibernate<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>hibernate-validator<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>4.3.1.Final<span class="tag">&lt;/<span class="name">version</span>&gt;</span> </span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure><p><strong>常用注解说明</strong>：</p><table><thead><tr><th>注解</th><th>说明</th></tr></thead><tbody><tr><td>@Length(min=,max=)</td><td>检查所属的字段的长度是否在min和max之间，只能用于字符串</td></tr><tr><td>@Range(min=,max=,message=)</td><td>被注释的元素必须在合适的范围内</td></tr><tr><td>@Max</td><td>该字段的值只能小于或等于该值</td></tr><tr><td>@Min</td><td>该字段的值只能大于或等于该值</td></tr><tr><td>@NotNull</td><td>不能为null</td></tr><tr><td>@NotBlank</td><td>不能为空，检查时会将空格忽略</td></tr><tr><td>@NotEmpty</td><td>不能为空，这里的空是指空字符串</td></tr><tr><td>@Pattern(regex=,flag=)</td><td>被注释的元素必须符合指定的正则表达式</td></tr></tbody></table><p><strong>使用</strong>：</p><p>需要搭配在Controller中搭配@Validated或@Valid注解一起使用，@Validated和@Valid注解区别不是很大，一般情况下任选一个即可，区别如下：</p><table><thead><tr><th>注解</th><th>@Validated</th><th>@Valid</th></tr></thead><tbody><tr><td>所属的包</td><td>属于org.springframework.validation.annotation包下的,是spring提供的</td><td>属于javax.validation包下,是jdk给提供的</td></tr><tr><td>是否支持分组和排序</td><td>是</td><td>否</td></tr></tbody></table><p>虽然@Validated比@Valid更加强大，在@Valid之上提供了分组功能和验证排序功能。Hibernate-validate框架中的注解是需要加在实体中一起使用的：</p><ul><li>定义一个实体：message字段为不符合校验规则时抛出的异常信息</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">DataSetSaveVO</span> </span>&#123;</span><br><span class="line">    <span class="comment">//唯一标识符为空</span></span><br><span class="line">    <span class="meta">@NotBlank(message = &quot;user uuid is empty&quot;)</span></span><br><span class="line">    <span class="comment">//用户名称只能是字母和数字</span></span><br><span class="line">    <span class="meta">@Pattern(regexp = &quot;^[a-z0-9]+$&quot;, message = &quot;user names can only be alphabetic and numeric&quot;)</span></span><br><span class="line">    <span class="meta">@Length(max = 48, message = &quot;user uuid length over 48 byte&quot;)</span></span><br><span class="line">    <span class="keyword">private</span> String userUuid;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//数据集名称只能是字母和数字</span></span><br><span class="line">    <span class="meta">@Pattern(regexp = &quot;^[A-Za-z0-9]+$&quot;, message = &quot;data set names can only be letters and Numbers&quot;)</span></span><br><span class="line">    <span class="comment">//文件名称过长</span></span><br><span class="line">    <span class="meta">@Length(max = 48, message = &quot;file name too long&quot;)</span></span><br><span class="line">    <span class="comment">//文件名称为空</span></span><br><span class="line">    <span class="meta">@NotBlank(message = &quot;file name is empty&quot;)</span></span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//数据集描述最多为256字节</span></span><br><span class="line">    <span class="meta">@Length(max = 256, message = &quot;data set description length over 256 byte&quot;)</span></span><br><span class="line">    <span class="comment">//数据集描述为空</span></span><br><span class="line">    <span class="meta">@NotBlank(message = &quot;data set description is null&quot;)</span></span><br><span class="line">    <span class="keyword">private</span> String description;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>Controller层中的方法：在校验的实体DataSetSaveVO旁边添加@Valid或@Validated注解</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@PostMapping</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> ResponseVO <span class="title">createDataSet</span><span class="params">(<span class="meta">@Valid</span> <span class="meta">@RequestBody</span> DataSetSaveVO dataSetVO)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> ResponseUtil.success(dataSetService.saveDataSet(dataSetVO));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="7-2-使用commons-lang3"><a href="#7-2-使用commons-lang3" class="headerlink" title="7.2 使用commons-lang3"></a>7.2 使用commons-lang3</h3><p><strong>引入依赖</strong>：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.apache.commons<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>commons-lang3<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>3.4<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure><p><strong>常用方法说明</strong>：</p><table><thead><tr><th>方法</th><th>说明</th></tr></thead><tbody><tr><td>CollectionUtils.isEmpty</td><td>判断集合是否为空，为null或者size==0，返回true</td></tr><tr><td>CollectionUtils.isNotEmpty</td><td>判断集合是否为非空</td></tr><tr><td>StringUtils.isEmpty</td><td>判断字符串是否为空</td></tr><tr><td>StringUtils.isNotEmpty</td><td>判断字符串是否非空</td></tr><tr><td>StringUtils.isBlank</td><td>判断字符串是否为空，为null或者size==0或者只存在空白字符(如” “)，则返回true</td></tr><tr><td>StringUtils.isNotBlank</td><td>判断字符串是否为非空</td></tr></tbody></table><p>测试代码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//StringUtils.isEmpty</span></span><br><span class="line">System.out.println(StringUtils.isEmpty(<span class="string">&quot;&quot;</span>));  <span class="comment">//true</span></span><br><span class="line">System.out.println(StringUtils.isEmpty(<span class="string">&quot;  &quot;</span>));  <span class="comment">//false</span></span><br><span class="line"><span class="comment">//StringUtils.isNotEmpty</span></span><br><span class="line">System.out.println(StringUtils.isNotEmpty(<span class="string">&quot;&quot;</span>));  <span class="comment">//false</span></span><br><span class="line">        </span><br><span class="line"><span class="comment">//StringUtils.isBlank</span></span><br><span class="line">System.out.println(StringUtils.isBlank(<span class="string">&quot;&quot;</span>));  <span class="comment">//true</span></span><br><span class="line">System.out.println(StringUtils.isBlank(<span class="string">&quot; &quot;</span>));  <span class="comment">//true</span></span><br><span class="line"><span class="comment">//StringUtils.isNotBlank</span></span><br><span class="line">System.out.println(StringUtils.isNotBlank(<span class="string">&quot; &quot;</span>));  <span class="comment">//false</span></span><br><span class="line"></span><br><span class="line">List&lt;Integer&gt; emptyList = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">List&lt;Integer&gt; nullList = <span class="keyword">null</span>;</span><br><span class="line">List&lt;Integer&gt; notEmptyList = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">notEmptyList.add(<span class="number">1</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">//CollectionUtils.isEmpty</span></span><br><span class="line">System.out.println(CollectionUtils.isEmpty(emptyList));   <span class="comment">//true</span></span><br><span class="line">System.out.println(CollectionUtils.isEmpty(nullList));   <span class="comment">//true</span></span><br><span class="line">System.out.println(CollectionUtils.isEmpty(notEmptyList));   <span class="comment">//false</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//CollectionUtils.isNotEmpty</span></span><br><span class="line">System.out.println(CollectionUtils.isNotEmpty(emptyList));   <span class="comment">//false</span></span><br><span class="line">System.out.println(CollectionUtils.isNotEmpty(nullList));   <span class="comment">//false</span></span><br><span class="line">System.out.println(CollectionUtils.isNotEmpty(notEmptyList));   <span class="comment">//true</span></span><br></pre></td></tr></table></figure><h3 id="7-3-自定义注解"><a href="#7-3-自定义注解" class="headerlink" title="7.3 自定义注解"></a>7.3 自定义注解</h3><p>当上面的方面都无法满足校验的需求以后，可以考虑使用自定义注解</p><hr><p>参考：</p><p>🔗《Java Web高级编程—涵盖WebSockets、Spring Framework、JPA Hibernate、Spring Security》</p><p>🔗 <a href="https://juejin.cn/post/6913735652806754311">Springboot中如何优雅进行字段校验 </a></p>]]></content>
    
    
    <summary type="html">内容来自于《Java Web高级编程—涵盖WebSockets、Spring Framework、JPA Hibernate、Spring Security》。</summary>
    
    
    
    <category term="技术文档" scheme="http://linyishui.top/categories/%E6%8A%80%E6%9C%AF%E6%96%87%E6%A1%A3/"/>
    
    
    <category term="Spring" scheme="http://linyishui.top/tags/Spring/"/>
    
    <category term="Hibernate" scheme="http://linyishui.top/tags/Hibernate/"/>
    
    <category term="Spring Framework" scheme="http://linyishui.top/tags/Spring-Framework/"/>
    
  </entry>
  
</feed>
