<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>沂水博客</title>
  
  <subtitle>编程和心历记录</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://linyishui.top/"/>
  <updated>2019-11-18T08:54:23.757Z</updated>
  <id>http://linyishui.top/</id>
  
  <author>
    <name>沂水</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>死亡会是解脱吗</title>
    <link href="http://linyishui.top/2019111201.html"/>
    <id>http://linyishui.top/2019111201.html</id>
    <published>2019-11-12T10:03:51.000Z</published>
    <updated>2019-11-18T08:54:23.757Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script>        <div id="aplayer-mEDvBNBz" class="aplayer aplayer-tag-marker" style="margin-bottom: 20px;">            <pre class="aplayer-lrc-content"></pre>        </div>        <script>          var ap = new APlayer({            element: document.getElementById("aplayer-mEDvBNBz"),            narrow: false,            autoplay: false,            showlrc: false,            music: {              title: "曾经我也想过一了百了",              author: "中島美嘉",              url: "https://music-1258215793.cos.ap-shanghai.myqcloud.com/JP/%E4%B8%AD%E5%B3%B6%E7%BE%8E%E5%98%89%20-%20%E5%83%95%E3%81%8C%E6%AD%BB%E3%81%AE%E3%81%86%E3%81%A8%E6%80%9D%E3%81%A3%E3%81%9F%E3%81%AE%E3%81%AF.mp3",              pic: "http://p1.music.126.net/HE-K4mxyNGF84xlyuxx9Wg==/109951163825342747.jpg",              lrc: ""            }          });          window.aplayers || (window.aplayers = []);          window.aplayers.push(ap);        </script>        <div id="aplayer-fUrHBuie" class="aplayer aplayer-tag-marker" style="margin-bottom: 20px;">            <pre class="aplayer-lrc-content"></pre>        </div>        <script>          var ap = new APlayer({            element: document.getElementById("aplayer-fUrHBuie"),            narrow: false,            autoplay: false,            showlrc: false,            music: {              title: "僕らの手には何もないけど、",              author: "RAM WIRE",              url: "https://music-1258215793.cos.ap-shanghai.myqcloud.com/JP/RAM%20WIRE%20-%20%E5%83%95%E3%82%89%E3%81%AE%E6%89%8B%E3%81%AB%E3%81%AF%E4%BD%95%E3%82%82%E3%81%AA%E3%81%84%E3%81%91%E3%81%A9%E3%80%81.mp3",              pic: "http://p2.music.126.net/V1o9XDhAnI1ayWW5elJwFQ==/109951163338252165.jpg",              lrc: ""            }          });          window.aplayers || (window.aplayers = []);          window.aplayers.push(ap);        </script>        <div id="aplayer-EGEVoQCF" class="aplayer aplayer-tag-marker" style="margin-bottom: 20px;">            <pre class="aplayer-lrc-content"></pre>        </div>        <script>          var ap = new APlayer({            element: document.getElementById("aplayer-EGEVoQCF"),            narrow: false,            autoplay: false,            showlrc: false,            music: {              title: "ごはんを食べよう",              author: "Goose house",              url: "https://music-1258215793.cos.ap-shanghai.myqcloud.com/Goose%20house%20-%20%E3%81%94%E3%81%AF%E3%82%93%E3%82%92%E9%A3%9F%E3%81%B9%E3%82%88%E3%81%86.mp3",              pic: "http://p1.music.126.net/niXAzTEt2zlFpcLiPedX3g==/5754843859843186.jpg",              lrc: ""            }          });          window.aplayers || (window.aplayers = []);          window.aplayers.push(ap);        </script><p>&emsp;&emsp;可能会有那么一刻感叹自己的人生很空虚，世界好像和我无关，就算在这里死掉也不会有人会发现吧。</p><p>&emsp;&emsp;可能会有那么一刻觉得活着好累，死了就会好一些吧。</p><p>&emsp;&emsp;可能会有那么一刻无力反抗背上的压力，想着死了就轻松了吧。</p><p>&emsp;&emsp;活着似乎总是要担负一些东西，嘴里说着要放下一切，只有死去的那一刻才能真的放下吧。</p><p>&emsp;&emsp;世界是这样吗，不像幻想中那么美好、那么宽容，我好像也没那么坚强。</p><p>&emsp;&emsp;也曾想向世界传递善意，但身边的世界好像是空空的，是不是只有坏的记忆才能留在人的心里。</p><p>&emsp;&emsp;也曾想对世界倾诉，但好像没人有在乎，渐渐的也不知道该怎么说话了。</p><p>&emsp;&emsp;是啊，大家活着都很累啊，慢慢地封闭了自己的内心。</p><p>&emsp;&emsp;为了不受伤害而戴上的面具，也遮挡住了阳光，勉强才能维持着正常人的姿态。</p><p>&emsp;&emsp;“你没事吧”，“休息一下就好了”，“为家人考虑一下”，“再多坚强一些”，“还是内心不够强大”，“看不起这种自私的人”</p><p>&emsp;&emsp;说什么把握当下，生命要活得精彩，只是漂亮话罢了。</p><p>&emsp;&emsp;永别的时候告诉自己这不是放弃，是放下了。</p><p>&emsp;&emsp;好像这一生积攒的勇气终于释放了，好像扮演了一生的舞台剧终于谢幕了。</p><p>&emsp;&emsp;黑暗中死的无声无息，似乎从来没有存在过，直到最后也没有选择在阳光下，是担心围观的人肆意评论吗，人的恶意从来不会消失吧。</p><p>&emsp;&emsp;曾经也活着啊，匆匆的这一生有什么意义？</p><p>&emsp;&emsp;可能最后时刻的你也曾许愿，如果有来生，希望和能相互拥抱的人相遇。</p><p>&emsp;&emsp;哪怕一直聊着没有营养的话题，只想这样呆在一起。</p><p>&emsp;&emsp;就算还是一样活的辛苦，至少能感受到温暖。</p><p>&emsp;&emsp;希望那时可以相信这世界一切美好的存在，希望我也能成为温暖别人的存在。</p><p>&emsp;&emsp;但死了就什么都没有了，如果坚持到明天会不会有不同？</p><p>&emsp;&emsp;已放下所有的你，也许在明天的街头，可以邂逅一个阳光一样的人，也许再尝试一次就能找到一个同样孤独的人相拥取暖。</p><p>&emsp;&emsp;也许是一个多年未联系的老友，敞开心扉后，发现被社会打磨的油滑的他内心也还保留着一颗温热的心。</p><p>&emsp;&emsp;即便因奔忙无法相见，即便相互已无法变得坦率，但只要能够回到每个人都怀念的那个地方的话，是能让时光从那个时候开始延续吧</p><p>&emsp;&emsp;找到一个活下去的理由，只要能继续努力的活着，一切都还有重来的机会。</p><p>&emsp;&emsp;原本以为做不到的事情实际却可以做到的，世界渐渐变得广阔，因为相信现在所处的世界，即使一无所有仍可以顽强的活下去。</p><p>&emsp;&emsp;是啊，活着就是一件麻烦的事情，觉得不行了就暂停一下，无法面对了就逃避一下，总有一天，我们会从所有束缚我们的事之中，从肉眼看不到的微痛之中，得以解放。</p>        <div id="aplayer-XYfmweCL" class="aplayer aplayer-tag-marker" style="margin-bottom: 20px;">            <pre class="aplayer-lrc-content"></pre>        </div>        <script>          var ap = new APlayer({            element: document.getElementById("aplayer-XYfmweCL"),            narrow: false,            autoplay: false,            showlrc: false,            music: {              title: "面会菜",              author: "林生祥",              url: "https://music-1258215793.cos.ap-shanghai.myqcloud.com/OM/%E6%9E%97%E7%94%9F%E7%A5%A5%20-%20%E9%9D%A2%E4%BC%9A%E8%8F%9C.mp3",              pic: "http://p2.music.126.net/cLoAM3X8pIuCil_oJpxjWw==/18511377767183768.jpg",              lrc: ""            }          });          window.aplayers || (window.aplayers = []);          window.aplayers.push(ap);        </script><blockquote><p>&emsp;&emsp;这篇博客算是记录一下最近几年的一些感想吧，经历了一些生活中、网络中发生的事情会有些感受，这些碎片式的感受还挺难整理的，很多回忆融合到一起，写的时候有些混乱了，写着写着也搞不清想要说什么了。<br>&emsp;&emsp;有些事情发生了，可能并没有一个简单的答案，局外人却可以随心所欲的谈论自己的观点，虽然他们可能什么都不知道，却能没有责任的随便开口。事情已经发生了，当事人也没办法为自己辩护了。<br>&emsp;&emsp;</p></blockquote>]]></content>
    
    <summary type="html">
    
      
      
        &lt;link rel=&quot;stylesheet&quot; class=&quot;aplayer-secondary-style-marker&quot; href=&quot;\assets\css\APlayer.min.css&quot;&gt;&lt;script src=&quot;\assets\js\APlayer.min.js&quot; cla
      
    
    </summary>
    
      <category term="日志" scheme="http://linyishui.top/categories/%E6%97%A5%E5%BF%97/"/>
    
    
      <category term="diary" scheme="http://linyishui.top/tags/diary/"/>
    
  </entry>
  
  <entry>
    <title>面试整理——Spring和SpringMVC</title>
    <link href="http://linyishui.top/2019110101.html"/>
    <id>http://linyishui.top/2019110101.html</id>
    <published>2019-11-01T09:42:38.000Z</published>
    <updated>2019-12-12T09:44:08.675Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="Spring"><a href="#Spring" class="headerlink" title="Spring"></a><strong>Spring</strong></h1><!--说说Spring的生命周期吧Spring的单例是怎么实现的？SpringMVC不同用户登录的信息怎么保证线程安全的？AOPspringmvc执行流程。3. ioc与aop的原理与流程4. aop实现原理？动态代理与CGlib的区别？5. bean对象的生命周期？6. bean成员变量的参数注入有哪种方式？7. spring常用的注解有哪些？8. @Autowired和@Resource的区别？9. spring提供的扩展组件有用过吗？比如拦截器？说下这个拦截器的api（疯狂问还有没用过其它的组件）10. 登录态怎么去处理的？11. 用的服务器是tomcat还是netty？tomcat的配置参数有印象吗？优化方面有了解过吗？12. SpringBoot的自动配置流程？Spring IOC是怎么管理bean的？给你spring的jar包你要怎么让它启动20.假如现在在一个类了要引用到几十个Bean，难道要在类里声明这些bean然后加注解吗，有没有更好的做法？21.Spring Bean是如何注入的？单例的情况下怎么实例化，什么时候，多例呢？22.Hibernate如何实现ORM，引入它的jar包你怎么使用Hibernate操作数据库基本上涉及到框架的，都是问里面怎么实现的，回答得太表层没什么用，感觉不是他想要的答案，有时搞不清他要问框架的整个处理流程还是底层怎么实现，知道的点很多但是不知道怎么回答，而且情景不是应用在web项目里的，而是一个普通的Java项目你怎么使用。--><h1 id="SpringMVC"><a href="#SpringMVC" class="headerlink" title="SpringMVC"></a><strong>SpringMVC</strong></h1><hr><p><em>参考内容均来自网络中网友分享，若内容涉及侵权请及时告知，我会尽快修改和删除相关内容</em></p>]]></content>
    
    <summary type="html">
    
      整理面试中常问的Spring和SpringMVC相关问题，持续更新中。
    
    </summary>
    
      <category term="面试整理" scheme="http://linyishui.top/categories/%E9%9D%A2%E8%AF%95%E6%95%B4%E7%90%86/"/>
    
    
      <category term="Q&amp;A" scheme="http://linyishui.top/tags/Q-A/"/>
    
  </entry>
  
  <entry>
    <title>面试整理——数据库</title>
    <link href="http://linyishui.top/2019102901.html"/>
    <id>http://linyishui.top/2019102901.html</id>
    <published>2019-10-29T08:24:25.000Z</published>
    <updated>2019-12-13T02:53:06.001Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h2 id="未归类"><a href="#未归类" class="headerlink" title="未归类"></a><strong>未归类</strong></h2><h3 id="问：查询姓名，课程名，成绩-（自定义设计表，写出sql）？"><a href="#问：查询姓名，课程名，成绩-（自定义设计表，写出sql）？" class="headerlink" title="问：查询姓名，课程名，成绩?（自定义设计表，写出sql）？"></a><strong>问：查询姓名，课程名，成绩?（自定义设计表，写出sql）？</strong></h3><details><br><br>&emsp;&emsp;<br><br></details><h3 id="问：解释一下ACID都是什么？事务的ACID，其中把事务的隔离性详细解释一遍，事务有哪些特性？怎么理解原子性？"><a href="#问：解释一下ACID都是什么？事务的ACID，其中把事务的隔离性详细解释一遍，事务有哪些特性？怎么理解原子性？" class="headerlink" title="问：解释一下ACID都是什么？事务的ACID，其中把事务的隔离性详细解释一遍，事务有哪些特性？怎么理解原子性？"></a><strong>问：解释一下ACID都是什么？事务的ACID，其中把事务的隔离性详细解释一遍，事务有哪些特性？怎么理解原子性？</strong></h3><details><br><br>&emsp;&emsp;脏读、幻影读、不可重复读？<br><br></details><h3 id="问：你们生产用的是哪种事务隔离级别，为什么？"><a href="#问：你们生产用的是哪种事务隔离级别，为什么？" class="headerlink" title="问：你们生产用的是哪种事务隔离级别，为什么？"></a><strong>问：你们生产用的是哪种事务隔离级别，为什么？</strong></h3><details><br><br>&emsp;&emsp;<br><br></details><h3 id="问：什么是索引覆盖？"><a href="#问：什么是索引覆盖？" class="headerlink" title="问：什么是索引覆盖？"></a><strong>问：什么是索引覆盖？</strong></h3><details><br><br>&emsp;&emsp;<br><br></details><h3 id="问：你们数据库的高可用架构是怎么样的？"><a href="#问：你们数据库的高可用架构是怎么样的？" class="headerlink" title="问：你们数据库的高可用架构是怎么样的？"></a><strong>问：你们数据库的高可用架构是怎么样的？</strong></h3><details><br><br>&emsp;&emsp;<br><br></details><h3 id="问：如何保证数据库主从一致性？"><a href="#问：如何保证数据库主从一致性？" class="headerlink" title="问：如何保证数据库主从一致性？"></a><strong>问：如何保证数据库主从一致性？</strong></h3><details><br><br>&emsp;&emsp;<br><br></details><h3 id="问：数据库存储引擎特点与区别-还有应用场景"><a href="#问：数据库存储引擎特点与区别-还有应用场景" class="headerlink" title="问：数据库存储引擎特点与区别?还有应用场景"></a><strong>问：数据库存储引擎特点与区别?还有应用场景</strong></h3><details><br><br>&emsp;&emsp;<br><br></details><h3 id="问：数据库的存储引擎有哪几种？有什么区别？"><a href="#问：数据库的存储引擎有哪几种？有什么区别？" class="headerlink" title="问：数据库的存储引擎有哪几种？有什么区别？"></a><strong>问：数据库的存储引擎有哪几种？有什么区别？</strong></h3><details><br><br>&emsp;&emsp;<br><br></details><h3 id="问：什么时候该用索引-（字段查询过多时）除了这个还有吗"><a href="#问：什么时候该用索引-（字段查询过多时）除了这个还有吗" class="headerlink" title="问：什么时候该用索引?（字段查询过多时）除了这个还有吗?"></a><strong>问：什么时候该用索引?（字段查询过多时）除了这个还有吗?</strong></h3><details><br><br>&emsp;&emsp;<br><br></details><h3 id="问：聚簇和非聚簇又可细分哪一些？"><a href="#问：聚簇和非聚簇又可细分哪一些？" class="headerlink" title="问：聚簇和非聚簇又可细分哪一些？"></a><strong>问：聚簇和非聚簇又可细分哪一些？</strong></h3><details><br><br>&emsp;&emsp;<br><br></details><h3 id="问：B-树与B树的区别？索引为什么选择B-树？说下索引结构，为什么使用B-树？"><a href="#问：B-树与B树的区别？索引为什么选择B-树？说下索引结构，为什么使用B-树？" class="headerlink" title="问：B+树与B树的区别？索引为什么选择B+树？说下索引结构，为什么使用B+树？"></a><strong>问：B+树与B树的区别？索引为什么选择B+树？说下索引结构，为什么使用B+树？</strong></h3><details><br><br>&emsp;&emsp;<br><br></details><h3 id="问：组合索引？"><a href="#问：组合索引？" class="headerlink" title="问：组合索引？"></a><strong>问：组合索引？</strong></h3><details><br><br>&emsp;&emsp;（写了一个例子，选择会走索引的sql）。like索引的例子？(就是以like %李%和like 李%为例子讲)有没有其它例子也是这样跳过索引的？<br><br></details><h3 id="问：主从的模式有哪些？实现同步的方式？"><a href="#问：主从的模式有哪些？实现同步的方式？" class="headerlink" title="问：主从的模式有哪些？实现同步的方式？"></a><strong>问：主从的模式有哪些？实现同步的方式？</strong></h3><details><br><br>&emsp;&emsp;<br><br></details><h3 id="问：有考虑过大数据量优化的情况吗？"><a href="#问：有考虑过大数据量优化的情况吗？" class="headerlink" title="问：有考虑过大数据量优化的情况吗？"></a><strong>问：有考虑过大数据量优化的情况吗？</strong></h3><details><br><br>&emsp;&emsp;<br><br></details><h3 id="问：Innodb中索引的实现？"><a href="#问：Innodb中索引的实现？" class="headerlink" title="问：Innodb中索引的实现？"></a><strong>问：Innodb中索引的实现？</strong></h3><details><br><br>&emsp;&emsp;<br><br></details><hr><h2 id="MySql"><a href="#MySql" class="headerlink" title="MySql"></a><strong>MySql</strong></h2><h3 id="问：知道mysql的索引算法么？"><a href="#问：知道mysql的索引算法么？" class="headerlink" title="问：知道mysql的索引算法么？"></a><strong>问：知道mysql的索引算法么？</strong></h3><details><br><br>&emsp;&emsp;<br><br></details><h3 id="问：为什么mongodb的索引用了B树，而mysql用B-树？"><a href="#问：为什么mongodb的索引用了B树，而mysql用B-树？" class="headerlink" title="问：为什么mongodb的索引用了B树，而mysql用B+树？"></a><strong>问：为什么mongodb的索引用了B树，而mysql用B+树？</strong></h3><details><br><br>&emsp;&emsp;<br><br></details><h3 id="问：mysql索引的执行计划有了解过吗？"><a href="#问：mysql索引的执行计划有了解过吗？" class="headerlink" title="问：mysql索引的执行计划有了解过吗？"></a><strong>问：mysql索引的执行计划有了解过吗？</strong></h3><details><br><br>&emsp;&emsp;<br><br></details><h3 id="问：有用过explain吗？它执行的结果重要的参数是什么？"><a href="#问：有用过explain吗？它执行的结果重要的参数是什么？" class="headerlink" title="问：有用过explain吗？它执行的结果重要的参数是什么？"></a><strong>问：有用过explain吗？它执行的结果重要的参数是什么？</strong></h3><details><br><br>&emsp;&emsp;<br><br></details><h3 id="问：mysql的主从复制有了解过吗？"><a href="#问：mysql的主从复制有了解过吗？" class="headerlink" title="问：mysql的主从复制有了解过吗？"></a><strong>问：mysql的主从复制有了解过吗？</strong></h3><details><br><br>&emsp;&emsp;<br><br></details><h3 id="问：mysql常用的索引类型有哪些？"><a href="#问：mysql常用的索引类型有哪些？" class="headerlink" title="问：mysql常用的索引类型有哪些？"></a><strong>问：mysql常用的索引类型有哪些？</strong></h3><details><br><br>&emsp;&emsp;<br><br></details><h3 id="问：MySQL有哪些锁？"><a href="#问：MySQL有哪些锁？" class="headerlink" title="问：MySQL有哪些锁？"></a><strong>问：MySQL有哪些锁？</strong></h3><details><br><br>&emsp;&emsp;<br><br></details><h3 id="问：MySQL行锁是否会有死锁的情况？"><a href="#问：MySQL行锁是否会有死锁的情况？" class="headerlink" title="问：MySQL行锁是否会有死锁的情况？"></a><strong>问：MySQL行锁是否会有死锁的情况？</strong></h3><details><br><br>&emsp;&emsp;<br><br></details><h3 id="问：AUTO-INCREMENT原理（考察并发情况）？"><a href="#问：AUTO-INCREMENT原理（考察并发情况）？" class="headerlink" title="问：AUTO_INCREMENT原理（考察并发情况）？"></a><strong>问：AUTO_INCREMENT原理（考察并发情况）？</strong></h3><details><br><br>&emsp;&emsp;<br><br></details><h3 id="问：数据库的索引有哪几种？"><a href="#问：数据库的索引有哪几种？" class="headerlink" title="问：数据库的索引有哪几种？"></a><strong>问：数据库的索引有哪几种？</strong></h3><details><br><br>&emsp;&emsp;为什么要用B+树来做索引？<br><br>&emsp;&emsp;组合索引和几个单个的索引有什么区别？<br><br>&emsp;&emsp;数据库的大表查询优化了解吗？<br><br>&emsp;&emsp;MVCC机制了解不？<br><br>&emsp;&emsp;MVCC机制有什么问题？<br><br>&emsp;&emsp;怎么去解决这个问题？<br><br>&emsp;&emsp;mysql慢语句调优做过吗？<br><br>&emsp;&emsp;说说你是怎么做的？<br><br></details><h2 id="Redis"><a href="#Redis" class="headerlink" title="Redis"></a><strong>Redis</strong></h2><h3 id="问：redis了解吗？你说说怎么用redis实现分布式锁？"><a href="#问：redis了解吗？你说说怎么用redis实现分布式锁？" class="headerlink" title="问：redis了解吗？你说说怎么用redis实现分布式锁？"></a><strong>问：redis了解吗？你说说怎么用redis实现分布式锁？</strong></h3><details><br><br>&emsp;&emsp;<br><br></details><h3 id="问：Redis常用数据结构及底层数据结构实现？了解哪些数据结构-分别用在什么场景-zset底层怎么实现的"><a href="#问：Redis常用数据结构及底层数据结构实现？了解哪些数据结构-分别用在什么场景-zset底层怎么实现的" class="headerlink" title="问：Redis常用数据结构及底层数据结构实现？了解哪些数据结构? 分别用在什么场景? zset底层怎么实现的?"></a><strong>问：Redis常用数据结构及底层数据结构实现？了解哪些数据结构? 分别用在什么场景? zset底层怎么实现的?</strong></h3><details><br><br>&emsp;&emsp;既然两个数据结构时间复杂度都是O(logN)，zset为什么不用红黑树。你们用了redis，redis的底层数据结构了解多少？<br><br></details><h3 id="问：如何解决-Redis-的并发竞争-Key-问题？"><a href="#问：如何解决-Redis-的并发竞争-Key-问题？" class="headerlink" title="问：如何解决 Redis 的并发竞争 Key 问题？"></a><strong>问：如何解决 Redis 的并发竞争 Key 问题？</strong></h3><details><br><br>&emsp;&emsp;<br><br></details><h3 id="问：如何保证缓存与数据库双写时的数据一致性？"><a href="#问：如何保证缓存与数据库双写时的数据一致性？" class="headerlink" title="问：如何保证缓存与数据库双写时的数据一致性？"></a><strong>问：如何保证缓存与数据库双写时的数据一致性？</strong></h3><details><br><br>&emsp;&emsp;<br><br></details><h3 id="问：项目用到了redis，讲讲你项目用到了redis的哪些特性？"><a href="#问：项目用到了redis，讲讲你项目用到了redis的哪些特性？" class="headerlink" title="问：项目用到了redis，讲讲你项目用到了redis的哪些特性？"></a><strong>问：项目用到了redis，讲讲你项目用到了redis的哪些特性？</strong></h3><details><br><br>&emsp;&emsp;<br><br></details><h3 id="问：Redis是单线程？redis的单线程特性有什么优缺点？redis的单进程单线程模型；延伸到IO多路复用；一路延伸到epoll、poll、select-主要讲了三者使用的数据结构区别以及各自的特点-；"><a href="#问：Redis是单线程？redis的单线程特性有什么优缺点？redis的单进程单线程模型；延伸到IO多路复用；一路延伸到epoll、poll、select-主要讲了三者使用的数据结构区别以及各自的特点-；" class="headerlink" title="问：Redis是单线程？redis的单线程特性有什么优缺点？redis的单进程单线程模型；延伸到IO多路复用；一路延伸到epoll、poll、select(主要讲了三者使用的数据结构区别以及各自的特点)；"></a><strong>问：Redis是单线程？redis的单线程特性有什么优缺点？redis的单进程单线程模型；延伸到IO多路复用；一路延伸到epoll、poll、select(主要讲了三者使用的数据结构区别以及各自的特点)；</strong></h3><details><br><br>&emsp;&emsp;<br><br></details><h3 id="问：redis支持哪些数据类型？"><a href="#问：redis支持哪些数据类型？" class="headerlink" title="问：redis支持哪些数据类型？"></a><strong>问：redis支持哪些数据类型？</strong></h3><details><br><br>&emsp;&emsp;<br><br></details><h3 id="问：redis中的字符串类型是怎么实现的？"><a href="#问：redis中的字符串类型是怎么实现的？" class="headerlink" title="问：redis中的字符串类型是怎么实现的？"></a><strong>问：redis中的字符串类型是怎么实现的？</strong></h3><details><br><br>&emsp;&emsp;(SDS)注:sds为redis底层数据结构之一<br><br></details><h3 id="问：SDS相比原生的char-有什么优点？知道动态字符串sds的优缺点么？"><a href="#问：SDS相比原生的char-有什么优点？知道动态字符串sds的优缺点么？" class="headerlink" title="问：SDS相比原生的char[]有什么优点？知道动态字符串sds的优缺点么？"></a><strong>问：SDS相比原生的char[]有什么优点？知道动态字符串sds的优缺点么？</strong></h3><details><br><br>&emsp;&emsp;（共有4个优点，前不久刚看过，当时只回忆起1个优点。。）<br><br></details><h3 id="问：关于redis对象系统的一个问题？"><a href="#问：关于redis对象系统的一个问题？" class="headerlink" title="问：关于redis对象系统的一个问题？"></a><strong>问：关于redis对象系统的一个问题？</strong></h3><details><br><br>&emsp;&emsp;（我说忘记了，记得redis设计与实现有写，面试小哥：忘记了那就不问了）<br><br></details><h3 id="问：Redis高并发快的原因？"><a href="#问：Redis高并发快的原因？" class="headerlink" title="问：Redis高并发快的原因？"></a><strong>问：Redis高并发快的原因？</strong></h3><details><br><br>&emsp;&emsp;<br><br></details><h3 id="问：redis主从机制了解么？怎么实现的？"><a href="#问：redis主从机制了解么？怎么实现的？" class="headerlink" title="问：redis主从机制了解么？怎么实现的？"></a><strong>问：redis主从机制了解么？怎么实现的？</strong></h3><details><br><br>&emsp;&emsp;<br><br></details><h3 id="问：如何利用Redis处理热点数据？"><a href="#问：如何利用Redis处理热点数据？" class="headerlink" title="问：如何利用Redis处理热点数据？"></a><strong>问：如何利用Redis处理热点数据？</strong></h3><details><br><br>&emsp;&emsp;<br><br></details><h3 id="问：谈谈Redis哨兵、复制、集群？"><a href="#问：谈谈Redis哨兵、复制、集群？" class="headerlink" title="问：谈谈Redis哨兵、复制、集群？"></a><strong>问：谈谈Redis哨兵、复制、集群？</strong></h3><details><br><br>&emsp;&emsp;<br><br></details><h3 id="问：你们怎么解决缓存击穿问题的？"><a href="#问：你们怎么解决缓存击穿问题的？" class="headerlink" title="问：你们怎么解决缓存击穿问题的？"></a><strong>问：你们怎么解决缓存击穿问题的？</strong></h3><details><br><br>&emsp;&emsp;注:估计答了Hystrix<br><br></details><h3 id="问：Hystrix的隔离机制有哪些？Hystrix常见配置是哪些？"><a href="#问：Hystrix的隔离机制有哪些？Hystrix常见配置是哪些？" class="headerlink" title="问：Hystrix的隔离机制有哪些？Hystrix常见配置是哪些？"></a><strong>问：Hystrix的隔离机制有哪些？Hystrix常见配置是哪些？</strong></h3><details><br><br>&emsp;&emsp;注:估计答了Hystrix<br><br></details><hr><p><em>参考内容均来自网络中网友分享，若内容涉及侵权请及时告知，我会尽快修改和删除相关内容</em></p>]]></content>
    
    <summary type="html">
    
      整理面试中常问的数据库相关问题，持续更新中。
    
    </summary>
    
      <category term="面试整理" scheme="http://linyishui.top/categories/%E9%9D%A2%E8%AF%95%E6%95%B4%E7%90%86/"/>
    
    
      <category term="Q&amp;A" scheme="http://linyishui.top/tags/Q-A/"/>
    
  </entry>
  
  <entry>
    <title>面试整理——分布式</title>
    <link href="http://linyishui.top/2019102801.html"/>
    <id>http://linyishui.top/2019102801.html</id>
    <published>2019-10-28T08:24:18.000Z</published>
    <updated>2019-12-13T02:35:30.984Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>zookeeper怎么保证数据一致性的</p><p>讲讲你对zk的理解吧</p><p>Spring Cloud用到什么东西？<br>如何实现负载均衡？<br>服务挂了注册中心怎么判断？</p><p>分布式锁的实现你知道的有哪些？具体详细谈一种实现方式</p><p>高并发的应用场景，技术需要涉及到哪些？怎样来架构设计？</p><p>接着高并发的问题，谈到了秒杀等的技术应用：kafka、redis、mycat等</p><p>最后谈谈你参与过的项目，技术含量比较高的，相关的架构设计以及你负责哪些核心编码</p><p>部门组织结构是怎样的？<br>系统有哪些模块，每个模块用了哪些技术，数据怎么流转的？给了我一张纸，我在上面简单画了下系统之间的流转情况<br>链路追踪的信息是怎么传递的？</p><p>SpanId怎么保证唯一性？<br>RpcContext是在什么维度传递的？<br>Dubbo的远程调用怎么实现的？</p><p>为什么要单独实现一个服务治理框架？<br>谁主导的？内部还在使用么？<br>逆向有想过怎么做成通用么？</p><p>说下Dubbo的原理?</p><p>分布式追踪的上下文是怎么存储和传递的？</p><p>Dubbo的RpcContext是怎么传递的？主线程的ThreadLocal怎么传递到线程池？你说的内存泄漏具体是怎么产生的？<br>线程池的线程是不是必须手动remove才可以回收value？那你说的内存泄漏是指主线程还是线程池？</p><p>介绍一下自己对 Netty 的认识，为什么要用。说说业务中，Netty 的使用场景。什么是TCP 粘包/拆包,解决办法。Netty线程模型。Dubbo 在使用 Netty 作为网络通讯时候是如何避免粘包与半包问题？讲讲Netty的零拷贝？巴拉巴拉问了好多，我记得有好几个我都没回答上来，心里想着凉凉了啊。</p><p>NginX如何做负载均衡、常见的负载均衡算法有哪些、一致性哈希的一致性是什么意思、一致性哈希是如何做哈希的</p><p>你们项目中微服务是怎么划分的，划分粒度怎么确定？<br>那在实践微服务架构中，有遇到什么问题么？<br>你们在关于微服务间数据一致性问题，是如何解决的？<br>你们为什么不用其他的MQ,最终选择了RocketMQ？<br>为什么RocketMQ没有选择ZooKeeper，而是自己实现了一个NameServer集群？<br>嗯，理解的不错，Zookeeper在选举的过程中，还能对外提供服务么？<br>对Paxos算法了解多少？<br>如果让你来设计一个春晚抢红包架构，你会怎么设计？</p><p>你们在微服务中用RPC通信还是REST？<br>RPC和HTTP的关系是什么？</p><p>谈一谈你对微服务架构的理解</p><p>你用过哪些RPC框架，讲讲他们优缺点</p><p>用过docker么，对容器了解多少</p><p>RPC是什么，如何实现？发送请求之后如何阻塞？让你来设计你会怎么做？这里讨巧，回答用restful做，但是同样问了发送之后怎么确定收到了这个请求的数据</p><h2 id="消息队列怎么实现？异步回调你会怎么做，讲一下你要怎么实现"><a href="#消息队列怎么实现？异步回调你会怎么做，讲一下你要怎么实现" class="headerlink" title="消息队列怎么实现？异步回调你会怎么做，讲一下你要怎么实现"></a>消息队列怎么实现？异步回调你会怎么做，讲一下你要怎么实现</h2><p><em>参考内容均来自网络中网友分享，若内容涉及侵权请及时告知，我会尽快修改和删除相关内容</em></p>]]></content>
    
    <summary type="html">
    
      整理面试中常问的分布式相关问题，持续更新中。
    
    </summary>
    
      <category term="面试整理" scheme="http://linyishui.top/categories/%E9%9D%A2%E8%AF%95%E6%95%B4%E7%90%86/"/>
    
    
      <category term="Q&amp;A" scheme="http://linyishui.top/tags/Q-A/"/>
    
  </entry>
  
  <entry>
    <title>面试整理——操作系统</title>
    <link href="http://linyishui.top/2019102701.html"/>
    <id>http://linyishui.top/2019102701.html</id>
    <published>2019-10-27T08:24:13.000Z</published>
    <updated>2019-12-13T02:34:28.626Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h2 id="未归类"><a href="#未归类" class="headerlink" title="未归类"></a><strong>未归类</strong></h2><h3 id="问：说一下操作系统的内存管理机制？"><a href="#问：说一下操作系统的内存管理机制？" class="headerlink" title="问：说一下操作系统的内存管理机制？"></a><strong>问：说一下操作系统的内存管理机制？</strong></h3><details><br><br>&emsp;&emsp;<br><br></details><h3 id="问：页面置换算法有哪些，介绍一下？"><a href="#问：页面置换算法有哪些，介绍一下？" class="headerlink" title="问：页面置换算法有哪些，介绍一下？"></a><strong>问：页面置换算法有哪些，介绍一下？</strong></h3><details><br><br>&emsp;&emsp;<br><br></details><h3 id="问：试着实现一下LRU算法？"><a href="#问：试着实现一下LRU算法？" class="headerlink" title="问：试着实现一下LRU算法？"></a><strong>问：试着实现一下LRU算法？</strong></h3><details><br><br>&emsp;&emsp;<br><br></details><hr><h2 id="进程和线程"><a href="#进程和线程" class="headerlink" title="进程和线程"></a><strong>进程和线程</strong></h2><h3 id="问：fork和exec有深入了解吗？"><a href="#问：fork和exec有深入了解吗？" class="headerlink" title="问：fork和exec有深入了解吗？"></a><strong>问：fork和exec有深入了解吗？</strong></h3><details><br><br>&emsp;&emsp;<br><br></details><h3 id="问：父进程有多个线程在运行，调用fork后，产生的子进程中有多少个线程？"><a href="#问：父进程有多个线程在运行，调用fork后，产生的子进程中有多少个线程？" class="headerlink" title="问：父进程有多个线程在运行，调用fork后，产生的子进程中有多少个线程？"></a><strong>问：父进程有多个线程在运行，调用fork后，产生的子进程中有多少个线程？</strong></h3><details><br><br>&emsp;&emsp;答：只有一个线程<br><br>&emsp;&emsp;为什会只fork一个线程？会带来什么问题？<br><br>&emsp;&emsp;答：扯了一下unix设计fork接口那会还没有多线程的概念，所以就没考虑复制多个线程，会带来线程安全性问题，略去。<br><br></details><hr><h2 id="Linux"><a href="#Linux" class="headerlink" title="Linux"></a><strong>Linux</strong></h2><h3 id="问：linux中有哪些常见的指令？"><a href="#问：linux中有哪些常见的指令？" class="headerlink" title="问：linux中有哪些常见的指令？"></a><strong>问：linux中有哪些常见的指令？</strong></h3><details><br><br>&emsp;&emsp;<br><br></details><h3 id="问：select、poll、epoll有没有了解过，讲解一下？区别？"><a href="#问：select、poll、epoll有没有了解过，讲解一下？区别？" class="headerlink" title="问：select、poll、epoll有没有了解过，讲解一下？区别？"></a><strong>问：select、poll、epoll有没有了解过，讲解一下？区别？</strong></h3><details><br><br>&emsp;&emsp;<br><br></details><h3 id="问：如何查看Linux系统运行状态？"><a href="#问：如何查看Linux系统运行状态？" class="headerlink" title="问：如何查看Linux系统运行状态？"></a><strong>问：如何查看Linux系统运行状态？</strong></h3><details><br><br>&emsp;&emsp;<br><br></details><h3 id="问：说一下Linux软链接以及和硬链接的区别？"><a href="#问：说一下Linux软链接以及和硬链接的区别？" class="headerlink" title="问：说一下Linux软链接以及和硬链接的区别？"></a><strong>问：说一下Linux软链接以及和硬链接的区别？</strong></h3><details><br><br>&emsp;&emsp;<br><br></details><h3 id="问：说一下Linux进程间通信的方式？"><a href="#问：说一下Linux进程间通信的方式？" class="headerlink" title="问：说一下Linux进程间通信的方式？"></a><strong>问：说一下Linux进程间通信的方式？</strong></h3><p>&emsp;&emsp;答：管道，信号量，消息队列，共享内存，套接字。</p><h3 id="问：说一下命名管道和匿名管道的特点和区别？"><a href="#问：说一下命名管道和匿名管道的特点和区别？" class="headerlink" title="问：说一下命名管道和匿名管道的特点和区别？"></a><strong>问：说一下命名管道和匿名管道的特点和区别？</strong></h3><details><br><br>&emsp;&emsp;<br><br></details><hr><p><em>参考内容均来自网络中网友分享，若内容涉及侵权请及时告知，我会尽快修改和删除相关内容</em></p>]]></content>
    
    <summary type="html">
    
      整理面试中常问的操作系统相关问题，持续更新中。
    
    </summary>
    
      <category term="面试整理" scheme="http://linyishui.top/categories/%E9%9D%A2%E8%AF%95%E6%95%B4%E7%90%86/"/>
    
    
      <category term="Q&amp;A" scheme="http://linyishui.top/tags/Q-A/"/>
    
  </entry>
  
  <entry>
    <title>面试整理——网络</title>
    <link href="http://linyishui.top/2019102601.html"/>
    <id>http://linyishui.top/2019102601.html</id>
    <published>2019-10-26T08:23:48.000Z</published>
    <updated>2019-12-13T02:34:13.131Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h2 id="未归类"><a href="#未归类" class="headerlink" title="未归类"></a><strong>未归类</strong></h2><h3 id="问：说一下dns的原理？"><a href="#问：说一下dns的原理？" class="headerlink" title="问：说一下dns的原理？"></a><strong>问：说一下dns的原理？</strong></h3><details><br><br>&emsp;&emsp;<br><br></details><h3 id="问：cookie、session、token三者区别以及优缺点？"><a href="#问：cookie、session、token三者区别以及优缺点？" class="headerlink" title="问：cookie、session、token三者区别以及优缺点？"></a><strong>问：cookie、session、token三者区别以及优缺点？</strong></h3><details><br><br>&emsp;&emsp;<br><br></details><hr><h2 id="TCP-IP"><a href="#TCP-IP" class="headerlink" title="TCP/IP"></a><strong>TCP/IP</strong></h2><h3 id="问：OSI七层模型都是什么？"><a href="#问：OSI七层模型都是什么？" class="headerlink" title="问：OSI七层模型都是什么？"></a><strong>问：OSI七层模型都是什么？</strong></h3><details><br><br>&emsp;&emsp;<br><br></details><h3 id="问：举例网络协议，都在哪个层？"><a href="#问：举例网络协议，都在哪个层？" class="headerlink" title="问：举例网络协议，都在哪个层？"></a><strong>问：举例网络协议，都在哪个层？</strong></h3><details><br><br>&emsp;&emsp;<br><br></details><h3 id="问：TCP和UDP的区别？udp为什么要比tcp快？"><a href="#问：TCP和UDP的区别？udp为什么要比tcp快？" class="headerlink" title="问：TCP和UDP的区别？udp为什么要比tcp快？"></a><strong>问：TCP和UDP的区别？udp为什么要比tcp快？</strong></h3><details><br><br>&emsp;&emsp;<br><br></details><h3 id="问：TCP如何实现可靠连接-传输？"><a href="#问：TCP如何实现可靠连接-传输？" class="headerlink" title="问：TCP如何实现可靠连接/传输？"></a><strong>问：TCP如何实现可靠连接/传输？</strong></h3><details><br><br>&emsp;&emsp;<br><br></details><h3 id="问：为什么要有TimeWait状态？"><a href="#问：为什么要有TimeWait状态？" class="headerlink" title="问：为什么要有TimeWait状态？"></a><strong>问：为什么要有TimeWait状态？</strong></h3><details><br><br>&emsp;&emsp;TimeWait的等待时长一般是多少？为什么Time_Wait中2*msl？<br><br></details><h3 id="问：如果TCP突然接收方故障会发生什么？"><a href="#问：如果TCP突然接收方故障会发生什么？" class="headerlink" title="问：如果TCP突然接收方故障会发生什么？"></a><strong>问：如果TCP突然接收方故障会发生什么？</strong></h3><details><br><br>&emsp;&emsp;<br><br></details><h3 id="问：一个url从输入到访问经过了哪些过程？"><a href="#问：一个url从输入到访问经过了哪些过程？" class="headerlink" title="问：一个url从输入到访问经过了哪些过程？"></a><strong>问：一个url从输入到访问经过了哪些过程？</strong></h3><details><br><br>&emsp;&emsp;<br><br></details><h3 id="问：说一说TCP三次握手和四次挥手？"><a href="#问：说一说TCP三次握手和四次挥手？" class="headerlink" title="问：说一说TCP三次握手和四次挥手？"></a><strong>问：说一说TCP三次握手和四次挥手？</strong></h3><details><br><br>&emsp;&emsp;<br><br></details><h3 id="问：TCP怎么计算网络延迟？"><a href="#问：TCP怎么计算网络延迟？" class="headerlink" title="问：TCP怎么计算网络延迟？"></a><strong>问：TCP怎么计算网络延迟？</strong></h3><details><br><br>&emsp;&emsp;网络延迟的采样方法。<br><br></details><h3 id="问：TCP的三次握手和四次挥手，以及为什么要三次握手，而不是二次？"><a href="#问：TCP的三次握手和四次挥手，以及为什么要三次握手，而不是二次？" class="headerlink" title="问：TCP的三次握手和四次挥手，以及为什么要三次握手，而不是二次？"></a><strong>问：TCP的三次握手和四次挥手，以及为什么要三次握手，而不是二次？</strong></h3><details><br><br>&emsp;&emsp;<br><br></details><h3 id="问：TCP有哪些状态，相应状态的含义？"><a href="#问：TCP有哪些状态，相应状态的含义？" class="headerlink" title="问：TCP有哪些状态，相应状态的含义？"></a><strong>问：TCP有哪些状态，相应状态的含义？</strong></h3><details><br><br>&emsp;&emsp;<br><br></details><hr><h2 id="HTTP"><a href="#HTTP" class="headerlink" title="HTTP"></a><strong>HTTP</strong></h2><h3 id="问：简单谈谈对HTTP的了解？"><a href="#问：简单谈谈对HTTP的了解？" class="headerlink" title="问：简单谈谈对HTTP的了解？"></a><strong>问：简单谈谈对HTTP的了解？</strong></h3><details><br><br>&emsp;&emsp;<br><br></details><h3 id="问：说一下post和put的数据是放在哪个字段？"><a href="#问：说一下post和put的数据是放在哪个字段？" class="headerlink" title="问：说一下post和put的数据是放在哪个字段？"></a><strong>问：说一下post和put的数据是放在哪个字段？</strong></h3><details><br><br>&emsp;&emsp;<br><br></details><h3 id="问：HTTP状态码含义：503，504，505，403，200？"><a href="#问：HTTP状态码含义：503，504，505，403，200？" class="headerlink" title="问：HTTP状态码含义：503，504，505，403，200？"></a><strong>问：HTTP状态码含义：503，504，505，403，200？</strong></h3><details><br><br>&emsp;&emsp;<br><br></details><h3 id="问：GET和POST区别？"><a href="#问：GET和POST区别？" class="headerlink" title="问：GET和POST区别？"></a><strong>问：GET和POST区别？</strong></h3><details><br><br>&emsp;&emsp;<br><br></details><h3 id="问：知道HTTP1-0和1-1的区别么？"><a href="#问：知道HTTP1-0和1-1的区别么？" class="headerlink" title="问：知道HTTP1.0和1.1的区别么？"></a><strong>问：知道HTTP1.0和1.1的区别么？</strong></h3><details><br><br>&emsp;&emsp;<br><br></details><h3 id="问：谈谈什么是HTTP的长连接和短连接？"><a href="#问：谈谈什么是HTTP的长连接和短连接？" class="headerlink" title="问：谈谈什么是HTTP的长连接和短连接？"></a><strong>问：谈谈什么是HTTP的长连接和短连接？</strong></h3><details><br><br>&emsp;&emsp;<br><br></details><hr><p><em>参考内容均来自网络中网友分享，若内容涉及侵权请及时告知，我会尽快修改和删除相关内容</em></p>]]></content>
    
    <summary type="html">
    
      整理面试中常问的网络相关问题，持续更新中。
    
    </summary>
    
      <category term="面试整理" scheme="http://linyishui.top/categories/%E9%9D%A2%E8%AF%95%E6%95%B4%E7%90%86/"/>
    
    
      <category term="Q&amp;A" scheme="http://linyishui.top/tags/Q-A/"/>
    
  </entry>
  
  <entry>
    <title>面试整理——算法</title>
    <link href="http://linyishui.top/2019102501.html"/>
    <id>http://linyishui.top/2019102501.html</id>
    <published>2019-10-25T08:23:37.000Z</published>
    <updated>2019-12-13T02:51:12.166Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h2 id="未归类"><a href="#未归类" class="headerlink" title="未归类"></a><strong>未归类</strong></h2><hr><h2 id="数据结构"><a href="#数据结构" class="headerlink" title="数据结构"></a><strong>数据结构</strong></h2><h3 id="问：讲讲红黑树、二叉树的算法？红黑树了解么，时间复杂度"><a href="#问：讲讲红黑树、二叉树的算法？红黑树了解么，时间复杂度" class="headerlink" title="问：讲讲红黑树、二叉树的算法？红黑树了解么，时间复杂度?"></a><strong>问：讲讲红黑树、二叉树的算法？红黑树了解么，时间复杂度?</strong></h3><details><br><br>&emsp;&emsp;<br><br></details><h3 id="问：讲下跳表怎么实现的-哈夫曼编码是怎么回事？非递归且不用额外空间（不用栈），如何遍历二叉树？"><a href="#问：讲下跳表怎么实现的-哈夫曼编码是怎么回事？非递归且不用额外空间（不用栈），如何遍历二叉树？" class="headerlink" title="问：讲下跳表怎么实现的?哈夫曼编码是怎么回事？非递归且不用额外空间（不用栈），如何遍历二叉树？"></a><strong>问：讲下跳表怎么实现的?哈夫曼编码是怎么回事？非递归且不用额外空间（不用栈），如何遍历二叉树？</strong></h3><details><br><br>&emsp;&emsp;<br><br></details><h3 id="问：讲下常见的排序算法及其复杂度？怎么实现一个快排？树一般怎么实现，链表怎么实现？"><a href="#问：讲下常见的排序算法及其复杂度？怎么实现一个快排？树一般怎么实现，链表怎么实现？" class="headerlink" title="问：讲下常见的排序算法及其复杂度？怎么实现一个快排？树一般怎么实现，链表怎么实现？"></a><strong>问：讲下常见的排序算法及其复杂度？怎么实现一个快排？树一般怎么实现，链表怎么实现？</strong></h3><details><br><br>&emsp;&emsp;<br><br></details><h3 id="问：堆是怎么实现？小根堆如何插入数据，讲一下过程？"><a href="#问：堆是怎么实现？小根堆如何插入数据，讲一下过程？" class="headerlink" title="问：堆是怎么实现？小根堆如何插入数据，讲一下过程？"></a><strong>问：堆是怎么实现？小根堆如何插入数据，讲一下过程？</strong></h3><details><br><br>&emsp;&emsp;<br><br></details><hr><h2 id="算法题"><a href="#算法题" class="headerlink" title="算法题"></a><strong>算法题</strong></h2><h3 id="问：使用O-N-复杂度完成GBDT分裂？"><a href="#问：使用O-N-复杂度完成GBDT分裂？" class="headerlink" title="问：使用O(N)复杂度完成GBDT分裂？"></a><strong>问：使用O(N)复杂度完成GBDT分裂？</strong></h3><details><br><br>&emsp;&emsp;<br><br></details><h3 id="问：找出无序数组中相隔距离最长的逆序对？"><a href="#问：找出无序数组中相隔距离最长的逆序对？" class="headerlink" title="问：找出无序数组中相隔距离最长的逆序对？"></a><strong>问：找出无序数组中相隔距离最长的逆序对？</strong></h3><details><br><br>&emsp;&emsp;<br><br></details><h3 id="问：给出一个rand5-，实现一个分布均匀的rand7-生成器？"><a href="#问：给出一个rand5-，实现一个分布均匀的rand7-生成器？" class="headerlink" title="问：给出一个rand5()，实现一个分布均匀的rand7()生成器？"></a><strong>问：给出一个rand5()，实现一个分布均匀的rand7()生成器？</strong></h3><details><br><br>&emsp;&emsp;<br><br></details><h3 id="问：有一个点，向北走5公里、东走10km、向南走5公里，回到原点。这样的点有几个，证明？"><a href="#问：有一个点，向北走5公里、东走10km、向南走5公里，回到原点。这样的点有几个，证明？" class="headerlink" title="问：有一个点，向北走5公里、东走10km、向南走5公里，回到原点。这样的点有几个，证明？"></a><strong>问：有一个点，向北走5公里、东走10km、向南走5公里，回到原点。这样的点有几个，证明？</strong></h3><details><br><br>&emsp;&emsp;<br><br></details><h3 id="问：有一个n克的物体、一个天平和若干砝码，这个天平没有刻度，试问最少用多少个什么样的砝码可以将这个物体的质量称出。砝码的质量和个数自行指定。"><a href="#问：有一个n克的物体、一个天平和若干砝码，这个天平没有刻度，试问最少用多少个什么样的砝码可以将这个物体的质量称出。砝码的质量和个数自行指定。" class="headerlink" title="问：有一个n克的物体、一个天平和若干砝码，这个天平没有刻度，试问最少用多少个什么样的砝码可以将这个物体的质量称出。砝码的质量和个数自行指定。"></a><strong>问：有一个n克的物体、一个天平和若干砝码，这个天平没有刻度，试问最少用多少个什么样的砝码可以将这个物体的质量称出。砝码的质量和个数自行指定。</strong></h3><details><br><br>&emsp;&emsp;<br><br></details><h3 id="问：实现堆排序"><a href="#问：实现堆排序" class="headerlink" title="问：实现堆排序"></a><strong>问：实现堆排序</strong></h3><details><br><br>&emsp;&emsp;<br><br></details><h3 id="问：给了长度为N的有重复元素的数组，要求输出第10大的数。需要在2小时内完成"><a href="#问：给了长度为N的有重复元素的数组，要求输出第10大的数。需要在2小时内完成" class="headerlink" title="问：给了长度为N的有重复元素的数组，要求输出第10大的数。需要在2小时内完成"></a><strong>问：给了长度为N的有重复元素的数组，要求输出第10大的数。需要在2小时内完成</strong></h3><details><br><br>&emsp;&emsp;<br><br></details><h3 id="问：手写一个对象池"><a href="#问：手写一个对象池" class="headerlink" title="问：手写一个对象池"></a><strong>问：手写一个对象池</strong></h3><details><br><br>&emsp;&emsp;<br><br></details><hr><h2 id="手撕"><a href="#手撕" class="headerlink" title="手撕"></a><strong>手撕</strong></h2><h3 id="问：一个人从起点出发，初始生命值为n，每次可以向前跳k步并消耗k点生命值，路上的每一个位置都有恢复生命值的好蘑菇，和扣除生命值的坏蘑菇，人的生命值不能为0。问该人到达终点时的最大剩余生命值是多少？如果不能到达终点，返回-1。"><a href="#问：一个人从起点出发，初始生命值为n，每次可以向前跳k步并消耗k点生命值，路上的每一个位置都有恢复生命值的好蘑菇，和扣除生命值的坏蘑菇，人的生命值不能为0。问该人到达终点时的最大剩余生命值是多少？如果不能到达终点，返回-1。" class="headerlink" title="问：一个人从起点出发，初始生命值为n，每次可以向前跳k步并消耗k点生命值，路上的每一个位置都有恢复生命值的好蘑菇，和扣除生命值的坏蘑菇，人的生命值不能为0。问该人到达终点时的最大剩余生命值是多少？如果不能到达终点，返回-1。"></a><strong>问：一个人从起点出发，初始生命值为n，每次可以向前跳k步并消耗k点生命值，路上的每一个位置都有恢复生命值的好蘑菇，和扣除生命值的坏蘑菇，人的生命值不能为0。问该人到达终点时的最大剩余生命值是多少？如果不能到达终点，返回-1。</strong></h3><details><br><br>&emsp;&emsp;一开始以为这道题是道动态规划的题目，但是老想不出递推关系式。问了下是不是贪心的思路，面试官说是贪心，然后给了个例子以及一波暗示，我才终于发现其实每次都跳到加血的蘑菇位置就行了。然后赶紧写了波代码，就这样过去了<br><br></details><h3 id="问：leetcode原题，买卖股票。给一组股票价格，只进行一次交易，最大利润是多少？如果可以进行多次交易，利润又是多少呢？"><a href="#问：leetcode原题，买卖股票。给一组股票价格，只进行一次交易，最大利润是多少？如果可以进行多次交易，利润又是多少呢？" class="headerlink" title="问：leetcode原题，买卖股票。给一组股票价格，只进行一次交易，最大利润是多少？如果可以进行多次交易，利润又是多少呢？"></a><strong>问：leetcode原题，买卖股票。给一组股票价格，只进行一次交易，最大利润是多少？如果可以进行多次交易，利润又是多少呢？</strong></h3><details><br><br>&emsp;&emsp;<br><br></details><h3 id="问：有大量已知的url网址，以及一个新的url网址，如何高效的判断新网址是否和已知网址重复？"><a href="#问：有大量已知的url网址，以及一个新的url网址，如何高效的判断新网址是否和已知网址重复？" class="headerlink" title="问：有大量已知的url网址，以及一个新的url网址，如何高效的判断新网址是否和已知网址重复？"></a><strong>问：有大量已知的url网址，以及一个新的url网址，如何高效的判断新网址是否和已知网址重复？</strong></h3><details><br><br>&emsp;&emsp;答：用字典树来做，省略100字。<br><br></details><h3 id="问：url很长，字典树很占空间怎么办？"><a href="#问：url很长，字典树很占空间怎么办？" class="headerlink" title="问：url很长，字典树很占空间怎么办？"></a><strong>问：url很长，字典树很占空间怎么办？</strong></h3><details><br><br>&emsp;&emsp;答：对url进行分段哈希，然后再放到树节点中，而不是直接把每一个字符作为一个树节点。<br><br></details><h3 id="问：你刚才提到了哈希，那说一下哈希的实现？"><a href="#问：你刚才提到了哈希，那说一下哈希的实现？" class="headerlink" title="问：你刚才提到了哈希，那说一下哈希的实现？"></a><strong>问：你刚才提到了哈希，那说一下哈希的实现？</strong></h3><details><br><br>&emsp;&emsp;答：说了下STL里面unordered_map的大概实现原理，哈希函数，二次探测，开链，省略100字。<br><br>&emsp;&emsp;哈希在什么情况下需要扩容？怎么扩容？<br><br>&emsp;&emsp;答：说了下饱和度过大时需要扩容，每次容量翻一倍。<br><br>&emsp;&emsp;为什么扩容时是翻一倍呢？而不是两倍，三倍？<br><br>&emsp;&emsp;答：（这我就真不知道了😖，一顿乱猜）于是说了下STL内存分配器的特点以及里面内存池的结构可能更适合这样分配，才算糊弄过去😅。<br><br>&emsp;&emsp;服务器中有大量数据需要迁移，如何在不停止对外服务的情况下安全的迁移数据？<br><br>&emsp;&emsp;答：一开始没明白意思，说这个直接复制就行噻😃，<br><br>&emsp;&emsp;然后面试官提醒要是复制的过程中数据被改动了怎么办？<br><br>&emsp;&emsp;答：需要对数据加锁。<br><br>&emsp;&emsp;加锁了不就没法对外服务了吗？<br><br>&emsp;&emsp;答：可以把数据分成许多段，复制某一段的时候就把这一段数据加锁。<br><br>&emsp;&emsp;面试官觉得我越扯越远，就没继续问了。😌<br><br>&emsp;&emsp;谈一下你的职业规划？答略<br><br></details><h3 id="问：找出数组中只出现一次的那个数，其他都出现两次；-异或"><a href="#问：找出数组中只出现一次的那个数，其他都出现两次；-异或" class="headerlink" title="问：找出数组中只出现一次的那个数，其他都出现两次；(异或)"></a><strong>问：找出数组中只出现一次的那个数，其他都出现两次；(异或)</strong></h3><details><br><br>&emsp;&emsp;接上面，如果数组中有两个数只出现一次呢？<br><br></details><h3 id="问：BST中任意两个节点差的最小值"><a href="#问：BST中任意两个节点差的最小值" class="headerlink" title="问：BST中任意两个节点差的最小值"></a><strong>问：BST中任意两个节点差的最小值</strong></h3><details><br><br>&emsp;&emsp;<br><br></details><h3 id="问：判断二叉树是否中心对称"><a href="#问：判断二叉树是否中心对称" class="headerlink" title="问：判断二叉树是否中心对称"></a><strong>问：判断二叉树是否中心对称</strong></h3><details><br><br>&emsp;&emsp;<br><br></details><h3 id="问：大数相乘"><a href="#问：大数相乘" class="headerlink" title="问：大数相乘"></a><strong>问：大数相乘</strong></h3><details><br><br>&emsp;&emsp;<br><br></details><h3 id="问：给我一张纸，画了一个九方格，都填了数字，给一个MN矩阵，从1开始逆时针打印这MN个数，要求时间复杂度尽可能低，可以先说下思路"><a href="#问：给我一张纸，画了一个九方格，都填了数字，给一个MN矩阵，从1开始逆时针打印这MN个数，要求时间复杂度尽可能低，可以先说下思路" class="headerlink" title="问：给我一张纸，画了一个九方格，都填了数字，给一个MN矩阵，从1开始逆时针打印这MN个数，要求时间复杂度尽可能低，可以先说下思路"></a><strong>问：给我一张纸，画了一个九方格，都填了数字，给一个MN矩阵，从1开始逆时针打印这MN个数，要求时间复杂度尽可能低，可以先说下思路</strong></h3><details><br><br>&emsp;&emsp;<br><br></details><h3 id="问：数组A，2-n个元素，n个奇数、n个偶数，设计一个算法，使得数组奇数下标位置放置的都是奇数，偶数下标位置放置的都是偶数。先说下你的思路"><a href="#问：数组A，2-n个元素，n个奇数、n个偶数，设计一个算法，使得数组奇数下标位置放置的都是奇数，偶数下标位置放置的都是偶数。先说下你的思路" class="headerlink" title="问：数组A，2*n个元素，n个奇数、n个偶数，设计一个算法，使得数组奇数下标位置放置的都是奇数，偶数下标位置放置的都是偶数。先说下你的思路"></a><strong>问：数组A，2*n个元素，n个奇数、n个偶数，设计一个算法，使得数组奇数下标位置放置的都是奇数，偶数下标位置放置的都是偶数。先说下你的思路</strong></h3><details><br><br>&emsp;&emsp;<br><br></details><h3 id="问：统计一个字符串的字符出现字数并打印-除了这个还有别的办法吗"><a href="#问：统计一个字符串的字符出现字数并打印-除了这个还有别的办法吗" class="headerlink" title="问：统计一个字符串的字符出现字数并打印?除了这个还有别的办法吗?"></a><strong>问：统计一个字符串的字符出现字数并打印?除了这个还有别的办法吗?</strong></h3><details><br><br>&emsp;&emsp;<br><br></details><h3 id="问：全排列"><a href="#问：全排列" class="headerlink" title="问：全排列?"></a><strong>问：全排列?</strong></h3><details><br><br>&emsp;&emsp;<br><br></details><h3 id="问：假如你正在做淘宝的后台，如何快速查询出1000-2000价格的商品？"><a href="#问：假如你正在做淘宝的后台，如何快速查询出1000-2000价格的商品？" class="headerlink" title="问：假如你正在做淘宝的后台，如何快速查询出1000-2000价格的商品？"></a><strong>问：假如你正在做淘宝的后台，如何快速查询出1000-2000价格的商品？</strong></h3><details><br><br>&emsp;&emsp;<br><br></details><h3 id="问：有一个场景，一个背包里，多个线程往里面移走东西如何保证线程安全？加锁加在什么地方，让你来写代码你怎么写？"><a href="#问：有一个场景，一个背包里，多个线程往里面移走东西如何保证线程安全？加锁加在什么地方，让你来写代码你怎么写？" class="headerlink" title="问：有一个场景，一个背包里，多个线程往里面移走东西如何保证线程安全？加锁加在什么地方，让你来写代码你怎么写？"></a><strong>问：有一个场景，一个背包里，多个线程往里面移走东西如何保证线程安全？加锁加在什么地方，让你来写代码你怎么写？</strong></h3><details><br><br>&emsp;&emsp;<br><br></details><h3 id="问：判断数组里是否有和为指定值的两个数？"><a href="#问：判断数组里是否有和为指定值的两个数？" class="headerlink" title="问：判断数组里是否有和为指定值的两个数？"></a><strong>问：判断数组里是否有和为指定值的两个数？</strong></h3><details><br><br>&emsp;&emsp;<br><br></details><h3 id="问：对笔试题进行提问？有没找到更好的解法吗？"><a href="#问：对笔试题进行提问？有没找到更好的解法吗？" class="headerlink" title="问：对笔试题进行提问？有没找到更好的解法吗？"></a><strong>问：对笔试题进行提问？有没找到更好的解法吗？</strong></h3><details><br><br>&emsp;&emsp;(题目大概是一个数组里除了一个数字出现一次，其它数字都出现了两次，给一个最优解法？我说可以用map，key为数字，value为该数字出现次数？面试官给了一个异或的方法，提示两次异或是本身）<br><br></details><hr><p><em>参考内容均来自网络中网友分享，若内容涉及侵权请及时告知，我会尽快修改和删除相关内容</em></p>]]></content>
    
    <summary type="html">
    
      整理面试中常问的算法相关问题，持续更新中。
    
    </summary>
    
      <category term="面试整理" scheme="http://linyishui.top/categories/%E9%9D%A2%E8%AF%95%E6%95%B4%E7%90%86/"/>
    
    
      <category term="Q&amp;A" scheme="http://linyishui.top/tags/Q-A/"/>
    
  </entry>
  
  <entry>
    <title>面试整理——JVM</title>
    <link href="http://linyishui.top/2019102401.html"/>
    <id>http://linyishui.top/2019102401.html</id>
    <published>2019-10-24T08:06:28.000Z</published>
    <updated>2019-12-13T02:52:58.177Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h2 id="未归类"><a href="#未归类" class="headerlink" title="未归类"></a><strong>未归类</strong></h2><h3 id="问：Java为什么要设计双亲委派模型？"><a href="#问：Java为什么要设计双亲委派模型？" class="headerlink" title="问：Java为什么要设计双亲委派模型？"></a><strong>问：Java为什么要设计双亲委派模型？</strong></h3><details><br><br>&emsp;&emsp;<br><br></details><h3 id="问：谈谈工作中技术优化过哪些？JVM、MySQL、代码等都谈谈？自己做过哪些调优？JVM调优、数据库调优都行"><a href="#问：谈谈工作中技术优化过哪些？JVM、MySQL、代码等都谈谈？自己做过哪些调优？JVM调优、数据库调优都行" class="headerlink" title="问：谈谈工作中技术优化过哪些？JVM、MySQL、代码等都谈谈？自己做过哪些调优？JVM调优、数据库调优都行"></a><strong>问：谈谈工作中技术优化过哪些？JVM、MySQL、代码等都谈谈？自己做过哪些调优？JVM调优、数据库调优都行</strong></h3><details><br><br>&emsp;&emsp;<br><br></details><hr><h2 id="内存模型"><a href="#内存模型" class="headerlink" title="内存模型"></a><strong>内存模型</strong></h2><h3 id="问：简单介绍一下JVM内存模型？"><a href="#问：简单介绍一下JVM内存模型？" class="headerlink" title="问：简单介绍一下JVM内存模型？"></a><strong>问：简单介绍一下JVM内存模型？</strong></h3><details><br><br>&emsp;&emsp;<br><br></details><h3 id="问：讲解新生代和老年代？"><a href="#问：讲解新生代和老年代？" class="headerlink" title="问：讲解新生代和老年代？"></a><strong>问：讲解新生代和老年代？</strong></h3><details><br><br>&emsp;&emsp;<br><br></details><p>说一下JVM的线程模型？这些区域都分别是干啥用的？java线程模型和jvm线程模型注意区分</p><hr><h2 id="垃圾回收"><a href="#垃圾回收" class="headerlink" title="垃圾回收"></a><strong>垃圾回收</strong></h2><h3 id="问：既然jvm有垃圾回收，为什么还会出现内存溢出的情况？"><a href="#问：既然jvm有垃圾回收，为什么还会出现内存溢出的情况？" class="headerlink" title="问：既然jvm有垃圾回收，为什么还会出现内存溢出的情况？"></a><strong>问：既然jvm有垃圾回收，为什么还会出现内存溢出的情况？</strong></h3><details><br><br>&emsp;&emsp;<br><br></details><h3 id="问：简单介绍一下GC垃圾回收算法？说说GC的过程"><a href="#问：简单介绍一下GC垃圾回收算法？说说GC的过程" class="headerlink" title="问：简单介绍一下GC垃圾回收算法？说说GC的过程"></a><strong>问：简单介绍一下GC垃圾回收算法？说说GC的过程</strong></h3><details><br><br>&emsp;&emsp;垃圾回收。如何通知gc回收?（System.gc）除了这个方法还有吗?（将不用的对象赋值为null）<br><br></details><h3 id="问：常见的垃圾回收器？"><a href="#问：常见的垃圾回收器？" class="headerlink" title="问：常见的垃圾回收器？"></a><strong>问：常见的垃圾回收器？</strong></h3><details><br><br>&emsp;&emsp;<br><br></details><h3 id="问：Java-GC机制？GC-Roots有哪些？"><a href="#问：Java-GC机制？GC-Roots有哪些？" class="headerlink" title="问：Java GC机制？GC Roots有哪些？"></a><strong>问：Java GC机制？GC Roots有哪些？</strong></h3><details><br><br>&emsp;&emsp;<br><br></details><h3 id="问：有过GC调优的经历么？"><a href="#问：有过GC调优的经历么？" class="headerlink" title="问：有过GC调优的经历么？"></a><strong>问：有过GC调优的经历么？</strong></h3><details><br><br>&emsp;&emsp;<br><br></details><h3 id="问：强制young-gc会有什么问题？"><a href="#问：强制young-gc会有什么问题？" class="headerlink" title="问：强制young gc会有什么问题？"></a><strong>问：强制young gc会有什么问题？</strong></h3><details><br><br>&emsp;&emsp;<br><br></details><h3 id="问：知道G1么？回收过程是怎么样的？"><a href="#问：知道G1么？回收过程是怎么样的？" class="headerlink" title="问：知道G1么？回收过程是怎么样的？"></a><strong>问：知道G1么？回收过程是怎么样的？</strong></h3><details><br><br>&emsp;&emsp;你提到的Remember Set底层是怎么实现的？CMS GC有什么问题？怎么避免产生浮动垃圾？<br><br></details><h3 id="问：Full-GC-发生的条件、怎么设置永久代和堆的大小、怎么减少-Full-GC-、JVM-调优？"><a href="#问：Full-GC-发生的条件、怎么设置永久代和堆的大小、怎么减少-Full-GC-、JVM-调优？" class="headerlink" title="问：Full GC 发生的条件、怎么设置永久代和堆的大小、怎么减少 Full GC 、JVM 调优？"></a><strong>问：Full GC 发生的条件、怎么设置永久代和堆的大小、怎么减少 Full GC 、JVM 调优？</strong></h3><details><br><br>&emsp;&emsp;<br><br></details><hr><h2 id="类加载"><a href="#类加载" class="headerlink" title="类加载"></a><strong>类加载</strong></h2><h3 id="问：说下类加载的过程？"><a href="#问：说下类加载的过程？" class="headerlink" title="问：说下类加载的过程？"></a><strong>问：说下类加载的过程？</strong></h3><details><br><br>&emsp;&emsp;<br><br></details><h3 id="问：什么时候需要自定义类加载器？"><a href="#问：什么时候需要自定义类加载器？" class="headerlink" title="问：什么时候需要自定义类加载器？"></a><strong>问：什么时候需要自定义类加载器？</strong></h3><details><br><br>&emsp;&emsp;<br><br></details><h3 id="问：Class-forName-是否会初始化类？"><a href="#问：Class-forName-是否会初始化类？" class="headerlink" title="问：Class.forName 是否会初始化类？"></a><strong>问：Class.forName 是否会初始化类？</strong></h3><details><br><br>&emsp;&emsp;这里我智障了，振振有词地说说不会初始化<br><br></details><h3 id="问：static-块会执行几次？怎么让它执行第二次？"><a href="#问：static-块会执行几次？怎么让它执行第二次？" class="headerlink" title="问：static 块会执行几次？怎么让它执行第二次？"></a><strong>问：static 块会执行几次？怎么让它执行第二次？</strong></h3><details><br><br>&emsp;&emsp;<br><br></details><hr><p><em>参考内容均来自网络中网友分享，若内容涉及侵权请及时告知，我会尽快修改和删除相关内容</em></p>]]></content>
    
    <summary type="html">
    
      整理面试中常问的Java虚拟机相关问题，持续更新中。
    
    </summary>
    
      <category term="面试整理" scheme="http://linyishui.top/categories/%E9%9D%A2%E8%AF%95%E6%95%B4%E7%90%86/"/>
    
    
      <category term="Q&amp;A" scheme="http://linyishui.top/tags/Q-A/"/>
    
  </entry>
  
  <entry>
    <title>面试整理——Java网络编程</title>
    <link href="http://linyishui.top/2019102301.html"/>
    <id>http://linyishui.top/2019102301.html</id>
    <published>2019-10-23T08:06:22.000Z</published>
    <updated>2019-12-12T08:12:12.836Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><hr><p><em>参考内容均来自网络中网友分享，若内容涉及侵权请及时告知，我会尽快修改和删除相关内容</em></p>]]></content>
    
    <summary type="html">
    
      整理面试中常问的Java网络编程相关问题，持续更新中。
    
    </summary>
    
      <category term="面试整理" scheme="http://linyishui.top/categories/%E9%9D%A2%E8%AF%95%E6%95%B4%E7%90%86/"/>
    
    
      <category term="Q&amp;A" scheme="http://linyishui.top/tags/Q-A/"/>
    
  </entry>
  
  <entry>
    <title>面试整理——Java并发编程</title>
    <link href="http://linyishui.top/2019102201.html"/>
    <id>http://linyishui.top/2019102201.html</id>
    <published>2019-10-22T08:06:16.000Z</published>
    <updated>2019-12-13T02:41:04.317Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h2 id="未归类"><a href="#未归类" class="headerlink" title="未归类"></a><strong>未归类</strong></h2><hr><h2 id="锁"><a href="#锁" class="headerlink" title="锁"></a><strong>锁</strong></h2><h3 id="问：讲讲你知道的锁？"><a href="#问：讲讲你知道的锁？" class="headerlink" title="问：讲讲你知道的锁？"></a><strong>问：讲讲你知道的锁？</strong></h3><details><br><br>&emsp;&emsp;<br><br></details><h3 id="问：谈一下悲观锁和乐观锁？"><a href="#问：谈一下悲观锁和乐观锁？" class="headerlink" title="问：谈一下悲观锁和乐观锁？"></a><strong>问：谈一下悲观锁和乐观锁？</strong></h3><details><br><br>&emsp;&emsp;JDK中涉及到乐观锁和悲观锁的内容？这两种锁在Java和MySQL分别是怎么实现的？<br><br></details><h3 id="问：讲讲ReentrantLock实现原理？"><a href="#问：讲讲ReentrantLock实现原理？" class="headerlink" title="问：讲讲ReentrantLock实现原理？"></a><strong>问：讲讲ReentrantLock实现原理？</strong></h3><details><br><br>&emsp;&emsp;<br><br></details><h3 id="问：讲讲AQS？讲讲AQS怎么实现的Fair和NoFair？"><a href="#问：讲讲AQS？讲讲AQS怎么实现的Fair和NoFair？" class="headerlink" title="问：讲讲AQS？讲讲AQS怎么实现的Fair和NoFair？"></a><strong>问：讲讲AQS？讲讲AQS怎么实现的Fair和NoFair？</strong></h3><details><br><br>&emsp;&emsp;<br><br></details><h3 id="问：synchronized-和-ReentranLock的区别？"><a href="#问：synchronized-和-ReentranLock的区别？" class="headerlink" title="问：synchronized 和 ReentranLock的区别？"></a><strong>问：synchronized 和 ReentranLock的区别？</strong></h3><details><br><br>&emsp;&emsp;<br><br></details><h3 id="问：sychronized和lock有什么区别？"><a href="#问：sychronized和lock有什么区别？" class="headerlink" title="问：sychronized和lock有什么区别？"></a><strong>问：sychronized和lock有什么区别？</strong></h3><details><br><br>&emsp;&emsp;<br><br></details><h3 id="问：CAS和synchronize有什么区别？都用synchronize不行么？"><a href="#问：CAS和synchronize有什么区别？都用synchronize不行么？" class="headerlink" title="问：CAS和synchronize有什么区别？都用synchronize不行么？"></a><strong>问：CAS和synchronize有什么区别？都用synchronize不行么？</strong></h3><details><br><br>&emsp;&emsp;<br><br></details><h3 id="问：ConcurrentHashMap的get需要加锁么，为什么？"><a href="#问：ConcurrentHashMap的get需要加锁么，为什么？" class="headerlink" title="问：ConcurrentHashMap的get需要加锁么，为什么？"></a><strong>问：ConcurrentHashMap的get需要加锁么，为什么？</strong></h3><details><br><br>&emsp;&emsp;<br><br></details><h3 id="问：volatile的作用是什么？"><a href="#问：volatile的作用是什么？" class="headerlink" title="问：volatile的作用是什么？"></a><strong>问：volatile的作用是什么？</strong></h3><details><br><br>&emsp;&emsp;<br><br></details><h3 id="问：用过CountDownLatch么？什么场景下用的？"><a href="#问：用过CountDownLatch么？什么场景下用的？" class="headerlink" title="问：用过CountDownLatch么？什么场景下用的？"></a><strong>问：用过CountDownLatch么？什么场景下用的？</strong></h3><details><br><br>&emsp;&emsp;<br><br></details><h3 id="问：死锁产生的原因？如何预防？"><a href="#问：死锁产生的原因？如何预防？" class="headerlink" title="问：死锁产生的原因？如何预防？"></a><strong>问：死锁产生的原因？如何预防？</strong></h3><details><br><br>&emsp;&emsp;<br><br></details><h3 id="问：加锁会带来哪些性能问题。如何解决？"><a href="#问：加锁会带来哪些性能问题。如何解决？" class="headerlink" title="问：加锁会带来哪些性能问题。如何解决？"></a><strong>问：加锁会带来哪些性能问题。如何解决？</strong></h3><details><br><br>&emsp;&emsp;<br><br></details><hr><h2 id="线程"><a href="#线程" class="headerlink" title="线程"></a><strong>线程</strong></h2><h3 id="问：线程和进程的区别？"><a href="#问：线程和进程的区别？" class="headerlink" title="问：线程和进程的区别？"></a><strong>问：线程和进程的区别？</strong></h3><details><br><br>&emsp;&emsp;<br><br></details><h3 id="问：什么时候用线程？"><a href="#问：什么时候用线程？" class="headerlink" title="问：什么时候用线程？"></a><strong>问：什么时候用线程？</strong></h3><details><br><br>&emsp;&emsp;<br><br></details><h3 id="问：如何创建子进程？"><a href="#问：如何创建子进程？" class="headerlink" title="问：如何创建子进程？"></a><strong>问：如何创建子进程？</strong></h3><details><br><br>&emsp;&emsp;<br><br></details><h3 id="问：谈一下线程切换，并引申到Java阻塞，运行？"><a href="#问：谈一下线程切换，并引申到Java阻塞，运行？" class="headerlink" title="问：谈一下线程切换，并引申到Java阻塞，运行？"></a><strong>问：谈一下线程切换，并引申到Java阻塞，运行？</strong></h3><details><br><br>&emsp;&emsp;<br><br></details><h3 id="问：谈一下ThreadLocal？应用场景？"><a href="#问：谈一下ThreadLocal？应用场景？" class="headerlink" title="问：谈一下ThreadLocal？应用场景？"></a><strong>问：谈一下ThreadLocal？应用场景？</strong></h3><details><br><br>&emsp;&emsp;<br><br></details><h3 id="问：谈一下对线程安全的理解？用什么方法保证线程的安全？"><a href="#问：谈一下对线程安全的理解？用什么方法保证线程的安全？" class="headerlink" title="问：谈一下对线程安全的理解？用什么方法保证线程的安全？"></a><strong>问：谈一下对线程安全的理解？用什么方法保证线程的安全？</strong></h3><details><br><br>&emsp;&emsp;<br><br></details><h3 id="问：CAS了解么？还了解其他同步机制么？"><a href="#问：CAS了解么？还了解其他同步机制么？" class="headerlink" title="问：CAS了解么？还了解其他同步机制么？"></a><strong>问：CAS了解么？还了解其他同步机制么？</strong></h3><details><br><br>&emsp;&emsp;<br><br></details><h3 id="问：Thread类里有哪些常用方法？wait和sleep有什么区别？"><a href="#问：Thread类里有哪些常用方法？wait和sleep有什么区别？" class="headerlink" title="问：Thread类里有哪些常用方法？wait和sleep有什么区别？"></a><strong>问：Thread类里有哪些常用方法？wait和sleep有什么区别？</strong></h3><details><br><br>&emsp;&emsp;<br><br></details><h3 id="问：项目的用户量多吗？有用过线程池吗？用到多线程的优势在哪？"><a href="#问：项目的用户量多吗？有用过线程池吗？用到多线程的优势在哪？" class="headerlink" title="问：项目的用户量多吗？有用过线程池吗？用到多线程的优势在哪？"></a><strong>问：项目的用户量多吗？有用过线程池吗？用到多线程的优势在哪？</strong></h3><details><br><br>&emsp;&emsp;<br><br></details><h3 id="问：如何实现一个线程池，Java中线程池如何进行配置？线程池的线程数怎么确定？"><a href="#问：如何实现一个线程池，Java中线程池如何进行配置？线程池的线程数怎么确定？" class="headerlink" title="问：如何实现一个线程池，Java中线程池如何进行配置？线程池的线程数怎么确定？"></a><strong>问：如何实现一个线程池，Java中线程池如何进行配置？线程池的线程数怎么确定？</strong></h3><details><br><br>&emsp;&emsp;如果是IO操作为主怎么确定？如果计算型操作又怎么确定？跳表的查询过程是怎么样的，查询和插入的时间复杂度?<br><br></details><h3 id="问：如何实现一个线程池，Java中线程池如何进行配置？线程池的核心参数记得吗？线程池的工作流程记得吗？"><a href="#问：如何实现一个线程池，Java中线程池如何进行配置？线程池的核心参数记得吗？线程池的工作流程记得吗？" class="headerlink" title="问：如何实现一个线程池，Java中线程池如何进行配置？线程池的核心参数记得吗？线程池的工作流程记得吗？"></a><strong>问：如何实现一个线程池，Java中线程池如何进行配置？线程池的核心参数记得吗？线程池的工作流程记得吗？</strong></h3><details><br><br>&emsp;&emsp;<br><br></details><h3 id="问：线程池里如何知道线程执行完了没有？线程阻塞怎么办？怎么保证所有线程执行完之后继续往下处理？怎么让一个线程等另一个线程执行结束？"><a href="#问：线程池里如何知道线程执行完了没有？线程阻塞怎么办？怎么保证所有线程执行完之后继续往下处理？怎么让一个线程等另一个线程执行结束？" class="headerlink" title="问：线程池里如何知道线程执行完了没有？线程阻塞怎么办？怎么保证所有线程执行完之后继续往下处理？怎么让一个线程等另一个线程执行结束？"></a><strong>问：线程池里如何知道线程执行完了没有？线程阻塞怎么办？怎么保证所有线程执行完之后继续往下处理？怎么让一个线程等另一个线程执行结束？</strong></h3><details><br><br>&emsp;&emsp;答了CountdownLatch和CyclicBarrier，之后提示可以利用Thread的join方法<br><br></details><h3 id="问：线程间的通信可以怎么做？线程间相互通知你会怎么做，代码要怎么实现？"><a href="#问：线程间的通信可以怎么做？线程间相互通知你会怎么做，代码要怎么实现？" class="headerlink" title="问：线程间的通信可以怎么做？线程间相互通知你会怎么做，代码要怎么实现？"></a><strong>问：线程间的通信可以怎么做？线程间相互通知你会怎么做，代码要怎么实现？</strong></h3><details><br><br>&emsp;&emsp;答了synchronized和Object的wait和notify，强调了notify是随机，All是全部，然后问All怎么个全部法，全部唤醒都开始执行不就不安全了吗？<br><br></details><hr><p><em>参考内容均来自网络中网友分享，若内容涉及侵权请及时告知，我会尽快修改和删除相关内容</em></p>]]></content>
    
    <summary type="html">
    
      整理面试中常问的Java并发编程相关问题，持续更新中。
    
    </summary>
    
      <category term="面试整理" scheme="http://linyishui.top/categories/%E9%9D%A2%E8%AF%95%E6%95%B4%E7%90%86/"/>
    
    
      <category term="Q&amp;A" scheme="http://linyishui.top/tags/Q-A/"/>
    
  </entry>
  
  <entry>
    <title>面试整理——Java集合</title>
    <link href="http://linyishui.top/2019102101.html"/>
    <id>http://linyishui.top/2019102101.html</id>
    <published>2019-10-21T08:06:06.000Z</published>
    <updated>2019-12-13T02:44:01.619Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h2 id="未归类"><a href="#未归类" class="headerlink" title="未归类"></a><strong>未归类</strong></h2><h3 id="问：平常用到哪些集合类？"><a href="#问：平常用到哪些集合类？" class="headerlink" title="问：平常用到哪些集合类？"></a><strong>问：平常用到哪些集合类？</strong></h3><details><br><br>&emsp;&emsp;答：ArrayList，LinkedList，HashSet，HashMap，TreeMap等（补充：ArrayQueue，PriorityQueue，TreeSet，EnumSet，LinkedHashSet，EnumMap，LinkedHashMap，WeakHashMap，IdentityHashMap）<br><br>&emsp;&emsp;<a href="../2019040901.html" title="Title">Java集合(一) 概述</a><br><br></details><h3 id="问：了解了哪些并发安全集合，从list到map都讲一下？"><a href="#问：了解了哪些并发安全集合，从list到map都讲一下？" class="headerlink" title="问：了解了哪些并发安全集合，从list到map都讲一下？"></a><strong>问：了解了哪些并发安全集合，从list到map都讲一下？</strong></h3><details><br><br>&emsp;&emsp;答：<br><br></details><hr><h2 id="List"><a href="#List" class="headerlink" title="List"></a><strong>List</strong></h2><h3 id="问：ArrayList的实现？怎么扩容？怎么插入？怎么删除？在遍历ArrayList时，删除元素会发生什么？LinkedList呢？"><a href="#问：ArrayList的实现？怎么扩容？怎么插入？怎么删除？在遍历ArrayList时，删除元素会发生什么？LinkedList呢？" class="headerlink" title="问：ArrayList的实现？怎么扩容？怎么插入？怎么删除？在遍历ArrayList时，删除元素会发生什么？LinkedList呢？"></a><strong>问：ArrayList的实现？怎么扩容？怎么插入？怎么删除？在遍历ArrayList时，删除元素会发生什么？LinkedList呢？</strong></h3><details><br><br>&emsp;&emsp;<br><br></details><h3 id="问：ArrayList和LinkedList区别？链表和数组的优缺点？"><a href="#问：ArrayList和LinkedList区别？链表和数组的优缺点？" class="headerlink" title="问：ArrayList和LinkedList区别？链表和数组的优缺点？"></a><strong>问：ArrayList和LinkedList区别？链表和数组的优缺点？</strong></h3><details><br><br>&emsp;&emsp;答：ArrayList是动态索引数组，LinkedList则是有序链表。前者可以快速随机访问，后者则会较慢。但链表更方便删除，因为只要局部变动。所以数组易查难改，链表易改难查。LinkedList通过迭代器进行插入操作。<br><br></details><h3 id="问：LinkedList还是LinkedHashMap用过吗？存进集合如何比较大小保证顺序？"><a href="#问：LinkedList还是LinkedHashMap用过吗？存进集合如何比较大小保证顺序？" class="headerlink" title="问：LinkedList还是LinkedHashMap用过吗？存进集合如何比较大小保证顺序？"></a><strong>问：LinkedList还是LinkedHashMap用过吗？存进集合如何比较大小保证顺序？</strong></h3><details><br><br>&emsp;&emsp;答：可以用来实现LRU<br><br></details><hr><h2 id="Set"><a href="#Set" class="headerlink" title="Set"></a><strong>Set</strong></h2><hr><h2 id="Map"><a href="#Map" class="headerlink" title="Map"></a><strong>Map</strong></h2><h3 id="问：能讲讲HashMap的实现原理吗？hashmap的底层是什么？HashMap内部数据结构？HashMap如何存值？解决hash冲突的方法有哪些？"><a href="#问：能讲讲HashMap的实现原理吗？hashmap的底层是什么？HashMap内部数据结构？HashMap如何存值？解决hash冲突的方法有哪些？" class="headerlink" title="问：能讲讲HashMap的实现原理吗？hashmap的底层是什么？HashMap内部数据结构？HashMap如何存值？解决hash冲突的方法有哪些？"></a><strong>问：能讲讲HashMap的实现原理吗？hashmap的底层是什么？HashMap内部数据结构？HashMap如何存值？解决hash冲突的方法有哪些？</strong></h3><details><br><br>&emsp;&emsp;HashMap。<br><br></details><h3 id="问：hashmap查询的时间复杂度能达到O-1-是什么实现的？里面的索引是怎么计算的？"><a href="#问：hashmap查询的时间复杂度能达到O-1-是什么实现的？里面的索引是怎么计算的？" class="headerlink" title="问：hashmap查询的时间复杂度能达到O(1)是什么实现的？里面的索引是怎么计算的？"></a><strong>问：hashmap查询的时间复杂度能达到O(1)是什么实现的？里面的索引是怎么计算的？</strong></h3><details><br><br>&emsp;&emsp;HashMap。<br><br></details><h3 id="问：HashMap多线程有什么问题？怎么解决？"><a href="#问：HashMap多线程有什么问题？怎么解决？" class="headerlink" title="问：HashMap多线程有什么问题？怎么解决？"></a><strong>问：HashMap多线程有什么问题？怎么解决？</strong></h3><details><br><br>&emsp;&emsp;<br><br></details><h3 id="问：HashMap什么时候会进行rehash？"><a href="#问：HashMap什么时候会进行rehash？" class="headerlink" title="问：HashMap什么时候会进行rehash？"></a><strong>问：HashMap什么时候会进行rehash？</strong></h3><details><br><br>&emsp;&emsp;<br><br></details><h3 id="问：HashMap什么时候会进行扩容？"><a href="#问：HashMap什么时候会进行扩容？" class="headerlink" title="问：HashMap什么时候会进行扩容？"></a><strong>问：HashMap什么时候会进行扩容？</strong></h3><details><br><br>&emsp;&emsp;<br><br></details><h3 id="问：HashMap的初始容量设置成多少比较合适呢？"><a href="#问：HashMap的初始容量设置成多少比较合适呢？" class="headerlink" title="问：HashMap的初始容量设置成多少比较合适呢？"></a><strong>问：HashMap的初始容量设置成多少比较合适呢？</strong></h3><details><br><br>&emsp;&emsp;<br><br></details><h3 id="问：结合源码说说HashMap在高并发场景中为什么会出现死循环？"><a href="#问：结合源码说说HashMap在高并发场景中为什么会出现死循环？" class="headerlink" title="问：结合源码说说HashMap在高并发场景中为什么会出现死循环？"></a><strong>问：结合源码说说HashMap在高并发场景中为什么会出现死循环？</strong></h3><details><br><br>&emsp;&emsp;<br><br></details><h3 id="问：HashMap和HashTable有何不同？"><a href="#问：HashMap和HashTable有何不同？" class="headerlink" title="问：HashMap和HashTable有何不同？"></a><strong>问：HashMap和HashTable有何不同？</strong></h3><details><br><br>&emsp;&emsp;HashMap为什么不是线程安全的？怎么让HashMap变得线程安全？<br><br></details><h3 id="问：HashMap-和-WeakHashMap-的区别？"><a href="#问：HashMap-和-WeakHashMap-的区别？" class="headerlink" title="问：HashMap 和 WeakHashMap 的区别？"></a><strong>问：HashMap 和 WeakHashMap 的区别？</strong></h3><details><br><br>&emsp;&emsp;<br><br></details><h3 id="问：HashMap-和-ConcurrentHashMap-的区别？"><a href="#问：HashMap-和-ConcurrentHashMap-的区别？" class="headerlink" title="问：HashMap 和 ConcurrentHashMap 的区别？"></a><strong>问：HashMap 和 ConcurrentHashMap 的区别？</strong></h3><details><br><br>&emsp;&emsp;<br><br></details><h3 id="问：jdk1-8中，对hashMap和concurrentHashMap做了哪些优化？"><a href="#问：jdk1-8中，对hashMap和concurrentHashMap做了哪些优化？" class="headerlink" title="问：jdk1.8中，对hashMap和concurrentHashMap做了哪些优化？"></a><strong>问：jdk1.8中，对hashMap和concurrentHashMap做了哪些优化？</strong></h3><details><br><br>&emsp;&emsp;<br><br></details><h3 id="问：讲讲TreeMap？"><a href="#问：讲讲TreeMap？" class="headerlink" title="问：讲讲TreeMap？"></a><strong>问：讲讲TreeMap？</strong></h3><details><br><br>&emsp;&emsp;<br><br></details><h3 id="问：TreeMap查询写入的时间复杂度多少？"><a href="#问：TreeMap查询写入的时间复杂度多少？" class="headerlink" title="问：TreeMap查询写入的时间复杂度多少？"></a><strong>问：TreeMap查询写入的时间复杂度多少？</strong></h3><details><br><br>&emsp;&emsp;<br><br></details><h3 id="问：ConcurrentHashMap分段锁？"><a href="#问：ConcurrentHashMap分段锁？" class="headerlink" title="问：ConcurrentHashMap分段锁？"></a><strong>问：ConcurrentHashMap分段锁？</strong></h3><details><br><br>&emsp;&emsp;<br><br></details><h3 id="问：如何解决hash冲突的，以及如果冲突了，怎么在hash表中找到目标值？"><a href="#问：如何解决hash冲突的，以及如果冲突了，怎么在hash表中找到目标值？" class="headerlink" title="问：如何解决hash冲突的，以及如果冲突了，怎么在hash表中找到目标值？"></a><strong>问：如何解决hash冲突的，以及如果冲突了，怎么在hash表中找到目标值？</strong></h3><details><br><br>&emsp;&emsp;<br><br></details><h3 id="问：ConcurrentHashMap和LinkedHashMap有什么区别？"><a href="#问：ConcurrentHashMap和LinkedHashMap有什么区别？" class="headerlink" title="问：ConcurrentHashMap和LinkedHashMap有什么区别？"></a><strong>问：ConcurrentHashMap和LinkedHashMap有什么区别？</strong></h3><details><br><br>&emsp;&emsp;<br><br></details><h3 id="问：为什么ConcurrentHashMap中的链表转红黑树的阀值是8？"><a href="#问：为什么ConcurrentHashMap中的链表转红黑树的阀值是8？" class="headerlink" title="问：为什么ConcurrentHashMap中的链表转红黑树的阀值是8？"></a><strong>问：为什么ConcurrentHashMap中的链表转红黑树的阀值是8？</strong></h3><details><br><br>&emsp;&emsp;<br><br></details><h3 id="问：什么是ConcurrentSkipListMap？他和ConcurrentHashMap有什么区别？"><a href="#问：什么是ConcurrentSkipListMap？他和ConcurrentHashMap有什么区别？" class="headerlink" title="问：什么是ConcurrentSkipListMap？他和ConcurrentHashMap有什么区别？"></a><strong>问：什么是ConcurrentSkipListMap？他和ConcurrentHashMap有什么区别？</strong></h3><details><br><br>&emsp;&emsp;<br><br></details><h3 id="问：ConcurrentHashMap怎么实现线程安全的？"><a href="#问：ConcurrentHashMap怎么实现线程安全的？" class="headerlink" title="问：ConcurrentHashMap怎么实现线程安全的？"></a><strong>问：ConcurrentHashMap怎么实现线程安全的？</strong></h3><details><br><br>&emsp;&emsp;<br><br></details><hr><p><em>参考内容均来自网络中网友分享，若内容涉及侵权请及时告知，我会尽快修改和删除相关内容</em></p>]]></content>
    
    <summary type="html">
    
      整理面试中常问的Java集合相关问题，持续更新中。
    
    </summary>
    
      <category term="面试整理" scheme="http://linyishui.top/categories/%E9%9D%A2%E8%AF%95%E6%95%B4%E7%90%86/"/>
    
    
      <category term="Q&amp;A" scheme="http://linyishui.top/tags/Q-A/"/>
    
  </entry>
  
  <entry>
    <title>面试整理——Java基础</title>
    <link href="http://linyishui.top/2019102002.html"/>
    <id>http://linyishui.top/2019102002.html</id>
    <published>2019-10-20T08:05:59.000Z</published>
    <updated>2019-12-12T14:38:32.471Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h2 id="数据类型"><a href="#数据类型" class="headerlink" title="数据类型"></a><strong>数据类型</strong></h2><h3 id="问：java的基本类型有哪几个？各自占了多少位？"><a href="#问：java的基本类型有哪几个？各自占了多少位？" class="headerlink" title="问：java的基本类型有哪几个？各自占了多少位？"></a><strong>问：java的基本类型有哪几个？各自占了多少位？</strong></h3><details><br><br>&emsp;&emsp;答：8个：byte，short，int，long，float，double，boolean，char<br><br>&emsp;&emsp;byte是8位，short是16位，int是32位，long是64位，float是32位（单精度），double是64位（双精度），boolean是1位，char则是16位Unicode字符<br><br></details><h3 id="问：货币用哪种数据类型？"><a href="#问：货币用哪种数据类型？" class="headerlink" title="问：货币用哪种数据类型？"></a><strong>问：货币用哪种数据类型？</strong></h3><details><br><br>&emsp;&emsp;答：BigDecimal，因为浮点数表示近似值，而BigDecimal则可以表示精确的浮点数。<br><br></details><hr><h2 id="字符串"><a href="#字符串" class="headerlink" title="字符串"></a><strong>字符串</strong></h2><h3 id="问：String是不是java的基本类型？"><a href="#问：String是不是java的基本类型？" class="headerlink" title="问：String是不是java的基本类型？"></a><strong>问：String是不是java的基本类型？</strong></h3><details><br><br>&emsp;&emsp;答：不是，String是引用类型，虽然有常量的一些特性。<br><br></details><h3 id="问：String为什么要是final类型的？"><a href="#问：String为什么要是final类型的？" class="headerlink" title="问：String为什么要是final类型的？"></a><strong>问：String为什么要是final类型的？</strong></h3><details><br><br>&emsp;&emsp;答：要保证字符串的不可变性，而字符串常量池的设计采用享元模式，需要字符串的不可变性。假如字符串可变，共享元素在一处被改变，所有使用者都会感知到变化。如果字符串可变性会使软件安全性降低，不可变就意味着不会被篡改，同样也意味着线程安全。<br><br></details><hr><h2 id="未归类"><a href="#未归类" class="headerlink" title="未归类"></a><strong>未归类</strong></h2><h3 id="问：面向对象的三大特性-分别是怎么使用的，给个例子"><a href="#问：面向对象的三大特性-分别是怎么使用的，给个例子" class="headerlink" title="问：面向对象的三大特性?分别是怎么使用的，给个例子?"></a><strong>问：面向对象的三大特性?分别是怎么使用的，给个例子?</strong></h3><details><br><br>&emsp;&emsp;答：封装，继承和多态。<br><br>&emsp;&emsp;比如类把属性和行为封装起来，只提供公共方法被外界访问。<br><br>&emsp;&emsp;比如父子类间的继承关系，子类继承父类的属性方法。<br><br>&emsp;&emsp;比如子类通过继承并重写父类方法，同样的方法会有不同的实现。<br><br></details><h3 id="问：讲一下重载和重写"><a href="#问：讲一下重载和重写" class="headerlink" title="问：讲一下重载和重写?"></a><strong>问：讲一下重载和重写?</strong></h3><details><br><br>&emsp;&emsp;答：重载是：同一类中，用相同的方法名，但参数个数或数据类型不同，返回值、访问修饰和抛出异常可以相同也可以不同，<br><br>&emsp;&emsp;重写则是：不同类中，子类继承父类方法，有相同的方法描述，但会受限于父类的访问修饰类型，且子类的访问修饰要更大。<br><br></details><h3 id="问：谈下hashcode和equals的用法及区别？为什么重写equals方法时还要重写hashcode方法？"><a href="#问：谈下hashcode和equals的用法及区别？为什么重写equals方法时还要重写hashcode方法？" class="headerlink" title="问：谈下hashcode和equals的用法及区别？为什么重写equals方法时还要重写hashcode方法？"></a><strong>问：谈下hashcode和equals的用法及区别？为什么重写equals方法时还要重写hashcode方法？</strong></h3><details><br><br>&emsp;&emsp;哈希值相等的两个对象未必是相等的（哈希冲突），并不是百分百可靠，而equals方法则默认判断引用地址，重写后则根据实现进行相等性判断。所以hashcode相等，equals未必相等。因为hashcode进行比较效率较高，所以可以先判断hashcode，<br><br>&emsp;&emsp;但equals相等应该让hashcode也相等，否则会在许多场景下出错（Set或HashMap取值），所以重写equals时也要重写hashcode。<br><br>&emsp;&emsp;<a href="../2018123101.html" title="Title">equals和hashCode异同</a><br><br></details><h3 id="问：说下如何操控文件-（输入输出）怎么关闭呢-（在finally关闭），发生异常怎么办"><a href="#问：说下如何操控文件-（输入输出）怎么关闭呢-（在finally关闭），发生异常怎么办" class="headerlink" title="问：说下如何操控文件?（输入输出）怎么关闭呢?（在finally关闭），发生异常怎么办?"></a><strong>问：说下如何操控文件?（输入输出）怎么关闭呢?（在finally关闭），发生异常怎么办?</strong></h3><details><br><br>&emsp;&emsp;<br><br></details><h3 id="问：讲讲序列化？"><a href="#问：讲讲序列化？" class="headerlink" title="问：讲讲序列化？"></a><strong>问：讲讲序列化？</strong></h3><details><br><br>&emsp;&emsp;<br><br></details><h3 id="问：深拷贝与浅拷贝？"><a href="#问：深拷贝与浅拷贝？" class="headerlink" title="问：深拷贝与浅拷贝？"></a><strong>问：深拷贝与浅拷贝？</strong></h3><details><br><br>&emsp;&emsp;<br><br></details><h3 id="问：java8有了解吗？"><a href="#问：java8有了解吗？" class="headerlink" title="问：java8有了解吗？"></a><strong>问：java8有了解吗？</strong></h3><details><br><br>&emsp;&emsp;<br><br></details><hr><p><em>参考内容均来自网络中网友分享，若内容涉及侵权请及时告知，我会尽快修改和删除相关内容</em></p>]]></content>
    
    <summary type="html">
    
      整理面试中常问的Java基础相关问题，持续更新中。
    
    </summary>
    
      <category term="面试整理" scheme="http://linyishui.top/categories/%E9%9D%A2%E8%AF%95%E6%95%B4%E7%90%86/"/>
    
    
      <category term="Q&amp;A" scheme="http://linyishui.top/tags/Q-A/"/>
    
  </entry>
  
  <entry>
    <title>面经整理——导航页</title>
    <link href="http://linyishui.top/2019102001.html"/>
    <id>http://linyishui.top/2019102001.html</id>
    <published>2019-10-20T07:53:31.000Z</published>
    <updated>2019-12-12T10:52:02.752Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>&emsp;&emsp;答案基本上是博主自答，受限于当前知识水平和闲暇时间，如果有错误或纰漏请包涵。</p><h1 id="Java面试题目"><a href="#Java面试题目" class="headerlink" title="Java面试题目"></a><strong>Java面试题目</strong></h1><h2 id="Java语言"><a href="#Java语言" class="headerlink" title="Java语言"></a><strong>Java语言</strong></h2><p>&emsp;&emsp;<a href="../2019102002.html" title="Title">面试整理——Java基础</a></p><p>&emsp;&emsp;<a href="../2019102101.html" title="Title">面试整理——Java集合</a></p><p>&emsp;&emsp;<a href="../2019102201.html" title="Title">面试整理——Java并发编程</a></p><p>&emsp;&emsp;<a href="../2019102301.html" title="Title">面试整理——Java网络编程</a></p><p>&emsp;&emsp;<a href="../2019102401.html" title="Title">面试整理——JVM</a></p><hr><h2 id="算法"><a href="#算法" class="headerlink" title="算法"></a><strong>算法</strong></h2><p>&emsp;&emsp;<a href="../2019102501.html" title="Title">面试整理——算法</a></p><hr><h2 id="网络"><a href="#网络" class="headerlink" title="网络"></a><strong>网络</strong></h2><p>&emsp;&emsp;<a href="../2019102601.html" title="Title">面试整理——网络</a></p><hr><h2 id="操作系统"><a href="#操作系统" class="headerlink" title="操作系统"></a><strong>操作系统</strong></h2><p>&emsp;&emsp;<a href="../2019102701.html" title="Title">面试整理——操作系统</a></p><hr><h2 id="分布式"><a href="#分布式" class="headerlink" title="分布式"></a><strong>分布式</strong></h2><p>&emsp;&emsp;<a href="../2019102801.html" title="Title">面试整理——分布式</a></p><hr><h2 id="数据库"><a href="#数据库" class="headerlink" title="数据库"></a><strong>数据库</strong></h2><p>&emsp;&emsp;<a href="../2019102901.html" title="Title">面试整理——数据库</a></p><hr><h2 id="Java框架"><a href="#Java框架" class="headerlink" title="Java框架"></a><strong>Java框架</strong></h2><h3 id="Spring"><a href="#Spring" class="headerlink" title="Spring"></a><strong>Spring</strong></h3><p>&emsp;&emsp;<a href="../2019110101.html" title="Title">面试整理——Spring</a></p><h3 id="Spring-Boot"><a href="#Spring-Boot" class="headerlink" title="Spring Boot"></a><strong>Spring Boot</strong></h3><p>&emsp;&emsp;未完待续</p><h3 id="Spring-Cloud"><a href="#Spring-Cloud" class="headerlink" title="Spring Cloud"></a><strong>Spring Cloud</strong></h3><p>&emsp;&emsp;未完待续</p><!--Hashmap源码级掌握，扩容，红黑树，最小树化容量，hash 冲突解决，有些面试官会提出发自灵魂的审问，比如为什么是红黑树，别的树不可以吗；为什么 8 的时候树化，4 不可以吗，等等concureentHashMap，段锁，如何分段，和 hashmap 在 hash 上的区别，性能，等等HashTable，同步锁，这块可能会问你 synchronized 关键字 1.6 之后提升了什么，怎么提升的这些ArrayList 优势，扩容，什么时候用LinkedList 优势，什么时候用，和 arraylist 的区别 等等基本类型和包装类型的区别，涉及自动装箱和拆箱，怎么做的，原理String，StringBuffer，StringBuilder哪个是安全的字符串编码的区别，被问到过，我觉得比较容易被忽视的一个点什么是泛型，怎么用泛型static 能不能修饰 threadLocal，为什么，这道题我当时一听到其实挺懵逼的Comparable 和 Comparator 接口是干什么的，其区别多态的原理是什么，感觉这个很容易被问到接口和抽象类，面试官问我是怎么理解的，我说接口对应功能，抽象类对应属性，然后面试官给我说了他的看法，说抽象类更偏向于一种模板~ 然后又交流了一下各自的想法如何通过反射和设置对象私有字段的值快速失败(fail-fast)和安全失败(fail-safe)的区别是什么synchronized 的实现原理以及锁优化？volatile 的实现原理？Java 的信号灯？synchronized 在静态方法和普通方法的区别？怎么实现所有线程在等待某个事件的发生才会去执行？CAS ？ CAS 有什么缺陷，如何解决？synchronized 和 lock 有什么区别？Hashtable 是怎么加锁的 ？List，Map，Set 接口在取元素师，各有什么特点如何线程安全的实现一个计数器生产者消费者模式，要求手写过代码，还是要知道的单例模式，饿汉式，懒汉式，线程安全的做法，两次判断 instance 是否为空，每次判断的作用是什么。线程池，这个还是很重要的，在生产中用的挺多，四个线程池类型，其参数，参数的理解很重要，corepoolSize 怎么设置，maxpoolsize 怎么设置，keep-alive 各种的，和美团面试官探讨过阻塞队列在生产中的设置，他说他一般设置为 0，防止用户阻塞cyclicbarrier 和 countdownlatch 的区别，个人理解 赛马和点火箭线程回调，这块 被问过让我设计一个 RPC，怎么实现，其实用到了回调这块的东西sleep 和 yeild 方法有什么区别volatile 关键字，可见性。乐观锁和悲观锁的使用场景悲观锁的常见实现方式：lock synchronized retreentlock乐观锁：CAS MVCC读写锁的实现方式，16 位 int 的前八位和后八位分别作为读锁和写锁的标志位死锁的条件，怎么解除死锁，怎么观测死锁。希望大家能够好好看一下反射的原理，怎么确定类，怎么调方法RPC 框架，同步异步，响应时间，这些都被问到过，还让设计过同步，异步，阻塞，非阻塞 在深信服的面试中遇到过，最好再找一些应用场景加以理解下面这些开个胃先## JAVA 基础1. HashMap 的源码，实现原理； JDK8 做了什么优化2. HashMap 扩容机制，为什么都是 2 的 N 次幂3. ArrayList 和 Vector 的区别，扩容机制等4. CopyOnWriteArrayList 原理5. HashSet 和 TreeSet 原理6. ArrayBlockingQueue 和 LinkedBlockingQueue 区别7. 集合迭代器的原理8. 传值和传引用的区别9. 动态代理10. JDK8 ConcurrentHashMap 的原理## 多线程1. 创建多线程的方式，以及线程的状态转换2. 线程的中断机制3. ThreadPoolExecutor 初始化参数； Executors 静态方法4. synchronized 的使用方式及原理5. 偏向锁、轻量级锁、自旋锁等优化6. ReentrantLock 的特点及 AQS 原理7. Semaphore、CountDownLatch、CyclicBarrier 等使用8. ThreadLocal 的原理、与 Thread 类的关系、以及内存泄漏问题9. volatile 的原理及内存屏障相关10. Lock 接口有哪些实现类，使用场景是什么11. 悲观锁，乐观锁，优缺点，CAS 有什么缺陷，该如何解决12. ABC 三个线程如何保证顺序执行13. 生产者消费者模式的实现方式14. 如何实现控制线程在某段时间内完成，不完成就撤销## JVM1. JVM 的内存区域2. 字符串常量池相关3. 对象的内存布局，涉及到锁的部分4. 类加载的过程，以及双亲委派机制、自定义类加载器5. GC 常见算法，CMS 以及 G1 的垃圾回收过程，CMS 的各个阶段哪两个是 Stop the world 的，CMS 会不会产生碎片，G1 的优势6. 标记清除、复制和标记整理算法的理解以及优缺点7. eden survivor 区的比例，为什么是这个比例，eden survivor 的工作过程8. JVM 如何判断一个对象是否该被 GC，可以视为 root 的都有哪几种类型9. 强软弱虚引用的区别以及 GC 对他们执行怎样的操作10. Java 是否可以 GC 直接内存11. 常用的 JVM 调优参数12. GC 优化的步骤13. 当出现了内存泄漏或内存溢出，怎么排错14. CMS 和 G1 收集过程## 数据库相关1. 常见的数据库优化手段2. 索引的优缺点，以及索引选择3. B+树索引的原理4. 数据库连接池5. MySQL 的锁机制6. MVCC 和 ReadView7. InnoDB 的一些特性8. 数据库三范式## 计算机网络、操作系统1. TCP，UDP 区别2. 三次握手，四次挥手，为什么要四次挥手3. 长连接和短连接，连接池适合长连接还是短连接4. OSI 七层模型5. 用户态和内核态## 数据结构和算法1. 红黑树、AVL 树2. B 树、B+树3. 排序算法4. 一致性 Hash 算法，一致性 Hash 算法的应用5. TopK 问题6. 判断链表是否有环## 缓存相关1. redis 支持的数据类型及使用场景2. redis 单线程为什么还那么快3. redis 如何存储一个 String 的4. redis 的过期策略5. redis 的部署方式，主从，集群6. redis 的哨兵模式，一个 key 值如何在 redis 集群中找到存储在哪7. redis 持久化策略8. 缓存穿透、缓存击穿、缓存雪崩问题及解决方法9. 缓存和数据库一致性问题## 框架相关1. Spring 的常用注解及作用2. Spring Bean 的生命周期3. Spring 怎么解决单例 Bean 的循环依赖问题4. Spring 对于 IOC 的扩展点有哪些5. Spring AOP 的原理，及代理对象调用过程（责任链+递归调用）6. Spring 的事务机制，及执行流程7. Spring 使用了哪些设计模式8. Mybatis 基于接口完成查询的过程及原理9. Mybatis 的一级缓存和二级缓存10. Quartz 是如何完成定时任务的；集群同步机制## 分布式相关1. 分布式事务的控制2. 分布式锁如何设计3. 分布式 session 如何设计4. dubbo 的组件有哪些，及其作用5. dubbo SPI 机制；远程接口调用过程6. dubbo 支持的协议及序列化方式7. dubbo 的负载均衡和容错策略8. zookeeper 的 ZAB 协议工作原理9. zookeeper 的 Watcher 机制10. zookeeper 的 Watcher 机制11. zookeeper 的数据存储12. zookeeper 的负载均衡算法13. rocketmq 的模块功能14. rocketmq 的高可用及高性能15. elasticsearch 的系统架构及读写过程16. elasticsearch 在数据量很大的情况下（数十亿级别）如何提高查询效率啊17. eureka 的相关原理，和 zookeeper 的比较--><hr><p><em>参考内容均来自网络中网友分享，若内容涉及侵权请及时告知，我会尽快修改和删除相关内容</em></p>]]></content>
    
    <summary type="html">
    
      通过在各个平台收集面试相关问题，再进行分类、整理和收集，持续更新中。
    
    </summary>
    
      <category term="面试整理" scheme="http://linyishui.top/categories/%E9%9D%A2%E8%AF%95%E6%95%B4%E7%90%86/"/>
    
    
      <category term="others" scheme="http://linyishui.top/tags/others/"/>
    
  </entry>
  
  <entry>
    <title>Docker（五）应用的容器化</title>
    <link href="http://linyishui.top/2019101301.html"/>
    <id>http://linyishui.top/2019101301.html</id>
    <published>2019-10-13T08:40:00.000Z</published>
    <updated>2019-12-12T07:39:11.154Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="Docker（五）应用的容器化"><a href="#Docker（五）应用的容器化" class="headerlink" title="Docker（五）应用的容器化"></a><strong>Docker（五）应用的容器化</strong></h1><h2 id="第一节-应用的容器化"><a href="#第一节-应用的容器化" class="headerlink" title="第一节 应用的容器化"></a><strong>第一节 应用的容器化</strong></h2><p>&emsp;&emsp;Docker的核心思想就是如何将应用整合到容器中，并且能在容器中实际运行。将应用整合到容器中并且运行起来的这个过程，称为“容器化”（Containerizing），有时也叫作“Docker化”（Dockerizing）。</p><p>&emsp;&emsp;本节将逐步介绍容器化一个简单的Linux Web应用的过程。如果没有一个Linux的Docker环境来跟进练习，那么可以免费使用Play With Docker。只需使用浏览器打开Play With Docker的页面，并启动若干Linux Docker节点即可。</p><h3 id="1-1-简介"><a href="#1-1-简介" class="headerlink" title="1.1 简介"></a><strong>1.1 简介</strong></h3><p>&emsp;&emsp;容器是为应用而生！具体来说，<strong>容器能够简化应用的构建、部署和运行过程</strong>。</p><blockquote><p>完整的应用容器化过程主要分为以下几个步骤。</p><ol><li>编写应用代码。</li><li>创建一个Dockerfile，其中包括当前应用的描述、依赖以及该如何运行这个应用。</li><li>对该Dockerfile执行docker image build命令。</li><li>等待Docker将应用程序构建到Docker镜像中。</li></ol></blockquote><p>&emsp;&emsp;一旦应用容器化完成（即应用被打包为一个Docker镜像），就能以镜像的形式交付并以容器的方式运行了。图8.1展示了上述步骤。</p><p><img src="https://pic-1258215793.cos.ap-shanghai.myqcloud.com/content/20191001/201910010128.png" alt="容器化的基本过程"></p><hr><h3 id="1-2-详解"><a href="#1-2-详解" class="headerlink" title="1.2 详解"></a><strong>1.2 详解</strong></h3><h4 id="1-2-1-单体应用容器化"><a href="#1-2-1-单体应用容器化" class="headerlink" title="1.2.1 单体应用容器化"></a><strong>1.2.1 单体应用容器化</strong></h4><p>&emsp;&emsp;接下来逐步展示如何将一个简单的单节点Node.js Web应用容器化。本部分主要完成单节点应用的容器化，采用Docker Compose去完成多节点应用容器化，使用Docker Stack去处理更复杂应用的容器化场景。接下来通过以下几个步骤，来介绍具体的过程。</p><h5 id="（1）获取应用代码"><a href="#（1）获取应用代码" class="headerlink" title="（1）获取应用代码"></a><strong>（1）获取应用代码</strong></h5><p>&emsp;&emsp;应用代码可以从作者的GitHub主页获取，将代码克隆到本地，创建一个名为psweb的文件夹。（本人直接用PC端DFW克隆到本地，后续环境即Windows 10）</p><figure class="highlight crmsh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ git <span class="keyword">clone</span> <span class="title">https</span>://github.com/nigelpoulton/psweb.git</span><br></pre></td></tr></table></figure><p>&emsp;&emsp;跳转项目根目录，查看项目文件结构。</p><figure class="highlight tap"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">$ cd psweb</span><br><span class="line"></span><br><span class="line">$ ls -l </span><br><span class="line">total<span class="number"> 28 </span></span><br><span class="line">-rw-r--r--<span class="number"> 1 </span>root root <span class="number"> 341 </span>Sep<span class="number"> 29 </span>16:26 app.js </span><br><span class="line">-rw-r--r--<span class="number"> 1 </span>root root <span class="number"> 216 </span>Sep<span class="number"> 29 </span>16:26 circle.yml </span><br><span class="line">-rw-r--r--<span class="number"> 1 </span>root root <span class="number"> 338 </span>Sep<span class="number"> 29 </span>16:26 Dockerfile </span><br><span class="line">-rw-r--r--<span class="number"> 1 </span>root root <span class="number"> 421 </span>Sep<span class="number"> 29 </span>16:26 package.json </span><br><span class="line">-rw-r--r--<span class="number"> 1 </span>root root <span class="number"> 370 </span>Sep<span class="number"> 29 </span>16:26 README.md </span><br><span class="line">drwxr-xr-x<span class="number"> 2 </span>root root<span class="number"> 4096 </span>Sep<span class="number"> 29 </span>16:26 test/</span><br><span class="line">drwxr-xr-x<span class="number"> 2 </span>root root<span class="number"> 4096 </span>Sep<span class="number"> 29 </span>16:26 views/</span><br></pre></td></tr></table></figure><h5 id="（2）分析Dockerfile"><a href="#（2）分析Dockerfile" class="headerlink" title="（2）分析Dockerfile"></a><strong>（2）分析Dockerfile</strong></h5><p>&emsp;&emsp;在代码目录当中，有个名称为Dockerfile的文件。这个文件包含了对当前应用的描述，并且能指导Docker完成镜像的构建。<br>在Docker当中，包含应用文件的目录通常被称为构建上下文（Build Context）。通常将Dockerfile放到构建上下文的根目录下。</p><p>&emsp;&emsp;另外很重要的一点是，文件开头字母是大写D，这里是一个单词。 像“dockerfile”或者“Docker file”这种写法都是不允许的。</p><p>&emsp;&emsp;接下来了解一下Dockerfile文件当中都包含哪些具体内容。</p><figure class="highlight dockerfile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Test web-app to use with Pluralsight courses and Docker Deep Dive book</span></span><br><span class="line"><span class="comment"># Linux x64</span></span><br><span class="line"><span class="keyword">FROM</span> alpine</span><br><span class="line"></span><br><span class="line"><span class="keyword">LABEL</span><span class="bash"> maintainer=<span class="string">"nigelpoulton@hotmail.com"</span></span></span><br><span class="line"><span class="bash"></span></span><br><span class="line"><span class="bash"><span class="comment"># Install Node and NPM</span></span></span><br><span class="line"><span class="bash">RUN apk add --update nodejs nodejs-npm</span></span><br><span class="line"><span class="bash"></span></span><br><span class="line"><span class="bash"><span class="comment"># Copy app to /src</span></span></span><br><span class="line"><span class="bash">COPY . /src</span></span><br><span class="line"><span class="bash"></span></span><br><span class="line"><span class="bash">WORKDIR /src</span></span><br><span class="line"><span class="bash"></span></span><br><span class="line"><span class="bash"><span class="comment"># Install dependencies</span></span></span><br><span class="line"><span class="bash">RUN  npm install</span></span><br><span class="line"><span class="bash"></span></span><br><span class="line"><span class="bash">EXPOSE 8080</span></span><br><span class="line"><span class="bash"></span></span><br><span class="line"><span class="bash">ENTRYPOINT [<span class="string">"node"</span>, <span class="string">"./app.js"</span>]</span></span><br></pre></td></tr></table></figure><blockquote><p>Dockerfile主要包括两个用途：</p><ul><li>对当前应用的描述。 </li><li>指导Docker完成应用的容器化（创建一个包含当前应用的镜像）。</li></ul></blockquote><p>&emsp;&emsp;Dockerfile能实现开发和部署两个过程的无缝切换。同时Dockerfile还能帮助新手快速熟悉这个项目。Dockerfile对当前的应用及其依赖有一个清晰准确的描述，并且非常容易阅读和理解。因此，要像重视你的代码一样重视这个文件，并且将它纳入到源控制系统当中。</p><p>&emsp;&emsp;下面是这个文件中的一些关键步骤概述：以alpine镜像作为当前镜像基础，指定维护者（maintainer）为“<a href="mailto:nigelpoultion@hotmail.com" target="_blank" rel="noopener">nigelpoultion@hotmail.com</a>”，安装Node.js和NPM，将应用的代码复制到镜像当中，设置新的工作目录，安装依赖包，记录应用的网络端口，最后将app.js设置为默认运行的应用。</p><p>&emsp;&emsp;具体分析一下每一步的作用：每个Dockerfile文件第一行都是FROM指令。FROM指令指定的镜像，会作为当前镜像的一个基础镜像层，当前应用的剩余内容会作为新增镜像层添加到基础镜像层之上。本例中的应用基于Linux操作系统，所以在FROM指令当中所引用的也是一个Linux基础镜像；如果要容器化的应用是一个基于Windows操作系统的应用，就需要指定一个像microsoft/aspnetcore-build这样的Windows基础镜像了。当前基础镜像的结构如图8.2所示</p><p><img src="https://pic-1258215793.cos.ap-shanghai.myqcloud.com/content/20191001/201910010129.png" alt="基础镜像的结构"></p><p>&emsp;&emsp;接下来，Dockerfile中通过标签（LABLE）方式指定了当前镜像的维护者为“<a href="mailto:nigelpoulton@hotmail.com" target="_blank" rel="noopener">nigelpoulton@hotmail.com</a>”。每个标签其实是一个键值对（Key-Value），在一个镜像当中可以通过增加标签的方式来为镜像添加自定义元数据。备注维护者信息有助于为该镜像的潜在使用者提供沟通途径，这是一种值得提倡的做法。</p><p>&emsp;&emsp;RUN apk add –update nodejs nodejs-npm指令使用alpine的apk包管理器将nodejs和nodejs-npm安装到当前镜像之中。RUN指令会在FROM指定的alpine基础镜像之上，新建一个镜像层来存储这些安装内容。当前镜像的结构如图8.3所示。</p><p><img src="https://pic-1258215793.cos.ap-shanghai.myqcloud.com/content/20191001/201910010130.png" alt="当前镜像的结构"></p><p>&emsp;&emsp;COPY. / src指令将应用相关文件从构建上下文复制到了当前镜像中，并且新建一个镜像层来存储。COPY执行结束之后，当前镜像共包含3层，如图8.4所示。</p><p><img src="https://pic-1258215793.cos.ap-shanghai.myqcloud.com/content/20191001/201910010131.png" alt="当前的3层镜像"></p><p>&emsp;&emsp;下一步，Dockerfile通过WORKDIR指令，为Dockerfile中尚未执行的指令设置工作目录。该目录与镜像相关，并且会作为元数据记录到镜像配置中，但不会创建新的镜像层。</p><p>&emsp;&emsp;然后，RUN npm install指令会根据package.json中的配置信息，使用npm来安装当前应用的相关依赖包。npm命令会在前文设置的工作目录中执行，并且在镜像中新建镜像层来保存相应的依赖文件。目前镜像一共包含4层，如图8.5所示。</p><p><img src="https://pic-1258215793.cos.ap-shanghai.myqcloud.com/content/20191001/201910010132.png" alt="当前的4层镜像"></p><p>&emsp;&emsp;因为当前应用需要通过TCP端口8080对外提供一个Web服务，所以在Dockerfile中通过EXPOSE 8080指令来完成相应端口的设置。这个配置信息会作为镜像的元数据被保存下来，并不会产生新的镜像层。</p><p>&emsp;&emsp;最终，通过ENTRYPOINT指令来指定当前镜像的入口程序。ENTRYPOINT指定的配置信息也是通过镜像元数据的形式保存下来，而不是新增镜像层。</p><h5 id="（3）构建应用镜像"><a href="#（3）构建应用镜像" class="headerlink" title="（3）构建应用镜像"></a><strong>（3）构建应用镜像</strong></h5><p>&emsp;&emsp;下面的命令会构建并生成一个名为web:latest的镜像。命令最后的点（.）表示Docker在进行构建的时候，使用当前目录作为构建上下文。一定要在命令最后包含这个点，并且在执行命令前，要确认当前目录是psweb（包含Dockerfile和应用代码的目录）。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> docker image build -t web:latest .</span></span><br></pre></td></tr></table></figure><p>&emsp;&emsp;命令执行结束后，检查本地Docker镜像库是否包含了刚才构建的镜像。可以通过docker image inspect web:latest来确认刚刚构 建的镜像配置是否正确。这个命令会列出Dockerfile中设置的所有配置 项。</p><figure class="highlight crmsh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$ docker image ls </span><br><span class="line">REPO    <span class="keyword">TAG</span>       <span class="title">IMAGE</span> ID          CREATED              SIZE </span><br><span class="line">web     latest    fc69fdc4c18e      <span class="number">10</span> seconds ago       <span class="number">64.4M</span>B</span><br></pre></td></tr></table></figure><h5 id="（4）推送镜像到仓库"><a href="#（4）推送镜像到仓库" class="headerlink" title="（4）推送镜像到仓库"></a><strong>（4）推送镜像到仓库</strong></h5><p>&emsp;&emsp;在创建一个镜像之后，将其保存在一个镜像仓库服务是一个不错的方式。这样存储镜像会比较安全，并且可以被其他人访问使用。Docker Hub就是这样的一个开放的公共镜像仓库服务，并且这也是docker image push命令默认的推送地址。</p><p>&emsp;&emsp;在推送镜像之前，需要先使用Docker ID登录Docker Hub（xxx表示docker id）。除此之外，还需要为待推送的镜像打上合适的标签。因为Docker在镜像推送的过程中需要如下信息：Registry（镜像仓库服务），Repository（镜像仓库），Tag（镜像标签）。</p><figure class="highlight applescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">$ docker login </span><br><span class="line">Login <span class="keyword">with</span> **your** Docker ID <span class="keyword">to</span> push <span class="keyword">and</span> pull images <span class="keyword">from</span> Docker Hub... </span><br><span class="line">Username: xxx </span><br><span class="line">Password: Login Succeeded</span><br></pre></td></tr></table></figure><p>&emsp;&emsp;Docker会默认Registry=docker.io、Tag=latest。但是 Docker并没有给Repository提供默认值，而是从被推送镜像中的REPOSITORY属性值获取。</p><p>&emsp;&emsp;执行docker image push命令，会尝试将镜像推送到docker.io/web:latest中。但是xxx用户并没有web这个镜像仓库的访问权限，所以只能尝试推送到xxx这个二级命名空间（Namespace）之下。因此需要使用xxx这个ID，为当前镜像重新打一个标签。</p><figure class="highlight crmsh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ docker image <span class="keyword">tag</span> <span class="title">web</span>:latest nigelpoulton/web:latest</span><br></pre></td></tr></table></figure><p>&emsp;&emsp;再次执行docker image ls命令，可以看到这个镜像现在有了两个标签，其中一个包含Docker ID nigelpoulton。</p><figure class="highlight lsl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">$ docker image ls </span><br><span class="line">REPO                TAG       IMAGE ID        CREATED       SIZE </span><br><span class="line">web                 latest    fc69fdc4c18e    <span class="number">10</span> secs ago   <span class="number">64.4</span>MB </span><br><span class="line">xxx/web             latest    fc69fdc4c18e    <span class="number">10</span> secs ago   <span class="number">64.4</span>MB</span><br></pre></td></tr></table></figure><p>&emsp;&emsp;现在将该镜像推送到Docker Hub。</p><figure class="highlight maxima"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ docker <span class="built_in">image</span> <span class="built_in">push</span> xxx/web:latest</span><br></pre></td></tr></table></figure><p>&emsp;&emsp;图8.6展示了Docker如何确定镜像所要推送的目的仓库。</p><p><img src="https://pic-1258215793.cos.ap-shanghai.myqcloud.com/content/20191001/201910010133.png" alt="确定镜像所要推送的目的仓库"></p><h5 id="（5）运行该应用"><a href="#（5）运行该应用" class="headerlink" title="（5）运行该应用"></a><strong>（5）运行该应用</strong></h5><p>&emsp;&emsp;前文中容器化的这个应用程序其实很简单，从app.js这个文件内容中可以看出，这其实就是一个在8080端口提供Web服务的应用程序。下面的命令会基于web:latest这个镜像，启动一个名为c1的容器。该容器将内部的8080端口与Docker主机的80端口进行映射。这意味我们可以打开一个浏览器，在地址栏输入Docker主机的DNS名称或者IP地址，然后就能直接访问这个Web应用了。</p><blockquote><p>如果Docker主机已经运行了某个使用80端口的应用程序，可以在执行docker container run命令时指定一个不同的映射端口。例如，可以使用-p 5000:8000参数，将Docker内部应用程序的8080端口映射到主机的5000端口。</p></blockquote><figure class="highlight dockerfile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$ docker container <span class="keyword">run</span><span class="bash"> -d --name c1 \  </span></span><br><span class="line"><span class="bash">  -p 80:8080 \  </span></span><br><span class="line"><span class="bash">  web:latest</span></span><br></pre></td></tr></table></figure><p>&emsp;&emsp;接下来验证一下程序是否真的成功运行，并且对外提供服务的端口是否正常工作。</p><figure class="highlight x86asm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">$ docker container ls</span><br><span class="line"></span><br><span class="line">ID    IMAGE       COMMAND           STATUS      PORTS </span><br><span class="line"><span class="number">49</span>．.  web:latest  <span class="string">"node ./app.js"</span>   <span class="meta">UP</span> <span class="number">6</span> secs   <span class="number">0.0</span><span class="meta">.0</span><span class="meta">.0</span>:<span class="number">80</span>-&gt;<span class="number">8080</span>/tcp</span><br></pre></td></tr></table></figure><h5 id="（6）测试应用"><a href="#（6）测试应用" class="headerlink" title="（6）测试应用"></a><strong>（6）测试应用</strong></h5><p>&emsp;&emsp;打开浏览器，在地址栏输入DNS名称或者IP地址，就能访问到正在运行的应用程序了。</p><p>&emsp;&emsp;如果没有出现正常的界面，尝试执行下面的检查来确认原因所在。</p><blockquote><ul><li>使用docker container ls指令来确认容器已经启动并且正常运行。容器名称是c1，并且从输出内容中能看到0.0.0.0:80&gt;8080/tcp。 </li><li>确认防火墙或者其他网络安全设置没有阻止访问Docker主机的80端口。</li></ul></blockquote><h5 id="（7）容器应用化细节"><a href="#（7）容器应用化细节" class="headerlink" title="（7）容器应用化细节"></a><strong>（7）容器应用化细节</strong></h5><p>&emsp;&emsp;一些细节部分的回顾和总结。</p><p>&emsp;&emsp;Dockerfile中的注释行，都是以#开头的。除注释之外，每一行都是一条指令（Instruction）。指令的参数格式如下：INSTRUCTION argument，指令是不区分大小写的，但是通常都采用大写的方式，这样Dockerfile的可读性会高一些。</p><p>&emsp;&emsp;Docker image build命令会按行来解析Dockerfile中的指令并顺序执行。部分指令会在镜像中创建新的镜像层，其他指令只会增加或修改镜像的元数据信息。在上面的例子当中，新增镜像层的指令包括FROM、RUN以及COPY，而新增元数据的指令包括EXPOSE、WORKDIR、ENV以及ENTERPOINT。 关于如何区分命令是否会新建镜像层，一个基本的原则是，如果指令的作用是向镜像中增添新的文件或者程序，那么这条指令就会新建镜像层；如果只是告诉Docker如何完成构建或者如何运行应用程序，那么就只会增加镜像的元数据。</p><p>&emsp;&emsp;可以通过docker image history来查看在构建镜像的过程中都执行了哪些指令。</p><figure class="highlight leaf"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">$ docker image history web:latest</span><br><span class="line"></span><br><span class="line">IMAGE     CREATED BY                                       SIZE </span><br><span class="line">fc6..18e  /bin/sh -c <span class="function"><span class="keyword">#</span><span class="params">(<span class="variable">nop</span>)</span></span>  ENTRYPOINT ["node" "./a...    0B </span><br><span class="line">334．.bf0  /bin/sh -c <span class="function"><span class="keyword">#</span><span class="params">(<span class="variable">nop</span>)</span></span>  EXPOSE 8080/tcp               0B </span><br><span class="line">b27..eae  /bin/sh -c npm install                           14.1MB </span><br><span class="line">932．.749  /bin/sh -c <span class="function"><span class="keyword">#</span><span class="params">(<span class="variable">nop</span>)</span></span> WORKDIR /src                   0B </span><br><span class="line">052．.2dc  /bin/sh -c <span class="function"><span class="keyword">#</span><span class="params">(<span class="variable">nop</span>)</span></span> COPY dir:2a6ed1703749e80...    22.5kB </span><br><span class="line">c1d..81f  /bin/sh -c apk add --update nodejs nodejs-npm    46.1MB </span><br><span class="line">336．.b92  /bin/sh -c <span class="function"><span class="keyword">#</span><span class="params">(<span class="variable">nop</span>)</span></span>  LABEL maintainer=nigelp...    0B</span><br><span class="line">3fd..f02  /bin/sh -c <span class="function"><span class="keyword">#</span><span class="params">(<span class="variable">nop</span>)</span></span>  CMD ["/bin/sh"]               0B </span><br><span class="line"> /bin/sh -c <span class="function"><span class="keyword">#</span><span class="params">(<span class="variable">nop</span>)</span></span> ADD file:093f0723fa46f6c...    4.15MB</span><br></pre></td></tr></table></figure><p>&emsp;&emsp;在上面的输出内容当中，有两点是需要注意的。首先，每行内容都对应了Dockerfile中的一条指令（顺序是自下而上）。CREATE BY这一列中还展示了当前行具体对应Dockerfile中的哪条指令。其次，从这个输出内容中，可以观察到只有4条指令会新建镜像层 （就是那些SIZE列对应的数值不为零的指令），分别对应Dockerfile中的FROM、RUN以及COPY指令。虽然其他指令看上去跟这些新建镜像层的指令并无区别，但实际上它们只在镜像中新增了元数据信息。这些指令之所以看起来没有区别，是因为Docker对之前构建镜像层方式的兼容。</p><p>&emsp;&emsp;可以通过执行docker image inspect指令来确认确实只有4个层被创建了。</p><figure class="highlight vim"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">$ docker image inspect we<span class="variable">b:latest</span> </span><br><span class="line"><span class="symbol">&lt;Snip&gt;</span> </span><br><span class="line">&#125;, <span class="string">"RootFS"</span>: &#123;    </span><br><span class="line">    <span class="string">"Type"</span>: <span class="string">"layers"</span>,    </span><br><span class="line">    <span class="string">"Layers"</span>: [        </span><br><span class="line">        <span class="string">"sha256:cd7100...1882bd56d263e02b6215"</span>,        </span><br><span class="line">        <span class="string">"sha256:b3f88e...cae0e290980576e24885"</span>,        </span><br><span class="line">        <span class="string">"sha256:3cfa21...cc819ef5e3246ec4fe16"</span>,        </span><br><span class="line">        <span class="string">"sha256:4408b4...d52c731ba0b205392567"</span>    </span><br><span class="line">    ] </span><br><span class="line">&#125;,</span><br></pre></td></tr></table></figure><p>&emsp;&emsp;使用FROM指令引用官方基础镜像是一个很好的习惯，官方的镜像通常会遵循一些最佳实践，并且能帮助使用者规避一些已知的问<br>题。除此之外，使用FROM的时候选择一个相对较小的镜像文件通常也能避免一些潜在的问题。</p><p>&emsp;&emsp;我们也可以观察docker image build命令具体的输出内容，了解镜像构建的过程。在下面的片段中，可以看到基本的构建过程是，运行临时容器&gt;在该容器中运行Dockerfile中的指令&gt;将指令运行结果保存为 一个新的镜像层&gt;删除临时容器。</p><figure class="highlight groovy"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">Step <span class="number">3</span>/<span class="number">8</span> : RUN apk add --update nodejs nodejs-npm </span><br><span class="line"> ---&gt; Running <span class="keyword">in</span> e690ddca785f    &lt;&lt; Run inside of temp container </span><br><span class="line">fetch <span class="string">http:</span><span class="comment">//dl-cdn...APKINDEX.tar.gz </span></span><br><span class="line">fetch <span class="string">http:</span><span class="comment">//dl-cdn...APKINDEX.tar.gz </span></span><br><span class="line">(<span class="number">1</span>/<span class="number">10</span>) Installing ca-certificates (<span class="number">20171114</span>-r0) </span><br><span class="line">&lt;Snip&gt; </span><br><span class="line"><span class="string">OK:</span> <span class="number">61</span> MiB <span class="keyword">in</span> <span class="number">21</span> packages ---&gt; c1d31d36b81f                &lt;&lt; Create <span class="keyword">new</span> layer </span><br><span class="line">Removing intermediate container   &lt;&lt; Remove temp container </span><br><span class="line">Step <span class="number">4</span><span class="regexp">/8 : COPY . /</span>src</span><br></pre></td></tr></table></figure><h4 id="1-2-2-生产环境中的多阶段构建"><a href="#1-2-2-生产环境中的多阶段构建" class="headerlink" title="1.2.2 生产环境中的多阶段构建"></a><strong>1.2.2 生产环境中的多阶段构建</strong></h4><p>&emsp;&emsp;对于Docker镜像来说，体积越大则越慢，就意味着更难使用，而且可能更加脆弱，更容易遭受攻击。对于生产环境镜像来说，目标是将其缩小到仅包含运行应用所必需的内容即可，但生成较小的镜像并非易事。</p><p>&emsp;&emsp;例如，不同的Dockerfile写法就会对镜像的大小产生显著影响。常见的例子是，每一个RUN指令会新增一个镜像层。因此，通过使用 &amp;&amp; 连接多个命令以及使用反斜杠（\）换行的方法，将多个命令包含在一个RUN指令中，通常来说是一种值得提倡的方式。这并不难掌握，多加练习即可。</p><p>&emsp;&emsp;另一个问题是开发者通常不会在构建完成后进行清理。当使用RUN执行一个命令时，可能会拉取一些构建工具，这些工具会留在镜像中移交至生产环境。这是不合适的！</p><p>&emsp;&emsp;有多种方式来改善这一问题——比如常见的是采用<strong>建造者模式</strong>（Builder Pattern）。但无论采用哪种方式，通常都需要额外的培训，并且会增加构建的复杂度。建造者模式需要至少两个Dockerfile——一个用于开发环境，一个用于生产环境。首先需要编写Dockerfile.dev，它基于一个大型基础镜像（Base Image），拉取所需的构建工具，并构建应用。接下来，需要基于Dockerfile.dev构建一个镜像，并用这个镜像创建一个容器。这时再编写Dockerfile.prod，它基于一个较小的基础镜像开始构建，并从刚才创建的容器中将应用程序相关的部分复制过来。整个过程需要编写额外的脚本才能串联起来。这种方式是可行的，但是比较复杂。</p><p>&emsp;&emsp;<strong>多阶段构建</strong>（Multi-Stage Build）是一种更好的方式！多阶段构建是随Docker 17.05版本新增的一个特性，用于构建精简的生产环境镜像。多阶段构建能够在不增加复杂性的情况下优化构建过程。多阶段构建方式使用一个Dockerfile，其中包含多个FROM指令。每一个FROM指令都是一个新的构建阶段（Build Stage），并且可以方便地复制之前阶段的构件。示例源码可从作者GitHub主页中atsea-sample-shopapp仓库获得，Dockerfile位于app目录。这是一个基于Linux系统的应用，因此只能运行在Linux容器环境上。</p><p>&emsp;&emsp;Dockerfile如下所示。</p><figure class="highlight dockerfile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">FROM</span> node:latest AS storefront </span><br><span class="line"><span class="keyword">WORKDIR</span><span class="bash"> /usr/src/atsea/app/react-app </span></span><br><span class="line"><span class="bash">COPY react-app . </span></span><br><span class="line"><span class="bash">RUN npm install </span></span><br><span class="line"><span class="bash">RUN npm run build</span></span><br><span class="line"><span class="bash"></span></span><br><span class="line"><span class="bash">FROM maven:latest AS appserver </span></span><br><span class="line"><span class="bash">WORKDIR /usr/src/atsea </span></span><br><span class="line"><span class="bash">COPY pom.xml . </span></span><br><span class="line"><span class="bash">RUN mvn -B -f pom.xml -s /usr/share/maven/ref/settings-docker.xml dependen </span></span><br><span class="line"><span class="bash">cy </span></span><br><span class="line"><span class="bash">\:resolve </span></span><br><span class="line"><span class="bash">COPY . . </span></span><br><span class="line"><span class="bash">RUN mvn -B -s /usr/share/maven/ref/settings-docker.xml package -DskipTests</span></span><br><span class="line"><span class="bash"></span></span><br><span class="line"><span class="bash">FROM java:8-jdk-alpine AS production </span></span><br><span class="line"><span class="bash">RUN adduser -Dh /home/gordon gordon </span></span><br><span class="line"><span class="bash">WORKDIR /static </span></span><br><span class="line"><span class="bash">COPY --from=storefront /usr/src/atsea/app/react-app/build/ . </span></span><br><span class="line"><span class="bash">WORKDIR /app </span></span><br><span class="line"><span class="bash">COPY --from=appserver /usr/src/atsea/target/AtSea-0.0.1-SNAPSHOT.jar . </span></span><br><span class="line"><span class="bash">ENTRYPOINT [<span class="string">"java"</span>, <span class="string">"-jar"</span>, <span class="string">"/app/AtSea-0.0.1-SNAPSHOT.jar"</span>] </span></span><br><span class="line"><span class="bash">CMD [<span class="string">"--spring.profiles.active=postgres"</span>]</span></span><br></pre></td></tr></table></figure><p>&emsp;&emsp;首先注意到，Dockerfile中有3个FROM指令。每一个FROM指令构成一个单独的构建阶段。各个阶段在内部从0开始编号。不过，示例中针对每个阶段都定义了便于理解的名字。阶段0叫作storefront，阶段1叫作appserver，阶段2叫作production。</p><p>&emsp;&emsp;storefront阶段拉取了大小超过600MB的node:latest镜像，然后设置了工作目录，复制一些应用代码进去，然后使用2个RUN指令来执行npm操作。这会生成3个镜像层并显著增加镜像大小。指令执行结束后会得到一个比原镜像大得多的镜像，其中包含许多构建工具和少量应用程序代码。</p><p>&emsp;&emsp;appserver阶段拉取了大小超过700MB的maven:latest镜像。然后通过2个COPY指令和2个RUN指令生成了4个镜像层。这个阶段同样会构建出一个非常大的包含许多构建工具和非常少量应用程序代码的镜像。</p><p>&emsp;&emsp;production阶段拉取java:8-jdk-alpine镜像，这个镜像大约150MB，明显小于前两个构建阶段用到的node和maven镜像。这个阶段会创建一个用户，设置工作目录，从storefront阶段生成的镜像中复制一些应用代码过来。之后，设置一个不同的工作目录，然后从 appserver阶段生成的镜像中复制应用相关的代码。最后，production设置当前应用程序为容器启动时的主程序。</p><p>&emsp;&emsp;重点在于COPY –from指令，它从之前的阶段构建的镜像中仅复制生产环境相关的应用代码，而不会复制生产环境不需要的构件。</p><p>&emsp;&emsp;还有一点也很重要，多阶段构建这种方式仅用到了一个Dockerfile，并且docker image build命令不需要增加额外参数。</p><p>&emsp;&emsp;下面就进行一下构建，首先克隆代码库并切换到app目录，并确保其中有Dockerfile。</p><figure class="highlight tap"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">$ cd atsea-sample-shop-app/app</span><br><span class="line"></span><br><span class="line">$ ls -l </span><br><span class="line">total<span class="number"> 24 </span></span><br><span class="line">-rw-r--r--<span class="number"> 1 </span>root root <span class="number"> 682 </span>Oct<span class="number"> 1 </span>22:03 Dockerfile </span><br><span class="line">-rw-r--r--<span class="number"> 1 </span>root root<span class="number"> 4365 </span>Oct<span class="number"> 1 </span>22:03 pom.xml </span><br><span class="line">drwxr-xr-x<span class="number"> 4 </span>root root<span class="number"> 4096 </span>Oct<span class="number"> 1 </span>22:03 react-app </span><br><span class="line">drwxr-xr-x<span class="number"> 4 </span>root root<span class="number"> 4096 </span>Oct<span class="number"> 1 </span>22:03 src</span><br></pre></td></tr></table></figure><p>&emsp;&emsp;执行构建（这可能会花费几分钟）。</p><figure class="highlight crmsh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">$ docker image build -t multi:stage .</span><br><span class="line"></span><br><span class="line">Sending build context to Docker daemon <span class="number">3.658M</span>B </span><br><span class="line">Step <span class="number">1</span>/<span class="number">19</span> : FROM <span class="keyword">node</span><span class="title">:latest</span> AS storefront </span><br><span class="line">latest: Pulling from library/<span class="keyword">node</span> <span class="title"></span></span><br><span class="line"><span class="title">aa18ad1a0d33</span>: Pull complete </span><br><span class="line"><span class="number">15</span>a33158a136: Pull complete </span><br><span class="line"><span class="tag">&lt;Snip&gt;</span> </span><br><span class="line">Step <span class="number">19</span>/<span class="number">19</span> : CMD --spring.profiles.<span class="attr">active=</span>postgres </span><br><span class="line"> ---&gt; Running <span class="keyword">in</span> b4df9850f7ed </span><br><span class="line"> ---&gt; <span class="number">3</span>dc0d5e6223e </span><br><span class="line">Removing intermediate container b4df9850f7ed </span><br><span class="line">Successfully built <span class="number">3</span>dc0d5e6223e </span><br><span class="line">Successfully tagged multi:stage</span><br></pre></td></tr></table></figure><p>&emsp;&emsp;执行docker image ls命令查看由构建命令拉取和生成的镜像。</p><figure class="highlight lsl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">$ docker image ls</span><br><span class="line"></span><br><span class="line">REPO    TAG            IMAGE ID         CREATED        SIZE </span><br><span class="line">node    latest         <span class="number">9</span>ea1c3e33a0b     <span class="number">4</span> days ago     <span class="number">673</span>MB </span><br><span class="line">&lt;none&gt;  &lt;none&gt;         <span class="number">6598</span>db3cefaf     <span class="number">3</span> mins ago     <span class="number">816</span>MB </span><br><span class="line">maven   latest         cbf114925530     <span class="number">2</span> weeks ago    <span class="number">750</span>MB </span><br><span class="line">&lt;none&gt;  &lt;none&gt;         d5b619b83d9e     <span class="number">1</span> min ago      <span class="number">891</span>MB </span><br><span class="line">java    <span class="number">8</span>-jdk-alpine   <span class="number">3</span>fd9dd82815c     <span class="number">7</span> months ago   <span class="number">145</span>MB </span><br><span class="line">multi   stage          <span class="number">3</span>dc0d5e6223e     <span class="number">1</span> min ago      <span class="number">210</span>MB</span><br></pre></td></tr></table></figure><p>&emsp;&emsp;第一行显示了在storefront阶段拉取的node:latest镜像，第二行内容为该阶段生成的镜像（通过添加代码，执行npm安装和构建操作生成该镜像）。这两个都包含许多的构建工具，因此镜像体积非常大。</p><p>&emsp;&emsp;第3～4行是在appserver阶段拉取和生成的镜像，它们也都因为包含许多构建工具而导致体积较大。</p><p>&emsp;&emsp;最后一行是Dockerfile中的最后一个构建阶段（stage2/production）生成的multi:stage镜像。可见它明显比之前阶段拉取和生成的镜像要小。这是因为该镜像是基于相对精简的java:8-jdk-alpine镜像构建的，并且仅添加了用于生产环境的应用程序文件。</p><p>&emsp;&emsp;最终，无须额外的脚本，仅对一个单独的Dockerfile执行docker image build命令，就创建了一个精简的生产环境镜像。</p><h4 id="1-2-3-最佳实践"><a href="#1-2-3-最佳实践" class="headerlink" title="1.2.3 最佳实践"></a><strong>1.2.3 最佳实践</strong></h4><h5 id="（1）利用构建缓存"><a href="#（1）利用构建缓存" class="headerlink" title="（1）利用构建缓存"></a><strong>（1）利用构建缓存</strong></h5><p>&emsp;&emsp;Docker的构建过程利用了<strong>缓存机制</strong>。观察缓存效果的一个方法，就是在一个干净的Docker主机上构建一个新的镜像，然后再重复同样的构建。第一次构建会拉取基础镜像，并构建镜像层，构建过程需要花费一定时间；第二次构建几乎能够立即完成。这就是因为第一次构建的内容（如镜像层）能够被缓存下来，并被后续的构建过程复用。</p><p>&emsp;&emsp;docker image build命令会从顶层开始解析Dockerfile中的指令并逐行执行。而对每一条指令，Docker都会检查缓存中是否已经有与该指令对应的镜像层。如果有，即为<strong>缓存命中</strong>（Cache Hit），并且会使用这个镜像层；如果没有，则是<strong>缓存未命中</strong>（Cache Miss），Docker会基于该指令构建新的镜像层。缓存命中能够显著加快构建过程。</p><figure class="highlight dockerfile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">--告诉Docker使用alpine:latest作为基础镜像，如果镜像不存在，会从Docker Hub（docker.io）拉取。</span><br><span class="line"><span class="keyword">FROM</span> alpine </span><br><span class="line"></span><br><span class="line">--对镜像执行一条命令，Docker会检查构建缓存中是否存在基于同一基础镜像，并且执行了相同指令的镜像层</span><br><span class="line">--如果找到该镜像层，Docker会跳过这条指令，并链接到这个已经存在的镜像层，然后继续构建；</span><br><span class="line">--如果无法找到符合要求的镜像层，则设置缓存无效（后续不再取缓存）并构建该镜像层</span><br><span class="line"><span class="keyword">RUN</span><span class="bash"> apk add --update nodejs nodejs-npm </span></span><br><span class="line"><span class="bash"></span></span><br><span class="line"><span class="bash">--假设Docker已经在缓存中找到了该指令对应的镜像层（缓存命中），并且假设这个镜像层的ID是AAA</span></span><br><span class="line"><span class="bash">--下一条指令会复制一些代码到镜像中</span></span><br><span class="line"><span class="bash">--因为上一条指令命中了缓存，Docker会继续查找是否有一个缓存的镜像层也是基于AAA层并执行了COPY . /src命令。</span></span><br><span class="line"><span class="bash">--如果有，Docker会链接到这个缓存的镜像层并继续执行后续指令；</span></span><br><span class="line"><span class="bash">--如果没有，则构建镜像层，并对后续的构建操作设置缓存无效。</span></span><br><span class="line"><span class="bash">COPY . /src </span></span><br><span class="line"><span class="bash"></span></span><br><span class="line"><span class="bash">WORKDIR /src </span></span><br><span class="line"><span class="bash"></span></span><br><span class="line"><span class="bash">RUN npm install </span></span><br><span class="line"><span class="bash"></span></span><br><span class="line"><span class="bash">EXPOSE 8080 </span></span><br><span class="line"><span class="bash"></span></span><br><span class="line"><span class="bash">ENTRYPOINT [<span class="string">"node"</span>, <span class="string">"./app.js"</span>]</span></span><br></pre></td></tr></table></figure><p>&emsp;&emsp;一旦有指令在缓存中未命中（没有该指令对应的镜像层），则后续的整个构建过程将不再使用缓存。在编写Dockerfile时须特别注意这一点，尽量将易于发生变化的指令置于Dockerfile文件的后方执行。通过对docker image build命令加入–nocache=true参数可以强制忽略对缓存的使用。</p><p>&emsp;&emsp;COPY和ADD指令会检查复制到镜像中的内容自上一次构建之后是否发生了变化。例如，有可能Dockerfile中的COPY . /src指令没有发生变化，但是被复制的目录中的内容已经发生变化了。为了应对这一问题，Docker会计算每一个被复制文件的Checksum值，并与缓存镜像层中同一文件的checksum进行对比。如果不匹配，那么就认为缓存无效并构建新的镜像层。</p><h5 id="（2）合并镜像"><a href="#（2）合并镜像" class="headerlink" title="（2）合并镜像"></a><strong>（2）合并镜像</strong></h5><p>&emsp;&emsp;合并镜像并非一个最佳实践，因为这种方式利弊参半。总体来说，Docker会遵循正常的方式构建镜像，但之后会增加一个额外的步骤，将所有的内容合并到一个镜像层中。当镜像中层数太多时，合并是一个不错的优化方式。例如，当创建一个新的基础镜像，以便基于它来构建其他镜像的时候，这个基础镜像就最好被合并为一层。缺点是，合并的镜像将无法共享镜像层。这会导致存储空间的低效利用，而且push和pull操作的镜像体积更大。</p><p>&emsp;&emsp;执行docker image build命令时，可以通过增加–squash参数来创建一个合并的镜像。</p><p>&emsp;&emsp;图8.8阐释了合并镜像层带来的存储空间低效利用的问题。两个镜像的内容是完全一样的，区别在于是否进行了合并。在使用docker image push命令发送镜像到Docker Hub时，合并的镜像需要发送全部字节，而不合并的镜像只需要发送不同的镜像层即可。</p><p><img src="https://pic-1258215793.cos.ap-shanghai.myqcloud.com/content/20191001/201910010134.png" alt="合并的与不合并的镜像"></p><h5 id="（3）使用no-install-recommends"><a href="#（3）使用no-install-recommends" class="headerlink" title="（3）使用no-install-recommends"></a><strong>（3）使用no-install-recommends</strong></h5><p>&emsp;&emsp;在构建Linux镜像时，若使用的是APT包管理器，则应该在执行apt-get install命令时增加no-install-recommends参数。这能够确保APT仅安装核心依赖（Depends中定义）包，而不是推荐和建议的包。这样能够显著减少不必要包的下载数量。</p><h5 id="（4）不要安装MSI包（Windows）"><a href="#（4）不要安装MSI包（Windows）" class="headerlink" title="（4）不要安装MSI包（Windows）"></a><strong>（4）不要安装MSI包（Windows）</strong></h5><p>&emsp;&emsp;在构建Windows镜像时，尽量避免使用MSI包管理器。因其对空间的利用率不高，会大幅增加镜像的体积。</p><hr><h3 id="1-3-命令"><a href="#1-3-命令" class="headerlink" title="1.3 命令"></a><strong>1.3 命令</strong></h3><blockquote><ul><li>docker image build命令会读取Dockerfile，并将应用程序容器化。使用-t参数为镜像打标签，使用-f参数指定Dockerfile的路径和名称，使用-f参数可以指定位于任意路径下的任意名称的Dockerfile。构建上下文是指应用文件存放的位置，可能是本地Docker主机上的一个目录或一个远程的Git库。 </li><li>Dockerfile中的FROM指令用于指定要构建的镜像的基础镜像。它通常是Dockerfile中的第一条指令。 </li><li>Dockerfile中的RUN指令用于在镜像中执行命令，这会创建新的镜像层。每个RUN指令创建一个新的镜像层。 </li><li>Dockerfile中的COPY指令用于将文件作为一个新的层添加到镜像中。通常使用COPY指令将应用代码赋值到镜像中。 </li><li>Dockerfile中的EXPOSE指令用于记录应用所使用的网络端口。 </li><li>Dockerfile中的ENTRYPOINT指令用于指定镜像以容器方式启动后默认运行的程序。 </li><li>其他的Dockerfile指令还有LABEL、ENV、ONBUILD、HEALTHCHECK、CMD等。</li></ul></blockquote><hr><p><em>参考博客和文章书籍等：</em></p><blockquote><p>《深入浅出Docker》</p></blockquote><p><em>因博客主等未标明不可引用，若部分内容涉及侵权请及时告知，我会尽快修改和删除相关内容</em></p>]]></content>
    
    <summary type="html">
    
      简单介绍Docker（五）应用的容器化，内容包括：简介，详解（单体应用容器化、生产环境中的多阶段构建、最佳实践/优化），命令等。
    
    </summary>
    
      <category term="技术文档" scheme="http://linyishui.top/categories/%E6%8A%80%E6%9C%AF%E6%96%87%E6%A1%A3/"/>
    
    
      <category term="docker" scheme="http://linyishui.top/tags/docker/"/>
    
  </entry>
  
  <entry>
    <title>Docker（四）容器</title>
    <link href="http://linyishui.top/2019101201.html"/>
    <id>http://linyishui.top/2019101201.html</id>
    <published>2019-10-12T06:03:27.000Z</published>
    <updated>2019-12-12T06:55:21.424Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="Docker（四）容器"><a href="#Docker（四）容器" class="headerlink" title="Docker（四）容器"></a><strong>Docker（四）容器</strong></h1><h2 id="第一节-Docker容器"><a href="#第一节-Docker容器" class="headerlink" title="第一节 Docker容器"></a><strong>第一节 Docker容器</strong></h2><h3 id="1-1-简介"><a href="#1-1-简介" class="headerlink" title="1.1 简介"></a><strong>1.1 简介</strong></h3><p>&emsp;&emsp;容器是镜像的运行时实例。正如从虚拟机模板上启动VM一样，用户也同样可以从单个镜像上启动一个或多个容器。虚拟机和容器最大的区别是容器更快并且更轻量级——与虚拟机运行在完整的操作系统之上相比，容器会共享其所在主机的操作系统/内核。</p><p>&emsp;&emsp;启动容器的简便方式是使用docker container run命令。该命令可以携带很多参数，在其基础的格式docker container run \&lt; image&gt; \&lt; app&gt;中，指定了启动所需的镜像以及要运行的应用。docker container run -it ubuntu /bin/bash则会启动某个Ubuntu Linux容器，并运行Bash Shell作为其应用；如果想启动 PowerShell并运行一个应用，则可以使用命令docker container run -it microsoft- /powershell:nanoserver pwsh.exe。</p><p>&emsp;&emsp;-it参数可以将当前终端连接到容器的Shell终端之上。</p><p>&emsp;&emsp;容器随着其中运行应用的退出而终止。在上面两个示例中，Linux容器会在Bash Shell退出后终止，而Windows容器会在PowerShell进程终止后退出。一个简单的验证方法就是启动新的容器，并运行sleep命令休眠10s。容器会启动，然后运行休眠命令，在10s后退出。如果在Linux主机（或者在Linux容器模式下的Windows主机上）运行docker container run alpine:latest sleep 10命令，Shell会连接到容器Shell 10s的时间，然后退出；可以在Windows容器上运行docker container run microsoft/powershell:nanoserver StartSleep -s 10来验证这一点。可以使用docker container stop命令手动停止容器运行，并且使用docker container start再次启动该容器。如果再也不需要该容器，则使用docker container rm命令来删除容器。</p><hr><h3 id="1-2-详解"><a href="#1-2-详解" class="headerlink" title="1.2 详解"></a><strong>1.2 详解</strong></h3><h4 id="1-2-1-容器vs虚拟机"><a href="#1-2-1-容器vs虚拟机" class="headerlink" title="1.2.1 容器vs虚拟机"></a><strong>1.2.1 容器vs虚拟机</strong></h4><p>&emsp;&emsp;容器和虚拟机都依赖于宿主机才能运行。宿主机可以是笔记本，是数据中心的物理服务器，也可以是公有云的某个实例。假设宿主机是一台需要运行4个业务应用的物理服务器。在虚拟机模型中，首先要开启物理机并启动Hypervisor引导程序（跳过了BIOS和Bootloader代码等）。一旦Hypervisor启动，就会占有机器上的全部物理资源，如CPU、RAM、存储和NIC。Hypervisor接下来就会将这些物理资源划分为虚拟资源，并且看起来与真实物理资源完全一致。然后Hypervisor会将这些资源打包进一个叫作虚拟机（VM）的软件结构当中。这样用户就可以使用这些虚拟机，并在其中安装操作系统和应用。前面提到需要在物理机上运行4个应用，所以在Hypervisor之上需要创建4个虚拟机并安装4个操作系统，然后安装4个应用。当操作完成后，结构如图7.2所示。</p><p><img src="https://pic-1258215793.cos.ap-shanghai.myqcloud.com/content/20191001/201910010126.png" alt="运行4个业务应用的物理服务器"></p><p>&emsp;&emsp;而容器模型则略有不同。服务器启动之后，所选择的操作系统会启动。在Docker世界中可以选择Linux，或者内核支持内核中的容器原语的新版本Windows。与虚拟机模型相同，OS也占用了全部硬件资源。在OS层之上，需要安装容器引擎（如Docker）。容器引擎可以获取系统资源，比如进程树、文件 系统以及网络栈，接着将资源分割为安全的互相隔离的资源结构，称之为容器。每个容器看起来就像一个真实的操作系统，在其内部可以运行应用。按照前面的假设，需要在物理机上运行4个应用。因此，需要划分出4个容器并在每个容器中运行一个应用，如图7.3所示。</p><p><img src="https://pic-1258215793.cos.ap-shanghai.myqcloud.com/content/20191001/201910010127.png" alt="划分4个容器"></p><p>&emsp;&emsp;从更高层面上来讲，<strong>Hypervisor是硬件虚拟化</strong>（Hardware Virtualization）——Hypervisor将硬件物理资源划分为虚拟资源；另外，<strong>容器是操作系统虚拟化</strong>（OS Virtualization）——容器将系统资源划分为虚拟资源。</p><h4 id="1-2-2-虚拟机的额外开销"><a href="#1-2-2-虚拟机的额外开销" class="headerlink" title="1.2.2 虚拟机的额外开销"></a><strong>1.2.2 虚拟机的额外开销</strong></h4><p>&emsp;&emsp;接下来着重探讨Hypervisor模型的一个主要问题。</p><p>&emsp;&emsp;首先我们的目标是在一台物理机上运行4个业务相关应用。每种模型示例中都安装了一个操作系统或者Hypervisor（一种针对虚拟机高度优化后的操作系统）。截至目前，两个模型还很相似，但是也就到此为止了。</p><p>&emsp;&emsp;虚拟机模型将底层硬件资源划分到虚拟机当中。每个虚拟机都是包含了虚拟CPU、虚拟RAM、虚拟磁盘等资源的一种软件结构。因此，每个虚拟机都需要有自己的操作系统来声明、初始化并管理这些虚拟资源。但不幸的是，操作系统本身是有其额外开销的。例如，每个操作系统都消耗一点CPU、一点RAM、一点存储空间等。每个操作系统都需要独立的许可证，并且都需要打补丁升级，每个操作系统也都面临被攻击的风险。通常将这种现象称作OS Tax或者VM Tax，<strong>每个操作系统都占用一定的资源</strong>。</p><p>&emsp;&emsp;容器模型具有在宿主机操作系统中运行的单个内核。在一台主机上 运行数十个甚至数百个容器都是可能的，容器共享一个操作系统/内核，意味着只有一个操作系统消耗CPU、RAM和存储资源，只有一个操作系统需要授权，只有一个操作系统需要升级和打补丁，同时只有一个操作系统面临被攻击的风险。简言之就是只有一份OS损耗！</p><p>&emsp;&emsp;因为容器并不是完整的操作系统，所以其启动要远比虚拟机快。在容器内部并不需要内核，也就没有定位、解压以及初始化的过程——更不用提在内核启动过程中对硬件的遍历和初始化了。唯一需要的是位于下层操作系统的共享内核是启动了的！最终结果就是，容器可以在1s内启动。唯一对容器启动时间有影响的就是容器内应用启动所花费的时间。</p><p>&emsp;&emsp;这些就是容器模型要比虚拟机模型简洁并且高效的原因了。使用容器可以在更少的资源上运行更多的应用，启动更快，并且支付更少的授权和管理费用，同时面对未知攻击的风险也更小。</p><h4 id="1-2-3-检查Docker-daemon"><a href="#1-2-3-检查Docker-daemon" class="headerlink" title="1.2.3 检查Docker daemon"></a><strong>1.2.3 检查Docker daemon</strong></h4><p>&emsp;&emsp;通常登录Docker主机后的第一件事情是检查Docker是否正在运行。当命令输出中包含Client和Server的内容时，可以继续下面的示例。如果在Server部分中包含了错误码，这表示Docker daemon很可能没有运行，或者当前用户没有权限访问。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> docker version</span></span><br></pre></td></tr></table></figure><p>&emsp;&emsp;如果在Linux中遇到无权限访问的问题，需要确认当前用户是否属于本地Docker UNIX组。如果不是，可以通过usermod -aG docker \&lt; user&gt;来添加，然后退出并重新登录Shell，改动即可生效。如果当前用户已经属于本地docker用户组，那么问题可能是Docker daemon没有运行导致。根据下列指令检查Docker daemon的状态。</p><figure class="highlight arduino"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//使用Systemd在Linux系统中执行该命令 </span></span><br><span class="line">$ service docker status docker start/<span class="built_in">running</span>, <span class="built_in">process</span> <span class="number">29393</span></span><br><span class="line"><span class="comment">//使用Systemd在Linux系统中执行该命令 </span></span><br><span class="line">$ systemctl is-active docker active</span><br></pre></td></tr></table></figure><h4 id="1-2-4-启动一个简单容器"><a href="#1-2-4-启动一个简单容器" class="headerlink" title="1.2.4 启动一个简单容器"></a><strong>1.2.4 启动一个简单容器</strong></h4><p>&emsp;&emsp;启动容器的一个简单的方式是通过docker container run命令。下面的命令启动了一个简单的容器，其中运行了容器化版本的centos Linux。</p><figure class="highlight vim"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">$ docker container run -it ubuntu:latest /bin/bash </span><br><span class="line">Unable <span class="keyword">to</span> <span class="keyword">find</span> image <span class="string">'ubuntu:latest'</span> locally</span><br><span class="line">lates<span class="variable">t:</span> Pulling from library/ubuntu </span><br><span class="line"><span class="number">952132</span>ac251<span class="variable">a:</span> Pull <span class="built_in">complete</span> </span><br><span class="line"><span class="number">82659</span>f8f1b76:  Pull <span class="built_in">complete</span> </span><br><span class="line">c19118ca682d:  Pull <span class="built_in">complete</span> </span><br><span class="line"><span class="number">8296858250</span>fe:  Pull <span class="built_in">complete</span> </span><br><span class="line"><span class="number">24</span>e0251a0e2c:  Pull <span class="built_in">complete</span> </span><br><span class="line">Diges<span class="variable">t:</span> <span class="built_in">sha256</span>:f4691c96e6bbaa99d9...e95a60369c506dd6e6f6ab </span><br><span class="line">Statu<span class="variable">s:</span> Downloaded newer image <span class="keyword">for</span> ubuntu:latest </span><br><span class="line">root@<span class="number">3027</span>eb644874:/#</span><br></pre></td></tr></table></figure><p>&emsp;&emsp;命令的基础格式为docker container run \&lt; options&gt; \&lt; image&gt;:\&lt; tag&gt; \&lt; app&gt;。</p><p>&emsp;&emsp;使用docker container run来启动容器，这也是启动新容器的标准命令。命令中使用了-it参数使容器具备交互性并与终端进行连接。接下来，命令中指定了具体镜像ubuntu:latest。最终，在命令中指定了运行在容器中的程序Bash Shell。</p><p>&emsp;&emsp;当敲击回车键之后，Docker客户端选择合适的API来调用Docker daemon。Docker daemon接收到命令并搜索Docker本地缓存，观察是否有命令所请求的镜像。在上面引用的示例中，本地缓存并未包含该镜像，所以Docker接下来查询在Docker Hub中是否存在对应镜像。找到该镜像后，Docker将镜像拉取到本地，存储在本地缓存当中。</p><p>&emsp;&emsp;一旦镜像拉取到本地，daemon就创建容器并在其中运行指定的应用。在上面的示例中，Shell提示符已经变为root@3027eb644874:/#，说明目前已经位于容器内部了。@之后的一长串数字就是容器唯一ID的前12个字符。</p><p>&emsp;&emsp;若尝试在容器内执行一些基础命令，可能会发现某些指令无法正常工作。这是因为大部分容器镜像都是经过高度优化的。这意味着某些命令或者包可能没有安装。下面的示例展示了两个命令——一条执行成功，一条执行失败。</p><figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">root@3027eb644874:/# ls -l</span><br><span class="line">root@3027eb644874:/#<span class="built_in"> ping </span>www.docker.com</span><br></pre></td></tr></table></figure><h4 id="1-2-5-容器进程"><a href="#1-2-5-容器进程" class="headerlink" title="1.2.5 容器进程"></a><strong>1.2.5 容器进程</strong></h4><p>&emsp;&emsp;启动Ubuntu容器之时，让容器运行Bash Shell（/bin/bash）。这使得Bash Shell成为容器中运行的且唯一运行的进程。可以通过ps -elf命令在容器内部查看（ps -elf进程在输出后即结束）。</p><p>&emsp;&emsp;这意味着如果通过输入exit退出Bash Shell，那么容器也会退出（终止）。原因是容器如果不运行任何进程则无法存在——杀死Bash Shell即杀死了容器唯一运行的进程，导致这个容器也被杀死。</p><p>&emsp;&emsp;按下Ctrl-PQ组合键则会退出容器但并不终止容器运行。这样做会切回到Docker主机的Shell，并保持容器在后台运行。可以使用docker container ls命令来观察当前系统正在运行的容器列表。</p><figure class="highlight jboss-cli"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$ docker container <span class="keyword">ls</span> </span><br><span class="line">CNTNR ID  IMAGE          COMMAND    CREATED   STATUS     NAMES </span><br><span class="line">302．<span class="string">..74</span>  ubuntu<span class="function">:latest</span>  <span class="string">/bin/bash</span>  6 mins    Up 6mins   sick_montalcini</span><br></pre></td></tr></table></figure><p>&emsp;&emsp;当前容器仍然在运行，并且可以通过docker container exec命令将终端重新连接到Docker，理解这一点很重要。</p><figure class="highlight elixir"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable">$ </span>docker container exec -it <span class="number">3027</span>eb644874 bash </span><br><span class="line">root<span class="variable">@3027eb644874</span><span class="symbol">:/</span><span class="comment">#</span></span><br></pre></td></tr></table></figure><p>&emsp;&emsp;Shell提示符切换到了容器，如果再次运行ps命令，会看到两个Bash或者PowerShell进程，这是因为docker container exec命令创建了新的Bash或者PowerShell进程并且连接到容器。这意味着在当前Shell输入exit并不会导致容器终止，因为原Bash或者PowerShell进程还在运行当中。</p><p>&emsp;&emsp;输入exit退出容器，并通过命令docker container ps来确认容器依然在运行中。如果在自己的Docker主机上运行示例，则需要使用下面两个命令来停止并删除容器。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> docker container stop 3027eb64487 </span></span><br><span class="line"><span class="meta">$</span><span class="bash"> docker container rm 3027eb64487</span></span><br></pre></td></tr></table></figure><h4 id="1-2-6-容器生命周期"><a href="#1-2-6-容器生命周期" class="headerlink" title="1.2.6 容器生命周期"></a><strong>1.2.6 容器生命周期</strong></h4><p>&emsp;&emsp;通常会认为容器不擅长持久化工作或者持久化数据，很大程度上是因为容器在非持久化领域上表现得太出色。但是在一个领域做得很好并不意味着不擅长其他的领域。很多虚拟机管理员会记得微软或者Oracle告诉他们不能在虚拟机中运行他们的应用，至少他们不会支持这么做。</p><p>&emsp;&emsp;容器的生命周期——从创建、运行、休眠，直至销毁的整个过程。</p><p>&emsp;&emsp;新建容器，命名为“percy”，意指持久化（persistent）。</p><figure class="highlight dockerfile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ docker container <span class="keyword">run</span><span class="bash"> --name percy -it ubuntu:latest /bin/bash</span></span><br><span class="line"><span class="bash">root@9cb2d2fd1d65:/<span class="comment">#</span></span></span><br></pre></td></tr></table></figure><p>&emsp;&emsp;接下来将一部分数据写入容器中。在新容器内部Shell中，执行下面的步骤来将部分数据写入到tmp目录下的某个文件中，并确认数据是否写入成功。</p><figure class="highlight elixir"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">root<span class="variable">@9cb2d2fd1d65</span><span class="symbol">:/</span><span class="comment"># cd tmp</span></span><br><span class="line"></span><br><span class="line">root<span class="variable">@9cb2d2fd1d65</span><span class="symbol">:/tmp</span><span class="comment"># ls -l </span></span><br><span class="line">total <span class="number">0</span></span><br><span class="line"></span><br><span class="line">root<span class="variable">@9cb2d2fd1d65</span><span class="symbol">:/tmp</span><span class="comment"># echo "DevOps FTW" &gt; newfile</span></span><br><span class="line"></span><br><span class="line">root<span class="variable">@9cb2d2fd1d65</span><span class="symbol">:/tmp</span><span class="comment"># ls -l </span></span><br><span class="line">total <span class="number">4</span> </span><br><span class="line">-rw-r--r-- <span class="number">1</span> root root <span class="number">14</span> May <span class="number">23</span> <span class="number">11</span><span class="symbol">:</span><span class="number">22</span> newfile</span><br><span class="line"></span><br><span class="line">root<span class="variable">@9cb2d2fd1d65</span><span class="symbol">:/tmp</span><span class="comment"># cat newfile </span></span><br><span class="line">DevOps FTW</span><br></pre></td></tr></table></figure><p>&emsp;&emsp;按Ctrl-PQ组合键退出当前容器。现在使用docker container stop命令来停止容器运行，切换到暂停（vacation）状态。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> docker container stop percy</span></span><br></pre></td></tr></table></figure><p>&emsp;&emsp;现在运行docker container ls命令列出全部处于运行中状态的容器。</p><figure class="highlight inform7"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ docker <span class="keyword">container</span> ls </span><br><span class="line"><span class="keyword">CONTAINER</span> ID   IMAGE   COMMAND   CREATED  STATUS  PORTS   NAMES</span><br></pre></td></tr></table></figure><p>&emsp;&emsp;新建的容器没有列表中出现，原因是docker container stop命令使该容器停止运行。加上-a参数再次运行前面的命令，就会显示出全部的容器，包括处于停止状态的。</p><figure class="highlight jboss-cli"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$ docker container <span class="keyword">ls</span> -a </span><br><span class="line">CNTNR ID  IMAGE          COMMAND    CREATED   STATUS       NAMES </span><br><span class="line">9cb.<span class="string">..65</span>  ubuntu<span class="function">:latest</span>  <span class="string">/bin/bash</span>  4 mins    Exited <span class="params">(0)</span>   perc</span><br></pre></td></tr></table></figure><p>&emsp;&emsp;现在可以看到该容器显示当前状态为Exited(0)。停止容器就像停止虚拟机一样。尽管已经停止运行，容器的全部配置和内容仍然保存在Docker主机的文件系统之中，并且随时可以重新启动。</p><p>&emsp;&emsp;使用docker container start命令可以将容器重新启动。</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">$ docker container <span class="keyword">start</span> percy </span><br><span class="line">percy</span><br><span class="line"></span><br><span class="line">$ docker <span class="keyword">container</span> ls </span><br><span class="line"><span class="keyword">CONTAINER</span> <span class="keyword">ID</span>  IMAGE          COMMAND      CREATED  <span class="keyword">STATUS</span>     <span class="keyword">NAMES</span> </span><br><span class="line"><span class="number">9</span>cb2d2fd1d65  ubuntu:latest  <span class="string">"/bin/bash"</span>  <span class="number">4</span> mins   Up <span class="number">3</span> secs  percy</span><br></pre></td></tr></table></figure><p>&emsp;&emsp;现在停止的容器已经重新启动了，此时可以确认之前创建的文件是否还存在。使用docker container exec命令连接到重启后的容器。</p><figure class="highlight elixir"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable">$ </span>docker container exec -it percy bash </span><br><span class="line">root<span class="variable">@9cb2d2fd1d65</span><span class="symbol">:/</span><span class="comment">#</span></span><br></pre></td></tr></table></figure><p>&emsp;&emsp;Shell提示符发生变化，提示正在容器内部空间进行操作。确认之前创建的文件依然存在，并且文件中仍包含之前写入的数据。</p><figure class="highlight elixir"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">root<span class="variable">@9cb2d2fd1d65</span><span class="symbol">:/</span><span class="comment"># cd tmp </span></span><br><span class="line">root<span class="variable">@9cb2d2fd1d65</span><span class="symbol">:/</span><span class="comment"># ls -l </span></span><br><span class="line">-rw-r--r-- <span class="number">1</span> root root <span class="number">14</span> Sep <span class="number">13</span> <span class="number">04</span><span class="symbol">:</span><span class="number">22</span> newfile </span><br><span class="line">root<span class="variable">@9cb2d2fd1d65</span><span class="symbol">:/</span><span class="comment"># </span></span><br><span class="line">root<span class="variable">@9cb2d2fd1d65</span><span class="symbol">:/</span><span class="comment"># cat newfile </span></span><br><span class="line">DevOps FTW</span><br></pre></td></tr></table></figure><p>&emsp;&emsp;之前创建的文件依然存在，数据也是当时的状态，这证明停止容器运行并不会损毁容器或者其中的数据。</p><p>&emsp;&emsp;尽管上面的示例阐明了容器的持久化特性，还是需要指出<strong>卷</strong>（volume）才是在容器中存储持久化数据的首选方式。到目前为止，我们应该对容器和虚拟机之间的主要区别有了深刻的印象。</p><p>&emsp;&emsp;现在停止该容器并从系统中删除它。通过在docker container rm命令后面添加-f参数来一次性删除运行中的容器是可行的。但是，删除容器的最佳方式还是分两步，先停止容器然后删除。这样可以给容器中运行的应用/进程一个停止运行并清理残留数据的机会。</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">$ docker container <span class="keyword">stop</span> percy percy</span><br><span class="line"></span><br><span class="line">$ docker <span class="keyword">container</span> rm percy percy</span><br><span class="line"></span><br><span class="line">$ docker <span class="keyword">container</span> ls -a </span><br><span class="line"><span class="keyword">CONTAINER</span> <span class="keyword">ID</span>    IMAGE      COMMAND      CREATED   <span class="keyword">STATUS</span>   PORTS     <span class="keyword">NAME</span></span><br></pre></td></tr></table></figure><p>&emsp;&emsp;总结一下容器的生命周期。可以根据需要多次停止、启动、暂停以及重启容器，并且这些操作执行得很快。但是容器及其数据是安全的。直至明确删除容器前，容器都不会丢弃其中的数据。就算容器被删除了，如果将容器数据存储在卷中，数据也会被保存下来。</p><h4 id="1-2-7-优雅地停止容器"><a href="#1-2-7-优雅地停止容器" class="headerlink" title="1.2.7 优雅地停止容器"></a><strong>1.2.7 优雅地停止容器</strong></h4><p>&emsp;&emsp;Linux中的大部分容器都会运行单一进程；在Windows中可能运行若干个，但是下面的原则对于两者都适用。</p><p>&emsp;&emsp;前面的示例中容器正在运行/bin/bash应用。当使用docker container rm \&lt; container&gt; -f来销毁运行中的容器时，不会发出任何告警。这个过程相当暴力，但是，docker container stop命令就有礼貌多了。该命令给容器内进程发送将要停止的警告信息，给进程机会来有序处理停止前要做的事情。一旦docker stop命令返回后，就可以使用docker container rm命令删除容器了。</p><p>&emsp;&emsp;这背后的原理可以通过Linux/POSIX信号来解释。stop命令向容器内的PID 1进程发送了SIGTERM这样的信号。就像前文提到的一样，会为进程预留一个清理并优雅停止的机会。如果10s内进程没有终止，那么就会收到SIGKILL信号。这是致命一击。但是，进程起码有10s的时间来“解决”自己。而rm命令会直接发出SIGKILL。</p><h4 id="1-2-8-利用重启策略进行容器的自我修复"><a href="#1-2-8-利用重启策略进行容器的自我修复" class="headerlink" title="1.2.8 利用重启策略进行容器的自我修复"></a><strong>1.2.8 利用重启策略进行容器的自我修复</strong></h4><p>&emsp;&emsp;通常建议在运行容器时配置好重启策略。这是容器的一种自我修复能力，可以在指定事件或者错误后重启来完成自我修复。</p><p>&emsp;&emsp;重启策略应用于每个容器，可以作为参数被强制传入docker container run命令中，或者在Compose文件中声明（在使用Docker Compose以及Docker Stacks的情况下）。容器支持的重启策略包括always、unless stopped和on-failed。</p><p>&emsp;&emsp;<strong>always策略</strong>是一种简单的方式。除非容器被明确停止，比如通过docker container stop命令，否则该策略会一直尝试重启处于停止状态的容器。</p><p>&emsp;&emsp;一种简单的证明方式是启动一个新的交互式容器，并在命令后面指定–restart always策略，同时在命令中指定运行Shell进程。当容器启动的时候，会登录到该Shell。退出Shell时会杀死容器中PID为1的进程，并且杀死这个容器。但是因为指定了–restart always策略，所以容器会自动重启。如果运行docker container ls命令，就会看到容器的启动时间小于创建时间。下面请看示例。</p><figure class="highlight jboss-cli"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">$ docker container run <span class="params">--name</span> neversaydie -it <span class="params">--restart</span> always alpine sh</span><br><span class="line"></span><br><span class="line"><span class="string">//</span>等待几秒后输入exit</span><br><span class="line"></span><br><span class="line">/<span class="comment"># exit</span></span><br><span class="line"></span><br><span class="line">$ docker container <span class="keyword">ls</span> </span><br><span class="line">CONTAINER ID    IMAGE     COMMAND     CREATED           STATUS </span><br><span class="line">0901afb84439    alpine    <span class="string">"sh"</span>        35 seconds ago    Up 1 second</span><br></pre></td></tr></table></figure><p>&emsp;&emsp;注意，容器于35s前被创建，但却在1s前才启动。这是因为在容器中输入退出命令的时候，容器被杀死，然后Docker又重新启动了该容器。</p><p>&emsp;&emsp;<strong>–restart always策略</strong>有一个很有意思的特性，当daemon重启的时候，停止的容器也会被重启。例如，新创建一个容器并指定-restart always策略，然后通过docker container stop命令停止该容器。现在容器处于Stopped (Exited)状态。但是，如果重启Docker daemon，当daemon启动完成时，该容器也会重新启动。</p><p>&emsp;&emsp;always和unless-stopped的最大区别，就是那些指定了-restart unless-stopped并处于Stopped (Exited)状态的容器，不会在Docker daemon重启的时候被重启。</p><p>&emsp;&emsp;下面创建两个新容器，其中“always”容器指定–restart always策略，另一个“unless- stopped”容器指定了–restart unlessstopped策略。两个容器均通过docker container stop命令停止，接着重启Docker。结果“always”容器会重启，但是“unless-stopped”容器不会。</p><p>&emsp;&emsp;（1）创建两个新容器。</p><figure class="highlight sqf"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">$ docker container run -d --<span class="built_in">name</span> always \  </span><br><span class="line">  --restart always \  </span><br><span class="line">  alpine <span class="built_in">sleep</span> <span class="number">1</span>d</span><br><span class="line"></span><br><span class="line">$ docker container run -d --<span class="built_in">name</span> unless-<span class="built_in">stopped</span> \  </span><br><span class="line">  --restart unless-<span class="built_in">stopped</span> \  </span><br><span class="line">  alpine <span class="built_in">sleep</span> <span class="number">1</span>d</span><br><span class="line"></span><br><span class="line">$ docker container ls </span><br><span class="line">CONTAINER ID   <span class="built_in">IMAGE</span>    COMMAND      STATUS        NAMES </span><br><span class="line"><span class="number">3142</span>bd91ecc4   alpine   <span class="string">"sleep 1d"</span>   Up <span class="number">2</span> secs     unless-<span class="built_in">stopped</span> </span><br><span class="line"><span class="number">4</span>f1b431ac729   alpine   <span class="string">"sleep 1d"</span>   Up <span class="number">17</span> secs    always</span><br></pre></td></tr></table></figure><p>&emsp;&emsp;现在有两个运行的容器了。一个叫作“always”，另一个叫作“unlessstopped”。</p><p>&emsp;&emsp;（2）停止两个容器。</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">$ docker container <span class="keyword">stop</span> <span class="keyword">always</span> unless-stopped</span><br><span class="line"></span><br><span class="line">$ docker <span class="keyword">container</span> ls -a </span><br><span class="line"><span class="keyword">CONTAINER</span> <span class="keyword">ID</span>   IMAGE     <span class="keyword">STATUS</span>                        <span class="keyword">NAMES</span></span><br><span class="line"><span class="number">3142</span>bd91ecc4   alpine    Exited (<span class="number">137</span>) <span class="number">3</span> seconds ago    unless-stopped </span><br><span class="line"><span class="number">4</span>f1b431ac729   alpine    Exited (<span class="number">137</span>) <span class="number">3</span> seconds ago    <span class="keyword">always</span></span><br></pre></td></tr></table></figure><p>&emsp;&emsp;（3）重启Docker。重启Docker的过程在不同的操作系统上可能不同。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> systemlctl restart docker</span></span><br></pre></td></tr></table></figure><p>&emsp;&emsp;（4）一旦Docker重启成功，检查两个容器的状态。</p><figure class="highlight lsl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">$ docker container ls -a </span><br><span class="line">CONTAINER   CREATED           STATUS                        NAMES </span><br><span class="line"><span class="number">314</span>．.cc4    <span class="number">2</span> minutes ago    Exited (<span class="number">137</span>) <span class="number">2</span> minutes ago     unless-stoppe d </span><br><span class="line"><span class="number">4</span>f1.<span class="number">.729</span>    <span class="number">2</span> minutes ago    Up <span class="number">9</span> seconds                   always</span><br></pre></td></tr></table></figure><p>&emsp;&emsp;注意到“always”容器已经重启了，但是“unless-stopped”容器并没有重启。<strong>on-failure策略</strong>会在退出容器并且返回值不是0的时候，重启容器。就算容器处于stopped状态，在Docker daemon重启的时候，容器也会被重启。</p><p>&emsp;&emsp;如果使用Docker Compose或者Docker Stack，可以在service对象中配置重启策略，示例如下。</p><figure class="highlight dts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="symbol">version:</span> <span class="string">"3.5"</span> </span><br><span class="line"><span class="symbol">services:</span>  </span><br><span class="line"><span class="symbol">  myservice:</span></span><br><span class="line">    <span class="params">&lt;Snip&gt;</span>    </span><br><span class="line"><span class="symbol">    restart_policy:</span>      </span><br><span class="line"><span class="symbol">      condition:</span> always | unless-stopped | on-failure</span><br></pre></td></tr></table></figure><h4 id="1-2-9-Web服务器示例"><a href="#1-2-9-Web服务器示例" class="headerlink" title="1.2.9 Web服务器示例"></a><strong>1.2.9 Web服务器示例</strong></h4><p>&emsp;&emsp;在该示例中，会使用到作者用于Pluralsight视频教程网站中的一个镜像。这个镜像会在8080端口启动一个相当简单的Web服务。</p><p>&emsp;&emsp;使用docker container stop以及docker container rm命令清理当前系统中的全部容器，然后运行下面的docker container run命令。</p><figure class="highlight vim"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">$ docker container run -d --name webserver -<span class="keyword">p</span> <span class="number">80</span>:<span class="number">8080</span> \  </span><br><span class="line">  nigelpoulton/pluralsight-docker-ci</span><br><span class="line"></span><br><span class="line">Unable <span class="keyword">to</span> <span class="keyword">find</span> image <span class="string">'nigelpoulton/pluralsight-docker-ci:latest'</span> locally </span><br><span class="line">lates<span class="variable">t:</span> Pulling from nigelpoulton/pluralsight-docker-ci </span><br><span class="line">a3ed95caeb02: Pull <span class="built_in">complete</span> </span><br><span class="line"><span class="number">3</span>b231ed5aa2f:  Pull <span class="built_in">complete</span> </span><br><span class="line"><span class="number">7</span>e4f9cd54d46:  Pull <span class="built_in">complete</span> </span><br><span class="line"><span class="number">929432235</span>e51:  Pull <span class="built_in">complete</span> </span><br><span class="line"><span class="number">6899</span>ef41c594:  Pull <span class="built_in">complete</span> </span><br><span class="line"><span class="number">0</span>b38fccd0da<span class="variable">b:</span>  Pull <span class="built_in">complete</span> </span><br><span class="line">Diges<span class="variable">t:</span> <span class="built_in">sha256</span>:<span class="number">7</span>a6b0125fe7893e70dc63b2...<span class="number">9</span>b12a28e2c38bd8d3d </span><br><span class="line">Statu<span class="variable">s:</span> Downloaded newer image <span class="keyword">for</span> nigelpoulton/plur...docker-ci:latest <span class="number">6</span>efa1838cd51b92a4817e0e7483d103bf72a7ba7ffb5855080128d85043fef21</span><br></pre></td></tr></table></figure><p>&emsp;&emsp;注意，当前Shell提示符并未发生变化。这是因为使用了-d参数启动容器，并在后台运行。这种后台启动的方式不会将当前终端连接到容器当中。</p><p>&emsp;&emsp;该示例在docker container run命令中抛出了一些额外的参数，已知docker container run会启动一个新容器，但是这次使 用-d参数替换了-it。-d表示后台模式，告知容器在后台运行。然后为容器命名，并且指定了-p 80:8080。-p参数将Docker主机的端口映射到容器内。本例中，将Docker主机的80端口映射到了容器内的8080端口。这意味着当有流量访问主机的80端口的时候，流量会直接映射到容器内的8080端口。之所以如此是因为当前使用的镜像，其Web服务监听了8080端口。这意味着容器启动时会运行一个Web服务，监听8080端口。</p><p>&emsp;&emsp;最终，命令中还指定Docker所使用的镜像：nigelpoulton/pluralsight-docker-ci。这个镜像不一定保持更新，并且可能存在缺陷。使用docker container ls命令可以查看当前运行的容器以及端口的映射情况。端口信息按照host-port:container-port的格式显 示，明确这一点很重要。</p><figure class="highlight clean"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">$ docker container ls </span><br><span class="line">CONTAINER ID  COMMAND         STATUS       PORTS               NAMES </span><br><span class="line"><span class="number">6</span>efa1838cd51  /bin/sh -c...   Up <span class="number">2</span> mins  <span class="number">0.0</span><span class="number">.0</span><span class="number">.0</span>:<span class="number">80</span>-&gt;<span class="number">8080</span>/tcp  webserver</span><br><span class="line">......</span><br></pre></td></tr></table></figure><p>&emsp;&emsp;现在容器已经运行，端口也映射成功，可以通过浏览器来访问该容器，需要在浏览器中指定Docker主机的IP地址或DNS名称，端口号是80。</p><h4 id="1-2-10-查看容器详情"><a href="#1-2-10-查看容器详情" class="headerlink" title="1.2.10 查看容器详情"></a><strong>1.2.10 查看容器详情</strong></h4><p>&emsp;&emsp;在前面的示例当中，我们可能发现当运行docker container run命令的时候，并没有指定容器中的具体应用。但是容器却启动了一个简单的Web服务，这是如何发生的？</p><p>&emsp;&emsp;当构建Docker镜像的时候，可以通过嵌入指令来列出希望容器运行时启动的默认应用。如果运行docker image inspect命令来查看运行容器时使用的镜像，就能看到容器启动时将要运行的应用列表了。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> docker image inspect nigelpoulton/pluralsight-docker-ci</span></span><br><span class="line">...</span><br></pre></td></tr></table></figure><p>&emsp;&emsp;Cmd一项中展示了容器将会执行的命令或应用，除非在启动的时候指定另外的应用。如果去掉示例脚本中的转义字符，可以得到这样的命令：/bin/sh -c “cd /src &amp;&amp; node ./app.js。这是基于该镜像的容器会默认运行的应用。在构建镜像时指定默认命令是一种很普遍的做法，因为这样可以简化容器的启动。这也为镜像指定了默认的行为，并且从侧面阐述了镜像的用途——可以通过Inspect镜像的方式来了解所要运行的应用。</p><h4 id="1-2-11-快速清理"><a href="#1-2-11-快速清理" class="headerlink" title="1.2.11 快速清理"></a><strong>1.2.11 快速清理</strong></h4><p>&emsp;&emsp;接下来了解一种简单且快速的清理Docker主机上全部运行容器的方法。这种处理方式会强制删除所有的容器，并且不会给容器 完成清理的机会。<strong>这种操作一定不能在生产环境系统或者运行着重要容器的系统上执行</strong>。</p><p>&emsp;&emsp;在Docker主机的Shell中运行下面的命令，可以删除全部容器。</p><figure class="highlight mel"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ docker <span class="keyword">container</span> rm $(docker <span class="keyword">container</span> <span class="keyword">ls</span> -aq) -f </span><br><span class="line"><span class="number">6</span>efa1838cd51</span><br></pre></td></tr></table></figure><p>&emsp;&emsp;在本例中，因为只有一个运行中的容器，所以只有一个容器被删除（6efa1838cd51）。如果将$(docker container ls -aq)作为参数传递给docker container rm命令，等价于将系统中每个容器的ID传给该命令。-f标识表示强制执行，所以即使是处于运行状态的容器也会被删除。</p><hr><h3 id="1-3-命令"><a href="#1-3-命令" class="headerlink" title="1.3 命令"></a><strong>1.3 命令</strong></h3><p>&emsp;&emsp;容器中常用命令。</p><blockquote><ul><li>docker container run是启动新容器的命令。该命令的最简形式接收镜像和命令作为参数。镜像用于创建容器，而命令则是希望容器运行的应用。docker container run -it ubuntu /bin/bash命令会在前台启动一个Ubuntu容器，并运行Bash Shell。 </li><li>Ctrl-PQ会断开Shell和容器终端之间的链接，并在退出后保持容器在后台处于运行（UP）状态。 </li><li>docker container ls用于列出所有在运行（UP）状态的容器。如果使用-a标记，还可以看到处于停止（Exited）状态的容器。 </li><li>docker container exec允许用户在运行状态的容器中，启动一个新进程。该命令在将Docker主机Shell连接到一个运行中容器终端时非常有用。docker container exec -it \&lt; container-name or container-id&gt; bash命令会在容器内部启动一个Bash Shell进程，并连接到该Shell。为了使该命令生效，用于创建容器的镜像必须包含Bash Shell。 </li><li>docker container stop命令会停止运行中的容器，并将状态置为Exited(0)。该命令通过发送SIGTERM信号给容器内PID为1的进程达到目的。如果进程没有在10s之内得到清理并停止运行，那么会接着发送SIGKILL信号来强制停止该容器。docker container stop可以接收容器ID以及容器名称作为参数。 </li><li>docker container start会重启处于停止（Exited）状态的容器。可以在docker container start命令中指定容器的名称或者ID。 </li><li>docker container rm会删除停止运行的容器。可以通过容器名<br>称或者ID来指定要删除的容器。推荐首先使用docker container stop命令停止容器，然后使用docker container rm来完成删除。 </li><li>docker container inspect命令会显示容器的配置细节和运行时信息。该命令接收容器名称和容器ID作为主要参数。</li></ul></blockquote><hr><p><em>参考博客和文章书籍等：</em></p><blockquote><p>《深入浅出Docker》</p></blockquote><p><em>因博客主等未标明不可引用，若部分内容涉及侵权请及时告知，我会尽快修改和删除相关内容</em></p>]]></content>
    
    <summary type="html">
    
      简单介绍Docker（四）容器，内容包括：简介，详解（容器vs虚拟机、虚拟机的额外开销、检查Docker daemon、启动一个简单容器、容器进程、容器生命周期、优雅地停止容器、利用重启策略进行容器的自我修复、Web服务器示例、查看容器详情、快速清理），命令等。
    
    </summary>
    
      <category term="技术文档" scheme="http://linyishui.top/categories/%E6%8A%80%E6%9C%AF%E6%96%87%E6%A1%A3/"/>
    
    
      <category term="docker" scheme="http://linyishui.top/tags/docker/"/>
    
  </entry>
  
  <entry>
    <title>Docker（三）镜像</title>
    <link href="http://linyishui.top/2019101101.html"/>
    <id>http://linyishui.top/2019101101.html</id>
    <published>2019-10-11T02:14:38.000Z</published>
    <updated>2019-12-11T06:14:20.570Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="Docker（三）镜像"><a href="#Docker（三）镜像" class="headerlink" title="Docker（三）镜像"></a><strong>Docker（三）镜像</strong></h1><h2 id="第一节-Docker镜像"><a href="#第一节-Docker镜像" class="headerlink" title="第一节 Docker镜像"></a><strong>第一节 Docker镜像</strong></h2><h3 id="1-1-简介"><a href="#1-1-简介" class="headerlink" title="1.1 简介"></a><strong>1.1 简介</strong></h3><p>&emsp;&emsp;如果读者之前曾经是VM管理员，则可以把Docker镜像理解为<strong>VM模板</strong>，VM模板就像停止运行的VM，而Docker镜像就像停止运行的容器； 如果读者是一名研发人员，可以将镜像理解为<strong>类</strong>（Class）。</p><p>&emsp;&emsp;需要先从<strong>镜像仓库服务</strong>中拉取镜像。常见的镜像仓库服务是Docker Hub，但是也存在其他镜像仓库服务。拉取操作会将镜像下载到本地Docker主机，可以使用该镜像启动一个或者多个容器。</p><p>&emsp;&emsp;镜像由多个层组成，每层叠加之后，从外部看来就如一个独立的对象。镜像内部是一个精简的操作系统（OS），同时还包含应用运行所必须的文件和依赖包。因为容器的设计初衷就是快速和小巧，所以镜像通常都比较小。</p><hr><h3 id="1-2-详解"><a href="#1-2-详解" class="headerlink" title="1.2 详解"></a><strong>1.2 详解</strong></h3><p>&emsp;&emsp;前面多次提到镜像就像停止运行的容器（类）。实际上，我们可以停止某个容器的运行，并从中创建新的镜像。所以镜像可以理解为一种构建时（build-time）结构，而容器可以理解为一种运行时（run-time）结构。</p><h4 id="1-2-1-镜像和容器"><a href="#1-2-1-镜像和容器" class="headerlink" title="1.2.1 镜像和容器"></a><strong>1.2.1 镜像和容器</strong></h4><p>&emsp;&emsp;通常使用docker container run和docker service create命令从某个镜像启动一个或多个容器。一旦容器从镜像启动后，二者之间就变成了互相依赖的关系，并且在镜像上启动的容器全部停止之前，镜像是无法被删除的。尝试删除镜像而不停止或销毁使用它的容器，会导致下面的错误。</p><figure class="highlight subunit"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">$ docker image rm </span><br><span class="line"><span class="keyword">Error </span>response from daemon: conflict: unable to remove repository referenc </span><br><span class="line">e \ </span><br><span class="line">"" (must force) - container  is using its referenc\ </span><br><span class="line">ed image</span><br></pre></td></tr></table></figure><h4 id="1-2-2-镜像通常比较小"><a href="#1-2-2-镜像通常比较小" class="headerlink" title="1.2.2 镜像通常比较小"></a><strong>1.2.2 镜像通常比较小</strong></h4><p>&emsp;&emsp;容器目的就是运行应用或者服务，这意味着<strong>容器的镜像中必须包含应用/服务运行所必需的操作系统和应用文件</strong>。但是，容器又追求快速和小巧，这意味着构建镜像的时候通常需要裁剪掉不必要的部分，保持较小的体积。例如，Docker镜像通常不会包含6个不同的Shell让用户选择——通常Docker镜像中只有一个精简的Shell，甚至没有Shell。镜像中还不包含内核——容器都是共享所在Docker主机的内核。所以有时会说容器仅包含必要的操作系统（通常只有操作系统文件和文件系统对象）。<em>Hyper-V容器运行在专用的轻量级VM上，同时利用VM内部的操作系统内核。</em></p><p>&emsp;&emsp;Windows镜像要比Linux镜像大一些，这与Windows OS工作原理相关。比如，未压缩的最新Microsoft .NET镜像 （microsoft/dotnet:latest）超过1.7GB。Windows Server 2016 Nano Server镜像（microsoft/nanoserver:latest）在拉取并解压后，其体积略大于1GB。</p><h4 id="1-2-3-拉取镜像"><a href="#1-2-3-拉取镜像" class="headerlink" title="1.2.3 拉取镜像"></a><strong>1.2.3 拉取镜像</strong></h4><p>&emsp;&emsp;Docker主机安装之后，本地并没有镜像。Linux Docker主机本地镜像仓库通常位于/var/lib/docker/\<storage-driver>，Windows Docker主机则是C:\ProgramData\docker\windowsfilter。可以使用以下命令检查Docker主机的本地仓库中是否包含镜像。</storage-driver></p><figure class="highlight crmsh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ docker image ls </span><br><span class="line">REPOSITORY  <span class="keyword">TAG</span>      <span class="title">IMAGE</span> ID      CREATED      SIZE</span><br></pre></td></tr></table></figure><p>&emsp;&emsp;将镜像取到Docker主机本地的操作是拉取。通过下面的命令可以将镜像拉取到本地，并观察其大小。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> docker image pull ubuntu:latest</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> docker image pull alpine:latest</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> docker image ls</span></span><br></pre></td></tr></table></figure><h4 id="1-2-4-镜像仓库服务"><a href="#1-2-4-镜像仓库服务" class="headerlink" title="1.2.4 镜像仓库服务"></a><strong>1.2.4 镜像仓库服务</strong></h4><p>&emsp;&emsp;Docker镜像存储在镜像仓库服务（Image Registry）当中。Docker客户端的镜像仓库服务是可配置的，默认使用Docker Hub。镜像仓库服务包含多个<strong>镜像仓库</strong>（Image Repository）。同样，一个镜像仓库中可以包含多个镜像。图6.2展示了包含3个镜像仓库的镜像仓库服务，其中每个镜像仓库都包含一个或多个镜像。</p><p><img src="https://pic-1258215793.cos.ap-shanghai.myqcloud.com/content/20191001/201910010118.png" alt="包含3个镜像仓库的镜像仓库服务"></p><p>&emsp;&emsp;顾名思义，官方仓库中的镜像是由Docker公司审查的。这意味着其中的镜像会及时更新，由高质量的代码构成，这些代码是安全的，有完善的文档和最佳实践。非官方仓库更像江湖侠客，其中的镜像不一定具备官方仓库的优点，但这并不意味着所有非官方仓库都是不好的！非官方仓库中也有一些很优秀的镜像。用户需要做的是在信任非官方仓库镜像代码之前保持谨慎。</p><h4 id="1-2-5-镜像命名和标签"><a href="#1-2-5-镜像命名和标签" class="headerlink" title="1.2.5 镜像命名和标签"></a><strong>1.2.5 镜像命名和标签</strong></h4><p>&emsp;&emsp;只需要给出镜像的名字和标签，就能在官方仓库中定位一个镜像（采用“:”分隔）。从官方仓库拉取镜像时，docker image pull命令的格式如下。</p><figure class="highlight elixir"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker image pull &lt;repository&gt;<span class="symbol">:&lt;tag&gt;</span></span><br></pre></td></tr></table></figure><p>&emsp;&emsp;在之前的Linux示例中，通过下面的两条命令完成Alpine和Ubuntu镜像的拉取。这两条命令从alpine和ubuntu仓库拉取了标有“latest”标签的镜像。</p><figure class="highlight arduino"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker <span class="built_in">image</span> pull alpine:latest docker <span class="built_in">image</span> pull ubuntu:latest</span><br></pre></td></tr></table></figure><p>&emsp;&emsp;首先，如果没有在仓库名称后指定具体的镜像标签，则Docker会假设用户希望拉取标签为latest的镜像。</p><p>&emsp;&emsp;其次，标签为latest的镜像不保证这是仓库中最新的镜像。例如，Alpine仓库中最新的镜像通常标签是edge。通常来讲，使用latest标签时需要谨慎！</p><p>&emsp;&emsp;从非官方仓库拉取镜像也是类似的，用户只需要在仓库名称面前加上Docker Hub的用户名或者组织名称。下面的示例展示了如何从tudemo仓库中拉取v2这个镜像，其中镜像的拥有者是Docker Hub账户nigelpoulton，一个不应该被信任的账户。</p><figure class="highlight maxima"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ docker <span class="built_in">image</span> pull nigelpoulton/tu-<span class="built_in">demo</span>:v2 </span><br><span class="line">//该命令会从以书作者的Docker Hub账号为命名空间的tu-<span class="built_in">demo</span>库中下载标签为v2的镜像</span><br></pre></td></tr></table></figure><h4 id="1-2-6-为镜像打多个标签"><a href="#1-2-6-为镜像打多个标签" class="headerlink" title="1.2.6 为镜像打多个标签"></a><strong>1.2.6 为镜像打多个标签</strong></h4><p>&emsp;&emsp;<strong>一个镜像可以根据用户需要设置多个标签</strong>。这是因为标签是存放在镜像元数据中的任意数字或字符串。</p><p>&emsp;&emsp;在docker image pull命令中指定-a参数来拉取仓库中的全部镜像。接下来可以通过运行docker image ls查看已经拉取的镜像。</p><figure class="highlight vim"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">$ docker image pull -<span class="keyword">a</span> nigelpoulton/<span class="keyword">tu</span>-demo</span><br><span class="line"></span><br><span class="line">lates<span class="variable">t:</span> Pulling from nigelpoulton/<span class="keyword">tu</span>-demo </span><br><span class="line"><span class="number">237</span>d5fcd25cf: Pull <span class="built_in">complete</span> </span><br><span class="line">a3ed95caeb02: Pull <span class="built_in">complete</span> </span><br><span class="line"><span class="symbol">&lt;Snip&gt;</span> </span><br><span class="line">Diges<span class="variable">t:</span> <span class="built_in">sha256</span>:<span class="number">42</span>e34e546cee61adb1...<span class="number">3</span>a0c5b53f324a9e1c1aae451e9 </span><br><span class="line">v1: Pulling from nigelpoulton/<span class="keyword">tu</span>-demo </span><br><span class="line"><span class="number">237</span>d5fcd25cf: Already <span class="built_in">exists</span> </span><br><span class="line">a3ed95caeb02: Already <span class="built_in">exists</span> </span><br><span class="line"><span class="symbol">&lt;Snip&gt;</span> </span><br><span class="line">Diges<span class="variable">t:</span> <span class="built_in">sha256</span>:<span class="number">9</span>ccc0c67e5c5eaae4b...<span class="number">624</span>c1d5c80f2c9623cbcc9b59a </span><br><span class="line">v2: Pulling from nigelpoulton/<span class="keyword">tu</span>-demo </span><br><span class="line"><span class="number">237</span>d5fcd25cf: Already <span class="built_in">exists</span> </span><br><span class="line">a3ed95caeb02: Already <span class="built_in">exists</span> </span><br><span class="line"><span class="symbol">&lt;Snip&gt;</span> </span><br><span class="line">Diges<span class="variable">t:</span> <span class="built_in">sha256</span>:d3c0d8c9d5719d31b7...<span class="number">9</span>fef58a7e038cf0ef2ba5eb74c </span><br><span class="line">Statu<span class="variable">s:</span> Downloaded newer image <span class="keyword">for</span> nigelpoulton/<span class="keyword">tu</span>-demo</span><br><span class="line"></span><br><span class="line">$ docker image <span class="keyword">ls</span> </span><br><span class="line">REPOSITORY              TAG     IMAGE ID       CREATED     SIZE </span><br><span class="line">nigelpoulton/<span class="keyword">tu</span>-demo     v2     <span class="number">6</span>ac21e..bead   <span class="number">1</span> yr ago    <span class="number">211.6</span> MB </span><br><span class="line">nigelpoulton/<span class="keyword">tu</span>-demo     latest <span class="number">9</span>b915a..<span class="number">1</span>e29   <span class="number">1</span> yr ago    <span class="number">211.6</span> MB </span><br><span class="line">nigelpoulton/<span class="keyword">tu</span>-demo     v1     <span class="number">9</span>b915a..<span class="number">1</span>e29   <span class="number">1</span> yr ago    <span class="number">211.6</span> MB</span><br></pre></td></tr></table></figure><p>&emsp;&emsp;刚才发生了如下几件事情：首先，该命令从nigelpoulton/tu-demo仓库拉取了3个镜像：latest、v1以及v2。其次，注意看docker image ls命令输出中的IMAGE ID这一列。可以发现只有两个不同的Image ID。这是因为实际只下载了两个镜像，其中一个镜像拥有两个标签。</p><p>&emsp;&emsp;这个示例也完美证明了前文中关于latest标签使用的警告。在本例中，latest标签指向了v1标签的镜像。这意味着latest实际指向了两个镜像中较早的那个版本，而不是最新的版本！latest是一个非强制标签，不保证指向仓库中最新的镜像！</p><h4 id="1-2-7-过滤docker-image-ls的输出内容"><a href="#1-2-7-过滤docker-image-ls的输出内容" class="headerlink" title="1.2.7 过滤docker image ls的输出内容"></a><strong>1.2.7 过滤docker image ls的输出内容</strong></h4><p>　<br>&emsp;&emsp;Docker提供–filter参数来过滤docker image ls命令返回的镜像列表内容。</p><p>&emsp;&emsp;下面的示例只会返回悬虚（dangling）镜像。</p><figure class="highlight crmsh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$ docker image ls --filter <span class="attr">dangling=</span><span class="literal">true</span> </span><br><span class="line">REPOSITORY    <span class="keyword">TAG</span>       <span class="title">IMAGE</span> ID       CREATED      SIZE </span><br><span class="line"><span class="tag">&lt;none&gt;</span>        <span class="tag">&lt;none&gt;</span>    <span class="number">4</span>fd34165afe0   <span class="number">7</span> days ago   <span class="number">14.5M</span>B</span><br></pre></td></tr></table></figure><p>&emsp;&emsp;那些没有标签的镜像被称为悬虚镜像，在列表中展示为\<none>: \<none>。通常出现这种情况，是因为构建了一个新镜像，然后为该镜像打了一个已经存在的标签。当此情况出现，Docker会构建新的镜像，然后发现已经有镜像包含相同的标签，接着Docker会移除旧镜像上面的标签，将该标签标在新的镜像之上。</none></none></p><p>&emsp;&emsp;例如，首先基于alpine:3.4构建一个新的镜像，并打上dodge:challenger标签。然后更新Dockerfile， 将alpine:3.4替换为alpine:3.5，并且再次执行docker image build命令。该命令会构建一个新的镜像，并且标签为dodge:challenger，同时移除了旧镜像上面对应的标签，旧镜像就变成了悬虚镜像。</p><p>&emsp;&emsp;可以通过docker image prune命令移除全部的悬虚镜像。如果添加了-a参数，Docker会额外移除没有被使用的镜像（那些没有被任何容器使用的镜像）。</p><blockquote><p>Docker目前支持如下的过滤器: </p><ul><li>dangling：可以指定true或者false，仅返回悬虚镜像（true），或者非悬虚镜像（false）。 </li><li>before：需要镜像名称或者ID作为参数，返回在之前被创建的全部镜像。 </li><li>since：与before类似，不过返回的是指定镜像之后创建的全部镜 像。 </li><li>label：根据标注（label）的名称或者值，对镜像进行过滤。docker image ls命令输出中不显示标注内容。</li></ul></blockquote><p>&emsp;&emsp;其他的过滤方式可以使用reference。下面就是使用reference完成过滤并且仅显示标签为latest的示例。</p><figure class="highlight subunit"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">$ docker image ls --filter=reference="*:latest" </span><br><span class="line">REPOSITORY   TAG      IMAGE ID        CREATED      SIZE </span><br><span class="line">alpine       latest   3fd9065eaf02    8 days ago   4.15MB </span><br><span class="line"><span class="keyword">test         </span>latest   8426e7efb777    3 days ago   122MB</span><br></pre></td></tr></table></figure><p>&emsp;&emsp;也可以使用–format参数来通过Go模板对输出内容进行格式化。例如，下面的指令将只返回Docker主机上镜像的大小属性。</p><figure class="highlight mel"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$ docker <span class="keyword">image</span> <span class="keyword">ls</span> --<span class="keyword">format</span> <span class="string">"&#123;&#123;.Size&#125;&#125;"</span> </span><br><span class="line"><span class="number">99.3</span>MB </span><br><span class="line"><span class="number">111</span>MB</span><br></pre></td></tr></table></figure><p>&emsp;&emsp;使用下面命令返回全部镜像，但是只显示仓库、标签和大小信息。</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">$</span> <span class="string">docker</span> <span class="string">image</span> <span class="string">ls</span> <span class="bullet">--format</span> <span class="string">"<span class="template-variable">&#123;&#123;.Repository&#125;&#125;</span>: <span class="template-variable">&#123;&#123;.Tag&#125;&#125;</span>: <span class="template-variable">&#123;&#123;.Size&#125;&#125;</span>"</span> </span><br><span class="line"><span class="attr">dodge:</span>  <span class="attr">challenger:</span> <span class="number">99.3</span><span class="string">MB</span> </span><br><span class="line"><span class="attr">ubuntu:</span> <span class="attr">latest:</span>     <span class="number">111</span><span class="string">MB</span></span><br></pre></td></tr></table></figure><p>&emsp;&emsp;如果需要更复杂的过滤，可以使用OS或者Shell自带的工具，比如Grep或者AWK。</p><h4 id="1-2-8-通过CLI方式搜索Docker-Hub"><a href="#1-2-8-通过CLI方式搜索Docker-Hub" class="headerlink" title="1.2.8 通过CLI方式搜索Docker Hub"></a><strong>1.2.8 通过CLI方式搜索Docker Hub</strong></h4><p>&emsp;&emsp;docker search命令允许通过CLI的方式搜索Docker Hub。可以通过“NAME”字段的内容进行匹配，并且基于返回内容中任意列的值进 行过滤。</p><p>&emsp;&emsp;简单模式下，该命令会搜索所有“NAME”字段中包含特定字符串的仓库。</p><figure class="highlight lsl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">$ docker search nigelpoulton </span><br><span class="line">NAME                         DESCRIPTION                STARS    AUTOMATED </span><br><span class="line">nigelpoulton/pluralsight..   Web app used in...         <span class="number">8</span>        [OK] </span><br><span class="line">nigelpoulton/tu-demo                                    <span class="number">7</span> </span><br><span class="line">nigelpoulton/k8sbook         Kubernetes Book web app    <span class="number">1</span> </span><br><span class="line">nigelpoulton/web-fe1         Web front end example      <span class="number">0</span></span><br><span class="line">nigelpoulton/hello-cloud     Quick hello-world image    <span class="number">0</span></span><br></pre></td></tr></table></figure><p>&emsp;&emsp;可以使用–filter “is-official=true”，使命令返回内容只显示官方镜像。通过”is-automated=true”只显示自动创建的仓库。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> docker search alpine --filter <span class="string">"is-official=true"</span></span></span><br><span class="line"><span class="meta">$</span><span class="bash"> docker search alpine --filter <span class="string">"is-automated=true"</span></span></span><br></pre></td></tr></table></figure><p>&emsp;&emsp;默认情况下，Docker只返回25行结果。但是可以指定–limit参数来增加返回内容行数，最多为100行。</p><h4 id="1-2-9-镜像和分层"><a href="#1-2-9-镜像和分层" class="headerlink" title="1.2.9 镜像和分层"></a><strong>1.2.9 镜像和分层</strong></h4><p>&emsp;&emsp;Docker镜像由一些松耦合的只读镜像层组成。如图6.3所示。</p><p><img src="https://pic-1258215793.cos.ap-shanghai.myqcloud.com/content/20191001/201910010119.png" alt="Docker镜像"></p><p>&emsp;&emsp;Docker负责堆叠这些镜像层，并且将它们表示为单个统一的对象。有多种方式可以查看和检查构成某个镜像的分层，在前面已经展示了其中一种。回顾一下docker image pull ubuntu:latest命令的输出内容。</p><figure class="highlight groovy"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">$ docker image pull <span class="string">ubuntu:</span>latest </span><br><span class="line"><span class="string">latest:</span> Pulling from library/ubuntu </span><br><span class="line"><span class="number">952132</span><span class="string">ac251a:</span> Pull  complete </span><br><span class="line"><span class="number">82659</span><span class="string">f8f1b76:</span> Pull  complete </span><br><span class="line"><span class="string">c19118ca682d:</span> Pull  complete </span><br><span class="line"><span class="number">8296858250</span><span class="string">fe:</span> Pull  complete </span><br><span class="line"><span class="number">24e0251</span><span class="string">a0e2c:</span> Pull complete</span><br><span class="line"><span class="string">Digest:</span> <span class="string">sha256:</span>f4691c96e6bbaa99d..<span class="number">.28</span>ae95a60369c506dd6e6f6ab </span><br><span class="line"><span class="string">Status:</span> Downloaded newer image <span class="keyword">for</span> <span class="string">ubuntu:</span>latest</span><br></pre></td></tr></table></figure><p>&emsp;&emsp;以Pull complete结尾的每一行都代表了镜像中某个被拉取的镜像层。可以看到，这个镜像包含5个镜像层。图6.4以图片形式将镜像层ID作为标识展示了这些分层。</p><p><img src="https://pic-1258215793.cos.ap-shanghai.myqcloud.com/content/20191001/201910010120.png" alt="镜像层"></p><p>&emsp;&emsp;另一种查看镜像分层的方式是通过docker image inspect命令。缩减之后的输出也显示该镜像包含5个镜像层。只不过这次的输出 内容中使用了镜像的SHA256散列值来标识镜像层。不过，两中命令都显示了镜像包含5个镜像层。</p><p>&emsp;&emsp;所有的Docker镜像都起始于一个基础镜像层，当进行修改或增加新的内容时，就会在当前镜像层之上，创建新的镜像层。</p><p>&emsp;&emsp;举一个简单的例子，假如基于Ubuntu Linux 16.04创建一个新的镜像，这就是新镜像的第一层；如果在该镜像中添加Python包，就会在基础镜像层之上创建第二个镜像层；如果继续添加一个安全补丁，就会创建第三个镜像层。该镜像当前已经包含3个镜像层，如图6.5所示（这只是一个用于演示的很简单的例子）。</p><p><img src="https://pic-1258215793.cos.ap-shanghai.myqcloud.com/content/20191001/201910010121.png" alt="基于Ubuntu Linux 16.04创建镜像"></p><p>&emsp;&emsp;在添加额外的镜像层的同时，镜像始终保持是当前所有镜像的组合。图6.6中举了一个简单的例子，每个镜像层包含3个文件，而镜像包含了来自两个镜像层的6个文件。</p><p><img src="https://pic-1258215793.cos.ap-shanghai.myqcloud.com/content/20191001/201910010122.png" alt="添加额外的镜像层后的镜像"></p><p>&emsp;&emsp;图6.7中展示了一个稍微复杂的三层镜像，在外部看来整个镜像只有6个文件，这是因为最上层中的文件7是文件5的一个更新版本。这种情况下，上层镜像层中的文件覆盖了底层镜像层中的文件。这样就使得 文件的更新版本作为一个新镜像层添加到镜像当中。</p><p><img src="https://pic-1258215793.cos.ap-shanghai.myqcloud.com/content/20191001/201910010123.png" alt="三层镜像"></p><p>&emsp;&emsp;Docker通过存储引擎（新版本采用快照机制）的方式来实现镜像层堆栈，并保证多镜像层对外展示为统一的文件系统。Linux上可用的存储引擎有AUFS、Overlay2、Device Mapper、Btrfs以及ZFS。每种存储引擎都基于Linux中对应的文件系统或者块设备技术，并且每种存储引擎都有其独有的性能特点。</p><p>图6.8展示了从系统角度看三层镜像，与系统显示相同的三层镜像。所有镜像层堆叠并合并，对外提供统一的视图。</p><p><img src="https://pic-1258215793.cos.ap-shanghai.myqcloud.com/content/20191001/201910010124.png" alt="从系统角度看三层镜像"></p><h4 id="1-2-10-共享镜像层"><a href="#1-2-10-共享镜像层" class="headerlink" title="1.2.10 共享镜像层"></a><strong>1.2.10 共享镜像层</strong></h4><p>&emsp;&emsp;多个镜像之间可以并且确实会共享镜像层。这样可以有效节省空间并提升性能。再回顾一下之前用于拉取nigelpoulton/tu-demo仓库下全部包含标签的docker image pull命令（包含-a参数）。</p><p>&emsp;&emsp;注意那些以Already exists结尾的行。由这几行可见，Docker很聪明，可以识别出要拉取的镜像中，哪几层已经在本地存在。在本例中，Docker首先尝试拉取标签为latest的镜像。然后，当拉取标签为v1和v2的镜像时，Docker注意到组成这两个镜像的镜像层，有一部分已经存在了。出现这种情况的原因是前面3个镜像相似度很高，所以共享了很多镜像层。</p><p>&emsp;&emsp;Docker在Linux上支持很多存储引擎（Snapshotter）。每个存储引擎都有自己的镜像分层、镜像层共享以及写时复制（CoW）技术的具体实现。但是其最终效果和用户体验是完全一致的。</p><h4 id="1-2-11-根据摘要拉取镜像"><a href="#1-2-11-根据摘要拉取镜像" class="headerlink" title="1.2.11 根据摘要拉取镜像"></a><strong>1.2.11 根据摘要拉取镜像</strong></h4><p>&emsp;&emsp;到目前为止介绍了如何通过标签来拉取镜像，但问题是标签是可变的！这意味着可能偶尔出现给镜像打错标签的情况，有时甚至会给新镜像打一个已经存在的标签。</p><p>&emsp;&emsp;假设镜像golftrack:1.5存在一个已知的Bug。因此可以拉取该镜像后修复它，并使用相同的标签将更新的镜像重新推送回仓库。</p><p>&emsp;&emsp;镜像golftrack:1.5存在Bug，这个镜像已经应用于生产环境。如果创建一个新版本的镜像，并修复了这个Bug。那么问题来了，构建新镜像并将其推送回仓库时使用了与问题镜像相同的标签！原镜像被覆盖，但在生产环境中遗留了大量运行中的容器，没有什么好办法区分正在使用的镜像版本是修复前还是修复后的，因为两个镜像的标签是相同的！<br>是时候轮到<strong>镜像摘要</strong>（Image Digest）出马了。</p><p>&emsp;&emsp;Docker 1.10中引入了新的<strong>内容寻址存储模型</strong>。作为模型的一部分，每一个镜像现在都有一个基于其内容的密码散列值（后文用摘要代指这个散列值）。因为摘要是镜像内容的一个散列值，所以镜像内容的变更一定会导致散列值的改变。这意味着摘要是不可变的。这种方式可以解决前面讨论的问题。</p><p>&emsp;&emsp;每次拉取镜像，摘要都会作为docker image pull命令返回代码的一部分。只需要在docker image ls命令之后添加–digests参数即可在本地查看镜像摘要。</p><figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">$ docker image pull alpine </span><br><span class="line">Using<span class="built_in"> default </span>tag: latest </span><br><span class="line">latest: Pulling <span class="keyword">from</span> library/alpine </span><br><span class="line">e110a4a17941: Pull complete </span><br><span class="line">Digest: sha256:3dcdb92d7432d56604d<span class="built_in">..</span>.6d99b889d0626de158f73a </span><br><span class="line">Status: Downloaded newer image <span class="keyword">for</span> alpine:latest</span><br><span class="line"></span><br><span class="line">$ docker image ls --digests alpine </span><br><span class="line">REPOSITORY  TAG     DIGEST              IMAGE ID      CREATED        SIZE </span><br><span class="line">alpine      latest  sha256:3dcd<span class="built_in">..</span>.f73a  4e38e38c8ce0  10 weeks ago   4.8 MB</span><br></pre></td></tr></table></figure><p>&emsp;&emsp;从上面的代码片段中可知，Alpine镜像的签名值：sha256:3dcdb92d7432d56604d… 6d99b889d0626de158f73a。</p><p>&emsp;&emsp;已知镜像的摘要，可以使用摘要值再次拉取这个镜像，确保准确拉取想要的镜像。截止当前没有原生Docker命令支持从远端镜像仓库服务（如Docker Hub）中获取镜像签名了。这意味着只能先通过标签方式拉取镜像到本地，然后自己维护镜像的摘要列表。</p><p>&emsp;&emsp;下面的例子首先在Docker主机上删除alpine:latest镜像，然后显示如何通过摘要（而不是标签）来再次拉取该镜像。</p><figure class="highlight llvm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">$ docker image rm alpine:latest </span><br><span class="line">Untagged: alpine:latest </span><br><span class="line">Untagged: alpine<span class="title">@sha256</span>:<span class="keyword">c</span><span class="number">0537</span>...<span class="number">7</span><span class="keyword">c</span><span class="number">0</span>a<span class="number">7726</span><span class="keyword">c</span><span class="number">88e2</span>bb<span class="number">7584</span>dc<span class="number">96</span> </span><br><span class="line">Deleted: sha<span class="number">256</span>:<span class="number">02674</span>b<span class="number">9</span>cb<span class="number">179</span>d...abff<span class="number">0</span><span class="keyword">c</span><span class="number">2</span>bf<span class="number">5</span>ceca<span class="number">5</span>bad<span class="number">72</span>cd<span class="number">9</span> </span><br><span class="line">Deleted: sha<span class="number">256</span>:e<span class="number">154057080</span>f<span class="number">40</span>...<span class="number">3823</span>bab<span class="number">1</span>be<span class="number">5</span>b<span class="number">86926</span><span class="keyword">c</span><span class="number">6</span>f<span class="number">860</span></span><br><span class="line"></span><br><span class="line">$ docker image pull alpine<span class="title">@sha256</span>:<span class="keyword">c</span><span class="number">0537</span>...<span class="number">7</span><span class="keyword">c</span><span class="number">0</span>a<span class="number">7726</span><span class="keyword">c</span><span class="number">88e2</span>bb<span class="number">7584</span>dc<span class="number">96</span> </span><br><span class="line">sha<span class="number">256</span>:<span class="keyword">c</span><span class="number">0537</span>...<span class="number">7726</span><span class="keyword">c</span><span class="number">88e2</span>bb<span class="number">7584</span>dc<span class="number">96</span>: Pulling from library/alpine </span><br><span class="line">cfc<span class="number">728</span><span class="keyword">c</span><span class="number">1</span><span class="keyword">c</span><span class="number">558</span>: Pull complete </span><br><span class="line">Digest: sha<span class="number">256</span>:<span class="keyword">c</span><span class="number">0537</span>ff<span class="number">6</span>a<span class="number">5218</span>...<span class="number">7</span><span class="keyword">c</span><span class="number">0</span>a<span class="number">7726</span><span class="keyword">c</span><span class="number">88e2</span>bb<span class="number">7584</span>dc<span class="number">96</span> </span><br><span class="line">Status: Downloaded newer image for alpine<span class="title">@sha256</span>:<span class="keyword">c</span><span class="number">0537</span>...bb<span class="number">7584</span>dc<span class="number">96</span></span><br></pre></td></tr></table></figure><h4 id="1-2-12-镜像散列值（摘要）"><a href="#1-2-12-镜像散列值（摘要）" class="headerlink" title="1.2.12 镜像散列值（摘要）"></a><strong>1.2.12 镜像散列值（摘要）</strong></h4><p>&emsp;&emsp;从Docker 1.10版本开始，镜像就是一系列松耦合的独立层的集合。镜像本身就是一个配置对象，其中包含了镜像层的列表以及一些元数据信息。<strong>镜像层</strong>才是实际数据存储的地方（比如文件等，镜像层之间是完全独立的，并没有从属于某个镜像集合的概念）。</p><p>&emsp;&emsp;镜像的唯一标识是一个加密ID，即配置对象本身的散列值。每个镜像层也由一个加密ID区分，其值为镜像层本身内容的散列值。这意味着修改镜像的内容或其中任意的镜像层，都会导致加密散列值的变化。所以，<strong>镜像和其镜像层都是不可变的</strong>，任何改动都能很轻松地被辨别。这就是所谓的<strong>内容散列</strong>（Content Hash）。</p><p>&emsp;&emsp;在推送和拉取镜像的时候，都会对镜像层进行压缩来节省网络带宽以及仓库二进制存储空间。但是压缩会改变镜像内容，这意味着镜像的内容散列值在推送或者拉取操作之后，会与镜像内容不相符！这显然是个问题。例如，在推送镜像层到Docker Hub的时候，Docker Hub会尝试确认接收到的镜像没有在传输过程中被篡改。为了完成校验，Docker Hub会根据镜像层重新计算散列值，并与原散列值进行比较。因为镜像在传输过程中被压缩（发生了改变），所以散列值的校验也会失败。为避免该问题，每个镜像层同时会包含一个<strong>分发散列值</strong> （Distribution Hash）。这是一个压缩版镜像的散列值，当从镜像仓库服务拉取或者推送镜像的时候，其中就包含了分发散列值，<strong>该散列值会用于校验拉取的镜像是否被篡改过</strong>。</p><p>&emsp;&emsp;这个内容寻址存储模型极大地提升了镜像的安全性，因为在拉取和推送操作后提供了一种方式来确保镜像和镜像层数据是一致的。该模型也解决了随机生成镜像和镜像层ID这种方式可能导致的ID冲突问题。</p><h4 id="1-2-13-多层架构的镜像"><a href="#1-2-13-多层架构的镜像" class="headerlink" title="1.2.13 多层架构的镜像"></a><strong>1.2.13 多层架构的镜像</strong></h4><p>&emsp;&emsp;Docker最值得称赞的一点就是使用方便。例如，运行一个应用就像拉取镜像并运行容器这么简单。无须担心安装、依赖或者配置的问题。但是，随着Docker的发展，事情开始变得复杂——尤其是在添加了新平台和架构之后，例如Windows、ARM以及s390x。在拉取镜像并运行之前，需要考虑镜像是否与当前运行环境的架构匹配，这破坏了Docker的流畅体验。</p><p>&emsp;&emsp;<strong>多架构镜像</strong>（Multi-architecture Image）的出现解决了这个问题！</p><p>&emsp;&emsp;Docker（镜像和镜像仓库服务）规范目前支持多架构镜像。这意味着某个镜像仓库标签（repository:tag）下的镜像可以同时支持64位 Linux、PowerPC Linux、64位Windows和ARM等多种架构。简单地说，就是一个镜像标签之下可以支持多个平台和架构。</p><p>&emsp;&emsp;为了实现这个特性，镜像仓库服务API支持两种重要的结构： Manifest列表（新）和Manifest。Manifest列表是指某个镜像标签支持的架构列表。其支持的每种架构，都有自己的Mainfest定义，其中列举了该镜像的构成。</p><p>&emsp;&emsp;图6.9使用Golang官方镜像作为示例。图左侧是Manifest列表，其中包含了该镜像支持的每种架构。Manifest列表的每一项都有一个箭头，指向具体的Manifest，其中包含了镜像配置和镜像层数据。</p><p><img src="https://pic-1258215793.cos.ap-shanghai.myqcloud.com/content/20191001/201910010125.png" alt="Golang官方镜像"></p><p>&emsp;&emsp;在具体操作之前，先来了解一下原理：假设要在Raspberry Pi（基于ARM架构的Linux）上运行Docker。在拉取镜像的时候，Docker客户端会调用Docker Hub镜像仓库服务相应的API完成拉取。如果该镜像有Mainfest列表，并且存在Linux on ARM这一项，则Docker Client就会找到ARM架构对应的Mainfest并解析出组成 该镜像的镜像层加密ID。然后从Docker Hub二进制存储中拉取每个镜像层。</p><p>&emsp;&emsp;下面的示例就展示了多架构镜像是如何在拉取官方Golang镜像时工作的，并且通过一个简单的命令展示了Go的版本和所在主机的CPU架构。需要注意的是，两个例子都使用相同的命令 docker container run。不需要告知Docker具体的镜像版本是64位Linux还是64位Windows。示例中只运行了普通的命令，选择当前平台和架构所需的正确镜像版本是有由Docker完成的。</p><figure class="highlight vim"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">$ docker container run --rm golang <span class="keyword">go</span> <span class="keyword">version</span></span><br><span class="line"></span><br><span class="line">Unable <span class="keyword">to</span> <span class="keyword">find</span> image <span class="string">'golang:latest'</span> locally</span><br><span class="line">lates<span class="variable">t:</span> Pulling from library/golang </span><br><span class="line"><span class="number">723254</span>a2c089: Pull <span class="built_in">complete</span> </span><br><span class="line"><span class="symbol">&lt;Snip&gt;</span> </span><br><span class="line"><span class="number">39</span>cd5f38ffb8: Pull <span class="built_in">complete</span> </span><br><span class="line">Diges<span class="variable">t:</span> <span class="built_in">sha256</span>:<span class="number">947826</span>b5b6bc4... </span><br><span class="line">Statu<span class="variable">s:</span> Downloaded newer image <span class="keyword">for</span> golan<span class="variable">g:latest</span> </span><br><span class="line"><span class="keyword">go</span> <span class="keyword">version</span> go1.<span class="number">9.2</span> linux/amd64</span><br></pre></td></tr></table></figure><p>&emsp;&emsp;前面的操作包括从Docker Hub拉取Golang镜像，以容器方式启动，执行go version命令，并且输出Go的版本和主机OS / CPU架构信息。最后一行展示了go version命令的输出内容。</p><p>&emsp;&emsp;全面支持各种架构的工作仍在推进当中。创建支持多架构的镜像需要镜像的发布者做更多的工作。同时，某些软件也并非跨平台的。在这个前提下，Manifest列表是可选的——在没有Manifest列表的情况下，镜像仓库服务会返回普通的Manifest。</p><h4 id="1-2-14-删除镜像"><a href="#1-2-14-删除镜像" class="headerlink" title="1.2.14 删除镜像"></a><strong>1.2.14 删除镜像</strong></h4><p>&emsp;&emsp;当不再需要某个镜像的时候，可以通过docker image rm命令从Docker主机删除该镜像。其中，rm是remove的缩写。</p><p>&emsp;&emsp;删除操作会在当前主机上删除该镜像以及相关的镜像层。这意味着无法通过docker image ls命令看到删除后的镜像，并且对应的包含镜像层数据的目录会被删除。但是，如果某个镜像层被多个镜像共享，那只有当全部依赖该镜像层的镜像都被删除后，该镜像层才会被删除。如果被删除的镜像上存在运行状态的容器，那么删除操作不会被允许。再次执行删除镜像命令之前，需要停止并删除该镜像相关的全部容器。</p><p>&emsp;&emsp;下面通过镜像ID来删除镜像。</p><figure class="highlight groovy"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">$ docker image rm <span class="number">02674</span>b9cb179 </span><br><span class="line"><span class="string">Untagged:</span> alpine<span class="meta">@sha</span><span class="number">256:</span>c0537ff6a5218...c0a7726c88e2bb7584dc96 </span><br><span class="line"><span class="string">Deleted:</span> <span class="string">sha256:</span><span class="number">02674</span>b9cb179d57..<span class="number">.31</span>ba0abff0c2bf5ceca5bad72cd9 </span><br><span class="line"><span class="string">Deleted:</span> <span class="string">sha256:</span>e154057080f4063..<span class="number">.2</span>a0d13823bab1be5b86926c6f860</span><br></pre></td></tr></table></figure><p>&emsp;&emsp;一种删除某Docker主机上全部镜像的快捷方式是在docker image rm命令中传入当前系统的全部镜像ID，可以通过docker image ls获取全部镜像ID（使用-q参数）。如果是在Windows环境中，那么只有在PowerShell终端中执行才会 生效。在CMD中执行并不会生效。</p><figure class="highlight mel"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ docker <span class="keyword">image</span> rm $(docker <span class="keyword">image</span> <span class="keyword">ls</span> -q) -f</span><br></pre></td></tr></table></figure><p>&emsp;&emsp;为了理解具体工作原理，首先下载一组镜像，然后通过运行docker image ls -q。</p><figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">$ docker image pull alpine </span><br><span class="line">Using<span class="built_in"> default </span>tag: latest </span><br><span class="line">latest: Pulling <span class="keyword">from</span> library/alpine </span><br><span class="line">e110a4a17941: Pull complete </span><br><span class="line">Digest: sha256:3dcdb92d7432d5<span class="built_in">..</span>.3626d99b889d0626de158f73a </span><br><span class="line">Status: Downloaded newer image <span class="keyword">for</span> alpine:latest</span><br><span class="line"></span><br><span class="line">$ docker image pull ubuntu </span><br><span class="line">Using<span class="built_in"> default </span>tag: latest </span><br><span class="line">latest: Pulling <span class="keyword">from</span> library/ubuntu </span><br><span class="line">952132ac251a: Pull complete </span><br><span class="line">82659f8f1b76:  Pull complete </span><br><span class="line">c19118ca682d:  Pull complete </span><br><span class="line">8296858250fe:  Pull complete </span><br><span class="line">24e0251a0e2c:  Pull complete </span><br><span class="line">Digest: sha256:f4691c96e6bba<span class="built_in">..</span>.128ae95a60369c506dd6e6f6ab </span><br><span class="line">Status: Downloaded newer image <span class="keyword">for</span> ubuntu:latest</span><br><span class="line"></span><br><span class="line">$ docker image ls -q </span><br><span class="line">bd3d4369aebc </span><br><span class="line">4e38e38c8ce0</span><br></pre></td></tr></table></figure><p>&emsp;&emsp;可以看到docker image ls -q命令只返回了系统中本地拉取的全部镜像的ID列表。将这个列表作为参数传给docker image rm会删除本地系统中的全部镜像。</p><figure class="highlight groovy"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">$ docker image rm $(docker image ls -q) -f </span><br><span class="line"><span class="string">Untagged:</span> <span class="string">ubuntu:</span>latest </span><br><span class="line"><span class="string">Untagged:</span> ubuntu<span class="meta">@sha</span><span class="number">256:</span>f4691c9..<span class="number">.2128</span>ae95a60369c506dd6e6f6ab </span><br><span class="line"><span class="string">Deleted:</span> <span class="string">sha256:</span>bd3d4369aebc494...fa2645f5699037d7d8c6b415a10 </span><br><span class="line"><span class="string">Deleted:</span> <span class="string">sha256:</span>cd10a3b73e247dd...c3a71fcf5b6c2bb28d4f2e5360b </span><br><span class="line"><span class="string">Deleted:</span> <span class="string">sha256:</span><span class="number">4</span>d4de39110cd250..<span class="number">.28</span>bfe816393d0f2e0dae82c363a </span><br><span class="line"><span class="string">Deleted:</span> <span class="string">sha256:</span><span class="number">6</span>a89826eba8d895...cb0d7dba1ef62409f037c6e608b </span><br><span class="line"><span class="string">Deleted:</span> <span class="string">sha256:</span><span class="number">33</span>efada9158c32d..<span class="number">.195</span>aa12859239d35e7fe9566056 </span><br><span class="line"><span class="string">Deleted:</span> <span class="string">sha256:</span>c8a75145fcc4e1a..<span class="number">.4129005e461</span>a43875a094b93412 </span><br><span class="line"><span class="string">Untagged:</span> <span class="string">alpine:</span>latest </span><br><span class="line"><span class="string">Untagged:</span> alpine<span class="meta">@sha</span><span class="number">256:</span><span class="number">3</span>dcdb92..<span class="number">.313626</span>d99b889d0626de158f73a </span><br><span class="line"><span class="string">Deleted:</span> <span class="string">sha256:</span><span class="number">4e38</span>e38c8ce0b8d..<span class="number">.6225e13</span>b0bfe8cfa2321aec4bba </span><br><span class="line"><span class="string">Deleted:</span> <span class="string">sha256:</span><span class="number">4</span>fe15f8d0ae69e1...eeeeebb265cd2e328e15c6a869f</span><br><span class="line"></span><br><span class="line">$ docker image ls </span><br><span class="line">REPOSITORY     TAG    IMAGE ID    CREATED    SIZE</span><br></pre></td></tr></table></figure><hr><h3 id="1-3-命令"><a href="#1-3-命令" class="headerlink" title="1.3 命令"></a><strong>1.3 命令</strong></h3><p>&emsp;&emsp;操作Docker镜像常用到的命令。</p><blockquote><ul><li><strong>docker image pull</strong> 是下载镜像的命令。镜像从远程镜像仓库服务的仓库中下载。默认情况下，镜像会从Docker Hub的仓库中拉取。docker image pull alpine:latest命令会从Docker Hub的alpine仓库中拉取标签为latest的镜像。 </li><li><strong>docker image ls</strong> 列出了本地Docker主机上存储的镜像。可以通过–digests参数来查看镜像的SHA256签名。 </li><li><strong>docker image inspect</strong> 命令非常有用！该命令完美展示了镜像的细节，包括镜像层数据和元数据。</li><li><strong>docker image rm</strong> 用于删除镜像。docker image rm alpine:latest命令的含义是删除alpine:latest镜像。当镜像存在关联的容器，并且容器处于运行（Up）或者停止（Exited）状态时，不允许删除该镜像。</li></ul></blockquote><hr><p><em>参考博客和文章书籍等：</em></p><blockquote><p>《深入浅出Docker》</p></blockquote><p><em>因博客主等未标明不可引用，若部分内容涉及侵权请及时告知，我会尽快修改和删除相关内容</em></p>]]></content>
    
    <summary type="html">
    
      简单介绍Docker（三）镜像，内容包括：简介，详解（镜像和容器、镜像通常比较小、拉取镜像、镜像仓库服务、镜像命名和标签、为镜像打多个标签、过滤docker image ls的输出内容、通过CLI方式搜索Docker Hub、镜像和分层、共享镜像层、根据摘要拉取镜像、镜像散列值（摘要）、多层架构的镜像、删除镜像），命令等。
    
    </summary>
    
      <category term="技术文档" scheme="http://linyishui.top/categories/%E6%8A%80%E6%9C%AF%E6%96%87%E6%A1%A3/"/>
    
    
      <category term="docker" scheme="http://linyishui.top/tags/docker/"/>
    
  </entry>
  
  <entry>
    <title>Docker（二）引擎</title>
    <link href="http://linyishui.top/2019101001.html"/>
    <id>http://linyishui.top/2019101001.html</id>
    <published>2019-10-10T10:21:48.000Z</published>
    <updated>2019-12-11T02:20:03.743Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="Docker（二）引擎"><a href="#Docker（二）引擎" class="headerlink" title="Docker（二）引擎"></a><strong>Docker（二）引擎</strong></h1><h2 id="第一节-Docker引擎"><a href="#第一节-Docker引擎" class="headerlink" title="第一节 Docker引擎"></a><strong>第一节 Docker引擎</strong></h2><h3 id="1-1-简介"><a href="#1-1-简介" class="headerlink" title="1.1 简介"></a><strong>1.1 简介</strong></h3><p>&emsp;&emsp;Docker引擎是用来运行和管理容器的核心软件。如果有对VMware略知一二，可以将Docker引擎理解为ESXi的角色。基于开放容器计划（OCI）相关标准的要求，Docker引擎采用了<strong>模块化</strong>的设计原则，其组件是可替换的。可以把Docker引擎看作汽车引擎——二者都是模块化的，并且由许多可交换的部件组成。</p><p>&emsp;&emsp;Docker引擎由如下主要的组件构成：Docker客户端 （Docker Client）、Docker守护进程（Docker daemon）、containerd以及runc，它们共同负责容器的创建和运行。总体逻辑如图所示。之后的整理中提到runc和containerd时，将一律使用小写的“r”和“c”。</p><p><img src="https://pic-1258215793.cos.ap-shanghai.myqcloud.com/content/20191001/201910010114.png" alt="Docker总体逻辑"></p><hr><h3 id="1-2-详解"><a href="#1-2-详解" class="headerlink" title="1.2 详解"></a><strong>1.2 详解</strong></h3><p>&emsp;&emsp;Docker首次发布时，引擎由两个核心组件构成：LXC 和 Docker daemon。</p><p>&emsp;&emsp;Docker daemon是单一的二进制文件，包含诸如Docker客户端、 Docker API、容器运行时、镜像构建等。</p><p>&emsp;&emsp;LXC提供了对诸如命名空间（Namespace）和控制组（CGroup）等基础工具的操作能力，它们是基于Linux内核的容器虚拟化技术。</p><p>&emsp;&emsp;图5.2阐释了在Docker旧版本中，Docker daemon、LXC和操作系统之间的交互关系。</p><p><img src="https://pic-1258215793.cos.ap-shanghai.myqcloud.com/content/20191001/201910010115.png" alt="先前的Docker架构"></p><h4 id="1-2-1-摆脱LXC"><a href="#1-2-1-摆脱LXC" class="headerlink" title="1.2.1 摆脱LXC"></a><strong>1.2.1 摆脱LXC</strong></h4><p>&emsp;&emsp;对LXC的依赖自始至终都是个问题。首先，LXC是基于Linux的。这对于一个想要跨平台的项目来说是个问题。其次，如此核心的组件依赖于外部工具，这会给项目带来巨大风险，甚至影响其发展。因此，Docker公司开发了名为Libcontainer的自研工具，用于替代LXC。Libcontainer的目标是成为与平台无关的工具，可基于不同内核为Docker上层提供必要的容器交互功能。在Docker 0.9版本中，Libcontainer取代LXC成为默认的执行驱动。</p><h4 id="1-2-2-摒弃大而全的Docker-daemon"><a href="#1-2-2-摒弃大而全的Docker-daemon" class="headerlink" title="1.2.2 摒弃大而全的Docker daemon"></a><strong>1.2.2 摒弃大而全的Docker daemon</strong></h4><p>&emsp;&emsp;随着时间的推移，Docker daemon的整体性带来了越来越多的问题。</p><blockquote><ul><li>难于变更。 </li><li>运行越来越慢。 </li><li>这并非生态（或Docker公司）所期望的。</li></ul></blockquote><p>&emsp;&emsp;Docker公司意识到了这些问题，开始努力着手拆解这个大而全的Docker daemon进程，并将其模块化。这项任务的目标是尽可能拆解出其中的功能特性，并用小而专的工具来实现它。这些小工具可以是可替换的，也可以被第三方拿去用于构建其他工具。这一计划遵循了在UNIX中得以实践并验证过的一种软件哲学：小而专的工具可以组装为大型工具。</p><p>&emsp;&emsp;这项拆解和重构Docker引擎的工作仍在进行中。不过，所有容器执行和容器运行时的代码已经完全从daemon中移除，并重构为小而专的工具。</p><p>&emsp;&emsp;目前Docker引擎的架构示意图如图5.3所示，图中有简要的描述。</p><p><img src="https://pic-1258215793.cos.ap-shanghai.myqcloud.com/content/20191001/201910010116.png" alt="Docker引擎的架构"></p><h4 id="1-2-3-开放容器计划（OCI）的影响"><a href="#1-2-3-开放容器计划（OCI）的影响" class="headerlink" title="1.2.3 开放容器计划（OCI）的影响"></a><strong>1.2.3 开放容器计划（OCI）的影响</strong></h4><p>&emsp;&emsp;当Docker公司正在进行Docker daemon进程的拆解和重构的时候，OCI也正在着手定义两个容器相关的规范（或者说标准）。</p><blockquote><ul><li>镜像规范。 </li><li>容器运行时规范</li></ul></blockquote><p>&emsp;&emsp;从Docker 1.11版本（2016年初）开始，Docker引擎尽可能实现了OCI的规范。如Docker daemon不再包含任何容器运行时的代码——<strong>所有的容器运行代码在一个单独的OCI兼容层中实现</strong>。</p><p>&emsp;&emsp;默认情况下，Docker使用runc来实现这一点。runc是OCI容器运行时标准的参考实现。如上面图5.3中的runc容器运行时层。runc项目的目标之一就是与OCI规范保持一致。目前OCI规范均为1.0版本，我们不希望它们频繁地迭代，毕竟稳定胜于一切。除此之外，Docker引擎中的containerd组件确保了Docker镜像能够以正确的OCI Bundle的格式传递给runc。</p><h4 id="1-2-4-runc"><a href="#1-2-4-runc" class="headerlink" title="1.2.4 runc"></a><strong>1.2.4 runc</strong></h4><p>&emsp;&emsp;runc是OCI容器运行时规范的参考实现。去粗取精，会发现runc实质上是一个轻量级的、针对Libcontainer进行了包装的命令行交互工具（Libcontainer取代了早期Docker架构中的LXC）。</p><p>&emsp;&emsp;runc生来只有一个作用——<strong>创建容器</strong>，这一点它非常拿手，速度很快！不过它是一个CLI包装器，实质上就是一个独立的容器运行时工具。因此直接下载它或基于源码编译二进制文件，即可拥有一个全功能的runc。但它只是一个基础工具，并不提供类似Docker引擎所拥有的丰富功能。有时也将runc所在的那一层称为“OCI层”，如图5.3所示。</p><h4 id="1-2-5-containerd"><a href="#1-2-5-containerd" class="headerlink" title="1.2.5 containerd"></a><strong>1.2.5 containerd</strong></h4><p>&emsp;&emsp;在对Docker daemon的功能进行拆解后，所有的容器执行逻辑被重构到一个新的名为containerd（发音为container-dee）的工具中。它的主要任务是容器的生命周期管理——start | stop | pause | rm….</p><p>&emsp;&emsp;containerd在Linux和Windows中以daemon的方式运行，从1.11版本之后Docker就开始在Linux上使用它。Docker引擎技术栈中，containerd位于daemon和runc所在的OCI层之间。Kubernetes也可以通过cricontainerd使用containerd。</p><p>&emsp;&emsp;如前所述，containerd最初被设计为轻量级的小型工具，仅用于容器的生命周期管理。然而，随着时间的推移，它被赋予了更多的功能， 比如镜像管理。<br>其原因之一在于，这样便于在其他项目中使用它。比如，在Kubernetes中，containerd就是一个很受欢迎的容器运行时。然而在Kubernetes这样的项目中，如果containerd能够完成一些诸如push和pull镜像这样的操作就更好了。因此，如今containerd还能够完成一些除容器生命周期管理之外的操作。不过，所有的额外功能都是模块化的、可选的，便于自行选择所需功能。所以，Kubernetes这样的项目在使用containerd时，可以仅包含所需的功能。</p><h4 id="1-2-6-启动一个新的容器"><a href="#1-2-6-启动一个新的容器" class="headerlink" title="1.2.6 启动一个新的容器"></a><strong>1.2.6 启动一个新的容器</strong></h4><p>&emsp;&emsp;现在我们对Docker引擎已经有了一个总体认识，下面介绍一下创建新容器的过程。</p><p>&emsp;&emsp;常用的启动容器的方法就是使用Docker命令行工具。下面的docker container run命令会基于alpine:latest镜像启动一个新容器。</p><figure class="highlight applescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ docker container <span class="built_in">run</span> <span class="comment">--name ctr1 -it alpine:latest sh</span></span><br></pre></td></tr></table></figure><p>&emsp;&emsp;当使用Docker命令行工具执行如上命令时，Docker客户端会将其转换为合适的API格式，并发送到正确的API端点。API是在daemon中实现的。这套功能丰富、基于版本的REST API已经成为Docker的标志，并且被行业接受成为事实上的容器API。</p><p>&emsp;&emsp;一旦daemon接收到创建新容器的命令，它就会向containerd发出调用。daemon已经不再包含任何创建容器的代码了！daemon使用一种CRUD风格的API，通过gRPC与containerd进行通信。虽然名叫containerd，但是它并不负责创建容器，而是指挥runc去做。containerd将Docker镜像转换为OCI bundle，并让runc基于此创建一个新的容器。</p><p>&emsp;&emsp;然后，runc与操作系统内核接口进行通信，基于所有必要的工具（Namespace、CGroup等）来创建容器。容器进程作为runc的子进程启动，启动完毕后，runc将会退出。</p><p>&emsp;&emsp;现在，容器启动完毕了。整个过程如图5.4所示。</p><p><img src="https://pic-1258215793.cos.ap-shanghai.myqcloud.com/content/20191001/201910010117.png" alt="启动新容器的过程"></p><h4 id="1-2-7-该模型的显著优势"><a href="#1-2-7-该模型的显著优势" class="headerlink" title="1.2.7 该模型的显著优势"></a><strong>1.2.7 该模型的显著优势</strong></h4><p>&emsp;&emsp;将所有的用于启动、管理容器的逻辑和代码从daemon中移除，意味着容器运行时与Docker daemon是解耦的，有时称之为“无守护进程的容器（daemonless container）”，如此，对Docker daemon的维护和升级工作不会影响到运行中的容器。</p><p>&emsp;&emsp;在旧模型中，所有容器运行时的逻辑都在daemon中实现，启动和停止daemon会导致宿主机上所有运行中的容器被杀掉。这在生产环境中是一个大问题——想一想新版Docker的发布频次吧，每次daemon的升级都会杀掉宿主机上所有的容器。</p><h4 id="1-2-8-shim"><a href="#1-2-8-shim" class="headerlink" title="1.2.8 shim"></a><strong>1.2.8 shim</strong></h4><p>&emsp;&emsp;shim是实现无daemon的容器（用于将运行中的容器与daemon解耦，以便进行daemon升级等操作）不可或缺的工具。</p><p>&emsp;&emsp;前面提到，containerd指挥runc来创建新容器。事实上，每次创建容器时它都会fork一个新的runc实例。不过，一旦容器创建完毕，对应的runc进程就会退出。因此，即使运行上百个容器，也无须保持上百个运行中的runc实例。一旦容器进程的父进程runc退出，相关联的containerd-shim进程就会成为容器的父进程。作为容器的父进程，shim的部分职责如下。</p><blockquote><ul><li>保持所有STDIN和STDOUT流是开启状态，从而当daemon重启的时候，容器不会因为管道（pipe）的关闭而终止。 </li><li>将容器的退出状态反馈给daemon。</li></ul></blockquote><h4 id="1-2-9-在Linux中的实现"><a href="#1-2-9-在Linux中的实现" class="headerlink" title="1.2.9 在Linux中的实现"></a><strong>1.2.9 在Linux中的实现</strong></h4><p>&emsp;&emsp;在Linux系统中，前面谈到的组件由单独的二进制来实现，具体包括dockerd(Docker daemon)、docker-containerd(containerd)、docker<br>containerd-shim (shim)和docker-runc (runc)。通过在Docker宿主机的Linux系统中执行ps命令可以看到以上组件的进程。当然，有些进程只有在运行容器的时候才可见。</p><h4 id="1-2-10-daemon的作用"><a href="#1-2-10-daemon的作用" class="headerlink" title="1.2.10 daemon的作用"></a><strong>1.2.10 daemon的作用</strong></h4><p>&emsp;&emsp;当所有的执行逻辑和运行时代码都从daemon中剥离出来之后，问题出现了——daemon中还剩什么？显然，随着越来越多的功能从daemon中拆解出来并被模块化，这一问题的答案也会发生变化。不过，当本书撰写时，daemon的主要功能包括镜像管理、镜像构建、REST API、身份验证、安全、核心网络以及编排。</p><hr><p><em>参考博客和文章书籍等：</em></p><blockquote><p>《深入浅出Docker》</p></blockquote><p><em>因博客主等未标明不可引用，若部分内容涉及侵权请及时告知，我会尽快修改和删除相关内容</em></p>]]></content>
    
    <summary type="html">
    
      简单介绍Docker（二）引擎，内容包括：简介，详解，摆脱LXC，摒弃大而全的Docker daemon，开放容器计划（OCI）的影响，runc，containerd，启动一个新的容器，该模型的显著优势，shim，在Linux中的实现，daemon的作用等。
    
    </summary>
    
      <category term="技术文档" scheme="http://linyishui.top/categories/%E6%8A%80%E6%9C%AF%E6%96%87%E6%A1%A3/"/>
    
    
      <category term="docker" scheme="http://linyishui.top/tags/docker/"/>
    
  </entry>
  
  <entry>
    <title>Docker（一）概览</title>
    <link href="http://linyishui.top/2019100701.html"/>
    <id>http://linyishui.top/2019100701.html</id>
    <published>2019-10-07T02:34:47.000Z</published>
    <updated>2019-12-10T10:25:40.790Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="Docker概览（一）概览"><a href="#Docker概览（一）概览" class="headerlink" title="Docker概览（一）概览"></a><strong>Docker概览（一）概览</strong></h1><h2 id="第一节-容器的发展"><a href="#第一节-容器的发展" class="headerlink" title="第一节 容器的发展"></a><strong>第一节 容器的发展</strong></h2><h3 id="1-1-过去"><a href="#1-1-过去" class="headerlink" title="1.1 过去"></a><strong>1.1 过去</strong></h3><p>&emsp;&emsp;过去服务器只能运行单一应用，旧时代的Windows和Linux系统都没有相应的技术手段来保证能够在一台服务器上稳定安全的同时运行多个应用。所以每当业务部门需要新增一个应用就要采购一台新的服务器，而对于应用所需服务器性能只能凭经验来推测，所以不得不买性能要大幅优于所需的硬件，最终必然造成大量的浪费。</p><h3 id="1-2-虚拟机"><a href="#1-2-虚拟机" class="headerlink" title="1.2 虚拟机"></a><strong>1.2 虚拟机</strong></h3><p>&emsp;&emsp;为了解决上述问题，VMware公司开发了<strong>虚拟机</strong>，终于可以有一种允许多应用能稳定安全运行在同一台服务器的技术。虚拟机是一项划时代的技术，让现有的资产可以发挥更多的作用。</p><p>&emsp;&emsp;但虚拟机需要依赖于其专用的操作系统，而OS会占用额外的CPU、RAM和存储，这些资源本可以用来运行更多的应用。每个OS都需要补丁和监控，还有一些情况下OS需要许可证才可以运行。还有一些挑战如虚拟机启动会较慢，可移植性很差等等。</p><h3 id="1-3-容器"><a href="#1-3-容器" class="headerlink" title="1.3 容器"></a><strong>1.3 容器</strong></h3><p>&emsp;&emsp;后来，像谷歌这样的公司开始采用容器（Container）技术来解决虚拟机的这些缺点。容器不会独占OS，从而节省了大量的系统资源，也省下了花费在许可证和为OS打补丁的运维成本。容器还有启动快和便于迁移等优势，从PC迁移到云上或再迁移到数据中心的虚拟机或物理机上都非常简单。</p><h3 id="1-4-Linux容器"><a href="#1-4-Linux容器" class="headerlink" title="1.4 Linux容器"></a><strong>1.4 Linux容器</strong></h3><p>&emsp;&emsp;现代的容器技术起源于Linux，是很多力量持续贡献的产物，这些年对容器影响较大的技术包括：内核命名空间、控制组、联合文件系统、当然还有Docker。</p><h3 id="1-5-Docker"><a href="#1-5-Docker" class="headerlink" title="1.5 Docker"></a><strong>1.5 Docker</strong></h3><p>&emsp;&emsp;容器技术的复杂度一直以来是导致其没有被普遍应用的原因，但Docker技术的诞生改变了这一情况。Docker使容器变得简单。</p><h3 id="1-6-Windows容器"><a href="#1-6-Windows容器" class="headerlink" title="1.6 Windows容器"></a><strong>1.6 Windows容器</strong></h3><p>&emsp;&emsp;近些年微软致力于在Windows平台发展Docker和容器技术，实现容器所需的核心Windows内核技术被统称为Windows容器。用户空间通过Docker来完成与Windows容器的交互，所以同Linux上使用Docker几乎一直。</p><p>&emsp;&emsp;运行中的容器共享宿主机的内核，这意味着基于Windows的容器化应用在Linux上是无法运行的，但目前Windows版Docker已可以在Windows模式和Linux模式间切换。Docker发展速度日新月异，请及时了解最新技术进展。</p><h3 id="1-7-Kubernetes"><a href="#1-7-Kubernetes" class="headerlink" title="1.7 Kubernetes"></a><strong>1.7 Kubernetes</strong></h3><p>&emsp;&emsp;Kubernetes是谷歌的一个开源项目，是容器编排领域的领头羊。简单理解就是Docker之上的一个平台，采用Docker作为其底层容器操作。</p><p>&emsp;&emsp;Kubernetes采用Docker作为其默认容器运行时（container runtime），包括Kubernetes启动和停止容器，以及镜像拉取等。Kubernetes提供了一个可插拔的容器运行时接口CRI，帮助Kubernetes实现将运行时环境从Docker快速替换为其他容器运行时，未来Kubernetes会将默认由Docker转为containerd。</p><hr><h2 id="第二节-了解Docker"><a href="#第二节-了解Docker" class="headerlink" title="第二节 了解Docker"></a><strong>第二节 了解Docker</strong></h2><h3 id="2-1-简介"><a href="#2-1-简介" class="headerlink" title="2.1 简介"></a><strong>2.1 简介</strong></h3><p>&emsp;&emsp;Docker是一种运行于Linux和Windows上的软件，<strong>用于创建、管理和编排容器</strong>。Docker是在GitHub上开发的Moby开源项目的一部分。Docker公司是整个Moby开源项目的维护者，还提供包含支持服务的商业版本的Docker。</p><blockquote><p><em>“Docker”一词来自英国口语，意为码头工人（Dock Worker），即从船上装卸货物的人</em></p></blockquote><h3 id="2-2-Docker运行时与编排引擎"><a href="#2-2-Docker运行时与编排引擎" class="headerlink" title="2.2 Docker运行时与编排引擎"></a><strong>2.2 Docker运行时与编排引擎</strong></h3><p>&emsp;&emsp;多数技术人员在谈到Docker时，主要是指Docker引擎。<strong>Docker引擎是用于运行和编排容器的基础设施工具</strong>。有VMware管理经验的读者可以将其类比为ESXi（运行虚拟机的核心管理程序），而Docker引擎是运行容器的核心容器运行时。</p><p>&emsp;&emsp;其他Docker公司或第三方的产品都是围绕Docker引擎进行开发和集成的。如图2.2所示，Docker引擎位于中心，其他产品基于Docker引擎的核心功能进行集成。</p><p><img src="https://pic-1258215793.cos.ap-shanghai.myqcloud.com/content/20191001/201910010111.png" alt="围绕Docker引擎进行开发和集成的产品"></p><p>&emsp;&emsp;Docker引擎可以从Docker网站下载，也可以基于GitHub上的源码进行构建。无论是开源版本还是商业版本，都有Linux和Windows版本。Docker引擎主要有两个版本：企业版（EE）和社区 版（CE）。每个季度，企业版和社区版都会发布一个稳定版本。社区版本会提供4个月的支持，而企业版本会提供12个月的支持。社区版还会通过Edge方式发布月度版。</p><h3 id="2-3-Docker开源项目（Moby）"><a href="#2-3-Docker开源项目（Moby）" class="headerlink" title="2.3 Docker开源项目（Moby）"></a><strong>2.3 Docker开源项目（Moby）</strong></h3><p>&emsp;&emsp;“Docker”一词也会用于指代开源Docker项目。其中包含一系列可以从Docker官网下载和安装的工具，比如Docker服务端和Docker客户端。不过，该项目在2017年于Austin举办的DockerCon上正式命名为Moby项目。由于这次改名，GitHub上的docker/docker库也被转移到了moby/moby。</p><p>&emsp;&emsp;Moby项目的目标是基于开源的方式，发展成为Docker上游，并将Docker拆分为更多的模块化组件。Moby项目托管于GitHub的Moby代码库，包括子项目和工具列表。核心的Docker引擎项目位于GitHub的moby/moby，但是引擎中的代码正持续被拆分和模块化。</p><p>&emsp;&emsp;多数项目及其工具都是基于Golang编写的，这是谷歌推出的一种新的系统级编程语言，又叫Go语言。使用Go语言的读者，将更容易为该项目贡献代码。</p><h3 id="2-4-容器生态"><a href="#2-4-容器生态" class="headerlink" title="2.4 容器生态"></a><strong>2.4 容器生态</strong></h3><p>&emsp;&emsp;Docker公司的一个核心哲学通常被称为“含电池，但可拆卸”（Batteries included but removable）。意思是许多Docker内置的组件都可以替换为第三方的组件，网络技术栈就是一个很好的例子。Docker核心产品内置有网络解决方案。但是网络技术栈是可插拔的，这意味着Docker内置的网络方案可以被替换为第三方的方案，许多人都会这样使用。</p><p>&emsp;&emsp;早期的时候，经常出现第三方插件比 Docker 提供的内置组件更好的情况。然而这会对Docker公司的商业模式造成冲击。毕竟，Docker公司需要依靠盈利来维持基业长青。因此，“内置的电池”变得越来越好用了。这也导致了生态内部的紧张关系和竞争的加剧。简单来说，Docker内置的“电池”仍然是可插拔的，然而越来越不需要将它们移除了。</p><h3 id="2-5-开放容器计划"><a href="#2-5-开放容器计划" class="headerlink" title="2.5 开放容器计划"></a><strong>2.5 开放容器计划</strong></h3><p>&emsp;&emsp;如果不谈及<strong>开放容器计划</strong>（The Open Container Initiative, OCI）的话，对Docker和容器生态的探讨总是不完整的。</p><p>&emsp;&emsp;<strong>OCI是一个旨在对容器基础架构中的基础组件</strong>（如镜像格式与容器运行时）进行标准化的管理委员会。简短的历史介绍是，一个名为CoreOS的公司不喜欢Docker的某些行事方式。因此它就创建了一个新的开源标准，称作“appc”，该标准涉及诸如镜像格式和容器运行时等方面。此外它还开发了一个名为rkt（发音“rocket”）的实现。</p><p>&emsp;&emsp;两个处于竞争状态的标准将容器生态置于一种尴尬的境地。这使容器生态陷入了分裂的危险中，同时也令用户和消费者陷入两难。虽然竞争是一件好事，但是标准的竞争通常不是。因为它会导致困扰，降低用户接受度，对谁都无益。</p><p>&emsp;&emsp;考虑到这一点，所有相关方都尽力用成熟的方式处理此事，共同成立了OCI——一个旨在管理容器标准的轻量级的、敏捷型的委员会。当前OCI已经发布了两份规范（标准）：镜像规范和运行时规范。Docker 1.11版本中，Docker引擎架构已经遵循OCI运行时规范了。到目前为止，OCI已经取得了不错的成效，将容器生态团结起来。OCI在Linux基金会的支持下运作，Docker公司和CoreOS公司都是主要贡献者。</p><hr><h2 id="第三节-安装Docker"><a href="#第三节-安装Docker" class="headerlink" title="第三节 安装Docker"></a><strong>第三节 安装Docker</strong></h2><p>&emsp;&emsp;Docker可以安装在Windows、Mac、Linux之上。除此之外还可以在云上安装，也可以在个人笔记本电脑上安装等等。本节仅整理比较重要的几种安装方式。</p><blockquote><p>1.桌面安装:</p><ul><li>Windows版Docker（Docker for Windows）</li><li>Mac版Docker（Docker for Mac）</li></ul><p>2.服务器安装: </p><ul><li>Linux</li><li>Windows Server 2016</li></ul><p>3.Docker引擎升级</p><p>4.Docker存储驱动的选择</p></blockquote><h3 id="3-1-Windows版Docker（DfW）"><a href="#3-1-Windows版Docker（DfW）" class="headerlink" title="3.1 Windows版Docker（DfW）"></a><strong>3.1 Windows版Docker（DfW）</strong></h3><p>&emsp;&emsp;Windows版Docker需要运行在一个安装了64位Windows 10 操作系统的计算机上，通过启动一个独立的引擎来提供Docker环境。</p><p>&emsp;&emsp;Windows版Docker是一个社区版本（Community Edition，CE）的应用，并不是为生产环境设计的。Windows版Docker在某些版本特性上可能是延后支持的。这是因为Docker公司对该产品的定位是稳定性第一，新特性其次。</p><blockquote><p>在安装之前，Windows版Docker的环境有以下要求:</p><ul><li>Windows 10 Pro / Enterprise / Education（1607 Anniversary Update、 Build 14393或者更新的版本）。 </li><li>Windows必须是64位的版本。 </li><li>需要启用Windows操作系统中的Hyper-V和容器特性。</li></ul></blockquote><h4 id="开启Hyper-V和容器"><a href="#开启Hyper-V和容器" class="headerlink" title="开启Hyper-V和容器"></a><strong>开启Hyper-V和容器</strong></h4><p>&emsp;&emsp;接下来的步骤会假设读者的计算机已经开启了BIOS设置中的硬件虚拟化支持。如果没有开启，则需要在机器上执行下面的步骤。</p><blockquote><p>首先，读者需要确认在Windows 10操作系统中，Hyper-V和容器特性已安装并且开启。</p><ol><li>右键单击Windows开始按钮并选择“应用和功能”页面。</li><li>单击“程序和功能”链接。</li><li>单击“启用或关闭Windows功能”。</li><li>确认Hyper-V和容器复选框已经被勾选，并单击确定按钮。</li></ol></blockquote><p>&emsp;&emsp;按上述步骤操作完成后，会安装并开启Hyper-V和容器特性，需要重启操作系统。之后就可以安装Windows版Docker。</p><blockquote><ol><li>访问Docker的下载页面，并单击其中的Download for Windows按钮。</li><li>单击后会跳转到Docker商店，需要读者使用自己的Docker ID进行登录。</li><li>单击任意Get Docker下载链接。Docker for Windows分为稳定版（Stable）和抢鲜版（Edge）。抢鲜版当中包含一些新特性，但是可能不够稳定。单击下载链接后，会将名为Docker for Windows Installer.exe的安装包下载到默认下载目录。</li><li>找到上一步下载的安装包并运行即可。</li></ol></blockquote><h4 id="家庭版手动伪装专业版"><a href="#家庭版手动伪装专业版" class="headerlink" title="家庭版手动伪装专业版"></a><strong>家庭版手动伪装专业版</strong></h4><p>&emsp;&emsp;windows10家庭版无法安装docker，没有Hyper-V等组件，需要下载docker toolbox安装，当然也可以直接将以下代码保存到.cmd文件并用管理员权限执行来安装Hyper-V。</p><figure class="highlight jboss-cli"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">pushd <span class="string">"%~dp0"</span></span><br><span class="line">dir <span class="string">/b</span> %SystemRoot%\servicing\Packages\*Hyper-V*<span class="string">.mum</span> &gt;hyper-v.txt</span><br><span class="line">for <span class="string">/f</span> %%i in <span class="params">('findstr /i . hyper-v.txt 2^&gt;nul')</span> do dism <span class="string">/online</span> <span class="string">/norestart</span> <span class="string">/add-package</span>:<span class="string">"%SystemRoot%\servicing\Packages\%%i"</span></span><br><span class="line">del hyper-v.txt</span><br><span class="line">Dism <span class="string">/online</span> <span class="string">/enable-feature</span> <span class="string">/featurename</span><span class="function">:Microsoft-Hyper-V-All</span> <span class="string">/LimitAccess</span> <span class="string">/ALL</span></span><br></pre></td></tr></table></figure><p>&emsp;&emsp;管理员身份执行以下cmd文件，伪装成win10专业版</p><figure class="highlight jboss-cli"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">REG ADD <span class="string">"HKEY_LOCAL_MACHINE\software\Microsoft\Windows NT\CurrentVersion"</span> <span class="string">/v</span> EditionId <span class="string">/T</span> REG_EXPAND_SZ <span class="string">/d</span> </span><br><span class="line">Professional <span class="string">/F</span></span><br></pre></td></tr></table></figure><p>&emsp;&emsp;但执行失败，所以还是用toolbox来安装了。</p><blockquote><p><a href="http://mirrors.aliyun.com/docker-toolbox/windows/docker-toolbox/" target="_blank" rel="noopener">http://mirrors.aliyun.com/docker-toolbox/windows/docker-toolbox/</a></p></blockquote><h4 id="正式安装"><a href="#正式安装" class="headerlink" title="正式安装"></a><strong>正式安装</strong></h4><p>&emsp;&emsp;以管理员身份运行安装向导，并按照提示一步一步完成整个安装过程。安装完成后Docker会作为系统服务自动启动，并且在Windows的通知栏看到Docker的大鲸鱼图标。</p><p>&emsp;&emsp;打开命令行或者PowerShell界面，并尝试执行下面的命令：</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">Client:</span> </span><br><span class="line"><span class="attr"> Version:</span>       <span class="number">18.01</span><span class="number">.0</span><span class="bullet">-ce</span> </span><br><span class="line"> <span class="string">API</span> <span class="attr">version:</span>   <span class="number">1.35</span> </span><br><span class="line"> <span class="string">Go</span> <span class="attr">version:</span>    <span class="string">go1.9.2</span> </span><br><span class="line"> <span class="string">Git</span> <span class="attr">commit:</span>    <span class="number">03596</span><span class="string">f5</span> </span><br><span class="line"><span class="attr"> Built:</span> <span class="string">Wed</span> <span class="string">Jan</span> <span class="number">10</span> <span class="number">20</span><span class="string">:05:55</span> <span class="number">2018</span> </span><br><span class="line"> <span class="string">OS/Arch:</span>       <span class="string">windows/amd64</span> </span><br><span class="line"><span class="attr"> Experimental:</span>  <span class="literal">false</span> </span><br><span class="line"><span class="attr"> Orchestrator:</span>  <span class="string">swarm</span></span><br><span class="line"><span class="attr">Server:</span> </span><br><span class="line"><span class="attr"> Engine:</span>  </span><br><span class="line"><span class="attr">  Version:</span>      <span class="number">18.01</span><span class="number">.0</span><span class="bullet">-ce</span>  </span><br><span class="line">  <span class="string">API</span> <span class="attr">version:</span>  <span class="number">1.35</span> <span class="string">(minimum</span> <span class="string">version</span> <span class="number">1.12</span><span class="string">)</span>  </span><br><span class="line">  <span class="string">Go</span> <span class="attr">version:</span>   <span class="string">go1.9.2</span>  </span><br><span class="line">  <span class="string">Git</span> <span class="attr">commit:</span>   <span class="number">03596</span><span class="string">f5</span>  </span><br><span class="line"><span class="attr">  Built:</span>        <span class="string">Wed</span> <span class="string">Jan</span> <span class="number">10</span> <span class="number">20</span><span class="string">:13:12</span> <span class="number">2018</span>  </span><br><span class="line">  <span class="string">OS/Arch:</span>      <span class="string">linux/amd64</span>  </span><br><span class="line"><span class="attr">  Experimental:</span> <span class="literal">false</span></span><br></pre></td></tr></table></figure><p>&emsp;&emsp;注意观察命令输出内容，其中Server部分中的OS/Arch属性展示了当前的操作系统是linux/amd64。这是因为在默认安装方式中，Docker daemon是运行在Hyper-V虚拟机中的一个轻量级Linux上的。这种情况下只能在Windows版Docker上运行Linux容器。</p><p>&emsp;&emsp;如果想要运行原生Windows容器（Native Windows Container），可以右击Windows通知栏中的Docker鲸鱼图标，并选择“切换到Windows容器”。使用下面的命令也可以完成切换（进入\Program Files\Docker\Docker目录下执行）。</p><figure class="highlight taggerscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">C:<span class="symbol">\P</span>rogram Files<span class="symbol">\D</span>ocker<span class="symbol">\D</span>ocker&gt; .<span class="symbol">\d</span>ockercli -SwitchDaemon</span><br></pre></td></tr></table></figure><p>&emsp;&emsp;如果已经开启了Windows容器特性，则只需要花费数秒就能完成切换。一旦切换完成，在命令行中执行docker version指令的输出内容如下。</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">C:</span><span class="string">\&gt;</span> <span class="string">docker</span> <span class="string">version</span> </span><br><span class="line"><span class="attr">Client:</span> </span><br><span class="line"> <span class="string">&lt;Snip&gt;</span></span><br><span class="line"><span class="attr">Server:</span> </span><br><span class="line"><span class="attr"> Engine:</span>  </span><br><span class="line"><span class="attr">  Version:</span>      <span class="number">18.01</span><span class="number">.0</span><span class="bullet">-ce</span>  </span><br><span class="line">  <span class="string">API</span> <span class="attr">version:</span>  <span class="number">1.35</span> <span class="string">(minimum</span> <span class="string">version</span> <span class="number">1.24</span><span class="string">)</span>  </span><br><span class="line">  <span class="string">Go</span> <span class="attr">version:</span>   <span class="string">go1.9.2</span></span><br><span class="line">  <span class="string">Git</span> <span class="attr">commit:</span>   <span class="number">03596</span><span class="string">f5</span>  </span><br><span class="line"><span class="attr">  Built:</span>        <span class="string">Wed</span> <span class="string">Jan</span> <span class="number">10</span> <span class="number">20</span><span class="string">:20:36</span> <span class="number">2018</span>  </span><br><span class="line">  <span class="string">OS/Arch:</span>      <span class="string">windows/amd64</span>  </span><br><span class="line"><span class="attr">  Experimental:</span> <span class="literal">true</span></span><br></pre></td></tr></table></figure><p>&emsp;&emsp;可以看到，现在Server版本信息变成了windows/amd64，这意味着Docker daemon运行在原生Windows内核上，并且只能运行Windows容器了。同时也可以发现，Experimental这个属性的值为true。这表示当前运行的Docker版本是实验版本。可以通过运行dockercli -Version命令来查看当前的Docker版本。dockercli命令在C:\Program Files\Docker\Docker目录下。</p><p>&emsp;&emsp;Windows版Docker包括Docker引擎（客户端和daemon）、Docker Compose、Docker Machine以及Docker Notary命令行。通过下列命令确认各个模块已经成功安装。</p><figure class="highlight vim"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">C:\&gt; docker --<span class="keyword">version</span> </span><br><span class="line">Docker <span class="keyword">version</span> <span class="number">18.01</span>.<span class="number">0</span>-<span class="keyword">ce</span>, build <span class="number">03596</span>f5</span><br><span class="line"></span><br><span class="line">C:\&gt; docker-compose --<span class="keyword">version</span> </span><br><span class="line">docker-compose <span class="keyword">version</span> <span class="number">1.18</span>.<span class="number">0</span>, build <span class="number">8</span>dd22a96</span><br><span class="line"></span><br><span class="line">C:\&gt; docker-machine --<span class="keyword">version</span> </span><br><span class="line">docker-machine.<span class="keyword">exe</span> <span class="keyword">version</span> <span class="number">0.13</span>.<span class="number">0</span>, build <span class="number">9</span>ba6da9</span><br><span class="line"></span><br><span class="line">C:\&gt; notary <span class="keyword">version</span> </span><br><span class="line">notary </span><br><span class="line"> Version:    <span class="number">0.4</span>.<span class="number">3</span> </span><br><span class="line"> Git commi<span class="variable">t:</span> <span class="number">9211198</span></span><br></pre></td></tr></table></figure><h3 id="3-2-Mac版Docker（DfM）"><a href="#3-2-Mac版Docker（DfM）" class="headerlink" title="3.2　Mac版Docker（DfM）"></a><strong>3.2　Mac版Docker（DfM）</strong></h3><p>&emsp;&emsp;Mac版Docker并不是为生产环境而设计的，Mac版Docker就是一个流畅、简单并且稳定版的boot2docker。对于Mac版Docker来说，提供基于Mac原生操作系统中Darwin内核的Docker引擎没有什么意义。所以在Mac版Docker当中，Docker daemon是运行在一个轻量级的Linux VM之上的。Mac版Docker通过对外提供daemon和API的方式与Mac环境实现无缝集成，这意味着我们可以在Mac上打开终端并直接使用Docker命令。</p><p>&emsp;&emsp;尽管在Mac上实现了无缝集成，还是要谨记Mac版Docker底层是基于Linux VM运行的，所以说Mac版Docker只能运行基于Linux的Docker容器。不过这样已经很好了，因为大部分容器实际上都是基于Linux的。</p><p>&emsp;&emsp;安装过程暂略，个人还未有Mac产品。</p><h3 id="3-3-在Linux上安装Docker"><a href="#3-3-在Linux上安装Docker" class="headerlink" title="3.3　在Linux上安装Docker"></a><strong>3.3　在Linux上安装Docker</strong></h3><p>&emsp;&emsp;在Linux上安装Docker是常见的安装场景，并且安装过程非常简单。通常难点在于Linux不同发行版之间的轻微区别，比如Ubuntu和CentOS之间的差异。接下来的示例基于Ubuntu版本Linux，同样适用于更低或者更高的版本。理论上，下面的示例在CentOS的各种版本上也是可以执行的。至于Linux操作系统是安装在自己的数据中心，还是第三方公有云，或是笔记本的虚拟机上，都没有任何的区别。唯一需求就是这台机器是Linux操作系统，并且能够访问 <a href="https://get.docker.com。" target="_blank" rel="noopener">https://get.docker.com。</a></p><p>&emsp;&emsp;首先需要选择安装的Docker版本。当前有两个版本可供选择： 社区版（Community Edition，CE）和企业版（Enterprise Edition，EE）。</p><p>&emsp;&emsp;下面使用wget命令来运行一个Shell脚本，完成Docker CE的安装。更多其他在Linux上安装Docker的方式，可以打开Docker主页面，单击页面中Get Started按钮来获取。</p><p>&emsp;&emsp;（1）在Linux机器上打开一个新的Shell</p><p>&emsp;&emsp;（2）使用wget从<a href="https://get.docker.com获取并运行Docker安装脚本，然后采用Shell中管道（pipe）的方式来执行这个脚本。" target="_blank" rel="noopener">https://get.docker.com获取并运行Docker安装脚本，然后采用Shell中管道（pipe）的方式来执行这个脚本。</a></p><figure class="highlight livecodeserver"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">$ wget -qO- <span class="keyword">https</span>://<span class="built_in">get</span>.docker.com/ | sh</span><br><span class="line"></span><br><span class="line">modprobe: FATAL: Module aufs <span class="keyword">not</span> found /lib/modules/<span class="number">4.4</span><span class="number">.0</span><span class="number">-36</span>-generic + sh -c <span class="string">'sleep 3; yum -y -q install docker-engine'</span> </span><br><span class="line">&lt;Snip&gt; </span><br><span class="line">If you would like <span class="built_in">to</span> use Docker <span class="keyword">as</span> <span class="keyword">a</span> non-root user, you should now consider adding your user <span class="built_in">to</span> <span class="keyword">the</span> <span class="string">"docker"</span> group <span class="keyword">with</span> something like:</span><br><span class="line"></span><br><span class="line">sudo usermod -aG docker your-user</span><br><span class="line"></span><br><span class="line">Remember that you will have <span class="built_in">to</span> <span class="built_in">log</span> out <span class="keyword">and</span> back <span class="keyword">in</span>...</span><br></pre></td></tr></table></figure><p>&emsp;&emsp;（3）最好通过非root用户来使用Docker。这时需要添加非root用户到本地Docker Unix组当中。下面的命令展示了如何把名为npoulton的用户添加到Docker组中，以及如何确认操作是否执行成功。请自行使用系统中的有效用户。</p><figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">$ sudo usermod -aG docker npoulton</span><br><span class="line"></span><br><span class="line">$ cat /etc<span class="built_in">/group </span>| grep docker </span><br><span class="line">docker:x:999:npoulton</span><br></pre></td></tr></table></figure><p>&emsp;&emsp;如果当前登录用户就是要添加到Docker组中的用户的话，则需要重新登录，组权限设置才会生效。这样Docker已经在Linux机器上安装成功。运行下面命令来确认安装结果。</p><figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">$ docker --version</span><br><span class="line">$ docker<span class="built_in"> system </span><span class="builtin-name">info</span> </span><br><span class="line"></span><br><span class="line">--有问题可以尝试重启docker</span><br><span class="line">service docker restart</span><br></pre></td></tr></table></figure><h3 id="3-4-在Windows-Server-2016上安装Docker"><a href="#3-4-在Windows-Server-2016上安装Docker" class="headerlink" title="3.4 在Windows Server 2016上安装Docker"></a><strong>3.4 在Windows Server 2016上安装Docker</strong></h3><p>&emsp;&emsp;暂略</p><h3 id="3-5-Docker引擎（Engine）升级"><a href="#3-5-Docker引擎（Engine）升级" class="headerlink" title="3.5 Docker引擎（Engine）升级"></a><strong>3.5 Docker引擎（Engine）升级</strong></h3><p>&emsp;&emsp;升级Docker引擎（Engine）是一项重要的任务，尤其是生产环境。 </p><p>&emsp;&emsp;需要重视升级操作的每个前置条件，包括确保容器配置了正确的重启策略；在Swarm Mode模式下使用服务时，需要确保正确配置了draining node。当完成了上述前置条件的检查之后，可以通过如下步骤完成升级操作。</p><blockquote><ol><li>停止Docker守护程序。</li><li>移除旧版本Docker。</li><li>安装新版本Docker。</li><li>配置新版本的Docker为开机自启动。</li><li>确保容器重启成功。</li></ol></blockquote><p>&emsp;&emsp;不同版本的Linux在升级Docker的时候，命令可能略有区别。</p><h4 id="在Ubuntu-16-04上升级Docker-CE"><a href="#在Ubuntu-16-04上升级Docker-CE" class="headerlink" title="在Ubuntu 16.04上升级Docker CE"></a><strong>在Ubuntu 16.04上升级Docker CE</strong></h4><p>&emsp;&emsp;假设已经完成了全部的升级前置步骤并且Docker处于可以 升级的状态，同时还可以用root用户身份运行升级命令。以root用户运行升级命令是不推荐的，但是可以简化示例。需要通过sudo来执行下列指令。</p><p>&emsp;&emsp;（1）更新APT包列表。</p><figure class="highlight q"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ apt-<span class="built_in">get</span> <span class="keyword">update</span></span><br></pre></td></tr></table></figure><p>&emsp;&emsp;（2）卸载当前Docker。</p><figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ apt-<span class="builtin-name">get</span> <span class="builtin-name">remove</span> docker docker-engine docker-ce docker.io -y</span><br></pre></td></tr></table></figure><p>&emsp;&emsp;在之前的版本中，Docker引擎的包名可能有多个。这条命令能够确保已经安装的Docker包全部被删除。</p><p>&emsp;&emsp;（3）安装新版本Docker。</p><p>&emsp;&emsp;有不同版本的Docker可供选择，并且有多种方式可以安装Docker。 无论是Docker CE还是Docker EE，都有不止一种安装方式。例如， Docker CE可以通过apt或者deb包管理方式进行安装，也可以使用Docker 官网上的脚本。</p><p>&emsp;&emsp;接下来的命令会使用get.docker.com的脚本完成最新版本Docker CE 的安装和配置。</p><figure class="highlight vim"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ wget -qO- http<span class="variable">s:</span>//<span class="built_in">get</span>.docker.<span class="keyword">com</span>/ | <span class="keyword">sh</span></span><br></pre></td></tr></table></figure><p>（4）将Docker配置为开机自启动。</p><figure class="highlight crystal"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">$ systemctl enable docker</span><br><span class="line">Synchronizing state <span class="keyword">of</span> docker.service... </span><br><span class="line">Executing /<span class="class"><span class="keyword">lib</span>/<span class="title">systemd</span>/<span class="title">systemd</span>-<span class="title">sysv</span>-<span class="title">install</span> <span class="title">enable</span> <span class="title">docker</span></span></span><br><span class="line">$ systemctl is-enabled docker </span><br><span class="line">enabled</span><br></pre></td></tr></table></figure><p>&emsp;&emsp;此时可能想重启自己的节点。这样可以确保刚安装的Docker不会对系统开机有任何的影响。</p><p>&emsp;&emsp;（5）检查并确保每一个容器和服务都已经重启成功。</p><figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">$ docker container ls </span><br><span class="line">CONTAINER ID    IMAGE     COMMAND       CREATED           STATUS</span><br><span class="line"></span><br><span class="line">97e599aca9f5    alpine    <span class="string">"sleep 1d"</span>    14 minutes ago    Up 1 minute</span><br><span class="line"></span><br><span class="line">$ docker<span class="built_in"> service </span>ls </span><br><span class="line">ID              NAME          MODE         REPLICAS     IMAGE </span><br><span class="line">ibyotlt1ehjy    prod-equus1   replicated   1/1          alpine:latest</span><br></pre></td></tr></table></figure><p>&emsp;&emsp;请注意，更新Docker还有其他的方法，此处只是介绍了基于Ubuntu Linux 16.04 版本的方式。</p><h4 id="在Windows-Server-2016上升级Docker-EE"><a href="#在Windows-Server-2016上升级Docker-EE" class="headerlink" title="在Windows Server 2016上升级Docker EE"></a><strong>在Windows Server 2016上升级Docker EE</strong></h4><p>&emsp;&emsp;暂略</p><h3 id="3-6-Docker存储驱动的选择"><a href="#3-6-Docker存储驱动的选择" class="headerlink" title="3.6 Docker存储驱动的选择"></a><strong>3.6 Docker存储驱动的选择</strong></h3><p>&emsp;&emsp;每个Docker容器都有一个<strong>本地存储空间</strong>，用于保存层叠的<strong>镜像层</strong>（Image Layer）以及挂载的容器<strong>文件系统</strong>。默认情况下，容器的所有读写操作都发生在其镜像层上或挂载的文件系统中，所以存储是每个容器的性能和稳定性不可或缺的一个环节。</p><p>&emsp;&emsp;以往，本地存储是通过<strong>存储驱动</strong>（Storage Driver）进行管理的，有时候也被称为Graph Driver或者GraphDriver。虽然存储驱动在上层抽象设计中都采用了<strong>栈式镜像层存储</strong>和<strong>写时复制</strong>（Copy-on-Write）的设计思想，但是Docker在Linux底层支持几种不同的存储驱动的具体实现，每一种实现方式都采用不同方法实现了镜像层和写时复制。虽然底层实现的差异不影响用户与Docker之间的交互，但是对Docker的性能和稳定性至关重要。</p><p>&emsp;&emsp;在Linux上，Docker可选择的一些存储驱动包括AUFS（最原始也是 最老的）、Overlay2（可能是未来的最佳选择）、Device Mapper、Btrfs 和ZFS。</p><p>&emsp;&emsp;Docker在Windows操作系统上只支持一种存储驱动，即Windows Filter。</p><p>&emsp;&emsp;存储驱动的选择是节点级别的。这意味着每个Docker主机只能选择一种存储驱动，而不能为每个容器选择不同的存储驱动。在Linux上，读者可以通过修改/etc/docker/daemon.json文件来修改存储引擎配置，修改完成之后需要重启Docker才能够生效。下面的代码片段展示了如何将存储驱动设置为overlay2。</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&#123;  <span class="attr">"storage-driver"</span>: <span class="string">"overlay2"</span> &#125;</span><br></pre></td></tr></table></figure><p>&emsp;&emsp;如果修改了正在运行Docker主机的存储引擎类型，则现有的镜像和容器在重启之后将不可用，这是因为每种存储驱动在主机上存储镜像层的位置是不同的（通常在/var/lib/docker/  \<storagedriver>/…目录下）。修改了存储驱动的类型，Docker就无法找到原有的镜像和容器了。切换到原来的存储驱动，之前的镜像和容器就可以继续使用了。</storagedriver></p><p>&emsp;&emsp;如果希望在切换存储引擎之后还能够继续使用之前的镜像和容器，需要将镜像保存为Docker格式，上传到某个镜像仓库，修改本地 Docker存储引擎并重启，之后从镜像仓库将镜像拉取到本地，最后重启容器。</p><p>&emsp;&emsp;通过下面的命令来检查Docker当前的存储驱动类型。</p><figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">$ docker<span class="built_in"> system </span><span class="builtin-name">info</span> </span><br><span class="line">&lt;Snip&gt; </span><br><span class="line">Storage Driver: overlay2  </span><br><span class="line">  Backing Filesystem: xfs  </span><br><span class="line">  Supports d_type: <span class="literal">true</span>  </span><br><span class="line">  Native Overlay Diff: <span class="literal">true</span> </span><br><span class="line">&lt;Snip&gt;</span><br></pre></td></tr></table></figure><p>&emsp;&emsp;选择存储驱动并正确地配置在Docker环境中是一件重要的事情，特别是在生产环境中，建议参阅Docker官网上由Linux发行商提供的最新文档来做出选择。</p><h4 id="3-6-1-Device-Mapper配置"><a href="#3-6-1-Device-Mapper配置" class="headerlink" title="3.6.1 Device Mapper配置"></a><strong>3.6.1 Device Mapper配置</strong></h4><p>&emsp;&emsp;大部分Linux存储驱动不需要或需要很少的配置。但是，Device Mapper通常需要合理配置之后才能表现出良好的性能。</p><p>&emsp;&emsp;默认情况下，Device Mapper采用loopback mounted sparse file作为底层实现来为Docker提供存储支持。如果需要的是开箱即用并且对性能没什么要求，那么这种方式是可行的。但这并不适用于生产环境。实际上，默认方式的性能很差，并不支持生产环境。</p><p>&emsp;&emsp;为了达到Device Mapper在生产环境中的最佳性能，读者需要将底层实现修改为direct-lvm模式。这种模式下通过使用基于裸块设备（Raw Block Device）的LVM精简池（LVM thin pool）来获取更好的性<br>能。</p><p>&emsp;&emsp;在Docker 17.06以及更高的版本中可以配置direct-lvm作为存储驱动，但到当前该方式存在某种限制。其中最主要的一点是，这种方式只能配置一个块设备，并且只有在第一次安装后才能设置生效。未来可能会有改进，但就目前情况来看配置单一块设备这种方式在性能和可靠性上都有一定的风险。</p><h4 id="3-6-2-让Docker自动设置direct-lvm"><a href="#3-6-2-让Docker自动设置direct-lvm" class="headerlink" title="3.6.2 让Docker自动设置direct-lvm"></a><strong>3.6.2 让Docker自动设置direct-lvm</strong></h4><p>&emsp;&emsp;下面的步骤会将Docker配置存储驱动为Device Mapper，并使用direct-lvm模式。</p><p>&emsp;&emsp;（1）将下面的存储驱动配置添加到/etc/docker/daemon.json当中。</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">&#123; </span><br><span class="line">  <span class="attr">"storage-driver"</span>: <span class="string">"devicemapper"</span>, </span><br><span class="line">  <span class="attr">"storage-opts"</span>: [  </span><br><span class="line">    <span class="string">"dm.directlvm_device=/dev/xdf"</span>,  </span><br><span class="line">    <span class="string">"dm.thinp_percent=95"</span>,  </span><br><span class="line">    <span class="string">"dm.thinp_metapercent=1"</span>,  <span class="string">"dm.thinp_autoextend_threshold=80"</span>,  <span class="string">"dm.thinp_autoextend_percent=20"</span>,  <span class="string">"dm.directlvm_device_force=false"</span> </span><br><span class="line">  ] </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>&emsp;&emsp;Device Mapper和LVM是很复杂的知识点，并不在讨论范围之内。下面简单介绍一下各配置项的含义。</p><blockquote><ul><li>dm.directlvm_device：设置了块设备的位置。为了存储的最佳<br>性能以及可用性，块设备应当位于高性能存储设备（如本地SSD） 或者外部RAID存储阵列之上。 </li><li>dm.thinp_percent=95：设置了镜像和容器允许使用的最大存储 空间占比，默认是95%。 </li><li>dm.thinp_metapercent：设置了元数据存储（MetaData Storage）允许使用的存储空间大小。默认是1%。 </li><li>dm.thinp_autoextend_threshold：设置了LVM自动扩展精简池 的阈值，默认是80%。 </li><li>dm.thinp_autoextend_percent：表示当触发精简池（thin pool）自动扩容机制的时候，扩容的大小应当占现有空间的比例。 </li><li>dm.directlvm_device_force：允许用户决定是否将块设备格式 化为新的文件系统。</li></ul></blockquote><p>&emsp;&emsp;（2）重启Docker。</p><p>&emsp;&emsp;（3）确认Docker已成功运行，并且块设备配置已被成功加载。</p><figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ docker version </span><br><span class="line">$ docker<span class="built_in"> system </span>info</span><br></pre></td></tr></table></figure><p>&emsp;&emsp;即使Docker在direct-lvm模式下只能设置单一块设备，其性能也会显著优于loopback模式。</p><h4 id="3-6-3-手动配置Device-Mapper的direct-lvm"><a href="#3-6-3-手动配置Device-Mapper的direct-lvm" class="headerlink" title="3.6.3 手动配置Device Mapper的direct-lvm"></a><strong>3.6.3 手动配置Device Mapper的direct-lvm</strong></h4><p>&emsp;&emsp;完整介绍如何进行Device Mapper direct-lvm的手动配置有些超出范畴。但是，下面列出的内容是我们需要了解并在配置的时候仔细斟酌的。</p><blockquote><ul><li><strong>块设备</strong>（Block Device）：在使用direct-lvm模式的时候，读者需要有可用的块设备。这些块设备应该位于高性能的存储设备之上，比如本地SSD或者外部高性能LUN存储。如果Docker环境部署在企业私有云（On-Premise）之上，那么外部LUN存储可以使用FC、iSCSI，或者其他支持块设备协议的存储阵列。如果Docker环境部署在公有云之上，那么可以采用公有云厂商提供的任何高性能的块设备（通常基于SSD）。 </li><li><strong>LVM</strong>配置：Docker的Device Mapper存储驱动底层利用LVM（Logical Volume Manager）来实现，因此需要配置LVM所需的物理设备、卷组、逻辑卷和精简池。读者应当使用专用的物理卷并将其配置在相同的卷组当中。这个卷组不应当被Docker之外的工作负载所使用。此外还需要配置额外两个逻辑卷，分别用于存储数据和源数据信息。另外，要创建LVM配置文件、指定LVM自动扩容的触发阈值，以及自动扩容的大小，并且为自动扩容配置相应的监控，保证自动扩容会被触发。 </li><li>Docker配置：修改Docker配置文件之前要先保存原始文件（etc/docker/daemon.json），然后再进行修改。读者环境中的dm.thinpooldev配置项对应值可能跟下面的示例内容有所不同，需要修改为合适的配置。</li></ul></blockquote><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&#123;  </span><br><span class="line">  <span class="attr">"storage-driver"</span>: <span class="string">"devicemapper"</span>,  </span><br><span class="line">  <span class="attr">"storage-opts"</span>: [</span><br><span class="line">    <span class="string">"dm.thinpooldev=/dev/mapper/docker-thinpool"</span>,  <span class="string">"dm.use_deferred_removal=true"</span>,  <span class="string">"dm.use_deferred_deletion=true"</span>  </span><br><span class="line">  ] </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>&emsp;&emsp;修改并保存配置后，可以重启Docker daemon。如果想获取更多细节信息，可以参考Docker文档，或者咨询Docker 技术账户管理员。</p><hr><h2 id="第四节-纵观Docker"><a href="#第四节-纵观Docker" class="headerlink" title="第四节 纵观Docker"></a><strong>第四节 纵观Docker</strong></h2><p>&emsp;&emsp;在继续深入研究Docker之前，需要先对Docker进行一个整体介绍。主要包含两部分内容：运维（Ops）视角。 开发（Dev）视角。</p><h3 id="4-1-运维视角"><a href="#4-1-运维视角" class="headerlink" title="4.1 运维视角"></a><strong>4.1 运维视角</strong></h3><p>&emsp;&emsp;在安装Docker的时候，会涉及两个主要组件：Docker客户端和 Docker daemon（有时也被称为“服务端”或者“引擎”）。daemon实现了Docker引擎的API。</p><p>&emsp;&emsp;使用Linux默认安装时，客户端与daemon之间的通信是通过本地IPC/UNIX Socket完成的（/var/run/docker.sock）；在Windows上是通过名为npipe:////./pipe/docker_engine的管道（pipe）完成的。可以使用docker version命令来检测客户端和服务端是否都已经成功运行，并且可以互相通信。</p><p>&emsp;&emsp;如果能成功获取来自客户端和服务端的响应，那么可以继续后面的操作。如果正在使用Linux，并且服务端返回了异常响应，则可尝试在命令的前面加上sudo——sudo docker version。如果加上sudo之后命令正常运行，那么需要将当前用户加入到docker用户组，或者给后面的命令都加上sudo前缀。</p><h4 id="4-1-1-镜像"><a href="#4-1-1-镜像" class="headerlink" title="4.1.1 镜像"></a><strong>4.1.1 镜像</strong></h4><p>&emsp;&emsp;将<strong>Docker镜像</strong>理解为一个包含了OS文件系统和应用的对象会很有帮助，与<strong>虚拟机模板</strong>类似。虚拟机模板本质上是处于关机状态的虚拟机。在Docker世界中，镜像实际上等价于未运行的容器，可以将镜像比作类（Class）。</p><p>&emsp;&emsp;在Docker主机上运行docker image ls命令。</p><figure class="highlight crmsh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ docker image ls </span><br><span class="line">REPOSITORY    <span class="keyword">TAG</span>     <span class="title">IMAGE</span> ID     CREATED     SIZE</span><br></pre></td></tr></table></figure><p>&emsp;&emsp;如果运行命令环境是刚完成Docker安装的主机，或者是Play With Docker，那么Docker主机中应当没有任何镜像，命令输出内容会如上所示。</p><p>&emsp;&emsp;在Docker主机上获取镜像的操作被称为<strong>拉取</strong>（pulling）。如果使用Linux，那么会拉取ubuntu:latest镜像；如果使用Windows，则会拉取microsoft/powershell:nanoserver镜像（本人环境是centos，所以直接docker pull centos）。</p><figure class="highlight groovy"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">latest:</span> Pulling from library/ubuntu </span><br><span class="line"><span class="number">50</span><span class="string">aff78429b1:</span> Pull complete </span><br><span class="line"><span class="string">f6d82e297bce:</span> Pull complete </span><br><span class="line"><span class="number">275</span><span class="string">abb2c8a6f:</span> Pull complete</span><br><span class="line"><span class="number">9</span><span class="string">f15a39356d6:</span> Pull complete </span><br><span class="line"><span class="string">fc0342a94c89:</span> Pull complete </span><br><span class="line"><span class="string">Digest:</span> <span class="string">sha256:</span>fbaf303...c0ea5d1212 </span><br><span class="line"><span class="string">Status:</span> Downloaded newer image <span class="keyword">for</span> <span class="string">ubuntu:</span>latest</span><br></pre></td></tr></table></figure><p>&emsp;&emsp;再次运行docker image ls命令来查看刚刚拉取的镜像。</p><figure class="highlight lsl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">$ docker images </span><br><span class="line">REPOSITORY       TAG      IMAGE ID       CREATED       SIZE </span><br><span class="line">ubuntu           latest   <span class="number">00</span>fd29ccc6f1   <span class="number">3</span> weeks ago   <span class="number">111</span>MB</span><br><span class="line">centos           latest   <span class="number">0</span>f3e07c0138f   <span class="number">2</span> months ago  <span class="number">220</span>MB</span><br></pre></td></tr></table></figure><p>&emsp;&emsp;关于镜像的存储位置以及镜像内部构成，会在后续进行整理。现在只需知道镜像包含了基础操作系统，以及应用程序运行所需的代码和依赖包。刚才拉取的ubuntu镜像有一个精简版的Ubuntu Linux文件系统，其中包含部分Ubuntu常用工具。而Windows示例中拉取的microsoft/powershell镜像，则包含了带有PowerShell的 Windows Nano Server操作系统。如果拉取了如nginx或者microsoft/iis这样的应用容器，则会得到一个包含操作系统的镜像，并且在镜像中还包括了运行Nginx或IIS所需的代码。</p><p>&emsp;&emsp;重要的是，Docker的每个镜像都有自己的唯一ID。用户可以通过引用镜像的ID或名称来使用镜像。如果用户选择使用镜像ID，通常只需要输入ID开头的几个字符即可——因为ID是唯一的，Docker知道用户想引用的具体镜像是哪个。</p><h4 id="4-1-2-容器"><a href="#4-1-2-容器" class="headerlink" title="4.1.2 容器"></a><strong>4.1.2 容器</strong></h4><p>&emsp;&emsp;到目前为止，我们已经拥有一个拉取到本地的镜像，可以使用docker container run命令从镜像来启动容器。</p><p>&emsp;&emsp;在Linux中启动容器的命令如下。</p><figure class="highlight dockerfile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$ docker container <span class="keyword">run</span><span class="bash"> -it ubuntu:latest /bin/bash </span></span><br><span class="line"><span class="bash">$ docker container run -it centos:latest /bin/bash </span></span><br><span class="line"><span class="bash">root@6dc20d508db0:/<span class="comment">#</span></span></span><br></pre></td></tr></table></figure><p>&emsp;&emsp;在Windows中启动容器的命令如下。</p><figure class="highlight dockerfile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&gt; docker container <span class="keyword">run</span><span class="bash"> -it microsoft/powershell:nanoserver pwsh.exe</span></span><br><span class="line"><span class="bash"></span></span><br><span class="line"><span class="bash">Windows PowerShell </span></span><br><span class="line"><span class="bash">Copyright (C) 2016 Microsoft Corporation. All rights reserved. </span></span><br><span class="line"><span class="bash">PS C:\&gt;</span></span><br></pre></td></tr></table></figure><p>&emsp;&emsp;每个实例中的提示符都发生了变化，是因为-it参数会将Shell切换到容器终端，现在已经位于容器内部了。</p><p>&emsp;&emsp;接下来分析一下docker container run命令：docker container run告诉Docker daemon启动新的容器。其中-it参数告诉Docker开启容器的交互模式并将当前的Shell连接到<strong>容器终端</strong>。接下来，命令告诉Docker，用户想基于ubuntu:latest镜像启动容器（如果用户使用Windows，则是基于 microsoft/powershell:nanoserver镜像）。最后，命令告诉Docker，用户想要在容器内部运行哪个进程。对于Linux示例来说是运行Bash Shell，对于Windows示例来说则是运行PowerShell。</p><p>&emsp;&emsp;在容器内部运行ps命令查看当前正在运行的全部进程。</p><p>&emsp;&emsp;Linux示例如下。</p><figure class="highlight tap"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">root@6dc20d508db0:/<span class="comment"># ps -elf </span></span><br><span class="line">F S UID    PID  PPID   NI ADDR SZ WCHAN  STIME TTY  TIME CMD </span><br><span class="line">4 S root    <span class="number"> 1 </span>   <span class="number"> 0 </span>  <span class="number"> 0 </span>- <span class="number"> 4560 </span>wait   13:38 ?    00:00:00 /bin/bash </span><br><span class="line">0 R root    <span class="number"> 9 </span>   <span class="number"> 1 </span>  <span class="number"> 0 </span>- <span class="number"> 8606 </span>-      13:38 ?    00:00:00 ps -elf</span><br></pre></td></tr></table></figure><p>&emsp;&emsp;Windows示例如下。</p><figure class="highlight tap"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">PS C:\&gt; ps</span><br><span class="line"></span><br><span class="line">Handles   NPM(K)   PM(K)   WS(K)   CPU(s)     Id   SI ProcessName </span><br><span class="line">-------   ------   -----   -----   ------     --   -- ----------      </span><br><span class="line">     <span class="number"> 0 </span>      <span class="number"> 5 </span>   <span class="number"> 964 </span>  <span class="number"> 1292 </span>    0.00  <span class="number"> 4716 </span>  <span class="number"> 4 </span>CExecSvc      </span><br><span class="line">     <span class="number"> 0 </span>      <span class="number"> 5 </span>   <span class="number"> 592 </span>   <span class="number"> 956 </span>    0.00  <span class="number"> 4524 </span>  <span class="number"> 4 </span>csrss      </span><br><span class="line">     <span class="number"> 0 </span>      <span class="number"> 0 </span>     <span class="number"> 0 </span>     <span class="number"> 4 </span>             <span class="number"> 0 </span>  <span class="number"> 0 </span>Idle      </span><br><span class="line">     <span class="number"> 0 </span>     <span class="number"> 18 </span>  <span class="number"> 3984 </span>  <span class="number"> 8624 </span>    0.13   <span class="number"> 700 </span>  <span class="number"> 4 </span>lsass      </span><br><span class="line">     <span class="number"> 0 </span>     <span class="number"> 52 </span> <span class="number"> 26624 </span> <span class="number"> 19400 </span>    1.64  <span class="number"> 2100 </span>  <span class="number"> 4 </span>powershell      </span><br><span class="line">     <span class="number"> 0 </span>     <span class="number"> 38 </span> <span class="number"> 28324 </span> <span class="number"> 49616 </span>    1.69  <span class="number"> 4464 </span>  <span class="number"> 4 </span>powershell      </span><br><span class="line">     <span class="number"> 0 </span>      <span class="number"> 8 </span>  <span class="number"> 1488 </span>  <span class="number"> 3032 </span>    0.06  <span class="number"> 2488 </span>  <span class="number"> 4 </span>services      </span><br><span class="line">     <span class="number"> 0 </span>      <span class="number"> 2 </span>   <span class="number"> 288 </span>   <span class="number"> 504 </span>    0.00  <span class="number"> 4508 </span>  <span class="number"> 0 </span>smss      </span><br><span class="line">     <span class="number"> 0 </span>      <span class="number"> 8 </span>  <span class="number"> 1600 </span>  <span class="number"> 3004 </span>    0.03   <span class="number"> 908 </span>  <span class="number"> 4 </span>svchost      </span><br><span class="line">     <span class="number"> 0 </span>     <span class="number"> 12 </span>  <span class="number"> 1492 </span>  <span class="number"> 3504 </span>    0.06  <span class="number"> 4572 </span>  <span class="number"> 4 </span>svchost      </span><br><span class="line">     <span class="number"> 0 </span>     <span class="number"> 15 </span> <span class="number"> 20284 </span> <span class="number"> 23428 </span>    5.64  <span class="number"> 4628 </span>  <span class="number"> 4 </span>svchost      </span><br><span class="line">     <span class="number"> 0 </span>     <span class="number"> 15 </span>  <span class="number"> 3704 </span>  <span class="number"> 7536 </span>    0.09  <span class="number"> 4688 </span>  <span class="number"> 4 </span>svchost      </span><br><span class="line">     <span class="number"> 0 </span>     <span class="number"> 28 </span>  <span class="number"> 5708 </span>  <span class="number"> 6588 </span>    0.45  <span class="number"> 4712 </span>  <span class="number"> 4 </span>svchost      </span><br><span class="line">     <span class="number"> 0 </span>     <span class="number"> 10 </span>  <span class="number"> 2028 </span>  <span class="number"> 4736 </span>    0.03  <span class="number"> 4840 </span>  <span class="number"> 4 </span>svchost      </span><br><span class="line">     <span class="number"> 0 </span>     <span class="number"> 11 </span>  <span class="number"> 5364 </span>  <span class="number"> 4824 </span>    0.08  <span class="number"> 4928 </span>  <span class="number"> 4 </span>svchost      </span><br><span class="line">     <span class="number"> 0 </span>      <span class="number"> 0 </span>   <span class="number"> 128 </span>   <span class="number"> 136 </span>   37.02     <span class="number"> 4 </span>  <span class="number"> 0 </span>System      </span><br><span class="line">     <span class="number"> 0 </span>      <span class="number"> 7 </span>   <span class="number"> 920 </span>  <span class="number"> 1832 </span>    0.02  <span class="number"> 3752 </span>  <span class="number"> 4 </span>wininit      </span><br><span class="line">     <span class="number"> 0 </span>      <span class="number"> 8 </span>  <span class="number"> 5472 </span> <span class="number"> 11124 </span>    0.77  <span class="number"> 5568 </span>  <span class="number"> 4 </span>WmiPrvSE</span><br></pre></td></tr></table></figure><p>&emsp;&emsp;Linux容器中仅包含两个进程。</p><blockquote><ul><li>PID 1：代表/bin/bash进程，该进程是通过docker container run命令来通知容器运行的。 </li><li>PID 9：代表ps -elf进程，查看当前运行中进程所使用的命令/程序。</li></ul></blockquote><p>&emsp;&emsp;命令输出中展示的ps -elf进程存在一定的误导，因为这个程序在ps命令退出后就结束了。这意味着容器内长期运行的进程其实只有/bin/bash。</p><p>&emsp;&emsp;Windows容器运行中的进程会更多，这是由 Windows 操作系统工作方式决定的。虽然Windows容器中的进程比Linux容器要多，但与常见的Windows服务器相比，其进程数量却是明显偏少的。</p><p>&emsp;&emsp;按Ctrl-PQ组合键，可以在退出容器的同时还保持容器运行。这样Shell就会返回到Docker主机终端。可以通过查看Shell提示符来确认。</p><p>&emsp;&emsp;现在已经返回到Docker主机的Shell提示符，再次运行ps命令。</p><p>&emsp;&emsp;Linux示例如下。</p><figure class="highlight tap"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">$ ps -elf </span><br><span class="line">F S UID       PID  PPID    NI ADDR SZ WCHAN  TIME CMD </span><br><span class="line">4 S root       <span class="number"> 1 </span>   <span class="number"> 0 </span>   <span class="number"> 0 </span>- <span class="number"> 9407 </span>-      00:00:03 /sbin/init </span><br><span class="line">1 S root       <span class="number"> 2 </span>   <span class="number"> 0 </span>   <span class="number"> 0 </span>-    <span class="number"> 0 </span>-      00:00:00 [kthreadd] </span><br><span class="line">1 S root       <span class="number"> 3 </span>   <span class="number"> 2 </span>   <span class="number"> 0 </span>-    <span class="number"> 0 </span>-      00:00:00 [ksoftirqd/0] </span><br><span class="line">1 S root       <span class="number"> 5 </span>   <span class="number"> 2 </span>    -20    <span class="number"> 0 </span>-      00:00:00 [kworker/0:0H] </span><br><span class="line">1 S root       <span class="number"> 7 </span>   <span class="number"> 2 </span>   -0 -    <span class="number"> 0 </span>-      00:00:00 [rcu_sched] </span><br><span class="line">&lt;Snip&gt; </span><br><span class="line">0 R ubuntu <span class="number"> 22783 </span>22475    <span class="number"> 0 </span>- <span class="number"> 9021 </span>-      00:00:00 ps -elf</span><br></pre></td></tr></table></figure><p>&emsp;&emsp;Windows示例如下。</p><figure class="highlight lsl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">&gt; ps </span><br><span class="line">Handles   NPM(K)    PM(K)    WS(K)    CPU(s)     Id  SI ProcessName </span><br><span class="line">-------   ------    -----    -----    ------     --  -- ----------    </span><br><span class="line">    <span class="number">220</span>       <span class="number">11</span>     <span class="number">7396</span>     <span class="number">7872</span>      <span class="number">0.33</span>   <span class="number">1732</span>   <span class="number">0</span> amazon-ssm-agen     </span><br><span class="line">     <span class="number">84</span>        <span class="number">5</span>      <span class="number">908</span>     <span class="number">2096</span>      <span class="number">0.00</span>   <span class="number">2428</span>   <span class="number">3</span> CExecSvc     </span><br><span class="line">     <span class="number">87</span>        <span class="number">5</span>      <span class="number">936</span>     <span class="number">1336</span>      <span class="number">0.00</span>   <span class="number">4716</span>   <span class="number">4</span> CExecSvc    </span><br><span class="line">    <span class="number">203</span>       <span class="number">13</span>     <span class="number">3600</span>    <span class="number">13132</span>      <span class="number">2.53</span>   <span class="number">3192</span>   <span class="number">2</span> conhost</span><br><span class="line">    <span class="number">210</span>       <span class="number">13</span>     <span class="number">3768</span>    <span class="number">22948</span>      <span class="number">0.08</span>   <span class="number">5260</span>   <span class="number">2</span> conhost    </span><br><span class="line">    <span class="number">257</span>       <span class="number">11</span>     <span class="number">1808</span>      <span class="number">992</span>      <span class="number">0.64</span>    <span class="number">524</span>   <span class="number">0</span> csrss    </span><br><span class="line">    <span class="number">116</span>        <span class="number">8</span>     <span class="number">1348</span>       <span class="number">580</span>     <span class="number">0.08</span>    <span class="number">592</span>   <span class="number">1</span> csrss     </span><br><span class="line">     <span class="number">85</span>        <span class="number">5</span>      <span class="number">532</span>      <span class="number">1136</span>     <span class="number">0.23</span>   <span class="number">2440</span>   <span class="number">3</span> csrss    </span><br><span class="line">    <span class="number">242</span>       <span class="number">11</span>     <span class="number">1848</span>       <span class="number">952</span>     <span class="number">0.42</span>   <span class="number">2708</span>   <span class="number">2</span> csrss     </span><br><span class="line">     <span class="number">95</span>        <span class="number">5</span>      <span class="number">592</span>       <span class="number">980</span>     <span class="number">0.00</span>   <span class="number">4524</span>   <span class="number">4</span> csrss    </span><br><span class="line">    <span class="number">137</span>        <span class="number">9</span>     <span class="number">7784</span>      <span class="number">6776</span>     <span class="number">0.05</span>   <span class="number">5080</span>   <span class="number">2</span> docker    </span><br><span class="line">    <span class="number">401</span>       <span class="number">17</span>    <span class="number">22744</span>     <span class="number">14016</span>    <span class="number">28.59</span>   <span class="number">1748</span>   <span class="number">0</span> dockerd    </span><br><span class="line">    <span class="number">307</span>       <span class="number">18</span>    <span class="number">13344</span>      <span class="number">1628</span>     <span class="number">0.17</span>    <span class="number">936</span>   <span class="number">1</span> dwm    </span><br><span class="line">    &lt;SNIP&gt;   </span><br><span class="line">   <span class="number">1888</span>        <span class="number">0</span>      <span class="number">128</span>       <span class="number">136</span>    <span class="number">37.17</span>      <span class="number">4</span>   <span class="number">0</span> System    </span><br><span class="line">    <span class="number">272</span>       <span class="number">15</span>     <span class="number">3372</span>      <span class="number">2452</span>     <span class="number">0.23</span>   <span class="number">3340</span>   <span class="number">2</span> TabTip     </span><br><span class="line">     <span class="number">72</span>        <span class="number">7</span>     <span class="number">1184</span>         <span class="number">8</span>     <span class="number">0.00</span>   <span class="number">3400</span>   <span class="number">2</span> TabTip32    </span><br><span class="line">    <span class="number">244</span>       <span class="number">16</span>     <span class="number">2676</span>      <span class="number">3148</span>     <span class="number">0.06</span>   <span class="number">1880</span>   <span class="number">2</span> taskhostw    </span><br><span class="line">    <span class="number">142</span>        <span class="number">7</span>     <span class="number">6172</span>      <span class="number">6680</span>     <span class="number">0.78</span>   <span class="number">4952</span>   <span class="number">3</span> WmiPrvSE    </span><br><span class="line">    <span class="number">148</span>        <span class="number">8</span>     <span class="number">5620</span>     <span class="number">11028</span>     <span class="number">0.77</span>   <span class="number">5568</span>   <span class="number">4</span> WmiPrvSE</span><br></pre></td></tr></table></figure><p>&emsp;&emsp;可以看到与容器相比，Docker主机中运行的进程数要多很多。 Windows容器中运行的进程要远少于Windows主机，Linux容器中的进程数也远少于Linux主机。</p><p>&emsp;&emsp;在之前的步骤当中，是使用Ctrl-PQ组合键来退出容器的。在容器内部使用该操作可以退出当前容器，但不会杀死容器进程。可以通过docker container ls命令查看系统内全部处于运行状态的容器。</p><figure class="highlight mel"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$ docker <span class="keyword">container</span> <span class="keyword">ls</span> </span><br><span class="line">CONTAINER ID   IMAGE          COMMAND      CREATED  STATUS    NAMES </span><br><span class="line">e2b69eeb55cb   ubuntu:latest  <span class="string">"/bin/bash"</span>  <span class="number">7</span> mins   Up <span class="number">7</span> <span class="keyword">min</span>  vigilant_borg</span><br></pre></td></tr></table></figure><p>&emsp;&emsp;上述的输出显示只有一个运行中的容器，就是前面示例中创建的那个容器，证明了容器在退出后依然是运行的。</p><h4 id="4-1-3-连接到运行中的容器"><a href="#4-1-3-连接到运行中的容器" class="headerlink" title="4.1.3 连接到运行中的容器"></a><strong>4.1.3 连接到运行中的容器</strong></h4><p>&emsp;&emsp;执行docker container exec命令，可以将Shell连接到一个运行中的容器终端。因为之前示例中的容器仍在运行，所以下面的示例会创建到该容器的新连接。</p><p>&emsp;&emsp;Linux示例如下。</p><figure class="highlight elixir"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable">$ </span>docker container exec -it vigilant_borg bash </span><br><span class="line">root<span class="variable">@e2b69eeb55cb</span><span class="symbol">:/</span><span class="comment">#</span></span><br></pre></td></tr></table></figure><p>&emsp;&emsp;示例中的容器名为“vigilant_brog”。每个人环境中的容器名称会不同（本机是thirsty_hermann），所以请记得将“vigilant_brog”替换为自己Docker主机上运行中的容器名称或者ID。</p><p>&emsp;&emsp;Windows示例如下。</p><figure class="highlight mathematica"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&gt; docker container exec -it pensive_hamilton pwsh.exe</span><br><span class="line"></span><br><span class="line">Windows PowerShell </span><br><span class="line">Copyright (<span class="keyword">C</span>) <span class="number">2016</span> Microsoft Corporation. <span class="keyword">All</span> rights reserved. </span><br><span class="line">PS <span class="keyword">C</span>:\&gt;</span><br></pre></td></tr></table></figure><p>&emsp;&emsp;注意，Shell提示符又发生了变化。此时已登录到了容器内部。docker container exec命令的格式是docker container exec \<options> \<container-name or="" container-id=""> \&lt;command/app&gt;。在示例中，将本地Shell连接到容器是通过-it参数实现的。本例中使用名称引用容器，并且告诉Docker运行Bash Shell（在Windows示例中是 PowerShell）。使用十六进制ID的方式也可以很容易地引用具体容器。</container-name></options></p><p>&emsp;&emsp;再次使用Ctrl-PQ组合键退出容器。Shell提示符应当退回到Docker主机中。</p><p>&emsp;&emsp;再次运行docker container ls命令来确认容器仍处于运行状态。</p><figure class="highlight mel"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ docker <span class="keyword">container</span> <span class="keyword">ls</span> CONTAINER ID   IMAGE          COMMAND      CREATED  STATUS    NAMES e2b69eeb55cb   ubuntu:latest  <span class="string">"/bin/bash"</span>  <span class="number">9</span> mins   Up <span class="number">9</span> <span class="keyword">min</span>  vigilant_borg</span><br></pre></td></tr></table></figure><p>&emsp;&emsp;通过docker container stop和docker container rm命令来停止并杀死容器。切记需要将示例中的名称/ID替换为读者自己的容器对应的名称和ID。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> docker container stop vigilant_borg vigilant_borg</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> docker container rm vigilant_borg vigilant_borg</span></span><br></pre></td></tr></table></figure><p>&emsp;&emsp;通过运行docker container ls命令，并指定-a参数来确认容器 已经被成功删除。添加-a的作用是让Docker列出所有容器，甚至包括那些处于停止状态的。</p><figure class="highlight inform7"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ docker <span class="keyword">container</span> ls -a </span><br><span class="line"><span class="keyword">CONTAINER</span> ID    IMAGE    COMMAND    CREATED    STATUS    PORTS    NAMES</span><br></pre></td></tr></table></figure><h3 id="4-2-开发视角"><a href="#4-2-开发视角" class="headerlink" title="4.2 开发视角"></a><strong>4.2 开发视角</strong></h3><p>&emsp;&emsp;<strong>容器即应用！</strong>，接下来会分析一份应用代码中的Dockerfile并将其容器化，最终以容器的方式运行。</p><p>&emsp;&emsp;进入到仓库文件目录之下，查看其内容。</p><figure class="highlight tap"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">$ cd psweb </span><br><span class="line">$ ls -l </span><br><span class="line">total<span class="number"> 28 </span></span><br><span class="line">-rw-rw-r--<span class="number"> 1 </span>ubuntu ubuntu <span class="number"> 341 </span>Sep<span class="number"> 29 </span>12:15 app.js </span><br><span class="line">-rw-rw-r--<span class="number"> 1 </span>ubuntu ubuntu <span class="number"> 216 </span>Sep<span class="number"> 29 </span>12:15 circle.yml </span><br><span class="line">-rw-rw-r--<span class="number"> 1 </span>ubuntu ubuntu <span class="number"> 338 </span>Sep<span class="number"> 29 </span>12:15 Dockerfile </span><br><span class="line">-rw-rw-r--<span class="number"> 1 </span>ubuntu ubuntu <span class="number"> 421 </span>Sep<span class="number"> 29 </span>12:15 package.json </span><br><span class="line">-rw-rw-r--<span class="number"> 1 </span>ubuntu ubuntu <span class="number"> 370 </span>Sep<span class="number"> 29 </span>12:15 README.md </span><br><span class="line">drwxrwxr-x<span class="number"> 2 </span>ubuntu ubuntu<span class="number"> 4096 </span>Sep<span class="number"> 29 </span>12:15 test </span><br><span class="line">drwxrwxr-x<span class="number"> 2 </span>ubuntu ubuntu<span class="number"> 4096 </span>Sep<span class="number"> 29 </span>12:15 views</span><br></pre></td></tr></table></figure><p>&emsp;&emsp;Linux的示例是一个简单的Node.js Web应用。Windows示例是一个简单的ASP.NET Web应用。每个仓库中都包含一个名为Dockerfile的文件。Dockerfile是一个纯文本文件，其中描述了如何将应用构建到Docker镜像当中。</p><p>&emsp;&emsp;查看Dockerfile的全部内容。</p><figure class="highlight dockerfile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">$ cat Dockerfile</span><br><span class="line"></span><br><span class="line"><span class="keyword">FROM</span> alpine </span><br><span class="line"><span class="keyword">LABEL</span><span class="bash"> maintainer=<span class="string">"nigelpoulton@hotmail.com"</span> </span></span><br><span class="line"><span class="bash">RUN apk add --update nodejs nodejs-npm </span></span><br><span class="line"><span class="bash">COPY . /src </span></span><br><span class="line"><span class="bash">WORKDIR /src </span></span><br><span class="line"><span class="bash">RUN  npm install </span></span><br><span class="line"><span class="bash">EXPOSE  8080 </span></span><br><span class="line"><span class="bash">ENTRYPOINT [<span class="string">"node"</span>, <span class="string">"./app.js"</span>]</span></span><br></pre></td></tr></table></figure><p>&emsp;&emsp;现在只需要知道Dockerfile的每一行都代表一个用于构建镜像的指令即可。使用docker image build命令，根据Dockerfile中的指令来创建新的镜像。示例中新建的Docker镜像名为test:latest。一定要在包含应用代码和Dockerfile的目录下执行这些命令。</p><figure class="highlight vim"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">$ docker image build -t tes<span class="variable">t:latest</span> .</span><br><span class="line"></span><br><span class="line">Sending build context <span class="keyword">to</span> Docker daemon <span class="number">74.75</span>kB </span><br><span class="line">Step <span class="number">1</span>/<span class="number">8</span> : FROM alpine </span><br><span class="line">lates<span class="variable">t:</span> Pulling from library/alpine </span><br><span class="line"><span class="number">88286</span>f41530e: Pull <span class="built_in">complete</span> </span><br><span class="line">Diges<span class="variable">t:</span> <span class="built_in">sha256</span>:f006ecbb824...<span class="number">0</span>c103f4820a417d </span><br><span class="line">Statu<span class="variable">s:</span> Downloaded newer image <span class="keyword">for</span> alpine:latest </span><br><span class="line"> ---&gt; <span class="number">76</span>da55c8019d </span><br><span class="line"><span class="symbol">&lt;Snip&gt;</span></span><br><span class="line">Successfully built f154cb3ddbd4 </span><br><span class="line">Successfully tagged tes<span class="variable">t:latest</span></span><br></pre></td></tr></table></figure><p>&emsp;&emsp;一旦构建完成，就可以确认主机上是否存在test:latest镜像。</p><figure class="highlight subunit"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">$ docker image ls </span><br><span class="line">REPO     TAG        IMAGE ID         CREATED         SIZE </span><br><span class="line"><span class="keyword">Test     </span>latest     f154cb3ddbd4     1 minute ago    55.6MB </span><br><span class="line">...</span><br></pre></td></tr></table></figure><p>&emsp;&emsp;现在已经拥有一个新的Docker镜像，其中包含了应用程序。从镜像启动容器，并测试应用。Linux代码如下。</p><figure class="highlight haml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">$ docker container run -d \  </span><br><span class="line">  -<span class="ruby">-name web1 \  </span></span><br><span class="line"><span class="ruby">  --publish <span class="number">8080</span><span class="symbol">:</span><span class="number">8080</span> \ </span></span><br><span class="line"><span class="ruby">  <span class="symbol">test:</span>latest</span></span><br></pre></td></tr></table></figure><p>&emsp;&emsp;打开Web浏览器，在地址栏中输入容器运行所在的Docker主机的DNS名称或者IP地址，并在后面加上端口号8080。然后就能看到图4.1的Web页面。</p><p><img src="https://pic-1258215793.cos.ap-shanghai.myqcloud.com/content/20191001/201910010112.png" alt="Linux系统测试应用Web界面"></p><p>&emsp;&emsp;Windows代码如下。</p><figure class="highlight haml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&gt; docker container run -d \  </span><br><span class="line">  -<span class="ruby">-name web1 \  </span></span><br><span class="line"><span class="ruby">  --publish <span class="number">8080</span><span class="symbol">:</span><span class="number">80</span> \  </span></span><br><span class="line"><span class="ruby">  <span class="symbol">test:</span>latest</span></span><br></pre></td></tr></table></figure><p>&emsp;&emsp;打开Web浏览器，在地址栏中输入容器运行所在的Docker主机的DNS名称或者IP地址，并在后面加上端口号8080，然后就能看到图4.2的Web页面。</p><p><img src="https://pic-1258215793.cos.ap-shanghai.myqcloud.com/content/20191001/201910010112.png" alt="Windows系统测试应用Web界面"></p><p>&emsp;&emsp;已经成功将应用代码构建到了Docker镜像当中，然后以容器的方式启动该镜像，这个过程叫作<strong>应用容器化</strong>。</p><hr><p><em>参考博客和文章书籍等：</em></p><blockquote><p>《深入浅出Docker》</p></blockquote><p><em>因博客主等未标明不可引用，若部分内容涉及侵权请及时告知，我会尽快修改和删除相关内容</em></p>]]></content>
    
    <summary type="html">
    
      简单介绍Docker概览（一）容器，内容包括：容器的发展（过去、虚拟机、容器、Linux容器、Docker、Windows容器、Kubernetes），了解Docker，安装Docker，纵观Docker（运维视角、开发视角）等。
    
    </summary>
    
      <category term="技术文档" scheme="http://linyishui.top/categories/%E6%8A%80%E6%9C%AF%E6%96%87%E6%A1%A3/"/>
    
    
      <category term="docker" scheme="http://linyishui.top/tags/docker/"/>
    
  </entry>
  
  <entry>
    <title>函数式编程的技巧</title>
    <link href="http://linyishui.top/2019100401.html"/>
    <id>http://linyishui.top/2019100401.html</id>
    <published>2019-10-04T07:12:28.000Z</published>
    <updated>2019-12-06T02:57:01.771Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="函数式编程的技巧"><a href="#函数式编程的技巧" class="headerlink" title="函数式编程的技巧"></a><strong>函数式编程的技巧</strong></h1><h2 id="第一节-无处不在的函数"><a href="#第一节-无处不在的函数" class="headerlink" title="第一节 无处不在的函数"></a><strong>第一节 无处不在的函数</strong></h2><p>&emsp;&emsp;我们知道函数式编程是指函数或方法的行为就像数学函数一样——没有任何副作用。对于程序员来说，这个术语还意味着函数可以像任何其他值一样随意使用：可以作为参数传递，可以作为返回值，还能存储在数据结构中。能够像普通变量一样使用的函数被称为<strong>一等函数</strong>，通过操作符\:\:创建的方法引用，可以像使用函数值一样使用方法，也能使用Lambda表达式直接表示方法的值。</p><h3 id="1-1-高阶函数"><a href="#1-1-高阶函数" class="headerlink" title="1.1 高阶函数"></a><strong>1.1 高阶函数</strong></h3><p>&emsp;&emsp;在之前我们使用一等函数只是为了将代码传递给流处理操作，达到行为参数化的效果。我们可以接受函数作为参数同时返回另一个函数。</p><figure class="highlight lisp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Comparator&lt;Apple&gt; c = comparing(<span class="name">Apple</span>:<span class="symbol">:getWeight</span>)<span class="comment">;</span></span><br></pre></td></tr></table></figure><p><img src="https://pic-1258215793.cos.ap-shanghai.myqcloud.com/content/20191001/201910010107.png" alt="comparing方法接受一个函数作为参数同时返回另一个函数"></p><p>&emsp;&emsp;在Java 8中函数不仅可以作为参数传递，也可以作为结果返回，能赋值给本地变量，也可以插入到某个数据结构。comparing方法是一个高阶函数，我们知道传递给流的操作应该是无副作用的，高阶函数也适用这一原则。</p><blockquote><p>高阶函数要满足的要求：</p><ul><li>接受至少一个函数作为参数</li><li>返回的结果是一个函数</li></ul></blockquote><h3 id="1-2-科里化"><a href="#1-2-科里化" class="headerlink" title="1.2 科里化"></a><strong>1.2 科里化</strong></h3><p>&emsp;&emsp;科里化是一种可以帮助我们模块化函数、提高代码重用性的技术。</p><p>&emsp;&emsp;假设我们需要实现单位转换的需求，一般单位转换会涉及到转换因子以及基线调整，如摄氏度转换为华氏度：CtoF(x)=x*9/5 + 32。</p><figure class="highlight aspectj"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 单位转换</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> x 需要转换的值</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> f 转换因子</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> b 基线值</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> 结果</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">static</span> <span class="function"><span class="keyword">double</span> <span class="title">converter</span><span class="params">(<span class="keyword">double</span> x, <span class="keyword">double</span> f, <span class="keyword">double</span> b)</span></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> x * f + b;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>&emsp;&emsp;但一些情况下（如公里和英里转换），可能不会同时用到三个参数，这时我们可能首先想到的是方法重载，但其实有一些更简单的办法。如下列curriedConverter方法，可以生产带一个参数的转换方法，这样一来我们就复用了转换逻辑，代码也更灵活了。</p><figure class="highlight aspectj"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 工厂方法生产单位转换公式</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> f 转换因子</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> b 基线值</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> 单位转换公式</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">static</span> <span class="function">DoubleUnaryOperator <span class="title">curriedConverter</span><span class="params">(<span class="keyword">double</span> f, <span class="keyword">double</span> b)</span></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> (<span class="keyword">double</span> x) -&gt; x * f + b;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="function"><span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">    DoubleUnaryOperator converterCtoF = curriedConverter(<span class="number">9.0</span>/<span class="number">5</span>, <span class="number">32</span>);</span><br><span class="line">    DoubleUnaryOperator converterUSDtoGBP= curriedConverter(<span class="number">0.6</span>, <span class="number">0</span>);</span><br><span class="line">    DoubleUnaryOperator converterKmtoMi = curriedConverter(<span class="number">0.6214</span>, <span class="number">0</span>);</span><br><span class="line">    <span class="keyword">double</span> c = converterCtoF.applyAsDouble(<span class="number">100</span>);<span class="comment">//212.0</span></span><br><span class="line">    <span class="keyword">double</span> gbp = converterUSDtoGBP.applyAsDouble(<span class="number">1000</span>);<span class="comment">//600.0</span></span><br><span class="line">    <span class="keyword">double</span> km = converterKmtoMi.applyAsDouble(<span class="number">1</span>_000_000);<span class="comment">//621400.0</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>&emsp;&emsp;科里化是一种将具备2个参数的函数f转换为使用一个参数的函数g，并且这个函数的返回值也是一个函数，它会作为新函数的一个参数。后者的返回值和初始函数的返回值相同，即f(x, y) = (g(x))(y)。所以我们可以把一个有6个参数的函数科里化为一个接受2、4、6号参数，并返回一个接受5号参数的函数，这个返回的函数又返回一个接受剩下的1号和3号参数的函数。</p><hr><h2 id="第二节-持久化数据结构"><a href="#第二节-持久化数据结构" class="headerlink" title="第二节 持久化数据结构"></a><strong>第二节 持久化数据结构</strong></h2><p>&emsp;&emsp;函数式编程中常见的数据结构叫法：函数式数据结构，不可变数据结构，持久化数据结构。函数式方法不允许修改任何全局数据结构或者任何作为参数传入的结构，一旦允许对这些数据进行修改，那么多次调用就可能得到不同的结构，这违背了引用透明性原则，我们也就无法将方法简单的看作从参数到结果的映射。</p><h3 id="2-1-破坏式更新和函数式更新的比较"><a href="#2-1-破坏式更新和函数式更新的比较" class="headerlink" title="2.1 破坏式更新和函数式更新的比较"></a><strong>2.1 破坏式更新和函数式更新的比较</strong></h3><p>&emsp;&emsp;假设我们要对火车旅行从A地到B地进行建模，代码如下。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 单向链表实现对火车旅行建模</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TrainJourney</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">int</span> price;<span class="comment">//当前路途段价格</span></span><br><span class="line">    <span class="keyword">public</span> TrainJourney onward;<span class="comment">//下一段路途</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">TrainJourney</span><span class="params">(<span class="keyword">int</span> p, TrainJourney t)</span></span>&#123;</span><br><span class="line">        price = p;</span><br><span class="line">        onward = t;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 将代表X到Y和Y到Z两段路途串接起来</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> a 路途段a</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> b 路途段b</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> 新的路途段</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">static</span> TrainJourney <span class="title">link</span><span class="params">(TrainJourney a, TrainJourney b)</span></span>&#123;</span><br><span class="line">        <span class="comment">//a为空则直接返回b</span></span><br><span class="line">        <span class="keyword">if</span>(a == <span class="keyword">null</span>) <span class="keyword">return</span> b;</span><br><span class="line">        TrainJourney t = a;</span><br><span class="line">        <span class="keyword">while</span> (t.onward != <span class="keyword">null</span>)&#123;</span><br><span class="line">            <span class="comment">//当a的下个路途段不为空时，将t引用指向下个路途段</span></span><br><span class="line">            t = t.onward;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//将a路途段链表的最后一节指向b路途段</span></span><br><span class="line">        t.onward = b;</span><br><span class="line">        <span class="keyword">return</span> a;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>&emsp;&emsp;link方法有一个问题，它会破坏性的更新a，让b加入到a的链表中，执行后a不再表示从X到Y的路途段，而是新的X到Z的路途段。所以现实中可能会导致什么问题？本来应该从X到Y的旅客，因为数据被破坏了会多坐几站到最新的终点站。</p><p>&emsp;&emsp;函数式编程要杜绝这种带副作用的方法，为了计算需要创建现存数据结构的副本，这样的做法也适用于标准的面向对象程序设计。当然有异议的是这样可能会导致过度的对象复制，可能你会说你记住了这个副作用，在别处会注意这个缺陷，但最终还是挖坑留给了维护人员。我们通过递归的方式改写link方法，代码如下。</p><figure class="highlight aspectj"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 递归函数式的将代表X到Y和Y到Z两段路途串接起来</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> a 路途段a</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> b 路途段b</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> 新的路途段</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">static</span> <span class="function">TrainJourney <span class="title">append</span><span class="params">(TrainJourney a, TrainJourney b)</span></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> a == <span class="keyword">null</span> ? b : <span class="keyword">new</span> TrainJourney(a.price, append(a.onward, b));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>&emsp;&emsp;append方法是函数式的，而且并未创建整个新TrainJourney对象的副本：如果a是n个元素的序列，b是m个元素的序列，那么调用此函数后，返回的是一个n+m个元素的序列，这个序列的前n个元素是新创建的，而后m个元素是和b共享的。要注意的是，append方法生成的结果不能被用户破坏，否则会影响到b的使用者。</p><p><img src="https://pic-1258215793.cos.ap-shanghai.myqcloud.com/content/20191001/201910010108.png" alt="破坏式和函数式数据结构对比"></p><h3 id="2-2-案例：二叉查找树"><a href="#2-2-案例：二叉查找树" class="headerlink" title="2.2 案例：二叉查找树"></a><strong>2.2 案例：二叉查找树</strong></h3><p>&emsp;&emsp;我们实现一个二叉查找树，代码如下。</p><figure class="highlight zephir"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 二叉查找树</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Tree</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> String key;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> val;</span><br><span class="line">    <span class="keyword">private</span> Tree left,right;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//构造器和成员方法</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TreeProcessor</span> </span>&#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 查找树中给定字符串对应键值的整型value</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> k 给定字符串</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> defaultval 默认value</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> t 二叉查找树</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> 对应整型value</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> lookup(String k, <span class="keyword">int</span> defaultval, Tree t)&#123;</span><br><span class="line">        <span class="keyword">if</span> (t == <span class="keyword">null</span>) <span class="keyword">return</span> defaultval;</span><br><span class="line">        <span class="keyword">if</span> (k.equals(t.getKey())) <span class="keyword">return</span> t.getVal();</span><br><span class="line">        <span class="keyword">return</span> lookup(k, defaultval, k.compareTo(t.getKey()) &lt; <span class="number">0</span> ? t.getLeft() : t.getRight());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//处理Tree的其他方法</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>&emsp;&emsp;如果需要对映射中指定键对应的值做更新，我们可能会如下列代码实现。</p><figure class="highlight haxe"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 更新键对应值</span></span><br><span class="line"><span class="comment"> * @param k 给定字符串</span></span><br><span class="line"><span class="comment"> * @param newval 新值</span></span><br><span class="line"><span class="comment"> * @param t 二叉查找树</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> void update(<span class="keyword">String</span> k, int <span class="keyword">new</span><span class="type">val</span>, Tree t)&#123;</span><br><span class="line">    <span class="keyword">if</span> (t == <span class="literal">null</span>)&#123;</span><br><span class="line">        <span class="comment">/* 增加一个新的节点 */</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (k.equals(t.getKey())) t.setVal(<span class="keyword">new</span><span class="type">val</span>);</span><br><span class="line">    <span class="keyword">else</span> update(k, <span class="keyword">new</span><span class="type">val</span>, k.compareTo(t.getKey()) &lt; <span class="number">0</span> ? t.getLeft() : <span class="type">t</span>.getRight());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>&emsp;&emsp;新增节点最简单的方法是在递归过程中让update直接返回其刚遍历的树，如下列代码所示。</p><figure class="highlight haxe"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> Tree update(<span class="keyword">String</span> k, int <span class="keyword">new</span><span class="type">val</span>, Tree t)&#123;</span><br><span class="line">    <span class="keyword">if</span> (t == <span class="literal">null</span>)&#123;</span><br><span class="line">        t = <span class="keyword">new</span> <span class="type">Tree</span>(k, <span class="keyword">new</span><span class="type">val</span>, <span class="literal">null</span>, <span class="literal">null</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (k.equals(t.getKey())) t.setVal(<span class="keyword">new</span><span class="type">val</span>);</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> ( k.compareTo(t.getKey()) &lt; <span class="number">0</span>) t.setLeft(update(k, <span class="keyword">new</span><span class="type">val</span>, t.getLeft()));</span><br><span class="line">    <span class="keyword">else</span> t.setRight(update(k, <span class="keyword">new</span><span class="type">val</span>, t.getRight()));</span><br><span class="line">    <span class="keyword">return</span> t;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>&emsp;&emsp;以上两种实现都会对现有的树进行修改，意味着树的使用者都会感知到这些修改。</p><h3 id="2-3-采用函数式的方法"><a href="#2-3-采用函数式的方法" class="headerlink" title="2.3 采用函数式的方法"></a><strong>2.3 采用函数式的方法</strong></h3><p>&emsp;&emsp;如果要用函数式的方法实现键值更新，需要为新的键值创建一个新的节点，还有创建从树的根节点到新节点路径上的所有节点（副本）。通常情况下，这个操作的代价并不会很大，如果树的深度为d，且保持着一定的平衡性，那么这个树的节点总数为2^d，我们只需要创建树的一小部分节点。我们实现时没有使用if-then-else，目的是强调函数式的思想，但也可以用if-then-else实现这些。</p><figure class="highlight haxe"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 函数式的更新键对应值</span></span><br><span class="line"><span class="comment"> * @param k 给定字符串</span></span><br><span class="line"><span class="comment"> * @param newval 新值</span></span><br><span class="line"><span class="comment"> * @param t 二叉查找树</span></span><br><span class="line"><span class="comment"> * @return 新的二叉查找树</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> Tree fupdate(<span class="keyword">String</span> k, int <span class="keyword">new</span><span class="type">val</span>, Tree t)&#123;</span><br><span class="line">    <span class="keyword">return</span> (t == <span class="literal">null</span>) ?</span><br><span class="line">            <span class="keyword">new</span> <span class="type">Tree</span>(k, <span class="keyword">new</span><span class="type">val</span>, <span class="literal">null</span>, <span class="literal">null</span>) :<span class="type"></span></span><br><span class="line"><span class="type">            k</span>.equals(t.getKey()) ?</span><br><span class="line">                    <span class="keyword">new</span> <span class="type">Tree</span>(k, <span class="keyword">new</span><span class="type">val</span>, t.getLeft(), t.getRight()) :<span class="type"></span></span><br><span class="line"><span class="type">                    k</span>.compareTo(t.getKey()) &lt; <span class="number">0</span> ?</span><br><span class="line">                            <span class="keyword">new</span> <span class="type">Tree</span>(t.getKey(), t.getVal(), fupdate(k, <span class="keyword">new</span><span class="type">val</span>, t.getLeft()), t.getRight()) :<span class="type"></span></span><br><span class="line"><span class="type">                            new Tree</span>(t.getKey(), t.getVal(), t.getLeft(), fupdate(k, <span class="keyword">new</span><span class="type">val</span>, t.getRight()));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>&emsp;&emsp;update和fupdate这两种实现有什么区别呢？update的用户只会共享一份数据结构，对于此数据结构的修改会影响到所有用户，用户应该也想要及时了解程序任何部分所做的更新。fupdate则是纯函数式的，它会创建一个新树并将其作为结果返回，通过参数的方式实现共享。</p><p><img src="https://pic-1258215793.cos.ap-shanghai.myqcloud.com/content/20191001/201910010109.png" alt="对树结构进行更新时，现存数据结构不会被破坏"></p><p>&emsp;&emsp;这种函数式的数据结构通常被称为<strong>持久化的</strong>——数据结构的值始终保持一致，不受其他部分变化的影响（数据库中的持久化表示数据生命周期比程序的执行周期更长的数据）。持久化的数据结构有一个附加条件：所有使用持久化数据结构的用户都需要遵守不修改原则。如果忽视此条件去修改fupdate结果（如修改共享的Emily的年龄），会被所有使用此结果的用户感知，造成无法预知的影响。</p><p>&emsp;&emsp;fupdate可能有更高效的方式：基于不对现存结构进行修改规则，对仅有细微差别的这些通用数据结构可以考虑使用共享存储。可以通过编译器将Tree类的字段key、val、left和right改为final，需要注意的是final只能应用于类的字段，无法应用于它指向的对象，如果需要对对象保护，需要对其中的字段声明final。</p><p>&emsp;&emsp;有些时候你可能需要对树结构的更新对某些用户可见，为了实现这一需求，我们可以通过两种方式：第一种是典型的Java解决方案：对对象进行更新时，需要特别小心，慎重的考虑是否需要在改动之前保存对象的一分副本；另一种是函数式的解决方案：逻辑上，我们在做任何改动之前都会创建一份新的数据结构，只要确保按照用户的需求传递给他正确版本的数据结构就可以了。后者甚至可以通过API强制实施，如果数据结构的某些用户需要进行可见性的改动，应该调用API返回最新版的数据结构。而对于另外一些客户应用，不希望发生任何可见的改动，就直接使用它们保存的备份。</p><hr><h2 id="第三节-Stream的延迟计算"><a href="#第三节-Stream的延迟计算" class="headerlink" title="第三节 Stream的延迟计算"></a><strong>第三节 Stream的延迟计算</strong></h2><p>&emsp;&emsp;Stream的局限是其只能使用一次，所以无法声明一个递归的Stream。</p><h3 id="3-1-自定义的Stream"><a href="#3-1-自定义的Stream" class="headerlink" title="3.1 自定义的Stream"></a><strong>3.1 自定义的Stream</strong></h3><p>&emsp;&emsp;回顾流相关内容时生成质数的例子，代码如下。</p><figure class="highlight arduino"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="built_in">Stream</span>&lt;Integer&gt; primes(<span class="keyword">int</span> n)&#123;</span><br><span class="line">    <span class="built_in">return</span> <span class="built_in">Stream</span>.iterate(<span class="number">2</span>, i -&gt; i + <span class="number">1</span>)</span><br><span class="line">                 .filter(MyMathUtils::isPrime)</span><br><span class="line">                 .limit(n);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">boolean</span> isPrime(<span class="keyword">int</span> candidate)&#123;</span><br><span class="line">    <span class="keyword">int</span> candidateRoot = (<span class="keyword">int</span>) Math.<span class="built_in">sqrt</span>((<span class="keyword">double</span>) candidate);</span><br><span class="line">    <span class="built_in">return</span> IntStream.rangeClosed(<span class="number">2</span>, candidateRoot).noneMatch(i -&gt; candidate % i == <span class="number">0</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>&emsp;&emsp;上述实现每次都要遍历每个数字，查看它是否能被候选数字整除，实际上我们只需要测试已被判定为质数的数字。理想情况下，Stream应该实现实时筛掉能被质数整除的数字。</p><blockquote><p>为了实现这一想法，我们需要：</p><ol><li>一个数字构成的Stream，用来筛选质数</li><li>从该Stream中取出第一个数字，它是一个质数（初始时为2）</li><li>紧接着从Stream尾部开始，筛选掉所有能被该数字整除的元素</li><li>最后剩下的结果即新的Stream，继续用其进行质数的查找，因为要回到第一步，所以此算法是递归的。</li></ol></blockquote><p>&emsp;&emsp;第一步，构造由数字组成的Stream。</p><figure class="highlight aspectj"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="function">IntStream <span class="title">numbers</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">return</span> IntStream.<span class="title">iterate</span><span class="params">(<span class="number">2</span>, n -&gt; n + <span class="number">1</span>)</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>&emsp;&emsp;第二步，取得首元素</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">int</span> <span class="title">head</span><span class="params">(IntStream numbers)</span></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> numbers.findFirst().getAsInt();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>&emsp;&emsp;第三步，对尾部元素进行筛选</p><figure class="highlight aspectj"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="function">IntStream <span class="title">tail</span><span class="params">(IntStream numbers)</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">return</span> numbers.<span class="title">skip</span><span class="params">(<span class="number">1</span>)</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">    IntStream numbers = numbers();</span><br><span class="line">    <span class="keyword">int</span> head = head(numbers);</span><br><span class="line">    IntStream filtered = tail(numbers).filter(n -&gt; n % head != <span class="number">0</span>);</span><br></pre></td></tr></table></figure><p>&emsp;&emsp;第四步，递归的创建由质数组成的Stream</p><figure class="highlight processing"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> IntStream primes(IntStream numbers)&#123;</span><br><span class="line">    <span class="built_in">int</span> head = head(numbers);</span><br><span class="line">    <span class="keyword">return</span> IntStream.<span class="built_in">concat</span>(</span><br><span class="line">            IntStream.of(head),</span><br><span class="line">            primes(tail(numbers).<span class="built_in">filter</span>(n -&gt; n % head != <span class="number">0</span>))</span><br><span class="line">    );</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>&emsp;&emsp;不幸的是执行第四步会抛出异常：“java.lang.IllegalStateException: stream has already been operated upon or closed”，因为试图使用两个终端操作：findFirst和skip将Stream切分成头尾两部分，一旦执行一次终端操作流就会终止。</p><p>&emsp;&emsp;此操作还附带一个更严重的问题：静态方法IntStream.concat接受两个Stream实例作为参数，但由于第二个参数是primes方法的直接递归调用，最终会导致无限递归的状况（当然Java的Stream不能递归）。而函数式语言Scala和Haskell的Stream具备的这些通用特性和模型仍能帮助到我们。我们需要一种方法来推迟primes中对concat的第二个参数计算，一般称之为<strong>延迟计算</strong>、<strong>非限制式计算</strong>或<strong>名调用</strong>，只有在需要处理那个质数时才对Stream进行计算。在Scala中操作符#::实现了延迟链接的功能。</p><figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">def numbers(n: Int) Stream[Int] = n #:: numbers(n+1)</span><br><span class="line">def primes(numbers: Stream[Int]): Stream[Int] = &#123;</span><br><span class="line">    numbers.head #:: primes(numbers.tail<span class="built_in"> filter </span>(n -&gt; n % numbers.head != 0))</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>&emsp;&emsp;在Java中执行一次方法调用，传递的所有参数在第一时间会被立即计算出来；而在Scala中，通过#::操作符，连接操作会立刻返回，而元素的计算会推迟到实际计算需要的时候才开始。</p><h3 id="3-2-创建自己的延迟列表"><a href="#3-2-创建自己的延迟列表" class="headerlink" title="3.2 创建自己的延迟列表"></a><strong>3.2 创建自己的延迟列表</strong></h3><p>&emsp;&emsp;Stream具有延迟执行的特性，流就像一个黑盒，接收请求并生成结果。当你向流提交一系列操作请求时，这些请求只是被异议保存起来，只有当请求一个终端操作时，才会实际的进行计算。这样设计的优点是Stream只需要被遍历一次，不需要为每个操作都遍历一次元素。</p><p>&emsp;&emsp;延迟列表是一种更加通用的Stream形式，提供了一种极好的方式去理解高阶函数，你可以将函数作为值存储在某个数据结构中，等到需要调用时可以创建更多的数据结构。</p><p><img src="https://pic-1258215793.cos.ap-shanghai.myqcloud.com/content/20191001/201910010110.png" alt="LinkedList的元素存在于内存中LazyList的元素由函数在需要使用时动态创建，可以看作实时延展的"></p><h4 id="3-2-1-一个基本的链接列表"><a href="#3-2-1-一个基本的链接列表" class="headerlink" title="3.2.1 一个基本的链接列表"></a><strong>3.2.1 一个基本的链接列表</strong></h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">MyList</span>&lt;<span class="title">T</span>&gt; </span>&#123;</span><br><span class="line">    <span class="function">T <span class="title">head</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="function">MyList&lt;T&gt; <span class="title">tail</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">default</span> <span class="keyword">boolean</span> <span class="title">isEmpty</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyLinkedList</span>&lt;<span class="title">T</span>&gt; <span class="keyword">implements</span> <span class="title">MyList</span>&lt;<span class="title">T</span>&gt; </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> T head;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> MyList&lt;T&gt; tail;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">MyLinkedList</span><span class="params">(T head, MyList&lt;T&gt; tail)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.head = head;</span><br><span class="line">        <span class="keyword">this</span>.tail = tail;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> T <span class="title">head</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> head;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> MyList&lt;T&gt; <span class="title">tail</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> tail;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isEmpty</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Empty</span>&lt;<span class="title">T</span>&gt; <span class="keyword">implements</span> <span class="title">MyList</span>&lt;<span class="title">T</span>&gt; </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> T <span class="title">head</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> UnsupportedOperationException();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> MyList&lt;T&gt; <span class="title">tail</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> UnsupportedOperationException();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        MyList&lt;Integer&gt; l = <span class="keyword">new</span> MyLinkedList&lt;&gt;(<span class="number">5</span>, <span class="keyword">new</span> MyLinkedList&lt;&gt;(<span class="number">10</span>,<span class="keyword">new</span> Empty&lt;&gt;()));</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><h4 id="3-2-2-一个基础的延迟列表"><a href="#3-2-2-一个基础的延迟列表" class="headerlink" title="3.2.2 一个基础的延迟列表"></a><strong>3.2.2 一个基础的延迟列表</strong></h4><p>&emsp;&emsp;对链表进行改造，使其符合延迟列表的要求。最简单的方法是避免让tail立刻出现在内存中，用Supplier包装一层，对应的函数代码会产生列表的下个节点。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">LazyList</span>&lt;<span class="title">T</span>&gt; <span class="keyword">implements</span> <span class="title">MyList</span>&lt;<span class="title">T</span>&gt; </span>&#123;</span><br><span class="line">    <span class="keyword">final</span> T head;</span><br><span class="line">    <span class="keyword">final</span> Supplier&lt;MyList&lt;T&gt;&gt; tail;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">LazyList</span><span class="params">(T head, Supplier&lt;MyList&lt;T&gt;&gt; tail)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.head = head;</span><br><span class="line">        <span class="keyword">this</span>.tail = tail;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> T <span class="title">head</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> head;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> MyList&lt;T&gt; <span class="title">tail</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> tail.get();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isEmpty</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>&emsp;&emsp;调用Supplier的get方法会触发延迟列表的节点创建，就像工厂会创建新的对象一样。我们可以通过递归传递函数创建一系列的数字序列。</p><figure class="highlight livescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 创建由数字构成的无限延迟列表</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">public static LazyList&lt;Integer&gt; <span class="keyword">from</span>(int n)&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> LazyList&lt;&gt;<span class="function"><span class="params">(n, () -&gt; <span class="keyword">from</span>(n+<span class="number">1</span>))</span>;</span></span><br><span class="line"><span class="function">&#125;</span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function"><span class="title">public</span> <span class="title">static</span> <span class="title">void</span> <span class="title">main</span><span class="params">(String[] args)</span> &#123;</span></span><br><span class="line"><span class="function">    <span class="title">LazyList</span>&lt;<span class="title">Integer</span>&gt; <span class="title">numbers</span> = <span class="title">LazyList</span>.<span class="title">from</span><span class="params">(<span class="number">2</span>)</span>;</span></span><br><span class="line"><span class="function">    <span class="title">int</span> <span class="title">two</span> = <span class="title">numbers</span>.<span class="title">head</span><span class="params">()</span>;</span></span><br><span class="line"><span class="function">    <span class="title">int</span> <span class="title">three</span> = <span class="title">numbers</span>.<span class="title">tail</span><span class="params">()</span>.<span class="title">head</span><span class="params">()</span>;</span></span><br><span class="line"><span class="function">    <span class="title">int</span> <span class="title">four</span> = <span class="title">numbers</span>.<span class="title">tail</span><span class="params">()</span>.<span class="title">tail</span><span class="params">()</span>.<span class="title">head</span><span class="params">()</span>;</span></span><br><span class="line"><span class="function">    <span class="title">System</span>.<span class="title">out</span>.<span class="title">println</span><span class="params">(two + <span class="string">" "</span> + three + <span class="string">" "</span> + four)</span>;//2 3 4</span></span><br><span class="line"><span class="function">&#125;</span></span><br></pre></td></tr></table></figure><h4 id="3-2-3-回到生成质数"><a href="#3-2-3-回到生成质数" class="headerlink" title="3.2.3 回到生成质数"></a><strong>3.2.3 回到生成质数</strong></h4><p>&emsp;&emsp;如果我们直接用LazyList替换实现的primes函数，如下代码所示，会因为filter方法未定义不能通过编译。</p><figure class="highlight livescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">public static MyList&lt;Integer&gt; primes(MyList&lt;Integer&gt; numbers)&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> LazyList&lt;&gt;(</span><br><span class="line">            numbers.head(),</span><br><span class="line">            <span class="function"><span class="params">()</span> -&gt;</span> primes(numbers.tail().filter(n<span class="function"> -&gt;</span> n % numbers.head() != <span class="number">0</span>))</span><br><span class="line">    );</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="3-2-4-实现一个延迟筛选器"><a href="#3-2-4-实现一个延迟筛选器" class="headerlink" title="3.2.4 实现一个延迟筛选器"></a><strong>3.2.4 实现一个延迟筛选器</strong></h4><p>&emsp;&emsp;我们在MyList接口添加方法定义，并在LazyList中实现filter方法，代码如下。</p><figure class="highlight livescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line">public interface MyList&lt;T&gt; &#123;</span><br><span class="line">    ......</span><br><span class="line">    MyList&lt;T&gt; filter(Predicate&lt;T&gt; p);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public <span class="class"><span class="keyword">class</span> <span class="title">LazyList</span>&lt;<span class="title">T</span>&gt; <span class="title">implements</span> <span class="title">MyList</span>&lt;<span class="title">T</span>&gt; &#123;</span></span><br><span class="line">    ......</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public MyList&lt;T&gt; filter(Predicate&lt;T&gt; p)&#123;</span><br><span class="line">        <span class="keyword">return</span> isEmpty() ?</span><br><span class="line">                <span class="keyword">this</span> : p.test<span class="function"><span class="params">(head())</span> ? <span class="title">new</span> <span class="title">LazyList</span>&lt;&gt;<span class="params">(head(), () -&gt; tail().filter(p))</span> : <span class="title">tail</span><span class="params">()</span>.<span class="title">filter</span><span class="params">(p)</span>;</span></span><br><span class="line"><span class="function">    &#125;</span></span><br><span class="line"><span class="function">&#125;</span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function">    <span class="title">public</span> <span class="title">static</span> <span class="title">MyList</span>&lt;<span class="title">Integer</span>&gt; <span class="title">primes</span><span class="params">(MyList&lt;Integer&gt; numbers)</span>&#123;</span></span><br><span class="line"><span class="function">        <span class="title">return</span> <span class="title">new</span> <span class="title">LazyList</span>&lt;&gt;<span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">                numbers.head(),</span></span></span><br><span class="line"><span class="function"><span class="params">                () -&gt; primes(numbers.tail().filter(n -&gt; n % numbers.head() != <span class="number">0</span>))</span></span></span><br><span class="line"><span class="function"><span class="params">        )</span>;</span></span><br><span class="line"><span class="function">    &#125;</span></span><br><span class="line"><span class="function">    </span></span><br><span class="line"><span class="function">    <span class="title">public</span> <span class="title">static</span> <span class="title">void</span> <span class="title">main</span><span class="params">(String[] args)</span> &#123;</span></span><br><span class="line"><span class="function">        //延迟列表实现生成质数</span></span><br><span class="line"><span class="function">        <span class="title">LazyList</span>&lt;<span class="title">Integer</span>&gt; <span class="title">numbers</span> = <span class="title">LazyList</span>.<span class="title">from</span><span class="params">(<span class="number">2</span>)</span>;</span></span><br><span class="line"><span class="function">        <span class="title">int</span> <span class="title">two</span> = <span class="title">primes</span><span class="params">(numbers)</span>.<span class="title">head</span><span class="params">()</span>;</span></span><br><span class="line"><span class="function">        <span class="title">int</span> <span class="title">three</span> = <span class="title">primes</span><span class="params">(numbers)</span>.<span class="title">tail</span><span class="params">()</span>.<span class="title">head</span><span class="params">()</span>;</span></span><br><span class="line"><span class="function">        <span class="title">int</span> <span class="title">four</span> = <span class="title">primes</span><span class="params">(numbers)</span>.<span class="title">tail</span><span class="params">()</span>.<span class="title">tail</span><span class="params">()</span>.<span class="title">head</span><span class="params">()</span>;</span></span><br><span class="line"><span class="function">        <span class="title">System</span>.<span class="title">out</span>.<span class="title">println</span><span class="params">(two + <span class="string">" "</span> + three + <span class="string">" "</span> + four)</span>;//2 3 5</span></span><br><span class="line"><span class="function">    &#125;</span></span><br></pre></td></tr></table></figure><p>&emsp;&emsp;尝试循环打印延迟数组中的质数，这个程序不会一直运行下去，最终会因栈溢出而终止，因为Java不支持尾部调用消除。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> &lt;T&gt; <span class="function"><span class="keyword">void</span> <span class="title">printAll</span><span class="params">(MyList&lt;T&gt; <span class="built_in">list</span>)</span></span>&#123;</span><br><span class="line">    <span class="keyword">while</span> (!<span class="built_in">list</span>.isEmpty())&#123;</span><br><span class="line">        System.out.println(<span class="built_in">list</span>.head());</span><br><span class="line">        <span class="built_in">list</span> = <span class="built_in">list</span>.tail();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//递归写法</span></span><br><span class="line"><span class="keyword">static</span> &lt;T&gt; <span class="function"><span class="keyword">void</span> <span class="title">printAll</span><span class="params">(MyList&lt;T&gt; <span class="built_in">list</span>)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(<span class="built_in">list</span>.isEmpty())</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    System.out.println(<span class="built_in">list</span>.head());</span><br><span class="line">    printAll(<span class="built_in">list</span>.tail());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="3-2-5-使用场景"><a href="#3-2-5-使用场景" class="headerlink" title="3.2.5 使用场景"></a><strong>3.2.5 使用场景</strong></h4><p>&emsp;&emsp;比如我们要编写游戏程序，可以定义一些数据结构来存放要加载的物体，具体内容可以在运行时创建，而不用花大量的时间在一开始就创建好，最终的结果是一个延迟树，而不是延迟列表，我们主要讲延迟列表是为了和Stream形成对比。</p><p>&emsp;&emsp;延迟操作的性能一般情况下都要比提前操作要好，但有时比如我们只访问列表前10个元素，每个节点会创建两次，最终创建20个节点，原因在于每次实时访问列表元素时，tail的Supplier都会被重复调用；我们可以设定tail中的Supplier方法只在第一次实时访问时才执行调用，可以在LazyList中添加一个私有的Optional&lt;LazyList<t>&gt;类型字段alreadyComputed，tail方法会根据情况查询及更新该字段的值。</t></p><hr><h2 id="第四节-模式匹配"><a href="#第四节-模式匹配" class="headerlink" title="第四节 模式匹配"></a><strong>第四节 模式匹配</strong></h2><p>&emsp;&emsp;函数式编程的模式匹配和正则表达式的模式匹配容易混淆，是为了解决因为需求变更等原因导致if-else-then或switch代码数量迅速膨胀的问题。</p><p>&emsp;&emsp;假设我们用类Expr对一种数学语言建模，包含数字和二进制操作符。</p><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Expr</span> </span>&#123; ... &#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Number</span> <span class="keyword">extends</span> <span class="title">Expr</span> </span>&#123; int <span class="keyword">val</span>; ... &#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">BinOp</span> <span class="keyword">extends</span> <span class="title">Expr</span> </span>&#123; <span class="type">String</span> opname; <span class="type">Expr</span> left; <span class="type">Expr</span> right; ... &#125;</span><br></pre></td></tr></table></figure><p>&emsp;&emsp;假设我们要通过方法来简化某个表达式，比如5+0=5可以简化为5 -&gt; new BinOp(“+”, new Number(5), new Number(0))可以简化为Number(5)，实现代码可能会如下。</p><figure class="highlight gauss"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">Expr</span> simplifyExpression(<span class="keyword">Expr</span> <span class="keyword">expr</span>)&#123;</span><br><span class="line">    <span class="keyword">if</span>(<span class="keyword">expr</span> instanceof BinOp</span><br><span class="line">         &amp;&amp; ((BinOp) <span class="keyword">expr</span>).opname.equals(<span class="string">"+"</span>))</span><br><span class="line">         &amp;&amp; ((BinOp) <span class="keyword">expr</span>).right instanceof Number</span><br><span class="line">         &amp;&amp; ... <span class="comment">//变得非常笨拙</span></span><br><span class="line">         &amp;&amp; ...)&#123;</span><br><span class="line">             <span class="keyword">return</span> (BinOp) <span class="keyword">expr</span>.left;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="4-1-访问者设计模式"><a href="#4-1-访问者设计模式" class="headerlink" title="4.1 访问者设计模式"></a><strong>4.1 访问者设计模式</strong></h3><p>&emsp;&emsp;访问者设计模式，需要创建一个单独的类，此类封装了一个算法，可以“访问”某种数据类型。访问者类会接受某种数据类型的实例作为输入，它可以访问实例所有的成员。</p><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">BinOp</span> <span class="keyword">extends</span> <span class="title">Expr</span> </span>&#123;</span><br><span class="line">    ...</span><br><span class="line">    public <span class="type">Expr</span> accept(<span class="type">SimplifyExprVistor</span> v)&#123;</span><br><span class="line">        <span class="keyword">return</span> v.visit(<span class="keyword">this</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>&emsp;&emsp;SimplifyExprVistor可以访问BinOp对象并解包其中的内容。</p><figure class="highlight cs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">SimplifyExprVistor</span>&#123;</span><br><span class="line">    ...</span><br><span class="line">    <span class="function"><span class="keyword">public</span> Expr <span class="title">visit</span>(<span class="params">BinOp e</span>)</span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(<span class="string">"+"</span>.<span class="keyword">equals</span>(e.opname) &amp;&amp; e.right instanceof Number &amp;&amp; ...)&#123;</span><br><span class="line">            <span class="keyword">return</span> e.left;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> e;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="4-2-用模式匹配力挽狂澜"><a href="#4-2-用模式匹配力挽狂澜" class="headerlink" title="4.2 用模式匹配力挽狂澜"></a><strong>4.2 用模式匹配力挽狂澜</strong></h3><p>&emsp;&emsp;通过模式匹配这个特性，我们可以更简单的来解决上述问题。但此特性在Java 8版本还未支持，所以用Scala语言来展示其作用。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">def simplifyExpression(expr: Expr): Expr = expr match&#123;</span><br><span class="line">    <span class="keyword">case</span> BinOp(<span class="string">"+"</span>, e, <span class="built_in">Number</span>(<span class="number">0</span>)) =&gt; e <span class="comment">//加0</span></span><br><span class="line">    <span class="keyword">case</span> BinOp(<span class="string">"*"</span>, e, <span class="built_in">Number</span>(<span class="number">1</span>)) =&gt; e <span class="comment">//乘以1</span></span><br><span class="line">    <span class="keyword">case</span> BinOp(<span class="string">"/"</span>, e, <span class="built_in">Number</span>(<span class="number">1</span>)) =&gt; e <span class="comment">//除以1</span></span><br><span class="line">    <span class="keyword">case</span> <span class="function"><span class="params">_</span> =&gt;</span> expr                     <span class="comment">//不能简化expr</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>&emsp;&emsp;Scala语法如下，通配符判断和Java中的default:扮演同样的角色。Java中的模式判断被限制在基础类型、枚举类型、包装类型以及String类型。模式匹配可以避免出现大量嵌套的switch或if-then-else语句与字段选择操作相互交织的情况。</p><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Expression match &#123; <span class="keyword">case</span> <span class="built_in">Pattern</span> =&gt; Expression ... &#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//和Java的switch相似</span></span><br><span class="line"><span class="keyword">switch</span> (Expression) &#123; <span class="keyword">case</span> Constant : Statement ... &#125;</span><br></pre></td></tr></table></figure><p>&emsp;&emsp;Lambda表达式反而可以比较简洁的实现单层的模式匹配。</p><hr><h2 id="第五节-杂项"><a href="#第五节-杂项" class="headerlink" title="第五节 杂项"></a><strong>第五节 杂项</strong></h2><h3 id="5-1-缓存或记忆表"><a href="#5-1-缓存或记忆表" class="headerlink" title="5.1 缓存或记忆表"></a><strong>5.1 缓存或记忆表</strong></h3><p>&emsp;&emsp;假设有一个方法computeNumberOfNodesUsingCache(Range)，用来计算一个树形网络中给定区间内的节点数目。假设此网络不会发生变化，即数据结构是不可变的，computeNumberOfNodesUsingCache需要递归遍历，所以方法的开销还是很大的。如果我们能保证引用透明性，就可以有一种方法来避免这种冗余的开销：<strong>记忆表</strong>——为方法添加一个封装器，在其中加入一块缓存（比如一个HashMap），当封装器被调用时，首先查看缓存，看请求的（参数，结果）是否已存于缓存中，如果存在就直接返回缓存结果，否则调用computeNumberOfNodesUsingCache。严格的来看，这种实现并非纯粹的函数式解决方案，因为会修改多个调用者共享的数据结构，但这段代码的封装版本的确是引用透明的。</p><figure class="highlight fortran"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">final</span> Map&lt;<span class="built_in">Range</span>, <span class="keyword">Integer</span>&gt; numberOfNodes = new HashMap&lt;&gt;();</span><br><span class="line"><span class="keyword">Integer</span> computeNumberOfNodesUsingCache(<span class="built_in">Range</span> <span class="built_in">range</span>)&#123;</span><br><span class="line">    <span class="keyword">Integer</span> result = numberOfNodes.get(<span class="built_in">range</span>);</span><br><span class="line">    <span class="keyword">if</span>(result <span class="comment">!= null)&#123;</span></span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line">    result = computeNumberOfNodesUsingCache(<span class="built_in">range</span>);</span><br><span class="line">    numberOfNodes.put(<span class="built_in">range</span>, result);</span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">//Java <span class="number">8</span>改进了Map接口，提供了computeIfAbsent方法来处理这种情况</span><br><span class="line"><span class="keyword">Integer</span> computeNumberOfNodesUsingCache(<span class="built_in">Range</span> <span class="built_in">range</span>)&#123;</span><br><span class="line">    <span class="keyword">return</span> numberOfNodes.computeIfAbsent(<span class="built_in">range</span>, this::computeNumberOfNodes)</span><br></pre></td></tr></table></figure><p>&emsp;&emsp;numberOfNodes处于可变共享状态，并且HashMap也没有同步，这意味着这段代码不是线程安全的。如果多核对numberOfNodes执行并发调用，就算用（锁保护的）HashTable 或（并发无锁的）ConcurrentHashMap，可能都无法达到预期的性能，因为这中间又存在由于发现某个值不再Map中，需要将对应的键值对插回到Map而引起的竞态条件。这意味着多个核上的进程可能算出的结果相同，又都需要将其加入到Map中。</p><p>&emsp;&emsp;一旦并发和可变对象揉到一起所引起的复杂度要远超我们的想象，而函数式编程可以从根本上解决这一问题。以函数式的方式进行设计，不用担心是否采用了正确的同步方式，因为没有任何共享的可变状态。</p><h3 id="5-2-“返回同样的对象”意味着什么"><a href="#5-2-“返回同样的对象”意味着什么" class="headerlink" title="5.2 “返回同样的对象”意味着什么"></a><strong>5.2 “返回同样的对象”意味着什么</strong></h3><p>&emsp;&emsp;回顾2.3实现的fupdate方法，通过变量t指向一棵现存的树，调用fupdate(“Will”, 26, t)会生成一个新树。我们假设该树会被赋值给变量t2，那么再调用一次fupdate(“Will”, 26, t)并赋值给t3，应该会生成一个同样数据的新树。那么fupdate还符合引用透明性吗？因为引用透明性原则意味着使用相同的参数会产生相同的结果，但 t2 != t3，所以fupdate应该不符合引用透明性原则。</p><p>&emsp;&emsp;但即使如此，t2和t3使用时在逻辑上没有区别，关于这一点也有很多的辩论，<strong>对于函数式编程通常不使用==（引用相等），而是使用equal对数据结构值进行比较</strong>，所以这样看来fupdate还是符合引用透明性原则的。</p><h3 id="5-3-结合器"><a href="#5-3-结合器" class="headerlink" title="5.3 结合器"></a><strong>5.3 结合器</strong></h3><p>&emsp;&emsp;函数式编程时经常会使用到高阶函数，接受两个或多个函数，并返回另一个函数，最终实现效果类似于把这些函数进行了结合。<strong>结合器</strong>就是用来表示这种思想的术语，Java 8中很多API都源自于此思想，如CompletableFuture类中的thenCombine，接受两个CompletableFuture方法和一个BiFunction方法，返回另一个CompletableFuture方法。</p><p>&emsp;&emsp;如下代码体现出函数组合的思想，效果就是先执行f再执行g。</p><figure class="highlight coq"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">static &lt;A,B,C&gt; <span class="keyword">Function</span>&lt;A,C&gt; compose(<span class="keyword">Function</span>&lt;B,C&gt; g, <span class="keyword">Function</span>&lt;A,B&gt; f)&#123;</span><br><span class="line">    <span class="keyword">return</span> x -&gt; g.<span class="built_in">apply</span>(f.<span class="built_in">apply</span>(x));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>&emsp;&emsp;假设我们想要对一个参数使用函数f连续的进行n次操作，类似于循环。</p><figure class="highlight fortran"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">static &lt;A&gt; <span class="function"><span class="keyword">Function</span></span>&lt;A,A&gt; <span class="built_in">repeat</span>(<span class="built_in">int</span> n, <span class="function"><span class="keyword">Function</span></span>&lt;A,A&gt; f)&#123;</span><br><span class="line">    //n为<span class="number">0</span>直接返回标识符表示什么也不做，否则执行f，重复执行n-<span class="number">1</span>次，最后再执行一次</span><br><span class="line">    <span class="keyword">return</span> n==<span class="number">0</span> ? x -&gt; x</span><br><span class="line">                : compose(f, <span class="built_in">repeat</span>(n-<span class="number">1</span>, f));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>&emsp;&emsp;这个想法稍作变更可以对迭代概念的更丰富外延进行建模，甚至包括对在迭代直接传递可变状态的函数式模型，但这里只是对函数式编程做一个全局的介绍就不继续展开了。</p><hr><p><em>参考博客和文章书籍等：</em></p><blockquote><p>《Java8实战》</p></blockquote><p><em>因博客主等未标明不可引用，若部分内容涉及侵权请及时告知，我会尽快修改和删除相关内容</em></p>]]></content>
    
    <summary type="html">
    
      介绍Java 8中引入的函数式编程的技巧，内容包括：第一节 无处不在的函数（高阶函数、科里化），第二节 持久化数据结构（破坏式更新和函数式更新的比较、案例：二叉查找树、采用函数式的方法），Stream的延迟计算（自定义的Stream、创建自己的延迟列表），第四节 模式匹配（访问者设计模式、用模式匹配力挽狂澜），第五节 杂项（缓存或记忆表、“返回同样的对象”意味着什么、结合器）等。
    
    </summary>
    
      <category term="技术文档" scheme="http://linyishui.top/categories/%E6%8A%80%E6%9C%AF%E6%96%87%E6%A1%A3/"/>
    
    
      <category term="java" scheme="http://linyishui.top/tags/java/"/>
    
      <category term="functional" scheme="http://linyishui.top/tags/functional/"/>
    
  </entry>
  
  <entry>
    <title>函数式的思考</title>
    <link href="http://linyishui.top/2019100301.html"/>
    <id>http://linyishui.top/2019100301.html</id>
    <published>2019-10-03T03:31:13.000Z</published>
    <updated>2019-12-05T07:09:40.827Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="函数式的思考"><a href="#函数式的思考" class="headerlink" title="函数式的思考"></a><strong>函数式的思考</strong></h1><h2 id="第一节-引文"><a href="#第一节-引文" class="headerlink" title="第一节 引文"></a><strong>第一节 引文</strong></h2><p>&emsp;&emsp;函数式编程是一种新的编程风格，核心就是<strong>把函数作为值</strong>。利用函数式编程可以用更少的时间，写出更清晰、简洁的代码。函数所指的这部分代码，可以被来回传递并加以组合，从而产生强大的编程语汇。</p><hr><h2 id="第二节-实现和维护系统"><a href="#第二节-实现和维护系统" class="headerlink" title="第二节 实现和维护系统"></a><strong>第二节 实现和维护系统</strong></h2><p>&emsp;&emsp;假设我们需要接手一个不熟悉项目，如果我们比较有经验可能会先搜索一下代码中是否有使用synchronized关键字，如果有就意味着要面对修复并发导致的缺陷的可能。为了让程序易于使用，希望最好项目的类结构能直接反映出系统的结构，具有良好的<strong>耦合性</strong>（软件系统各组件之间是否相互独立）和<strong>内聚性</strong>（系统的各相关部分之间如何协作）。对于程序员来说，大部分日常工作应该是代码维护时的调试：代码遭遇无法预测的情况而崩溃，为什么这样？如何进入这种状态的？而函数式编程的<strong>无副作用</strong>和<strong>不变性</strong>对于这一问题大有裨益。</p><h3 id="2-1-共享的可变数据"><a href="#2-1-共享的可变数据" class="headerlink" title="2.1 共享的可变数据"></a><strong>2.1 共享的可变数据</strong></h3><p>&emsp;&emsp;<strong>无法预知的变量修改问题</strong>源自于共享的数据结构被你所维护的代码中的多个方法读取和更新。正式由于使用了这种结构导致我们很难追踪到程序的各个组成部分所发生的变化。<strong>如果一个方法既不修改它内嵌类的状态，也不修改其他对象的状态，使用return返回所有的计算结果</strong>，那么我们就可以称其为<strong>纯粹的</strong>或<strong>无副作用的</strong>。</p><p>&emsp;&emsp;多个类同时共享一个可变对象，很难说到底哪个类真正拥有对象，如下图所示。</p><p><img src="https://pic-1258215793.cos.ap-shanghai.myqcloud.com/content/20191001/201910010102.png" alt="多个类同时共享一个可变对象，很难说到底哪个类真正拥有对象"></p><blockquote><p>副作用就是函数的效果超过了其自身的范畴，一些例子：</p><ul><li>除了构造器内的初始化操作，还对类中数据结构的任何修改，包括字段的赋值操作（如setter）</li><li>抛出一个异常</li><li>进行输入/输出操作，比如向文件写数据</li></ul></blockquote><p>&emsp;&emsp;所以为了实现无副作用，我们应该考虑不可变对象，可以放心的共享，不需要创建任何副本。但真正的生产系统是否能够由这种设计来实现？答案是可以，并且如何系统的各个组件能够遵守这一原则，系统就可以在无锁的情况下适用多核的并发机制，任何一个方法都不会对其他方法造成干扰。</p><h3 id="2-2-声明式编程"><a href="#2-2-声明式编程" class="headerlink" title="2.2 声明式编程"></a><strong>2.2 声明式编程</strong></h3><p>&emsp;&emsp;编程实现系统有两种思考方式：一种专注于如何实现，一种专注于要做什么。前者适合经典的面向对象编程，特点就是和计算机底层词汇相似，如赋值、条件分支以及循环，这种编程会被叫做<strong>命令式编程</strong>。后者则将如何实现的细节留给函数库，这种思想叫<strong>内部迭代</strong>，我们的语言看起来会更像问题陈述，这种风格的编程被称为<strong>声明式编程</strong>。</p><h3 id="2-3-为什么要采用函数式编程"><a href="#2-3-为什么要采用函数式编程" class="headerlink" title="2.3 为什么要采用函数式编程"></a><strong>2.3 为什么要采用函数式编程</strong></h3><p>&emsp;&emsp;函数式编程具体实践了声明式编程和无副作用计算，可以使我们更容易的构建和维护系统。实现函数式编程必要的一些特性，如构造操作和传递行为可以使我们的程序更便于阅读、易于编写。</p><hr><h2 id="第三节-什么是函数式编程"><a href="#第三节-什么是函数式编程" class="headerlink" title="第三节 什么是函数式编程"></a><strong>第三节 什么是函数式编程</strong></h2><p>&emsp;&emsp;一种使用函数进行编程的方式。函数式编程中的函数对应一个数学函数，接收参数返回结果但不会有副作用，不同于Java中常见的函数，没有可变共享变量的参与。当我们定义函数式时，想要表达的是像数学函数那样没有副作用，我们能否在函数内部执行一些非函数式操作，只要其结果不会暴露出来？或者程序可以存在副作用但不会被其它调用者感知？为了准确的区别二者，我们称第一种为<strong>纯粹的函数式编程</strong>，第二种为<strong>函数式编程</strong>。</p><p>&emsp;&emsp;我们可以把函数式编程看作一个<strong>黑盒模型</strong>：输入-&gt;函数-&gt;输出。下图分别为带有副作用的函数和没有副作用的函数。</p><p><img src="https://pic-1258215793.cos.ap-shanghai.myqcloud.com/content/20191001/201910010103.png" alt="带有副作用的函数"></p><p><img src="https://pic-1258215793.cos.ap-shanghai.myqcloud.com/content/20191001/201910010104.png" alt="没有副作用的函数"></p><h3 id="3-1-函数式Java编程"><a href="#3-1-函数式Java编程" class="headerlink" title="3.1 函数式Java编程"></a><strong>3.1 函数式Java编程</strong></h3><p>&emsp;&emsp;实际Java编程中，我们无法以纯粹的函数式编程来实现一个程序，但可以为系统的核心组件编写接近纯粹式函数式的实现。首先，要确保代码的副作用不能被感知到。比如有一个函数在进入方法体执行时会对一个字段值+1，退出方法体前会对字段值-1。对于单线程来说，这个函数没有副作用。但多线程时，其他线程可以查看该字段的值，甚至并发调用它，那么此函数就不能称为函数式的实现了。当然我们可以通过加锁来对方法体进行封装，从而掩盖这一问题，但同时也失去了在多核处理器上的两个核并发执行两个方法调用的能力。虽然最终符合了函数式的定义，但实际上降低了运行效率。</p><p>&emsp;&emsp;所以我们的准则是，<strong>被称为函数式的函数或方法都只能修改本地变量</strong>。除此之外，<strong>引用的对象都只能是不可修改的对象</strong>（期望所有字段都是final）。但<strong>实际上也会允许对方法中全新创建的对象中的字段进行更新</strong>，不过这些字段对于其他对象是不可见的，也不会因为保存而对后续调用造成影响。</p><p>&emsp;&emsp;如果被称为函数式，<strong>函数或方法不能抛出任何异常</strong>。一旦抛出异常就意味着结果被终止了，但这点其实和数学函数也有冲突，这些数学操作可以被称作<strong>局部函数式</strong>，当输入正常返回确定的结果，但对于一些输入其结果是<strong>未定义的</strong>，甚至不返回结果（比如除法除数为0）。所以有些人认为通过抛出异常来对这类情况建模是合理的，但捕获异常是一种非函数式的控制流，这种操作违背了我们定义的黑盒模型，从而增加了一组代表异常处理的箭头：-&gt;异常。</p><p><img src="https://pic-1258215793.cos.ap-shanghai.myqcloud.com/content/20191001/201910010105.png" alt="抛出一个异常的方法"></p><p>&emsp;&emsp;不使用异常的方案就是使用<strong>Optional<t></t></strong>类型，避免直接使用原始或引用类型作为函数返回值，而是Optional<t>包装返回值。当然我们需要检查函数返回值是否为一个空的Optional对象，这种方式似乎很繁琐，所以我们可以像非纯粹的函数式那样选择在本地局部地使用异常，避免通过接口将结果暴露给其他方法，这样既利用了函数式的优点，也不会过度的使代码膨胀。</t></p><p>&emsp;&emsp;当我们实现的函数存在副作用时，请隐藏这些非函数式行为，否则就不要调用这些方法（换句话说，你要确保它们对数据结构的任何修改对于调用者都是不可见的，可以通过首次复制，或者捕获任何可能抛出的异常来实现这一目的）。如后续3.4的实战代码中我们隐藏了方法insertAll调用库函数List.add所产生的副作用。</p><h3 id="3-2-引用透明性"><a href="#3-2-引用透明性" class="headerlink" title="3.2 引用透明性"></a><strong>3.2 引用透明性</strong></h3><p>&emsp;&emsp;<strong>没有可感知的副作用</strong>隐含着<strong>引用透明性</strong>，如果一个函数只要传递同样的参数值，必定会返回同样的结果，可以称这个函数是引用透明的。比如String.replace方法总是返回同样的结果，而不是更新它的this对象，就是引用透明的，可以被看作函数式。所以引用透明性可以看作是函数式的特征，相对的Random.nextInt方法就不会被看作函数式方法。</p><p>&emsp;&emsp;一种复杂的情况是，比如一个方法会返回一个集合，但如果调用两次会返回两个不同的集合对象，虽然它们有相同的元素值。如果我们把集合当作可变的对象值，那么这个方法就是不透明的。但如果我们把这些结合作为单纯的值（不可修改），这时两个集合被看作是相同集合是合理的，那么这个方法就是透明的。通常，<strong>在函数式编程中，你应该选择使用引用透明的函数</strong>。</p><h3 id="3-3-面向对象编程和函数式编程的对比"><a href="#3-3-面向对象编程和函数式编程的对比" class="headerlink" title="3.3 面向对象编程和函数式编程的对比"></a><strong>3.3 面向对象编程和函数式编程的对比</strong></h3><p>&emsp;&emsp;Java 8认为这些函数式风格只是面向对象的一个极端，由硬件发展和程序员的期望而带来了这些从面向对象到函数式的变化，实际上Java程序员经常会混用两种编程风格，可能会使用包含了可变内部状态的迭代器遍历某个数据结构，同时又通过函数式的方式计算数据结构中变量之和。</p><h3 id="3-4-函数式编程实战"><a href="#3-4-函数式编程实战" class="headerlink" title="3.4 函数式编程实战"></a><strong>3.4 函数式编程实战</strong></h3><p>&emsp;&emsp;假设我们需要对给定的一个集合求其所有子集，思路就是通过归纳法递归进行元素间的排列组合，实现方法subsets，递归的每一次都会拿出一个元素并求剩余集合元素的子集，再和拿出的元素排列组合得出结果。</p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ActualCombat</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> void main(String[] args) &#123;</span><br><span class="line">        <span class="keyword">List</span>&lt;Integer&gt; <span class="keyword">list</span> = Arrays.asList(<span class="number">1</span>,<span class="number">4</span>,<span class="number">9</span>);</span><br><span class="line">        subsets(<span class="keyword">list</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 给定一个集合，求集合所有子集</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> list 集合</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> 子集数组</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">List</span>&lt;<span class="keyword">List</span>&lt;Integer&gt;&gt; subsets(<span class="keyword">List</span>&lt;Integer&gt; <span class="keyword">list</span>)&#123;</span><br><span class="line">        <span class="keyword">if</span>(<span class="keyword">list</span>.isEmpty())&#123;</span><br><span class="line">            <span class="comment">//如果输入集合为空，其子集只包含空集</span></span><br><span class="line">            <span class="keyword">List</span>&lt;<span class="keyword">List</span>&lt;Integer&gt;&gt; ans = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">            ans.add(Collections.emptyList());</span><br><span class="line">            <span class="keyword">return</span> ans;</span><br><span class="line">        &#125;</span><br><span class="line">        Integer first = <span class="keyword">list</span>.get(<span class="number">0</span>);</span><br><span class="line">        System.out.println(<span class="string">"first: "</span> + first);</span><br><span class="line">        <span class="keyword">List</span>&lt;Integer&gt; rest = <span class="keyword">list</span>.subList(<span class="number">1</span>, <span class="keyword">list</span>.size());</span><br><span class="line"></span><br><span class="line">        <span class="comment">//否则就取出一个元素first，找出剩余部分的所有子集，并将其赋予subans。subans构成了结果的另一半。</span></span><br><span class="line">        <span class="keyword">List</span>&lt;<span class="keyword">List</span>&lt;Integer&gt;&gt; subans = subsets(rest);</span><br><span class="line">        <span class="comment">//答案的另一半是subans2，它包含了subans中的所有集合，但是经过调整，在每个列表的第一个元素之前添加了first</span></span><br><span class="line">        <span class="keyword">List</span>&lt;<span class="keyword">List</span>&lt;Integer&gt;&gt; subans2 = insertAll(first,subans);</span><br><span class="line">        <span class="comment">//将两个答案整合一起完成任务</span></span><br><span class="line">        <span class="keyword">return</span> concat(subans,subans2);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 将移出元素和当前子集组合</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> first 移出的当前首元素</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> lists 已生成的子集数组</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> 当前子集数组</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">List</span>&lt;<span class="keyword">List</span>&lt;Integer&gt;&gt; insertAll(Integer first,</span><br><span class="line">                                         <span class="keyword">List</span>&lt;<span class="keyword">List</span>&lt;Integer&gt;&gt; lists)&#123;</span><br><span class="line">        <span class="keyword">List</span>&lt;<span class="keyword">List</span>&lt;Integer&gt;&gt; result = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">List</span>&lt;Integer&gt; <span class="keyword">list</span> : lists)&#123;</span><br><span class="line">            <span class="comment">//复制列表，从而使你有机会对其进行添加操作。</span></span><br><span class="line">            <span class="comment">//即使底层是可变的，你也不应该复制底层的结构（不过Integer底层是不可变的）</span></span><br><span class="line">            <span class="keyword">List</span>&lt;Integer&gt; copyList = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">            copyList.add(first);</span><br><span class="line">            copyList.addAll(<span class="keyword">list</span>);</span><br><span class="line">            result.add(copyList);</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(<span class="string">"insertAll: "</span>);</span><br><span class="line">        result.<span class="keyword">forEach</span>(System.out::println);</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 合并子集数组元素</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> a 数组a</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> b 数组b</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> 最终结果</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">List</span>&lt;<span class="keyword">List</span>&lt;Integer&gt;&gt; concat(<span class="keyword">List</span>&lt;<span class="keyword">List</span>&lt;Integer&gt;&gt; a,</span><br><span class="line">                                      <span class="keyword">List</span>&lt;<span class="keyword">List</span>&lt;Integer&gt;&gt; b)&#123;</span><br><span class="line">        <span class="keyword">List</span>&lt;<span class="keyword">List</span>&lt;Integer&gt;&gt; r = <span class="keyword">new</span> ArrayList&lt;&gt;(a);</span><br><span class="line">        r.addAll(b);</span><br><span class="line">        System.out.println(<span class="string">"concat: "</span>);</span><br><span class="line">        r.<span class="keyword">forEach</span>(System.out::println);</span><br><span class="line">        <span class="keyword">return</span> r;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>&emsp;&emsp;运行结果如下。</p><figure class="highlight accesslog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line">first: <span class="number">1</span></span><br><span class="line">first: <span class="number">4</span></span><br><span class="line">first: <span class="number">9</span></span><br><span class="line">insertAll: </span><br><span class="line"><span class="string">[9]</span></span><br><span class="line">concat: </span><br><span class="line"><span class="string">[]</span></span><br><span class="line"><span class="string">[9]</span></span><br><span class="line">insertAll: </span><br><span class="line"><span class="string">[4]</span></span><br><span class="line"><span class="string">[4, 9]</span></span><br><span class="line">concat: </span><br><span class="line"><span class="string">[]</span></span><br><span class="line"><span class="string">[9]</span></span><br><span class="line"><span class="string">[4]</span></span><br><span class="line"><span class="string">[4, 9]</span></span><br><span class="line">insertAll: </span><br><span class="line"><span class="string">[1]</span></span><br><span class="line"><span class="string">[1, 9]</span></span><br><span class="line"><span class="string">[1, 4]</span></span><br><span class="line"><span class="string">[1, 4, 9]</span></span><br><span class="line">concat: </span><br><span class="line"><span class="string">[]</span></span><br><span class="line"><span class="string">[9]</span></span><br><span class="line"><span class="string">[4]</span></span><br><span class="line"><span class="string">[4, 9]</span></span><br><span class="line"><span class="string">[1]</span></span><br><span class="line"><span class="string">[1, 9]</span></span><br><span class="line"><span class="string">[1, 4]</span></span><br><span class="line"><span class="string">[1, 4, 9]</span></span><br></pre></td></tr></table></figure><p>&emsp;&emsp;首先实现insertAll时会有一个坑，如果直接list.add(first)，库函数List.add会修改传递的参数。为了使insertAll函数式的运行，我们利用Integer对象无法修改这一优势，否则需要为每个元素创建一个副本，将复制操作放入insertAll内，而不是调用者中。</p><p>&emsp;&emsp;concat方法的简单实现如下，但为了实现纯粹的函数式我们最终如上实现，虽然会在函数内部对对象进行修改，但<strong>基于参数返回的结果却未修改任意一个参数</strong>。简单实现版本只能基于这样一个条件：参数a不会再被使用，否则就可能会造成影响。</p><figure class="highlight lasso"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">static <span class="built_in">List</span>&lt;<span class="built_in">List</span>&lt;<span class="built_in">Integer</span>&gt;&gt; concat(<span class="built_in">List</span>&lt;<span class="built_in">List</span>&lt;<span class="built_in">Integer</span>&gt;&gt; a,</span><br><span class="line">                                  <span class="built_in">List</span>&lt;<span class="built_in">List</span>&lt;<span class="built_in">Integer</span>&gt;&gt; b)&#123;</span><br><span class="line">    a.addAll(b);</span><br><span class="line">    <span class="keyword">return</span> a;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><h2 id="第四节-递归和迭代"><a href="#第四节-递归和迭代" class="headerlink" title="第四节 递归和迭代"></a><strong>第四节 递归和迭代</strong></h2><p>&emsp;&emsp;纯粹的函数式编程通常不包含while或for这样的迭代构造器，因为这样的构造器通常隐藏着陷阱，诱使我们修改对象。比如while循环的条件状态必须要更新，但很多情况下循环是非常有用的，而我们也可以在不被感知的情况下修改局部变量。我们通常使用的for-each循环可以用迭代器的方式重写。</p><figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span>(Apple a : apples)&#123;</span><br><span class="line">    <span class="built_in">..</span><span class="built_in">..</span><span class="built_in">..</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Iterator&lt;Apple&gt; it = apples.iterator();</span><br><span class="line"><span class="keyword">while</span>(it.hasNext())&#123;</span><br><span class="line">    Apple apple = it.next();</span><br><span class="line">    <span class="built_in">..</span><span class="built_in">..</span><span class="built_in">..</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>&emsp;&emsp;当改变发生时，包括使用next方法对迭代器状态的改变，以及while循环内部对apple变量的赋值，这些对于方法的调用者是不可见的。但如果使用for-each循环，如下搜索算法时会带来问题，因为循环体会对调用方共享的数据结构进行修改。</p><figure class="highlight lasso"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="literal">void</span> searchForGold(<span class="built_in">List</span>&lt;<span class="built_in">String</span>&gt; <span class="built_in">list</span>, Stats stats)&#123;</span><br><span class="line">    fot(<span class="built_in">String</span> s : <span class="built_in">list</span>)&#123;</span><br><span class="line">        <span class="keyword">if</span>(<span class="string">"gold"</span>.<span class="keyword">equals</span>(s))&#123;</span><br><span class="line">            stats.incrementFor(<span class="string">"gold"</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>&emsp;&emsp;对于函数式而言，循环体带来乐一个无法避免的副作用：它会修改stats对象的状态，而这和程序的其他部分是共享的。为了解决这种副作用，正确的方案是用无需修改的递归重写来避免迭代。通过递归可以消除每步都需要更新的迭代变量，如实现一个计算阶乘的函数。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 迭代式阶乘计算</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">int</span> <span class="title">factorialIterative</span><span class="params">(<span class="keyword">int</span> n)</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> r = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>;i &lt;= n;i++)&#123;</span><br><span class="line">        r *= i;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> r;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 递归式阶乘计算</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">long</span> <span class="title">factorialRecursive</span><span class="params">(<span class="keyword">long</span> n)</span></span>&#123;</span><br><span class="line">   <span class="keyword">return</span> n == <span class="number">1</span> ? <span class="number">1</span> : n * factorialRecursive(n<span class="number">-1</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Stream式阶乘计算</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">long</span> <span class="title">factorialStreams</span><span class="params">(<span class="keyword">long</span> n)</span></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> LongStream.rangeClosed(<span class="number">1</span>,n)</span><br><span class="line">            .reduce(<span class="number">1</span>, (<span class="keyword">long</span> a, <span class="keyword">long</span> b) -&gt; a * b);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>&emsp;&emsp;当然我们也可以使用Stream流来实现阶乘计算。递归方式在Java中效率相比迭代会差一些，递归式方法调用的开销会比迭代执行单一机器级的分支指令大很多，因为每次执行factorialRecursive方法调用都需要在调用栈上创建一个新的栈帧，用于保存每个方法调用的状态，这个操作会一直指导程序运行直到结束，意味着递归迭代方法会依据它接收到的输入成比例的消耗内存。</p><p>&emsp;&emsp;函数式语言提供了一个方案来解决这个效率问题：<strong>尾—调优化</strong>（tail-call optimization），基本思想是你可以编写阶乘的一个迭代定义，不过迭代调用会发生在函数的最后，这种新型的迭代调用经过优化后的执行速度会快很多。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 递归式阶乘计算: 尾-调优化</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">long</span> <span class="title">factorialTailRecursive</span><span class="params">(<span class="keyword">long</span> n)</span></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> factorialHelper(<span class="number">1</span>,n);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">long</span> <span class="title">factorialHelper</span><span class="params">(<span class="keyword">long</span> acc, <span class="keyword">long</span> n)</span></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> n == <span class="number">1</span> ? acc : factorialHelper(acc * n, n<span class="number">-1</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>&emsp;&emsp;factorialHelper是尾-递类型的函数，递归调用会发生在方法的最后。factorialRecursive递归会先进行递归，递归结果最后进行运算；而factorialHelper则先运算，将运算结果直接作为参数进行递归。factorialRecursive方法会每次调用创建一个栈帧，而factorialHelper不需要在不同的栈帧上保存每次递归运算的中间值，编译器能够自行决定复用某个栈帧进行计算，阶乘的中间值直接被用作参数传递给此方法，也就不用为每个递归调用分配单独的栈帧用于跟踪每次调用的中间值——通过方法的参数可以直接访问直接值。</p><p><img src="https://pic-1258215793.cos.ap-shanghai.myqcloud.com/content/20191001/201910010106.png" alt="栈帧和尾递阶乘的差异"></p><p>&emsp;&emsp;但Java 8版本时还未能支持这种优化，而一些现代的语言如Scala或Groovy都支持了这种递归优化，最终的效果和迭代不相上下。这意味着坚持纯粹的函数式编程既能享受其好处，也不会损失执行的效率。所以在Java 8时，建议使用Stream代替迭代操作，如果采用递归能够不带来副作用且更容易实现那应该采用递归，毕竟开发的效率往往比执行的细微差异在大多数时候要更重要。</p><hr><p><em>参考博客和文章书籍等：</em></p><blockquote><p>《Java8实战》</p></blockquote><p><em>因博客主等未标明不可引用，若部分内容涉及侵权请及时告知，我会尽快修改和删除相关内容</em></p>]]></content>
    
    <summary type="html">
    
      介绍Java 8中引入的函数式编程，内容包括：第一节 引文，第二节 实现和维护系统（共享的可变数据、声明式编程、为什么要采用函数式编程），第三节 什么是函数式编程（函数式Java编程、引用透明性、面向对象编程和函数式编程的对比、函数式编程实战），第四节 递归和迭代等。
    
    </summary>
    
      <category term="技术文档" scheme="http://linyishui.top/categories/%E6%8A%80%E6%9C%AF%E6%96%87%E6%A1%A3/"/>
    
    
      <category term="java" scheme="http://linyishui.top/tags/java/"/>
    
      <category term="functional" scheme="http://linyishui.top/tags/functional/"/>
    
  </entry>
  
</feed>
