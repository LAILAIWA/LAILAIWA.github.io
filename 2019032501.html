<!DOCTYPE html>
<html lang="zh-CN">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width">
<meta name="theme-color" content="#222">
<meta name="generator" content="Hexo 5.4.0">


  <link rel="apple-touch-icon" sizes="180x180" href="/images/gamepad%20playstation.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/Dig%20Dug.ico">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/gamepad%20playstation.png">
  <link rel="mask-icon" href="/images/gamepad%20playstation.svg" color="#222">

<link rel="stylesheet" href="/css/main.css">

<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Monda:300,300italic,400,400italic,700,700italic%7CMa+Shan+Zheng:300,300italic,400,400italic,700,700italic%7CNoto+Serif+SC:300,300italic,400,400italic,700,700italic&display=swap&subset=latin,latin-ext">

<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free@5.15.3/css/all.min.css" integrity="sha256-2H3fkXt6FEmrReK448mDVGKb3WW2ZZw35gI7vqHOE4Y=" crossorigin="anonymous">
  <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/animate.css@3.1.1/animate.min.css" integrity="sha256-PR7ttpcvz8qrF57fur/yAx1qXMFJeJFiA6pSzWi0OIE=" crossorigin="anonymous">
  <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@3.5.7/dist/jquery.fancybox.min.css" integrity="sha256-Vzbj7sDDS/woiFS3uNKo8eIuni59rjyNGtXfstRzStA=" crossorigin="anonymous">
  <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/nprogress@0.2.0/nprogress.css" integrity="sha256-no0c5ccDODBwp+9hSmV5VvPpKwHCpbVzXHexIkupM6U=" crossorigin="anonymous">
  <script src="https://cdn.jsdelivr.net/npm/nprogress@0.2.0/nprogress.js" integrity="sha256-a5YRB27CcBwBFcT5EF/f3E4vzIqyHrSR878nseNYw64=" crossorigin="anonymous"></script>

<script class="next-config" data-name="main" type="application/json">{"hostname":"linyishui.top","root":"/","images":"/images","scheme":"Pisces","version":"8.6.0","exturl":false,"sidebar":{"position":"left","display":"always","padding":18,"offset":12},"copycode":true,"bookmark":{"enable":true,"color":"#222","save":"manual"},"fancybox":true,"mediumzoom":false,"lazyload":false,"pangu":false,"comments":{"style":"tabs","active":"utterances","storage":true,"lazyload":false,"nav":null,"activeClass":"utterances"},"motion":{"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"fadeInDown","post_body":"fadeInDown","coll_header":"fadeInLeft","sidebar":"fadeInUp"}},"prism":false,"i18n":{"placeholder":"搜索...","empty":"没有找到任何搜索结果：${query}","hits_time":"找到 ${hits} 个搜索结果（用时 ${time} 毫秒）","hits":"找到 ${hits} 个搜索结果"},"path":"/search.xml","localsearch":{"enable":true,"trigger":"auto","top_n_per_article":1,"unescape":false,"preload":false}}</script><script src="/js/config.js"></script>
<meta name="description" content="介绍Java中的IO和NIO相关内容，内容包括：I&#x2F;O模型（同步异步、阻塞与非阻塞、阻塞式IO与非阻塞式IO、同步IO与异步IO、5种IO模型、NIO），NIO（简述、内存映射、流与块的比较、IO与NIO 的区别、缓冲区-Buffer、通道-Channel、选择器-Selector），文件加锁机制，一些源码等。">
<meta property="og:type" content="article">
<meta property="og:title" content="NIO">
<meta property="og:url" content="http://linyishui.top/2019032501.html">
<meta property="og:site_name" content="俺的部落格">
<meta property="og:description" content="介绍Java中的IO和NIO相关内容，内容包括：I&#x2F;O模型（同步异步、阻塞与非阻塞、阻塞式IO与非阻塞式IO、同步IO与异步IO、5种IO模型、NIO），NIO（简述、内存映射、流与块的比较、IO与NIO 的区别、缓冲区-Buffer、通道-Channel、选择器-Selector），文件加锁机制，一些源码等。">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="https://pic-1258215793.cos.ap-shanghai.myqcloud.com/cover/rukam/IMG_20190303_235228.jpg">
<meta property="article:published_time" content="2019-03-25T08:55:34.000Z">
<meta property="article:modified_time" content="2021-08-23T07:48:04.000Z">
<meta property="article:author" content="Lys">
<meta property="article:tag" content="java">
<meta property="article:tag" content="io">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://pic-1258215793.cos.ap-shanghai.myqcloud.com/cover/rukam/IMG_20190303_235228.jpg">


<link rel="canonical" href="http://linyishui.top/2019032501.html">



<script class="next-config" data-name="page" type="application/json">{"sidebar":"","isHome":false,"isPost":true,"lang":"zh-CN","comments":true,"permalink":"http://linyishui.top/2019032501.html","path":"2019032501.html","title":"NIO"}</script>

<script class="next-config" data-name="calendar" type="application/json">""</script>
<title>NIO | 俺的部落格</title>
  




  <noscript>
    <link rel="stylesheet" href="/css/noscript.css">
  </noscript>
<link rel="alternate" href="/atom.xml" title="俺的部落格" type="application/atom+xml">
<style>.darkmode--activated{--body-bg-color:#282828;--content-bg-color:#333;--card-bg-color:#555;--text-color:#ccc;--blockquote-color:#bbb;--link-color:#ccc;--link-hover-color:#eee;--brand-color:#ddd;--brand-hover-color:#ddd;--table-row-odd-bg-color:#282828;--table-row-hover-bg-color:#363636;--menu-item-bg-color:#555;--btn-default-bg:#222;--btn-default-color:#ccc;--btn-default-border-color:#555;--btn-default-hover-bg:#666;--btn-default-hover-color:#ccc;--btn-default-hover-border-color:#666;--highlight-background:#282b2e;--highlight-foreground:#a9b7c6;--highlight-gutter-background:#34393d;--highlight-gutter-foreground:#9ca9b6}.darkmode--activated img{opacity:.75}.darkmode--activated img:hover{opacity:.9}.darkmode--activated code{color:#69dbdc;background:0 0}button.darkmode-toggle{z-index:9999}</style></head>

<body itemscope itemtype="http://schema.org/WebPage" class="use-motion">
  <div class="headband"></div>

  <main class="main">
    <header class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="切换导航栏" role="button">
        <span class="toggle-line"></span>
        <span class="toggle-line"></span>
        <span class="toggle-line"></span>
    </div>
  </div>

  <div class="site-meta">

    <a href="/" class="brand" rel="start">
      <i class="logo-line"></i>
      <h1 class="site-title">俺的部落格</h1>
      <i class="logo-line"></i>
    </a>
      <p class="site-subtitle" itemprop="description">俺寻思俺需要记点东西</p>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger">
        <i class="fa fa-search fa-fw fa-lg"></i>
    </div>
  </div>
</div>



<nav class="site-nav">
  <ul class="main-menu menu">
        <li class="menu-item menu-item-home"><a href="/" rel="section"><i class="fa fa-home fa-fw"></i>首页</a></li>
        <li class="menu-item menu-item-about"><a href="/about/" rel="section"><i class="fa fa-user fa-fw"></i>关于</a></li>
        <li class="menu-item menu-item-tags"><a href="/tags/" rel="section"><i class="fa fa-tags fa-fw"></i>标签</a></li>
        <li class="menu-item menu-item-categories"><a href="/categories/" rel="section"><i class="fa fa-th fa-fw"></i>分类</a></li>
        <li class="menu-item menu-item-archives"><a href="/archives/" rel="section"><i class="fa fa-archive fa-fw"></i>归档</a></li>
        <li class="menu-item menu-item-sitemap"><a href="/sitemap.xml" rel="section"><i class="fa fa-sitemap fa-fw"></i>站点地图</a></li>
        <li class="menu-item menu-item-tools"><a href="/links/" rel="section"><i class="fa fa-link fa-fw"></i>工具</a></li>
        <li class="menu-item menu-item-books"><a href="/books/" rel="section"><i class="fa fa-book fa-fw"></i>书架</a></li>
        <li class="menu-item menu-item-movies"><a href="/movies/" rel="section"><i class="fa fa-video fa-fw"></i>剧院</a></li>
        <li class="menu-item menu-item-games"><a href="/games/" rel="section"><i class="fa fa-gamepad fa-fw"></i>游戏</a></li>
        <li class="menu-item menu-item-commonweal"><a href="/404/" rel="section"><i class="fa fa-heartbeat fa-fw"></i>公益</a></li>
      <li class="menu-item menu-item-search">
        <a role="button" class="popup-trigger"><i class="fa fa-search fa-fw"></i>搜索
        </a>
      </li>
  </ul>
</nav>



  <div class="search-pop-overlay">
    <div class="popup search-popup"><div class="search-header">
  <span class="search-icon">
    <i class="fa fa-search"></i>
  </span>
  <div class="search-input-container">
    <input autocomplete="off" autocapitalize="off" maxlength="80"
           placeholder="搜索..." spellcheck="false"
           type="search" class="search-input">
  </div>
  <span class="popup-btn-close" role="button">
    <i class="fa fa-times-circle"></i>
  </span>
</div>
<div class="search-result-container no-result">
  <div class="search-result-icon">
    <i class="fa fa-spinner fa-pulse fa-5x"></i>
  </div>
</div>

    </div>
  </div>

</div>
        
  
  <div class="toggle sidebar-toggle" role="button">
    <span class="toggle-line"></span>
    <span class="toggle-line"></span>
    <span class="toggle-line"></span>
  </div>

  <aside class="sidebar">

    <div class="sidebar-inner sidebar-nav-active sidebar-toc-active">
      <ul class="sidebar-nav">
        <li class="sidebar-nav-toc">
          文章目录
        </li>
        <li class="sidebar-nav-overview">
          站点概览
        </li>
      </ul>

      <div class="sidebar-panel-container">
        <!--noindex-->
        <div class="post-toc-wrap sidebar-panel">
            <div class="post-toc animated"><ol class="nav"><li class="nav-item nav-level-1"><a class="nav-link" href="#NIO"><span class="nav-text">NIO</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#%E4%B8%80-I-O%E6%A8%A1%E5%9E%8B"><span class="nav-text">一. I&#x2F;O模型</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#1-1-%E5%90%8C%E6%AD%A5%E5%BC%82%E6%AD%A5"><span class="nav-text">1.1 同步异步</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#1-2-%E9%98%BB%E5%A1%9E%E4%B8%8E%E9%9D%9E%E9%98%BB%E5%A1%9E"><span class="nav-text">1.2 阻塞与非阻塞</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#1-3-%E9%98%BB%E5%A1%9E%E5%BC%8FIO%E4%B8%8E%E9%9D%9E%E9%98%BB%E5%A1%9E%E5%BC%8FIO"><span class="nav-text">1.3 阻塞式IO与非阻塞式IO</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#1-4-%E5%90%8C%E6%AD%A5IO%E4%B8%8E%E5%BC%82%E6%AD%A5IO"><span class="nav-text">1.4 同步IO与异步IO</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#1-5-5%E7%A7%8DIO%E6%A8%A1%E5%9E%8B"><span class="nav-text">1.5 5种IO模型</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#1-5-1-%E5%AE%8C%E5%85%A8%E9%98%BB%E5%A1%9E%E6%A8%A1%E5%9E%8B-BIO%EF%BC%8CBlocking-I-O"><span class="nav-text">1.5.1 完全阻塞模型(BIO，Blocking I&#x2F;O)</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#1-5-2-%E9%9D%9E%E9%98%BB%E5%A1%9EI-O%E6%A8%A1%E5%9E%8B"><span class="nav-text">1.5.2 非阻塞I&#x2F;O模型</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#1-5-3-I-O%E5%A4%9A%E8%B7%AF%E5%A4%8D%E7%94%A8%E6%A8%A1%E5%9E%8B"><span class="nav-text">1.5.3 I&#x2F;O多路复用模型</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#1-5-4-%E4%BF%A1%E5%8F%B7%E9%A9%B1%E5%8A%A8%E6%A8%A1%E5%9E%8BSIGIO"><span class="nav-text">1.5.4 信号驱动模型SIGIO**</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#1-5-5-%E5%BC%82%E6%AD%A5I-0%E6%A8%A1%E5%9E%8BASYNC-IO"><span class="nav-text">1.5.5 异步I&#x2F;0模型ASYNC IO**</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#1-6-NIO"><span class="nav-text">1.6 NIO**</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E7%AC%AC%E4%BA%8C%E8%8A%82-NIO"><span class="nav-text">第二节 NIO**</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#2-1-%E7%AE%80%E8%BF%B0"><span class="nav-text">2.1 简述**</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#2-2-%E5%86%85%E5%AD%98%E6%98%A0%E5%B0%84"><span class="nav-text">2.2 内存映射**</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#2-3-%E6%B5%81%E4%B8%8E%E5%9D%97%E7%9A%84%E6%AF%94%E8%BE%83"><span class="nav-text">2.3 流与块的比较**</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#2-4-IO-%E4%B8%8E-NIO-%E7%9A%84%E5%8C%BA%E5%88%AB"><span class="nav-text">2.4 IO 与 NIO 的区别**</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#2-4-1-%E9%9D%A2%E5%90%91%E6%B5%81%E5%92%8C%E9%9D%A2%E5%90%91%E7%BC%93%E5%86%B2"><span class="nav-text">2.4.1 面向流和面向缓冲**</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#2-4-2-%E9%98%BB%E5%A1%9EIO%E4%B8%8E%E9%9D%9E%E9%98%BB%E5%A1%9EIO"><span class="nav-text">2.4.2 阻塞IO与非阻塞IO**</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#2-4-3-%E9%80%89%E6%8B%A9%E5%99%A8"><span class="nav-text">2.4.3 选择器**</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#2-5-%E7%BC%93%E5%86%B2%E5%8C%BA-Buffer"><span class="nav-text">2.5 缓冲区-Buffer**</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#2-5-1-%E6%A6%82%E8%BF%B0"><span class="nav-text">2.5.1 概述**</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#2-5-2-%E7%B1%BB%E7%BB%93%E6%9E%84%E5%92%8CAPI"><span class="nav-text">2.5.2 类结构和API**</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#2-5-3-%E4%BD%BF%E7%94%A8%E6%A1%88%E4%BE%8B"><span class="nav-text">2.5.3 使用案例**</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#2-5-4-%E7%BC%93%E5%86%B2%E5%8C%BA%E5%88%86%E7%89%87"><span class="nav-text">2.5.4 缓冲区分片**</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#2-5-5-%E5%8F%AA%E8%AF%BB%E7%BC%93%E5%86%B2%E5%8C%BA"><span class="nav-text">2.5.5 只读缓冲区**</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#2-5-6-%E7%8A%B6%E6%80%81%E5%8F%98%E5%8C%96"><span class="nav-text">2.5.6 状态变化**</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#2-5-7-%E5%AD%97%E8%8A%82%E7%BC%93%E5%86%B2%E5%8C%BA"><span class="nav-text">2.5.7 字节缓冲区**</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#2-6-%E9%80%9A%E9%81%93-Channel"><span class="nav-text">2.6 通道-Channel**</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#2-6-1-%E6%A6%82%E8%BF%B0"><span class="nav-text">2.6.1 概述**</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#2-6-2-%E7%B1%BB%E7%BB%93%E6%9E%84"><span class="nav-text">2.6.2 类结构**</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#2-6-3-%E6%96%87%E4%BB%B6%E9%80%9A%E9%81%93"><span class="nav-text">2.6.3 文件通道**</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#2-6-4-NIO%E6%A1%88%E4%BE%8B"><span class="nav-text">2.6.4 NIO案例**</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#1-%E4%BD%BF%E7%94%A8NIO%E8%AF%BB%E5%8F%96%E6%95%B0%E6%8D%AE"><span class="nav-text">(1) 使用NIO读取数据**</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#2-%E4%BD%BF%E7%94%A8NIO%E5%86%99%E5%85%A5%E6%95%B0%E6%8D%AE"><span class="nav-text">(2) 使用NIO写入数据**</span></a></li></ol></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#2-7-%E9%80%89%E6%8B%A9%E5%99%A8-Selector"><span class="nav-text">2.7 选择器-Selector**</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#2-7-1-%E6%A6%82%E8%BF%B0"><span class="nav-text">2.7.1 概述**</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#2-7-2-%E4%BD%BF%E7%94%A8%E7%A4%BA%E4%BE%8B"><span class="nav-text">2.7.2 使用示例**</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#2-7-3-%E5%A6%82%E4%BD%95%E7%BB%93%E5%90%88%E4%BA%8B%E4%BB%B6%E6%A8%A1%E5%9E%8B%E4%BD%BF%E7%94%A8NIO%E5%90%8C%E6%AD%A5%E9%9D%9E%E9%98%BB%E5%A1%9E%E7%89%B9%E6%80%A7"><span class="nav-text">2.7.3 如何结合事件模型使用NIO同步非阻塞特性**</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#2-7-4-%E4%BC%98%E5%8C%96%E7%BA%BF%E7%A8%8B%E6%A8%A1%E5%9E%8B"><span class="nav-text">2.7.4 优化线程模型**</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#2-7-5-%E6%AF%8F%E8%BF%9E%E6%8E%A5%E9%A1%BA%E5%BA%8F%E8%AF%B7%E6%B1%82%E7%9A%84Redis"><span class="nav-text">2.7.5 每连接顺序请求的Redis**</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#2-7-6-%E5%A4%9A%E8%BF%9E%E6%8E%A5%E7%9F%AD%E8%BF%9E%E6%8E%A5%E7%9A%84HttpClient"><span class="nav-text">2.7.6 多连接短连接的HttpClient**</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#2-7-7-%E5%B8%B8%E8%A7%81%E7%9A%84RPC%E6%A1%86%E6%9E%B6%EF%BC%8C%E5%A6%82Thrift%EF%BC%8CDubbo"><span class="nav-text">2.7.7 常见的RPC框架，如Thrift，Dubbo**</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#2-7-8-Proactor%E4%B8%8EReactor"><span class="nav-text">2.7.8 Proactor与Reactor**</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#2-7-9-Selector-wakeup"><span class="nav-text">2.7.9 Selector.wakeup()**</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#2-7-10-Buffer%E7%9A%84%E9%80%89%E6%8B%A9"><span class="nav-text">2.7.10 Buffer的选择**</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#2-7-11-%E6%BA%90%E7%A0%81"><span class="nav-text">2.7.11 源码**</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#2-7-12-%E6%A1%88%E4%BE%8B"><span class="nav-text">2.7.12 案例**</span></a></li></ol></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E7%AC%AC%E4%B8%89%E8%8A%82-%E6%96%87%E4%BB%B6%E5%8A%A0%E9%94%81%E6%9C%BA%E5%88%B6"><span class="nav-text">第三节 文件加锁机制**</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E7%AC%AC%E5%9B%9B%E8%8A%82-%E4%B8%80%E4%BA%9B%E6%BA%90%E7%A0%81"><span class="nav-text">第四节 一些源码**</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%BA%90%E7%A0%81-FileChannel"><span class="nav-text">源码-FileChannel**</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%BA%90%E7%A0%81-SocketChannel"><span class="nav-text">源码-SocketChannel**</span></a></li></ol></li></ol></li></ol></div>
        </div>
        <!--/noindex-->

        <div class="site-overview-wrap sidebar-panel">
          <div class="site-overview">
            <div class="site-author site-overview-item animated" itemprop="author" itemscope itemtype="http://schema.org/Person">
    <img class="site-author-image" itemprop="image" alt="Lys"
      src="https://pic-1258215793.cos.ap-shanghai.myqcloud.com/cover/IMG_0759.JPG">
  <p class="site-author-name" itemprop="name">Lys</p>
  <div class="site-description" itemprop="description">记录编程点滴，写点生活中的酸甜</div>
</div>
<div class="site-state-wrap site-overview-item animated">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
          <a href="/archives/">
        
          <span class="site-state-item-count">324</span>
          <span class="site-state-item-name">日志</span>
        </a>
      </div>
      <div class="site-state-item site-state-categories">
            <a href="/categories/">
          
        <span class="site-state-item-count">11</span>
        <span class="site-state-item-name">分类</span></a>
      </div>
      <div class="site-state-item site-state-tags">
            <a href="/tags/">
          
        <span class="site-state-item-count">109</span>
        <span class="site-state-item-name">标签</span></a>
      </div>
  </nav>
</div>
  <div class="links-of-author site-overview-item animated">
      <span class="links-of-author-item">
        <a href="https://github.com/LAILAIWA" title="GitHub → https:&#x2F;&#x2F;github.com&#x2F;LAILAIWA" rel="noopener" target="_blank"><i class="fab fa-github fa-fw"></i>GitHub</a>
      </span>
      <span class="links-of-author-item">
        <a href="mailto:linyishui168@outlook.com" title="E-Mail → mailto:linyishui168@outlook.com" rel="noopener" target="_blank"><i class="fa fa-envelope fa-fw"></i>E-Mail</a>
      </span>
      <span class="links-of-author-item">
        <a href="https://weibo.com/u/5340162234" title="Weibo → https:&#x2F;&#x2F;weibo.com&#x2F;u&#x2F;5340162234" rel="noopener" target="_blank"><i class="fab fa-weibo fa-fw"></i>Weibo</a>
      </span>
      <span class="links-of-author-item">
        <a href="https://twitter.com/linyishui618" title="Twitter → https:&#x2F;&#x2F;twitter.com&#x2F;linyishui618" rel="noopener" target="_blank"><i class="fab fa-twitter fa-fw"></i>Twitter</a>
      </span>
      <span class="links-of-author-item">
        <a href="https://stackoverflow.com/users/13018339/lin-yishui" title="StackOverflow → https:&#x2F;&#x2F;stackoverflow.com&#x2F;users&#x2F;13018339&#x2F;lin-yishui" rel="noopener" target="_blank"><i class="fab fa-stack-overflow fa-fw"></i>StackOverflow</a>
      </span>
      <span class="links-of-author-item">
        <a href="https://instagram.com/linyishui618" title="Instagram → https:&#x2F;&#x2F;instagram.com&#x2F;linyishui618" rel="noopener" target="_blank"><i class="fab fa-instagram fa-fw"></i>Instagram</a>
      </span>
  </div>
  <div class="cc-license site-overview-item animated" itemprop="license">
    <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/deed.zh" class="cc-opacity" rel="noopener" target="_blank"><img src="https://cdn.jsdelivr.net/npm/@creativecommons/vocabulary@2020.11.3/assets/license_badges/small/by_nc_sa.svg" alt="Creative Commons"></a>
  </div>


  <div class="links-of-blogroll site-overview-item animated">
    <div class="links-of-blogroll-title"><i class="far fa-smile-wink fa-fw"></i>
      个人
    </div>
    <ul class="links-of-blogroll-list">
        <li class="links-of-blogroll-item">
          <a href="https://music.163.com/#/user/home?id=68425607" title="https:&#x2F;&#x2F;music.163.com&#x2F;#&#x2F;user&#x2F;home?id&#x3D;68425607" rel="noopener" target="_blank">网易云音乐</a>
        </li>
    </ul>
  </div>

          </div>
        </div>
    </div>
  </aside>
  <div class="sidebar-dimmer"></div>


    </header>

    
  <div class="back-to-top" role="button" aria-label="返回顶部">
    <i class="fa fa-arrow-up"></i>
    <span>0%</span>
  </div>
  <a role="button" class="book-mark-link book-mark-link-fixed"></a>

  <a href="https://github.com/LAILAIWA" class="github-corner" title="Follow me on GitHub" aria-label="Follow me on GitHub" rel="noopener" target="_blank"><svg width="80" height="80" viewBox="0 0 250 250" aria-hidden="true"><path d="M0,0 L115,115 L130,115 L142,142 L250,250 L250,0 Z"></path><path d="M128.3,109.0 C113.8,99.7 119.0,89.6 119.0,89.6 C122.0,82.7 120.5,78.6 120.5,78.6 C119.2,72.0 123.4,76.3 123.4,76.3 C127.3,80.9 125.5,87.3 125.5,87.3 C122.9,97.6 130.6,101.9 134.4,103.2" fill="currentColor" style="transform-origin: 130px 106px;" class="octo-arm"></path><path d="M115.0,115.0 C114.9,115.1 118.7,116.5 119.8,115.4 L133.7,101.6 C136.9,99.2 139.9,98.4 142.2,98.6 C133.8,88.0 127.5,74.4 143.8,58.0 C148.5,53.4 154.0,51.2 159.7,51.0 C160.3,49.4 163.2,43.6 171.4,40.1 C171.4,40.1 176.1,42.5 178.8,56.2 C183.1,58.6 187.2,61.8 190.9,65.4 C194.5,69.0 197.7,73.2 200.1,77.6 C213.8,80.2 216.3,84.9 216.3,84.9 C212.7,93.1 206.9,96.0 205.4,96.6 C205.1,102.4 203.0,107.8 198.3,112.5 C181.9,128.9 168.3,122.5 157.7,114.1 C157.9,116.9 156.7,120.9 152.7,124.9 L141.0,136.5 C139.8,137.7 141.6,141.9 141.8,141.8 Z" fill="currentColor" class="octo-body"></path></svg></a>

<noscript>
  <div class="noscript-warning">Theme NexT works best with JavaScript enabled</div>
</noscript>


    <div class="main-inner post posts-expand">


  


<div class="post-block">
  
  <div class="post-gallery" itemscope itemtype="http://schema.org/ImageGallery">
    
    <div class="post-gallery-image">
      <img src="https://pic-1258215793.cos.ap-shanghai.myqcloud.com/cover/rukam/IMG_20190303_235228.jpg" itemprop="contentUrl">
    </div>
    </div>

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://linyishui.top/2019032501.html">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="https://pic-1258215793.cos.ap-shanghai.myqcloud.com/cover/IMG_0759.JPG">
      <meta itemprop="name" content="Lys">
      <meta itemprop="description" content="记录编程点滴，写点生活中的酸甜">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="俺的部落格">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          NIO
        </h1>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>

      <time title="创建时间：2019-03-25 16:55:34" itemprop="dateCreated datePublished" datetime="2019-03-25T16:55:34+08:00">2019-03-25</time>
    </span>
      <span class="post-meta-item">
        <span class="post-meta-item-icon">
          <i class="far fa-calendar-check"></i>
        </span>
        <span class="post-meta-item-text">更新于</span>
        <time title="修改时间：2021-08-23 15:48:04" itemprop="dateModified" datetime="2021-08-23T15:48:04+08:00">2021-08-23</time>
      </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">分类于</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/%E6%8A%80%E6%9C%AF%E6%96%87%E6%A1%A3/" itemprop="url" rel="index"><span itemprop="name">技术文档</span></a>
        </span>
    </span>

  
      </div>
      <div class="post-meta">
    <span class="post-meta-item" title="本文字数">
      <span class="post-meta-item-icon">
        <i class="far fa-file-word"></i>
      </span>
      <span class="post-meta-item-text">本文字数：</span>
      <span>40k</span>
    </span>
    <span class="post-meta-item" title="阅读时长">
      <span class="post-meta-item-icon">
        <i class="far fa-clock"></i>
      </span>
      <span class="post-meta-item-text">阅读时长 &asymp;</span>
      <span>37 分钟</span>
    </span>
</div>

            <div class="post-description">介绍Java中的IO和NIO相关内容，内容包括：I/O模型（同步异步、阻塞与非阻塞、阻塞式IO与非阻塞式IO、同步IO与异步IO、5种IO模型、NIO），NIO（简述、内存映射、流与块的比较、IO与NIO 的区别、缓冲区-Buffer、通道-Channel、选择器-Selector），文件加锁机制，一些源码等。</div>
        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
        <h1 id="NIO"><a href="#NIO" class="headerlink" title="NIO"></a>NIO</h1><h2 id="一-I-O模型"><a href="#一-I-O模型" class="headerlink" title="一. I/O模型"></a>一. I/O模型</h2><h3 id="1-1-同步异步"><a href="#1-1-同步异步" class="headerlink" title="1.1 同步异步"></a>1.1 同步异步</h3><p>理解这些概念要结合相应的语境，一般主要在<strong>进程通信</strong>或<strong>I/O系统调用</strong>方面讨论这些概念。</p>
<p><strong>进程通信</strong>：进程间通信由 <code>send()</code> 和 <code>receive()</code> 两种动作完成，消息的传递可能是<strong>阻塞</strong>或<strong>非阻塞</strong>的，也可以叫做<strong>同步</strong>或<strong>异步</strong>的，<strong>此处二者指相同概念</strong>。可以根据和发送或接收的组合分为以下四种方式。</p>
<p>简单的说，同步指过程中各个任务逐个执行，需要等待，异步则是过程中任务可以并发执行，无需等待。</p>
<h3 id="1-2-阻塞与非阻塞"><a href="#1-2-阻塞与非阻塞" class="headerlink" title="1.2 阻塞与非阻塞"></a>1.2 阻塞与非阻塞</h3><ul>
<li>阻塞式发送（blocking send）：发送方进程会被一直阻塞， 直到消息被接受方进程收到。</li>
<li>非阻塞式发送（nonblocking send）： 发送方进程调用 <code>send()</code> 后， 立即就可以其他操作。</li>
<li>阻塞式接收（blocking receive）：接收方调用 <code>receive()</code> 后一直阻塞， 直到消息到达可用。</li>
<li>非阻塞式接受（nonblocking receive）： 接收方调用 <code>receive()</code> 函数后， 要么得到一个有效的结果，要么得到一个空值， 即不会被阻塞。</li>
</ul>
<p><strong>阻塞</strong>是指进程在发起一个<strong>系统调用</strong>（System Call）后，等待调用操作完成时，内核将进程挂起为<strong>等待</strong>（waiting）状态，以确保它此时不会被调度执行。</p>
<h3 id="1-3-阻塞式IO与非阻塞式IO"><a href="#1-3-阻塞式IO与非阻塞式IO" class="headerlink" title="1.3 阻塞式IO与非阻塞式IO"></a>1.3 阻塞式IO与非阻塞式IO</h3><p><strong>I/O系统调用</strong>（I/O System Call）：阻塞与系统调用紧密相关，现代计算机中物理通信操作通常是异步的，而操作系统则默认提供<strong>阻塞式的I/O系统调用</strong>接口（blocking systemcall），这样使应用代码编写更简单（代码执行顺序与编写顺序一致）。当然也会提供<strong>非阻塞式的I/O系统调用</strong>接口（nonblocking systemcall），不会挂起程序，而是立刻返回一个值。</p>
<p><strong>非阻塞系统调用</strong>（non-blocking I/O system call 与 asynchronous I/O system call） 的存在可以用来实现线程级别的 I/O 并发， 与通过多进程实现的 I/O 并发相比可以减少内存消耗以及进程切换的开销。</p>
<p>Java中常见的IO都是阻塞式IO，如通过Socket来读取数据，调用 <code>read()</code> 方法后，若数据未准备就绪，当前线程就会一直阻塞，直到有数据返回。而如果是非阻塞式IO，则会立即返回，告知当前线程数据未准备就绪。</p>
<h3 id="1-4-同步IO与异步IO"><a href="#1-4-同步IO与异步IO" class="headerlink" title="1.4 同步IO与异步IO"></a>1.4 同步IO与异步IO</h3><p>事实上，同步IO和异步IO模型是针对用户线程和内核的交互来说的：</p>
<ul>
<li><p><strong>同步IO</strong>：当用户发出IO请求操作之后，如果数据没有就绪，需要通过用户线程或者内核不断地去轮询数据是否就绪，当数据就绪时，再将数据从内核拷贝到用户线程；</p>
</li>
<li><p><strong>异步IO</strong>：只有IO请求操作的发出是由用户线程来进行的，IO操作的两个阶段都是由内核自动完成，然后发送通知告知用户线程IO操作已经完成。也就是说在异步IO中，不会对用户线程产生任何阻塞。</p>
</li>
</ul>
<p>这是同步IO和异步IO关键区别所在，同步IO和异步IO的关键区别反映在数据拷贝阶段是由用户线程完成还是内核完成。所以说异步IO必须要有操作系统的底层支持。</p>
<p><strong>异步I/O系统调用</strong>与<strong>非阻塞式的I/O系统调用</strong>类似，不会等待I/O操作完成，应用程序可以继续执行其他操作，待I/O完成时操作系统通知调用进程。二者的区别是<strong>非阻塞</strong>会立即返回数据（无论数据是否完整），而<strong>异步</strong>则要求结果是完整的，允许延迟获取。</p>
<h3 id="1-5-5种IO模型"><a href="#1-5-5种IO模型" class="headerlink" title="1.5 5种IO模型"></a>1.5 5种IO模型</h3><p>常见的5种IO模型包括：阻塞I/O、非阻塞IO、多路复用IO、信号驱动IO、异步IO。</p>
<p><img src="https://pic-1258215793.cos.ap-shanghai.myqcloud.com/content/20200501/202005010137.jpg"></p>
<p>一个完整的I/O操作包括两个阶段：</p>
<ol>
<li><strong>查看数据是否就绪；</strong></li>
<li><strong>进行数据拷贝（内核将数据拷贝到用户线程）。</strong></li>
</ol>
<p>需要说明的是等待就绪的阻塞是不使用CPU的，是在“空等”；而真正的读写操作的阻塞是使用CPU的，真正在”干活”，而且这个过程非常快，属于memory copy，带宽通常在1GB/s级别以上，可以理解为基本不耗时。</p>
<h4 id="1-5-1-完全阻塞模型-BIO，Blocking-I-O"><a href="#1-5-1-完全阻塞模型-BIO，Blocking-I-O" class="headerlink" title="1.5.1 完全阻塞模型(BIO，Blocking I/O)"></a>1.5.1 完全阻塞模型(BIO，Blocking I/O)</h4><p>读写过程都是阻塞式的，直到收到结果前一直处于阻塞状态。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">data = socket.read(); </span><br></pre></td></tr></table></figure>



<h4 id="1-5-2-非阻塞I-O模型"><a href="#1-5-2-非阻塞I-O模型" class="headerlink" title="1.5.2 非阻塞I/O模型"></a>1.5.2 非阻塞I/O模型</h4><p>当请求的I/O操作无法完成时，返回一个错误信息，进程仍然工作进行轮询直到操作完成。也就是说任务仍在继续进行，CPU也还在计算。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">while</span>(<span class="keyword">true</span>)&#123; </span><br><span class="line">   	data = socket.read(); <span class="comment">// 不断轮询</span></span><br><span class="line">   	<span class="keyword">if</span>(data != error)&#123; </span><br><span class="line">       	<span class="comment">// 处理数据 </span></span><br><span class="line">       	<span class="keyword">break</span>; </span><br><span class="line">   	&#125; </span><br><span class="line">&#125; </span><br></pre></td></tr></table></figure>



<p>非阻塞式IO这种持续循环的方式很容易导致CPU占用率过高，所以很少被采用。</p>
<h4 id="1-5-3-I-O多路复用模型"><a href="#1-5-3-I-O多路复用模型" class="headerlink" title="1.5.3 I/O多路复用模型"></a>1.5.3 I/O多路复用模型</h4><p>请求I/O操作无法完成，线程阻塞，但进程会同时检测多个资源，直到有资源可用。多路复用IO被使用的场合很多，Java NIO本身就是多路复用IO。</p>
<p>在多路复用IO模型中，会<strong>有一个线程不断去轮询多个socket的状态</strong>，只有当socket真正有读写事件时，才真正调用实际的IO读写操作。因为在多路复用IO模型中，只需要使用一个线程就可以管理多个socket，系统不需要建立新的进程或者线程，也不必维护这些线程和进程，并且<strong>只有在真正有socket读写事件进行时</strong>，<strong>才会使用IO资源</strong>，所以它大大减少了资源占用。</p>
<p>在Java NIO中，是通过 <code>selector.select()</code> 去查询每个通道是否有到达事件，如果没有事件，则一直阻塞在那里，因此这种方式会导致用户线程的阻塞。</p>
<p>也许有朋友会说，我可以采用 <code>多线程</code> + <code>阻塞IO</code> 达到类似的效果，但是由于在 <code>多线程</code> + <code>阻塞IO</code> 中，每个socket对应一个线程，这样会造成很大的资源占用，并且尤其是对于长连接来说，线程的资源一直不会释放，如果后面陆续有很多连接的话，就会造成性能上的瓶颈。</p>
<p>而多路复用IO模式，通过一个线程就可以管理多个socket，只有当socket真正有读写事件发生才会占用资源来进行实际的读写操作。因此，多路复用IO比较适合连接数比较多的情况。</p>
<p>另外多路复用IO为何比非阻塞IO模型的效率高是因为在非阻塞IO中，<strong>不断地询问socket状态是通过用户线程去进行的</strong>，而在多路复用IO中，<strong>轮询每个socket状态是内核在进行的</strong>，这个效率要比用户线程要高的多。</p>
<p>不过要注意的是，多路复用IO模型是通过<strong>轮询</strong>的方式来检测是否有事件到达，并且对到达的事件逐一进行响应。因此对于多路复用IO模型来说，一旦事件响应体很大，那么就会导致后续的事件迟迟得不到处理，并且会影响新的事件轮询。</p>
<h4 id="1-5-4-信号驱动模型SIGIO"><a href="#1-5-4-信号驱动模型SIGIO" class="headerlink" title="1.5.4 信号驱动模型SIGIO**"></a>1.5.4 信号驱动模型SIGIO**</h4><p><code>SIGIO</code> 和 <code>多路复用I/O</code> 的区别就在于 <code>多路复用I/O</code> <strong>会阻塞应用程序</strong>，<code>SIGIO</code> <strong>则不会</strong>。请求I/O操作失败，返回一个信号处理器，线程继续运行，待资源释放时，线程在信号处理器处理收到信号，并通知系统可以读取数据。</p>
<p>在信号驱动IO模型中，当用户线程发起一个IO请求操作，会给对应的socket注册一个信号函数，然后用户线程会继续执行，当内核数据就绪时会发送一个信号给用户线程，用户线程接收到信号之后，便在信号函数中调用IO读写操作来进行实际的IO请求操作。</p>
<h4 id="1-5-5-异步I-0模型ASYNC-IO"><a href="#1-5-5-异步I-0模型ASYNC-IO" class="headerlink" title="1.5.5 异步I/0模型ASYNC IO**"></a>1.5.5 异步I/0模型ASYNC IO**</h4><p>请求I/O操作失败，进程不会阻塞，直接返回，等到数据操作结束，告知进程I/O操作已完成。</p>
<p>异步IO模型才是最理想的IO模型，在异步IO模型中，当用户线程发起read操作之后，立刻就可以开始去做其它的事。而另一方面，从内核的角度，当它收到一个asynchronous read之后，它会立刻返回，说明read请求已经成功发起了，因此不会对用户线程产生任何block。然后，内核会等待数据准备完成，然后将数据拷贝到用户线程，当这一切都完成之后，内核会给用户线程发送一个信号，告诉它read操作完成了。也就说用户线程完全不需要知道实际的整个IO操作是如何进行的，只需要先发起一个请求，当接收内核返回的成功信号时表示IO操作已经完成，可以直接去使用数据了。</p>
<p>也就说<strong>在异步IO模型中</strong>，<strong>IO操作的两个阶段都不会阻塞用户线程</strong>，这两个阶段都是由内核自动完成，然后发送一个信号告知用户线程操作已完成。用户线程中不需要再次调用IO函数进行具体的读写。这点是和信号驱动模型有所不同的，<strong>在信号驱动模型中，当用户线程接收到信号表示数据已经就绪，然后需要用户线程调用IO函数进行实际的读写操作</strong>；<strong>而在异步IO模型中，收到信号表示IO操作已经完成，不需要再在用户线程中调用iO函数进行实际的读写操作</strong>。</p>
<p>注意，<strong>异步IO是需要操作系统的底层支持</strong>，<strong>在Java 7中，提供了Asynchronous IO</strong>。</p>
<p><strong>前面四种IO模型实际上都属于同步IO，只有最后一种是真正的异步IO</strong>，因为无论是多路复用IO还是信号驱动模型，IO操作的第2个阶段都会引起用户线程阻塞，也就是内核进行数据拷贝的过程都会让用户线程阻塞。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">	ExecutorService executor = Excutors.newFixedThreadPollExecutor(<span class="number">100</span>);<span class="comment">//线程池</span></span><br><span class="line">    ServerSocket serverSocket = <span class="keyword">new</span> ServerSocket();</span><br><span class="line">    serverSocket.bind(<span class="number">8088</span>);</span><br><span class="line">    <span class="keyword">while</span>(!Thread.currentThread.isInturrupted())&#123;<span class="comment">//主线程死循环等待新连接到来</span></span><br><span class="line">        Socket socket = serverSocket.accept();</span><br><span class="line">        executor.submit(<span class="keyword">new</span> ConnectIOnHandler(socket));<span class="comment">//为新的连接创建新的线程</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ConnectIOnHandler</span> <span class="keyword">extends</span> <span class="title">Thread</span></span>&#123;</span><br><span class="line">    <span class="keyword">private</span> Socket socket;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">ConnectIOnHandler</span><span class="params">(Socket socket)</span></span>&#123;</span><br><span class="line">       <span class="keyword">this</span>.socket = socket;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">while</span>(!Thread.currentThread.isInturrupted()&amp;&amp;!socket.isClosed()) &#123;<span class="comment">//死循环处理读写事件</span></span><br><span class="line">            String someThing = socket.read()....<span class="comment">//读取数据</span></span><br><span class="line">            <span class="keyword">if</span>(someThing!=<span class="keyword">null</span>)&#123;</span><br><span class="line">                ......<span class="comment">//处理数据</span></span><br><span class="line">                socket.write()....<span class="comment">//写数据</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="1-6-NIO"><a href="#1-6-NIO" class="headerlink" title="1.6 NIO**"></a>1.6 NIO**</h3><p><code>socket.accept()</code> 、<code>socket.read()</code> 、<code>socket.write()</code> 三个主要函数都是同步阻塞的，当一个连接在处理I/O的时候，系统是阻塞的，如果是单线程的话必然就挂死在那里；但CPU是被释放出来的，开启多线程，就可以让CPU去处理更多的事情。其实这也是所有使用多线程的本质： 1. 利用多核。 2. 当I/O阻塞系统，但CPU空闲的时候，可以利用多线程使用CPU资源。</p>
<p>现在的多线程一般都使用线程池，可以让线程的创建和回收成本相对较低。在活动连接数不是特别高（小于单机1000）的情况下，这种模型是比较不错的，可以让每一个连接专注于自己的I/O并且编程模型简单，也不用过多考虑系统的过载、限流等问题。线程池本身就是一个天然的漏斗，可以缓冲一些系统处理不了的连接或请求。</p>
<p>不过，这个模型最本质的问题在于，严重依赖于线程。但线程是很”贵”的资源，主要表现在： </p>
<ol>
<li>线程的创建和销毁成本很高，在Linux这样的操作系统中，线程本质上就是一个进程。创建和销毁都是重量级的系统函数。 </li>
<li>线程本身占用较大内存，像Java的线程栈，一般至少分配512K～1M的空间，如果系统中的线程数过千，恐怕整个JVM的内存都会被吃掉一半。</li>
<li>线程的切换成本是很高的。操作系统发生线程切换的时候，需要保留线程的上下文，然后执行系统调用。如果线程数过高，可能执行线程切换的时间甚至会大于线程执行的时间，这时候带来的表现往往是系统load偏高、CPU sy使用率特别高（超过20%以上)，导致系统几乎陷入不可用的状态。 </li>
<li>容易造成锯齿状的系统负载。因为系统负载是用活动线程数或CPU核心数，一旦线程数量高但外部网络环境不是很稳定，就很容易造成大量请求的结果同时返回，激活大量阻塞线程从而使系统负载压力过大。</li>
</ol>
<p>所以，当面对十万甚至百万级连接的时候，传统的BIO模型是无能为力的。随着移动端应用的兴起和各种网络游戏的盛行，百万级长连接日趋普遍，此时，必然需要一种更高效的I/O处理模型。</p>
<p>以 <code>socket.read()</code> 为例子：</p>
<p>传统的BIO里面 <code>socket.read()</code> ，如果TCP RecvBuffer里没有数据，函数会一直阻塞，直到收到数据，返回读到的数据。</p>
<p>对于NIO，如果TCP RecvBuffer有数据，就把数据从网卡读到内存，并且返回给用户；反之则直接返回0，永远不会阻塞。</p>
<p>最新的AIO(Async I/O)里面会更进一步：不但等待就绪是非阻塞的，就连数据从网卡到内存的过程也是异步的。</p>
<p>换句话说，BIO里用户最关心“我要读”，NIO里用户最关心”我可以读了”，在AIO模型里用户更需要关注的是“读完了”。</p>
<p>NIO一个重要的特点是：socket主要的读、写、注册和接收函数，在等待就绪阶段都是非阻塞的，真正的I/O操作是同步阻塞的（消耗CPU但性能非常高）。</p>
<hr>
<h2 id="第二节-NIO"><a href="#第二节-NIO" class="headerlink" title="第二节 NIO**"></a>第二节 NIO**</h2><h3 id="2-1-简述"><a href="#2-1-简述" class="headerlink" title="2.1 简述**"></a>2.1 简述**</h3><p>从JDK1.4开始，Java提供了一系列改进的输入/输出处理的新特性，被统称为NIO（Non-blocking I/O，在Java领域，也称为New I/O）。新增了许多用于处理输入输出的类，这些类都被放在 <code>java.nio</code> 包及子包下，并且对原 <code>java.io</code> 包中的很多类进行改写，新增了满足NIO的功能。</p>
<p>NIO采用<strong>内存映射</strong>文件的方式来处理输入输出，NIO将文件或文件的一段区域映射到内存中，这样就可以像访问内存一样访问文件了。</p>
<p>NIO 与原来的 I/O 有同样的作用和目的，但实现方式不同。NIO基于块I/O，其效率可以比流 I/O 高许多。</p>
<hr>
<h3 id="2-2-内存映射"><a href="#2-2-内存映射" class="headerlink" title="2.2 内存映射**"></a>2.2 内存映射**</h3><p>操作系统可以利用虚拟内存来将一个文件或文件其中一部分映射到内存中，可以像访问内存数组一样去处理文件，这比传统的文件操作要快很多。</p>
<p><code>java.nio</code> 包提供了内存映射的办法，首先从文件中获取一个通道 <code>Channel</code> ，<strong>通道就是对磁盘文件的一个抽象</strong>，可以通过通道来访问内存映射、文件加锁机制以及文件间快速数据传递等操作系统特性。<code>Channel</code> 封装了对数据源的操作，数据源可以是 <code>文件</code> 或 <code>Socket</code> 等，<code>Channel</code> 主要用来做<strong>非阻塞式读写</strong>。</p>
<hr>
<h3 id="2-3-流与块的比较"><a href="#2-3-流与块的比较" class="headerlink" title="2.3 流与块的比较**"></a>2.3 流与块的比较**</h3><p>原来的 I/O 库(在 <code>java.io.*</code> 中) 与 NIO 最重要的区别是<strong>数据打包和传输的方式</strong>。正如前面提到的，原来的 I/O 以流的方式处理数据，而 NIO 以块的方式处理数据。</p>
<p><strong>面向流 的 I/O 系统一次一个字节地处理数据</strong>。一个输入流产生一个字节的数据，一个输出流消费一个字节的数据。为流式数据创建过滤器非常容易。链接几个过滤器，以便每个过滤器只负责单个复杂处理机制的一部分，这样也是相对简单的。不利的一面是，面向流的 I/O 通常相当慢。</p>
<p>一个 面向块 的 I/O 系统以块的形式处理数据。<strong>每一个操作都在一步中产生或者消费一个数据块</strong>。按块处理数据比按(流式的)字节处理数据要快得多。但是面向块的 I/O 缺少一些面向流的 I/O 所具有的优雅性和简单性。</p>
<p>在NIO中有几个核心对象需要掌握：<strong>缓冲区</strong>（Buffer）、<strong>通道</strong>（Channel）、<strong>选择器</strong>（Selector）。</p>
<hr>
<h3 id="2-4-IO-与-NIO-的区别"><a href="#2-4-IO-与-NIO-的区别" class="headerlink" title="2.4 IO 与 NIO 的区别**"></a>2.4 IO 与 NIO 的区别**</h3><table>
<thead>
<tr>
<th><strong>IO</strong></th>
<th><strong>NIO</strong></th>
</tr>
</thead>
<tbody><tr>
<td>面向流</td>
<td>面向缓冲</td>
</tr>
<tr>
<td>阻塞IO</td>
<td>非阻塞IO</td>
</tr>
<tr>
<td>无</td>
<td>选择器</td>
</tr>
</tbody></table>
<h4 id="2-4-1-面向流和面向缓冲"><a href="#2-4-1-面向流和面向缓冲" class="headerlink" title="2.4.1 面向流和面向缓冲**"></a>2.4.1 面向流和面向缓冲**</h4><p>Java IO和NIO之间第一个最大的区别是，<strong>IO是面向流的，NIO是面向缓冲区的</strong>。 Java IO面向流意味着每次从流中读一个或多个字节，直至读取所有字节，它们没有被缓存在任何地方。此外，它不能前后移动流中的数据。如果需要前后移动从流中读取的数据，需要先将它缓存到一个缓冲区。 Java NIO的缓冲导向方法略有不同。数据读取到一个它稍后处理的缓冲区，需要时可在缓冲区中前后移动。这就增加了处理过程中的灵活性。但是，还需要检查是否该缓冲区中包含所有您需要处理的数据。而且，需确保当更多的数据读入缓冲区时，不要覆盖缓冲区里尚未处理的数据。</p>
<h4 id="2-4-2-阻塞IO与非阻塞IO"><a href="#2-4-2-阻塞IO与非阻塞IO" class="headerlink" title="2.4.2 阻塞IO与非阻塞IO**"></a>2.4.2 阻塞IO与非阻塞IO**</h4><p><strong>Java IO的各种流是阻塞的</strong>。这意味着，当一个线程调用read() 或 write()时，该线程被阻塞，直到有一些数据被读取，或数据完全写入。该线程在此期间不能再干任何事情了。<strong>Java NIO的非阻塞模式</strong>，使一个线程从某通道发送请求读取数据，但是它仅能得到目前可用的数据，如果目前没有数据可用时，就什么都不会获取，而不是保持线程阻塞，所以直至数据变的可以读取之前，该线程可以继续做其他的事情。 非阻塞写也是如此。一个线程请求写入一些数据到某通道，但不需要等待它完全写入，这个线程同时可以去做别的事情。 线程通常将非阻塞IO的空闲时间用于在其它通道上执行IO操作，所以一个单独的线程现在可以管理多个输入和输出通道（channel）。</p>
<h4 id="2-4-3-选择器"><a href="#2-4-3-选择器" class="headerlink" title="2.4.3 选择器**"></a>2.4.3 选择器**</h4><p>Java NIO的选择器允许一个单独的线程来监视多个输入通道，你可以注册多个通道使用一个选择器，然后使用一个单独的线程来“选择”通道：这些通道里已经有可以处理的输入，或者选择已准备写入的通道。这种选择机制，使得一个单独的线程很容易来管理多个通道。</p>
<hr>
<h3 id="2-5-缓冲区-Buffer"><a href="#2-5-缓冲区-Buffer" class="headerlink" title="2.5 缓冲区-Buffer**"></a>2.5 缓冲区-Buffer**</h3><h4 id="2-5-1-概述"><a href="#2-5-1-概述" class="headerlink" title="2.5.1 概述**"></a>2.5.1 概述**</h4><p>缓冲区实际上是一个容器对象，简单的看像是一个数组，在NIO库中，所有数据都是用缓冲区处理的。在读取数据时，它是直接读到缓冲区中的； 在写入数据时，它也是写入到缓冲区中的；任何时候访问 NIO 中的数据，都是将它放到缓冲区中。而在面向流I/O系统中，所有数据都是直接写入或者直接将数据读取到Stream对象中。具体看下面这张图就理解了：</p>
<p><img src="https://pic-1258215793.cos.ap-shanghai.myqcloud.com/content/20200501/202005010134.jpg"></p>
<p>上面的图描述了从一个客户端向服务端发送数据，然后服务端接收数据的过程。客户端发送数据时，必须先将数据存入Buffer中，然后将Buffer中的内容写入通道。服务端这边接收数据必须通过Channel将数据读入到Buffer中，然后再从Buffer中取出数据来处理。</p>
<h4 id="2-5-2-类结构和API"><a href="#2-5-2-类结构和API" class="headerlink" title="2.5.2 类结构和API**"></a>2.5.2 类结构和API**</h4><p>在NIO中，所有的缓冲区类型都继承于抽象类Buffer，支持顺序和随机数据访问，其有一系列子类ByteBuffer，CharBuffer等，最常用的就是ByteBuffer，StringBuffer并不属于这一系列。</p>
<p>对于Java中的基本类型，基本都有一个具体Buffer类型与之相对应，它们之间的继承关系如下图所示：</p>
<p><img src="https://pic-1258215793.cos.ap-shanghai.myqcloud.com/content/20200501/202005010135.png"></p>
<p>抽象类Buffer的四个关键属性：</p>
<table>
<thead>
<tr>
<th><strong>属    性</strong></th>
<th><strong>作    用</strong></th>
</tr>
</thead>
<tbody><tr>
<td>capacity</td>
<td>容量，指缓冲区能够容纳的数据元素的最大数量，这一容量在缓冲区创建时被设定，并且永远不能被改变</td>
</tr>
<tr>
<td>limit</td>
<td>上界，指缓冲区的第一个不能被读或写的元素，或者说是，缓冲区中现存元素的计数</td>
</tr>
<tr>
<td>position</td>
<td>位置，指下一个要被读或写的元素的索引，位置会自动由相应的get()和put()函数更新</td>
</tr>
<tr>
<td>mark</td>
<td>标记，指一个备忘位置，调用mark()来设定mark=position，调用reset()来设定postion=mark，标记未设定前是未定义的</td>
</tr>
</tbody></table>
<p>Buffer中提供了以下的一些方法：</p>
<table>
<thead>
<tr>
<th><strong>方    法</strong></th>
<th><strong>作    用</strong></th>
</tr>
</thead>
<tbody><tr>
<td>Object array()</td>
<td>返回此缓冲区的底层实现数组</td>
</tr>
<tr>
<td>int arrayOffset()</td>
<td>返回此缓冲区的底层实现数组中第一个缓冲区还俗的偏移量</td>
</tr>
<tr>
<td>int capacity()</td>
<td>返回此缓冲区的容量</td>
</tr>
<tr>
<td>Buffer clear()</td>
<td>清除此缓冲区</td>
</tr>
<tr>
<td>Buffer flip()</td>
<td>反转此缓冲区</td>
</tr>
<tr>
<td>boolean hasArray()</td>
<td>告知此缓冲区是否具有可访问的底层实现数组</td>
</tr>
<tr>
<td>boolean hasRemaining()</td>
<td>告知在当前位置和限制之间是否有元素</td>
</tr>
<tr>
<td>boolean isDirect()</td>
<td>告知此缓冲区是否为直接缓冲区</td>
</tr>
<tr>
<td>boolean isReadOnly()</td>
<td>告知此缓冲区是否为只读缓存</td>
</tr>
<tr>
<td>int limit()</td>
<td>返回此缓冲区的上界</td>
</tr>
<tr>
<td>Buffer limit(int newLimit)</td>
<td>设置此缓冲区的上界</td>
</tr>
<tr>
<td>Buffer mark()</td>
<td>在此缓冲区的位置设置标记</td>
</tr>
<tr>
<td>int position()</td>
<td>返回此缓冲区的位置</td>
</tr>
<tr>
<td>Buffer position(int newPosition)</td>
<td>设置此缓冲区的位置</td>
</tr>
<tr>
<td>int remaining()</td>
<td>返回当前位置与上界之间的元素数</td>
</tr>
<tr>
<td>Buffer reset()</td>
<td>将此缓冲区的位置重置为以前标记的位置</td>
</tr>
<tr>
<td>Buffer rewind()</td>
<td>重绕此缓冲区</td>
</tr>
</tbody></table>
<h4 id="2-5-3-使用案例"><a href="#2-5-3-使用案例" class="headerlink" title="2.5.3 使用案例**"></a>2.5.3 使用案例**</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TestIntBuffer</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 分配新的int缓冲区，参数为缓冲区容量</span></span><br><span class="line">        <span class="comment">// 新缓冲区的当前位置将为零，其界限(限制位置)将为其容量。它将具有一个底层实现数组，其数组偏移量将为零。</span></span><br><span class="line">        IntBuffer buffer = IntBuffer.allocate(<span class="number">8</span>);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; buffer.capacity(); ++i) &#123;</span><br><span class="line">            <span class="keyword">int</span> j = <span class="number">2</span> * (i + <span class="number">1</span>);</span><br><span class="line">            <span class="comment">// 将给定整数写入此缓冲区的当前位置，当前位置递增</span></span><br><span class="line">            buffer.put(j);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 重设此缓冲区，将限制设置为当前位置，然后将当前位置设置为0</span></span><br><span class="line">        buffer.flip();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 查看在当前位置和限制位置之间是否有元素</span></span><br><span class="line">        <span class="keyword">while</span> (buffer.hasRemaining()) &#123;</span><br><span class="line">            <span class="comment">// 读取此缓冲区当前位置的整数，然后当前位置递增</span></span><br><span class="line">            <span class="keyword">int</span> j = buffer.get();</span><br><span class="line">            System.out.print(j + <span class="string">&quot;  &quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>运行后可以看到：</p>
<figure class="highlight basic"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="symbol">2 </span> <span class="number">4</span>  <span class="number">6</span>  <span class="number">8</span>  <span class="number">10</span>  <span class="number">12</span>  <span class="number">14</span>  <span class="number">16</span> </span><br></pre></td></tr></table></figure>

<h4 id="2-5-4-缓冲区分片"><a href="#2-5-4-缓冲区分片" class="headerlink" title="2.5.4 缓冲区分片**"></a>2.5.4 缓冲区分片**</h4><p>通过 <code>slice()</code> 方法可以创建一个子缓冲区，也就是切出一块缓冲区，和原有的缓冲区是共享空间的。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">       <span class="comment">// 缓冲区分片</span></span><br><span class="line">       ByteBuffer byteBuffer = ByteBuffer.allocate(<span class="number">10</span>);</span><br><span class="line"></span><br><span class="line">       <span class="comment">// 缓冲区中的数据0-9</span></span><br><span class="line">       <span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;byteBuffer.capacity(); i++) &#123;</span><br><span class="line">           byteBuffer.put( (<span class="keyword">byte</span>)i );</span><br><span class="line">       &#125;</span><br><span class="line"></span><br><span class="line">       <span class="comment">// 创建子缓冲区</span></span><br><span class="line">       byteBuffer.position(<span class="number">3</span>);</span><br><span class="line">       byteBuffer.limit(<span class="number">7</span>);</span><br><span class="line">       ByteBuffer slice = byteBuffer.slice();</span><br><span class="line"></span><br><span class="line">       <span class="comment">// 改变子缓冲区的内容</span></span><br><span class="line">       <span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;slice.capacity(); i++) &#123;</span><br><span class="line">           <span class="keyword">byte</span> b = slice.get( i );</span><br><span class="line">           b *= <span class="number">10</span>;</span><br><span class="line">           slice.put( i, b );</span><br><span class="line">       &#125;</span><br><span class="line"></span><br><span class="line">       byteBuffer.position( <span class="number">0</span> );</span><br><span class="line">       byteBuffer.limit( byteBuffer.capacity() );</span><br><span class="line"></span><br><span class="line">       <span class="keyword">while</span> (byteBuffer.remaining()&gt;<span class="number">0</span>) &#123;</span><br><span class="line">           System.out.print( byteBuffer.get() );</span><br><span class="line">           System.out.print(<span class="string">&quot; &quot;</span>);</span><br><span class="line">       &#125;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>

<p>运行后可以看到如下结果，只有子缓冲区“可见的”那部分数据发生了变化，并且说明子缓冲区与原缓冲区是数据共享的。</p>
<figure class="highlight basic"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="symbol">0 </span><span class="number">1</span> <span class="number">2</span> <span class="number">30</span> <span class="number">40</span> <span class="number">50</span> <span class="number">60</span> <span class="number">7</span> <span class="number">8</span> <span class="number">9</span> </span><br></pre></td></tr></table></figure>

<h4 id="2-5-5-只读缓冲区"><a href="#2-5-5-只读缓冲区" class="headerlink" title="2.5.5 只读缓冲区**"></a>2.5.5 只读缓冲区**</h4><p>可以通过调用缓冲区的 <code>asReadOnlyBuffer()</code> 方法，将任何常规缓冲区转换为<strong>只读缓冲区</strong>，这个方法返回一个与原缓冲区完全相同的缓冲区，并与原缓冲区共享数据，只不过它是只读的。如果原缓冲区的内容发生了变化，只读缓冲区的内容也随之发生变化。</p>
<p>如果尝试修改只读缓冲区的内容，则会报 <code>ReadOnlyBufferException</code> 异常。只读缓冲区对于保护数据很有用。在将缓冲区传递给某个对象的方法时，无法知道这个方法是否会修改缓冲区中的数据。创建一个只读的缓冲区可以保证该缓冲区不会被修改。只可以把常规缓冲区转换为只读缓冲区，而不能将只读的缓冲区转换为可写的缓冲区。</p>
<h4 id="2-5-6-状态变化"><a href="#2-5-6-状态变化" class="headerlink" title="2.5.6 状态变化**"></a>2.5.6 状态变化**</h4><p>缓冲区对象内置了一些机制，能够跟踪和记录缓冲区的状态变化情况，如果我们使用 <code>get()</code> 方法从缓冲区获取数据或者使用 <code>put()</code> 方法把数据写入缓冲区，都会引起缓冲区状态的变化。</p>
<p>缓冲区结构就是一个数组，其四个属性 <code>mark &lt;= position &lt;= limit &lt;= capacity</code> ，也就是 <code>0&lt;=标记&lt;=位置&lt;=界限&lt;=容量</code> 。</p>
<blockquote>
<ol>
<li><strong>容量</strong>(Capacity)：容纳元素最大数量，不可修改。指定了可以存储在缓冲区中的最大数据容量，实际上，它指定了底层数组的大小，或者至少是指定了准许我们使用的底层数组的容量。</li>
<li><strong>上届</strong>(Limit)：当前数据总数。指定还有多少数据需要取出(在从缓冲区写入通道时)，或者还有多少空间可以放入数据(在从通道读入缓冲区时)。</li>
<li><strong>位置</strong>(Position)：下一个元素位置，下次读写所在位置。它的值由 <code>get()</code> / <code>put()</code> 方法自动更新，在新创建一个Buffer对象时，position被初始化为0。</li>
<li><strong>标记</strong>(Mark)：上一次读写的位置，可用于重复一个读写操作。</li>
</ol>
</blockquote>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">Buffer</span> </span>&#123;</span><br><span class="line">	<span class="comment">// Invariants: mark &lt;= position &lt;= limit &lt;= capacity</span></span><br><span class="line">	<span class="keyword">private</span> <span class="keyword">int</span> mark = -<span class="number">1</span>;</span><br><span class="line">	<span class="keyword">private</span> <span class="keyword">int</span> position = <span class="number">0</span>;</span><br><span class="line">	<span class="keyword">private</span> <span class="keyword">int</span> limit;</span><br><span class="line">	<span class="keyword">private</span> <span class="keyword">int</span> capacity;</span><br><span class="line"></span><br><span class="line">	Buffer(<span class="keyword">int</span> mark, <span class="keyword">int</span> pos, <span class="keyword">int</span> lim, <span class="keyword">int</span> cap) &#123; <span class="comment">// package-private</span></span><br><span class="line">		<span class="keyword">if</span> (cap &lt; <span class="number">0</span>)</span><br><span class="line">			<span class="keyword">throw</span> createCapacityException(cap);</span><br><span class="line">		<span class="keyword">this</span>.capacity = cap;</span><br><span class="line">		limit(lim);</span><br><span class="line">		position(pos);</span><br><span class="line">		<span class="keyword">if</span> (mark &gt;= <span class="number">0</span>) &#123;</span><br><span class="line">			<span class="keyword">if</span> (mark &gt; pos)</span><br><span class="line">				<span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(<span class="string">&quot;mark &gt; position: (&quot;</span> + mark + <span class="string">&quot; &gt; &quot;</span> + pos + <span class="string">&quot;)&quot;</span>);</span><br><span class="line">			<span class="keyword">this</span>.mark = mark;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    ......</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>缓冲区存取主要通过 <code>put()</code> ，<code>get()</code> 方法，可以通过 <code>position()</code> 读取指定位置的元素，当新建缓冲区时，limit为总量。不断通过 <code>put()</code> 把数据放入缓冲区，直到数据耗尽或到达容量，然后可以开始读取操作，若要从头开始读取应该调整limit，<code>filp()</code> 方法封装了这个操作。调用 <code>filp()</code> 将界限设为当前位置，即最后一个元素位置。不断调用get()将所有缓冲区数据读出后，调用 <code>clear()</code> 清空数据，来为下一次使用作准备，<code>clear()</code> 会将pos回归0，limit回归容量大小。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> Buffer <span class="title">flip</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	limit = position;</span><br><span class="line">	position = <span class="number">0</span>;</span><br><span class="line">	mark = -<span class="number">1</span>;</span><br><span class="line">	<span class="keyword">return</span> <span class="keyword">this</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> Buffer <span class="title">clear</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	position = <span class="number">0</span>;</span><br><span class="line">	limit = capacity;</span><br><span class="line">	mark = -<span class="number">1</span>;</span><br><span class="line">	<span class="keyword">return</span> <span class="keyword">this</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>因为涉及到修改limit，而缓冲区又根据limit限制了读写操作，所以使用时要注意limit的变化不要影响到自己的读写操作。</p>
<p>调用mark记录当前位置，position会在读写操作后改变，可以通过 <code>reset()</code> 方法恢复position。</p>
<p>重读可以调用 <code>rewind()</code> 或 <code>mark</code> / <code>reset()</code> 等方法，获取缓冲区可以通过 <code>ByteBuffer.allocate()</code> 或 <code>ByteBuffer.wrap()</code> 等方法。</p>
<p>下面通过一个案例来了解状态变化的过程：创建一个256字节的缓冲区，初始 <code>mark = -1，pos = 0，limit = 256，capacity = 256</code> 。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span>&#123;</span><br><span class="line">        <span class="comment">// 初始化时</span></span><br><span class="line">        <span class="comment">// mark = -1，pos = 0，limit = 256，capacity = 256</span></span><br><span class="line">        ByteBuffer byteBuffer = ByteBuffer.allocate(<span class="number">256</span>);</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 从通道读取4个数据，也就是写入缓冲区4个数据</span></span><br><span class="line">        <span class="comment">// mark = -1，pos = 4，limit = 256，capacity = 256</span></span><br><span class="line">        byteBuffer.put(<span class="string">&quot;abcd&quot;</span>.getBytes());</span><br><span class="line">        System.out.println(byteBuffer.toString());<span class="comment">//[pos=4 lim=256 cap=256]</span></span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 接着把数据写入输出通道，也就是从缓冲区读取数据</span></span><br><span class="line">        <span class="comment">// 首先要调用flip()，使输出时读取数据从0开始，并读取到limit为缓冲区所含数据</span></span><br><span class="line">        <span class="comment">// mark = -1，pos = 0，limit = 4，capacity = 256</span></span><br><span class="line">        byteBuffer.flip();</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 接着调用get()开始从缓冲区读取数据</span></span><br><span class="line">        System.out.println(byteBuffer.toString());<span class="comment">//[pos=0 lim=4 cap=256]</span></span><br><span class="line">        System.out.println(byteBuffer.get());<span class="comment">//97</span></span><br><span class="line">        System.out.println(byteBuffer.toString());<span class="comment">//[pos=1 lim=4 cap=256]</span></span><br><span class="line">        System.out.println(byteBuffer.get());<span class="comment">//98</span></span><br><span class="line">        System.out.println(byteBuffer.toString());<span class="comment">//[pos=2 lim=4 cap=256]</span></span><br><span class="line">        System.out.println(byteBuffer.get());<span class="comment">//99</span></span><br><span class="line">        System.out.println(byteBuffer.toString());<span class="comment">//[pos=3 lim=4 cap=256]</span></span><br><span class="line">        System.out.println(byteBuffer.get());<span class="comment">//100</span></span><br><span class="line">        System.out.println(byteBuffer.toString());<span class="comment">//[pos=4 lim=4 cap=256]</span></span><br><span class="line">        <span class="comment">// mark = -1，pos = 4，limit = 4，capacity = 256</span></span><br><span class="line">        <span class="comment">//继续调用get()会抛出java.nio.BufferUnderflowException</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="2-5-7-字节缓冲区"><a href="#2-5-7-字节缓冲区" class="headerlink" title="2.5.7 字节缓冲区**"></a>2.5.7 字节缓冲区**</h4><p>字节缓冲区和其他缓冲区类型最明显的不同在于，它们<strong>可能成为通道所执行I/O的源头或目标</strong>，如果对NIO有了解的朋友们一定知道，通道只接收 <code>ByteBuffer</code> 作为参数。</p>
<p>如我们所知道的，操作系统在内存区域进行I/O操作，这些内存区域，就操作系统方面而言，是相连的字节序列。于是，毫无疑问，只有字节缓冲区有资格参与I/O操作。也请回想一下操作系统会直接存取进程—-在本例中是JVM进程的内存空间，以传输数据。这也意味着I/O操作的目标内存区域必须是连续的字节序列，在JVM中，字节数组可能不会在内存中连续存储，或者无用存储单元收集可能随时对其进行移动。在Java中，数组是对象，而数据存储在对象中的方式在不同的JVM实现中各有不同。</p>
<p>出于这一原因，引入了直接缓冲区的概念。直接缓冲区被用于与通道和固有I/O线程交互，它们通过使用固有代码来告知操作系统直接释放或填充内存区域，对用于通道直接或原始存取的内存区域中的字节元素的存储尽了最大的努力。</p>
<p><strong>直接字节缓冲区</strong>通常是I/O操作最好的选择。在设计方面，它们支持JVM可用的最高效I/O机制，<strong>非直接字节缓冲区</strong>可以被传递给通道，但是这样可能导致性能损耗，通常非直接缓冲不可能成为一个本地I/O操作的目标，如果开发者向一个通道中传递一个非直接ByteBuffer对象用于写入，通道可能会在每次调用中隐含地进行下面的操作：</p>
<ol>
<li>创建一个临时的直接ByteBuffer对象</li>
<li>将非直接缓冲区的内容复制到临时缓冲中</li>
<li>使用临时缓冲区执行低层次I/O操作</li>
<li>临时缓冲区对象离开作用于，并最终成为被回收的无用数据</li>
</ol>
<p>这可能导致缓冲区在每个I/O上复制并产生大量对象，而这种事都是我们极力避免的。</p>
<p><strong>直接缓冲区是I/O的最佳选择</strong>，但可能比创建非直接缓冲区要花费更高的成本。直接缓冲区使用的内存是通过调用本地操作系统的代码分配的，绕过了标准JVM堆栈。建立和销毁直接缓冲区会明显比具有堆栈的缓冲区更极爱破费，这取决于主操作系统以及JVM实现。直接缓冲区的内存区域不受无用存储单元收集支配，因为它们位于标准JVM堆栈之外。</p>
<p>直接ByteBuffer是通过调用具有所需容量的 <code>ByteBuffer.allocateDirect()</code> 函数产生的：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">ByteBuffer</span></span></span><br><span class="line"><span class="class">    <span class="keyword">extends</span> <span class="title">Buffer</span></span></span><br><span class="line"><span class="class">    <span class="keyword">implements</span> <span class="title">Comparable</span>&lt;<span class="title">ByteBuffer</span>&gt; </span>&#123;</span><br><span class="line">    </span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> ByteBuffer <span class="title">allocate</span><span class="params">(<span class="keyword">int</span> capacity)</span> </span>&#123;</span><br><span class="line">		<span class="keyword">if</span> (capacity &lt; <span class="number">0</span>)</span><br><span class="line">			<span class="keyword">throw</span> createCapacityException(capacity);</span><br><span class="line">		<span class="keyword">return</span> <span class="keyword">new</span> HeapByteBuffer(capacity, capacity);<span class="comment">//返回局部内部类HeapByteBuffer</span></span><br><span class="line">	&#125;</span><br><span class="line">    ...</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> ByteBuffer <span class="title">allocateDirect</span><span class="params">(<span class="keyword">int</span> capacity)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> DirectByteBuffer(capacity);</span><br><span class="line">    &#125;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>可以使用 <code>通道</code> + <code>缓冲区</code> 的方式来代替随机访问文件，会提高读写性能。</p>
<hr>
<h3 id="2-6-通道-Channel"><a href="#2-6-通道-Channel" class="headerlink" title="2.6 通道-Channel**"></a>2.6 通道-Channel**</h3><h4 id="2-6-1-概述"><a href="#2-6-1-概述" class="headerlink" title="2.6.1 概述**"></a>2.6.1 概述**</h4><p><strong>通道</strong>用于在字节缓冲区和另一侧的实体（如文件、Socket等）之间传输数据，通常会与操作系统的文件描述符（FileDescriptor）和文件句柄（FileHandler）有着一对一的关系。虽然通道比文件描述符更广义，但开发者经常使用到的多数通道都是连接到开放的文件描述符的。Channel类提供维持平台独立性所需的抽象过程，不然仍然会模拟现代操作系统本身的I/O性能。</p>
<p>通道是一种途径，借助该途径，可以用最小的总开销来访问操作系统本身的I/O服务。<strong>缓冲区则是通道内部用来发送和接收数据的端点</strong>。</p>
<p><strong>Channel和Stream的区别？</strong>Channel和传统IO中的Stream很相似。虽然很相似，但是有很大的区别，主要区别为：<strong>通道是双向的</strong>，通过一个Channel既可以进行读，也可以进行写；而<strong>Stream只能进行单向操作</strong>，通过一个Stream只能进行读或者写，比如InputStream只能进行读取操作，OutputStream只能进行写操作；</p>
<p>通道是一个对象，通过它可以读取和写入数据，当然了所有数据都通过Buffer对象来处理。我们永远不会将字节直接写入通道中，相反是将数据写入包含一个或者多个字节的缓冲区。同样不会直接从通道中读取字节，而是将数据从通道读入缓冲区，再从缓冲区获取这个字节。</p>
<p>Channel提供了 <code>Scatter</code> / <code>Gather</code> 功能，也叫<strong>本地矢量I/O</strong>，就是在多个缓冲区上实现一个简单的I/O操作。比如一个write操作，数据从不同缓冲区按顺序抽取即 <code>gather</code> ，通过Channel发送出去。相反read操作就是按顺序散布 <code>scatter</code> 。缓冲区自身不需要具备 <code>Scatter</code> / <code>Gather</code> 功能，目前大部分操作系统都支持这种本地矢量I/O。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">ByteBuffer[] bufferArray = &#123;buffer1, buffer2&#125;;</span><br><span class="line">socketChannel.write(bufferArray);</span><br></pre></td></tr></table></figure>

<h4 id="2-6-2-类结构"><a href="#2-6-2-类结构" class="headerlink" title="2.6.2 类结构**"></a>2.6.2 类结构**</h4><p>Channel本身是一个接口，定义了方法 <code>isOpen()</code> 和 <code>close()</code> 。所以对所有通道来说只有两种共同的操作：检查一个通道是否打开 <code>isOpen()</code> 和关闭一个打开的通道 <code>close()</code> ，其余所有的东西都是那些实现Channel接口以及它的子接口的类。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Channel</span> <span class="keyword">extends</span> <span class="title">Closeable</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isOpen</span><span class="params">()</span></span>;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">close</span><span class="params">()</span> <span class="keyword">throws</span> IOException</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>Channel分为 <code>FileChannel</code> 和 <code>SocketChannel</code> 两类。</p>
<blockquote>
<p> <code>SocketChannel</code> 又分为如下三类。</p>
<ol>
<li>ServerSocketChannel-监听端口</li>
<li>SocketChannel-TCP通信</li>
<li>DatagramChannel-UDP通信</li>
</ol>
</blockquote>
<p>在NIO中，提供了多种通道对象，而所有的通道对象都实现了Channel接口。它们之间的继承关系如下图所示：</p>
<p><img src="https://pic-1258215793.cos.ap-shanghai.myqcloud.com/content/20200501/202005010136.png"></p>
<p>Channel(通道)表示到实体如硬件设备、文件、网络套接字或可以执行一个或多个不同I/O操作的程序组件的开放的连接。所有的Channel都不是通过构造器创建的，而是通过传统的节点InputStream、OutputStream的getChannel方法来返回响应的Channel。</p>
<p>Channel中最常用的三个类方法就是map、read和write，其中map方法用于将Channel对应的部分或全部数据映射成ByteBuffer，而read或write方法有一系列的重载形式，这些方法用于从Buffer中读取数据或向Buffer中写入数据。</p>
<h4 id="2-6-3-文件通道"><a href="#2-6-3-文件通道" class="headerlink" title="2.6.3 文件通道**"></a>2.6.3 文件通道**</h4><p><strong>文件通道总是阻塞式的</strong>，因此不能被置于非阻塞模式下。</p>
<p>通道可以以多种方式创建。Socket通道可以有直接创建Socket通道的工厂方法，但是一个FileChannel对象却只能通过在一个打开的RandomAccessFile、FileInputStream或FileOutputStream对象上调用 <code>getChannel()</code> 方法来获取，开发者不能直接创建一个FileChannel。</p>
<p>调用 <code>getChannel()</code> 方法会返回一个连接到相同文件的FileChannel对象且该FileChannel对象具有与file对象相同的访问权限，然后就可以使用通道对象来利用强大的FileChannel API了。</p>
<p><strong>FileChannel对象是线程安全的</strong>，多个进程可以在同一个实例上并发调用方法而不会引起任何问题，不过并非所有的操作都是多线程的。<strong>影响通道位置或者影响文件的操作都是单线程的</strong>，如果有一个线程已经在执行会影响通道位置或文件大小的操作，那么其他尝试进行此类操作之一的线程必须等待，并发行为也会受到底层操作系统或文件系统的影响。</p>
<p>从文件中读出数据。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">    File file = <span class="keyword">new</span> File(<span class="string">&quot;D:/files/readchannel.txt&quot;</span>);</span><br><span class="line">    FileInputStream fis = <span class="keyword">new</span> FileInputStream(file);</span><br><span class="line">    FileChannel fc = fis.getChannel();</span><br><span class="line">    ByteBuffer bb = ByteBuffer.allocate(<span class="number">35</span>);</span><br><span class="line">    fc.read(bb);</span><br><span class="line">    bb.flip();</span><br><span class="line">    <span class="keyword">while</span> (bb.hasRemaining())</span><br><span class="line">    &#123;</span><br><span class="line">        System.out.print((<span class="keyword">char</span>)bb.get());</span><br><span class="line">    &#125;</span><br><span class="line">    bb.clear();</span><br><span class="line">    fc.close();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>使用文件通道写数据。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">    File file = <span class="keyword">new</span> File(<span class="string">&quot;D:/files/writechannel.txt&quot;</span>);</span><br><span class="line">    RandomAccessFile raf = <span class="keyword">new</span> RandomAccessFile(file, <span class="string">&quot;rw&quot;</span>);</span><br><span class="line">    FileChannel fc = raf.getChannel();</span><br><span class="line">    ByteBuffer bb = ByteBuffer.allocate(<span class="number">10</span>);</span><br><span class="line">    String str = <span class="string">&quot;abcdefghij&quot;</span>;</span><br><span class="line">    bb.put(str.getBytes());</span><br><span class="line">    bb.flip();</span><br><span class="line">    fc.write(bb);</span><br><span class="line">    bb.clear();</span><br><span class="line">    fc.close();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>注意：<strong>通道只能使用ByteBuffer</strong>。</p>
<p>通过调用FileChannel类的 <code>map()</code> 方法可以获取一个ByteBuffer缓冲区，可以指定想要映射的文件区域与映射模式。</p>
<p>映射模式分为三种：</p>
<ul>
<li><code>FileChannel.MapMode.READ_ONLY</code> <strong>缓冲区只读</strong>，尝试写入抛出 <code>ReadOnlyBufferException</code> 异常。</li>
<li><code>FileChannel.MapMode.READ_WRITE</code> <strong>缓冲区可写</strong>，写操作会在某个时刻回写到文件中，但其它同步进行程序不一定可以立刻看到修改。</li>
<li><code>FileChannel.MapMode.PRIVATE</code> <strong>缓冲区可写</strong>，但只在缓冲区修改，文件并不会被影响。</li>
</ul>
<h4 id="2-6-4-NIO案例"><a href="#2-6-4-NIO案例" class="headerlink" title="2.6.4 NIO案例**"></a>2.6.4 NIO案例**</h4><h5 id="1-使用NIO读取数据"><a href="#1-使用NIO读取数据" class="headerlink" title="(1) 使用NIO读取数据**"></a>(1) 使用NIO读取数据**</h5><p>在前面我们说过，任何时候读取数据，都不是直接从通道读取，而是从通道读取到缓冲区。所以使用NIO读取数据可以分为下面三个步骤： </p>
<ol>
<li>从FileInputStream获取Channel。</li>
<li>创建Buffer。</li>
<li>将数据从Channel读取到Buffer中。</li>
</ol>
<p>下面是一个简单的使用NIO从文件中读取数据的例子：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Program</span> </span>&#123;  </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">( String args[] )</span> <span class="keyword">throws</span> Exception </span>&#123;  </span><br><span class="line">        FileInputStream fin = <span class="keyword">new</span> FileInputStream(<span class="string">&quot;c:\\test.txt&quot;</span>);  </span><br><span class="line">          </span><br><span class="line">        <span class="comment">// 获取通道  </span></span><br><span class="line">        FileChannel fc = fin.getChannel();  </span><br><span class="line">          </span><br><span class="line">        <span class="comment">// 创建缓冲区  </span></span><br><span class="line">        ByteBuffer buffer = ByteBuffer.allocate(<span class="number">1024</span>);  </span><br><span class="line">        <span class="comment">// 读取数据到缓冲区  </span></span><br><span class="line">        fc.read(buffer);  </span><br><span class="line">          </span><br><span class="line">        buffer.flip();  </span><br><span class="line">          </span><br><span class="line">        <span class="keyword">while</span> (buffer.remaining()&gt;<span class="number">0</span>) &#123;  </span><br><span class="line">            <span class="keyword">byte</span> b = buffer.get();  </span><br><span class="line">            System.out.print(((<span class="keyword">char</span>)b));  </span><br><span class="line">        &#125;  </span><br><span class="line">          </span><br><span class="line">        fin.close();  </span><br><span class="line">    &#125;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="2-使用NIO写入数据"><a href="#2-使用NIO写入数据" class="headerlink" title="(2) 使用NIO写入数据**"></a>(2) 使用NIO写入数据**</h5><p>使用NIO写入数据与读取数据的过程类似，同样数据不是直接写入通道，而是写入缓冲区，可以分为下面三个步骤：</p>
<ol>
<li>从FileInputStream获取Channel</li>
<li>创建Buffer</li>
<li>将数据从Channel写入到Buffer中</li>
</ol>
<p>下面是一个简单的使用NIO向文件中写入数据的例子：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Program</span> </span>&#123;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">byte</span> message[] = &#123; <span class="number">83</span>, <span class="number">111</span>, <span class="number">109</span>, <span class="number">101</span>, <span class="number">32</span>,</span><br><span class="line">        <span class="number">98</span>, <span class="number">121</span>, <span class="number">116</span>, <span class="number">101</span>, <span class="number">115</span>, <span class="number">46</span> &#125;;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">( String args[] )</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        FileOutputStream fout = <span class="keyword">new</span> FileOutputStream( <span class="string">&quot;c:\\test.txt&quot;</span> );</span><br><span class="line">        </span><br><span class="line">        FileChannel fc = fout.getChannel();</span><br><span class="line">        </span><br><span class="line">        ByteBuffer buffer = ByteBuffer.allocate( <span class="number">1024</span> );</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;message.length; ++i) &#123;</span><br><span class="line">            buffer.put( message[i] );</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        buffer.flip();</span><br><span class="line">        </span><br><span class="line">        fc.write( buffer );</span><br><span class="line">        </span><br><span class="line">        fout.close();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<hr>
<h3 id="2-7-选择器-Selector"><a href="#2-7-选择器-Selector" class="headerlink" title="2.7 选择器-Selector**"></a>2.7 选择器-Selector**</h3><h4 id="2-7-1-概述"><a href="#2-7-1-概述" class="headerlink" title="2.7.1 概述**"></a>2.7.1 概述**</h4><p>Selector即<strong>选择器</strong>，也叫<strong>多路复用器</strong>。可以用来<strong>检查一个或多个通道的状态是否可读可写</strong>，可以通过其实现单线程管理多个通道，管理多个网络连接。所以NIO实际上是一个<strong>多路复用IO</strong>。</p>
<p>这样的设计使得只有在连接真正有读写事件发生时，才会调用函数来进行读写，就大大地减少了系统开销，并且不必为每个连接都创建一个线程，不用去维护多个线程，并且避免了多线程之间的上下文切换导致的开销。</p>
<p>Channel通过 <code>write()</code> ，<code>read()</code> 方法读取和写入字节流，相较于通过Stream读取字节流其特点是<strong>封装了异步操作</strong>，且具有<strong>双向性</strong>，能<strong>同时支持读写</strong>。</p>
<p>与Selector有关的一个关键类是<strong>SelectionKey</strong>，一个SelectionKey表示一个到达的事件，这2个类构成了服务端处理业务的关键逻辑。</p>
<p>某种程度上来说，理解选择器比理解缓冲区和通道类更困难一些和复杂一些，因为涉及了三个主要的类，它们都会同时参与到这整个过程中。</p>
<blockquote>
<ul>
<li><strong>选择器</strong>（Selector）：选择器类管理着一个被注册的通道集合的信息和它们的就绪状态。通道是和选择器一起被注册的，并且<strong>使用选择器来更新通道的就绪状态</strong>。</li>
<li><strong>可选择通道</strong>（SelectableChannel）：这个抽象类<strong>提供了实现通道的可选择性所需要的公共方法</strong>，它是所有支持就绪检查的通道类的父类，<strong>FileChannel对象不是可选择的</strong>，因为它们没有继承SelectableChannel，所有Socket通道都是可选择的，包括从管道（Pipe）对象中获得的通道。SelectableChannel可以被注册到Selector对象上，同时可以设定对哪个选择器而言哪种操作是感兴趣的。一个通道可以被注册到多个选择器上，但对每个选择器而言只能被注册一次。</li>
<li><strong>选择键</strong>（SelectionKey）：选择键封装了特定的通道与特定的选择器的注册关系。调用 <code>SelectableChannel.register()</code> 方法会返回选择键并提供一个表示这种注册关系的标记。选择键包含了两个比特集（以整数形式进行编码），指示了该注册关系所关心的通道操作，以及通道已经准备好的操作。</li>
</ul>
</blockquote>
<p>这里先将选择器的执行分解为几条细节：</p>
<blockquote>
<ol>
<li>创建一个或者多个可选择的通道（SelectableChannel）。</li>
<li>将这些创建的通道注册到选择器对象中。</li>
<li>（SelectionKey）选择键会记住开发者关心的通道，它们也会追踪对应的通道是否已经就绪。</li>
<li>开发者调用一个选择器对象的 <code>select()</code> 方法，当方法从阻塞状态返回时，选择键会被更新。</li>
<li>获取选择键的集合，找到当时已经就绪的通道，通过遍历这些键，开发者可以选择对已就绪的通道要做的操作。</li>
</ol>
</blockquote>
<h4 id="2-7-2-使用示例"><a href="#2-7-2-使用示例" class="headerlink" title="2.7.2 使用示例**"></a>2.7.2 使用示例**</h4><p>创建选择器，并将其注册到通道。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//创建SocketChannel和Selector对象</span></span><br><span class="line">SocketChannel socketChannel = SocketChannel.open();</span><br><span class="line">Selector selector = Selector.open();</span><br><span class="line"></span><br><span class="line"><span class="comment">//配置socketChannel为非阻塞模式</span></span><br><span class="line">socketChannel.configureBlocking(<span class="keyword">false</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">//注册socketChannel到selector，channel必须继承AbstractSelectableChannel</span></span><br><span class="line"><span class="comment">//SelectionKey表示通道对象和选择器对象之间的注册关系</span></span><br><span class="line">SelectionKey key = socketChannel.register(selector, SelectionKey.OP_READ);</span><br><span class="line"><span class="comment">//select()方法在将线程置于睡眠状态直到这些感兴趣的事件中的一个发生或者10秒钟过去，这就是所谓的事件驱动。</span></span><br><span class="line">ready = selector.select(<span class="number">10000</span>); </span><br></pre></td></tr></table></figure>

<h4 id="2-7-3-如何结合事件模型使用NIO同步非阻塞特性"><a href="#2-7-3-如何结合事件模型使用NIO同步非阻塞特性" class="headerlink" title="2.7.3 如何结合事件模型使用NIO同步非阻塞特性**"></a>2.7.3 如何结合事件模型使用NIO同步非阻塞特性**</h4><p>回忆BIO模型，之所以需要多线程，是因为在进行I/O操作的时候，一是没有办法知道到底能不能写、能不能读，只能”傻等”，即使通过各种估算，算出来操作系统没有能力进行读写，也没法在socket.read()和socket.write()函数中返回，这两个函数无法进行有效的中断。所以除了多开线程另起炉灶，没有好的办法利用CPU。</p>
<p>NIO的读写函数可以立刻返回，这就给了我们不开线程利用CPU的最好机会：如果一个连接不能读写（socket.read()返回0或者socket.write()返回0），我们可以把这件事记下来，记录的方式通常是在Selector上注册标记位，然后切换到其它就绪的连接（channel）继续进行读写。</p>
<p>下面具体看下如何利用事件模型单线程处理所有I/O请求：</p>
<p>NIO的主要事件有几个：读就绪、写就绪、有新连接到来。</p>
<p>我们首先需要注册当这几个事件到来的时候所对应的处理器。然后在合适的时机告诉事件选择器：我对这个事件感兴趣。对于写操作，就是写不出去的时候对写事件感兴趣；对于读操作，就是完成连接和系统没有办法承载新读入的数据的时；对于accept，一般是服务器刚启动的时候；而对于connect，一般是connect失败需要重连或者直接异步调用connect的时候。</p>
<p>其次，用一个死循环选择就绪的事件，会执行系统调用（Linux 2.6之前是 <code>select</code> 、<code>poll</code> ，2.6之后是 <code>epoll</code> ，Windows是 <code>IOCP</code>），还会阻塞的等待新事件的到来。新事件到来的时候，会在selector上注册标记位，标示可读、可写或者有连接到来。</p>
<p>注意，select是阻塞的，无论是通过操作系统的通知（epoll）还是不停的轮询(select，poll)，这个函数是阻塞的。所以你可以放心大胆地在一个 <code>while(true)</code> 里面调用这个函数而不用担心CPU空转。</p>
<p>所以我们的程序大概的模样是：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">interface</span> <span class="title">ChannelHandler</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">channelReadable</span><span class="params">(Channel channel)</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">channelWritable</span><span class="params">(Channel channel)</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Channel</span></span>&#123;</span><br><span class="line">    Socket socket;</span><br><span class="line">    Event event;<span class="comment">//读，写或者连接</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//IO线程主循环:</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">IoThread</span> <span class="keyword">extends</span> <span class="title">Thread</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span></span>&#123;</span><br><span class="line">        Channel channel;</span><br><span class="line">        <span class="keyword">while</span>(channel=Selector.select())&#123;<span class="comment">//选择就绪的事件和对应的连接</span></span><br><span class="line">            <span class="keyword">if</span>(channel.event==accept)&#123;</span><br><span class="line">                registerNewChannelHandler(channel);<span class="comment">//如果是新连接，则注册一个新的读写处理器</span></span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span>(channel.event==write)&#123;</span><br><span class="line">                getChannelHandler(channel).channelWritable(channel);<span class="comment">//如果可以写，则执行写事件</span></span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span>(channel.event==read)&#123;</span><br><span class="line">                getChannelHandler(channel).channelReadable(channel);<span class="comment">//如果可以读，则执行读事件</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    Map&lt;Channel，ChannelHandler&gt; handlerMap;<span class="comment">//所有channel的对应事件处理器</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这个程序很简短，也是最简单的<strong>Reactor模式</strong>：<strong>注册所有感兴趣的事件处理器，单线程轮询选择就绪事件，执行事件处理器</strong>。</p>
<h4 id="2-7-4-优化线程模型"><a href="#2-7-4-优化线程模型" class="headerlink" title="2.7.4 优化线程模型**"></a>2.7.4 优化线程模型**</h4><p>由上面的示例我们大概可以总结出NIO是怎么解决掉线程的瓶颈并处理海量连接的：</p>
<p>NIO由原来的阻塞读写（占用线程）变成了单线程轮询事件，找到可以进行读写的网络描述符进行读写。除了事件的轮询是阻塞的（没有可干的事情必须要阻塞），剩余的I/O操作都是纯CPU操作，没有必要开启多线程。</p>
<p>并且由于线程的节约，连接数大的时候因为线程切换带来的问题也随之解决，进而为处理海量连接提供了可能。</p>
<p>单线程处理I/O的效率确实非常高，没有线程切换，只是拼命的读、写、选择事件。但现在的服务器，一般都是多核处理器，如果能够利用多核心进行I/O，无疑对效率会有更大的提高。</p>
<p>仔细分析一下我们需要的线程，其实主要包括以下几种： </p>
<ol>
<li>事件分发器，单线程选择就绪的事件。 </li>
<li>I/O处理器，包括connect、read、write等，这种纯CPU操作，一般开启CPU核心个线程就可以。 </li>
<li>业务线程，在处理完I/O后，业务一般还会有自己的业务逻辑，有的还会有其他的阻塞I/O，如DB操作，RPC等。只要有阻塞，就需要单独的线程。</li>
</ol>
<p>Java的Selector对于Linux系统来说，有一个致命限制：同一个channel的select不能被并发的调用。因此，如果有多个I/O线程，必须保证：一个socket只能属于一个IoThread，而一个IoThread可以管理多个socket。</p>
<p>另外连接的处理和读写的处理通常可以选择分开，这样对于海量连接的注册和读写就可以分发。虽然 <code>read()</code> 和 <code>write()</code> 是比较高效无阻塞的函数，但毕竟会占用CPU，如果面对更高的并发则无能为力。</p>
<p><img src="https://pic-1258215793.cos.ap-shanghai.myqcloud.com/content/20200501/202005010138.png"></p>
<p>通过上面的分析，可以看出NIO在服务端对于解放线程，优化I/O和处理海量连接方面，确实有自己的用武之地。那么在客户端上，NIO又有什么使用场景呢?</p>
<p>常见的 <code>客户端BIO</code> + <code>连接池</code> 模型，可以建立n个连接，然后当某一个连接被I/O占用的时候，可以使用其他连接来提高性能。</p>
<p>但多线程的模型面临和服务端相同的问题：如果指望增加连接数来提高性能，则连接数又受制于线程数、线程很贵、无法建立很多线程，则性能遇到瓶颈。</p>
<h4 id="2-7-5-每连接顺序请求的Redis"><a href="#2-7-5-每连接顺序请求的Redis" class="headerlink" title="2.7.5 每连接顺序请求的Redis**"></a>2.7.5 每连接顺序请求的Redis**</h4><p>对于Redis来说，由于服务端是全局串行的，能够保证同一连接的所有请求与返回顺序一致。这样可以使用 <code>单线程</code>＋<code>队列</code> ，把请求数据缓冲。然后pipeline发送，返回future，然后channel可读时，直接在队列中把future取回来，<code>done()</code> 就可以了。</p>
<p>伪代码如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">RedisClient</span> <span class="title">Implements</span> <span class="title">ChannelHandler</span></span>&#123;</span><br><span class="line">    <span class="keyword">private</span> BlockingQueue CmdQueue;</span><br><span class="line">    <span class="keyword">private</span> EventLoop eventLoop;</span><br><span class="line">    <span class="keyword">private</span> Channel channel;</span><br><span class="line">    </span><br><span class="line">    <span class="class"><span class="keyword">class</span> <span class="title">Cmd</span></span>&#123;</span><br><span class="line">        String cmd;</span><br><span class="line">        Future result;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> Future <span class="title">get</span><span class="params">(String key)</span></span>&#123;</span><br><span class="line">        Cmd cmd= <span class="keyword">new</span> Cmd(key);</span><br><span class="line">        queue.offer(cmd);</span><br><span class="line">        eventLoop.submit(<span class="keyword">new</span> Runnable()&#123;</span><br><span class="line">            List list = <span class="keyword">new</span> ArrayList();</span><br><span class="line">            queue.drainTo(list);</span><br><span class="line">            <span class="keyword">if</span>(channel.isWritable())&#123;</span><br><span class="line">                channel.writeAndFlush(list);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">ChannelReadFinish</span><span class="params">(Channel channel，Buffer Buffer)</span></span>&#123;</span><br><span class="line">        List result = handleBuffer();<span class="comment">//处理数据</span></span><br><span class="line">        <span class="comment">//从cmdQueue取出future，并设值，future.done();</span></span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">ChannelWritable</span><span class="params">(Channel channel)</span></span>&#123;</span><br><span class="line">        channel.flush();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这样做，能够充分的利用pipeline来提高I/O能力，同时获取异步处理能力。</p>
<h4 id="2-7-6-多连接短连接的HttpClient"><a href="#2-7-6-多连接短连接的HttpClient" class="headerlink" title="2.7.6 多连接短连接的HttpClient**"></a>2.7.6 多连接短连接的HttpClient**</h4><p>类似于竞对抓取的项目，往往需要建立无数的HTTP短连接，然后抓取，然后销毁，当需要单机抓取上千网站线程数又受制的时候，怎么保证性能呢?</p>
<p>何不尝试NIO，单线程进行连接、写、读操作？如果连接、读、写操作系统没有能力处理，简单的注册一个事件，等待下次循环就好了。</p>
<p>如何存储不同的请求/响应呢？由于http是无状态没有版本的协议，又没有办法使用队列，好像办法不多。比较笨的办法是对于不同的socket，直接存储socket的引用作为map的key。</p>
<h4 id="2-7-7-常见的RPC框架，如Thrift，Dubbo"><a href="#2-7-7-常见的RPC框架，如Thrift，Dubbo" class="headerlink" title="2.7.7 常见的RPC框架，如Thrift，Dubbo**"></a>2.7.7 常见的RPC框架，如Thrift，Dubbo**</h4><p>这种框架内部一般维护了请求的协议和请求号，可以维护一个以请求号为key，结果的result为future的map，结合 <code>NIO</code> + <code>长连接</code> ，获取非常不错的性能。</p>
<h4 id="2-7-8-Proactor与Reactor"><a href="#2-7-8-Proactor与Reactor" class="headerlink" title="2.7.8 Proactor与Reactor**"></a>2.7.8 Proactor与Reactor**</h4><p>一般情况下，I/O 复用机制需要<strong>事件分发器</strong>（event dispatcher）。 事件分发器的作用，即将那些读写事件源分发给各读写事件的处理者，就像送快递的在楼下喊: 谁谁谁的快递到了， 快来拿吧！开发人员在开始的时候需要在分发器那里注册感兴趣的事件，并提供相应的<strong>处理者</strong>（event handler)，或者是<strong>回调函数</strong>；事件分发器在适当的时候，会将请求的事件分发给这些handler或者回调函数。</p>
<p>涉及到事件分发器的两种模式称为：<strong>Reactor</strong>和<strong>Proactor</strong>。 Reactor模式是基于同步I/O的，而Proactor模式是和异步I/O相关的。在Reactor模式中，事件分发器等待某个事件或者可应用或个操作的状态发生（比如文件描述符可读写，或者是socket可读写），事件分发器就把这个事件传给事先注册的事件处理函数或者回调函数，由后者来做实际的读写操作。</p>
<p>而在Proactor模式中，事件处理者（或者代由事件分发器发起）直接发起一个异步读写操作（相当于请求），而实际的工作是由操作系统来完成的。发起时，需要提供的参数包括用于存放读到数据的缓存区、读的数据大小或用于存放外发数据的缓存区，以及这个请求完后的回调函数等信息。事件分发器得知了这个请求，它默默等待这个请求的完成，然后转发完成事件给相应的事件处理者或者回调。举例来说，在Windows上事件处理者投递了一个异步IO操作（称为overlapped技术），事件分发器等IO Complete事件完成。这种异步模式的典型实现是基于操作系统底层异步API的，所以我们可称之为“系统级别”的或者“真正意义上”的异步，因为具体的读写是由操作系统代劳的。</p>
<p>举个例子，将有助于理解Reactor与Proactor二者的差异，以读操作为例（写操作类似）。</p>
<p>在Reactor中实现读</p>
<ul>
<li>注册读就绪事件和相应的事件处理器。</li>
<li>事件分发器等待事件。</li>
<li>事件到来，激活分发器，分发器调用事件对应的处理器。</li>
<li>事件处理器完成实际的读操作，处理读到的数据，注册新的事件，然后返还控制权。</li>
</ul>
<p>在Proactor中实现读：</p>
<ul>
<li>处理器发起异步读操作（注意：操作系统必须支持异步IO）。在这种情况下，处理器无视IO就绪事件，它关注的是完成事件。</li>
<li>事件分发器等待操作完成事件。</li>
<li>在分发器等待过程中，操作系统利用并行的内核线程执行实际的读操作，并将结果数据存入用户自定义缓冲区，最后通知事件分发器读操作完成。</li>
<li>事件分发器呼唤处理器。</li>
<li>事件处理器处理用户自定义缓冲区中的数据，然后启动一个新的异步操作，并将控制权返回事件分发器。</li>
</ul>
<p>可以看出，两个模式的相同点，都是对某个I/O事件的事件通知（即告诉某个模块，这个I/O操作可以进行或已经完成)。在结构上，两者也有相同点：事件分发器负责提交IO操作（异步)、查询设备是否可操作（同步)，然后当条件满足时，就回调handler；不同点在于，异步情况下（Proactor)，当回调handler时，表示I/O操作已经完成；同步情况下（Reactor)，回调handler时，表示I/O设备可以进行某个操作（ <code>can read</code> 或 <code>can write</code> )。</p>
<p>下面，我们将尝试应对为Proactor和Reactor模式建立可移植框架的挑战。在改进方案中，我们将Reactor原来位于事件处理器内的Read/Write操作移至分发器（不妨将这个思路称为“模拟异步”），以此寻求将Reactor多路同步I/O转化为模拟异步I/O。以读操作为例子，改进过程如下： - 注册读就绪事件和相应的事件处理器。并为分发器提供数据缓冲区地址，需要读取数据量等信息。 - 分发器等待事件（如在 <code>select()</code> 上等待）。 - 事件到来，激活分发器。分发器执行一个非阻塞读操作（它有完成这个操作所需的全部信息），最后调用对应处理器。 - 事件处理器处理用户自定义缓冲区的数据，注册新的事件（当然同样要给出数据缓冲区地址，需要读取的数据量等信息），最后将控制权返还分发器。 如我们所见，通过对多路I/O模式功能结构的改造，可将Reactor转化为Proactor模式。改造前后，模型实际完成的工作量没有增加，只不过参与者间对工作职责稍加调换。没有工作量的改变，自然不会造成性能的削弱。对如下各步骤的比较，可以证明工作量的恒定：</p>
<p>标准/典型的Reactor：</p>
<ul>
<li>步骤1：等待事件到来（Reactor负责）。</li>
<li>步骤2：将读就绪事件分发给用户定义的处理器（Reactor负责）。</li>
<li>步骤3：读数据（用户处理器负责）。</li>
<li>步骤4：处理数据（用户处理器负责）。</li>
</ul>
<p>改进实现的模拟Proactor：</p>
<ul>
<li>步骤1：等待事件到来（Proactor负责）。</li>
<li>步骤2：得到读就绪事件，执行读数据（现在由Proactor负责）。</li>
<li>步骤3：将读完成事件分发给用户处理器（Proactor负责）。</li>
<li>步骤4：处理数据（用户处理器负责）。</li>
</ul>
<p>对于不提供异步I/O API的操作系统来说，这种办法可以隐藏Socket API的交互细节，从而对外暴露一个完整的异步接口。借此，我们就可以进一步构建完全可移植的，平台无关的，有通用对外接口的解决方案。</p>
<p>代码示例如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">interface</span> <span class="title">ChannelHandler</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">channelReadComplate</span><span class="params">(Channel channel，<span class="keyword">byte</span>[] data)</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">channelWritable</span><span class="params">(Channel channel)</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Channel</span></span>&#123;</span><br><span class="line">    Socket socket;</span><br><span class="line">    Event event;<span class="comment">//读，写或者连接</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//IO线程主循环：</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">IoThread</span> <span class="keyword">extends</span> <span class="title">Thread</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span></span>&#123;</span><br><span class="line">        Channel channel;</span><br><span class="line">        <span class="keyword">while</span>(channel=Selector.select())&#123;<span class="comment">//选择就绪的事件和对应的连接</span></span><br><span class="line">            <span class="keyword">if</span>(channel.event==accept)&#123;</span><br><span class="line">                registerNewChannelHandler(channel);<span class="comment">//如果是新连接，则注册一个新的读写处理器</span></span><br><span class="line">                Selector.interested(read);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span>(channel.event==write)&#123;</span><br><span class="line">                getChannelHandler(channel).channelWritable(channel);<span class="comment">//如果可以写，则执行写事件</span></span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span>(channel.event==read)&#123;</span><br><span class="line">                <span class="keyword">byte</span>[] data = channel.read();</span><br><span class="line">                <span class="keyword">if</span>(channel.read()==<span class="number">0</span>)<span class="comment">//没有读到数据，表示本次数据读完了</span></span><br><span class="line">                &#123;</span><br><span class="line">                    getChannelHandler(channel).channelReadComplate(channel，data);<span class="comment">//处理读完成事件</span></span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span>(过载保护)&#123;</span><br><span class="line">                    Selector.interested(read);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    Map&lt;Channel，ChannelHandler&gt; handlerMap;<span class="comment">//所有channel的对应事件处理器</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<h4 id="2-7-9-Selector-wakeup"><a href="#2-7-9-Selector-wakeup" class="headerlink" title="2.7.9 Selector.wakeup()**"></a>2.7.9 Selector.wakeup()**</h4><p>主要作用？</p>
<ul>
<li>解除阻塞在Selector.select()/select(long)上的线程，立即返回。</li>
<li>两次成功的select之间多次调用wakeup等价于一次调用。</li>
<li>如果当前没有阻塞在select上，则本次wakeup调用将作用于下一次select——“记忆”作用。</li>
</ul>
<p>为什么要唤醒？</p>
<ul>
<li>注册了新的channel或者事件。</li>
<li>channel关闭，取消注册。</li>
<li>优先级更高的事件触发（如定时器事件），希望及时处理。</li>
</ul>
<p>原理？</p>
<p>Linux上利用pipe调用创建一个管道，Windows上则是一个loopback的tcp连接。这是因为win32的管道无法加入select的fd set，将管道或者TCP连接加入select fd set。</p>
<p>wakeup往管道或者连接写入一个字节，阻塞的select因为有I/O事件就绪，立即返回。可见，wakeup的调用开销不可忽视。</p>
<h4 id="2-7-10-Buffer的选择"><a href="#2-7-10-Buffer的选择" class="headerlink" title="2.7.10 Buffer的选择**"></a>2.7.10 Buffer的选择**</h4><p>通常情况下，操作系统的一次写操作分为两步： </p>
<ol>
<li><p>将数据从用户空间拷贝到系统空间。 </p>
</li>
<li><p>从系统空间往网卡写。同理，读操作也分为两步：</p>
<p> ① 将数据从网卡拷贝到系统空间； </p>
<p> ② 将数据从系统空间拷贝到用户空间。</p>
</li>
</ol>
<p>对于NIO来说，缓存的使用可以使用DirectByteBuffer和HeapByteBuffer。如果使用了DirectByteBuffer，一般来说可以减少一次系统空间到用户空间的拷贝。但Buffer创建和销毁的成本更高，更不宜维护，通常会用内存池来提高性能。</p>
<p>如果数据量比较小的中小应用情况下，可以考虑使用heapBuffer；反之可以用directBuffer。</p>
<p>使用NIO != 高性能，当连接数&lt;1000，并发程度不高或者局域网环境下NIO并没有显著的性能优势。</p>
<p>NIO并没有完全屏蔽平台差异，它仍然是基于各个操作系统的I/O系统实现的，差异仍然存在。使用NIO做网络编程构建事件驱动模型并不容易，陷阱重重。</p>
<p>推荐大家使用成熟的NIO框架，如Netty，MINA等。解决了很多NIO的陷阱，并屏蔽了操作系统的差异，有较好的性能和编程模型。</p>
<p>最后总结一下到底NIO给我们带来了些什么：</p>
<ul>
<li>事件驱动模型</li>
<li>避免多线程</li>
<li>单线程处理多任务</li>
<li>非阻塞I/O，I/O读写不再阻塞，而是返回0</li>
<li>基于block的传输，通常比基于流的传输更高效</li>
<li>更高级的IO函数，zero-copy</li>
<li>IO多路复用大大提高了Java网络应用的可伸缩性和实用性</li>
</ul>
<h4 id="2-7-11-源码"><a href="#2-7-11-源码" class="headerlink" title="2.7.11 源码**"></a>2.7.11 源码**</h4><p>Selector是通过调用静态工厂方法 <code>open()</code> 来实例化的，这个从前面的代码里面也看到了，选择器不是像通道或流那样的基本I/O对象—-数据从来没有通过他们进行传递。</p>
<p>通道是调用 <code>register()</code> 方法注册到选择器上的，从上面代码里可以看到 <code>register()</code> 方法接受一个Selector对象作为参数，以及一个名为 <code>ops</code> 的整数型参数，第二个参数表示关心的通道操作。在JDK1.4中，有四种被定义的可选择操作：<strong>读</strong>（read）、<strong>写</strong>（write）、<strong>连接</strong>（connect）和<strong>接受</strong>（accept）。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">Selector</span> <span class="keyword">implements</span> <span class="title">Closeable</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="title">Selector</span><span class="params">()</span> </span>&#123; &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Selector <span class="title">open</span><span class="params">()</span> <span class="keyword">throws</span> IOException </span>&#123;<span class="comment">//创建一个Selector对象，打开选择器</span></span><br><span class="line">        <span class="keyword">return</span> SelectorProvider.provider().openSelector();</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">boolean</span> <span class="title">isOpen</span><span class="params">()</span></span>;<span class="comment">//判断Selector对象是否打开</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> SelectorProvider <span class="title">provider</span><span class="params">()</span></span>;<span class="comment">//返回创建此channel的provider</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> Set&lt;SelectionKey&gt; <span class="title">keys</span><span class="params">()</span></span>;<span class="comment">//返回此选择器的所有键集合，键集合不能直接修改，只能通过取消SelectionKey注销SocketChannel的方法移除SelectionKey</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> Set&lt;SelectionKey&gt; <span class="title">selectedKeys</span><span class="params">()</span></span>;<span class="comment">//返回此选择器的选定键集合，键可以直接移除，但不能直接加入键集合</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">int</span> <span class="title">selectNow</span><span class="params">()</span> <span class="keyword">throws</span> IOException</span>;<span class="comment">//选择一组准备好进行I/O操作的键，此方法执行非阻塞的选择操作，若自上个选择操作之后没有通道可以选择了就返回0，调用此方法会清除之前调用wakeup()的效果。</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">int</span> <span class="title">select</span><span class="params">(<span class="keyword">long</span> timeout)</span> <span class="keyword">throws</span> IOException</span>;<span class="comment">//选择一组准备好进行I/O操作的键，此方法执行非阻塞的选择操作，只有选择了至少一个通道后，或当前线程被中断，或选择器调用了wakeup()后才会返回</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">int</span> <span class="title">select</span><span class="params">()</span> <span class="keyword">throws</span> IOException</span>;<span class="comment">//选择一组准备好进行I/O操作的键，此方法执行阻塞的选择操作，只有选择了至少一个通道后，或当前线程被中断，或选择器调用了wakeup()后才会返回</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> Selector <span class="title">wakeup</span><span class="params">()</span></span>;<span class="comment">//使选择器当前尚未返回的第一个选择操作立即返回。若另一个线程在当前被select()或select(long timeout)阻塞，调用此方法会立即返回选择器。若当前没有正在进行的选择操作，则下次调用这些方法时其中一个会立即返回，除非同时调用selectNow()。除非同时再次调用此方法，否则select()或select(long timeout)方法的后续调用仍会继续阻塞。在两个连续选择之间多次调用此方法，效果等同于只调用一次。</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title">close</span><span class="params">()</span> <span class="keyword">throws</span> IOException</span>;<span class="comment">//关闭选择器。</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>选择键源码如下。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">SelectionKey</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="title">SelectionKey</span><span class="params">()</span> </span>&#123; &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// -- Channel and selector operations --</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> SelectableChannel <span class="title">channel</span><span class="params">()</span></span>;<span class="comment">//返回该SelectionKey对应的channel。</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> Selector <span class="title">selector</span><span class="params">()</span></span>;<span class="comment">//返回该SelectionKey对应的Selector。</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">boolean</span> <span class="title">isValid</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title">cancel</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// -- Operation-set accessors --</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">int</span> <span class="title">interestOps</span><span class="params">()</span></span>;<span class="comment">//返回代表需要Selector监控的IO操作的bit mask</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> SelectionKey <span class="title">interestOps</span><span class="params">(<span class="keyword">int</span> ops)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">int</span> <span class="title">readyOps</span><span class="params">()</span></span>;<span class="comment">//返回一个bit mask，代表在相应channel上可以进行的IO操作。</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// -- Operation bits and bit-testing convenience methods --</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> OP_READ = <span class="number">1</span> &lt;&lt; <span class="number">0</span>;<span class="comment">//监听事件-读就绪</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> OP_WRITE = <span class="number">1</span> &lt;&lt; <span class="number">2</span>;<span class="comment">//监听事件-写就绪</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> OP_CONNECT = <span class="number">1</span> &lt;&lt; <span class="number">3</span>;<span class="comment">//监听事件-连接就绪</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> OP_ACCEPT = <span class="number">1</span> &lt;&lt; <span class="number">4</span>;<span class="comment">//监听事件-接收就绪</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">isReadable</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> (readyOps() &amp; OP_READ) != <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">isWritable</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> (readyOps() &amp; OP_WRITE) != <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">isConnectable</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> (readyOps() &amp; OP_CONNECT) != <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">isAcceptable</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> (readyOps() &amp; OP_ACCEPT) != <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// -- Attachments --</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">volatile</span> Object attachment;<span class="comment">//</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> AtomicReferenceFieldUpdater&lt;SelectionKey,Object&gt; attachmentUpdater = AtomicReferenceFieldUpdater.newUpdater(SelectionKey.class, Object.class, <span class="string">&quot;attachment&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">final</span> Object <span class="title">attach</span><span class="params">(Object ob)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> attachmentUpdater.getAndSet(<span class="keyword">this</span>, ob);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">final</span> Object <span class="title">attachment</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> attachment;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ol>
<li><p>就像前面提到的，一个键表示了一个特定的通道对象和一个特定的选择器对象之间的注册关系，<code>channel()</code> 方法和 <code>selector()</code> 方法反映了这种关系。</p>
</li>
<li><p>开发者可以使用 <code>cancel()</code> 方法终结这种关系，可以使用 <code>isValid()</code> 方法来检查这种有效的关系是否仍然存在，可以使用 <code>readyOps()</code> 方法来获取相关的通道已经就绪的操作。</p>
</li>
<li><p>第2点有提到 <code>readyOps()</code> 方法，不过我们往往不需要使用这个方法，SelectionKey类定义了四个便于使用的布尔方法来为开发者测试通道的就绪状态，例如：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (key.isWritable())&#123;...&#125;</span><br></pre></td></tr></table></figure>

<p>这种写法就等价于：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> ((key.readyOps() &amp; SelectionKeys.OPWRITE) != <span class="number">0</span>)&#123;...&#125;</span><br></pre></td></tr></table></figure>

<p><code>isWritable()</code> 、<code>isReadable()</code> 、<code>isConnectable()</code> 、<code>isAcceptable()</code> 四个方法在任意一个SelectionKey对象上都能安全地调用。</p>
</li>
<li><p>当通道关闭时，所有相关的键会自动取消（一个通道可以被注册到多个选择器上）；当选择器关闭时，所有被注册到该选择器的通道都会被注销并且相关的键立即被取消。</p>
</li>
</ol>
<p>接着就是Selector的核心<strong>选择过程</strong>了。基本上来说，选择器是对 <code>select()</code> 、<code>poll()</code> 、<code>epoll()</code> 等本地调用或者类似的操作系统特定的系统调用的一个包装。但是Selector所做的不仅仅是简单地向本地代码传送参数，每个操作都有特定的过程，对这个过程的理解是合理地管理键和它们所表示的状态信息的基础。</p>
<p>选择操作是当三种形式的 <code>select()</code> 中的任意一种被调用时，由选择器执行的。不管是哪一种形式的调用，下面步骤将被执行：</p>
<ol>
<li>已取消的键的集合将会被检查。如果它是非空的，每个已取消的键的集合中的键将从另外两个集合中移除，并且相关的通道将被注销。此步骤结束，已取消的键的集合将是空的。</li>
<li>已注册的键的集合中的键的interest集合将被检查，此步骤结束，对interest集合的改动不会影响剩余的检查过程。一旦就绪条件被定下来，底层操作系统将会进行查询，以确定每个通道所关心的操作的真实就绪状态，依赖于特定的 <code>select()</code> 方法调用，如果没有通道已经准备好，线程可能会在这时阻塞，通常会有一个超时值。</li>
<li>步骤2可能会花费很长时间，特别是线程处于阻塞状态时。与该选择器相关的键可能会同时被取消，当步骤2结束时，步骤1将重新执行，以完成任意一个在选择进行的过程中，键已经被取消的通道的注册。</li>
<li>select操作的返回值不是已准备好的通道的总数，而是从上一个 <code>select()</code> 调用之后进入就绪状态的通道的数量。之前的调用中就绪的，并且在本次调用中仍然就绪的通道不会被计入，而那些在前一次调用中已经就绪但已经不再处于就绪状态的通道也不会被计入。</li>
</ol>
<h4 id="2-7-12-案例"><a href="#2-7-12-案例" class="headerlink" title="2.7.12 案例**"></a>2.7.12 案例**</h4><p>服务端：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">     <span class="comment">//创建SocketChannel和Selector对象，注册socketChannel到selector</span></span><br><span class="line">     ServerSocketChannel ssc = ServerSocketChannel.open();</span><br><span class="line">     ssc.socket().bind(<span class="keyword">new</span> InetSocketAddress(<span class="string">&quot;127.0.0.1&quot;</span>,<span class="number">8000</span>));</span><br><span class="line">     ssc.configureBlocking(<span class="keyword">false</span>);</span><br><span class="line">     Selector selector = Selector.open();</span><br><span class="line">     ssc.register(selector,SelectionKey.OP_ACCEPT);</span><br><span class="line"></span><br><span class="line">     <span class="comment">//创建读写缓冲区</span></span><br><span class="line">     ByteBuffer readBuffer = ByteBuffer.allocate(<span class="number">1024</span>);</span><br><span class="line">     ByteBuffer writeBuffer = ByteBuffer.allocate(<span class="number">128</span>);</span><br><span class="line">     writeBuffer.put(<span class="string">&quot;received&quot;</span>.getBytes());</span><br><span class="line">     writeBuffer.flip();</span><br><span class="line"></span><br><span class="line">     <span class="keyword">while</span> (<span class="keyword">true</span>)&#123;</span><br><span class="line">         <span class="keyword">int</span> ready = selector.select();</span><br><span class="line">         Set&lt;SelectionKey&gt; keys = selector.selectedKeys();</span><br><span class="line">         Iterator&lt;SelectionKey&gt; it = keys.iterator();</span><br><span class="line"></span><br><span class="line">         <span class="keyword">while</span> (it.hasNext())&#123;</span><br><span class="line">             SelectionKey key = it.next();</span><br><span class="line">             it.remove();</span><br><span class="line"></span><br><span class="line">             <span class="keyword">if</span>(key.isAcceptable())&#123;</span><br><span class="line">                 <span class="comment">// 创建新的连接，并且把连接注册到selector上，而且，</span></span><br><span class="line">                 <span class="comment">// 声明这个channel只对读操作感兴趣。</span></span><br><span class="line">                 SocketChannel socketChannel = ssc.accept();</span><br><span class="line">                 socketChannel.configureBlocking(<span class="keyword">false</span>);</span><br><span class="line">                 socketChannel.register(selector, SelectionKey.OP_READ);</span><br><span class="line">             &#125;<span class="keyword">else</span> <span class="keyword">if</span>(key.isReadable())&#123;</span><br><span class="line">                 SocketChannel socketChannel = (SocketChannel) key.channel();</span><br><span class="line">                 readBuffer.clear();</span><br><span class="line">                 socketChannel.read(readBuffer);</span><br><span class="line"></span><br><span class="line">                 readBuffer.flip();</span><br><span class="line">                 System.out.println(<span class="string">&quot;received : &quot;</span> + <span class="keyword">new</span> String(readBuffer.array()));</span><br><span class="line">                 key.interestOps(SelectionKey.OP_WRITE);</span><br><span class="line">             &#125;<span class="keyword">else</span> <span class="keyword">if</span>(key.isWritable())&#123;</span><br><span class="line">                 writeBuffer.rewind();</span><br><span class="line">                 SocketChannel socketChannel = (SocketChannel) key.channel();</span><br><span class="line">                 socketChannel.write(writeBuffer);</span><br><span class="line">                 key.interestOps(SelectionKey.OP_READ);</span><br><span class="line">             &#125;</span><br><span class="line">         &#125;</span><br><span class="line">     &#125;</span><br><span class="line"></span><br><span class="line"> &#125;<span class="keyword">catch</span> (IOException ex)&#123;</span><br><span class="line">     ex.printStackTrace();</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure>

<p>客户端：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">SocketChannel socketChannel = <span class="keyword">null</span>;</span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">    socketChannel = SocketChannel.open();</span><br><span class="line">    socketChannel.connect(<span class="keyword">new</span> InetSocketAddress(<span class="string">&quot;127.0.0.1&quot;</span>, <span class="number">8000</span>));</span><br><span class="line"></span><br><span class="line">    ByteBuffer writeBuffer1 = ByteBuffer.allocate(<span class="number">128</span>);</span><br><span class="line">    ByteBuffer writeBuffer2 = ByteBuffer.allocate(<span class="number">128</span>);</span><br><span class="line">    ByteBuffer readBuffer = ByteBuffer.allocate(<span class="number">16</span>);</span><br><span class="line">    writeBuffer1.put(<span class="string">&quot;hello &quot;</span>.getBytes());</span><br><span class="line">    writeBuffer2.put(<span class="string">&quot;world&quot;</span>.getBytes());</span><br><span class="line"></span><br><span class="line">    writeBuffer1.flip();</span><br><span class="line">    writeBuffer2.flip();</span><br><span class="line">    ByteBuffer[] bufferArray = &#123;writeBuffer1, writeBuffer2&#125;;</span><br><span class="line">    <span class="keyword">while</span> (<span class="keyword">true</span>)&#123;</span><br><span class="line">        writeBuffer1.rewind();</span><br><span class="line">        writeBuffer2.rewind();</span><br><span class="line">        socketChannel.write(bufferArray);</span><br><span class="line">        readBuffer.clear();</span><br><span class="line">        socketChannel.read(readBuffer);</span><br><span class="line">        <span class="comment">//socketChannel.close();</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">    ex.printStackTrace();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>运行结果如下：</p>
<figure class="highlight ada"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">received : <span class="type">hello</span> world </span><br><span class="line">received : <span class="type">hello</span> world </span><br><span class="line">received : <span class="type">hello</span> world </span><br><span class="line">received : <span class="type">hello</span> world </span><br><span class="line">received : <span class="type">hello</span> world </span><br><span class="line">received : <span class="type">hello</span> world </span><br><span class="line">received : <span class="type">hello</span> world </span><br><span class="line">received : <span class="type">hello</span> world </span><br><span class="line">received : <span class="type">hello</span> world </span><br><span class="line">received : <span class="type">hello</span> world </span><br><span class="line">received : <span class="type">hello</span> world </span><br><span class="line">received : <span class="type">hello</span> world </span><br><span class="line">received : <span class="type">hello</span> world</span><br></pre></td></tr></table></figure>

<hr>
<h2 id="第三节-文件加锁机制"><a href="#第三节-文件加锁机制" class="headerlink" title="第三节 文件加锁机制**"></a>第三节 文件加锁机制**</h2><p>实际使用中不难避免同时多个执行的程序对文件读写的情况，所以需要某种机制来避免这类情况造成文件损坏，文件锁可以控制对文件或文件范围内字节的访问。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">	Path path = Paths.get(<span class="string">&quot;D:/test.txt&quot;</span>);</span><br><span class="line">	FileChannel fc = FileChannel.open(path);</span><br><span class="line">	FileLock lock1 = fc.lock();<span class="comment">//会阻塞直到获得锁</span></span><br><span class="line">	FileLock lock2 = fc.tryLock();<span class="comment">//立即返回，要么返回锁，要么返回null</span></span><br><span class="line">&#125; <span class="keyword">catch</span> (IOException ex)&#123;</span><br><span class="line">          ex.printStackTrace();</span><br><span class="line">      &#125;</span><br></pre></td></tr></table></figure>

<p>源码如下。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> FileLock <span class="title">lock</span><span class="params">()</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">       <span class="keyword">return</span> lock(<span class="number">0L</span>, Long.MAX_VALUE, <span class="keyword">false</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> FileLock <span class="title">lock</span><span class="params">(<span class="keyword">long</span> position, <span class="keyword">long</span> size, <span class="keyword">boolean</span> shared)</span> <span class="keyword">throws</span> IOException</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> FileLock <span class="title">tryLock</span><span class="params">()</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">	<span class="keyword">return</span> tryLock(<span class="number">0L</span>, Long.MAX_VALUE, <span class="keyword">false</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> FileLock <span class="title">tryLock</span><span class="params">(<span class="keyword">long</span> position, <span class="keyword">long</span> size, <span class="keyword">boolean</span> shared)</span> <span class="keyword">throws</span> IOException</span>;</span><br></pre></td></tr></table></figure>

<p>两种调用都可以只锁定文件部分内容(假如size设定到文件尾，新增的数据是默认不加锁，可以通过 <code>Long.MAX_VALUE</code>来锁所有字节)，<code>share</code> 为false表示锁目的是读写，为true表示为共享锁，允许多进程读入，并阻止获取独占锁的行为。</p>
<p>释放锁和释放资源一样，都可以利用try-resource方式确保释放，参考<a href="../2019051101.html" title="Title">try-catch，try-with-resource</a>）。</p>
<p>文件加锁依赖操作系统，不同操作系统会有不同的设计和限制锁机制，文件锁归虚拟机所有，所以所有在同一虚拟机上启动的多个程序不可能同时获得同一个文件的锁。</p>
<hr>
<h2 id="第四节-一些源码"><a href="#第四节-一些源码" class="headerlink" title="第四节 一些源码**"></a>第四节 一些源码**</h2><h3 id="源码-FileChannel"><a href="#源码-FileChannel" class="headerlink" title="源码-FileChannel**"></a>源码-FileChannel**</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> java.nio.channels;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">FileChannel</span> <span class="keyword">extends</span> <span class="title">AbstractInterruptibleChannel</span> <span class="keyword">implements</span> <span class="title">SeekableByteChannel</span>, <span class="title">GatheringByteChannel</span>, <span class="title">ScatteringByteChannel</span> </span>&#123;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="title">FileChannel</span><span class="params">()</span> </span>&#123; &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> FileChannel <span class="title">open</span><span class="params">(Path path,</span></span></span><br><span class="line"><span class="params"><span class="function">                                   Set&lt;? extends OpenOption&gt; options,</span></span></span><br><span class="line"><span class="params"><span class="function">                                   FileAttribute&lt;?&gt;... attrs)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">        FileSystemProvider provider = path.getFileSystem().provider();</span><br><span class="line">        <span class="keyword">return</span> provider.newFileChannel(path, options, attrs);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="meta">@SuppressWarnings(&#123;&quot;unchecked&quot;, &quot;rawtypes&quot;&#125;)</span> <span class="comment">// generic array construction</span></span><br><span class="line">	<span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> FileAttribute&lt;?&gt;[] NO_ATTRIBUTES = <span class="keyword">new</span> FileAttribute[<span class="number">0</span>];</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> FileChannel <span class="title">open</span><span class="params">(Path path, OpenOption... options)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">        Set&lt;OpenOption&gt; set = <span class="keyword">new</span> HashSet&lt;&gt;(options.length);</span><br><span class="line">        Collections.addAll(set, options);</span><br><span class="line">        <span class="keyword">return</span> open(path, set, NO_ATTRIBUTES);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// -- Channel operations --</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">int</span> <span class="title">read</span><span class="params">(ByteBuffer dst)</span> <span class="keyword">throws</span> IOException</span>;</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">long</span> <span class="title">read</span><span class="params">(ByteBuffer[] dsts, <span class="keyword">int</span> offset, <span class="keyword">int</span> length)</span> <span class="keyword">throws</span> IOException</span>;</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">long</span> <span class="title">read</span><span class="params">(ByteBuffer[] dsts)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> read(dsts, <span class="number">0</span>, dsts.length);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">int</span> <span class="title">write</span><span class="params">(ByteBuffer src)</span> <span class="keyword">throws</span> IOException</span>;</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">long</span> <span class="title">write</span><span class="params">(ByteBuffer[] srcs, <span class="keyword">int</span> offset, <span class="keyword">int</span> length)</span> <span class="keyword">throws</span> IOException</span>;</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">long</span> <span class="title">write</span><span class="params">(ByteBuffer[] srcs)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> write(srcs, <span class="number">0</span>, srcs.length);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">	<span class="comment">// -- Other operations --</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">long</span> <span class="title">position</span><span class="params">()</span> <span class="keyword">throws</span> IOException</span>;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> FileChannel <span class="title">position</span><span class="params">(<span class="keyword">long</span> newPosition)</span> <span class="keyword">throws</span> IOException</span>;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">long</span> <span class="title">size</span><span class="params">()</span> <span class="keyword">throws</span> IOException</span>;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> FileChannel <span class="title">truncate</span><span class="params">(<span class="keyword">long</span> size)</span> <span class="keyword">throws</span> IOException</span>;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title">force</span><span class="params">(<span class="keyword">boolean</span> metaData)</span> <span class="keyword">throws</span> IOException</span>;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">long</span> <span class="title">transferTo</span><span class="params">(<span class="keyword">long</span> position, <span class="keyword">long</span> count,</span></span></span><br><span class="line"><span class="params"><span class="function">                                    WritableByteChannel target)</span> <span class="keyword">throws</span> IOException</span>;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">long</span> <span class="title">transferFrom</span><span class="params">(ReadableByteChannel src,</span></span></span><br><span class="line"><span class="params"><span class="function">                                      <span class="keyword">long</span> position, <span class="keyword">long</span> count)</span> <span class="keyword">throws</span> IOException</span>;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">int</span> <span class="title">read</span><span class="params">(ByteBuffer dst, <span class="keyword">long</span> position)</span> <span class="keyword">throws</span> IOException</span>;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">int</span> <span class="title">write</span><span class="params">(ByteBuffer src, <span class="keyword">long</span> position)</span> <span class="keyword">throws</span> IOException</span>;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// -- Memory-mapped buffers --</span></span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">MapMode</span> </span>&#123;</span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">         * Mode for a read-only mapping.</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> MapMode READ_ONLY = <span class="keyword">new</span> MapMode(<span class="string">&quot;READ_ONLY&quot;</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">         * Mode for a read/write mapping.</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> MapMode READ_WRITE = <span class="keyword">new</span> MapMode(<span class="string">&quot;READ_WRITE&quot;</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">         * Mode for a private (copy-on-write) mapping.</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> MapMode PRIVATE = <span class="keyword">new</span> MapMode(<span class="string">&quot;PRIVATE&quot;</span>);</span><br><span class="line"></span><br><span class="line">		<span class="keyword">private</span> <span class="keyword">final</span> String name;</span><br><span class="line"></span><br><span class="line">		<span class="function"><span class="keyword">private</span> <span class="title">MapMode</span><span class="params">(String name)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">this</span>.name = name;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="function"><span class="keyword">public</span> String <span class="title">toString</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            <span class="keyword">return</span> name;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> MappedByteBuffer <span class="title">map</span><span class="params">(MapMode mode,</span></span></span><br><span class="line"><span class="params"><span class="function">                                         <span class="keyword">long</span> position, <span class="keyword">long</span> size)</span> <span class="keyword">throws</span> IOException</span>;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// -- Locks --</span></span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> FileLock <span class="title">lock</span><span class="params">(<span class="keyword">long</span> position, <span class="keyword">long</span> size, <span class="keyword">boolean</span> shared)</span> <span class="keyword">throws</span> IOException</span>;</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">final</span> FileLock <span class="title">lock</span><span class="params">()</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> lock(<span class="number">0L</span>, Long.MAX_VALUE, <span class="keyword">false</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> FileLock <span class="title">tryLock</span><span class="params">(<span class="keyword">long</span> position, <span class="keyword">long</span> size, <span class="keyword">boolean</span> shared)</span> <span class="keyword">throws</span> IOException</span>;</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">final</span> FileLock <span class="title">tryLock</span><span class="params">()</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> tryLock(<span class="number">0L</span>, Long.MAX_VALUE, <span class="keyword">false</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="源码-SocketChannel"><a href="#源码-SocketChannel" class="headerlink" title="源码-SocketChannel**"></a>源码-SocketChannel**</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">SocketChannel</span> <span class="keyword">extends</span> <span class="title">AbstractSelectableChannel</span> <span class="keyword">implements</span> <span class="title">ByteChannel</span>, <span class="title">ScatteringByteChannel</span>, <span class="title">GatheringByteChannel</span>, <span class="title">NetworkChannel</span> </span>&#123;</span><br><span class="line">	<span class="function"><span class="keyword">protected</span> <span class="title">SocketChannel</span><span class="params">(SelectorProvider provider)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>(provider);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> SocketChannel <span class="title">open</span><span class="params">()</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> SelectorProvider.provider().openSocketChannel();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> SocketChannel <span class="title">open</span><span class="params">(SocketAddress remote)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">        SocketChannel sc = open();</span><br><span class="line">		<span class="keyword">try</span> &#123;</span><br><span class="line">            sc.connect(remote);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Throwable x) &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                sc.close();</span><br><span class="line">            &#125; <span class="keyword">catch</span> (Throwable suppressed) &#123;</span><br><span class="line">                x.addSuppressed(suppressed);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">throw</span> x;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">assert</span> sc.isConnected();</span><br><span class="line">        <span class="keyword">return</span> sc;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">int</span> <span class="title">validOps</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> (SelectionKey.OP_READ | SelectionKey.OP_WRITE | SelectionKey.OP_CONNECT);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// -- Socket-specific operations --</span></span><br><span class="line">	<span class="meta">@Override</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> SocketChannel <span class="title">bind</span><span class="params">(SocketAddress local)</span> <span class="keyword">throws</span> IOException</span>;</span><br><span class="line"></span><br><span class="line">	<span class="meta">@Override</span></span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">abstract</span> &lt;T&gt; <span class="function">SocketChannel <span class="title">setOption</span><span class="params">(SocketOption&lt;T&gt; name, T value)</span> <span class="keyword">throws</span> IOException</span>;</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> SocketChannel <span class="title">shutdownInput</span><span class="params">()</span> <span class="keyword">throws</span> IOException</span>;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> SocketChannel <span class="title">shutdownOutput</span><span class="params">()</span> <span class="keyword">throws</span> IOException</span>;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> Socket <span class="title">socket</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">boolean</span> <span class="title">isConnected</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">boolean</span> <span class="title">isConnectionPending</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">boolean</span> <span class="title">connect</span><span class="params">(SocketAddress remote)</span> <span class="keyword">throws</span> IOException</span>;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">boolean</span> <span class="title">finishConnect</span><span class="params">()</span> <span class="keyword">throws</span> IOException</span>;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> SocketAddress <span class="title">getRemoteAddress</span><span class="params">()</span> <span class="keyword">throws</span> IOException</span>;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// -- ByteChannel operations --</span></span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">int</span> <span class="title">read</span><span class="params">(ByteBuffer dst)</span> <span class="keyword">throws</span> IOException</span>;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">long</span> <span class="title">read</span><span class="params">(ByteBuffer[] dsts, <span class="keyword">int</span> offset, <span class="keyword">int</span> length)</span> <span class="keyword">throws</span> IOException</span>;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">long</span> <span class="title">read</span><span class="params">(ByteBuffer[] dsts)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> read(dsts, <span class="number">0</span>, dsts.length);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">int</span> <span class="title">write</span><span class="params">(ByteBuffer src)</span> <span class="keyword">throws</span> IOException</span>;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">long</span> <span class="title">write</span><span class="params">(ByteBuffer[] srcs, <span class="keyword">int</span> offset, <span class="keyword">int</span> length)</span> <span class="keyword">throws</span> IOException</span>;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">long</span> <span class="title">write</span><span class="params">(ByteBuffer[] srcs)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> write(srcs, <span class="number">0</span>, srcs.length);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">	<span class="meta">@Override</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> SocketAddress <span class="title">getLocalAddress</span><span class="params">()</span> <span class="keyword">throws</span> IOException</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<hr>
<p>参考：</p>
<p>🔗《Java核心技术 卷Ⅱ》</p>
<p>🔗 <a target="_blank" rel="noopener" href="https://blog.csdn.net/SkydivingWang/article/details/74917897">理解IO多路复用</a></p>
<p>🔗 <a target="_blank" rel="noopener" href="https://www.cnblogs.com/snailclimb/p/9086334.html">Java NIO 之 Selector 选择器</a></p>
<p>🔗 <a target="_blank" rel="noopener" href="http://tutorials.jenkov.com/java-nio/channels.html">Java NIO Channel</a></p>
<p>🔗 <a target="_blank" rel="noopener" href="https://www.cnblogs.com/xiaoxi/p/6525396.html">Java NIO1：浅谈I/O模型</a></p>
<p>🔗 <a target="_blank" rel="noopener" href="https://www.cnblogs.com/xiaoxi/p/6534926.html">Java NIO2：NIO概述</a></p>
<p>🔗 <a target="_blank" rel="noopener" href="https://www.cnblogs.com/xiaoxi/p/6542594.html">Java NIO3：缓冲区Buffer</a></p>
<p>🔗 <a target="_blank" rel="noopener" href="https://www.cnblogs.com/xiaoxi/p/6553706.html">Java NIO4：缓冲区Buffer(续)</a></p>
<p>🔗 <a target="_blank" rel="noopener" href="https://www.cnblogs.com/xiaoxi/p/6559688.html">Java NIO5：通道和文件通道</a></p>
<p>🔗 <a target="_blank" rel="noopener" href="https://www.cnblogs.com/xiaoxi/p/6576588.html">Java NIO：IO与NIO的区别</a></p>
<p>🔗 <a target="_blank" rel="noopener" href="https://www.cnblogs.com/xiaoxi/p/6604658.html">Java NIO6：选择器1——理论篇</a></p>
<p>🔗 <a target="_blank" rel="noopener" href="https://www.zhihu.com/question/19732473/answer/241673170">怎样理解阻塞非阻塞与同步异步的区别？萧萧</a></p>
<p>🔗 <a target="_blank" rel="noopener" href="https://tech.meituan.com/2016/11/04/nio.html">Java NIO浅析</a></p>

    </div>

    
    
    
      
  <div class="popular-posts-header">相关文章</div>
  <ul class="popular-posts">
    <li class="popular-posts-item">
      <div class="popular-posts-title"><a href="\2019032101.html" rel="bookmark">IO流与文件</a></div>
    </li>
    <li class="popular-posts-item">
      <div class="popular-posts-title"><a href="\2020090401.html" rel="bookmark">职业规划</a></div>
    </li>
    <li class="popular-posts-item">
      <div class="popular-posts-title"><a href="\2020070801.html" rel="bookmark">ConcurrentSkipListMap</a></div>
    </li>
    <li class="popular-posts-item">
      <div class="popular-posts-title"><a href="\2020061401.html" rel="bookmark">BlockingQueue（未完成）</a></div>
    </li>
    <li class="popular-posts-item">
      <div class="popular-posts-title"><a href="\2020060501.html" rel="bookmark">CopyOnWriteArrayList的实现原理</a></div>
    </li>
  </ul>


    <footer class="post-footer">
          

<div class="post-copyright">
<ul>
  <li class="post-copyright-author">
      <strong>本文作者： </strong>Lys
  </li>
  <li class="post-copyright-link">
      <strong>本文链接：</strong>
      <a href="http://linyishui.top/2019032501.html" title="NIO">http://linyishui.top/2019032501.html</a>
  </li>
  <li class="post-copyright-license">
    <strong>版权声明： </strong>本博客所有文章除特别声明外，均采用 <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/deed.zh" rel="noopener" target="_blank"><i class="fab fa-fw fa-creative-commons"></i>BY-NC-SA</a> 许可协议。转载请注明出处！
  </li>
</ul>
</div>

          <div class="post-tags">
              <a href="/tags/java/" rel="tag"><i class="fa fa-tag"></i> java</a>
              <a href="/tags/io/" rel="tag"><i class="fa fa-tag"></i> io</a>
          </div>

        

          <div class="post-nav">
            <div class="post-nav-item">
                <a href="/2019032102.html" rel="prev" title="多线程">
                  <i class="fa fa-chevron-left"></i> 多线程
                </a>
            </div>
            <div class="post-nav-item">
                <a href="/2019032701.html" rel="next" title="synchronized">
                  synchronized <i class="fa fa-chevron-right"></i>
                </a>
            </div>
          </div>
    </footer>
  </article>
</div>






    <div class="comments utterances-container"></div>
</div>
  </main>

  <footer class="footer">
    <div class="footer-inner">


<div class="copyright">
  &copy; 2018 – 
  <span itemprop="copyrightYear">2021</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">Lys</span>
</div>
<div class="wordcount">
  <span class="post-meta-item">
    <span class="post-meta-item-icon">
      <i class="fa fa-chart-line"></i>
    </span>
      <span>站点总字数：</span>
    <span title="站点总字数">3.4m</span>
  </span>
  <span class="post-meta-item">
    <span class="post-meta-item-icon">
      <i class="fa fa-coffee"></i>
    </span>
      <span>站点阅读时长 &asymp;</span>
    <span title="站点阅读时长">51:30</span>
  </span>
</div>
  <div class="powered-by">由 <a href="https://hexo.io/" rel="noopener" target="_blank">Hexo</a> & <a href="https://theme-next.js.org/pisces/" rel="noopener" target="_blank">NexT.Pisces</a> 强力驱动
  </div>

    </div>
  </footer>

  
  <script src="https://cdn.jsdelivr.net/npm/animejs@3.2.1/lib/anime.min.js" integrity="sha256-XL2inqUJaslATFnHdJOi9GfQ60on8Wx1C2H8DYiN1xY=" crossorigin="anonymous"></script>
  <script src="https://cdn.jsdelivr.net/npm/jquery@3.6.0/dist/jquery.min.js" integrity="sha256-/xUj+3OJU5yExlq6GSYGSHk7tPXikynS7ogEvDej/m4=" crossorigin="anonymous"></script>
  <script src="https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@3.5.7/dist/jquery.fancybox.min.js" integrity="sha256-yt2kYMy0w8AbtF89WXb2P1rfjcP/HTHLT7097U8Y5b8=" crossorigin="anonymous"></script>
<script src="/js/comments.js"></script><script src="/js/utils.js"></script><script src="/js/motion.js"></script><script src="/js/next-boot.js"></script><script src="/js/bookmark.js"></script>

  
<script src="/js/third-party/search/local-search.js"></script>



  <script class="next-config" data-name="nprogress" type="application/json">{"enable":true,"spinner":true}</script>
  <script src="/js/third-party/nprogress.js"></script>

  




<script src="https://cdn.jsdelivr.net/npm/darkmode-js@1.5.7/lib/darkmode-js.min.js"></script>

<script>
var options = {
  bottom: '64px',
  right: '32px',
  left: 'unset',
  time: '0.5s',
  mixColor: 'transparent',
  backgroundColor: 'transparent',
  buttonColorDark: '#100f2c',
  buttonColorLight: '#fff',
  saveInCookies: true,
  label: '🌓',
  autoMatchOsTheme: true
}
const darkmode = new Darkmode(options);
window.darkmode = darkmode;
darkmode.showWidget();
</script>
<script class="next-config" data-name="utterances" type="application/json">{"enable":true,"repo":"LAILAIWA/LAILAIWA.github.io","issue_term":"pathname","theme":"github-light"}</script>
<script src="/js/third-party/comments/utterances.js"></script>



</body>
</html>
