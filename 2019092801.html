<!DOCTYPE html>
<html lang="zh-CN">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width">
<meta name="theme-color" content="#222">
<meta name="generator" content="Hexo 5.4.0">


  <link rel="apple-touch-icon" sizes="180x180" href="/images/gamepad%20playstation.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/Dig%20Dug.ico">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/gamepad%20playstation.png">
  <link rel="mask-icon" href="/images/gamepad%20playstation.svg" color="#222">

<link rel="stylesheet" href="/css/main.css">

<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Monda:300,300italic,400,400italic,700,700italic%7CMa+Shan+Zheng:300,300italic,400,400italic,700,700italic%7CNoto+Serif+SC:300,300italic,400,400italic,700,700italic&display=swap&subset=latin,latin-ext">

<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free@5.15.3/css/all.min.css" integrity="sha256-2H3fkXt6FEmrReK448mDVGKb3WW2ZZw35gI7vqHOE4Y=" crossorigin="anonymous">
  <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/animate.css@3.1.1/animate.min.css" integrity="sha256-PR7ttpcvz8qrF57fur/yAx1qXMFJeJFiA6pSzWi0OIE=" crossorigin="anonymous">
  <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@3.5.7/dist/jquery.fancybox.min.css" integrity="sha256-Vzbj7sDDS/woiFS3uNKo8eIuni59rjyNGtXfstRzStA=" crossorigin="anonymous">
  <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/nprogress@0.2.0/nprogress.css" integrity="sha256-no0c5ccDODBwp+9hSmV5VvPpKwHCpbVzXHexIkupM6U=" crossorigin="anonymous">
  <script src="https://cdn.jsdelivr.net/npm/nprogress@0.2.0/nprogress.js" integrity="sha256-a5YRB27CcBwBFcT5EF/f3E4vzIqyHrSR878nseNYw64=" crossorigin="anonymous"></script>

<script class="next-config" data-name="main" type="application/json">{"hostname":"linyishui.top","root":"/","images":"/images","scheme":"Pisces","version":"8.6.0","exturl":false,"sidebar":{"position":"left","display":"always","padding":18,"offset":12},"copycode":true,"bookmark":{"enable":true,"color":"#222","save":"manual"},"fancybox":true,"mediumzoom":false,"lazyload":false,"pangu":false,"comments":{"style":"tabs","active":"utterances","storage":true,"lazyload":false,"nav":null,"activeClass":"utterances"},"motion":{"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"fadeInDown","post_body":"fadeInDown","coll_header":"fadeInLeft","sidebar":"fadeInUp"}},"prism":false,"i18n":{"placeholder":"搜索...","empty":"没有找到任何搜索结果：${query}","hits_time":"找到 ${hits} 个搜索结果（用时 ${time} 毫秒）","hits":"找到 ${hits} 个搜索结果"},"path":"/search.xml","localsearch":{"enable":true,"trigger":"auto","top_n_per_article":1,"unescape":false,"preload":false}}</script><script src="/js/config.js"></script>
<meta name="description" content="介绍Java 8引入的CompletableFuture组合式异步编程，主要内容包括：引文，Future接口（Future简介、Future接口的局限性），实现异步API（使用CompletableFuture构建异步应用、同步API、将同步方法转换为异步方法、错误处理、通过工厂方法supplyAsync优化CompletableFuture、避免阻塞、定制执行器、对多个异步任务进行流水线操作、响">
<meta property="og:type" content="article">
<meta property="og:title" content="CompletableFuture组合式异步编程">
<meta property="og:url" content="http://linyishui.top/2019092801.html">
<meta property="og:site_name" content="俺的部落格">
<meta property="og:description" content="介绍Java 8引入的CompletableFuture组合式异步编程，主要内容包括：引文，Future接口（Future简介、Future接口的局限性），实现异步API（使用CompletableFuture构建异步应用、同步API、将同步方法转换为异步方法、错误处理、通过工厂方法supplyAsync优化CompletableFuture、避免阻塞、定制执行器、对多个异步任务进行流水线操作、响">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="https://pic-1258215793.cos.ap-shanghai.myqcloud.com/content/20190901/201909010149.png">
<meta property="og:image" content="https://pic-1258215793.cos.ap-shanghai.myqcloud.com/content/20190901/201909010150.png">
<meta property="og:image" content="https://pic-1258215793.cos.ap-shanghai.myqcloud.com/content/20190901/201909010151.png">
<meta property="og:image" content="https://pic-1258215793.cos.ap-shanghai.myqcloud.com/content/20190901/201909010152.png">
<meta property="og:image" content="https://pic-1258215793.cos.ap-shanghai.myqcloud.com/content/20190901/201909010153.png">
<meta property="og:image" content="https://pic-1258215793.cos.ap-shanghai.myqcloud.com/content/20190901/201909010154.png">
<meta property="article:published_time" content="2019-09-28T03:37:33.000Z">
<meta property="article:modified_time" content="2021-06-20T15:22:56.000Z">
<meta property="article:author" content="Lys">
<meta property="article:tag" content="java8">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://pic-1258215793.cos.ap-shanghai.myqcloud.com/content/20190901/201909010149.png">


<link rel="canonical" href="http://linyishui.top/2019092801.html">



<script class="next-config" data-name="page" type="application/json">{"sidebar":"","isHome":false,"isPost":true,"lang":"zh-CN","comments":true,"permalink":"http://linyishui.top/2019092801.html","path":"2019092801.html","title":"CompletableFuture组合式异步编程"}</script>

<script class="next-config" data-name="calendar" type="application/json">""</script>
<title>CompletableFuture组合式异步编程 | 俺的部落格</title>
  




  <noscript>
    <link rel="stylesheet" href="/css/noscript.css">
  </noscript>
<link rel="alternate" href="/atom.xml" title="俺的部落格" type="application/atom+xml">
<style>.darkmode--activated{--body-bg-color:#282828;--content-bg-color:#333;--card-bg-color:#555;--text-color:#ccc;--blockquote-color:#bbb;--link-color:#ccc;--link-hover-color:#eee;--brand-color:#ddd;--brand-hover-color:#ddd;--table-row-odd-bg-color:#282828;--table-row-hover-bg-color:#363636;--menu-item-bg-color:#555;--btn-default-bg:#222;--btn-default-color:#ccc;--btn-default-border-color:#555;--btn-default-hover-bg:#666;--btn-default-hover-color:#ccc;--btn-default-hover-border-color:#666;--highlight-background:#282b2e;--highlight-foreground:#a9b7c6;--highlight-gutter-background:#34393d;--highlight-gutter-foreground:#9ca9b6}.darkmode--activated img{opacity:.75}.darkmode--activated img:hover{opacity:.9}.darkmode--activated code{color:#69dbdc;background:0 0}button.darkmode-toggle{z-index:9999}</style></head>

<body itemscope itemtype="http://schema.org/WebPage" class="use-motion">
  <div class="headband"></div>

  <main class="main">
    <header class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="切换导航栏" role="button">
        <span class="toggle-line"></span>
        <span class="toggle-line"></span>
        <span class="toggle-line"></span>
    </div>
  </div>

  <div class="site-meta">

    <a href="/" class="brand" rel="start">
      <i class="logo-line"></i>
      <h1 class="site-title">俺的部落格</h1>
      <i class="logo-line"></i>
    </a>
      <p class="site-subtitle" itemprop="description">俺寻思俺需要记点东西</p>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger">
        <i class="fa fa-search fa-fw fa-lg"></i>
    </div>
  </div>
</div>



<nav class="site-nav">
  <ul class="main-menu menu">
        <li class="menu-item menu-item-home"><a href="/" rel="section"><i class="fa fa-home fa-fw"></i>首页</a></li>
        <li class="menu-item menu-item-about"><a href="/about/" rel="section"><i class="fa fa-user fa-fw"></i>关于</a></li>
        <li class="menu-item menu-item-tags"><a href="/tags/" rel="section"><i class="fa fa-tags fa-fw"></i>标签</a></li>
        <li class="menu-item menu-item-categories"><a href="/categories/" rel="section"><i class="fa fa-th fa-fw"></i>分类</a></li>
        <li class="menu-item menu-item-archives"><a href="/archives/" rel="section"><i class="fa fa-archive fa-fw"></i>归档</a></li>
        <li class="menu-item menu-item-sitemap"><a href="/sitemap.xml" rel="section"><i class="fa fa-sitemap fa-fw"></i>站点地图</a></li>
        <li class="menu-item menu-item-tools"><a href="/links/" rel="section"><i class="fa fa-link fa-fw"></i>工具</a></li>
        <li class="menu-item menu-item-books"><a href="/books/" rel="section"><i class="fa fa-book fa-fw"></i>书架</a></li>
        <li class="menu-item menu-item-movies"><a href="/movies/" rel="section"><i class="fa fa-video fa-fw"></i>剧院</a></li>
        <li class="menu-item menu-item-games"><a href="/games/" rel="section"><i class="fa fa-gamepad fa-fw"></i>游戏</a></li>
        <li class="menu-item menu-item-commonweal"><a href="/404/" rel="section"><i class="fa fa-heartbeat fa-fw"></i>公益</a></li>
      <li class="menu-item menu-item-search">
        <a role="button" class="popup-trigger"><i class="fa fa-search fa-fw"></i>搜索
        </a>
      </li>
  </ul>
</nav>



  <div class="search-pop-overlay">
    <div class="popup search-popup"><div class="search-header">
  <span class="search-icon">
    <i class="fa fa-search"></i>
  </span>
  <div class="search-input-container">
    <input autocomplete="off" autocapitalize="off" maxlength="80"
           placeholder="搜索..." spellcheck="false"
           type="search" class="search-input">
  </div>
  <span class="popup-btn-close" role="button">
    <i class="fa fa-times-circle"></i>
  </span>
</div>
<div class="search-result-container no-result">
  <div class="search-result-icon">
    <i class="fa fa-spinner fa-pulse fa-5x"></i>
  </div>
</div>

    </div>
  </div>

</div>
        
  
  <div class="toggle sidebar-toggle" role="button">
    <span class="toggle-line"></span>
    <span class="toggle-line"></span>
    <span class="toggle-line"></span>
  </div>

  <aside class="sidebar">

    <div class="sidebar-inner sidebar-nav-active sidebar-toc-active">
      <ul class="sidebar-nav">
        <li class="sidebar-nav-toc">
          文章目录
        </li>
        <li class="sidebar-nav-overview">
          站点概览
        </li>
      </ul>

      <div class="sidebar-panel-container">
        <!--noindex-->
        <div class="post-toc-wrap sidebar-panel">
            <div class="post-toc animated"><ol class="nav"><li class="nav-item nav-level-1"><a class="nav-link" href="#CompletableFuture%E7%BB%84%E5%90%88%E5%BC%8F%E5%BC%82%E6%AD%A5%E7%BC%96%E7%A8%8B"><span class="nav-text">CompletableFuture组合式异步编程</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#%E4%B8%80-%E5%BC%95%E6%96%87"><span class="nav-text">一. 引文</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E4%BA%8C-Future%E6%8E%A5%E5%8F%A3"><span class="nav-text">二. Future接口</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#2-1-Future%E7%AE%80%E4%BB%8B"><span class="nav-text">2.1 Future简介</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#2-2-Future%E6%8E%A5%E5%8F%A3%E7%9A%84%E5%B1%80%E9%99%90%E6%80%A7"><span class="nav-text">2.2 Future接口的局限性</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E4%B8%89-%E5%AE%9E%E7%8E%B0%E5%BC%82%E6%AD%A5API"><span class="nav-text">三. 实现异步API</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#3-1-%E4%BD%BF%E7%94%A8CompletableFuture%E6%9E%84%E5%BB%BA%E5%BC%82%E6%AD%A5%E5%BA%94%E7%94%A8"><span class="nav-text">3.1 使用CompletableFuture构建异步应用</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#3-2-%E5%90%8C%E6%AD%A5API"><span class="nav-text">3.2 同步API</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#3-3-%E5%B0%86%E5%90%8C%E6%AD%A5%E6%96%B9%E6%B3%95%E8%BD%AC%E6%8D%A2%E4%B8%BA%E5%BC%82%E6%AD%A5%E6%96%B9%E6%B3%95"><span class="nav-text">3.3 将同步方法转换为异步方法</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#3-4-%E9%94%99%E8%AF%AF%E5%A4%84%E7%90%86"><span class="nav-text">3.4 错误处理</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#3-5-%E9%80%9A%E8%BF%87%E5%B7%A5%E5%8E%82%E6%96%B9%E6%B3%95supplyAsync%E4%BC%98%E5%8C%96CompletableFuture"><span class="nav-text">3.5 通过工厂方法supplyAsync优化CompletableFuture</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#3-6-%E9%81%BF%E5%85%8D%E9%98%BB%E5%A1%9E"><span class="nav-text">3.6 避免阻塞</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#3-7-%E5%AE%9A%E5%88%B6%E6%89%A7%E8%A1%8C%E5%99%A8"><span class="nav-text">3.7 定制执行器</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#3-8-%E5%AF%B9%E5%A4%9A%E4%B8%AA%E5%BC%82%E6%AD%A5%E4%BB%BB%E5%8A%A1%E8%BF%9B%E8%A1%8C%E6%B5%81%E6%B0%B4%E7%BA%BF%E6%93%8D%E4%BD%9C"><span class="nav-text">3.8 对多个异步任务进行流水线操作</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#3-8-1-%E5%AE%9E%E7%8E%B0%E6%8A%98%E6%89%A3%E6%9C%8D%E5%8A%A1"><span class="nav-text">3.8.1 实现折扣服务</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#3-8-2-%E6%9E%84%E9%80%A0%E5%90%8C%E6%AD%A5%E5%92%8C%E5%BC%82%E6%AD%A5%E6%93%8D%E4%BD%9C"><span class="nav-text">3.8.2 构造同步和异步操作</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#3-8-3-%E5%B0%86%E4%B8%A4%E4%B8%AACompletableFuture%E5%AF%B9%E8%B1%A1%E6%95%B4%E5%90%88%E8%B5%B7%E6%9D%A5%EF%BC%8C%E6%97%A0%E8%AE%BA%E5%AE%83%E4%BB%AC%E6%98%AF%E5%90%A6%E5%AD%98%E5%9C%A8%E4%BE%9D%E8%B5%96"><span class="nav-text">3.8.3 将两个CompletableFuture对象整合起来，无论它们是否存在依赖</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#3-8-4-%E5%9B%9E%E9%A1%BEFuture%E5%92%8CCompletableFuture"><span class="nav-text">3.8.4 回顾Future和CompletableFuture</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#3-9-%E5%93%8D%E5%BA%94CompletableFuture%E7%9A%84completion%E4%BA%8B%E4%BB%B6"><span class="nav-text">3.9 响应CompletableFuture的completion事件</span></a></li></ol></li></ol></li></ol></div>
        </div>
        <!--/noindex-->

        <div class="site-overview-wrap sidebar-panel">
          <div class="site-overview">
            <div class="site-author site-overview-item animated" itemprop="author" itemscope itemtype="http://schema.org/Person">
    <img class="site-author-image" itemprop="image" alt="Lys"
      src="https://pic-1258215793.cos.ap-shanghai.myqcloud.com/cover/IMG_0759.JPG">
  <p class="site-author-name" itemprop="name">Lys</p>
  <div class="site-description" itemprop="description">记录编程点滴，写点生活中的酸甜</div>
</div>
<div class="site-state-wrap site-overview-item animated">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
          <a href="/archives/">
        
          <span class="site-state-item-count">320</span>
          <span class="site-state-item-name">日志</span>
        </a>
      </div>
      <div class="site-state-item site-state-categories">
            <a href="/categories/">
          
        <span class="site-state-item-count">11</span>
        <span class="site-state-item-name">分类</span></a>
      </div>
      <div class="site-state-item site-state-tags">
            <a href="/tags/">
          
        <span class="site-state-item-count">108</span>
        <span class="site-state-item-name">标签</span></a>
      </div>
  </nav>
</div>
  <div class="links-of-author site-overview-item animated">
      <span class="links-of-author-item">
        <a href="https://github.com/LAILAIWA" title="GitHub → https:&#x2F;&#x2F;github.com&#x2F;LAILAIWA" rel="noopener" target="_blank"><i class="fab fa-github fa-fw"></i>GitHub</a>
      </span>
      <span class="links-of-author-item">
        <a href="mailto:linyishui168@outlook.com" title="E-Mail → mailto:linyishui168@outlook.com" rel="noopener" target="_blank"><i class="fa fa-envelope fa-fw"></i>E-Mail</a>
      </span>
      <span class="links-of-author-item">
        <a href="https://weibo.com/u/5340162234" title="Weibo → https:&#x2F;&#x2F;weibo.com&#x2F;u&#x2F;5340162234" rel="noopener" target="_blank"><i class="fab fa-weibo fa-fw"></i>Weibo</a>
      </span>
      <span class="links-of-author-item">
        <a href="https://twitter.com/linyishui618" title="Twitter → https:&#x2F;&#x2F;twitter.com&#x2F;linyishui618" rel="noopener" target="_blank"><i class="fab fa-twitter fa-fw"></i>Twitter</a>
      </span>
      <span class="links-of-author-item">
        <a href="https://stackoverflow.com/users/13018339/lin-yishui" title="StackOverflow → https:&#x2F;&#x2F;stackoverflow.com&#x2F;users&#x2F;13018339&#x2F;lin-yishui" rel="noopener" target="_blank"><i class="fab fa-stack-overflow fa-fw"></i>StackOverflow</a>
      </span>
      <span class="links-of-author-item">
        <a href="https://instagram.com/linyishui618" title="Instagram → https:&#x2F;&#x2F;instagram.com&#x2F;linyishui618" rel="noopener" target="_blank"><i class="fab fa-instagram fa-fw"></i>Instagram</a>
      </span>
  </div>
  <div class="cc-license site-overview-item animated" itemprop="license">
    <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/deed.zh" class="cc-opacity" rel="noopener" target="_blank"><img src="https://cdn.jsdelivr.net/npm/@creativecommons/vocabulary@2020.11.3/assets/license_badges/small/by_nc_sa.svg" alt="Creative Commons"></a>
  </div>


  <div class="links-of-blogroll site-overview-item animated">
    <div class="links-of-blogroll-title"><i class="far fa-smile-wink fa-fw"></i>
      个人
    </div>
    <ul class="links-of-blogroll-list">
        <li class="links-of-blogroll-item">
          <a href="https://music.163.com/#/user/home?id=68425607" title="https:&#x2F;&#x2F;music.163.com&#x2F;#&#x2F;user&#x2F;home?id&#x3D;68425607" rel="noopener" target="_blank">网易云音乐</a>
        </li>
    </ul>
  </div>

          </div>
        </div>
    </div>
  </aside>
  <div class="sidebar-dimmer"></div>


    </header>

    
  <div class="back-to-top" role="button" aria-label="返回顶部">
    <i class="fa fa-arrow-up"></i>
    <span>0%</span>
  </div>
  <a role="button" class="book-mark-link book-mark-link-fixed"></a>

  <a href="https://github.com/LAILAIWA" class="github-corner" title="Follow me on GitHub" aria-label="Follow me on GitHub" rel="noopener" target="_blank"><svg width="80" height="80" viewBox="0 0 250 250" aria-hidden="true"><path d="M0,0 L115,115 L130,115 L142,142 L250,250 L250,0 Z"></path><path d="M128.3,109.0 C113.8,99.7 119.0,89.6 119.0,89.6 C122.0,82.7 120.5,78.6 120.5,78.6 C119.2,72.0 123.4,76.3 123.4,76.3 C127.3,80.9 125.5,87.3 125.5,87.3 C122.9,97.6 130.6,101.9 134.4,103.2" fill="currentColor" style="transform-origin: 130px 106px;" class="octo-arm"></path><path d="M115.0,115.0 C114.9,115.1 118.7,116.5 119.8,115.4 L133.7,101.6 C136.9,99.2 139.9,98.4 142.2,98.6 C133.8,88.0 127.5,74.4 143.8,58.0 C148.5,53.4 154.0,51.2 159.7,51.0 C160.3,49.4 163.2,43.6 171.4,40.1 C171.4,40.1 176.1,42.5 178.8,56.2 C183.1,58.6 187.2,61.8 190.9,65.4 C194.5,69.0 197.7,73.2 200.1,77.6 C213.8,80.2 216.3,84.9 216.3,84.9 C212.7,93.1 206.9,96.0 205.4,96.6 C205.1,102.4 203.0,107.8 198.3,112.5 C181.9,128.9 168.3,122.5 157.7,114.1 C157.9,116.9 156.7,120.9 152.7,124.9 L141.0,136.5 C139.8,137.7 141.6,141.9 141.8,141.8 Z" fill="currentColor" class="octo-body"></path></svg></a>

<noscript>
  <div class="noscript-warning">Theme NexT works best with JavaScript enabled</div>
</noscript>


    <div class="main-inner post posts-expand">


  


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://linyishui.top/2019092801.html">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="https://pic-1258215793.cos.ap-shanghai.myqcloud.com/cover/IMG_0759.JPG">
      <meta itemprop="name" content="Lys">
      <meta itemprop="description" content="记录编程点滴，写点生活中的酸甜">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="俺的部落格">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          CompletableFuture组合式异步编程
        </h1>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>

      <time title="创建时间：2019-09-28 11:37:33" itemprop="dateCreated datePublished" datetime="2019-09-28T11:37:33+08:00">2019-09-28</time>
    </span>
      <span class="post-meta-item">
        <span class="post-meta-item-icon">
          <i class="far fa-calendar-check"></i>
        </span>
        <span class="post-meta-item-text">更新于</span>
        <time title="修改时间：2021-06-20 23:22:56" itemprop="dateModified" datetime="2021-06-20T23:22:56+08:00">2021-06-20</time>
      </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">分类于</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/%E6%8A%80%E6%9C%AF%E6%96%87%E6%A1%A3/" itemprop="url" rel="index"><span itemprop="name">技术文档</span></a>
        </span>
    </span>

  
      </div>
      <div class="post-meta">
    <span class="post-meta-item" title="本文字数">
      <span class="post-meta-item-icon">
        <i class="far fa-file-word"></i>
      </span>
      <span class="post-meta-item-text">本文字数：</span>
      <span>18k</span>
    </span>
    <span class="post-meta-item" title="阅读时长">
      <span class="post-meta-item-icon">
        <i class="far fa-clock"></i>
      </span>
      <span class="post-meta-item-text">阅读时长 &asymp;</span>
      <span>17 分钟</span>
    </span>
</div>

            <div class="post-description">介绍Java 8引入的CompletableFuture组合式异步编程，主要内容包括：引文，Future接口（Future简介、Future接口的局限性），实现异步API（使用CompletableFuture构建异步应用、同步API、将同步方法转换为异步方法、错误处理、通过工厂方法supplyAsync优化CompletableFuture、避免阻塞、定制执行器、对多个异步任务进行流水线操作、响应CompletableFuture的completion事件）等。</div>
        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
        <h1 id="CompletableFuture组合式异步编程"><a href="#CompletableFuture组合式异步编程" class="headerlink" title="CompletableFuture组合式异步编程"></a>CompletableFuture组合式异步编程</h1><h2 id="一-引文"><a href="#一-引文" class="headerlink" title="一. 引文"></a>一. 引文</h2><p>相比直接使用线程的方式，使用分支/合并框架和并行流能以更简单、更有效的方式来实现并行的效果。如今的互联网程序通常是混聚的方式：使用来自多个来源的内容，将这些内容聚合在一起，来实现功能需求。</p>
<p><img src="https://pic-1258215793.cos.ap-shanghai.myqcloud.com/content/20190901/201909010149.png" alt="典型的混聚式应用"></p>
<p>我们在应用中可能需要和互联网上的多个Web服务通信，但我们并不希望因为等待某些服务的响应而阻塞应用程序的运行，浪费掉数十亿宝贵的CPU时钟周期。如分支/合并框架和并行流这些工具可以帮我们实现并行处理：将一个操作切分为多个子操作，在多个不同的核、CPU甚至是机器上并行地执行这些子操作。</p>
<p>如果你的意图是想实现并发，而不是并行，或者你的主要目标是在同一个CPU上执行几个松耦合的任务，充分利用CPU的核，让其足够的忙碌从而最大化程序的吞吐量，那么你真正想做的是避免因为等待远程服务的返回，或者对数据库的查询，而阻塞线程的执行，浪费掉宝贵的计算资源。Future接口，尤其是其新版实现CompletableFuture是处理这种情况的利器。</p>
<p><img src="https://pic-1258215793.cos.ap-shanghai.myqcloud.com/content/20190901/201909010150.png" alt="并发和并行"></p>
<h2 id="二-Future接口"><a href="#二-Future接口" class="headerlink" title="二. Future接口"></a>二. Future接口</h2><p>Java 5时引入了Future接口，设计初衷是对将来某个时刻会发生的结果进行建模。它模拟了一种异步计算，返回一个执行运算结果的引用，当运算结束后，这个引用被返回给调用方。所以在执行Future接口中的耗时运算时，调用线程可以被解放出来做其他工作，而不是一直等待运算完成。</p>
<p>如下代码，使用Future以异步的方式执行一个耗时的操作。我们在需要异步操作结果才能继续运行时再调用get方法获取操作的结果，如果耗时操作不能像我们期待那样顺利的得出结果，也可以通过参数设定等待时间。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">    <span class="comment">//创建一个ExecutorService，可以通过它向线程池提交任务</span></span><br><span class="line">    ExecutorService executor = Executors.newCachedThreadPool();</span><br><span class="line">    <span class="comment">//向ExecutorService提交一个Callable对象</span></span><br><span class="line">    Future&lt;Double&gt; future = executor.submit(<span class="keyword">new</span> Callable&lt;Double&gt;() &#123;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> Double <span class="title">call</span><span class="params">()</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">            <span class="comment">//以异步方式在新的线程中执行耗时的操作</span></span><br><span class="line">            <span class="keyword">return</span> doSomeLongComputation();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;);</span><br><span class="line">    <span class="comment">//异步操作进行的同时可以做其他事情</span></span><br><span class="line">    doSomethingElse();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="comment">//获取异步操作的结果，如果最终被阻塞，无法得到结果，则最多等待1秒钟后退出</span></span><br><span class="line">        Double result = future.get(<span class="number">1</span>, TimeUnit.SECONDS);</span><br><span class="line">    &#125;<span class="keyword">catch</span> (ExecutionException ex)&#123;</span><br><span class="line">        <span class="comment">//计算抛出一个异常</span></span><br><span class="line">    &#125;<span class="keyword">catch</span> (InterruptedException ex)&#123;</span><br><span class="line">        <span class="comment">//当前线程在等待过程中被中断</span></span><br><span class="line">    &#125;<span class="keyword">catch</span> (TimeoutException ex)&#123;</span><br><span class="line">        <span class="comment">//在Future对象完成之前已过期</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p><img src="https://pic-1258215793.cos.ap-shanghai.myqcloud.com/content/20190901/201909010151.png" alt="使用Future以异步方式执行长时间操作"></p>
<h3 id="2-1-Future简介"><a href="#2-1-Future简介" class="headerlink" title="2.1 Future简介"></a>2.1 Future简介</h3><p>可以参考<a href="../2019080601.html" title="Title">Future接口，常见的线程池中的FutureTask实现</a>。</p>
<h3 id="2-2-Future接口的局限性"><a href="#2-2-Future接口的局限性" class="headerlink" title="2.2 Future接口的局限性"></a>2.2 Future接口的局限性</h3><p>Future接口提供了方法（isDone）来检测异步计算是否已经结束，等待异步操作结束，以及获取计算的结果。但这些特性并不能让我们编写足够简洁的并发代码，比如我们很难表述Future结果间的依赖性：“当长时间计算任务完成时，请将该计算的结果通知另一个长时间运行的计算任务，这两个计算任务都完成后，将计算的结果与另一个查询操作结果合并”。</p>
<blockquote>
<p>Future不能满足的一些需求：</p>
<ul>
<li>将两个异步计算合并为一个，两个异步计算间相互独立，同时第二个又依赖于第一个的结果</li>
<li>等待Future集合中的所有任务都完成</li>
<li>仅等待Future集合中最快的任务完成，并返回其结果</li>
<li>仅通过编程方式完成一个Future任务的执行，以手工设定异步操作结果的方式</li>
<li>应对Future的完成事件，即当Future的完成事件发生时会收到通知，并能用Future计算的结果进行下一步的操作，而不是简单的阻塞等待结果</li>
</ul>
</blockquote>
<h2 id="三-实现异步API"><a href="#三-实现异步API" class="headerlink" title="三. 实现异步API"></a>三. 实现异步API</h2><h3 id="3-1-使用CompletableFuture构建异步应用"><a href="#3-1-使用CompletableFuture构建异步应用" class="headerlink" title="3.1 使用CompletableFuture构建异步应用"></a>3.1 使用CompletableFuture构建异步应用</h3><p>假设一个需求：最佳价格查询器，需要查询多个在线商店，依据给定的产品或服务找出最低的价格</p>
<blockquote>
<ol>
<li>学会如何为客户提供异步API</li>
<li>掌握如何让使用了同步API的代码变为非阻塞代码。了解如何使用流水线将两个接续的异步操作合并为一个异步计算操作。</li>
<li>学会如何以响应式的方式处理异步操作的完成事件</li>
</ol>
</blockquote>
<blockquote>
<p>同步API和异步API?</p>
<ul>
<li><strong>同步API</strong>：同步API是对传统方法调用的称呼，调用方会在被调用方运行时等待，被调用方运行结束返回，调用方取得返回值继续运行。即使两者在不同的线程中运行，调用方还是要等被调用方结束运行，这就是<strong>阻塞式调用</strong>。</li>
<li><strong>异步API</strong>：异步API则会直接返回，或者至少在被调用方法计算完成之前，将它剩余的计算任务交给另一个线程去做，该线程和调用方是异步的，这种方式是<strong>非阻塞式调用</strong>。执行剩余计算的线程会把计算结果返回给调用方，返回的方式要么是通过回调函数，要么是通过调用方再执行一个“等待直到计算完成”的方法调用。</li>
</ul>
</blockquote>
<h3 id="3-2-同步API"><a href="#3-2-同步API" class="headerlink" title="3.2 同步API"></a>3.2 同步API</h3><p>我们首先根据需求用传统方式实现API，代码如下。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Shop</span> </span>&#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 获取价格</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> product 产品</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> 价格</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">double</span> <span class="title">getPrice</span><span class="params">(String product)</span></span>&#123;</span><br><span class="line">        <span class="comment">//需要查询商店的数据库</span></span><br><span class="line">        <span class="comment">//可能要联系其他外部服务，比如商店的供应商，和制造商相关的推广折扣</span></span><br><span class="line">        <span class="comment">//ToDo</span></span><br><span class="line">        <span class="keyword">return</span> calculatePrice(product);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 计算获取价格</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> product 产品</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> 价格</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">double</span> <span class="title">calculatePrice</span><span class="params">(String product)</span></span>&#123;</span><br><span class="line">        delay();</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> Random().nextDouble() * product.charAt(<span class="number">0</span>) + product.charAt(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 模拟耗时操作，1s延迟</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">delay</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">try</span>&#123;</span><br><span class="line">            Thread.sleep(<span class="number">1000L</span>);</span><br><span class="line">        &#125;<span class="keyword">catch</span> (InterruptedException ex)&#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h3 id="3-3-将同步方法转换为异步方法"><a href="#3-3-将同步方法转换为异步方法" class="headerlink" title="3.3 将同步方法转换为异步方法"></a>3.3 将同步方法转换为异步方法</h3><p>我们通过CompletableFuture来实现这一转换，如下代码。创建一个代表异步计算的CompletableFuture实例，它在计算完成时会包含计算的结果，接着调用fork创建了另一个线程去执行实际的价格计算工作，不等待计算完成，直接返回一个Future实例。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 获取价格—异步</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> product 产品</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> 价格-暂不可知</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> Future&lt;Double&gt; <span class="title">getPriceAsync</span><span class="params">(String product)</span></span>&#123;</span><br><span class="line">    <span class="comment">//创建CompletableFuture对象，它会包含计算的结果</span></span><br><span class="line">    CompletableFuture&lt;Double&gt; futurePrice = <span class="keyword">new</span> CompletableFuture&lt;&gt;();</span><br><span class="line">    <span class="comment">//开启一个新的线程来执行计算</span></span><br><span class="line">    <span class="keyword">new</span> Thread(() -&gt; &#123;</span><br><span class="line">        <span class="keyword">double</span> price = calculatePrice(product);</span><br><span class="line">        <span class="comment">//设置Future的返回值</span></span><br><span class="line">        futurePrice.complete(price);</span><br><span class="line">    &#125;).start();</span><br><span class="line">    <span class="comment">//无需等待还未结束的计算，直接返回Future&lt;Double&gt;对象</span></span><br><span class="line">    <span class="keyword">return</span> futurePrice;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p>我们尝试调用异步API，代码如下。用户向商店查询了某种商品的价格，商店实现了异步API，所以直接取到了Future返回。在等待结果的过程中，用户可以做一些其他操作，等到客户要执行的操作依赖于商品价格时，再调用 <code>futurePrice.get()</code> 。执行此操作后，客户要么获得Future封装的值，要么发生阻塞直到异步任务完成。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Shop shop = <span class="keyword">new</span> Shop(<span class="string">&quot;BestShop&quot;</span>);</span><br><span class="line">        <span class="keyword">long</span> start = System.nanoTime();</span><br><span class="line">        Future&lt;Double&gt; futurePrice = shop.getPriceAsync(<span class="string">&quot;my favorite product&quot;</span>);</span><br><span class="line">        <span class="keyword">long</span> invocationTime = ((System.nanoTime() - start) / <span class="number">1_000_000</span>);</span><br><span class="line">        System.out.println(<span class="string">&quot;Invocation returned after &quot;</span> + invocationTime + <span class="string">&quot; msecs&quot;</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//执行更多任务，比如查询其他商店</span></span><br><span class="line">        doSomethingElse();</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">double</span> price = futurePrice.get();</span><br><span class="line">            System.out.printf(<span class="string">&quot;Price is %.2f%n&quot;</span>,price);</span><br><span class="line">        &#125;<span class="keyword">catch</span> (Exception ex)&#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException(ex);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">long</span> retrievalTime = ((System.nanoTime() - start) / <span class="number">1_000_000</span>);</span><br><span class="line">        System.out.println(<span class="string">&quot;Price returned after &quot;</span> + retrievalTime + <span class="string">&quot; msecs&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">doSomethingElse</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">try</span>&#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;doSomethingElse&quot;</span>);</span><br><span class="line">            Thread.sleep(<span class="number">1000L</span>);</span><br><span class="line">        &#125;<span class="keyword">catch</span> (InterruptedException ex)&#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p>执行代码结果如下，异步API的返回远远早于价格计算完成的时间。</p>
<figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="attribute">Invocation</span> returned after <span class="number">182</span> msecs</span><br><span class="line"><span class="attribute">doSomethingElse</span></span><br><span class="line"><span class="attribute">Price</span> is <span class="number">155</span>.<span class="number">07</span></span><br><span class="line"><span class="attribute">Price</span> returned after <span class="number">1224</span> msecs</span><br></pre></td></tr></table></figure>



<h3 id="3-4-错误处理"><a href="#3-4-错误处理" class="headerlink" title="3.4 错误处理"></a>3.4 错误处理</h3><p>如果上述代码在计算过程中发生了错误呢？用于提示错误的异常会被限制在视图计算商品价格的当前线程内，最终会杀死该线程，而这会导致等待get方法返回结果的客户端永久的封闭。</p>
<p>我们可以调用get方法的重载版本设置一个等待时间，防止永久的等待。但这种方法我们无法得知计算时到底发生了什么问题，如果我们想让客户端能了解商店无法提供请求商品价格的原因，可以使用CompletableFuture的completeExceptionally方法，将导致CompletableFuture发生问题的异常抛出。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//设置一个等待时间</span></span><br><span class="line"><span class="keyword">double</span> price = futurePrice.get(<span class="number">1</span>, TimeUnit.SECONDS);</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> Future&lt;Double&gt; <span class="title">getPriceAsync</span><span class="params">(String product)</span></span>&#123;</span><br><span class="line">    <span class="comment">//创建CompletableFuture对象，它会包含计算的结果</span></span><br><span class="line">    CompletableFuture&lt;Double&gt; futurePrice = <span class="keyword">new</span> CompletableFuture&lt;&gt;();</span><br><span class="line">    <span class="comment">//开启一个新的线程来执行计算</span></span><br><span class="line">    <span class="keyword">new</span> Thread(() -&gt; &#123;</span><br><span class="line">        <span class="keyword">try</span>&#123;</span><br><span class="line">            <span class="keyword">double</span> price = calculatePrice(product);</span><br><span class="line">            <span class="comment">//设置Future的返回值</span></span><br><span class="line">            futurePrice.complete(price);</span><br><span class="line">        &#125;<span class="keyword">catch</span> (Exception ex)&#123;</span><br><span class="line">            <span class="comment">//抛出导致失败的异常，完成此次Future操作</span></span><br><span class="line">            futurePrice.completeExceptionally(ex);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;).start();</span><br><span class="line">    <span class="comment">//无需等待还未结束的计算，直接返回Future&lt;Double&gt;对象</span></span><br><span class="line">    <span class="keyword">return</span> futurePrice;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h3 id="3-5-通过工厂方法supplyAsync优化CompletableFuture"><a href="#3-5-通过工厂方法supplyAsync优化CompletableFuture" class="headerlink" title="3.5 通过工厂方法supplyAsync优化CompletableFuture"></a>3.5 通过工厂方法supplyAsync优化CompletableFuture</h3><p>CompletableFuture提供了很多精巧的工厂方法来帮助我们更容易的实现流程，还不用操心实现的细节，可以重写getPriceAsync方法如下。此实现和上述是等价的，也具有错误处理机制。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> Future&lt;Double&gt; <span class="title">getPriceAsync</span><span class="params">(String product)</span></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> CompletableFuture.supplyAsync(() -&gt; calculatePrice(product));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p>supplyAsync方法接受一个Supplier参数，返回CompletableFuture对象，此对象完成异步执行后会读取调用生产者方法的返回值。生产者方法会交由ForkJoinPool池中的某个执行线程（Executor）运行。重载版本添加了参数Executor，表示你可以自行指定执行线程。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> &lt;U&gt; <span class="function">CompletableFuture&lt;U&gt; <span class="title">supplyAsync</span><span class="params">(Supplier&lt;U&gt; supplier)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> asyncSupplyStage(asyncPool, supplier);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> &lt;U&gt; <span class="function">CompletableFuture&lt;U&gt; <span class="title">supplyAsync</span><span class="params">(Supplier&lt;U&gt; supplier,</span></span></span><br><span class="line"><span class="params"><span class="function">                                                   Executor executor)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> asyncSupplyStage(screenExecutor(executor), supplier);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">static</span> &lt;U&gt; <span class="function">CompletableFuture&lt;U&gt; <span class="title">asyncSupplyStage</span><span class="params">(Executor e,</span></span></span><br><span class="line"><span class="params"><span class="function">                                                 Supplier&lt;U&gt; f)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (f == <span class="keyword">null</span>) <span class="keyword">throw</span> <span class="keyword">new</span> NullPointerException();</span><br><span class="line">    CompletableFuture&lt;U&gt; d = <span class="keyword">new</span> CompletableFuture&lt;U&gt;();</span><br><span class="line">    e.execute(<span class="keyword">new</span> AsyncSupply&lt;U&gt;(d, f));</span><br><span class="line">    <span class="keyword">return</span> d;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h3 id="3-6-避免阻塞"><a href="#3-6-避免阻塞" class="headerlink" title="3.6 避免阻塞"></a>3.6 避免阻塞</h3><p>如果我们无法控制API的实现，可能最终拿到的API都是同步阻塞式的方法，那么要如何以异步的方式来查询多个商店，避免被单一的请求阻塞？</p>
<p>假设我们需要根据产品名查询多个商店中对应的价格，首先可以试一下用Stream来实现这一需求。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">List&lt;Shop&gt; shops = Arrays.asList(<span class="keyword">new</span> Shop(<span class="string">&quot;BestPrice&quot;</span>),</span><br><span class="line">        <span class="keyword">new</span> Shop(<span class="string">&quot;LetsSaveBig&quot;</span>),</span><br><span class="line">        <span class="keyword">new</span> Shop(<span class="string">&quot;MyFavoriteShop&quot;</span>),</span><br><span class="line">        <span class="keyword">new</span> Shop(<span class="string">&quot;BuyItAll&quot;</span>));</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 查询产品商店名和价格</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> product 产品</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> List&lt;String&gt; <span class="title">findPrices</span><span class="params">(String product)</span></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> shops.stream()</span><br><span class="line">            .map(shop -&gt; String.format(<span class="string">&quot;%s price is %.2f&quot;</span>,shop.getName(),shop.getPrice(product)))</span><br><span class="line">            .collect(Collectors.toList());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p>测试一下findPrices性能，运行大概需要4s，对四个商店的查询是顺序执行的，一个查询操作会阻塞另一个，而每个查询大概都需要1s的时间计算产品价格。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">long</span> start = System.nanoTime();</span><br><span class="line">List&lt;String&gt; result = findPrices(<span class="string">&quot;myPhone27S&quot;</span>);</span><br><span class="line">System.out.println(result);</span><br><span class="line"><span class="keyword">long</span> duration = (System.nanoTime() - start) / <span class="number">1_000_000</span>;</span><br><span class="line">System.out.println(<span class="string">&quot;Done in &quot;</span> + duration + <span class="string">&quot; msecs&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">//输出如下</span></span><br><span class="line">[BestPrice price is <span class="number">188.28</span>, LetsSaveBig price is <span class="number">207.11</span>, MyFavoriteShop price is <span class="number">223.33</span>, BuyItAll price is <span class="number">165.98</span>]</span><br><span class="line">Done in <span class="number">4152</span> msecs</span><br></pre></td></tr></table></figure>



<p>试着用并行流进行优化，避免顺序计算，结果总耗时降低到1s多，效果还是很明显的。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> List&lt;String&gt; <span class="title">findPrices</span><span class="params">(String product)</span></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> shops.parallelStream()</span><br><span class="line">            .map(shop -&gt; String.format(<span class="string">&quot;%s price is %.2f&quot;</span>,shop.getName(),shop.getPrice(product)))</span><br><span class="line">            .collect(Collectors.toList());</span><br><span class="line">&#125;</span><br><span class="line">            </span><br><span class="line"><span class="comment">//输出如下</span></span><br><span class="line">[BestPrice price is <span class="number">178.36</span>, LetsSaveBig price is <span class="number">162.40</span>, MyFavoriteShop price is <span class="number">160.91</span>, BuyItAll price is <span class="number">214.49</span>]</span><br><span class="line">Done in <span class="number">1127</span> msecs</span><br></pre></td></tr></table></figure>



<p>再试着用CompletableFuture将findPrices方法中对不同商店的同步调用替换为异步调用。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> List&lt;String&gt; <span class="title">findPricesAsync</span><span class="params">(String product)</span></span>&#123;</span><br><span class="line">    <span class="comment">//通过CompletableFuture以异步方式计算每种商品的价格</span></span><br><span class="line">    List&lt;CompletableFuture&lt;String&gt;&gt; priceFuture =</span><br><span class="line">            shops.stream()</span><br><span class="line">                    .map(shop -&gt; CompletableFuture.supplyAsync(</span><br><span class="line">                            () -&gt; String.format(<span class="string">&quot;%s price is %.2f&quot;</span>,shop.getName(),shop.getPrice(product))</span><br><span class="line">                    )).collect(Collectors.toList());</span><br><span class="line">    <span class="comment">//等待所有异步操作结束，join方法与Future.get()含义相同，但不会抛出检测的异常</span></span><br><span class="line">    <span class="keyword">return</span> priceFuture.stream().map(CompletableFuture::join).collect(Collectors.toList());</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//输出如下</span></span><br><span class="line">[BestPrice price is <span class="number">137.63</span>, LetsSaveBig price is <span class="number">128.50</span>, MyFavoriteShop price is <span class="number">146.31</span>, BuyItAll price is <span class="number">193.07</span>]</span><br><span class="line">Done in <span class="number">1193</span> msecs</span><br></pre></td></tr></table></figure>



<p>我们使用了两个不同的Stream流水线，而不是在同一个处理流的流水线上链接两个map操作，考虑流操作之间的延迟性，如果在单一流水线中处理流，发像不同商家的请求只能以同步、顺序执行的方式才会成功。所以单一流水线时每个CompletableFuture对象只能在前一个操作结束之后执行查询指定商家的动作，通知join方法返回计算结果。</p>
<p>下图显式了为什么Stream的延迟特性会引起顺序执行，以及如何避免。</p>
<p><img src="https://pic-1258215793.cos.ap-shanghai.myqcloud.com/content/20190901/201909010152.png" alt="为什么Stream的延迟特性会引起顺序执行，以及如何避免"></p>
<p>使用CompletableFuture后的效率并不比并行流要高，究竟是因为什么？首先并行流能提高效率是因为它能并行的执行四个任务，那如果我们把商家增加到线程无法一一分配的数量呢？我在加到8个的时候还能保持在1s，但如果商家再多时间就会马上增加一倍。多出的商家只能等前面任务结束才能执行。如果是CompletableFuture版本呢？结果也会在达到线程上限时成倍增加耗时。</p>
<figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="attribute">Done</span> in <span class="number">1191</span> msecs //<span class="number">8</span>个商家</span><br><span class="line"><span class="attribute">Done</span> in <span class="number">2131</span> msecs //<span class="number">9</span>个商家</span><br></pre></td></tr></table></figure>



<p>两种方法都采用同样的通用线程池，具体线程数取决于Runtime.getRuntime().availableProcessors()。CompletableFuture的优势在于允许对执行其（Executor）进行配置，特别是线程池的大小，这是并行流所无法提供的。</p>
<h3 id="3-7-定制执行器"><a href="#3-7-定制执行器" class="headerlink" title="3.7 定制执行器"></a>3.7 定制执行器</h3><p>线程数量如何选择是一个问题，这里不作扩展，在并发编程部分再作整理。我们先用商店数目来作线程数，然后给一个上限以防服务器超负荷崩溃。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//创建一个线程数为100以及商店数目中较小数字数量的线程池</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> Executor executor = Executors.newFixedThreadPool(</span><br><span class="line">        Math.min(shops.size(), <span class="number">100</span>), <span class="keyword">new</span> ThreadFactory() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> Thread <span class="title">newThread</span><span class="params">(Runnable r)</span> </span>&#123;</span><br><span class="line">                Thread t = <span class="keyword">new</span> Thread(r);</span><br><span class="line">                <span class="comment">//使用守护线程，不会阻止程序的关停</span></span><br><span class="line">                t.setDaemon(<span class="keyword">true</span>);</span><br><span class="line">                <span class="keyword">return</span> t;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">);</span><br><span class="line"></span><br><span class="line">    List&lt;CompletableFuture&lt;String&gt;&gt; priceFuture =</span><br><span class="line">            shops.stream()</span><br><span class="line">                    .map(shop -&gt; CompletableFuture.supplyAsync(</span><br><span class="line">                            () -&gt; shop.getName() + <span class="string">&quot; price is &quot;</span> + shop.getPrice(product),executor)</span><br><span class="line">                    ).collect(Collectors.toList());</span><br><span class="line"></span><br><span class="line"><span class="comment">//输出如下</span></span><br><span class="line">[BestPrice price is <span class="number">159.6635803338069</span>, LetsSaveBig price is <span class="number">211.5815957999706</span>, MyFavoriteShop price is <span class="number">163.89033905158914</span>, BuyItAll price is <span class="number">207.90324683524352</span>, aaa price is <span class="number">228.41628707718928</span>, bbb price is <span class="number">217.44062760239154</span>, ccc price is <span class="number">228.53941558431086</span>, ddd price is <span class="number">124.72630278636122</span>, ddd price is <span class="number">207.93080231005356</span>]</span><br><span class="line">Done in <span class="number">1074</span> msecs</span><br></pre></td></tr></table></figure>



<p>经过线程优化后，耗时又降低到了1s。</p>
<blockquote>
<p>怎样选择流和CompletableFuture？</p>
<ul>
<li>如果要进行的是计算密集型操作，且没有I/O，推荐使用流。因为实现简单，效率也可能是最高的，如果所有线程都是计算密集型，就没有必要创建大于CPU核心数的线程了。</li>
<li>如果并行工作的单元还涉及到等待I/O的操作，则选择CompletableFuture灵活性会更好，还有一个原因是并行流不能清楚了判断触发等待的原因。</li>
</ul>
</blockquote>
<h3 id="3-8-对多个异步任务进行流水线操作"><a href="#3-8-对多个异步任务进行流水线操作" class="headerlink" title="3.8 对多个异步任务进行流水线操作"></a>3.8 对多个异步任务进行流水线操作</h3><h4 id="3-8-1-实现折扣服务"><a href="#3-8-1-实现折扣服务" class="headerlink" title="3.8.1 实现折扣服务"></a>3.8.1 实现折扣服务</h4><p>我们假设所以商店都同意使用一个集中式的折扣服务，总共有五种不同的折扣代码，对应不同的折扣率。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 折扣</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Discount</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="class"><span class="keyword">enum</span> <span class="title">Code</span></span>&#123;</span><br><span class="line">        NONE(<span class="number">0</span>),SILVER(<span class="number">5</span>),GOLD(<span class="number">10</span>),PLATINUM(<span class="number">15</span>),DIAMOND(<span class="number">20</span>);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">int</span> percentage;</span><br><span class="line"></span><br><span class="line">        Code(<span class="keyword">int</span> percentage) &#123;</span><br><span class="line">            <span class="keyword">this</span>.percentage = percentage;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> String <span class="title">applyDiscount</span><span class="params">(Quote quote)</span></span>&#123;</span><br><span class="line">        <span class="comment">//将折扣代码应用于商品原价</span></span><br><span class="line">        <span class="keyword">return</span> quote.getShopName() + <span class="string">&quot; price is &quot;</span> +</span><br><span class="line">                Discount.apply(quote.getPrice(),quote.getDiscountCode());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">double</span> <span class="title">apply</span><span class="params">(<span class="keyword">double</span> price, Code code)</span></span>&#123;</span><br><span class="line">        <span class="comment">//模拟Discount服务的响应延迟</span></span><br><span class="line">        delay();</span><br><span class="line">        <span class="keyword">return</span> price * (<span class="number">100</span> - code.percentage) / <span class="number">100</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p>然后实现getPrice方法增加了返回随机折扣价格，更新了所有商家的价格返回格式。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 获取商品以及随机折扣</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> product 产品</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> 价格</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> String <span class="title">getPrice</span><span class="params">(String product)</span></span>&#123;</span><br><span class="line">    <span class="keyword">double</span> price = calculatePrice(product);</span><br><span class="line">    Discount.Code code = Discount.Code.values()[<span class="keyword">new</span> Random().nextInt(Discount.Code.values().length)];</span><br><span class="line">    <span class="keyword">return</span> String.format(<span class="string">&quot;%s:%.2f:%s&quot;</span>,name,price,code);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p>实现了Quote类对新的返回格式字符串进行解析，静态工厂方法parse得到实例。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 解析商店返回字符串</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Quote</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> String shopName;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">double</span> price;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> Discount.Code discountCode;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Quote <span class="title">parse</span><span class="params">(String s)</span></span>&#123;</span><br><span class="line">        String[] split = s.split(<span class="string">&quot;:&quot;</span>);</span><br><span class="line">        String shopName = split[<span class="number">0</span>];</span><br><span class="line">        <span class="keyword">double</span> price = Double.parseDouble(split[<span class="number">1</span>]);</span><br><span class="line">        Discount.Code discountCode = Discount.Code.valueOf(split[<span class="number">2</span>]);</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> Quote(shopName,price,discountCode);</span><br><span class="line">    &#125;</span><br><span class="line">    ......</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h4 id="3-8-2-构造同步和异步操作"><a href="#3-8-2-构造同步和异步操作" class="headerlink" title="3.8.2 构造同步和异步操作"></a>3.8.2 构造同步和异步操作</h4><p>然后就是使用这些方法了，首先我们用最直接的顺序执行方式，实现getPrices方法。我们运行并观察性能，结果耗时10s，其中顺序查询5个商店耗时5s，又加上了Discount服务为5个商店返回价格申请折扣消耗5s。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> List&lt;String&gt; <span class="title">getPrices</span><span class="params">(String product)</span></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> shops.stream().map(shop -&gt; shop.getPrice(product))</span><br><span class="line">            <span class="comment">//通过Quote对shop返回字符串进行解析</span></span><br><span class="line">            .map(Quote::parse)</span><br><span class="line">            <span class="comment">//调用applyDiscount方法为每个Quote申请折扣</span></span><br><span class="line">            .map(Discount::applyDiscount)</span><br><span class="line">            .collect(Collectors.toList());</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//输出如下</span></span><br><span class="line">[BestPrice price is <span class="number">118.42199999999998</span>, LetsSaveBig price is <span class="number">166.13099999999997</span>, MyFavoriteShop price is <span class="number">136.0765</span>, BuyItAll price is <span class="number">166.00799999999998</span>, ShopEasy price is <span class="number">195.2365</span>]</span><br><span class="line">Done in <span class="number">10088</span> msecs</span><br></pre></td></tr></table></figure>



<p>直接转为并行流，耗时下降到2s。</p>
<figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="attribute">Done</span> in <span class="number">2116</span> msecs</span><br></pre></td></tr></table></figure>



<p><img src="https://pic-1258215793.cos.ap-shanghai.myqcloud.com/content/20190901/201909010153.png" alt="构造同步操作和异步任务"></p>
<p>通过CompletableFuture以异步方式重新实现getPrices方法。大概流程：shop对象——(supplyAsync)——&gt;shop.getPrice——(thenApply)——&gt;new Quote——(thenCompose)——&gt;applyDiscount——(join)——&gt;price对象。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> List&lt;String&gt; <span class="title">getPricesAsync</span><span class="params">(String product)</span></span>&#123;</span><br><span class="line">    List&lt;CompletableFuture&lt;String&gt;&gt; priceFuture =</span><br><span class="line">            shops.stream()</span><br><span class="line">                    <span class="comment">//以异步的方式取得每个shop中指定产品的价格</span></span><br><span class="line">                    .map(shop -&gt; CompletableFuture.supplyAsync(</span><br><span class="line">                            () -&gt; shop.getPrice(product),executor))</span><br><span class="line">                    <span class="comment">//当Quote对象存在时，对返回值进行转换</span></span><br><span class="line">                    .map(future -&gt; future.thenApply(Quote::parse))</span><br><span class="line">                    <span class="comment">//使用另一个异步任务构造期望的Future，申请折扣</span></span><br><span class="line">                    .map(future -&gt; future.thenCompose(</span><br><span class="line">                            quote -&gt; CompletableFuture.supplyAsync(</span><br><span class="line">                                    () -&gt; Discount.applyDiscount(quote),executor)))</span><br><span class="line">                    .collect(Collectors.toList());</span><br><span class="line">    <span class="comment">//等待流中所有Future执行完毕，提取各自返回值</span></span><br><span class="line">    <span class="keyword">return</span> priceFuture.stream().map(CompletableFuture::join).collect(Collectors.toList());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p><strong>获取价格</strong>，第一步以异步方式对shop查询，获得 <code>Stream&lt;CompletableFuture&lt;String&gt;&gt;</code> ，当操作结束每个CompletableFuture对象都包含着对应shop返回的字符串。</p>
<p><strong>解析报价</strong>，第二步将字符串转为订单，因为解析过程一般不涉及远程服务或I/O操作，几乎都会在第一时间进行，可以采用同步操作。当CompletableFuture最终结束运行时，传递Lambda表达式给thenApply，将流中的每个 <code>CompletableFuture&lt;String&gt;</code> 转换为 <code>CompletableFuture&lt;Quote&gt;</code> 。</p>
<p><strong>为计算折扣价格构造Future</strong>，第三步涉及到远程服务Discount，为从商店中获取的原价申请折扣率。这一步需要远程执行，所以应该异步执行。所以我们像第一步那样调用supplyAsync。最终实现了两步异步操作，用了两个CompletableFuture对象进行建模。我们想要把这两步操作以<strong>级联</strong>的方式串接起来工作。</p>
<p>从shop对象获取价格，把价格转换为Quote，拿到返回的Quote对象，参数传递给Discount服务，取得最终折扣价格。thenCompose方法允许我们对两个异步操作进行流水线，第一个操作完成时将结果作为参数传递给第二个操作。这样即使Future在向不同的商店收集报价时，主线程还能继续执行其他重要操作。thenCompose也有Async命名结尾版本，会为后续任务新开一个线程。这里选择thenCompose的原因是更高效一些，减少了线程切换的开销。</p>
<p>最后一步收集后，我们可以得到 <code>List&lt;CompletableFuture&lt;String&gt;&gt;</code> ，等待CompletableFuture对象都执行完毕，利用join方法取得返回值。</p>
<h4 id="3-8-3-将两个CompletableFuture对象整合起来，无论它们是否存在依赖"><a href="#3-8-3-将两个CompletableFuture对象整合起来，无论它们是否存在依赖" class="headerlink" title="3.8.3 将两个CompletableFuture对象整合起来，无论它们是否存在依赖"></a>3.8.3 将两个CompletableFuture对象整合起来，无论它们是否存在依赖</h4><p>getPricesAsync方法中我们对CompletableFuture对象调用了thenCompose，并传递了第二个CompletableFuture，第二个需要第一个的执行结果作为输入。有的时候我们需要将两个完全不相干的CompletableFuture对象的结果整合起来，且不希望二者是顺序执行。</p>
<p>thenCombine方法接受参数CompletionStage和BiFunction，BiFunction定义了两个CompletableFuture完成计算后如何合并。Async版本会把合并操作提交到线程池，由另一个任务异步执行。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> &lt;U,V&gt; <span class="function">CompletableFuture&lt;V&gt; <span class="title">thenCombine</span><span class="params">(</span></span></span><br><span class="line"><span class="params"><span class="function">    CompletionStage&lt;? extends U&gt; other,</span></span></span><br><span class="line"><span class="params"><span class="function">    BiFunction&lt;? <span class="keyword">super</span> T,? <span class="keyword">super</span> U,? extends V&gt; fn)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> biApplyStage(<span class="keyword">null</span>, other, fn);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> &lt;U,V&gt; <span class="function">CompletableFuture&lt;V&gt; <span class="title">thenCombineAsync</span><span class="params">(</span></span></span><br><span class="line"><span class="params"><span class="function">    CompletionStage&lt;? extends U&gt; other,</span></span></span><br><span class="line"><span class="params"><span class="function">    BiFunction&lt;? <span class="keyword">super</span> T,? <span class="keyword">super</span> U,? extends V&gt; fn, Executor executor)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> biApplyStage(screenExecutor(executor), other, fn);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> &lt;U&gt; <span class="function">CompletableFuture&lt;Void&gt; <span class="title">thenAcceptBoth</span><span class="params">(</span></span></span><br><span class="line"><span class="params"><span class="function">    CompletionStage&lt;? extends U&gt; other,</span></span></span><br><span class="line"><span class="params"><span class="function">    BiConsumer&lt;? <span class="keyword">super</span> T, ? <span class="keyword">super</span> U&gt; action)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> biAcceptStage(<span class="keyword">null</span>, other, action);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> &lt;U,V&gt; <span class="function">CompletableFuture&lt;V&gt; <span class="title">biApplyStage</span><span class="params">(</span></span></span><br><span class="line"><span class="params"><span class="function">    Executor e, CompletionStage&lt;U&gt; o,</span></span></span><br><span class="line"><span class="params"><span class="function">    BiFunction&lt;? <span class="keyword">super</span> T,? <span class="keyword">super</span> U,? extends V&gt; f)</span> </span>&#123;</span><br><span class="line">    CompletableFuture&lt;U&gt; b;</span><br><span class="line">    <span class="keyword">if</span> (f == <span class="keyword">null</span> || (b = o.toCompletableFuture()) == <span class="keyword">null</span>)</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> NullPointerException();</span><br><span class="line">    CompletableFuture&lt;V&gt; d = <span class="keyword">new</span> CompletableFuture&lt;V&gt;();</span><br><span class="line">    <span class="keyword">if</span> (e != <span class="keyword">null</span> || !d.biApply(<span class="keyword">this</span>, b, f, <span class="keyword">null</span>)) &#123;</span><br><span class="line">        BiApply&lt;T,U,V&gt; c = <span class="keyword">new</span> BiApply&lt;T,U,V&gt;(e, d, <span class="keyword">this</span>, b, f);</span><br><span class="line">        bipush(b, c);</span><br><span class="line">        c.tryFire(SYNC);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> d;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p>假设我们需要实现汇率转换的功能，以异步的方式来进行商店价格查询和远程的汇率查询，最后将二者结果进行合并，因为只是相乘合并，所以用Async版本新开线程有些浪费资源。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> Future&lt;Double&gt; <span class="title">a</span><span class="params">(Shop shop,String product)</span></span>&#123;</span><br><span class="line">    Future&lt;Double&gt; futurePriceUSD =</span><br><span class="line">            CompletableFuture.supplyAsync(</span><br><span class="line">                    () -&gt; shop.getPrice(product)</span><br><span class="line">            ).thenCombine(</span><br><span class="line">                    CompletableFuture.supplyAsync(</span><br><span class="line">                            () -&gt; ExchangeService.getRate(ExchangeService.Money.EUR, ExchangeService.Money.USD)</span><br><span class="line">                    ), (price, rate) -&gt; price * rate</span><br><span class="line">            );</span><br><span class="line">    <span class="keyword">return</span> futurePriceUSD;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p><img src="https://pic-1258215793.cos.ap-shanghai.myqcloud.com/content/20190901/201909010154.png" alt="合并两个相互独立的异步任务"></p>
<h4 id="3-8-4-回顾Future和CompletableFuture"><a href="#3-8-4-回顾Future和CompletableFuture" class="headerlink" title="3.8.4 回顾Future和CompletableFuture"></a>3.8.4 回顾Future和CompletableFuture</h4><p>我们通过实践可以感受到CompletableFuture相比Future的巨大优势，CompletableFuture可以利用Lambda表达式以声明式的API用最简单有效的方式吧多个同步或一部操作结合起来。</p>
<p>如果我们只用Future来实现上个汇率转换会如何？</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> Future&lt;Double&gt; <span class="title">converterFuture</span><span class="params">(Shop shop,String product)</span></span>&#123;</span><br><span class="line">    <span class="comment">//创建ExecutorService将任务提交到线程池</span></span><br><span class="line">    ExecutorService executor = Executors.newCachedThreadPool();</span><br><span class="line">    <span class="comment">//创建一个查询汇率转换的Future</span></span><br><span class="line">    <span class="keyword">final</span> Future&lt;Double&gt; futureRate = executor.submit(<span class="keyword">new</span> Callable&lt;Double&gt;() &#123;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> Double <span class="title">call</span><span class="params">()</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">            <span class="keyword">return</span> ExchangeService.getRate(ExchangeService.Money.EUR, ExchangeService.Money.USD);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;);</span><br><span class="line">    Future&lt;Double&gt; futurePriceUSD = executor.submit(<span class="keyword">new</span> Callable&lt;Double&gt;() &#123;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> Double <span class="title">call</span><span class="params">()</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">            <span class="keyword">double</span> priceInEUR = shop.getPrice(product);</span><br><span class="line">            <span class="keyword">return</span> priceInEUR * futureRate.get();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;);</span><br><span class="line">    <span class="keyword">return</span> futurePriceUSD;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p>对比两种实现，就可以对CompletableFuture的优势有直观感受。</p>
<h3 id="3-9-响应CompletableFuture的completion事件"><a href="#3-9-响应CompletableFuture的completion事件" class="headerlink" title="3.9 响应CompletableFuture的completion事件"></a>3.9 响应CompletableFuture的completion事件</h3><p>我们模拟远程服务调用都是通过1s的等待，但实际网络环境中延迟区别很大，可能因为服务器负荷、网络延迟等等。我们目前对价格的查询需要取得所有商店返回值才能显示，但实际上我们可能想要每个商店只要返回价格就第一时间显示返回值。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> Random random = <span class="keyword">new</span> Random();</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 模拟耗时操作，0.5s - 2.5s随机延迟</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">randomDelay</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> delay = <span class="number">500</span> + random.nextInt(<span class="number">2000</span>);</span><br><span class="line">    <span class="keyword">try</span>&#123;</span><br><span class="line">        Thread.sleep(delay);</span><br><span class="line">    &#125;<span class="keyword">catch</span> (InterruptedException ex)&#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p>所以首先我们不能用List来存放所有价格查询结果，应该直接处理CompletableFuture流，每个CompletableFuture对象都在为某个商店执行。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 重构findPrices方法返回一个Future构成的流</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> product</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> Stream&lt;CompletableFuture&lt;String&gt;&gt; findPricesStream(String product)&#123;</span><br><span class="line">    <span class="keyword">return</span> shops.stream()</span><br><span class="line">            .map(shop -&gt; CompletableFuture.supplyAsync(</span><br><span class="line">                    () -&gt; shop.getPrice(product),executor))</span><br><span class="line">            .map(future -&gt; future.thenApply(Quote::parse))</span><br><span class="line">            .map(future -&gt; future.thenCompose(</span><br><span class="line">                    quote -&gt; CompletableFuture.supplyAsync(</span><br><span class="line">                            () -&gt; Discount.applyDiscount(quote),executor</span><br><span class="line">                    )));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p>接下来我们要为CompletableFuture注册一个操作，此操作需要在CompletableFuture完成执行后使用其返回值。thenAccept方法接收CompletableFuture执行完毕后的返回值做参数。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">findPricesStream(<span class="string">&quot;myPhone27S&quot;</span>).map(f -&gt; f.thenAccept(System.out::println));</span><br></pre></td></tr></table></figure>



<p>当CompletableFuture计算结束，返回一个 <code>CompletableFuture&lt;Void&gt;</code> ，所以map方法返回 <code>Stream&lt;CompletableFuture&lt;Void&gt;&gt;</code> ，最终的返回我们能做的事情很有限，只能等待其运行结束。可能我们还希望让最慢的商店也可以打印价格，可以把Stream的所有 <code>CompletableFuture&lt;Void&gt;</code> 放到一个数组中，等待所有的任务执行完成。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">CompletableFuture[] futures = </span><br><span class="line">        findPricesStream(<span class="string">&quot;myPhone27S&quot;</span>)</span><br><span class="line">                .map(f -&gt; f.thenAccept(System.out::println))</span><br><span class="line">                .toArray(size -&gt; <span class="keyword">new</span> CompletableFuture[size]);</span><br><span class="line"><span class="comment">//allOf方法接收一个由CompletableFuture构成的数组，数组对象执行完毕后，返回一个CompletableFuture&lt;Void&gt;对象</span></span><br><span class="line">CompletableFuture.allOf(futures).join();</span><br></pre></td></tr></table></figure>



<p>如果希望在有任何一个执行完就不再等待，比如查询多个汇率服务器，只要得到一个就满足需求，可以使用工厂方法anyOf，接收一个由CompletableFuture构成的数组，数组对象执行完毕后，返回一个 <code>CompletableFuture&lt;Object&gt;</code> 对象。</p>
<hr>
<p>参考：</p>
<p>🔗 《Java8实战》</p>

    </div>

    
    
    

    <footer class="post-footer">
          

<div class="post-copyright">
<ul>
  <li class="post-copyright-author">
      <strong>本文作者： </strong>Lys
  </li>
  <li class="post-copyright-link">
      <strong>本文链接：</strong>
      <a href="http://linyishui.top/2019092801.html" title="CompletableFuture组合式异步编程">http://linyishui.top/2019092801.html</a>
  </li>
  <li class="post-copyright-license">
    <strong>版权声明： </strong>本博客所有文章除特别声明外，均采用 <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/deed.zh" rel="noopener" target="_blank"><i class="fab fa-fw fa-creative-commons"></i>BY-NC-SA</a> 许可协议。转载请注明出处！
  </li>
</ul>
</div>

          <div class="post-tags">
              <a href="/tags/java8/" rel="tag"><i class="fa fa-tag"></i> java8</a>
          </div>

        

          <div class="post-nav">
            <div class="post-nav-item">
                <a href="/2019092701.html" rel="prev" title="Optional">
                  <i class="fa fa-chevron-left"></i> Optional
                </a>
            </div>
            <div class="post-nav-item">
                <a href="/2019100101.html" rel="next" title="新的日期和时间API">
                  新的日期和时间API <i class="fa fa-chevron-right"></i>
                </a>
            </div>
          </div>
    </footer>
  </article>
</div>






    <div class="comments utterances-container"></div>
</div>
  </main>

  <footer class="footer">
    <div class="footer-inner">


<div class="copyright">
  &copy; 2018 – 
  <span itemprop="copyrightYear">2021</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">Lys</span>
</div>
<div class="wordcount">
  <span class="post-meta-item">
    <span class="post-meta-item-icon">
      <i class="fa fa-chart-line"></i>
    </span>
      <span>站点总字数：</span>
    <span title="站点总字数">3.2m</span>
  </span>
  <span class="post-meta-item">
    <span class="post-meta-item-icon">
      <i class="fa fa-coffee"></i>
    </span>
      <span>站点阅读时长 &asymp;</span>
    <span title="站点阅读时长">48:21</span>
  </span>
</div>
  <div class="powered-by">由 <a href="https://hexo.io/" rel="noopener" target="_blank">Hexo</a> & <a href="https://theme-next.js.org/pisces/" rel="noopener" target="_blank">NexT.Pisces</a> 强力驱动
  </div>

    </div>
  </footer>

  
  <script src="https://cdn.jsdelivr.net/npm/animejs@3.2.1/lib/anime.min.js" integrity="sha256-XL2inqUJaslATFnHdJOi9GfQ60on8Wx1C2H8DYiN1xY=" crossorigin="anonymous"></script>
  <script src="https://cdn.jsdelivr.net/npm/jquery@3.6.0/dist/jquery.min.js" integrity="sha256-/xUj+3OJU5yExlq6GSYGSHk7tPXikynS7ogEvDej/m4=" crossorigin="anonymous"></script>
  <script src="https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@3.5.7/dist/jquery.fancybox.min.js" integrity="sha256-yt2kYMy0w8AbtF89WXb2P1rfjcP/HTHLT7097U8Y5b8=" crossorigin="anonymous"></script>
<script src="/js/comments.js"></script><script src="/js/utils.js"></script><script src="/js/motion.js"></script><script src="/js/next-boot.js"></script><script src="/js/bookmark.js"></script>

  
<script src="/js/third-party/search/local-search.js"></script>



  <script class="next-config" data-name="nprogress" type="application/json">{"enable":true,"spinner":true}</script>
  <script src="/js/third-party/nprogress.js"></script>

  




<script src="https://cdn.jsdelivr.net/npm/darkmode-js@1.5.7/lib/darkmode-js.min.js"></script>

<script>
var options = {
  bottom: '64px',
  right: '32px',
  left: 'unset',
  time: '0.5s',
  mixColor: 'transparent',
  backgroundColor: 'transparent',
  buttonColorDark: '#100f2c',
  buttonColorLight: '#fff',
  saveInCookies: true,
  label: '🌓',
  autoMatchOsTheme: true
}
const darkmode = new Darkmode(options);
window.darkmode = darkmode;
darkmode.showWidget();
</script>
<script class="next-config" data-name="utterances" type="application/json">{"enable":true,"repo":"LAILAIWA/LAILAIWA.github.io","issue_term":"pathname","theme":"github-light"}</script>
<script src="/js/third-party/comments/utterances.js"></script>



</body>
</html>
