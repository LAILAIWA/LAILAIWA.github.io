<!DOCTYPE html>
<html lang="zh-CN">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width">
<meta name="theme-color" content="#222">
<meta name="generator" content="Hexo 5.4.0">


  <link rel="apple-touch-icon" sizes="180x180" href="/images/gamepad%20playstation.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/Dig%20Dug.ico">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/gamepad%20playstation.png">
  <link rel="mask-icon" href="/images/gamepad%20playstation.svg" color="#222">

<link rel="stylesheet" href="/css/main.css">

<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Monda:300,300italic,400,400italic,700,700italic%7CMa+Shan+Zheng:300,300italic,400,400italic,700,700italic%7CNoto+Serif+SC:300,300italic,400,400italic,700,700italic&display=swap&subset=latin,latin-ext">

<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free@5.15.3/css/all.min.css" integrity="sha256-2H3fkXt6FEmrReK448mDVGKb3WW2ZZw35gI7vqHOE4Y=" crossorigin="anonymous">
  <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/animate.css@3.1.1/animate.min.css" integrity="sha256-PR7ttpcvz8qrF57fur/yAx1qXMFJeJFiA6pSzWi0OIE=" crossorigin="anonymous">
  <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@3.5.7/dist/jquery.fancybox.min.css" integrity="sha256-Vzbj7sDDS/woiFS3uNKo8eIuni59rjyNGtXfstRzStA=" crossorigin="anonymous">
  <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/nprogress@0.2.0/nprogress.css" integrity="sha256-no0c5ccDODBwp+9hSmV5VvPpKwHCpbVzXHexIkupM6U=" crossorigin="anonymous">
  <script src="https://cdn.jsdelivr.net/npm/nprogress@0.2.0/nprogress.js" integrity="sha256-a5YRB27CcBwBFcT5EF/f3E4vzIqyHrSR878nseNYw64=" crossorigin="anonymous"></script>

<script class="next-config" data-name="main" type="application/json">{"hostname":"linyishui.top","root":"/","images":"/images","scheme":"Pisces","version":"8.6.0","exturl":false,"sidebar":{"position":"left","display":"always","padding":18,"offset":12},"copycode":true,"bookmark":{"enable":true,"color":"#222","save":"manual"},"fancybox":true,"mediumzoom":false,"lazyload":false,"pangu":false,"comments":{"style":"tabs","active":"utterances","storage":true,"lazyload":false,"nav":null,"activeClass":"utterances"},"motion":{"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"fadeInDown","post_body":"fadeInDown","coll_header":"fadeInLeft","sidebar":"fadeInUp"}},"prism":false,"i18n":{"placeholder":"搜索...","empty":"没有找到任何搜索结果：${query}","hits_time":"找到 ${hits} 个搜索结果（用时 ${time} 毫秒）","hits":"找到 ${hits} 个搜索结果"},"path":"/search.xml","localsearch":{"enable":true,"trigger":"auto","top_n_per_article":1,"unescape":false,"preload":false}}</script><script src="/js/config.js"></script>
<meta name="description" content="整理面试中常问的网络相关问题，持续更新中。">
<meta property="og:type" content="article">
<meta property="og:title" content="面试整理——网络">
<meta property="og:url" content="http://linyishui.top/2019102601.html">
<meta property="og:site_name" content="俺的部落格">
<meta property="og:description" content="整理面试中常问的网络相关问题，持续更新中。">
<meta property="og:locale" content="zh_CN">
<meta property="article:published_time" content="2019-10-26T08:23:48.000Z">
<meta property="article:modified_time" content="2025-02-22T06:50:59.366Z">
<meta property="article:author" content="Lys">
<meta property="article:tag" content="Q&amp;A">
<meta property="article:tag" content="updating">
<meta name="twitter:card" content="summary">


<link rel="canonical" href="http://linyishui.top/2019102601.html">



<script class="next-config" data-name="page" type="application/json">{"sidebar":"","isHome":false,"isPost":true,"lang":"zh-CN","comments":true,"permalink":"http://linyishui.top/2019102601.html","path":"2019102601.html","title":"面试整理——网络"}</script>

<script class="next-config" data-name="calendar" type="application/json">""</script>
<title>面试整理——网络 | 俺的部落格</title>
  




  <noscript>
    <link rel="stylesheet" href="/css/noscript.css">
  </noscript>
<link rel="alternate" href="/atom.xml" title="俺的部落格" type="application/atom+xml">
<style>.darkmode--activated{--body-bg-color:#282828;--content-bg-color:#333;--card-bg-color:#555;--text-color:#ccc;--blockquote-color:#bbb;--link-color:#ccc;--link-hover-color:#eee;--brand-color:#ddd;--brand-hover-color:#ddd;--table-row-odd-bg-color:#282828;--table-row-hover-bg-color:#363636;--menu-item-bg-color:#555;--btn-default-bg:#222;--btn-default-color:#ccc;--btn-default-border-color:#555;--btn-default-hover-bg:#666;--btn-default-hover-color:#ccc;--btn-default-hover-border-color:#666;--highlight-background:#282b2e;--highlight-foreground:#a9b7c6;--highlight-gutter-background:#34393d;--highlight-gutter-foreground:#9ca9b6}.darkmode--activated img{opacity:.75}.darkmode--activated img:hover{opacity:.9}.darkmode--activated code{color:#69dbdc;background:0 0}button.darkmode-toggle{z-index:9999}</style></head>

<body itemscope itemtype="http://schema.org/WebPage" class="use-motion">
  <div class="headband"></div>

  <main class="main">
    <header class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="切换导航栏" role="button">
        <span class="toggle-line"></span>
        <span class="toggle-line"></span>
        <span class="toggle-line"></span>
    </div>
  </div>

  <div class="site-meta">

    <a href="/" class="brand" rel="start">
      <i class="logo-line"></i>
      <h1 class="site-title">俺的部落格</h1>
      <i class="logo-line"></i>
    </a>
      <p class="site-subtitle" itemprop="description">俺寻思俺需要记点东西</p>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger">
        <i class="fa fa-search fa-fw fa-lg"></i>
    </div>
  </div>
</div>



<nav class="site-nav">
  <ul class="main-menu menu">
        <li class="menu-item menu-item-home"><a href="/" rel="section"><i class="fa fa-home fa-fw"></i>首页</a></li>
        <li class="menu-item menu-item-about"><a href="/about/" rel="section"><i class="fa fa-user fa-fw"></i>关于</a></li>
        <li class="menu-item menu-item-tags"><a href="/tags/" rel="section"><i class="fa fa-tags fa-fw"></i>标签</a></li>
        <li class="menu-item menu-item-categories"><a href="/categories/" rel="section"><i class="fa fa-th fa-fw"></i>分类</a></li>
        <li class="menu-item menu-item-archives"><a href="/archives/" rel="section"><i class="fa fa-archive fa-fw"></i>归档</a></li>
        <li class="menu-item menu-item-sitemap"><a href="/sitemap.xml" rel="section"><i class="fa fa-sitemap fa-fw"></i>站点地图</a></li>
        <li class="menu-item menu-item-tools"><a href="/links/" rel="section"><i class="fa fa-link fa-fw"></i>工具</a></li>
        <li class="menu-item menu-item-books"><a href="/books/" rel="section"><i class="fa fa-book fa-fw"></i>书架</a></li>
        <li class="menu-item menu-item-movies"><a href="/movies/" rel="section"><i class="fa fa-video fa-fw"></i>剧院</a></li>
        <li class="menu-item menu-item-games"><a href="/games/" rel="section"><i class="fa fa-gamepad fa-fw"></i>游戏</a></li>
        <li class="menu-item menu-item-commonweal"><a href="/404/" rel="section"><i class="fa fa-heartbeat fa-fw"></i>公益</a></li>
      <li class="menu-item menu-item-search">
        <a role="button" class="popup-trigger"><i class="fa fa-search fa-fw"></i>搜索
        </a>
      </li>
  </ul>
</nav>



  <div class="search-pop-overlay">
    <div class="popup search-popup"><div class="search-header">
  <span class="search-icon">
    <i class="fa fa-search"></i>
  </span>
  <div class="search-input-container">
    <input autocomplete="off" autocapitalize="off" maxlength="80"
           placeholder="搜索..." spellcheck="false"
           type="search" class="search-input">
  </div>
  <span class="popup-btn-close" role="button">
    <i class="fa fa-times-circle"></i>
  </span>
</div>
<div class="search-result-container no-result">
  <div class="search-result-icon">
    <i class="fa fa-spinner fa-pulse fa-5x"></i>
  </div>
</div>

    </div>
  </div>

</div>
        
  
  <div class="toggle sidebar-toggle" role="button">
    <span class="toggle-line"></span>
    <span class="toggle-line"></span>
    <span class="toggle-line"></span>
  </div>

  <aside class="sidebar">

    <div class="sidebar-inner sidebar-nav-active sidebar-toc-active">
      <ul class="sidebar-nav">
        <li class="sidebar-nav-toc">
          文章目录
        </li>
        <li class="sidebar-nav-overview">
          站点概览
        </li>
      </ul>

      <div class="sidebar-panel-container">
        <!--noindex-->
        <div class="post-toc-wrap sidebar-panel">
            <div class="post-toc animated"><ol class="nav"><li class="nav-item nav-level-1"><a class="nav-link" href="#%E7%BD%91%E7%BB%9C"><span class="nav-text">网络</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#%E4%B8%80-%E7%BB%BC%E5%90%88"><span class="nav-text">一. 综合</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E9%97%AE%EF%BC%9A%E6%B5%8F%E8%A7%88%E5%99%A8%E8%BE%93%E5%85%A5url%E5%8F%91%E7%94%9F%E4%BA%86%E4%BB%80%E4%B9%88%EF%BC%9F%E4%B8%80%E4%B8%AAurl%E4%BB%8E%E8%BE%93%E5%85%A5%E5%88%B0%E8%AE%BF%E9%97%AE%E7%BB%8F%E8%BF%87%E4%BA%86%E5%93%AA%E4%BA%9B%E8%BF%87%E7%A8%8B%EF%BC%9F%E7%BB%86%E8%AF%B4%EF%BC%8C%E5%8C%85%E6%8B%AC%E6%AF%8F%E4%B8%80%E5%B1%82%E6%B6%89%E5%8F%8A%E5%88%B0%E7%9A%84%E5%8D%8F%E8%AE%AE"><span class="nav-text">问：浏览器输入url发生了什么？一个url从输入到访问经过了哪些过程？细说，包括每一层涉及到的协议</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E9%97%AE%EF%BC%9AOSI-%E4%B8%83%E5%B1%82%E6%A8%A1%E5%9E%8B%EF%BC%9F%E4%BA%94%E5%B1%82%E5%8D%8F%E8%AE%AE%EF%BC%9FTCP-IP%EF%BC%9F"><span class="nav-text">问：OSI 七层模型？五层协议？TCP&#x2F;IP？</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E9%97%AE%EF%BC%9A%E4%B8%BE%E4%BE%8B%E7%BD%91%E7%BB%9C%E5%8D%8F%E8%AE%AE%EF%BC%8C%E9%83%BD%E5%9C%A8%E5%93%AA%E4%B8%AA%E5%B1%82%EF%BC%9F"><span class="nav-text">问：举例网络协议，都在哪个层？</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E9%97%AE%EF%BC%9A%E7%BD%91%E7%BB%9C%E5%B1%82%E5%92%8C%E4%BC%A0%E8%BE%93%E5%B1%82%E5%A6%82%E4%BD%95%E5%8C%BA%E5%88%86%EF%BC%9F"><span class="nav-text">问：网络层和传输层如何区分？</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E9%97%AE%EF%BC%9A%E8%AE%B2%E4%B8%80%E4%B8%8B%E7%89%A9%E7%90%86%E5%B1%82%E7%9A%84%E4%B8%89%E7%A7%8D%E9%80%9A%E4%BF%A1%E6%96%B9%E5%BC%8F%EF%BC%9F"><span class="nav-text">问：讲一下物理层的三种通信方式？</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E9%97%AE%EF%BC%9A%E8%AE%B2%E4%B8%80%E4%B8%8B%E4%BF%A1%E9%81%93%E5%A4%8D%E7%94%A8%E6%8A%80%E6%9C%AF%EF%BC%9F"><span class="nav-text">问：讲一下信道复用技术？</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E9%97%AE%EF%BC%9A%E8%B7%AF%E7%94%B1%E5%99%A8%E6%98%AF%E5%A6%82%E4%BD%95%E5%B7%A5%E4%BD%9C%E7%9A%84%EF%BC%9F"><span class="nav-text">问：路由器是如何工作的？</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E9%97%AE%EF%BC%9AMAC%E5%9C%B0%E5%9D%80%E9%95%BF%E5%BA%A6%EF%BC%9F%E5%A6%82%E4%BD%95%E4%BF%9D%E8%AF%81%E6%AF%8F%E5%8F%B0%E6%9C%BA%E5%99%A8%E5%9C%B0%E5%9D%80%E4%B8%8D%E5%90%8C%EF%BC%9F"><span class="nav-text">问：MAC地址长度？如何保证每台机器地址不同？</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E9%97%AE%EF%BC%9A%E9%95%BF%E8%BF%9E%E6%8E%A5%E5%92%8C%E7%9F%AD%E8%BF%9E%E6%8E%A5%EF%BC%8C%E8%BF%9E%E6%8E%A5%E6%B1%A0%E9%80%82%E5%90%88%E9%95%BF%E8%BF%9E%E6%8E%A5%E8%BF%98%E6%98%AF%E7%9F%AD%E8%BF%9E%E6%8E%A5%EF%BC%9F"><span class="nav-text">问：长连接和短连接，连接池适合长连接还是短连接？</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E9%97%AE%EF%BC%9A%E8%AE%B2%E4%B8%80%E4%B8%8B%E5%8D%8A%E8%BF%9E%E6%8E%A5%E6%94%BB%E5%87%BB%EF%BC%9F"><span class="nav-text">问：讲一下半连接攻击？</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E9%97%AE%EF%BC%9A%E8%AE%B2%E4%B8%80%E4%B8%8BNAT%EF%BC%9F"><span class="nav-text">问：讲一下NAT？</span></a></li></ol></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E4%BA%8C-TCP-IP"><span class="nav-text">二. TCP&#x2F;IP</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E9%97%AE%EF%BC%9ATCP%E5%92%8CUDP%E7%9A%84%E5%8C%BA%E5%88%AB%EF%BC%9Fudp%E4%B8%BA%E4%BB%80%E4%B9%88%E8%A6%81%E6%AF%94tcp%E5%BF%AB%EF%BC%9F"><span class="nav-text">问：TCP和UDP的区别？udp为什么要比tcp快？</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E9%97%AE%EF%BC%9ATCP%E5%A6%82%E4%BD%95%E5%AE%9E%E7%8E%B0%E5%8F%AF%E9%9D%A0%E8%BF%9E%E6%8E%A5-%E4%BC%A0%E8%BE%93%EF%BC%9F"><span class="nav-text">问：TCP如何实现可靠连接&#x2F;传输？</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E9%97%AE%EF%BC%9A%E4%B8%BA%E4%BB%80%E4%B9%88%E8%A6%81%E6%9C%89TimeWait%E7%8A%B6%E6%80%81%EF%BC%9FTimeWait%E7%9A%84%E7%AD%89%E5%BE%85%E6%97%B6%E9%95%BF%E4%B8%80%E8%88%AC%E6%98%AF%E5%A4%9A%E5%B0%91%EF%BC%9F%E4%B8%BA%E4%BB%80%E4%B9%88Time-Wait%E4%B8%AD2-msl%EF%BC%9F"><span class="nav-text">问：为什么要有TimeWait状态？TimeWait的等待时长一般是多少？为什么Time_Wait中2*msl？</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E9%97%AE%EF%BC%9A%E5%A6%82%E6%9E%9CTCP%E7%AA%81%E7%84%B6%E6%8E%A5%E6%94%B6%E6%96%B9%E6%95%85%E9%9A%9C%E4%BC%9A%E5%8F%91%E7%94%9F%E4%BB%80%E4%B9%88%EF%BC%9F"><span class="nav-text">问：如果TCP突然接收方故障会发生什么？</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E9%97%AE%EF%BC%9ATCP%E6%80%8E%E4%B9%88%E8%AE%A1%E7%AE%97%E7%BD%91%E7%BB%9C%E5%BB%B6%E8%BF%9F%EF%BC%9F"><span class="nav-text">问：TCP怎么计算网络延迟？</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E9%97%AE%EF%BC%9ATCP%E4%B8%89%E6%AC%A1%E6%8F%A1%E6%89%8B%E5%92%8C%E5%9B%9B%E6%AC%A1%E6%8C%A5%E6%89%8B%EF%BC%9F"><span class="nav-text">问：TCP三次握手和四次挥手？</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E9%97%AE%EF%BC%9A%E4%B8%BA%E4%BB%80%E4%B9%88%E8%A6%81%E8%BF%9B%E8%A1%8C%E7%AC%AC%E4%B8%89%E6%AC%A1%E6%8F%A1%E6%89%8B%EF%BC%8C%E8%80%8C%E4%B8%8D%E6%98%AF%E4%BA%8C%E6%AC%A1%EF%BC%9F%E4%B8%BA%E4%BB%80%E4%B9%88%E8%BF%9E%E6%8E%A5%E6%97%B6%E6%98%AF%E4%B8%89%E6%AC%A1%EF%BC%8C%E9%87%8A%E6%94%BE%E6%97%B6%E5%8D%B4%E6%98%AF%E5%9B%9B%E6%AC%A1%EF%BC%9F"><span class="nav-text">问：为什么要进行第三次握手，而不是二次？为什么连接时是三次，释放时却是四次？</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E9%97%AE%EF%BC%9A%E4%B8%BA%E4%BB%80%E4%B9%88%E5%AE%A2%E6%88%B7%E7%AB%AF%E5%8F%91%E5%87%BA%E7%AC%AC%E5%9B%9B%E6%AC%A1%E6%8C%A5%E6%89%8B%E7%9A%84%E7%A1%AE%E8%AE%A4%E6%8A%A5%E6%96%87%E5%90%8E%E8%A6%81%E7%AD%892MSL%E7%9A%84%E6%97%B6%E9%97%B4%E6%89%8D%E8%83%BD%E9%87%8A%E6%94%BETCP%E8%BF%9E%E6%8E%A5%EF%BC%9F"><span class="nav-text">问：为什么客户端发出第四次挥手的确认报文后要等2MSL的时间才能释放TCP连接？</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E9%97%AE%EF%BC%9ATCP%E6%9C%89%E5%93%AA%E4%BA%9B%E7%8A%B6%E6%80%81%EF%BC%8C%E7%9B%B8%E5%BA%94%E7%8A%B6%E6%80%81%E7%9A%84%E5%90%AB%E4%B9%89%EF%BC%9F"><span class="nav-text">问：TCP有哪些状态，相应状态的含义？</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E9%97%AE%EF%BC%9A%E8%AF%B4%E4%B8%80%E4%B8%8Bdns%E7%9A%84%E5%8E%9F%E7%90%86%EF%BC%9F"><span class="nav-text">问：说一下dns的原理？</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E6%AD%A5%E9%AA%A4-1%EF%BC%9A%E6%9C%AC%E5%9C%B0%E7%BC%93%E5%AD%98%E6%9F%A5%E8%AF%A2"><span class="nav-text">步骤 1：本地缓存查询</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E6%AD%A5%E9%AA%A4-2%EF%BC%9A%E9%80%92%E5%BD%92-DNS-%E6%9F%A5%E8%AF%A2"><span class="nav-text">步骤 2：递归 DNS 查询</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E6%AD%A5%E9%AA%A4-3%EF%BC%9A%E6%9F%A5%E8%AF%A2%E6%A0%B9-DNS-%E6%9C%8D%E5%8A%A1%E5%99%A8"><span class="nav-text">步骤 3：查询根 DNS 服务器</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E6%AD%A5%E9%AA%A4-4%EF%BC%9A%E6%9F%A5%E8%AF%A2-TLD-DNS-%E6%9C%8D%E5%8A%A1%E5%99%A8"><span class="nav-text">步骤 4：查询 TLD DNS 服务器</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E6%AD%A5%E9%AA%A4-5%EF%BC%9A%E6%9F%A5%E8%AF%A2%E6%9D%83%E5%A8%81-DNS-%E6%9C%8D%E5%8A%A1%E5%99%A8"><span class="nav-text">步骤 5：查询权威 DNS 服务器</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E6%AD%A5%E9%AA%A4-6%EF%BC%9A%E5%B0%86%E7%BB%93%E6%9E%9C%E8%BF%94%E5%9B%9E%E7%BB%99%E5%AE%A2%E6%88%B7%E7%AB%AF"><span class="nav-text">步骤 6：将结果返回给客户端</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E9%97%AE%EF%BC%9ATCP%E6%8B%A5%E5%A1%9E%E6%8E%A7%E5%88%B6%EF%BC%9F"><span class="nav-text">问：TCP拥塞控制？</span></a></li></ol></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E4%B8%89-HTTP"><span class="nav-text">三. HTTP</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E9%97%AE%EF%BC%9A%E7%AE%80%E5%8D%95%E8%B0%88%E8%B0%88%E5%AF%B9HTTP%E7%9A%84%E4%BA%86%E8%A7%A3%EF%BC%9F"><span class="nav-text">问：简单谈谈对HTTP的了解？</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E9%97%AE%EF%BC%9AHTTPS%E5%92%8CHTTP%E7%9A%84%E5%8C%BA%E5%88%AB%EF%BC%9F"><span class="nav-text">问：HTTPS和HTTP的区别？</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E9%97%AE%EF%BC%9A%E8%AF%B4%E4%B8%80%E4%B8%8Bpost%E5%92%8Cput%E7%9A%84%E6%95%B0%E6%8D%AE%E6%98%AF%E6%94%BE%E5%9C%A8%E5%93%AA%E4%B8%AA%E5%AD%97%E6%AE%B5%EF%BC%9F"><span class="nav-text">问：说一下post和put的数据是放在哪个字段？</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E9%97%AE%EF%BC%9AHTTP%E7%8A%B6%E6%80%81%E7%A0%81%E5%90%AB%E4%B9%89%EF%BC%9A503%EF%BC%8C504%EF%BC%8C505%EF%BC%8C403%EF%BC%8C200%EF%BC%9F"><span class="nav-text">问：HTTP状态码含义：503，504，505，403，200？</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E9%97%AE%EF%BC%9AGET%E5%92%8CPOST%E5%8C%BA%E5%88%AB%EF%BC%9F"><span class="nav-text">问：GET和POST区别？</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E9%97%AE%EF%BC%9A%E7%9F%A5%E9%81%93HTTP1-0%E5%92%8C1-1%E7%9A%84%E5%8C%BA%E5%88%AB%E4%B9%88%EF%BC%9F"><span class="nav-text">问：知道HTTP1.0和1.1的区别么？</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E9%97%AE%EF%BC%9A%E8%B0%88%E8%B0%88%E4%BB%80%E4%B9%88%E6%98%AFHTTP%E7%9A%84%E9%95%BF%E8%BF%9E%E6%8E%A5%E5%92%8C%E7%9F%AD%E8%BF%9E%E6%8E%A5%EF%BC%9F"><span class="nav-text">问：谈谈什么是HTTP的长连接和短连接？</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E9%97%AE%EF%BC%9Acookie%E3%80%81session%E3%80%81token%E4%B8%89%E8%80%85%E5%8C%BA%E5%88%AB%E4%BB%A5%E5%8F%8A%E4%BC%98%E7%BC%BA%E7%82%B9%EF%BC%9F"><span class="nav-text">问：cookie、session、token三者区别以及优缺点？</span></a></li></ol></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E7%BD%91%E7%BB%9C%E5%AE%89%E5%85%A8"><span class="nav-text">网络安全</span></a></li></ol></li></ol></div>
        </div>
        <!--/noindex-->

        <div class="site-overview-wrap sidebar-panel">
          <div class="site-overview">
            <div class="site-author site-overview-item animated" itemprop="author" itemscope itemtype="http://schema.org/Person">
    <img class="site-author-image" itemprop="image" alt="Lys"
      src="https://pic-1258215793.cos.ap-shanghai.myqcloud.com/cover/IMG_0759.JPG">
  <p class="site-author-name" itemprop="name">Lys</p>
  <div class="site-description" itemprop="description">记录编程点滴，写点生活中的酸甜</div>
</div>
<div class="site-state-wrap site-overview-item animated">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
          <a href="/archives/">
        
          <span class="site-state-item-count">340</span>
          <span class="site-state-item-name">日志</span>
        </a>
      </div>
      <div class="site-state-item site-state-categories">
            <a href="/categories/">
          
        <span class="site-state-item-count">13</span>
        <span class="site-state-item-name">分类</span></a>
      </div>
      <div class="site-state-item site-state-tags">
            <a href="/tags/">
          
        <span class="site-state-item-count">113</span>
        <span class="site-state-item-name">标签</span></a>
      </div>
  </nav>
</div>
  <div class="links-of-author site-overview-item animated">
      <span class="links-of-author-item">
        <a href="https://github.com/LAILAIWA" title="GitHub → https:&#x2F;&#x2F;github.com&#x2F;LAILAIWA" rel="noopener" target="_blank"><i class="fab fa-github fa-fw"></i>GitHub</a>
      </span>
      <span class="links-of-author-item">
        <a href="mailto:linyishui168@outlook.com" title="E-Mail → mailto:linyishui168@outlook.com" rel="noopener" target="_blank"><i class="fa fa-envelope fa-fw"></i>E-Mail</a>
      </span>
      <span class="links-of-author-item">
        <a href="https://weibo.com/u/5340162234" title="Weibo → https:&#x2F;&#x2F;weibo.com&#x2F;u&#x2F;5340162234" rel="noopener" target="_blank"><i class="fab fa-weibo fa-fw"></i>Weibo</a>
      </span>
      <span class="links-of-author-item">
        <a href="https://twitter.com/linyishui618" title="Twitter → https:&#x2F;&#x2F;twitter.com&#x2F;linyishui618" rel="noopener" target="_blank"><i class="fab fa-twitter fa-fw"></i>Twitter</a>
      </span>
      <span class="links-of-author-item">
        <a href="https://stackoverflow.com/users/13018339/lin-yishui" title="StackOverflow → https:&#x2F;&#x2F;stackoverflow.com&#x2F;users&#x2F;13018339&#x2F;lin-yishui" rel="noopener" target="_blank"><i class="fab fa-stack-overflow fa-fw"></i>StackOverflow</a>
      </span>
      <span class="links-of-author-item">
        <a href="https://instagram.com/linyishui618" title="Instagram → https:&#x2F;&#x2F;instagram.com&#x2F;linyishui618" rel="noopener" target="_blank"><i class="fab fa-instagram fa-fw"></i>Instagram</a>
      </span>
  </div>
  <div class="cc-license site-overview-item animated" itemprop="license">
    <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/deed.zh" class="cc-opacity" rel="noopener" target="_blank"><img src="https://cdn.jsdelivr.net/npm/@creativecommons/vocabulary@2020.11.3/assets/license_badges/small/by_nc_sa.svg" alt="Creative Commons"></a>
  </div>


  <div class="links-of-blogroll site-overview-item animated">
    <div class="links-of-blogroll-title"><i class="far fa-smile-wink fa-fw"></i>
      个人
    </div>
    <ul class="links-of-blogroll-list">
        <li class="links-of-blogroll-item">
          <a href="https://music.163.com/#/user/home?id=68425607" title="https:&#x2F;&#x2F;music.163.com&#x2F;#&#x2F;user&#x2F;home?id&#x3D;68425607" rel="noopener" target="_blank">网易云音乐</a>
        </li>
    </ul>
  </div>

          </div>
        </div>
    </div>
  </aside>
  <div class="sidebar-dimmer"></div>


    </header>

    
  <div class="back-to-top" role="button" aria-label="返回顶部">
    <i class="fa fa-arrow-up"></i>
    <span>0%</span>
  </div>
  <a role="button" class="book-mark-link book-mark-link-fixed"></a>

  <a href="https://github.com/LAILAIWA" class="github-corner" title="Follow me on GitHub" aria-label="Follow me on GitHub" rel="noopener" target="_blank"><svg width="80" height="80" viewBox="0 0 250 250" aria-hidden="true"><path d="M0,0 L115,115 L130,115 L142,142 L250,250 L250,0 Z"></path><path d="M128.3,109.0 C113.8,99.7 119.0,89.6 119.0,89.6 C122.0,82.7 120.5,78.6 120.5,78.6 C119.2,72.0 123.4,76.3 123.4,76.3 C127.3,80.9 125.5,87.3 125.5,87.3 C122.9,97.6 130.6,101.9 134.4,103.2" fill="currentColor" style="transform-origin: 130px 106px;" class="octo-arm"></path><path d="M115.0,115.0 C114.9,115.1 118.7,116.5 119.8,115.4 L133.7,101.6 C136.9,99.2 139.9,98.4 142.2,98.6 C133.8,88.0 127.5,74.4 143.8,58.0 C148.5,53.4 154.0,51.2 159.7,51.0 C160.3,49.4 163.2,43.6 171.4,40.1 C171.4,40.1 176.1,42.5 178.8,56.2 C183.1,58.6 187.2,61.8 190.9,65.4 C194.5,69.0 197.7,73.2 200.1,77.6 C213.8,80.2 216.3,84.9 216.3,84.9 C212.7,93.1 206.9,96.0 205.4,96.6 C205.1,102.4 203.0,107.8 198.3,112.5 C181.9,128.9 168.3,122.5 157.7,114.1 C157.9,116.9 156.7,120.9 152.7,124.9 L141.0,136.5 C139.8,137.7 141.6,141.9 141.8,141.8 Z" fill="currentColor" class="octo-body"></path></svg></a>

<noscript>
  <div class="noscript-warning">Theme NexT works best with JavaScript enabled</div>
</noscript>


    <div class="main-inner post posts-expand">


  


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://linyishui.top/2019102601.html">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="https://pic-1258215793.cos.ap-shanghai.myqcloud.com/cover/IMG_0759.JPG">
      <meta itemprop="name" content="Lys">
      <meta itemprop="description" content="记录编程点滴，写点生活中的酸甜">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="俺的部落格">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          面试整理——网络
        </h1>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>

      <time title="创建时间：2019-10-26 16:23:48" itemprop="dateCreated datePublished" datetime="2019-10-26T16:23:48+08:00">2019-10-26</time>
    </span>
      <span class="post-meta-item">
        <span class="post-meta-item-icon">
          <i class="far fa-calendar-check"></i>
        </span>
        <span class="post-meta-item-text">更新于</span>
        <time title="修改时间：2025-02-22 14:50:59" itemprop="dateModified" datetime="2025-02-22T14:50:59+08:00">2025-02-22</time>
      </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">分类于</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/%E9%9D%A2%E8%AF%95%E6%95%B4%E7%90%86/" itemprop="url" rel="index"><span itemprop="name">面试整理</span></a>
        </span>
    </span>

  
      </div>
      <div class="post-meta">
    <span class="post-meta-item" title="本文字数">
      <span class="post-meta-item-icon">
        <i class="far fa-file-word"></i>
      </span>
      <span class="post-meta-item-text">本文字数：</span>
      <span>55k</span>
    </span>
    <span class="post-meta-item" title="阅读时长">
      <span class="post-meta-item-icon">
        <i class="far fa-clock"></i>
      </span>
      <span class="post-meta-item-text">阅读时长 &asymp;</span>
      <span>50 分钟</span>
    </span>
</div>

            <div class="post-description">整理面试中常问的网络相关问题，持续更新中。</div>
        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
        <h1 id="网络"><a href="#网络" class="headerlink" title="网络"></a>网络</h1><h2 id="一-综合"><a href="#一-综合" class="headerlink" title="一. 综合"></a>一. 综合</h2><h4 id="问：浏览器输入url发生了什么？一个url从输入到访问经过了哪些过程？细说，包括每一层涉及到的协议"><a href="#问：浏览器输入url发生了什么？一个url从输入到访问经过了哪些过程？细说，包括每一层涉及到的协议" class="headerlink" title="问：浏览器输入url发生了什么？一个url从输入到访问经过了哪些过程？细说，包括每一层涉及到的协议"></a>问：浏览器输入url发生了什么？一个url从输入到访问经过了哪些过程？细说，包括每一层涉及到的协议</h4><ol>
<li><p><strong>用户输入 URL</strong>：假设用户输入的 URL 为 <code>https://www.example.com/index.html</code>。</p>
</li>
<li><p><strong>浏览器解析 URL</strong>：浏览器将 URL 分解为以下部分：</p>
<ul>
<li><strong>协议（Scheme）</strong>：<code>https</code>，表示使用 HTTPS 协议。</li>
<li><strong>域名（Host）</strong>：<code>www.example.com</code>，指向的服务器的域名。</li>
<li><strong>路径（Path）</strong>：<code>/index.html</code>，服务器上的资源路径。</li>
<li><strong>端口（Port）</strong>：HTTPS 默认端口为 443。</li>
<li><strong>查询参数和哈希</strong>（如果有）：比如 URL 中的 <code>?id=123#section1</code>。</li>
</ul>
</li>
<li><p><strong>DNS 查询</strong>：向 DNS 服务器查询域名对应的 IP 地址。</p>
<ul>
<li><p><strong>目的</strong>：将域名 <code>www.example.com</code> 转换为 IP 地址，以便与目标服务器建立连接。</p>
</li>
<li><p>协议：使用 DNS（Domain Name System）协议。</p>
<ul>
<li>浏览器首先检查本地缓存中是否有 <code>www.example.com</code> 的 IP 地址。</li>
<li>如果没有，浏览器会向 DNS 服务器发起查询请求（UDP 协议），可能通过递归查询的方式找到最终的 IP 地址。</li>
<li>DNS 响应返回 IP 地址（如 <code>93.184.216.34</code>），用于后续的连接。</li>
</ul>
</li>
</ul>
</li>
<li><p><strong>建立 TCP 连接</strong></p>
<ul>
<li><p><strong>目的</strong>：在浏览器和目标服务器之间建立一个可靠的连接，确保数据的可靠传输。</p>
</li>
<li><p>协议：TCP（Transmission Control Protocol），是一个面向连接、可靠的传输协议。</p>
<ul>
<li><p>三次握手：浏览器（客户端）与服务器建立连接的过程。</p>
<ol>
<li><strong>SYN</strong>（Synchronize Sequence Numbers）同步序列编号：客户端发送连接请求，发送一个带 SYN 标志的包。</li>
<li><strong>SYN-ACK</strong>：服务器响应并确认客户端请求，发送带 SYN 和 ACK 标志的包。</li>
<li><strong>ACK</strong>：客户端确认接收到服务器的响应，连接建立完成。</li>
</ol>
</li>
<li><p>建立连接后，客户端与服务器之间可以开始传输数据。</p>
</li>
</ul>
</li>
</ul>
</li>
<li><p><strong>SSL/TLS 握手（HTTPS 特有）</strong></p>
<ul>
<li><p><strong>目的</strong>：通过 SSL/TLS 加密协议保护数据传输的机密性、完整性和身份验证。</p>
</li>
<li><p><strong>协议</strong>：<strong>SSL/TLS</strong>（Secure Sockets Layer / Transport Layer Security），主要包括以下步骤：</p>
<ul>
<li><strong>客户端Hello</strong>：客户端向服务器发送支持的加密算法（如 AES、RSA）、随机数等信息。</li>
<li><strong>服务器Hello</strong>：服务器响应，选择加密算法，发送服务器的 SSL/TLS 证书（包含公钥）。</li>
<li><strong>密钥交换</strong>：客户端通过公钥加密一个随机生成的对称加密密钥（称为 “Pre-master secret”），并发送给服务器。</li>
<li><strong>双方计算密钥</strong>：客户端和服务器使用各自的私钥和预主密钥，生成对称加密密钥。</li>
<li><strong>完成握手</strong>：双方使用对称加密密钥加密后续的通信数据。</li>
</ul>
<p>这样，整个通信过程就被加密，确保了数据的安全性。</p>
</li>
</ul>
</li>
<li><p><strong>发送 HTTP 请求</strong></p>
<ul>
<li><p><strong>目的</strong>：浏览器向服务器请求所需的资源（如网页、图片等）。</p>
</li>
<li><p>协议：HTTP/HTTPS（HyperText Transfer Protocol / HyperText Transfer Protocol Secure）。</p>
<ul>
<li>浏览器向服务器发送一个 HTTP 请求报文，通常是一个 <strong>GET</strong> 请求，表示请求访问指定的 URL（如 <code>GET /index.html HTTP/1.1</code>）。</li>
<li>HTTP 请求报文的格式包括：<ul>
<li>请求方法（如 GET、POST）。</li>
<li>请求 URL（如 <code>/index.html</code>）。</li>
<li>协议版本（如 HTTP/1.1）。</li>
<li>请求头（包括 <code>User-Agent</code>、<code>Accept</code>、<code>Cookie</code> 等信息）。</li>
<li>（如果是 POST 请求）请求体（包含用户提交的数据）。</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li><p><strong>服务器处理请求</strong></p>
<ul>
<li><p><strong>目的</strong>：服务器接收到请求后，处理并返回所需的资源。</p>
</li>
<li><p>协议：HTTP/HTTPS。</p>
<ul>
<li>服务器根据请求的 URL 和其他信息，查找相应的资源（如文件、数据库查询结果等）。</li>
<li>服务器可能会动态生成网页内容（如 PHP、Java 或 Python 后端代码生成的 HTML），或者返回静态文件（如 <code>index.html</code>）。</li>
<li>服务器将响应数据通过 HTTP/HTTPS 协议返回给浏览器。</li>
</ul>
</li>
</ul>
</li>
<li><p><strong>接收 HTTP 响应</strong></p>
<ul>
<li><p><strong>目的</strong>：浏览器接收服务器返回的 HTTP 响应，处理并渲染页面。</p>
</li>
<li><p>协议：HTTP/HTTPS。</p>
<ul>
<li>HTTP 响应报文格式包括：<ul>
<li>响应状态码（如 <code>200 OK</code>，<code>404 Not Found</code>）。</li>
<li>响应头（如 <code>Content-Type</code>、<code>Set-Cookie</code>、<code>Cache-Control</code> 等）。</li>
<li>响应体（实际的网页内容、图片、视频等资源）。</li>
</ul>
</li>
</ul>
<p>如果返回的是 HTML 页面，浏览器会解析 HTML，并根据页面中的资源（如 CSS、JavaScript、图片等）继续发起后续的请求。</p>
</li>
</ul>
</li>
<li><p><strong>渲染网页</strong></p>
<ul>
<li><p><strong>目的</strong>：浏览器将收到的 HTML、CSS 和 JavaScript 等内容解析并展示为用户界面。</p>
</li>
<li><p>过程：</p>
<ul>
<li><strong>解析 HTML</strong>：浏览器将 HTML 内容解析为 DOM（Document Object Model）树。</li>
<li><strong>解析 CSS</strong>：浏览器根据 CSS 样式规则，应用样式并生成渲染树。</li>
<li><strong>执行 JavaScript</strong>：浏览器通过 JavaScript 引擎执行页面中的脚本，可能会修改 DOM 或样式，增加交互性。</li>
<li><strong>渲染页面</strong>：根据渲染树和 JavaScript 的修改，浏览器逐步将页面渲染到用户屏幕上。</li>
</ul>
</li>
</ul>
</li>
<li><p><strong>关闭连接</strong></p>
<ul>
<li><p><strong>目的</strong>：完成所有请求后，关闭客户端与服务器之间的连接。</p>
</li>
<li><p>协议：TCP。</p>
<ul>
<li>在 HTTP/1.1 中，浏览器通常会保持连接（<code>Connection: keep-alive</code>），以便复用连接发送后续请求。</li>
<li>在页面加载完成后，浏览器会根据服务器的指示（如 <code>Connection: close</code>）关闭 TCP 连接，释放资源。</li>
</ul>
</li>
</ul>
</li>
</ol>
<h4 id="问：OSI-七层模型？五层协议？TCP-IP？"><a href="#问：OSI-七层模型？五层协议？TCP-IP？" class="headerlink" title="问：OSI 七层模型？五层协议？TCP/IP？"></a>问：OSI 七层模型？五层协议？TCP/IP？</h4><p><strong>五层协议模型</strong></p>
<p>五层协议模型是对 OSI 七层模型的简化，常用于描述互联网协议的层次结构，尤其是在 TCP/IP 网络架构中。五层模型去除了 OSI 模型中的 <strong>表示层</strong> 和 <strong>会话层</strong>，集中描述了实际数据传输中重要的协议层次。五层协议模型如下：</p>
<table>
<thead>
<tr>
<th>层级</th>
<th>层次名称</th>
<th>对应 OSI 层</th>
<th>作用与描述</th>
<th>服务对象</th>
<th>数据单位</th>
</tr>
</thead>
<tbody><tr>
<td><strong>5</strong></td>
<td><strong>应用层</strong></td>
<td>OSI 的 <strong>应用层</strong>、<strong>表示层</strong>、<strong>会话层</strong></td>
<td>提供用户应用程序之间的交互，包含 HTTP、FTP、SMTP、DNS 等协议</td>
<td>应用程序</td>
<td>报文</td>
</tr>
<tr>
<td><strong>4</strong></td>
<td><strong>传输层</strong></td>
<td>OSI 的 <strong>传输层</strong></td>
<td>提供端到端的数据传输服务，处理端口、流量控制和错误检测，常用协议有 TCP 和 UDP。由于应用层协议很多，定义通用的传输层协议就可以支持不断增多的应用层协议。</td>
<td>主机中的进程</td>
<td>用户数据报、报文段</td>
</tr>
<tr>
<td><strong>3</strong></td>
<td><strong>网络层</strong></td>
<td>OSI 的 <strong>网络层</strong></td>
<td>负责数据包的寻址和路由，常用协议有 IP、ICMP。网络层<strong>把传输层传递下来的报文段或者用户数据报封装成分组</strong>。</td>
<td>主机</td>
<td>分组</td>
</tr>
<tr>
<td><strong>2</strong></td>
<td><strong>数据链路层</strong></td>
<td>OSI 的 <strong>数据链路层</strong></td>
<td>负责物理地址的标识和帧封装，常用协议有 Ethernet、ARP。网络层针对主机之间的数据传输，主机之间可以有很多链路，链路层协议就是为同一链路的主机提供数据传输服务。<strong>数据链路层把网络层传下来的分组封装成帧</strong>。</td>
<td>主机</td>
<td>帧</td>
</tr>
<tr>
<td><strong>1</strong></td>
<td><strong>物理层</strong></td>
<td>OSI 的 <strong>物理层</strong></td>
<td>负责传输电信号、光信号等，定义物理连接的标准（如电缆类型、网卡、交换机等）。物理层的作用是尽可能屏蔽传输媒体和通信手段的差异，使数据链路层感觉不到这些差异。</td>
<td></td>
<td>数据比特流</td>
</tr>
</tbody></table>
<p><strong>OSI 七层模型 (Open Systems Interconnection Model)</strong></p>
<p>OSI 模型是由国际标准化组织（ISO）制定的一个网络通信模型，用于理解计算机网络中不同协议和设备如何协同工作。OSI 模型将网络通信过程分为 7 个不同的层次，从物理层到应用层，每一层都有其特定的功能。以下是 OSI 七层模型的各个层次：</p>
<table>
<thead>
<tr>
<th>层级</th>
<th>层次名称</th>
<th>作用与描述</th>
</tr>
</thead>
<tbody><tr>
<td><strong>7</strong></td>
<td><strong>应用层</strong></td>
<td>直接与用户应用程序交互，提供网络服务。包括 HTTP、FTP、SMTP 等协议。</td>
</tr>
<tr>
<td><strong>6</strong></td>
<td><strong>表示层</strong></td>
<td>负责数据格式转换、数据加密和解密、压缩等功能，确保数据可以在不同的系统之间被正确理解。使得应用程序不必关心在各台主机中数据内部格式不同的问题。</td>
</tr>
<tr>
<td><strong>5</strong></td>
<td><strong>会话层</strong></td>
<td>管理会话的建立、维护和终止，负责数据交换的控制，确保通信会话的完整性。</td>
</tr>
<tr>
<td><strong>4</strong></td>
<td><strong>传输层</strong></td>
<td>提供端到端的数据传输服务，确保数据传输的可靠性（TCP）或不可靠性（UDP），进行错误校验和流量控制。</td>
</tr>
<tr>
<td><strong>3</strong></td>
<td><strong>网络层</strong></td>
<td>负责数据包的路由选择、转发和地址分配，使用 IP 协议来进行数据包的寻址与路由。</td>
</tr>
<tr>
<td><strong>2</strong></td>
<td><strong>数据链路层</strong></td>
<td>负责物理地址（MAC 地址）的识别、数据的帧封装和错误检测，控制数据的物理传输。</td>
</tr>
<tr>
<td><strong>1</strong></td>
<td><strong>物理层</strong></td>
<td>负责数据在物理介质上的传输，包括电气信号、光信号等，定义硬件的规范（如电缆、网卡）。</td>
</tr>
</tbody></table>
<p><strong>TCP/IP 协议模型</strong></p>
<p>TCP/IP 模型是一个分层网络协议模型。与 OSI 模型和五层协议模型相比，<strong>TCP/IP 模型只有 4 层，相当于五层协议中数据链路层和物理层合并为网络接口层。</strong>不严格遵循 OSI 分层概念，应用层可能会直接使用 IP 层或者网络接口层。</p>
<table>
<thead>
<tr>
<th>层级</th>
<th>层次名称</th>
<th>对应 OSI 层</th>
<th>主要协议与功能</th>
</tr>
</thead>
<tbody><tr>
<td><strong>4</strong></td>
<td><strong>应用层</strong></td>
<td>OSI 的 <strong>应用层</strong>、<strong>表示层</strong>、<strong>会话层</strong></td>
<td>包括 HTTP、FTP、SMTP、DNS 等协议，负责用户应用和网络服务之间的交互</td>
</tr>
<tr>
<td><strong>3</strong></td>
<td><strong>传输层</strong></td>
<td>OSI 的 <strong>传输层</strong></td>
<td>提供可靠或不可靠的数据传输服务，主要协议是 TCP 和 UDP</td>
</tr>
<tr>
<td><strong>2</strong></td>
<td><strong>互联网层</strong></td>
<td>OSI 的 <strong>网络层</strong></td>
<td>主要协议是 IP，负责数据的路由和寻址</td>
</tr>
<tr>
<td><strong>1</strong></td>
<td><strong>网络接口层</strong></td>
<td>OSI 的 <strong>数据链路层</strong>、<strong>物理层</strong></td>
<td>负责数据的封装与物理传输，使用以太网、Wi-Fi 等技术</td>
</tr>
</tbody></table>
<p><strong>TCP/IP 各层详细解释</strong></p>
<p><strong>1. 应用层 (Application Layer)</strong></p>
<ul>
<li>负责为用户提供各种网络应用服务。</li>
<li>涵盖了所有面向用户的协议，如：<ul>
<li><strong>HTTP</strong>：用于网页浏览。</li>
<li><strong>FTP</strong>：文件传输协议。</li>
<li><strong>SMTP</strong>：邮件传输协议。</li>
<li><strong>DNS</strong>：域名解析系统。</li>
<li><strong>Telnet</strong>、<strong>SSH</strong>：远程登录协议等。</li>
</ul>
</li>
</ul>
<p><strong>2. 传输层 (Transport Layer)</strong></p>
<ul>
<li>负责端到端的数据传输，并提供可靠性和错误校验。</li>
<li>主要协议：<ul>
<li><strong>TCP</strong>（传输控制协议）：面向连接的协议，提供可靠的传输服务，包括数据包排序、错误校验和流量控制。</li>
<li><strong>UDP</strong>（用户数据报协议）：无连接协议，不保证数据的可靠性，适用于实时应用（如视频、语音）。</li>
</ul>
</li>
</ul>
<p><strong>3. 互联网层 (Internet Layer)</strong></p>
<ul>
<li><p>负责数据包的路由和转发。</p>
</li>
<li><p>主要协议：</p>
<ul>
<li><p>IP（Internet Protocol）：提供数据包的寻址和路由。</p>
<ul>
<li><strong>IPv4</strong>：32 位地址，地址空间为 42 亿个。</li>
<li><strong>IPv6</strong>：128 位地址，地址空间几乎无限。</li>
</ul>
</li>
<li><p><strong>ICMP</strong>：用于发送控制消息，如 <code>ping</code> 命令和网络错误通知。</p>
</li>
</ul>
</li>
</ul>
<p><strong>4. 网络接口层 (Network Interface Layer)</strong></p>
<ul>
<li>负责数据的物理传输，数据链路的封装。</li>
<li>主要技术：<ul>
<li><strong>以太网</strong>：局域网中的标准通信协议。</li>
<li><strong>Wi-Fi</strong>：无线局域网协议。</li>
<li><strong>PPP</strong>：点对点协议，常用于拨号连接。</li>
<li><strong>ARP</strong>：地址解析协议，用于解析 IP 地址到 MAC 地址。</li>
</ul>
</li>
</ul>
<h4 id="问：举例网络协议，都在哪个层？"><a href="#问：举例网络协议，都在哪个层？" class="headerlink" title="问：举例网络协议，都在哪个层？"></a>问：举例网络协议，都在哪个层？</h4><p><strong>1. 应用层（Layer 7）</strong>：应用层协议为用户和应用程序提供网络服务，通常与实际的应用程序交互。</p>
<ul>
<li>**HTTP (HyperText Transfer Protocol)**：用于网页浏览，客户端和服务器之间的通信协议。</li>
<li>**HTTPS (HyperText Transfer Protocol Secure)**：HTTP 协议的加密版本，安全传输数据。</li>
<li>**FTP (File Transfer Protocol)**：用于文件传输，支持在网络中上传和下载文件。</li>
<li>**SMTP (Simple Mail Transfer Protocol)**：用于电子邮件的发送。</li>
<li>**POP3 (Post Office Protocol 3)**：用于从邮件服务器接收邮件。</li>
<li>**IMAP (Internet Message Access Protocol)**：用于访问和管理邮件服务器上的电子邮件。</li>
<li>**DNS (Domain Name System)**：将域名转换为 IP 地址，确保通过人类友好的名称访问网站。</li>
<li><strong>Telnet</strong>：远程登录协议，用于通过命令行与远程计算机交互。</li>
<li>**SSH (Secure Shell)**：加密的远程登录协议，比 Telnet 更安全。</li>
</ul>
<p><strong>2. 表示层（Layer 6）</strong>：表示层主要负责数据的格式化、加密、解密等。该层协议并不常用，通常由应用层协议自己处理。</p>
<ul>
<li>**SSL/TLS (Secure Sockets Layer / Transport Layer Security)**：加密协议，确保数据传输过程中的保密性和完整性，通常与 HTTPS 一起使用。</li>
<li><strong>JPEG、GIF、PNG</strong>：用于图像数据的格式化和压缩。</li>
<li>**MIME (Multipurpose Internet Mail Extensions)**：用于邮件中处理多种媒体类型（如图片、音频、视频等）。</li>
</ul>
<p><strong>3. 会话层（Layer 5）</strong>：会话层管理会话的建立、维持和终止，确保通信的可靠性，但这个层次的协议较少，通常由应用层协议处理。</p>
<ul>
<li>**NetBIOS (Network Basic Input/Output System)**：提供会话和文件共享的服务。</li>
<li>**RPC (Remote Procedure Call)**：允许程序远程执行过程调用。</li>
<li>**SMB (Server Message Block)**：文件共享协议，通常用于 Windows 系统中，处理会话的建立和管理。</li>
</ul>
<p><strong>4. 传输层（Layer 4）</strong>：传输层负责提供端到端的通信，确保数据的完整性、顺序以及错误控制。</p>
<ul>
<li>**TCP (Transmission Control Protocol)**：可靠的面向连接的协议，确保数据传输的可靠性，执行重传、排序和错误检测。</li>
<li>**UDP (User Datagram Protocol)**：无连接、不可靠的协议，适用于不需要可靠性保证的应用（如视频流、在线游戏）。</li>
<li>**SCTP (Stream Control Transmission Protocol)**：结合了 TCP 和 UDP 的特点，提供多流和多重连接的功能，适用于更复杂的传输需求。</li>
</ul>
<p><strong>5. 网络层（Layer 3）</strong>：网络层负责数据包的路由和转发，提供逻辑地址（如 IP 地址）和路径选择。</p>
<ul>
<li>**IP (Internet Protocol)**：负责数据包的寻址和路由。IPv4 和 IPv6 是两种常见的版本。</li>
<li>**ICMP (Internet Control Message Protocol)**：用于发送控制信息，如网络错误报告（例如 <code>ping</code> 命令）。</li>
<li>**ARP (Address Resolution Protocol)**：用于解析 IP 地址到 MAC 地址。</li>
<li>**RIP (Routing Information Protocol)**：一种路由协议，用于动态计算最短路径。</li>
<li>**OSPF (Open Shortest Path First)**：一种链路状态路由协议，用于内网路由选择。</li>
<li>**BGP (Border Gateway Protocol)**：用于互联网中的自治系统间路由选择。</li>
</ul>
<p><strong>6. 数据链路层（Layer 2）</strong>：数据链路层负责在物理网络之间传输数据帧，管理物理地址（如 MAC 地址）并提供错误检测。</p>
<ul>
<li><strong>Ethernet</strong>：最常用的局域网技术，通过以太网帧在局域网内传输数据。</li>
<li><strong>Wi-Fi</strong>：无线局域网协议，基于 IEEE 802.11 标准。</li>
<li>**PPP (Point-to-Point Protocol)**：常用于拨号连接的协议，支持路由、IP 地址分配等功能。</li>
<li>**HDLC (High-Level Data Link Control)**：一种同步数据链路层协议，广泛用于 WAN 链路。</li>
<li>**VLAN (Virtual Local Area Network)**：通过交换机将网络划分为不同的虚拟局域网，用于网络分段。</li>
</ul>
<p><strong>7. 物理层（Layer 1）</strong>：物理层负责实际的电气信号传输，定义了硬件介质（如电缆、光纤、无线信号）和信号的传输标准。</p>
<ul>
<li>**Ethernet (物理标准)**：定义了通过电缆和连接器传输以太网帧的标准。</li>
<li>**Wi-Fi (物理标准)**：无线信号传输标准，定义了无线局域网设备之间的信号传输方式。</li>
<li>**DSL (Digital Subscriber Line)**：通过电话线传输数据的技术。</li>
<li>**光纤通信 (Fiber Optic Communication)**：通过光纤传输数据的协议。</li>
<li>**USB (Universal Serial Bus)**：用于计算机与外部设备之间传输数据的标准。</li>
</ul>
<p><strong>总结：</strong></p>
<table>
<thead>
<tr>
<th>层次</th>
<th>协议示例</th>
</tr>
</thead>
<tbody><tr>
<td><strong>应用层</strong></td>
<td>HTTP, HTTPS, FTP, SMTP, DNS, POP3, IMAP, Telnet, SSH</td>
</tr>
<tr>
<td><strong>表示层</strong></td>
<td>SSL/TLS, JPEG, MIME</td>
</tr>
<tr>
<td><strong>会话层</strong></td>
<td>NetBIOS, RPC, SMB</td>
</tr>
<tr>
<td><strong>传输层</strong></td>
<td>TCP, UDP, SCTP</td>
</tr>
<tr>
<td><strong>网络层</strong></td>
<td>IP, ICMP, ARP, RIP, OSPF, BGP</td>
</tr>
<tr>
<td><strong>数据链路层</strong></td>
<td>Ethernet, Wi-Fi, PPP, HDLC, VLAN</td>
</tr>
<tr>
<td><strong>物理层</strong></td>
<td>Ethernet (物理标准), Wi-Fi (物理标准), DSL, 光纤通信, USB</td>
</tr>
</tbody></table>
<h4 id="问：网络层和传输层如何区分？"><a href="#问：网络层和传输层如何区分？" class="headerlink" title="问：网络层和传输层如何区分？"></a>问：网络层和传输层如何区分？</h4><table>
<thead>
<tr>
<th>功能</th>
<th>网络层（Layer 3）</th>
<th>传输层（Layer 4）</th>
</tr>
</thead>
<tbody><tr>
<td><strong>主要任务</strong></td>
<td>点到点。负责数据包的<strong>路由、寻址和转发</strong>，确保数据能够从源设备到达目标设备。</td>
<td>端到端，确保数据从源端传输到目的端的正确性、完整性、顺序等。</td>
</tr>
<tr>
<td><strong>关注点</strong></td>
<td>网络层关注的是<strong>跨网络的数据传输</strong>，即在不同的网络之间如何通过路由器转发数据包，选择最佳路径。</td>
<td>传输层关注的是<strong>主机之间的端到端通信</strong>，确保数据在两台设备之间能够可靠传输，并处理数据的顺序、错误控制、流量控制等问题。</td>
</tr>
<tr>
<td><strong>协议</strong></td>
<td><strong>IP</strong>（Internet Protocol）、<strong>ICMP</strong>（Internet Control Message Protocol）、<strong>ARP</strong>（Address Resolution Protocol）、<strong>RIP</strong>（Routing Information Protocol）</td>
<td><strong>TCP</strong>（Transmission Control Protocol）、<strong>UDP</strong>（User Datagram Protocol）、<strong>SCTP</strong>（Stream Control Transmission Protocol）</td>
</tr>
<tr>
<td><strong>数据单位</strong></td>
<td>数据包（Packet）</td>
<td>TCP-段（Segment）或UDP-数据报（Datagram）</td>
</tr>
<tr>
<td><strong>主要目标</strong></td>
<td>数据从源设备到目的设备的路由和寻址</td>
<td>数据从源端应用到目的端应用的可靠传输</td>
</tr>
<tr>
<td><strong>寻址方式</strong></td>
<td>使用 IP 地址进行逻辑寻址。每个设备在网络中有一个唯一的 IP 地址。</td>
<td>使用端口号标识应用程序（如 HTTP 使用 80 端口，HTTPS 使用 443 端口）。</td>
</tr>
<tr>
<td><strong>协议</strong></td>
<td>IP、ICMP、ARP、RIP、OSPF、BGP</td>
<td>TCP、UDP、SCTP</td>
</tr>
<tr>
<td><strong>路由/转发</strong></td>
<td>负责路由器选择路径并转发数据包</td>
<td>负责端到端的数据传输、顺序、流量控制和错误恢复</td>
</tr>
<tr>
<td><strong>错误控制</strong></td>
<td>主要负责数据包的路由和寻址，不涉及传输的可靠性</td>
<td>提供可靠的数据传输，保证数据的完整性和顺序</td>
</tr>
<tr>
<td><strong>连接类型</strong></td>
<td>无连接（IP）或连接导向（如 MPLS）</td>
<td>TCP 是面向连接的，UDP 是无连接的</td>
</tr>
</tbody></table>
<p><strong>网络层的工作原理：</strong></p>
<ul>
<li><p>IP 协议：网络层使用 IP 协议来为每个数据包分配一个源 IP 地址和目标 IP 地址。路由器根据这些 IP 地址来决定如何将数据包从一个网络传输到另一个网络。</p>
<ul>
<li><strong>例如</strong>：当你访问一个网站时，网络层负责将数据包从你的计算机发送到路由器，路由器根据目标 IP 地址将数据包转发到目的服务器的网络。</li>
</ul>
</li>
</ul>
<p><strong>传输层的工作原理：</strong></p>
<ul>
<li><p>TCP 协议：传输层使用 TCP 协议提供可靠的、面向连接的数据传输。TCP 通过三次握手建立连接，确保数据的顺序和完整性。</p>
<ul>
<li><strong>例如</strong>：在浏览器访问网页时，TCP 协议保证从浏览器到服务器的数据传输是可靠的。如果数据丢失或发生错误，TCP 会进行重传。</li>
</ul>
</li>
<li><p>UDP 协议：传输层的 UDP 协议不保证数据的可靠性，适用于需要快速传输且能容忍丢包的应用，如视频流、语音通信等。</p>
<ul>
<li><strong>例如</strong>：在实时视频通话中，UDP 协议可以提供更低延迟的传输，但不保证每个数据包都能到达。</li>
</ul>
</li>
</ul>
<p><strong>4. 总结</strong></p>
<ul>
<li><strong>网络层</strong>：负责数据包的路由和寻址，确保数据从源设备到达目标设备，重点在于网络之间的连接。它关注的是逻辑地址（IP 地址）和跨网络传输。</li>
<li><strong>传输层</strong>：负责确保数据的可靠传输，处理端到端的通信，重点在于数据的完整性、顺序和错误控制。它关注的是通过端口号与应用程序通信。</li>
</ul>
<p>两者的主要区别在于，网络层关注的是<strong>跨网络的数据传输和寻址</strong>，而传输层关注的是<strong>主机之间的端到端的可靠数据传输</strong>。</p>
<h4 id="问：讲一下物理层的三种通信方式？"><a href="#问：讲一下物理层的三种通信方式？" class="headerlink" title="问：讲一下物理层的三种通信方式？"></a>问：讲一下物理层的三种通信方式？</h4><ul>
<li>单工通信：单向传输</li>
<li>半双工通信：双向交替传输</li>
<li>全双工通信：双向同时传输</li>
</ul>
<p>物理层是 OSI 模型中的第一层，负责将数据从一个设备传输到另一个设备，主要通过物理媒介进行信号传输。在物理层中，通常有三种基本的通信方式，它们决定了数据传输的方向性和信号的传递方式。</p>
<ol>
<li><p><strong>单工通信（Simplex）</strong></p>
<p>单工通信是最简单的一种通信方式。在单工通信中，数据只能<strong>单向传输</strong>，即<strong>信号只能从发送端传输到接收端，而接收端不能将数据发送回发送端</strong>。</p>
<p><strong>特点</strong>：</p>
<ul>
<li><strong>单向传输</strong>：数据从发送端传输到接收端，接收端无法回应。</li>
<li><strong>应用</strong>：这种通信方式适用于广播、电视、无线电等情况，其中信息流动方向固定，接收端无需回应。</li>
</ul>
<p><strong>举例</strong>：</p>
<ul>
<li><strong>电视广播</strong>：电视信号从广播公司发送到电视观众，观众无法向广播公司发送数据。</li>
<li><strong>无线电广播</strong>：从广播电台发出的电波只能传送给收听者，收听者无法反馈信息给广播电台。</li>
</ul>
</li>
<li><p><strong>半双工通信（Half-Duplex）</strong></p>
<p>半双工通信允许数据在两个设备之间双向传输，但在任意时刻，数据只能单向流动。这意味着<strong>在同一时刻，发送端和接收端不能同时发送和接收数据</strong>。通信方向需要在两个方向之间切换。</p>
<p><strong>特点</strong>：</p>
<ul>
<li><strong>双向传输</strong>：数据可以在两个设备之间双向传输，但不是同时传输，而是交替进行。</li>
<li><strong>需要时分复用</strong>：发送方和接收方必须按顺序发送和接收数据，通常依赖于某种时序机制来协调双方的传输。</li>
<li><strong>应用</strong>：适用于那些传输不需要实时双向交互的场景，例如对讲机、传统的无线通信设备等。</li>
</ul>
<p><strong>举例</strong>：</p>
<ul>
<li><strong>对讲机</strong>：两个用户可以交替进行讲话，一个用户说话时，另一个用户只能听。</li>
<li><strong>无线电通信</strong>：在某些无线电通信系统中，用户可以在某一时刻发送信息，另一时刻接收信息，但不能同时进行。</li>
</ul>
</li>
<li><p><strong>全双工通信（Full-Duplex）</strong></p>
<p>全双工通信允许数据在两个设备之间同时双向传输。<strong>发送端和接收端可以同时发送和接收数据</strong>，因此通信是双向的并且实时的。</p>
<p><strong>特点</strong>：</p>
<ul>
<li><strong>双向传输</strong>：数据可以同时在两个方向上传输，发送端和接收端可以同时进行数据交换。</li>
<li><strong>实时交互</strong>：支持实时的双向通信，通常用于需要高效和快速响应的通信场景。</li>
<li><strong>应用</strong>：广泛应用于电话、视频通话、局域网（LAN）和大多数现代通信系统中。</li>
</ul>
<p><strong>举例</strong>：</p>
<ul>
<li><strong>电话通信</strong>：通话的双方可以同时说话和听到对方的声音。</li>
<li><strong>视频会议</strong>：在视频会议中，参与者能够同时发言和听到其他人的声音。</li>
<li><strong>局域网通信</strong>：计算机通过以太网进行数据传输时，数据可以同时从一个设备发送到另一个设备，反之亦然。</li>
</ul>
</li>
</ol>
<p><strong>总结</strong></p>
<table>
<thead>
<tr>
<th>通信方式</th>
<th>数据流向</th>
<th>特点</th>
<th>举例</th>
</tr>
</thead>
<tbody><tr>
<td><strong>单工通信</strong></td>
<td>单向传输 (仅发送方向)</td>
<td>只能单向传输，接收端不能反馈</td>
<td>电视广播、无线电广播</td>
</tr>
<tr>
<td><strong>半双工通信</strong></td>
<td>双向传输（但不能同时进行）</td>
<td>可以双向传输，但需要切换方向</td>
<td>对讲机、传统无线电通信</td>
</tr>
<tr>
<td><strong>全双工通信</strong></td>
<td>双向传输（可以同时进行）</td>
<td>同时双向传输，实时交互</td>
<td>电话通信、视频会议、局域网通信</td>
</tr>
</tbody></table>
<p><strong>总结</strong></p>
<ul>
<li><strong>单工通信</strong>：只有一个方向的数据传输。</li>
<li><strong>半双工通信</strong>：允许双向传输，但在同一时刻只能有一个方向的数据传输。</li>
<li><strong>全双工通信</strong>：允许双向传输，并且两个方向的数据可以同时传输。</li>
</ul>
<p>在现代网络中，全双工通信被广泛应用，因为它支持实时、高效的双向通信。</p>
<h4 id="问：讲一下信道复用技术？"><a href="#问：讲一下信道复用技术？" class="headerlink" title="问：讲一下信道复用技术？"></a>问：讲一下信道复用技术？</h4><p>信道分类：</p>
<ol>
<li><p><strong>广播信道</strong>：一对多通信，一个节点发送的数据能够被广播信道上所有的节点接收到。</p>
<p>所有的节点都在同一个广播信道上发送数据，因此需要有专门的控制方法进行协调，避免发生冲突（冲突也叫碰撞）。</p>
<p>主要有两种控制方法进行协调，一个是使用信道复用技术，一是使用 CSMA/CD 协议。</p>
</li>
<li><p><strong>点对点信道</strong>：一对一通信。</p>
<p>因为不会发生碰撞，因此也比较简单，使用 PPP 协议进行控制。</p>
</li>
</ol>
<p>信道复用技术：</p>
<ol>
<li><p>频分复用：频分复用的所有主机在相同的时间占用不同的频率带宽资源。</p>
</li>
<li><p>时分复用：时分复用的所有主机在不同的时间占用相同的频率带宽资源。</p>
<ul>
<li>使用频分复用和时分复用进行通信，在通信的过程中主机会一直占用一部分信道资源。但是由于计算机数据的突发性质，通信过程没必要一直占用信道资源而不让出给其它用户使用，因此这两种方式对信道的利用率都不高。</li>
</ul>
</li>
<li><p>统计时分复用：是对时分复用的一种改进，不固定每个用户在时分复用帧中的位置，只要有数据就集中起来组成统计时分复用帧然后发送。</p>
</li>
<li><p>波分复用：光的频分复用。由于光的频率很高，因此习惯上用波长而不是频率来表示所使用的光载波。</p>
</li>
<li><p>码分复用：</p>
</li>
</ol>
<p>信道复用技术（Channel Multiplexing）是指<strong>在同一个物理传输信道上，利用一定的技术手段，使多个信号能够同时传输，从而提高信道的利用率</strong>。信道复用在通信系统中具有非常重要的作用，尤其是在带宽有限的情况下，通过复用可以让多个用户共享同一物理信道，减少资源浪费，提高传输效率。</p>
<p>常见的信道复用技术有以下几种：</p>
<ol>
<li><p><strong>频分复用（FDM, Frequency Division Multiplexing）</strong></p>
<p>频分复用是最早的信道复用技术之一，通过<strong>将频带划分成多个不重叠的子带，每个子带用于传输不同的信号</strong>。每个信号在其独立的频率范围内传输，互不干扰。</p>
<p><strong>原理</strong>：</p>
<ul>
<li>将一个宽频带的信道分割成多个较小的子信道，每个子信道使用不同的频率范围。</li>
<li>各个信号在各自的频段上独立工作，通过调制将信息传输到信道中。</li>
<li>接收端通过滤波器选择特定频段的信号，进行解调并提取信息。</li>
</ul>
<p><strong>特点</strong>：</p>
<ul>
<li><strong>优点</strong>：可以同时支持多个信号的传输，每个信号独立占用不同的频带，互不干扰。</li>
<li><strong>缺点</strong>：需要确保频带之间有足够的保护带宽以避免干扰（即频带的重叠问题），此外，频率资源有限，不能无限扩展。</li>
</ul>
<p><strong>应用</strong>：</p>
<ul>
<li><strong>广播电视</strong>：每个电视台或广播电台都占用一个特定的频率频道进行传输。</li>
<li><strong>蜂窝移动通信</strong>：不同的移动用户使用不同的频段进行通信。</li>
</ul>
</li>
<li><p><strong>时分复用（TDM, Time Division Multiplexing）</strong></p>
<p>时分复用是一种基于时间的复用技术，通过<strong>将信道分割成时间片，每个时间片分配给不同的信号源</strong>。各个信号在不同的时间片段内传输数据，整个信道轮流为不同信号提供传输机会。</p>
<p><strong>原理</strong>：</p>
<ul>
<li>时间上划分出多个时间槽（Time Slot），每个信号源在特定的时间段内传输数据。</li>
<li>各个信号共享同一个频带，但每个信号按照时间分配到不同的时隙中进行传输。</li>
<li>接收端按时隙顺序恢复各个信号，确保它们不会发生冲突。</li>
</ul>
<p><strong>特点</strong>：</p>
<ul>
<li><strong>优点</strong>：可以在同一频率带宽内传输多个信号，通过时间上的分配避免了频率的浪费。</li>
<li><strong>缺点</strong>：需要精确的同步机制来确保各信号在正确的时间窗口内传输。</li>
</ul>
<p><strong>应用</strong>：</p>
<ul>
<li><strong>电话网络</strong>：在传统的电话网络中，多个电话信号可以通过时分复用在同一条传输线中传输。</li>
<li><strong>数字传输系统</strong>：如数字电视广播、卫星通信、光纤通信等系统中也采用时分复用。</li>
</ul>
</li>
<li><p><strong>波分复用（WDM, Wavelength Division Multiplexing）</strong></p>
<p>波分复用是一种基于光纤通信的复用技术，<strong>利用不同的光波长（即不同的颜色）来实现多路信号的并行传输</strong>。每个信号通过不同的光波长传输，并通过波分复用器（WDM）将其合并到一根光纤中。</p>
<p><strong>原理</strong>：</p>
<ul>
<li>将不同的信号分配到不同的波长，每个信号使用不同的光频（或波长）进行传输。</li>
<li>接收端通过波分复用解复用器将不同波长的信号分开，并分别处理。</li>
<li>光纤中使用的多个波长相当于多个独立的传输信道，极大地提高了信道的传输能力。</li>
</ul>
<p><strong>特点</strong>：</p>
<ul>
<li><strong>优点</strong>：大大增加了光纤的传输带宽，可以同时传输大量数据。</li>
<li><strong>缺点</strong>：需要高精度的波长选择和设备支持，因此成本较高。</li>
</ul>
<p><strong>应用</strong>：</p>
<ul>
<li><strong>光纤通信</strong>：现代光纤通信网络，如长距离的光纤背骨网和数据中心之间的光纤连接广泛采用波分复用技术。</li>
<li><strong>光纤互联网</strong>：在互联网骨干网中，利用波分复用技术提供高速的数据传输能力。</li>
</ul>
</li>
<li><p><strong>码分复用（CDM, Code Division Multiplexing）</strong></p>
<p>码分复用技术通过<strong>为每个信号分配不同的编码序列，使得多个信号可以在同一频带内同时传输</strong>。每个信号都带有一个独特的“代码”，接收端通过匹配代码来分离不同的信号。</p>
<p><strong>原理</strong>：</p>
<ul>
<li>每个信号通过一个特定的“码字”（通常是一个长序列）进行编码，信号在同一频带内同时传输。</li>
<li>接收端通过相关检测和解码技术，利用预定的代码来提取正确的信号。</li>
<li>即使信号之间重叠，因每个信号有独特的代码，它们可以被有效区分和恢复。</li>
</ul>
<p><strong>特点</strong>：</p>
<ul>
<li><strong>优点</strong>：可以实现非常高效的复用，信号之间几乎不产生干扰，尤其适合在无线信道中使用。</li>
<li><strong>缺点</strong>：需要复杂的编码、解码和干扰管理技术。</li>
</ul>
<p><strong>应用</strong>：</p>
<ul>
<li><strong>移动通信（如 CDMA）</strong>：在 CDMA（码分多址）中，不同的手机信号通过不同的编码在同一频段内同时传输。</li>
<li><strong>卫星通信</strong>：在卫星通信中，也使用码分复用来同时传输多个信号。</li>
</ul>
</li>
<li><p><strong>空间复用（SDM, Spatial Division Multiplexing）</strong></p>
<p>空间复用技术<strong>利用空间分离来提高信道的使用效率</strong>，即通过物理上的分离（如多根天线或多条信号传输通道）实现多路信号同时传输。</p>
<p><strong>原理</strong>：</p>
<ul>
<li>在多天线系统中，通过天线阵列或 MIMO（多输入多输出）技术，将信号分配到多个不同的空间通道中，进行同时传输。</li>
<li>接收端使用多个接收天线接收不同的信号，从而实现复用。</li>
</ul>
<p><strong>特点</strong>：</p>
<ul>
<li><strong>优点</strong>：通过空间上的分离，可以有效增加系统容量，支持更多的用户或更高的带宽。</li>
<li><strong>缺点</strong>：需要复杂的硬件支持，如多天线阵列和空间解码技术。</li>
</ul>
<p><strong>应用</strong>：</p>
<ul>
<li><strong>4G/5G 网络</strong>：现代无线通信系统（如 LTE、5G）中广泛使用 MIMO 技术，实现空间复用。</li>
<li><strong>Wi-Fi</strong>：现代 Wi-Fi 网络也利用多个天线进行空间复用。</li>
</ul>
</li>
</ol>
<p><strong>总结</strong></p>
<table>
<thead>
<tr>
<th>技术</th>
<th>简介</th>
<th>应用</th>
</tr>
</thead>
<tbody><tr>
<td><strong>频分复用（FDM）</strong></td>
<td>将频带划分为多个子带，每个信号占用一个频带传输</td>
<td>广播电视、移动通信</td>
</tr>
<tr>
<td><strong>时分复用（TDM）</strong></td>
<td>将时间分割为多个时隙，不同信号在不同时间段传输</td>
<td>电话网络、卫星通信</td>
</tr>
<tr>
<td><strong>波分复用（WDM）</strong></td>
<td>利用不同的光波长进行信号的复用，适用于光纤通信</td>
<td>光纤通信、光纤互联网</td>
</tr>
<tr>
<td><strong>码分复用（CDM）</strong></td>
<td>利用不同的编码序列来区分多个信号，即使在同一频带中也可以同时传输</td>
<td>移动通信（如 CDMA）、卫星通信</td>
</tr>
<tr>
<td><strong>空间复用（SDM）</strong></td>
<td>通过空间分离的多个信道来传输多个信号</td>
<td>4G/5G 网络、Wi-Fi</td>
</tr>
</tbody></table>
<h4 id="问：路由器是如何工作的？"><a href="#问：路由器是如何工作的？" class="headerlink" title="问：路由器是如何工作的？"></a>问：路由器是如何工作的？</h4><p>路由器（Router）是一种网络设备，主要<strong>用于在不同的网络之间转发数据包，选择最佳路径并将数据从一个网络传输到另一个网络</strong>。路由器工作在 <strong>网络层（Layer 3）</strong>，它根据目标 IP 地址来确定数据包的转发路径。路由器只有下面三层协议，因为<strong>路由器位于网络核心中，不需要为进程或者应用程序提供服务，因此也就不需要传输层和应用层</strong>。</p>
<ol>
<li><p>路由表（Routing Table）</p>
<p>路由器通过维护一个 <strong>路由表</strong> 来决定数据包的转发路径。路由表是一个存储在路由器中的数据库，<strong>包含了到不同网络或子网的路径信息</strong>。每个路由条目一般包含以下内容：</p>
<ul>
<li><strong>目标网络</strong>（Destination Network）：数据包最终要到达的网络地址。</li>
<li><strong>下一跳（Next Hop）</strong>：数据包到达目标网络前，需要经过的下一台设备或路由器。</li>
<li><strong>接口（Interface）</strong>：路由器上用于转发数据包的物理或虚拟接口。</li>
<li><strong>路由成本（Metric）</strong>：用于表示从路由器到达目标网络的“距离”，可以是延迟、带宽、跳数等度量值。</li>
</ul>
<p>当路由器收到数据包时，它会查阅路由表，查看目标 IP 地址对应的路由条目，并根据该条目的信息决定如何转发数据包。</p>
</li>
<li><p>路由选择过程</p>
<p>路由器根据不同的路由选择算法，使用 <strong>静态路由</strong> 或 <strong>动态路由</strong> 来选择数据包的最佳转发路径：</p>
<ul>
<li><strong>静态路由</strong>：管理员手动配置的路由表条目，适用于网络环境固定、变化较小的情况。</li>
<li><strong>动态路由</strong>：路由器使用动态路由协议（如 <strong>RIP</strong>、<strong>OSPF</strong>、<strong>BGP</strong>）自动学习和更新路由信息，适用于网络拓扑经常变化的环境。</li>
</ul>
<p><strong>动态路由协议</strong>：</p>
<ul>
<li><strong>RIP（Routing Information Protocol）</strong>：一种较为简单的路由协议，使用跳数作为路由的度量标准。最多支持 15 跳。</li>
<li><strong>OSPF（Open Shortest Path First）</strong>：一种链路状态路由协议，基于网络拓扑图计算最短路径，适用于大规模企业网络。</li>
<li><strong>BGP（Border Gateway Protocol）</strong>：一种用于不同自治系统（AS）之间的路由协议，通常用于互联网中的路由选择。</li>
</ul>
</li>
<li><p>数据包转发过程</p>
<p>路由器的工作过程可以通过以下步骤来描述：</p>
<p><strong>1. 接收数据包</strong>：路由器接收到来自网络接口的数据包。数据包的结构包含了源 IP 地址、目标 IP 地址、源 MAC 地址、目标 MAC 地址等信息。</p>
<p><strong>2. 查找路由表</strong>：路由器根据数据包中的目标 IP 地址查找 <strong>路由表</strong>，确定将数据包转发到哪一个接口或下一跳路由器。</p>
<ul>
<li>如果目标网络已经在路由表中找到匹配的条目，路由器会根据该条目的 <strong>下一跳</strong> 和 <strong>接口</strong> 信息将数据包转发到正确的方向。</li>
<li>如果目标网络没有在路由表中找到匹配的条目，路由器将根据<strong>默认路由</strong>（如果配置了默认路由）将数据包转发到预设的路径。如果没有默认路由，路由器将丢弃该数据包。</li>
</ul>
<p><strong>3. 转发数据包</strong>：根据路由表的信息，路由器<strong>将数据包转发到下一个设备或目标网络</strong>。为了进行正确的转发，路由器可能需要对数据包进行封装、修改目标 MAC 地址等操作。</p>
<ul>
<li>如果数据包的目标 IP 地址属于直接连接的网络，路由器将直接将数据包发送到目标设备。</li>
<li>如果数据包的目标 IP 地址属于其他网络，路由器将数据包转发到下一跳路由器，直到数据包到达目标设备。</li>
</ul>
<p><strong>4. 发送数据包</strong>：路由器将数据包通过适当的接口发送出去。在此过程中，路由器可能需要进行一些物理层和数据链路层的处理（例如生成或修改帧的 MAC 地址）。</p>
</li>
<li><p>路由器的其他功能，除了基本的数据包转发，现代路由器还具有许多其他功能：</p>
<p><strong>1. NAT（Network Address Translation）</strong>：NAT 允许多个内部网络设备共享一个公共 IP 地址。路由器会将内部网络的私有 IP 地址转换为公共 IP 地址，从而实现私有网络与互联网之间的通信。</p>
<ul>
<li><strong>源 NAT（SNAT）</strong>：当内部设备访问外部网络时，路由器将私有 IP 地址转换为公共 IP 地址。</li>
<li><strong>目的 NAT（DNAT）</strong>：外部设备访问内部网络时，路由器将公共 IP 地址转换为私有 IP 地址。</li>
</ul>
<p><strong>2. 防火墙功能</strong>：路由器可以配置防火墙规则来过滤传入和传出的数据包，保护内部网络免受恶意攻击。防火墙可以基于 IP 地址、端口号、协议类型等信息来决定是否允许数据包通过。</p>
<p><strong>3. 路由聚合与路由优化</strong>：现代路由器会根据网络拓扑自动调整路由路径，减少路由循环，并优化数据包传输路径。路由聚合是一种将多个路由条目合并为一个条目的技术，从而减少路由表的大小，提升路由效率。</p>
</li>
<li><p>路由器与交换机的区别：</p>
<ul>
<li><strong>工作层次</strong>：路由器工作在 <strong>网络层（Layer 3）</strong>，主要根据 IP 地址进行路由选择；而交换机工作在 <strong>数据链路层（Layer 2）</strong>，主要根据 MAC 地址进行数据帧的转发。</li>
<li><strong>作用</strong>：路由器主要用于不同网络之间的连接和数据包转发，而交换机主要用于同一网络内部设备之间的连接，处理局域网内的数据帧转发。</li>
</ul>
</li>
<li><p>路由器的高级功能，现代路由器通常不仅仅用于基本的包转发，它们还集成了许多高级功能，以支持更加复杂的网络需求：</p>
<ul>
<li><strong>QoS（Quality of Service）</strong>：为不同类型的数据流提供优先级调度，确保高优先级流量（如语音、视频）的顺畅传输。</li>
<li><strong>VPN（Virtual Private Network）</strong>：支持虚拟专用网络的功能，允许通过加密隧道在不安全的公共网络（如互联网）上安全地传输数据。</li>
<li><strong>负载均衡</strong>：通过多个路径同时转发数据流，优化网络资源的使用，提升性能和可用性。</li>
</ul>
</li>
</ol>
<p><strong>总结</strong>：路由器是负责网络中不同网络或子网之间数据传输的关键设备。它通过查找路由表，选择最佳路径并转发数据包，工作在 OSI 模型的 <strong>网络层（Layer 3）</strong>。路由器不仅仅负责基本的路由功能，还包括网络地址转换（NAT）、防火墙、VPN、QoS、负载均衡等多种高级功能。它是现代网络架构中不可或缺的核心组件。</p>
<h4 id="问：MAC地址长度？如何保证每台机器地址不同？"><a href="#问：MAC地址长度？如何保证每台机器地址不同？" class="headerlink" title="问：MAC地址长度？如何保证每台机器地址不同？"></a>问：MAC地址长度？如何保证每台机器地址不同？</h4><p>MAC 地址，长度为 6 字节（48 位），用于唯一标识网络适配器（网卡）。</p>
<p>一台主机拥有多少个网络适配器就有多少个 MAC 地址。例如笔记本电脑普遍存在无线网络适配器和有线网络适配器，因此就有两个 MAC 地址。</p>
<p> IEEE 会根据设备的制造商分配地址段，48 位 MAC 地址的前 24 位是设备制造商的标识符，也就是组织唯一标识符（Organizationally Unique Identifier，OUI），后面的 24 位是序列号；如果每个设备制造商都能保证在同一个命名空间中的全部 MAC 地址唯一，那么全世界所有的 MAC 地址就可以保证唯一。</p>
<ul>
<li><p><strong>MAC地址的长度</strong>：MAC地址（Media Access Control Address）是用于在 <strong>数据链路层</strong> 唯一标识网络设备的硬件地址，是链路层地址。每个MAC地址由 <strong>48位</strong>（<strong>6字节</strong>）组成，通常以16进制表示，例如：<code>00:14:22:01:23:45</code> 或者：<code>00-14-22-01-23-45</code></p>
</li>
<li><p><strong>MAC地址的组成</strong>：</p>
<p>一个标准的 48 位 MAC 地址由两部分组成：</p>
<ol>
<li><p><strong>前 24 位（高 3 字节）</strong>：称为 <strong>组织唯一标识符（OUI，Organizationally Unique Identifier）</strong>，由国际标准化组织（ISO）分配给硬件制造商，用于标识设备的生产厂商。每个制造商都有一个唯一的 OUI。例如：</p>
<ul>
<li><code>00:14:22</code> 是一个典型的 OUI，它对应于某些制造商（如 TP-Link）的硬件设备。</li>
</ul>
</li>
<li><p><strong>后 24 位（低 3 字节）</strong>：由设备制造商分配，通常由制造商在其生产的每台设备上生成唯一的 MAC 地址。这个部分可以是任意的，只要它在该制造商的范围内是唯一的。例如：</p>
<ul>
<li><code>01:23:45</code> 是制造商自定义的部分，确保每台设备在该制造商范围内有唯一的 MAC 地址。</li>
</ul>
</li>
</ol>
</li>
<li><p><strong>保证每台机器MAC地址唯一</strong></p>
<ol>
<li><strong>OUI（组织唯一标识符）</strong>：<ul>
<li>OUI 是由 <strong>IEEE（Institute of Electrical and Electronics Engineers）</strong> 分配给硬件厂商的一个全球唯一的标识符。每个硬件制造商都会从 IEEE 获得一个独一无二的 OUI。</li>
<li>这意味着，所有由同一个制造商生产的设备，都会使用相同的 OUI 前缀（即前 3 字节相同）。</li>
</ul>
</li>
<li><strong>制造商的管理</strong>：<ul>
<li>制造商在自己的设备上分配后 3 字节（即最后 24 位），确保在它们的设备中不会重复。这部分由厂商根据其需求和生产量来管理，通常是逐一递增的。</li>
<li>这样，虽然每个制造商有相同的 OUI 前缀，但他们会确保后缀（后 3 字节）的唯一性。制造商通常采用序列号的方式来分配这些地址，从而确保每台设备的 MAC 地址是唯一的。</li>
</ul>
</li>
<li><strong>IEEE的管理和规定</strong>：<ul>
<li>IEEE 对 MAC 地址的分配有严格的规范和管理。每个厂商必须按照 IEEE 的规定使用 OUI 并且按规则分配后 24 位，从而保证不同厂商生产的设备地址不会发生冲突。</li>
<li>IEEE 还规定，MAC地址的前 24 位是全球唯一的，而后 24 位由厂商管理，保证每个厂商的设备之间是唯一的。</li>
</ul>
</li>
</ol>
</li>
<li><p><strong>如何避免MAC地址冲突</strong></p>
<p>MAC地址冲突可能会发生，如果两个设备的地址完全相同。在制造过程中，冲突的可能性极低，但依然存在。为了避免冲突，通常采取以下措施：</p>
<ol>
<li><strong>OUI的管理</strong>：<ul>
<li>IEEE 管理 OUI，并将其分配给制造商，每个 OUI 是唯一的。因此，不同的厂商使用不同的 OUI 前缀，确保了全球范围内不会出现 MAC 地址的冲突。</li>
</ul>
</li>
<li><strong>设备的自动生成与分配机制</strong>：<ul>
<li>大多数硬件制造商都会在生产设备时，为每个设备自动分配一个唯一的 MAC 地址。通过自动化的生产管理系统，制造商能确保每个生产的设备有一个唯一的地址。</li>
</ul>
</li>
<li><strong>MAC地址生成规则</strong>：<ul>
<li>MAC 地址的生成通常遵循某种有序规则，例如递增或按序号分配，减少冲突的概率。</li>
</ul>
</li>
<li><strong>虚拟化中的 MAC 地址管理</strong>：<ul>
<li>在虚拟化环境（如 VMware、Hyper-V 等）中，虚拟机的 MAC 地址通常由虚拟化平台动态生成并管理。如果管理员手动配置 MAC 地址，则需要确保每个虚拟机使用唯一的地址，避免冲突。</li>
</ul>
</li>
</ol>
</li>
</ul>
<p><strong>总结</strong></p>
<ul>
<li><p><strong>MAC地址长度</strong>：MAC地址由 48 位（6 字节）组成，通常以 16 进制形式表示。</p>
</li>
<li><p>如何保证唯一性：</p>
<ol>
<li>每个制造商从 IEEE 获得一个唯一的 OUI。</li>
<li>制造商在生产设备时，利用 OUI 和独特的后 24 位来确保每个设备的 MAC 地址是唯一的。</li>
<li>IEEE 对 MAC 地址的分配和管理有严格的规范，确保全球范围内的唯一性。</li>
</ol>
</li>
</ul>
<h4 id="问：长连接和短连接，连接池适合长连接还是短连接？"><a href="#问：长连接和短连接，连接池适合长连接还是短连接？" class="headerlink" title="问：长连接和短连接，连接池适合长连接还是短连接？"></a>问：长连接和短连接，连接池适合长连接还是短连接？</h4><p><strong>长连接和短连接</strong>是网络通信中常见的两种连接方式，它们在资源管理、性能和适用场景等方面有着显著的区别。理解这两者的区别，有助于了解 <strong>连接池</strong> 适合哪种连接。</p>
<ol>
<li><p>长连接和短连接的区别</p>
<p><strong>短连接（Short-lived Connection）</strong></p>
<ul>
<li><p><strong>定义</strong>：短连接是指每次请求和响应都建立一个新的连接，完成数据传输后立即关闭连接。每个请求/响应都使用独立的连接。</p>
</li>
<li><p><strong>过程</strong>：客户端向服务器发起请求，服务器响应请求后关闭连接。下一个请求会重新建立一个新的连接。</p>
</li>
<li><p>特点：</p>
<ul>
<li>每次请求都需要重新建立连接和释放连接，增加了连接的创建和销毁开销。</li>
<li>请求和响应结束后，连接会被关闭，无法复用。</li>
<li>适合请求量小、请求和响应时间短的场景。</li>
</ul>
</li>
<li><p>应用场景：</p>
<ul>
<li><strong>HTTP/1.0</strong>：默认使用短连接，每次请求完成后即关闭连接。</li>
<li>一些传统的客户端-服务器应用场景，如每次请求都不需要依赖之前的请求状态。</li>
</ul>
</li>
</ul>
<p><strong>长连接（Persistent Connection）</strong></p>
<ul>
<li><p><strong>定义</strong>：长连接是在客户端和服务器之间建立一个连接后，可以在多个请求/响应之间复用该连接，而不需要每次请求时都重新建立连接。连接在多次请求完成后才会关闭。</p>
</li>
<li><p><strong>过程</strong>：客户端和服务器建立连接后，数据传输完成后连接仍然保持打开状态，可以继续使用，直到客户端或服务器主动关闭连接。</p>
</li>
<li><p>特点：</p>
<ul>
<li>连接建立后可复用，减少了频繁建立连接的开销，提高了效率。</li>
<li>可以发送多个请求/响应，减少了连接的创建和销毁过程中的延迟。</li>
<li>长时间保持连接可能会占用更多的系统资源（如内存、连接句柄等）。</li>
</ul>
</li>
<li><p>应用场景：</p>
<ul>
<li><strong>HTTP/1.1</strong>：默认使用长连接，可以通过 <code>Connection: keep-alive</code> 保持连接。</li>
<li><strong>WebSocket</strong>、<strong>HTTP/2</strong> 等协议：通常使用长连接来支持实时通信或持续传输数据。</li>
<li>数据库、消息队列等服务通常也倾向于使用长连接。</li>
</ul>
</li>
</ul>
</li>
<li><p>连接池适合长连接还是短连接？</p>
<p><strong>连接池</strong>（Connection Pool）是为了避免频繁建立和关闭连接而设计的技术，它通过维护一定数量的连接来为应用提供连接复用服务。连接池是用于 <strong>长连接</strong> 的最佳选择，因为它专门为重用连接而设计，减少了频繁创建和销毁连接的开销。</p>
<p><strong>连接池适合长连接的原因</strong>：</p>
<ol>
<li><strong>复用连接</strong>：连接池通过管理和复用数据库或网络连接，避免了每次请求都重新创建连接的成本。长连接本身就是建立后长时间保持活跃，可以重复使用的连接。</li>
<li><strong>性能提升</strong>：长连接的优势在于它们避免了频繁建立连接所带来的开销。而连接池能更高效地管理这些长连接，使得多个线程或请求可以共享有限的连接资源，提高了性能和资源利用率。</li>
<li><strong>管理资源</strong>：连接池可以控制连接的数量，避免连接过多导致的资源耗尽，保证系统稳定性。对于数据库、消息队列等服务，长连接能有效减少连接的创建、销毁操作，提升整体吞吐量。</li>
<li><strong>适合高并发应用</strong>：长连接池可以在高并发环境下，快速为客户端提供连接，减少了每次连接建立的延迟，尤其在需要处理大量请求的应用中表现优异。</li>
</ol>
<p><strong>短连接与连接池的关系</strong>：</p>
<ul>
<li>短连接本质上不适合使用连接池，因为每次请求都会新建连接，连接池的作用是通过复用连接来减少创建和销毁连接的开销，而短连接每次请求结束后就关闭连接，因此并没有连接复用的机会。短连接更多的是直接创建和销毁连接，而不需要像长连接那样管理和复用。</li>
</ul>
</li>
<li><p>适用场景总结</p>
</li>
</ol>
<table>
<thead>
<tr>
<th><strong>特性</strong></th>
<th><strong>短连接</strong></th>
<th><strong>长连接</strong></th>
</tr>
</thead>
<tbody><tr>
<td><strong>连接建立和关闭</strong></td>
<td>每次请求建立和关闭一个连接</td>
<td>连接在多个请求/响应之间复用</td>
</tr>
<tr>
<td><strong>性能开销</strong></td>
<td>每次都需要重新建立连接，性能开销较大</td>
<td>连接复用，减少频繁的连接建立和销毁开销</td>
</tr>
<tr>
<td><strong>适用场景</strong></td>
<td>请求数量较少、连接频繁建立和关闭的应用场景</td>
<td>请求量大、长时间连接的应用场景</td>
</tr>
<tr>
<td><strong>连接池的适用性</strong></td>
<td>不适合，连接池没有复用连接的机会</td>
<td>适合，连接池能有效管理和复用长连接</td>
</tr>
</tbody></table>
<p><strong>典型应用</strong></p>
<ul>
<li><strong>短连接</strong>：适用于一些对性能要求不高且请求较少的场景，如简单的 HTTP 请求、一些小型的客户端应用。</li>
<li><strong>长连接</strong>：适用于高并发、高性能的应用场景，如 <strong>数据库连接池</strong>、<strong>消息队列（如 RabbitMQ）</strong>、<strong>WebSocket</strong>、<strong>HTTP/2</strong> 等。</li>
</ul>
<p><strong>总结</strong></p>
<p>连接池主要是为 <strong>长连接</strong> 设计的，通过复用连接来提高系统的性能和资源利用效率。对于 <strong>短连接</strong>，通常不需要连接池，因为每次请求都会新建和关闭连接，不涉及连接复用的问题。</p>
<h4 id="问：讲一下半连接攻击？"><a href="#问：讲一下半连接攻击？" class="headerlink" title="问：讲一下半连接攻击？"></a>问：讲一下半连接攻击？</h4><p><strong>半连接攻击（Half-Open Connection Attack）</strong> 是一种针对网络协议的攻击，尤其是针对 <strong>TCP协议</strong> 的常见网络攻击方式。它利用了 TCP 的 <strong>三次握手（Three-Way Handshake）</strong> 过程中的特性，试图通过消耗目标服务器的资源，造成拒绝服务（DoS）或拒绝访问（DDoS）的效果。其基本原理是通过发送伪造的 <strong>SYN</strong> 包来建立 TCP 连接，但不完成连接的建立过程，从而使目标主机保持大量处于半连接状态的连接，导致资源耗尽，无法处理合法的连接请求。</p>
<ol>
<li><p>TCP 三次握手回顾</p>
<p>在正常情况下，TCP 的建立连接过程分为三次握手：</p>
<ol>
<li><strong>SYN</strong>：客户端发送一个 SYN 包，表示请求建立连接。</li>
<li><strong>SYN-ACK</strong>：服务器收到 SYN 包后，回应一个 SYN-ACK 包，表示同意建立连接。</li>
<li><strong>ACK</strong>：客户端收到 SYN-ACK 包后，发送一个 ACK 包，表示连接建立完成。</li>
</ol>
</li>
<li><p>半连接攻击原理</p>
<p>在半连接攻击中，攻击者通过发送大量的 <strong>SYN</strong> 包到目标服务器，伪造源 IP 地址（通常是随机的或假冒的）。目标服务器收到这些 <strong>SYN</strong> 包后，会回复一个 <strong>SYN-ACK</strong> 包，并等待客户端的 <strong>ACK</strong> 响应。由于攻击者伪造了源 IP 地址，它不会发送 <strong>ACK</strong> 包来完成三次握手，从而导致服务器一直处于等待状态，资源被消耗。</p>
<p><strong>攻击流程</strong>：</p>
<ol>
<li><strong>攻击者发起大量 SYN 包</strong>：攻击者向目标服务器发送大量的 <strong>SYN</strong> 请求包，伪造源 IP 地址。</li>
<li><strong>服务器响应 SYN-ACK 包</strong>：目标服务器收到每个 <strong>SYN</strong> 请求后，会向攻击者伪造的 IP 地址回复一个 <strong>SYN-ACK</strong> 包，表示同意建立连接。</li>
<li><strong>连接没有完成</strong>：攻击者没有回应 <strong>SYN-ACK</strong> 包，不发送 <strong>ACK</strong> 包，导致服务器处于半连接状态。</li>
<li><strong>资源消耗</strong>：每个半连接都占用服务器的资源，如内存、连接队列等。随着攻击流量的增加，服务器的资源被迅速消耗，最终导致服务器无法处理其他合法连接，甚至崩溃。</li>
</ol>
</li>
<li><p>半连接攻击的目标：</p>
<p>半连接攻击的目标是 <strong>资源消耗</strong> 和 <strong>拒绝服务</strong>。它通过在服务器端维护大量的半连接，消耗服务器的连接队列和内存等资源，最终导致正常用户无法建立连接，从而实现拒绝服务（DoS）效果。</p>
<ul>
<li><strong>SYN队列</strong>：每个未完成的连接都会占用服务器的 <strong>SYN 队列</strong>，这是服务器等待连接完成的地方。每当一个新的 <strong>SYN</strong> 请求到来，服务器会将其添加到队列中，直到握手完成。队列的大小是有限的，攻击者通过发送大量的 SYN 包来填满该队列。</li>
<li><strong>资源占用</strong>：每个半连接都需要占用服务器的一定资源，如内存、CPU 等。随着攻击的增加，服务器的资源会被迅速消耗殆尽，正常请求被阻塞或丢失。</li>
</ul>
</li>
<li><p>半连接攻击的防御</p>
<p>防止半连接攻击的方式主要是通过 <strong>增加服务器处理能力</strong> 或使用 <strong>防火墙</strong>、<strong>入侵检测系统（IDS）</strong>、<strong>负载均衡</strong> 等技术来减少或避免其影响。常见的防御策略包括：</p>
<p><strong>1. 增加SYN队列的长度</strong></p>
<ul>
<li>服务器可以通过调整 <strong>SYN 队列的大小</strong> 来提高其承受 SYN 请求的能力。增加队列长度使得它能够处理更多的半连接，但这并不能从根本上解决问题。</li>
</ul>
<p><strong>2. SYN Cookies</strong></p>
<ul>
<li><strong>SYN Cookies</strong> 是一种常用的防御机制。当服务器收到 SYN 请求时，不立即为连接分配资源，而是生成一个 <strong>SYN Cookie</strong>，该值作为回应的 <strong>SYN-ACK</strong> 包的一部分返回给客户端。只有在客户端正确响应 <strong>ACK</strong> 包时，服务器才会分配真正的资源和创建连接。这种方法有效地避免了服务器因为等待 ACK 包而占用资源。</li>
</ul>
<p><strong>3. 防火墙和入侵检测系统（IDS）</strong></p>
<ul>
<li>使用 <strong>防火墙</strong> 或 <strong>入侵检测系统（IDS）</strong> 来识别和过滤大量的 SYN 请求。防火墙可以限制单个 IP 地址的连接次数或阻止来自不合法来源的请求。</li>
<li>IDS 可以实时监控异常的网络流量，检测和阻止半连接攻击。</li>
</ul>
<p><strong>4. 限制连接速率</strong></p>
<ul>
<li>服务器可以限制 <strong>SYN 请求的速率</strong>，从而防止恶意用户快速发起大量的半连接请求。</li>
<li>一些负载均衡器和防火墙也可以实现这种功能，通过限制同一 IP 地址的连接请求频率来缓解攻击。</li>
</ul>
<p><strong>5. 超时设置</strong></p>
<ul>
<li>设置合理的连接超时策略，对于长时间没有完成三次握手的半连接进行超时清除，释放资源。</li>
<li>例如，配置 TCP 协议栈的 <strong>SYN Timeout</strong> 时间，确保半连接不会在服务器中永久存在。</li>
</ul>
<p><strong>6. 利用负载均衡</strong></p>
<ul>
<li>在多个服务器之间分配负载，避免单个服务器成为攻击的瓶颈，减少资源被耗尽的风险。</li>
</ul>
</li>
<li><p>示例工具</p>
<ul>
<li><strong>SYN Flood</strong>：最常见的半连接攻击工具。它利用伪造源 IP 地址发送大量的 <strong>SYN</strong> 包，从而触发大量半连接，造成服务器资源耗尽。</li>
<li>**LOIC (Low Orbit Ion Cannon)**：是一种流行的 DDoS 攻击工具，它可以用来发起包括半连接攻击在内的多种攻击。</li>
</ul>
</li>
<li><p>半连接攻击与其他 DoS 攻击的区别</p>
<ul>
<li><strong>半连接攻击</strong> 主要针对 <strong>TCP三次握手</strong> 过程中的资源消耗，通常不会真正传输有效数据，只是通过建立未完成的连接来耗费服务器资源。</li>
<li><strong>SYN Flood</strong> 是半连接攻击的一种典型表现。</li>
<li>相比之下，其他 <strong>DoS（拒绝服务）攻击</strong> 如 <strong>UDP Flood</strong> 或 <strong>ICMP Flood</strong> 通常会通过消耗网络带宽或系统资源来阻塞正常流量。</li>
</ul>
</li>
</ol>
<p><strong>总结</strong>：半连接攻击是一种利用 TCP 三次握手中的 <strong>SYN</strong> 包来消耗服务器资源的攻击方式，目的是使目标服务器的资源（如连接队列、内存等）耗尽，导致服务器无法处理正常的连接请求。防御半连接攻击的方法包括增加 SYN 队列大小、使用 SYN Cookies、限制连接速率、利用防火墙和入侵检测系统等。</p>
<h4 id="问：讲一下NAT？"><a href="#问：讲一下NAT？" class="headerlink" title="问：讲一下NAT？"></a>问：讲一下NAT？</h4><p><strong>NAT</strong>（<strong>Network Address Translation</strong>，网络地址转换）是一种在网络层对 IP 地址进行转换的技术。<strong>NAT 允许多个内部设备共享一个公共的外部 IP 地址，从而实现私有网络与公共网络（如互联网）之间的通信</strong>。NAT 常用于家庭和企业网络中，以节省 IP 地址、增强网络安全性和简化网络结构。</p>
<ol>
<li><p>NAT的基本原理</p>
<p>NAT 的主要功能是将 <strong>私有 IP 地址</strong> 转换为 <strong>公有 IP 地址</strong>，并反向处理数据流量，即当外部响应到达时，将返回的流量转换回私有 IP 地址。这种转换通常发生在路由器或防火墙设备上。</p>
<p><strong>基本流程</strong>：</p>
<ul>
<li><strong>内部设备发起连接</strong>：例如，内网中的一台设备（如计算机）发起到外网的请求，数据包会通过 NAT 路由器。在这个过程中，路由器将私有 IP 地址（例如 192.168.x.x）转换为公共 IP 地址（例如 203.0.113.x）。</li>
<li><strong>外部设备响应</strong>：当外部服务器响应时，返回的数据包会发送到公有 IP 地址（203.0.113.x），NAT 路由器会根据之前的映射关系，将数据包重定向到原始发起请求的内部设备（如 192.168.x.x）。</li>
</ul>
<p>通过这种方式，NAT 允许多个内部设备共享一个公共 IP 地址进行外部通信，同时外部无法直接访问内部设备，从而提高了网络的安全性。</p>
</li>
<li><p>NAT的类型</p>
<p>NAT 有不同的实现方式，常见的有以下几种类型：</p>
<p><strong>1. 静态NAT（Static NAT）</strong></p>
<ul>
<li><p><strong>定义</strong>：静态 NAT 是将每个内部设备的私有 IP 地址与一个固定的公共 IP 地址一一对应起来。这意味着每个内部设备都始终通过同一个公共 IP 地址进行通信。</p>
</li>
<li><p>特点：</p>
<ul>
<li>需要公共 IP 地址池。</li>
<li>内部设备和外部设备之间的映射是固定的，适用于需要从外部访问内部服务器的场景（如 Web 服务器、FTP 服务器）。</li>
</ul>
</li>
<li><p><strong>例子</strong>：内部服务器 192.168.1.2 映射到公网 IP 地址 203.0.113.2。</p>
</li>
</ul>
<p><strong>2. 动态NAT（Dynamic NAT）</strong></p>
<ul>
<li><p><strong>定义</strong>：动态 NAT 将私有 IP 地址池与公共 IP 地址池之间进行动态映射。在这种方式下，公共 IP 地址是临时分配给内部设备的，而不是一一对应。</p>
</li>
<li><p>特点：</p>
<ul>
<li>内部设备通过随机选择的公网 IP 进行外部访问。</li>
<li>没有固定的映射关系，外部无法直接访问内部设备。</li>
<li>适合大量内部设备共享少量公共 IP 地址的场景。</li>
</ul>
</li>
<li><p><strong>例子</strong>：内部设备 192.168.1.x 可以通过公网 IP 地址池中的任一 IP（如 203.0.113.1、203.0.113.2）进行外部通信。</p>
</li>
</ul>
<p><strong>3. 端口映射NAT（PAT，Port Address Translation）</strong></p>
<ul>
<li><p><strong>定义</strong>：端口映射 NAT（通常称为 <strong>NAT Overload</strong>）是最常见的 NAT 类型，它通过对私有 IP 地址和端口号进行转换，将多个内网设备的连接映射到一个公网 IP 地址的不同端口上。</p>
</li>
<li><p>特点：</p>
<ul>
<li>多个内部设备通过同一个公共 IP 地址进行通信，但每个连接通过不同的端口号区分。</li>
<li>在大多数家庭和小型企业网络中，通常使用 PAT 来共享单一的公网 IP 地址。</li>
<li>增强了公共 IP 地址的利用率，是最常见的 NAT 类型。</li>
</ul>
</li>
<li><p><strong>例子</strong>：多个内部设备（192.168.1.2:12345、192.168.1.3:12346）通过公共 IP 地址 203.0.113.1 和不同的端口号（例如 203.0.113.1:10000 和 203.0.113.1:10001）与外部通信。</p>
</li>
</ul>
</li>
<li><p>NAT的应用场景</p>
<ol>
<li><strong>私有地址与公网地址的转换</strong>：NAT 允许多个设备共享一个公共 IP 地址，因此可以缓解 IPv4 地址紧张的问题，尤其是在局域网中的设备数量远大于公共 IP 地址时。</li>
<li><strong>网络安全</strong>：NAT 能够增强网络安全性。通过隐藏内网设备的真实 IP 地址，外部无法直接访问内部网络中的设备，从而降低了网络被攻击的风险。</li>
<li><strong>连接多个设备</strong>：在企业或家庭网络中，NAT 可以让多个设备共享单一公网 IP 地址访问互联网，减少了对公网 IP 地址的需求。</li>
<li><strong>私有网络互通</strong>：NAT 还可以用于不同的私有网络之间的通信。通过合理的 NAT 配置，可以使得多个私有网络在公网中进行通信，而无需每个网络都持有公网 IP 地址。</li>
</ol>
</li>
<li><p>NAT的优缺点</p>
<p><strong>优点</strong>：</p>
<ul>
<li><strong>节省公共 IP 地址</strong>：通过共享公共 IP 地址，NAT 使得多个内网设备能够使用单个公网 IP 地址进行互联网通信，从而节省了大量的公网 IP 地址。</li>
<li><strong>增强安全性</strong>：外部网络无法直接访问内网设备的真实 IP 地址，增加了网络的安全性，降低了潜在的攻击面。</li>
<li><strong>灵活性</strong>：不同类型的 NAT（如静态、动态、PAT）提供了灵活的配置选项，可以根据网络规模和需求进行选择。</li>
</ul>
<p><strong>缺点</strong>：</p>
<ul>
<li><strong>连接追踪复杂</strong>：NAT 需要跟踪每个连接的状态（特别是 PAT），随着连接数的增加，路由器或防火墙需要维护更多的连接信息，增加了复杂性。</li>
<li><strong>限制某些协议</strong>：一些协议（如 FTP、SIP 等）依赖于真实的 IP 地址，NAT 可能会对这些协议的通信造成干扰。为了解决这些问题，可能需要特别配置（如端口映射、NAT 穿越技术等）。</li>
<li><strong>性能影响</strong>：NAT 需要进行地址转换和连接追踪，这可能会导致一定的性能开销，尤其是在高并发的网络环境中。</li>
</ul>
</li>
<li><p>NAT的常见问题与解决方案</p>
<ul>
<li><strong>IP 地址限制</strong>：由于 NAT 主要依赖公网 IP 地址池进行转换，因此公网 IP 地址池的大小直接限制了可以处理的连接数量。为了解决这个问题，可以使用 <strong>PAT</strong>，通过端口号复用一个公网 IP 地址来支持多个连接。</li>
<li><strong>NAT 穿透问题</strong>：一些基于端到端连接的协议（如 P2P 协议）可能会遇到 NAT 穿透问题。为此，可以使用技术如 <strong>UPnP</strong>、<strong>STUN</strong>、<strong>TURN</strong> 等来穿越 NAT，实现设备间的直接通信。</li>
<li><strong>端口映射</strong>：对于需要外部访问内网服务的情况（如 Web 服务器、FTP 服务器），需要手动配置端口映射。</li>
</ul>
</li>
<li><p>NAT 的标准与协议</p>
<ul>
<li><strong>NAT44</strong>：指的是传统的 IPv4 地址之间的 NAT 操作。在这种 NAT 配置下，通常使用一个公网 IP 地址来与多个私有地址共享连接。</li>
<li><strong>NAT64</strong>：是 IPv6 和 IPv4 网络之间进行互通的 NAT 技术。通过将 IPv6 地址映射到 IPv4 地址，解决了 IPv6 和 IPv4 不兼容的问题。</li>
</ul>
</li>
</ol>
<p><strong>总结</strong>：NAT（网络地址转换）是一项重要的网络技术，用于通过转换 IP 地址来节省公网地址、提高安全性并简化网络结构。它有多种类型，最常见的是静态 NAT、动态 NAT 和端口映射 NAT（PAT）。NAT 的广泛应用可以有效缓解 IP 地址短缺的问题，提升网络的灵活性和安全性，但也有一些局限性，如连接跟踪复杂性、协议支持问题等。</p>
<hr>
<h2 id="二-TCP-IP"><a href="#二-TCP-IP" class="headerlink" title="二. TCP/IP"></a>二. TCP/IP</h2><h4 id="问：TCP和UDP的区别？udp为什么要比tcp快？"><a href="#问：TCP和UDP的区别？udp为什么要比tcp快？" class="headerlink" title="问：TCP和UDP的区别？udp为什么要比tcp快？"></a>问：TCP和UDP的区别？udp为什么要比tcp快？</h4><p>TCP是一种面向连接的、可靠的、基于字节流的传输层通信协议，在发送数据前，通信双方必须在彼此间建立一条连接。所谓的“连接”，其实是客户端和服务端保存的一份关于对方的信息，如ip地址、端口号等。</p>
<p>TCP向上层提供面向连接的可靠服务 ，UDP向上层提供无连接不可靠服务。 虽然 UDP 并没有 TCP 传输来的准确，但是也能在很多实时性要求高的地方有所作为 对数据准确性要求高，速度可以相对较慢的，可以选用TCP</p>
<p><strong>TCP（传输控制协议）**和**UDP（用户数据报协议）**是两种常用的传输层协议，它们各有特点，适用于不同的应用场景。它们的主要区别体现在**连接方式<strong>、</strong>可靠性</strong>、<strong>流量控制</strong>等方面。</p>
<p><strong>1. TCP和UDP的主要区别</strong></p>
<table>
<thead>
<tr>
<th>特性</th>
<th><strong>TCP（传输控制协议）</strong></th>
<th><strong>UDP（用户数据报协议）</strong></th>
</tr>
</thead>
<tbody><tr>
<td><strong>连接方式</strong></td>
<td>面向连接，在数据传输前需要建立连接（通过三次握手）</td>
<td>无连接，数据传输之前不需要建立连接</td>
</tr>
<tr>
<td><strong>可靠性</strong></td>
<td>提供可靠的数据传输，确保数据按顺序到达且无丢失</td>
<td>不提供可靠性保证，数据包可能丢失、重复或乱序</td>
</tr>
<tr>
<td><strong>流量控制</strong></td>
<td>支持流量控制，确保发送方的速度不会超过接收方的处理能力</td>
<td>不支持流量控制，数据包发送速度不受控制</td>
</tr>
<tr>
<td><strong>拥塞控制</strong></td>
<td>支持拥塞控制，动态调整发送速度以避免网络拥堵</td>
<td>不支持拥塞控制，发送速度不受网络状况影响</td>
</tr>
<tr>
<td><strong>数据顺序</strong></td>
<td>数据包有序到达，接收方根据顺序重新组装</td>
<td>数据包无序到达，接收方不关心顺序，需要应用层自行处理顺序</td>
</tr>
<tr>
<td><strong>头部开销</strong></td>
<td>TCP头部较大（20字节以上），包括序号、确认号、标志位等</td>
<td>UDP头部较小（8字节），只有源端口、目的端口、长度、校验和等</td>
</tr>
<tr>
<td><strong>适用场景</strong></td>
<td>适用于对可靠性要求高的应用，如 HTTP、FTP、SMTP 等</td>
<td>适用于对实时性要求高或对可靠性要求低的应用，如 VoIP、视频流、DNS、在线游戏等</td>
</tr>
<tr>
<td><strong>流控制与重传机制</strong></td>
<td>提供自动重传机制，确保丢失的数据包能够重新发送</td>
<td>不提供自动重传机制，丢失的数据包无法恢复</td>
</tr>
</tbody></table>
<p><strong>2. UDP为什么比TCP快？</strong></p>
<p><strong>UDP之所以比TCP快，主要是因为以下几个方面的原因：</strong></p>
<p><strong>1. 无连接特性</strong></p>
<ul>
<li><strong>UDP</strong> 是 <strong>无连接</strong> 的协议。它不会像 <strong>TCP</strong> 一样需要在通信前建立连接，也不需要三次握手过程来确保双方的连接稳定。每次数据发送时，UDP 只需要将数据包发送出去，不涉及连接的建立、维持和终止，这大大减少了通信的延迟。</li>
<li>而 <strong>TCP</strong> 在传输数据之前，必须经过三次握手（SYN → SYN-ACK → ACK），这就增加了初始的延迟。</li>
</ul>
<p><strong>2. 无可靠性保证</strong></p>
<ul>
<li><strong>TCP</strong> 提供了可靠的数据传输保证。它使用 <strong>序列号、确认号</strong> 和 <strong>重传机制</strong> 来确保数据的完整性和顺序。每个数据包都需要确认收到，若丢失则重新传输。这就增加了额外的延迟。</li>
<li><strong>UDP</strong> 则不保证数据的可靠到达，它不进行重传、不保证顺序，也不进行流量控制，发送数据后没有任何等待和确认，因此传输速度更快。</li>
</ul>
<p><strong>3. 无流量控制和拥塞控制</strong></p>
<ul>
<li><strong>TCP</strong> 使用 <strong>流量控制</strong>（通过滑动窗口机制）来确保接收方能够处理发送方发送的每个数据包，若接收方缓慢处理数据，发送方就会减速。此外，TCP 还进行 <strong>拥塞控制</strong>，根据网络的拥塞程度调整传输速度。</li>
<li><strong>UDP</strong> 则没有这些机制，它直接将数据包送往目标，而不考虑接收方的处理能力和网络状况，因此它能够以更高的速度传输数据。</li>
</ul>
<p><strong>4. 更小的协议头</strong></p>
<ul>
<li><strong>TCP</strong> 的协议头较大，至少 20 字节，用于存储序列号、确认号、窗口大小、标志位等控制信息。</li>
<li><strong>UDP</strong> 的协议头只有 8 字节，结构简单，只有源端口、目的端口、长度、校验和等基本信息，因此可以节省传输的开销。</li>
</ul>
<p><strong>5. 数据包处理简化</strong></p>
<ul>
<li>在 <strong>UDP</strong> 中，每个数据包独立处理，发送和接收的数据包没有关联性。每个数据包的发送者不需要等待接收者的确认，也不需要等待丢失数据包的重传。</li>
<li>而 <strong>TCP</strong> 需要维护连接状态、确保数据顺序、进行流量控制、进行重传等，这些都增加了处理的复杂度和延迟。</li>
</ul>
<p><strong>3. 使用场景</strong></p>
<p><strong>TCP适合的场景：</strong></p>
<ul>
<li><strong>需要可靠性保证的应用</strong>：如 <strong>HTTP、HTTPS（网页访问）</strong>、<strong>FTP（文件传输）</strong>、<strong>SMTP（邮件传输）</strong> 等。</li>
<li><strong>数据顺序要求严格</strong>：例如 <strong>在线购物、银行系统</strong> 等，这些应用必须保证数据按照发送顺序到达。</li>
<li><strong>网络环境相对稳定，传输质量有保障</strong>：如企业内部网络、可靠的互联网连接等。</li>
</ul>
<p><strong>UDP适合的场景：</strong></p>
<ul>
<li><strong>对实时性要求高但不太关注可靠性的应用</strong>：如 <strong>VoIP（语音通信）</strong>、<strong>视频流</strong>、<strong>在线游戏</strong>、<strong>DNS 查询</strong> 等。</li>
<li><strong>数据量大且丢包不影响整体效果</strong>：例如 <strong>视频直播</strong>、<strong>IPTV</strong> 等，虽然丢包会影响质量，但不会影响整体的体验，因为数据是流式的，可以容忍丢包。</li>
</ul>
<p><strong>4. 总结</strong></p>
<ul>
<li><strong>TCP</strong> 提供可靠的传输、顺序控制、流量控制和拥塞控制，适用于对数据完整性和传输顺序有高要求的场景，但这些功能增加了延迟和开销。</li>
<li><strong>UDP</strong> 则是一个轻量级的协议，它去除了所有的连接管理、可靠性保证、流量控制和拥塞控制等机制，使得它可以在没有这些负担的情况下提供更快的传输速度，适用于实时性要求较高的场景，但它不能保证数据的可靠到达。</li>
</ul>
<h4 id="问：TCP如何实现可靠连接-传输？"><a href="#问：TCP如何实现可靠连接-传输？" class="headerlink" title="问：TCP如何实现可靠连接/传输？"></a>问：TCP如何实现可靠连接/传输？</h4><p><strong>TCP（传输控制协议）</strong> 实现可靠连接和可靠数据传输的机制非常复杂，它通过一系列精密的协议和算法来确保数据的完整性、顺序、以及在丢失或出现错误时的重传。TCP 的可靠传输依赖于以下几个关键机制：</p>
<p><strong>1. 三次握手（Three-Way Handshake）</strong></p>
<p>三次握手是 TCP 实现可靠连接的第一步，用于确保通信双方都准备好进行数据交换。</p>
<ul>
<li><strong>第一次握手：SYN</strong><ul>
<li>客户端发送一个 <strong>SYN（同步）</strong> 包，表示请求建立连接。</li>
<li>这个包包含客户端的 <strong>初始序列号</strong>（ISN，Initial Sequence Number），这个序列号用于标识后续的数据包。</li>
</ul>
</li>
<li><strong>第二次握手：SYN-ACK</strong><ul>
<li>服务器收到客户端的 <strong>SYN</strong> 包后，发送一个 <strong>SYN-ACK（同步-确认）</strong> 包，表示同意建立连接。</li>
<li>该包包含一个 <strong>确认号</strong>，即客户端的 ISN + 1，表示已收到客户端的 SYN 包，同时也会为自己生成一个初始序列号（ISN）。</li>
</ul>
</li>
<li><strong>第三次握手：ACK</strong><ul>
<li>客户端收到服务器的 <strong>SYN-ACK</strong> 包后，发送一个 <strong>ACK（确认）</strong> 包，确认收到了服务器的 SYN 包。</li>
<li>客户端的 ACK 包的 <strong>确认号</strong> 是服务器的 ISN + 1，表示客户端已接收到服务器的初始序列号。</li>
<li>三次握手完成后，客户端和服务器之间的连接建立成功，双方可以开始数据传输。</li>
</ul>
</li>
</ul>
<p><strong>三次握手的目的：</strong></p>
<ul>
<li>确保客户端和服务器双方都能接收到对方的初始序列号。</li>
<li>确保双方都处于可用状态并准备好进行通信。</li>
<li>防止旧的重复连接请求对当前连接产生影响。</li>
</ul>
<p><strong>2. 数据传输过程中的可靠性保证</strong></p>
<p><strong>（1）数据的顺序保证</strong></p>
<ul>
<li><strong>序列号（Sequence Number）</strong>：每个 TCP 数据段都携带一个序列号，用于标识数据在流中的位置。序列号的作用是确保数据按正确的顺序到达接收端。</li>
<li>即使数据包在网络中乱序到达，接收方也能够通过序列号将数据按照正确的顺序进行重组。</li>
</ul>
<p><strong>（2）确认（Acknowledgment）和重传机制</strong></p>
<ul>
<li><strong>确认号（Acknowledgment Number）</strong>：每个接收端会发送一个确认号（ACK），表示它已收到的数据字节的下一个期望字节的序号。比如，接收端收到字节 1 到 100 的数据，那么它会发送确认号 101，表示接收端已经成功接收了 1 到 100 的数据，期望下一个数据是 101。</li>
<li><strong>超时重传</strong>：如果发送方在一定时间内没有收到对方的 ACK 响应，它会假设数据包丢失，重新发送该数据包。超时时间通常使用 <strong>动态计算</strong>，根据网络的延迟和拥塞情况进行调整。</li>
</ul>
<p><strong>（3）滑动窗口（Sliding Window）机制</strong></p>
<ul>
<li><strong>滑动窗口</strong>：TCP 使用滑动窗口机制来控制数据的流量和确认。在一个窗口内，发送方可以连续发送多个数据包，而无需等待每个数据包的确认。窗口大小由接收方的缓冲区大小和网络状况动态决定。</li>
<li><strong>窗口大小的调整</strong>：接收方可以通过 ACK 包中携带的窗口大小字段来告诉发送方它的接收窗口大小。发送方可以根据接收方的接收能力调整发送速度，从而实现流量控制。</li>
</ul>
<p><strong>（4）流量控制</strong></p>
<ul>
<li>TCP 通过 <strong>流量控制</strong> 来防止发送方的数据超出接收方的处理能力。流量控制机制通常是基于 <strong>接收窗口（rwnd）</strong> 来工作，接收方在 ACK 包中告知发送方自己接收缓冲区的剩余空间，发送方根据这个信息控制数据发送的速率。</li>
</ul>
<p><strong>（5）拥塞控制</strong></p>
<ul>
<li><p>拥塞控制</p>
<p> 用于避免网络过载，防止过多的数据包在网络中排队，从而导致网络性能下降。TCP 使用以下几种算法来进行拥塞控制：</p>
<ul>
<li><strong>慢启动（Slow Start）</strong>：TCP 连接刚开始时，发送方的拥塞窗口大小设置为一个较小的值。随着网络的正常运行，窗口会指数级增长，直到检测到网络拥塞。</li>
<li><strong>拥塞避免（Congestion Avoidance）</strong>：在慢启动后，窗口大小的增长将变得线性，以避免网络拥塞。</li>
<li><strong>快速重传和快速恢复（Fast Retransmit &amp; Fast Recovery）</strong>：当接收方收到重复的 ACK（即表明丢包）时，发送方会迅速重传丢失的数据包，并进入快速恢复阶段，避免慢启动再次发生。</li>
</ul>
</li>
</ul>
<p><strong>3. 连接的终止（四次挥手）</strong></p>
<p>连接终止也需要通过一系列的信号交互来确保数据传输的可靠性。TCP 使用 <strong>四次挥手（Four-Way Handshake）</strong> 来断开连接：</p>
<ul>
<li><strong>第一次挥手（FIN）：</strong> 发送方通过发送一个 <strong>FIN</strong>（结束）包来请求断开连接。</li>
<li><strong>第二次挥手（ACK）：</strong> 接收方确认收到 <strong>FIN</strong> 包，并发送一个 <strong>ACK</strong> 包确认。</li>
<li><strong>第三次挥手（FIN）：</strong> 接收方在确认完 <strong>ACK</strong> 后，发送一个 <strong>FIN</strong> 包，表示准备断开连接。</li>
<li><strong>第四次挥手（ACK）：</strong> 发送方确认接收到接收方的 <strong>FIN</strong> 包，并发送 <strong>ACK</strong> 包确认，至此连接完全关闭。</li>
</ul>
<p><strong>4. TCP实现可靠连接和传输的关键点</strong></p>
<ol>
<li><strong>顺序保证</strong>：通过序列号和确认号，确保数据按顺序到达。</li>
<li><strong>重传机制</strong>：通过超时重传和重复 ACK，确保丢失的数据包被重新发送。</li>
<li><strong>流量控制</strong>：通过滑动窗口和接收方的反馈，防止接收方溢出。</li>
<li><strong>拥塞控制</strong>：通过慢启动、拥塞避免、快速重传等算法，避免网络拥塞。</li>
<li><strong>双向关闭</strong>：通过四次挥手确保双方都能正确地断开连接。</li>
</ol>
<p><strong>总结</strong></p>
<p>TCP 实现可靠连接和可靠传输主要依赖于以下几个机制：</p>
<ul>
<li><strong>三次握手</strong>：确保双方能够建立连接并同步初始序列号。</li>
<li><strong>顺序保证、确认机制、重传机制</strong>：确保数据完整、按顺序到达，并且丢失的数据会被重新传输。</li>
<li><strong>流量控制</strong>：防止接收方缓冲区溢出。</li>
<li><strong>拥塞控制</strong>：避免网络拥塞，优化数据传输效率。 这些机制使得 TCP 能够在不可靠的网络环境中提供可靠的端到端通信。</li>
</ul>
<h4 id="问：为什么要有TimeWait状态？TimeWait的等待时长一般是多少？为什么Time-Wait中2-msl？"><a href="#问：为什么要有TimeWait状态？TimeWait的等待时长一般是多少？为什么Time-Wait中2-msl？" class="headerlink" title="问：为什么要有TimeWait状态？TimeWait的等待时长一般是多少？为什么Time_Wait中2*msl？"></a>问：为什么要有TimeWait状态？TimeWait的等待时长一般是多少？为什么Time_Wait中2*msl？</h4><p><strong>TIME_WAIT</strong> 状态是 TCP 连接断开时的一个关键状态，它在四次挥手（Four-Way Handshake）过程中起着重要作用，确保连接的正常终止并避免一些潜在的问题。</p>
<p><strong>TIME_WAIT 状态的主要作用</strong></p>
<ol>
<li><strong>确保最后的 ACK 能被对方收到</strong><ul>
<li>在 TCP 的连接断开过程中，发送方首先发送一个 <strong>FIN</strong> 包来请求关闭连接，接收方收到 <strong>FIN</strong> 包后，会返回一个 <strong>ACK</strong> 包作为确认。接着，接收方也会发送一个 <strong>FIN</strong> 包来请求关闭连接，发送方在收到 <strong>FIN</strong> 包后，会发送最后一个 <strong>ACK</strong> 包。</li>
<li>为了确保接收方的 <strong>ACK</strong> 包不丢失且最终被对方收到，发送方必须保持连接的状态一段时间。若对方没有收到该 <strong>ACK</strong> 包，它可以重传 <strong>FIN</strong> 包，发送方就可以重发 <strong>ACK</strong> 包。</li>
<li>由于网络中可能会有延迟或数据包丢失，发送方需要保留连接一段时间以确保最后的确认 <strong>ACK</strong> 包不会丢失。</li>
</ul>
</li>
<li><strong>防止重传数据包干扰新的连接</strong><ul>
<li>网络中可能会有延迟的包，即使连接已经关闭，之前的数据包可能在某个时间点到达目的地。在 <strong>TIME_WAIT</strong> 状态下，发送方会等待一段时间，这样可以确保即使旧的数据包到达，因其带有旧的序列号，接收方也能正确识别并丢弃它们，而不会错误地将其当作新连接的一部分。</li>
<li>如果没有 <strong>TIME_WAIT</strong> 状态，早期的旧数据包可能会干扰新的连接（比如新连接也使用相同的端口号），导致连接出错。</li>
</ul>
</li>
</ol>
<p><strong>TIME_WAIT 状态的作用总结</strong></p>
<ol>
<li><strong>确保可靠的连接关闭</strong>：通过保证对方的 <strong>ACK</strong> 包能够到达，确保连接的正常终止。</li>
<li><strong>避免旧数据包的干扰</strong>：通过等待一段时间，使得网络中的延迟包被清理，避免它们对后续连接产生影响。</li>
</ol>
<p><strong>TIME_WAIT 状态的持续时间</strong></p>
<ul>
<li><strong>TIME_WAIT</strong> 状态持续的时间是 <strong>2MSL（Maximum Segment Lifetime）</strong>，即最大报文生存时间（MSL）。MSL 是指数据包在网络中存在的最长时间。一般来说，MSL 的值取决于具体的操作系统和网络环境，通常为 <strong>2 分钟</strong>（即 120 秒），有时也可能是 <strong>4 分钟</strong>。</li>
</ul>
<p><strong>TIME_WAIT 状态的必要性</strong></p>
<ul>
<li><strong>保证正确关闭连接</strong>：如果没有 <strong>TIME_WAIT</strong> 状态，TCP 连接可能会错误地终止，导致数据丢失或者连接重用时出现问题。</li>
<li><strong>避免端口冲突</strong>：在 <strong>TIME_WAIT</strong> 状态期间，原连接使用的端口被标记为不可用，直到 <strong>TIME_WAIT</strong> 状态结束。这确保了新连接不会复用已经关闭的端口，避免了数据包的混乱。</li>
</ul>
<p><strong>TIME_WAIT 状态的性能影响</strong></p>
<p>尽管 <strong>TIME_WAIT</strong> 状态是必要的，但在高并发的服务器（如 Web 服务器）中，它可能会导致端口耗尽的问题，特别是在大量短时间内打开和关闭连接的情况下。为了缓解这种问题，一些操作系统和应用程序可以采取以下措施：</p>
<ol>
<li><strong>重用 TIME_WAIT 状态</strong>：通过一些技术，如 <strong>TCP 快速重用（TCP Fast Open）</strong> 或 <strong>SO_REUSEADDR/SO_REUSEPORT</strong>，操作系统可能允许在 <strong>TIME_WAIT</strong> 状态期间重新使用端口，但这需要确保不干扰网络协议的可靠性。</li>
<li><strong>减少 TIME_WAIT 持续时间</strong>：一些操作系统允许调整 <strong>TIME_WAIT</strong> 的持续时间，例如通过 <strong>sysctl</strong> 设置，虽然这种做法可能会牺牲一定的可靠性。</li>
</ol>
<p><strong>总结</strong></p>
<p><strong>TIME_WAIT</strong> 状态是 TCP 协议中确保可靠关闭连接、避免数据包干扰以及保证端口不冲突的机制。它确保了即使在连接关闭后仍能正确处理网络延迟、数据包丢失等问题，防止旧的数据包干扰到新的连接。尽管它可能带来一定的资源消耗和端口耗尽问题，但它是 TCP 协议实现可靠传输的重要一环。</p>
<p><strong>TIME_WAIT</strong> 状态的持续时间设为 <strong>2 * MSL</strong>（即 <strong>最大报文生存时间（Maximum Segment Lifetime）</strong>）的原因是为了确保两个重要的目的：</p>
<p><strong>1. 确保对方的最后一个 ACK 能被接收方收到</strong></p>
<ul>
<li>在 TCP 连接的关闭过程中，发送方会发送一个 <strong>FIN</strong> 包来请求关闭连接，接收方收到 <strong>FIN</strong> 包后，会发送一个 <strong>ACK</strong> 包确认。接着，接收方也会发送一个 <strong>FIN</strong> 包来请求关闭连接，发送方在收到接收方的 <strong>FIN</strong> 包后，发送最后一个 <strong>ACK</strong> 包作为确认。</li>
<li>在 <strong>TIME_WAIT</strong> 状态期间，发送方会等待一个 <strong>MSL（最大报文生存时间）</strong> 的时间，以确保接收方能够正确接收到这个 <strong>最后的 ACK</strong> 包。如果接收方没有接收到这个 <strong>ACK</strong> 包，它可以重传 <strong>FIN</strong> 包，发送方就可以重发 <strong>ACK</strong> 包。<ul>
<li>例如，在一个复杂的网络环境中，延迟和丢包可能导致对方的 <strong>ACK</strong> 包丢失。<strong>TIME_WAIT</strong> 状态确保发送方能在等待足够的时间后再次重发 <strong>ACK</strong> 包，从而确保连接能够被正确关闭。</li>
</ul>
</li>
</ul>
<p><strong>2. 确保旧的重复数据包不会干扰新的连接</strong></p>
<ul>
<li>在实际的网络环境中，由于网络延迟、路由变化等原因，旧的数据包可能在连接关闭后仍然存在于网络中并最终到达接收方。这些数据包可能是旧连接的数据包，它们可能携带旧的序列号，和新的连接产生冲突。</li>
<li><strong>TIME_WAIT</strong> 状态确保连接在关闭后仍然保持一段时间，这样可以让网络中任何还未被丢弃的旧数据包完全消失。这样，当新的连接使用相同的端口号时，接收方能够正确区分新旧连接，避免误判。<ul>
<li>假设一个连接的最后一个 <strong>FIN</strong> 包的序列号是 1000，发送方在关闭连接时处于 <strong>TIME_WAIT</strong> 状态。如果连接的端口被重用，新的连接会再次使用相同的端口号。如果没有 <strong>TIME_WAIT</strong> 状态，旧的 <strong>FIN</strong> 包可能会被误认为是新连接的数据包，而导致新的连接出现问题。</li>
</ul>
</li>
</ul>
<p><strong>3. MSL 的定义：最大报文生存时间</strong></p>
<ul>
<li><strong>MSL（Maximum Segment Lifetime）</strong> 是一个网络中数据包能够存在的最大时间。这个时间取决于网络中的各种因素，如网络设备的缓冲、路由路径、以及数据包的转发过程。MSL 并不是固定的标准，而是根据具体的网络环境和实现来确定。<ul>
<li>在大多数网络中，MSL 通常设定为 <strong>2 分钟（120 秒）</strong>，因此，<strong>TIME_WAIT</strong> 状态的持续时间通常设为 <strong>2 * MSL = 240 秒</strong>，即 <strong>4 分钟</strong>。这样可以确保连接完全终止后，网络中可能存在的旧数据包不会干扰新的连接。</li>
</ul>
</li>
</ul>
<p><strong>4. 为何是 2 * MSL 而不是 MSL？</strong></p>
<ul>
<li>设定 <strong>TIME_WAIT</strong> 的时间为 <strong>2 * MSL</strong>，是为了考虑到 <strong>网络中的各种延迟和数据包传播时间</strong>。因为一个数据包从发送到接收，可能会经过不同的路由和设备，且不同的数据包在网络中的存活时间不同。因此，必须保证有足够长的时间来清理网络中可能滞留的所有数据包。<ul>
<li><strong>TIME_WAIT</strong> 状态的 <strong>2 * MSL</strong> 时间可以确保所有可能的 <strong>FIN</strong> 包、<strong>ACK</strong> 包以及其他延迟包的存在时间都被覆盖，防止它们在网络中存在过久，导致对新的连接产生影响。</li>
</ul>
</li>
</ul>
<p><strong>5. 实际效果</strong></p>
<ul>
<li><strong>TIME_WAIT</strong> 状态保证了连接的可靠终止，确保即使在网络环境复杂、延迟较大时，数据的顺序、完整性和正确关闭都能得到保证。即使某些数据包在网络中滞留，TCP 也能够处理它们，而不会误将它们当作新连接的数据包。</li>
</ul>
<p><strong>总结</strong></p>
<p><strong>TIME_WAIT</strong> 状态持续 <strong>2 * MSL</strong> 时间，主要是为了确保：</p>
<ol>
<li>对方的 <strong>最后一个 ACK</strong> 能够成功到达并被接收方接收，以完成连接的可靠关闭。</li>
<li>网络中可能存在的延迟数据包（旧连接的数据包）不会干扰到新的连接。 通过设定为 <strong>2 * MSL</strong>，TCP 可以确保在复杂的网络环境中，不会出现数据包干扰，保证连接能够正确地关闭，同时也确保了端口号的重用不会导致混乱。</li>
</ol>
<h4 id="问：如果TCP突然接收方故障会发生什么？"><a href="#问：如果TCP突然接收方故障会发生什么？" class="headerlink" title="问：如果TCP突然接收方故障会发生什么？"></a>问：如果TCP突然接收方故障会发生什么？</h4><p>TCP设有一个保活计时器，客户端如果出现故障，服务器不能一直等下去，白白浪费资源。服务器每收到一次客户端的请求后都会重新复位这个计时器，时间通常是设置为2小时，若两小时还没有收到客户端的任何数据，服务器就会发送一个探测报文段，以后每隔75秒钟发送一次。若一连发送10个探测报文仍然没反应，服务器就认为客户端出了故障，接着就关闭连接。</p>
<p>当 <strong>TCP 连接的接收方故障</strong>时，数据传输会受到影响，可能会导致连接中断、数据丢失或传输延迟等问题。具体的后果取决于故障的类型、发生时的具体情况，以及接收方故障后的恢复机制。下面是一些可能发生的情况以及相应的处理方式：</p>
<p><strong>1. 网络中断或接收方崩溃</strong></p>
<p>当接收方发生故障时，可能出现以下几种情况：</p>
<p><strong>a. 数据包丢失</strong></p>
<ul>
<li><strong>接收方故障导致丢失数据</strong>：如果接收方崩溃或与网络断开连接，任何正在发送到接收方的数据包可能会丢失。由于 TCP 是面向连接的可靠协议，它会通过 <strong>超时重传</strong> 机制检测到丢包，并尝试重新发送数据包。<ul>
<li><strong>发送方的行为</strong>：发送方会等待一段时间以接收到接收方的确认（ACK），如果在超时时间内没有收到确认，它会重传相应的数据包。</li>
</ul>
</li>
</ul>
<p><strong>b. 接收方没有 ACK 响应</strong></p>
<ul>
<li>在接收方故障时，发送方会发现无法收到对数据包的 <strong>确认</strong>（ACK）。在 TCP 中，发送方需要等待确认才能继续发送新的数据（或者根据拥塞控制机制适当调整发送窗口）。<ul>
<li><strong>超时重传</strong>：发送方在超时后会重新发送没有被确认的数据包。这会导致延迟，直到接收方恢复。</li>
<li><strong>连接断开</strong>：如果故障持续存在，发送方的重传次数会达到上限（通常是 3 次或更多），最终发送方会认为连接无法恢复，导致连接终止。</li>
</ul>
</li>
</ul>
<p><strong>c. 数据库或资源未释放</strong></p>
<ul>
<li>如果接收方的故障没有及时修复，可能会导致未处理的数据被丢弃，或者相关资源（如数据库连接、文件句柄等）没有被正确释放。发送方将不会得到数据的确认，可能最终会因多次重传失败而关闭连接。</li>
</ul>
<p><strong>2. TCP 连接状态变化</strong></p>
<p>TCP 连接通常在某些状态下进行数据传输，接收方故障时，TCP 连接的状态会发生变化：</p>
<p><strong>a. 窗口变为零</strong></p>
<ul>
<li>当接收方故障时，它可能没有能力处理更多的数据，或者它的接收窗口被填满。在这种情况下，接收方通过发送 <strong>窗口为零</strong> 的 ACK 报文来通知发送方停止发送数据。</li>
<li>发送方收到 <strong>窗口为零</strong> 的 ACK 后，会进入 <strong>等待窗口更新</strong> 的状态，直到接收方恢复并发送一个非零的窗口大小。</li>
</ul>
<p><strong>b. 重传超时（RTO）</strong></p>
<ul>
<li>如果接收方崩溃，发送方会检测到 <strong>超时重传</strong>，并且如果超时重传的次数过多，TCP 会认为连接不可恢复，最终关闭连接。</li>
</ul>
<p><strong>c. 半开连接（Half-Open）</strong></p>
<ul>
<li>如果接收方在数据传输过程中突然崩溃，可能会导致 <strong>半开连接</strong>。在这种情况下，发送方认为连接仍然存在，并继续发送数据包，但由于接收方故障，它不会响应 <strong>ACK</strong>，从而导致发送方无法收到确认。<ul>
<li>这种情况下，接收方恢复后可能会发送一个 <strong>RESET</strong>（RST）包来告知发送方连接已经中断。</li>
</ul>
</li>
</ul>
<p><strong>3. TCP 连接的关闭与重建</strong></p>
<p>接收方故障之后，发送方如果无法继续等待重传或无法从接收方恢复连接，它可能会主动关闭连接。连接的关闭一般会通过 <strong>四次挥手</strong>（Four-Way Handshake）来完成。</p>
<p><strong>a. 连接重置（RST）</strong></p>
<ul>
<li>在某些情况下，如果接收方发生崩溃或发生其他错误，接收方可能会发送一个 <strong>RST（重置）包</strong>，表示连接不再有效。发送方收到 <strong>RST</strong> 包后，连接会立即被关闭。</li>
</ul>
<p><strong>b. 重新建立连接</strong></p>
<ul>
<li>如果接收方恢复正常，它可以重新启动服务并重新建立连接，或者接收方和发送方在应用层会重新尝试进行连接。此时，TCP 连接就会重新进入三次握手过程，重新建立可靠连接。</li>
</ul>
<p><strong>4. 接收方故障的恢复</strong></p>
<p>TCP 本身并没有专门的机制来处理接收方故障时的自动恢复，但有一些方法可以在应用层和网络层进行优化，以便尽量减少故障对数据传输的影响：</p>
<p><strong>a. 数据重传</strong></p>
<ul>
<li>TCP 依赖于 <strong>重传机制</strong>，发送方会在没有收到确认的情况下重传数据包。当接收方恢复后，它将会发送确认信号并接收丢失的数据包。</li>
</ul>
<p><strong>b. 快速重传（Fast Retransmit）</strong></p>
<ul>
<li>如果接收方恢复后，发送方通过快速重传机制（基于接收方发送的重复 ACK）快速恢复数据传输。</li>
</ul>
<p><strong>c. 保持活动机制（Keep-Alive）</strong></p>
<ul>
<li>为了确保连接不中断，某些应用程序使用 <strong>TCP Keep-Alive</strong> 机制。通过定期发送小的 <strong>探测包</strong> 来检测连接是否还有效。若连接没有响应，发送方可以判断接收方故障并采取适当的恢复措施。</li>
</ul>
<p><strong>5. 应用层的处理</strong></p>
<p>应用层通常会采取一些策略来处理 TCP 连接的中断或接收方故障：</p>
<ul>
<li><strong>超时和重试机制</strong>：应用层可能会设置超时并在超时后重试连接。比如，HTTP 客户端在请求失败时可以自动重试。</li>
<li><strong>分布式系统中的容错机制</strong>：在分布式系统中，可能会使用 <strong>负载均衡器</strong>、<strong>容错</strong> 或 <strong>备份系统</strong>，即使一个接收方出现故障，其他节点可以接管其工作，确保系统的高可用性。</li>
</ul>
<p><strong>总结</strong></p>
<p>当 TCP 的接收方故障时，发送方会发现无法收到确认，并通过超时重传机制继续重试。如果故障持续，连接将会中断，可能导致数据丢失、传输延迟，或者连接被重置。最终，连接将会被关闭或重新建立。虽然 TCP 提供了数据的可靠传输，但接收方故障仍然会对连接产生影响，应用层和系统通常需要额外的容错和恢复机制来减少故障带来的影响。</p>
<h4 id="问：TCP怎么计算网络延迟？"><a href="#问：TCP怎么计算网络延迟？" class="headerlink" title="问：TCP怎么计算网络延迟？"></a>问：TCP怎么计算网络延迟？</h4><p>网络延迟的采样方法。</p>
<p>在 <strong>TCP</strong> 协议中，<strong>网络延迟</strong>（或称为 <strong>往返时间</strong>，Round-Trip Time，RTT）是指数据从发送方发送到接收方并且接收方响应返回到发送方所花费的时间。TCP 使用 <strong>RTT</strong> 来估算网络的延迟，并根据这一信息来调整连接的行为，尤其是 <strong>超时重传</strong>、<strong>流量控制</strong> 和 <strong>拥塞控制</strong> 等方面。</p>
<p><strong>TCP 如何计算和使用 RTT</strong></p>
<p>TCP 中的 RTT 是通过对每个数据包的往返时延进行测量来估算的。具体来说，TCP 使用 <strong>时间戳</strong> 或 <strong>ACK</strong> 来测量往返时间。每当发送一个数据包时，发送方会在该数据包中记录当前的时间戳，接收方收到该数据包并发送确认时，发送方就可以计算该数据包的 RTT。</p>
<p><strong>1. RTT 的测量</strong></p>
<p>TCP 通过以下机制来测量 RTT：</p>
<ul>
<li><strong>发送数据包时记录时间戳</strong>：当 TCP 发送数据时，它记录发送该数据包时的本地时间。这个时间戳通常是在发送的数据包中嵌入的（或者通过操作系统内部的时间戳机制来捕获）。发送方把该数据包发送给接收方，并等待接收方的确认（ACK）。</li>
<li><strong>接收方发送确认</strong>：接收方收到数据包后，会发送一个 <strong>ACK</strong> 包确认该数据包的接收。</li>
<li><strong>计算 RTT</strong>：当发送方收到 <strong>ACK</strong> 包时，它可以计算发送时和接收时的时间差，得到 <strong>RTT</strong> 值。<ul>
<li>具体的计算方式是： RTT=ACK 到达时间−数据包发送时间</li>
</ul>
</li>
</ul>
<p><strong>2. 平滑 RTT（Smoothed RTT，SRTT）</strong></p>
<p>因为网络延迟可能会波动，TCP 通常不会使用单次测量的 RTT 值，而是使用一个 <strong>平滑后的 RTT</strong>（SRTT），它对多次 RTT 测量进行加权平均，从而减少网络波动的影响，获得更加稳定的延迟估算值。</p>
<ul>
<li><p><strong>平滑 RTT 计算</strong>：通常使用 <strong>加权平均法</strong>，根据以下公式计算 SRTT：</p>
<p>SRTT=(1−α)×SRTT+α×RTTsample</p>
<p>其中，α 是一个小的常数，通常为 0.125，RTTsample 是当前的 RTT 测量值。</p>
</li>
<li><p><strong>RTT 的变化</strong>：为了估算网络的变化情况，TCP 还会计算一个叫做 <strong>RTTVAR</strong>（RTT Variation）的值，它表示 RTT 的波动。RTTVAR 使用以下公式计算：</p>
<p>RTTVAR=(1−β)×RTTVAR+β×∣RTTsample−SRTT∣</p>
<p>其中，β\beta 通常为 0.25。</p>
</li>
<li><p><strong>最终的超时值</strong>（RTO）：TCP 会结合 SRTT 和 RTTVAR 来计算 <strong>重传超时时间（RTO，Retransmission Timeout）</strong>，即发送方等待 ACK 的最大时间。在 RTO 计算中，通常使用以下公式：</p>
<p>RTO=SRTT+max⁡(4×RTTVAR,MSL)</p>
<p>其中，MSL（最大报文生存时间）是网络中数据包的最大存活时间，通常为 1 秒或更长。</p>
</li>
</ul>
<p><strong>3. 计算示例</strong></p>
<p>假设我们有以下 RTT 测量值：</p>
<ul>
<li>第一次测量 RTT 为 <strong>100ms</strong></li>
<li>第二次测量 RTT 为 <strong>150ms</strong></li>
<li>第三次测量 RTT 为 <strong>120ms</strong></li>
</ul>
<p>假设初始的 <strong>SRTT</strong> 为 <strong>100ms</strong> 和 <strong>RTTVAR</strong> 为 <strong>20ms</strong>，使用 <strong>α = 0.125</strong> 和 <strong>β = 0.25</strong> 来平滑计算。</p>
<ul>
<li><p><strong>SRTT 计算</strong>：</p>
<p>SRTT=(1−0.125)×100+0.125×150=87.5+18.75=106.25ms</p>
</li>
<li><p><strong>RTTVAR 计算</strong>：</p>
<p>RTTVAR=(1−0.25)×20+0.25×∣150−106.25∣=15+10.9375=25.9375ms</p>
</li>
</ul>
<p>通过这些计算，TCP 就可以在不断的 RTT 测量中持续优化超时时间（RTO）和流量控制。</p>
<p><strong>4. 为什么平滑 RTT 重要？</strong></p>
<p>平滑 RTT 对于 TCP 的性能至关重要，尤其是在：</p>
<ul>
<li><strong>重传机制</strong>：通过平滑 RTT 和 RTTVAR，TCP 能够更好地调整 <strong>重传超时（RTO）</strong>，避免因偶尔的高 RTT 测量导致过早重传或过长的重传超时。</li>
<li><strong>流量控制和拥塞控制</strong>：TCP 使用 RTT 来调整 <strong>滑动窗口</strong> 和 <strong>拥塞窗口</strong>，如果网络延迟很高，它会减缓数据的发送速度，从而避免网络拥塞。</li>
</ul>
<p>平滑 RTT 和 RTTVAR 使得 TCP 更加稳健，避免在网络状况波动时作出过于激烈的反应。</p>
<p><strong>5. 网络延迟对 TCP 的影响</strong></p>
<p>网络延迟直接影响 TCP 的性能，特别是在以下几个方面：</p>
<ul>
<li><strong>传输速度</strong>：高 RTT 会增加数据包的往返时间，导致数据传输的速率降低。TCP 会依据 RTT 来调整数据发送速率，确保网络不被过载。</li>
<li><strong>拥塞控制</strong>：在高延迟环境下，TCP 会适当减少 <strong>拥塞窗口</strong>，以避免因延迟导致的拥塞。</li>
<li><strong>超时重传</strong>：延迟增大会增加超时的概率，导致数据包重传，增加网络负载和延迟。</li>
</ul>
<p><strong>总结</strong></p>
<p>TCP 通过不断测量 RTT（往返时延）来估算网络延迟，并根据这些测量值调整重传超时（RTO）、流量控制和拥塞控制等参数。通过平滑 RTT 和计算 RTTVAR，TCP 能够更稳健地应对网络延迟的波动，优化连接的性能。</p>
<h4 id="问：TCP三次握手和四次挥手？"><a href="#问：TCP三次握手和四次挥手？" class="headerlink" title="问：TCP三次握手和四次挥手？"></a>问：TCP三次握手和四次挥手？</h4><p>标志位字段：</p>
<ul>
<li>ACK：确认序号有效。</li>
<li>FIN：释放一个连接。</li>
<li>PSH：接收方应该尽快将这个报文交给应用层。</li>
<li>RST：重置连接。</li>
<li>SYN：发起一个新连接。</li>
<li>URG：紧急指针（urgent pointer）有效。</li>
</ul>
<p>三次握手：</p>
<p>（1）：客户端发送连接请求报文，SYN=1，ACK=0，选择一个初始的序号 x。</p>
<p>（2）：服务端收到连接请求报文，通过SYN=1知道是连接请求，如果同意建立连接，保存序号，向客户端发送连接确认报文，SYN=1，ACK=1，确认号ack= x+1，同时也选择一个初始的序号 y。</p>
<p>（3）：客户端收到连接确认报文后，还要向服务端发出确认，确认号为 y+1，序号为 x+1。（不携带数据的ACK报文是不占据序列号的，所以后面第一次正式发送数据时seq还是101)）</p>
<p>TCP四次挥手</p>
<p>（1）：客户端发送终止命令报文，FIN=1，序列号=x + 1 + n = u，此后客户端无法再发送数据，但可以接收。</p>
<p>（2）：服务端收到后回复确认报文，ACK=1，确认号ack=u + 1，服务端处于close_wait状态，在此期间将未发送完的数据发送。</p>
<p>（3）：服务器将最后的数据发送完毕后发送连接释放报文，FIN=1，ACK=1，序列号=w，确认号ack=u + 1，给客户端后处于last_ack状态</p>
<p>（4）：客户端收到FIN报文后，发送确认报文，ACK=1，序列号=u+1，确认号ack=w + 1，发送ack后处于tim-wait等待2倍最大报文寿命时长而后进入closed状态，释放TCP连接。服务端收到确认报文后即进入closed状态。</p>
<p><strong>TCP 三次握手（Three-Way Handshake）</strong>和<strong>四次挥手（Four-Way Handshake）</strong>是建立和断开 TCP 连接的核心过程。它们保证了数据传输的可靠性和数据的有序性。下面详细解释这两个过程。</p>
<p><strong>一、三次握手（Three-Way Handshake）</strong></p>
<p>三次握手是建立 TCP 连接的过程，它确保双方在开始通信之前达成一致的协议，以便进行可靠的数据传输。三次握手的目的是让客户端和服务器都能够确认对方的接收能力，确保连接的初始化。</p>
<p><strong>三次握手的过程：</strong></p>
<ol>
<li><strong>客户端发送 SYN 包：</strong><ul>
<li>客户端向服务器发送一个 <strong>SYN</strong>（Synchronize）包，表示请求建立连接。</li>
<li>在此包中，客户端选择一个初始的 <strong>序列号</strong>（Sequence Number，ISN），并将 <strong>SYN</strong> 标志位设置为 1。</li>
<li>客户端进入 <strong>SYN_SENT</strong> 状态，等待服务器的响应。</li>
</ul>
</li>
<li><strong>服务器响应 SYN-ACK 包：</strong><ul>
<li>服务器收到客户端的 <strong>SYN</strong> 包后，确认收到并同意建立连接，发送一个 <strong>SYN-ACK</strong> 包作为回应。</li>
<li>该包包含了服务器自己的 <strong>序列号</strong>，并且 <strong>SYN</strong> 和 <strong>ACK</strong> 标志位均被设置为 1。<strong>ACK</strong> 包的 <strong>确认号</strong> 会设置为客户端的 <strong>序列号 + 1</strong>，表示接收到了客户端的 <strong>SYN</strong> 包。</li>
<li>服务器进入 <strong>SYN-RECEIVED</strong> 状态，等待客户端的确认。</li>
</ul>
</li>
<li><strong>客户端确认 ACK 包：</strong><ul>
<li>客户端收到服务器的 <strong>SYN-ACK</strong> 包后，发送一个 <strong>ACK</strong> 包来确认连接。</li>
<li>该包的 <strong>确认号</strong> 为服务器的 <strong>序列号 + 1</strong>，表示确认收到服务器的 <strong>SYN</strong> 包。此时，客户端进入 <strong>ESTABLISHED</strong> 状态。</li>
<li>服务器收到客户端的 <strong>ACK</strong> 包后，进入 <strong>ESTABLISHED</strong> 状态，连接建立完成。</li>
</ul>
</li>
</ol>
<p><strong>三次握手的流程图：</strong></p>
<figure class="highlight gherkin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">客户端               服务器</span><br><span class="line">  |<span class="string">                    </span>|</span><br><span class="line">  |<span class="string">---- SYN ----------&gt; </span>|</span><br><span class="line">  |<span class="string">                    </span>|</span><br><span class="line">  |<span class="string"> &lt;--- SYN-ACK ------ </span>|</span><br><span class="line">  |<span class="string">                    </span>|</span><br><span class="line">  |<span class="string">---- ACK ----------&gt; </span>|</span><br><span class="line">  |<span class="string">                    </span>|</span><br><span class="line">连接建立，开始数据传输</span><br></pre></td></tr></table></figure>

<p><strong>三次握手的作用：</strong></p>
<ul>
<li><strong>确认双方的接收能力</strong>：客户端和服务器通过交换序列号来确保双方都能发送和接收数据。</li>
<li><strong>防止旧的重复连接</strong>：通过使用序列号和确认号，可以确保建立的连接是新的，避免了先前连接的残留数据影响新的连接。</li>
</ul>
<p><strong>二、四次挥手（Four-Way Handshake）</strong></p>
<p>四次挥手是断开 TCP 连接的过程，确保双方都能够可靠地终止连接，并保证数据能够完整地传输。</p>
<p><strong>四次挥手的过程：</strong></p>
<ol>
<li><strong>客户端发送 FIN 包：</strong><ul>
<li>客户端希望关闭连接时，发送一个 <strong>FIN</strong>（Finish）包，表示客户端没有数据要发送了，但仍然可以接收数据。此时客户端进入 <strong>FIN_WAIT_1</strong> 状态。</li>
<li><strong>FIN</strong> 包的 <strong>序列号</strong> 被设置为客户端当前的序列号，客户端请求终止连接。</li>
</ul>
</li>
<li><strong>服务器回应 ACK 包：</strong><ul>
<li>服务器收到客户端的 <strong>FIN</strong> 包后，确认关闭连接，发送一个 <strong>ACK</strong> 包。这个 <strong>ACK</strong> 包的 <strong>确认号</strong> 为客户端的 <strong>序列号 + 1</strong>，表示已收到关闭请求。</li>
<li>服务器进入 <strong>CLOSE_WAIT</strong> 状态，等待将数据发送完后再关闭连接。</li>
</ul>
</li>
<li><strong>服务器发送 FIN 包：</strong><ul>
<li>服务器准备好关闭连接时，发送一个 <strong>FIN</strong> 包，表示服务器也没有数据要发送了。此时，服务器进入 <strong>LAST_ACK</strong> 状态。</li>
<li>服务器的 <strong>FIN</strong> 包包含服务器的 <strong>序列号</strong>。</li>
</ul>
</li>
<li><strong>客户端回应 ACK 包：</strong><ul>
<li>客户端收到服务器的 <strong>FIN</strong> 包后，发送一个 <strong>ACK</strong> 包确认关闭连接。此时，客户端进入 <strong>TIME_WAIT</strong> 状态。</li>
<li>客户端发送的 <strong>ACK</strong> 包的 <strong>确认号</strong> 为服务器的 <strong>序列号 + 1</strong>。</li>
<li>客户端在 <strong>TIME_WAIT</strong> 状态下等待一段时间（通常是 2 * MSL，最大报文生存时间），以确保服务器收到 <strong>ACK</strong> 包，然后客户端完全关闭连接。</li>
</ul>
</li>
</ol>
<p><strong>四次挥手的流程图：</strong></p>
<figure class="highlight gherkin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">客户端               服务器</span><br><span class="line">  |<span class="string">                    </span>|</span><br><span class="line">  |<span class="string">---- FIN ----------&gt; </span>|</span><br><span class="line">  |<span class="string">                    </span>|</span><br><span class="line">  |<span class="string"> &lt;--- ACK --------- </span>|</span><br><span class="line">  |<span class="string">                    </span>|</span><br><span class="line">  |<span class="string"> &lt;--- FIN --------- </span>|</span><br><span class="line">  |<span class="string">                    </span>|</span><br><span class="line">  |<span class="string">---- ACK ----------&gt; </span>|</span><br><span class="line">  |<span class="string">                    </span>|</span><br><span class="line">连接关闭</span><br></pre></td></tr></table></figure>

<p><strong>四次挥手的作用：</strong></p>
<ul>
<li><strong>确保数据完整性</strong>：四次挥手保证在关闭连接之前，所有数据都能完整地发送和确认。</li>
<li><strong>分步关闭连接</strong>：TCP 连接是全双工的，四次挥手允许双方分别关闭各自的连接通道，避免数据丢失。</li>
</ul>
<p><strong>三次握手与四次挥手的区别</strong></p>
<table>
<thead>
<tr>
<th>特性</th>
<th>三次握手 (连接建立)</th>
<th>四次挥手 (连接关闭)</th>
</tr>
</thead>
<tbody><tr>
<td><strong>作用</strong></td>
<td>建立连接</td>
<td>断开连接</td>
</tr>
<tr>
<td><strong>过程</strong></td>
<td>客户端 -&gt; 服务器 -&gt; 客户端</td>
<td>客户端 -&gt; 服务器 -&gt; 客户端 -&gt; 服务器</td>
</tr>
<tr>
<td><strong>结束标志</strong></td>
<td>客户端和服务器都进入 <strong>ESTABLISHED</strong> 状态</td>
<td>客户端和服务器都进入 <strong>CLOSED</strong> 状态</td>
</tr>
<tr>
<td><strong>数据发送</strong></td>
<td>双方都可以开始发送数据</td>
<td>双方都停止发送数据</td>
</tr>
<tr>
<td><strong>消息类型</strong></td>
<td>SYN, ACK</td>
<td>FIN, ACK</td>
</tr>
</tbody></table>
<p><strong>总结</strong></p>
<ul>
<li><strong>三次握手</strong>用于建立可靠的连接，确保双方能够开始数据传输，且连接是有效的。</li>
<li><strong>四次挥手</strong>用于优雅地断开连接，确保双方在关闭连接前都能够发送完剩余的数据，并且对方能够确认断开请求。</li>
</ul>
<p>这两种机制是 TCP 连接管理的基础，确保了可靠的数据传输和正确的连接生命周期管理。</p>
<h4 id="问：为什么要进行第三次握手，而不是二次？为什么连接时是三次，释放时却是四次？"><a href="#问：为什么要进行第三次握手，而不是二次？为什么连接时是三次，释放时却是四次？" class="headerlink" title="问：为什么要进行第三次握手，而不是二次？为什么连接时是三次，释放时却是四次？"></a>问：为什么要进行第三次握手，而不是二次？为什么连接时是三次，释放时却是四次？</h4><p>为什么要进行第三次握手，而不是二次？</p>
<p>首先要考虑连接时丢包问题，如果是两次，第二次握手时确认报文丢失，而且服务端已做好接收准备（开启一些无用的连接），但客户端未收到确认所以不会发送数据。三次握手的情况，若服务端未收到确认ack报文，就会重新进行第二次握手。</p>
<ul>
<li>防止服务器端开启一些无用的连接增加服务器开销</li>
<li>防止已失效的连接请求报文段突然又传送到了服务端</li>
</ul>
<p>为什么连接时是三次，释放时却是四次？</p>
<ul>
<li>连接时没有特殊要求，而断开时需要考虑数据是否发送完全。</li>
<li>服务端需要等待数据发送完毕再给客户端发送FIN报文，而不能一次性发布确认报文和FIN报文，所以多出了一次。</li>
</ul>
<p>为什么要进行第三次握手，而不是两次？</p>
<p><strong>三次握手</strong>（Three-Way Handshake）而非两次握手，主要是因为 <strong>TCP 是一种全双工协议</strong>，即数据在连接的双方之间是双向流动的，每一方都可以发送数据，并且需要确认对方的状态。通过三次握手，双方能够确认连接的初始化和接收能力，确保可靠的数据传输。</p>
<p>我们逐步分析为什么需要第三次握手：</p>
<p><strong>1. 第一次握手：客户端向服务器发起连接请求</strong></p>
<ul>
<li>客户端发送一个 <strong>SYN</strong> 包，告诉服务器自己希望建立连接。</li>
<li>但此时，客户端并不知道服务器是否已经准备好接受连接，只是表达了希望连接的意图。</li>
</ul>
<p><strong>2. 第二次握手：服务器响应客户端的连接请求</strong></p>
<ul>
<li>服务器收到客户端的 <strong>SYN</strong> 包后，如果服务器能够接受连接，它会回应一个 <strong>SYN-ACK</strong> 包。</li>
<li>这时，客户端知道服务器已经收到了连接请求，并且准备好建立连接。</li>
</ul>
<p><strong>3. 第三次握手：客户端确认连接建立</strong></p>
<ul>
<li>客户端收到服务器的 <strong>SYN-ACK</strong> 包后，会发送一个 <strong>ACK</strong> 包来确认接收到服务器的响应。这样，双方都确认了对方的状态，并且能够开始数据传输。</li>
<li>只有第三次确认后，双方才算完全建立了连接。此时，双方才可以同时发送和接收数据。</li>
</ul>
<p>为什么要进行三次而不是两次？</p>
<p>如果只进行 <strong>两次握手</strong>，客户端和服务器无法相互确认对方的接收能力及状态。例如：</p>
<ul>
<li>客户端发送了 <strong>SYN</strong> 包，服务器接受并返回了 <strong>SYN-ACK</strong> 包。如果只通过这两次交换来建立连接，客户端在发送数据时可能并没有得到确认，导致潜在的 <strong>数据丢失</strong> 或 <strong>连接异常</strong>。</li>
<li>三次握手的第三次确认是确保连接双方都已经准备好并且可以进行数据交换。</li>
</ul>
<p><strong>总结</strong>：三次握手能确保双向的确认，即客户端确认了服务器能接收连接并准备好接收数据，服务器确认了客户端能够接收数据并准备好通信。这样，数据传输就能可靠地进行。</p>
<p>为什么连接时是三次握手，释放时却是四次挥手？</p>
<p><strong>四次挥手</strong>（Four-Way Handshake）而非三次挥手，主要是由于 <strong>TCP 连接是全双工的</strong>，即每一方都可以独立地发送和接收数据。所以，当连接关闭时，每一方都需要独立地关闭自己的发送通道和接收通道。</p>
<p><strong>分析四次挥手的过程：</strong></p>
<ol>
<li><strong>客户端发送 FIN 包：</strong><ul>
<li>客户端发送 <strong>FIN</strong> 包，表示自己已经没有数据要发送了，但仍然可以接收数据。此时，客户端希望关闭连接，但并不意味着服务器的发送通道也关闭了。</li>
</ul>
</li>
<li><strong>服务器发送 ACK 包：</strong><ul>
<li>服务器收到 <strong>FIN</strong> 包后，发送一个 <strong>ACK</strong> 包来确认客户端的关闭请求，并且通知客户端它已准备好关闭接收通道。</li>
<li>此时，客户端的发送通道已关闭，但客户端仍然可以接收来自服务器的数据。</li>
</ul>
</li>
<li><strong>服务器发送 FIN 包：</strong><ul>
<li>服务器准备关闭连接时，发送一个 <strong>FIN</strong> 包，表示服务器端也没有数据要发送了。服务器的发送通道关闭。</li>
<li>此时，服务器的接收通道仍然是开放的，客户端仍然可以向服务器发送数据。</li>
</ul>
</li>
<li><strong>客户端发送 ACK 包：</strong><ul>
<li>客户端收到服务器的 <strong>FIN</strong> 包后，发送一个 <strong>ACK</strong> 包确认关闭连接。</li>
<li>这时，客户端和服务器的发送通道都已经关闭，连接完全释放。</li>
</ul>
</li>
</ol>
<p><strong>为什么要四次而不是三次？</strong></p>
<ul>
<li><strong>全双工连接</strong>：在 TCP 中，连接是全双工的。每一方都可以独立地发送和接收数据。所以，关闭连接时，每一方都需要单独关闭自己的发送通道和接收通道。</li>
<li><strong>关闭顺序问题</strong>：客户端发送 <strong>FIN</strong> 包表示自己发送通道关闭，但接收通道可能仍然需要保持一段时间，等待服务器发送最后的数据。服务器则必须再发送一个 <strong>FIN</strong> 包来关闭其发送通道。</li>
<li><strong>独立的关闭步骤</strong>：四次挥手确保了每一方都能够独立控制自己的关闭进程。只有在双方都确认关闭自己的一侧通道后，连接才算彻底关闭。</li>
</ul>
<p><strong>总结</strong>：因为 TCP 是全双工协议，每个方向的通信都是独立的。连接关闭时，需要分别关闭发送和接收通道，因此需要 <strong>四次</strong> 握手才能确保连接完全释放。</p>
<h4 id="问：为什么客户端发出第四次挥手的确认报文后要等2MSL的时间才能释放TCP连接？"><a href="#问：为什么客户端发出第四次挥手的确认报文后要等2MSL的时间才能释放TCP连接？" class="headerlink" title="问：为什么客户端发出第四次挥手的确认报文后要等2MSL的时间才能释放TCP连接？"></a>问：为什么客户端发出第四次挥手的确认报文后要等2MSL的时间才能释放TCP连接？</h4><p>同样是要考虑丢包的问题，如果第四次挥手的报文丢失，服务端没收到确认ack报文就会重发第三次挥手的报文，这样报文一去一回最长时间就是2MSL，所以需要等这么长时间来确认服务端确实已经收到了。</p>
<p>在 <strong>TCP 连接释放</strong>的过程中，客户端在发送第四次挥手的确认报文（<strong>ACK</strong>）后，处于 <strong>TIME_WAIT</strong> 状态，并且必须等待 <strong>2 * MSL</strong>（<strong>最大报文生存时间，Maximum Segment Lifetime</strong>）的时间才能完全释放连接。这一机制的主要目的是为了确保：</p>
<ol>
<li><p><strong>确保 ACK 能被服务器收到</strong></p>
</li>
<li><p><strong>避免延迟的重复数据包</strong></p>
</li>
<li><p><strong>保证连接的完整关闭</strong></p>
</li>
<li><p><strong>确保 ACK 能被服务器收到</strong></p>
</li>
</ol>
<p>当客户端发送最后一个 <strong>ACK</strong> 包确认服务器的 <strong>FIN</strong> 包时，客户端进入 <strong>TIME_WAIT</strong> 状态，并等待 2 * MSL 的时间。这是因为服务器可能没有收到客户端的 <strong>ACK</strong> 包，或者客户端的 <strong>ACK</strong> 包在网络中由于某种原因丢失了。如果 <strong>ACK</strong> 包丢失，服务器会重新发送 <strong>FIN</strong> 包，客户端必须能够接收到这个 <strong>FIN</strong> 包并重新发送 <strong>ACK</strong> 来确认关闭连接。</p>
<ul>
<li><strong>TIME_WAIT</strong> 状态的 2 * MSL 等待时间保证了客户端能够有足够的时间重新接收并确认可能丢失的 <strong>FIN</strong> 包。</li>
<li><strong>MSL</strong>（最大报文生存时间）是一个预设的时间值，它定义了一个报文在网络中存在的最大时间，通常是 2 分钟（120 秒）或者更长。2 * MSL 意味着等待两倍于网络中数据包的最大生命周期，确保所有延迟的数据包在此时间内消失。</li>
</ul>
<ol start="2">
<li><strong>避免延迟的重复数据包</strong></li>
</ol>
<p>网络中，尤其是经过多个路由器的情况下，数据包可能会发生延迟。即使连接关闭后，之前的 <strong>数据包</strong> 可能会因各种原因（比如路由变化、网络拥塞）在网络中延迟很久到达目标主机。</p>
<ul>
<li>如果 <strong>TIME_WAIT</strong> 时间不够长，可能会发生 <strong>重复数据包</strong> 的情况。假设客户端已经完全关闭了连接，但网络中依然存在一些延迟的旧数据包，这些旧数据包可能在 <strong>TIME_WAIT</strong> 状态结束后到达客户端。如果不等待足够长的时间，这些数据包就会被误认为是新的数据包，导致连接混乱或错误。</li>
<li>通过等待 <strong>2 * MSL</strong>，可以确保所有延迟的 <strong>旧数据包</strong> 都已经超时，并且不会干扰将来的连接。</li>
</ul>
<ol start="3">
<li><strong>保证连接的完整关闭</strong></li>
</ol>
<p>TCP 是一种 <strong>可靠传输协议</strong>，其目的是确保数据的完整和可靠传输。由于 TCP 是 <strong>全双工</strong> 的，在释放连接时，必须保证每一方都已经完全接收完所有数据，关闭连接后不会遗留任何尚未处理的数据。</p>
<ul>
<li>在客户端发送最后的 <strong>ACK</strong> 后，如果没有 2 * MSL 的等待时间，可能存在某些尚未被完全确认的 <strong>数据包</strong>，即使这些数据包已经到达服务器，它们可能仍在等待确认，导致连接没有彻底关闭。</li>
<li>通过等待 2 * MSL 的时间，可以确保所有数据都已经完全接收，并且客户端和服务器双方都已经关闭了所有连接资源。</li>
</ul>
<p>总结：</p>
<p><strong>TIME_WAIT</strong> 状态中的 2 * MSL 时间是为了确保以下几点：</p>
<ul>
<li>服务器能够正确接收到客户端的 <strong>ACK</strong> 包并完成连接的释放。</li>
<li>网络中可能存在的延迟数据包不会影响将来的连接，避免数据包混乱。</li>
<li>确保连接资源被彻底释放，避免连接冲突。</li>
</ul>
<p>这也是保证 <strong>TCP 连接可靠性</strong> 和 <strong>连接的完整关闭</strong> 的重要措施。</p>
<h4 id="问：TCP有哪些状态，相应状态的含义？"><a href="#问：TCP有哪些状态，相应状态的含义？" class="headerlink" title="问：TCP有哪些状态，相应状态的含义？"></a>问：TCP有哪些状态，相应状态的含义？</h4><p><strong>TCP（Transmission Control Protocol）</strong> 是一个面向连接的协议，它的连接过程和数据传输过程都涉及到不同的 <strong>状态</strong>。每个连接都会经历不同的状态来保证数据传输的可靠性和顺序性。TCP 协议的状态机有 11 个状态，每个状态的含义都在建立连接、传输数据以及断开连接过程中扮演着不同的角色。</p>
<p><strong>TCP 状态机概述</strong></p>
<p>TCP 的状态可以通过 <strong>连接的生命周期</strong> 来理解，它通常包括 <strong>连接建立、数据传输</strong> 和 <strong>连接释放</strong> 三个主要阶段。</p>
<ol>
<li><strong>LISTEN</strong></li>
</ol>
<ul>
<li><strong>含义</strong>：等待来自远程主机的连接请求。</li>
<li><strong>应用场景</strong>：服务器端在等待客户端连接时会处于该状态。服务器通过监听一个特定端口，等待客户端发起连接请求。</li>
<li><strong>操作</strong>：服务器创建一个套接字，调用 <code>listen()</code> 函数进入 LISTEN 状态，等待客户端的 <strong>SYN</strong> 包。</li>
</ul>
<ol start="2">
<li><strong>SYN_SENT</strong></li>
</ol>
<ul>
<li><strong>含义</strong>：客户端已发送连接请求，等待服务器的确认。</li>
<li><strong>应用场景</strong>：当客户端向服务器发送了一个 <strong>SYN</strong> 包请求建立连接时，客户端进入 <strong>SYN_SENT</strong> 状态。</li>
<li><strong>操作</strong>：客户端在此状态下发送 <strong>SYN</strong> 包，并等待服务器返回 <strong>SYN-ACK</strong> 包。</li>
</ul>
<ol start="3">
<li><strong>SYN_RECEIVED</strong></li>
</ol>
<ul>
<li><strong>含义</strong>：服务器已收到客户端的连接请求，且已发送回 <strong>SYN-ACK</strong> 包，等待客户端的确认。</li>
<li><strong>应用场景</strong>：服务器接收到客户端的 <strong>SYN</strong> 包后，发送回 <strong>SYN-ACK</strong> 包，进入 <strong>SYN_RECEIVED</strong> 状态，等待客户端的 <strong>ACK</strong> 包。</li>
<li><strong>操作</strong>：此状态表示服务器已经准备好并在等待客户端的确认。</li>
</ul>
<ol start="4">
<li><strong>ESTABLISHED</strong></li>
</ol>
<ul>
<li><strong>含义</strong>：连接建立成功，数据可以双向传输。</li>
<li><strong>应用场景</strong>：连接的双方都收到了对方的确认，TCP 连接已经建立。此时，客户端和服务器可以开始数据传输。</li>
<li><strong>操作</strong>：在这个状态下，双方都可以进行数据的发送和接收。</li>
</ul>
<ol start="5">
<li><strong>FIN_WAIT_1</strong></li>
</ol>
<ul>
<li><strong>含义</strong>：客户端发送了 <strong>FIN</strong> 包，表示希望关闭连接，并等待服务器的 <strong>ACK</strong> 包。</li>
<li><strong>应用场景</strong>：当客户端不再需要发送数据时，它会发送 <strong>FIN</strong> 包来请求关闭连接。</li>
<li><strong>操作</strong>：客户端进入 <strong>FIN_WAIT_1</strong> 状态，等待服务器的 <strong>ACK</strong> 包和最后的数据。</li>
</ul>
<ol start="6">
<li><strong>FIN_WAIT_2</strong></li>
</ol>
<ul>
<li><strong>含义</strong>：客户端已经收到服务器对 <strong>FIN</strong> 包的确认，等待服务器关闭连接。</li>
<li><strong>应用场景</strong>：客户端收到服务器的 <strong>ACK</strong> 包后，它进入 <strong>FIN_WAIT_2</strong> 状态，等待服务器发送 <strong>FIN</strong> 包。</li>
<li><strong>操作</strong>：客户端已经准备好关闭连接，但还需要等待服务器的关闭请求。</li>
</ul>
<ol start="7">
<li><strong>CLOSE_WAIT</strong></li>
</ol>
<ul>
<li><strong>含义</strong>：服务器已收到客户端的 <strong>FIN</strong> 包，等待应用程序关闭连接。</li>
<li><strong>应用场景</strong>：当服务器接收到客户端的 <strong>FIN</strong> 包时，服务器进入 <strong>CLOSE_WAIT</strong> 状态，表示连接的一方已经发起关闭请求，等待应用程序关闭连接。</li>
<li><strong>操作</strong>：服务器需要先处理完应用程序中的所有数据，然后发送 <strong>FIN</strong> 包来请求关闭连接。</li>
</ul>
<ol start="8">
<li><strong>CLOSING</strong></li>
</ol>
<ul>
<li><strong>含义</strong>：双方同时尝试关闭连接，等待对方的确认。</li>
<li><strong>应用场景</strong>：客户端和服务器几乎同时发送了 <strong>FIN</strong> 包。这时，连接的双方都在等待对方的确认。</li>
<li><strong>操作</strong>：这个状态非常少见，通常出现在 <strong>两端同时发起连接关闭请求</strong> 的情况下。</li>
</ul>
<ol start="9">
<li><strong>TIME_WAIT</strong></li>
</ol>
<ul>
<li><strong>含义</strong>：客户端已收到服务器的 <strong>FIN</strong> 包并发送了 <strong>ACK</strong> 包，等待 <strong>2 * MSL</strong>（最大报文生存时间）后，彻底关闭连接。</li>
<li><strong>应用场景</strong>：客户端发送 <strong>ACK</strong> 包确认服务器的 <strong>FIN</strong> 包后，进入 <strong>TIME_WAIT</strong> 状态，等待足够的时间以确保服务器接收到确认。</li>
<li><strong>操作</strong>：客户端处于 <strong>TIME_WAIT</strong> 状态，等待 <strong>2 * MSL</strong> 时间以确保网络中所有延迟的包都消失，避免影响后续连接。</li>
</ul>
<ol start="10">
<li><strong>CLOSED</strong></li>
</ol>
<ul>
<li><strong>含义</strong>：连接已完全关闭。</li>
<li><strong>应用场景</strong>：连接的双方都已经完全关闭连接后，进入 <strong>CLOSED</strong> 状态。</li>
<li><strong>操作</strong>：此状态表示连接的完全关闭。所有的资源都已经释放，套接字也关闭了。</li>
</ul>
<p><strong>TCP 状态总结图</strong></p>
<table>
<thead>
<tr>
<th>状态</th>
<th>含义</th>
<th>描述</th>
</tr>
</thead>
<tbody><tr>
<td><strong>LISTEN</strong></td>
<td>等待连接请求</td>
<td>服务器端在等待客户端的连接请求</td>
</tr>
<tr>
<td><strong>SYN_SENT</strong></td>
<td>连接请求已发送，等待响应</td>
<td>客户端已发送 <strong>SYN</strong> 包，等待服务器的响应（<strong>SYN-ACK</strong> 包）</td>
</tr>
<tr>
<td><strong>SYN_RECEIVED</strong></td>
<td>收到连接请求，等待客户端确认</td>
<td>服务器已收到客户端的 <strong>SYN</strong> 包并返回 <strong>SYN-ACK</strong> 包，等待客户端确认</td>
</tr>
<tr>
<td><strong>ESTABLISHED</strong></td>
<td>连接已建立，数据可传输</td>
<td>连接已建立，客户端和服务器可以开始数据传输</td>
</tr>
<tr>
<td><strong>FIN_WAIT_1</strong></td>
<td>客户端请求关闭连接，等待确认</td>
<td>客户端发送 <strong>FIN</strong> 包，等待服务器的确认（<strong>ACK</strong> 包）</td>
</tr>
<tr>
<td><strong>FIN_WAIT_2</strong></td>
<td>客户端等待服务器关闭连接</td>
<td>客户端收到服务器的 <strong>ACK</strong> 包，等待服务器的 <strong>FIN</strong> 包</td>
</tr>
<tr>
<td><strong>CLOSE_WAIT</strong></td>
<td>服务器准备关闭连接，等待应用关闭</td>
<td>服务器收到客户端的 <strong>FIN</strong> 包，等待应用程序关闭连接</td>
</tr>
<tr>
<td><strong>CLOSING</strong></td>
<td>双方都请求关闭连接，等待确认</td>
<td>双方同时发送 <strong>FIN</strong> 包，等待对方确认</td>
</tr>
<tr>
<td><strong>TIME_WAIT</strong></td>
<td>等待 2 * MSL，确保最后的确认包被接收</td>
<td>客户端已收到 <strong>FIN</strong> 包并发送 <strong>ACK</strong> 包，等待 2 * MSL 时间确认连接关闭</td>
</tr>
<tr>
<td><strong>CLOSED</strong></td>
<td>连接完全关闭</td>
<td>连接已完全关闭，所有资源释放，套接字关闭</td>
</tr>
</tbody></table>
<p><strong>状态之间的转换</strong></p>
<ul>
<li><strong>连接建立</strong>：<ul>
<li>客户端通过发送 <strong>SYN</strong> 包进入 <strong>SYN_SENT</strong> 状态，等待服务器的响应。</li>
<li>服务器收到 <strong>SYN</strong> 后进入 <strong>SYN_RECEIVED</strong> 状态，返回 <strong>SYN-ACK</strong> 包。</li>
<li>客户端收到 <strong>SYN-ACK</strong> 后，进入 <strong>ESTABLISHED</strong> 状态，发送 <strong>ACK</strong> 确认。</li>
</ul>
</li>
<li><strong>连接关闭</strong>：<ul>
<li>客户端通过发送 <strong>FIN</strong> 包进入 <strong>FIN_WAIT_1</strong> 状态。</li>
<li>服务器确认 <strong>FIN</strong> 包后，进入 <strong>CLOSE_WAIT</strong> 状态。</li>
<li>客户端收到 <strong>ACK</strong> 后进入 <strong>FIN_WAIT_2</strong> 状态，等待服务器的 <strong>FIN</strong> 包。</li>
<li>服务器发送 <strong>FIN</strong> 包后，客户端进入 <strong>TIME_WAIT</strong> 状态，等待确认。</li>
<li>服务器进入 <strong>CLOSED</strong> 状态。</li>
</ul>
</li>
</ul>
<p>通过这些状态和状态转换，TCP 确保了数据传输的可靠性，保证了连接的正确建立和可靠断开。</p>
<h4 id="问：说一下dns的原理？"><a href="#问：说一下dns的原理？" class="headerlink" title="问：说一下dns的原理？"></a>问：说一下dns的原理？</h4><p><strong>DNS (Domain Name System)</strong> 原理</p>
<p><strong>DNS (域名系统)</strong> 是互联网中的一种分布式、层次化的命名系统，用于将用户友好的域名（如 <code>www.example.com</code>）转换为计算机可以识别的 IP 地址（如 <code>192.0.2.1</code>）。它是互联网的核心组成部分之一，确保了我们能够使用易记的域名访问网站，而不需要记住数字形式的 IP 地址。</p>
<p><strong>DNS 的工作原理</strong></p>
<ol>
<li><p><strong>用户输入域名</strong><br> 当用户在浏览器中输入一个网址（例如 <code>www.example.com</code>）时，浏览器首先需要找到该网站的 IP 地址，以便与该网站的服务器建立连接。这个过程就是 <strong>DNS 查询</strong>。</p>
</li>
<li><p><strong>DNS 查询过程</strong><br> DNS 查询通常遵循以下步骤：</p>
<h4 id="步骤-1：本地缓存查询"><a href="#步骤-1：本地缓存查询" class="headerlink" title="步骤 1：本地缓存查询"></a><strong>步骤 1：本地缓存查询</strong></h4><ul>
<li>首先，操作系统会检查本地的 DNS 缓存，看看是否已经解析过这个域名并且缓存了其对应的 IP 地址。</li>
<li>如果缓存中存在该域名的 IP 地址（即之前已经解析过并且缓存未过期），系统直接使用缓存中的地址来访问目标网站。</li>
<li>如果缓存中没有该域名的 IP 地址，则继续向 DNS 服务器发起查询请求。</li>
</ul>
<h4 id="步骤-2：递归-DNS-查询"><a href="#步骤-2：递归-DNS-查询" class="headerlink" title="步骤 2：递归 DNS 查询"></a><strong>步骤 2：递归 DNS 查询</strong></h4><ul>
<li>如果本地缓存没有找到 IP 地址，计算机会向 <strong>递归 DNS 服务器</strong> 发送查询请求。递归 DNS 服务器通常由互联网服务提供商（ISP）提供。</li>
<li>递归 DNS 服务器会代替客户端继续查询该域名的 IP 地址，并通过一系列的 DNS 服务器来逐步解析该域名。</li>
</ul>
<h4 id="步骤-3：查询根-DNS-服务器"><a href="#步骤-3：查询根-DNS-服务器" class="headerlink" title="步骤 3：查询根 DNS 服务器"></a><strong>步骤 3：查询根 DNS 服务器</strong></h4><ul>
<li>如果递归 DNS 服务器没有缓存该域名的结果，它会向 <strong>根 DNS 服务器</strong> 发送查询请求。根 DNS 服务器并不直接知道域名的 IP 地址，但它知道 <strong>顶级域（TLD）DNS 服务器</strong> 的位置。</li>
<li>例如，查询 <code>www.example.com</code> 时，根服务器会告诉递归 DNS 服务器 <code>.com</code> 的 <strong>TLD DNS 服务器</strong> 的地址。</li>
</ul>
<h4 id="步骤-4：查询-TLD-DNS-服务器"><a href="#步骤-4：查询-TLD-DNS-服务器" class="headerlink" title="步骤 4：查询 TLD DNS 服务器"></a><strong>步骤 4：查询 TLD DNS 服务器</strong></h4><ul>
<li>接着，递归 DNS 服务器会向指定的 <strong>TLD DNS 服务器</strong> 发送查询请求。TLD DNS 服务器负责解析顶级域名的请求，如 <code>.com</code>、<code>.org</code>、<code>.edu</code> 等。</li>
<li>对于 <code>www.example.com</code>，TLD DNS 服务器会告诉递归 DNS 服务器 <strong>example.com</strong> 的 <strong>权威 DNS 服务器</strong> 的地址。</li>
</ul>
<h4 id="步骤-5：查询权威-DNS-服务器"><a href="#步骤-5：查询权威-DNS-服务器" class="headerlink" title="步骤 5：查询权威 DNS 服务器"></a><strong>步骤 5：查询权威 DNS 服务器</strong></h4><ul>
<li>最后，递归 DNS 服务器会向 <strong>权威 DNS 服务器</strong> 发送请求，权威 DNS 服务器是负责存储该域名的最终解析记录的服务器。</li>
<li>权威 DNS 服务器知道 <code>example.com</code> 的准确 IP 地址，并将该地址返回给递归 DNS 服务器。</li>
</ul>
<h4 id="步骤-6：将结果返回给客户端"><a href="#步骤-6：将结果返回给客户端" class="headerlink" title="步骤 6：将结果返回给客户端"></a><strong>步骤 6：将结果返回给客户端</strong></h4><ul>
<li>递归 DNS 服务器将最终解析到的 IP 地址返回给客户端（如用户的计算机）。</li>
<li>客户端得到 IP 地址后，浏览器就可以通过该地址与目标服务器建立连接，开始请求网页内容。</li>
</ul>
</li>
<li><p><strong>缓存和 TTL（Time to Live）</strong></p>
<ul>
<li><strong>TTL</strong> 是 DNS 记录的一个字段，表示该记录在缓存中存活的时间。每个 DNS 查询都会被缓存一定时间，这个时间由服务器配置的 TTL 值决定。TTL 过期后，缓存就会被清除，下一次查询时需要重新执行 DNS 查询过程。</li>
<li>TTL 的目的是减少频繁的 DNS 查询，提高解析效率，减少 DNS 服务器的负担。</li>
</ul>
</li>
</ol>
<p><strong>DNS 解析过程的示意图</strong></p>
<figure class="highlight gherkin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">客户端                  本地 DNS 服务器          根 DNS 服务器       TLD DNS 服务器       权威 DNS 服务器</span><br><span class="line">   |<span class="string">                         </span>|<span class="string">                        </span>|<span class="string">                    </span>|<span class="string">                     </span>|</span><br><span class="line">   |<span class="string">---- 1. 输入域名 --------&gt;</span>|<span class="string">                        </span>|<span class="string">                    </span>|<span class="string">                     </span>|</span><br><span class="line">   |<span class="string">                         </span>|<span class="string">---- 2. 查询根 DNS -----&gt;</span>|<span class="string">                    </span>|<span class="string">                     </span>|</span><br><span class="line">   |<span class="string">                         </span>|<span class="string">                        </span>|<span class="string">---- 3. 查询 TLD ----&gt;</span>|<span class="string">                     </span>|</span><br><span class="line">   |<span class="string">                         </span>|<span class="string">                        </span>|<span class="string">                    </span>|<span class="string">---- 4. 查询权威 DNS  </span>|</span><br><span class="line">   |<span class="string">                         </span>|<span class="string">                        </span>|<span class="string">                    </span>|<span class="string">                     </span>|</span><br><span class="line">   |<span class="string">                         </span>|<span class="string">                        </span>|<span class="string">                    </span>|<span class="string">&lt;---- 5. 返回 IP 地址   </span>|</span><br><span class="line">   |<span class="string">                         </span>|<span class="string">&lt;--- 6. 返回 IP 地址 ----</span>|<span class="string">                    </span>|<span class="string">                     </span>|</span><br><span class="line">   |<span class="string">&lt;----- 7. 浏览器加载网页 -</span>|<span class="string">                        </span>|<span class="string">                    </span>|<span class="string">                     </span>|</span><br></pre></td></tr></table></figure>

<p><strong>DNS 记录类型</strong></p>
<p>DNS 服务器返回的结果不仅仅是 IP 地址，还可以包含多种不同类型的记录，最常见的几种如下：</p>
<ol>
<li><strong>A 记录（Address Record）</strong><ul>
<li>将域名映射到一个 IPv4 地址（例如 <code>www.example.com</code> -&gt; <code>192.0.2.1</code>）。</li>
</ul>
</li>
<li><strong>AAAA 记录</strong><ul>
<li>将域名映射到一个 IPv6 地址（例如 <code>www.example.com</code> -&gt; <code>2001:db8::1</code>）。</li>
</ul>
</li>
<li><strong>CNAME 记录（Canonical Name Record）</strong><ul>
<li>将一个域名别名指向另一个域名（例如 <code>www.example.com</code> -&gt; <code>example.com</code>）。</li>
</ul>
</li>
<li><strong>MX 记录（Mail Exchange Record）</strong><ul>
<li>指定负责接收邮件的邮件服务器（例如 <code>example.com</code> -&gt; <code>mail.example.com</code>）。</li>
</ul>
</li>
<li><strong>NS 记录（Name Server Record）</strong><ul>
<li>指定域名的权威 DNS 服务器（例如 <code>example.com</code> -&gt; <code>ns1.example.com</code>）。</li>
</ul>
</li>
<li><strong>PTR 记录（Pointer Record）</strong><ul>
<li>用于反向 DNS 查询，将 IP 地址映射到域名（例如 <code>192.0.2.1</code> -&gt; <code>www.example.com</code>）。</li>
</ul>
</li>
<li><strong>TXT 记录</strong><ul>
<li>用于存储任意文本信息（例如用于 SPF 记录，验证邮件发送源等）。</li>
</ul>
</li>
<li><strong>SRV 记录</strong><ul>
<li>指定某个服务（如 VoIP、XMPP 等）所使用的服务器地址和端口。</li>
</ul>
</li>
</ol>
<p><strong>DNS 缓存</strong></p>
<ul>
<li><strong>递归 DNS 服务器缓存</strong>：当递归 DNS 服务器从权威 DNS 服务器获取域名解析结果时，通常会将结果缓存一段时间。这样，当其他用户查询相同的域名时，可以直接返回缓存的结果，减少查询时间和 DNS 服务器负担。</li>
<li><strong>本地缓存</strong>：操作系统和浏览器也会缓存 DNS 解析结果，以避免每次访问同一网站时都进行 DNS 查询。</li>
</ul>
<p><strong>DNS 安全性：DNS 污染与 DNSSEC</strong></p>
<ul>
<li><strong>DNS 污染（DNS Spoofing）</strong>：恶意攻击者可能会向 DNS 服务器注入错误的域名解析信息，导致用户访问到错误的 IP 地址。这种攻击可以通过 <strong>DNSSEC（DNS Security Extensions）</strong> 来缓解。DNSSEC 通过数字签名确保返回的 DNS 记录的真实性，防止 DNS 污染。</li>
</ul>
<p><strong>总结</strong></p>
<p>DNS 是一个分布式的数据库系统，它将人类友好的域名转换为计算机能够识别的 IP 地址，并在此过程中提供了缓存和安全措施。DNS 是互联网运作的基础之一，支持了从浏览器到网站服务器之间的高效且可靠的域名解析。</p>
<h4 id="问：TCP拥塞控制？"><a href="#问：TCP拥塞控制？" class="headerlink" title="问：TCP拥塞控制？"></a>问：TCP拥塞控制？</h4><p><strong>TCP 拥塞控制</strong></p>
<p>TCP 拥塞控制是为了解决网络拥塞问题而设计的一组机制，目的是在尽可能高效地利用网络资源的同时，避免因数据流量过大而导致网络性能下降。拥塞控制是 TCP 的核心特性之一，它通过调节发送方的数据发送速率，动态适应网络的实际负载情况，确保数据能够可靠地传输。</p>
<p><strong>TCP 拥塞控制的四个关键算法</strong></p>
<p>TCP 拥塞控制主要包括四个核心算法：<strong>慢启动</strong>、<strong>拥塞避免</strong>、<strong>快速重传</strong> 和 <strong>快速恢复</strong>。</p>
<ol>
<li><strong>慢启动 (Slow Start)</strong></li>
</ol>
<ul>
<li><p><strong>目标</strong>：探测网络的容量，逐步增加发送窗口，避免一开始发送过多数据导致网络拥塞。</p>
</li>
<li><p>机制</p>
<p>：</p>
<ul>
<li>开始时，将拥塞窗口（<code>cwnd</code>，congestion window）设置为一个较小的值（通常为 1 MSS，最大报文段）。</li>
<li>每收到一个 ACK，<code>cwnd</code> 加倍（指数增长）。</li>
<li>当 <code>cwnd</code> 增长到达到慢启动阈值（<code>ssthresh</code>，slow start threshold）时，进入 <strong>拥塞避免</strong> 阶段。</li>
</ul>
</li>
<li><p><strong>问题</strong>：如果网络容量较小，慢启动的指数增长可能会迅速导致网络拥塞。</p>
</li>
</ul>
<ol start="2">
<li><strong>拥塞避免 (Congestion Avoidance)</strong></li>
</ol>
<ul>
<li><p><strong>目标</strong>：在网络接近饱和时，防止发送速率增长过快，从而避免拥塞。</p>
</li>
<li><p>机制</p>
<p>：</p>
<ul>
<li>当 <code>cwnd</code> 达到或超过 <code>ssthresh</code> 时，拥塞窗口的增长从指数增长变为线性增长。</li>
<li>每个 RTT（往返时间）只增加 1 MSS，而不是像慢启动阶段那样成倍增加。</li>
</ul>
</li>
<li><p><strong>优势</strong>：通过逐步增加发送窗口，可以减少网络拥塞的风险。</p>
</li>
</ul>
<ol start="3">
<li><strong>快速重传 (Fast Retransmit)</strong></li>
</ol>
<ul>
<li><p><strong>目标</strong>：在丢包发生时快速恢复数据传输，而无需等待超时。</p>
</li>
<li><p>机制</p>
<p>：</p>
<ul>
<li>如果发送方收到三个重复的 ACK（表明某个数据包未到达接收方），立即重传丢失的数据包，而不是等待超时重传。</li>
</ul>
</li>
<li><p><strong>优势</strong>：加快了丢包的检测和处理速度，减少了等待时间。</p>
</li>
</ul>
<ol start="4">
<li><strong>快速恢复 (Fast Recovery)</strong></li>
</ol>
<ul>
<li><p><strong>目标</strong>：避免因单个丢包导致的过度拥塞窗口减少，提高网络吞吐量。</p>
</li>
<li><p>机制</p>
<p>：</p>
<ul>
<li>收到三个重复的 ACK 后，进入快速恢复阶段：<ul>
<li>将 <code>ssthresh</code> 设置为当前 <code>cwnd</code> 的一半。</li>
<li>将 <code>cwnd</code> 暂时调整为 <code>ssthresh</code> 的值。</li>
<li>恢复正常数据传输。</li>
</ul>
</li>
<li>如果重传的丢失数据包得到确认，直接进入拥塞避免阶段。</li>
</ul>
</li>
<li><p><strong>优势</strong>：避免了将拥塞窗口直接降到 1 MSS，从而更高效地恢复数据传输。</p>
</li>
</ul>
<p><strong>拥塞控制中的重要变量</strong></p>
<ol>
<li><strong>拥塞窗口（<code>cwnd</code>）</strong><ul>
<li>表示发送方在未收到接收方确认前，可以发送的最大数据量。</li>
<li>动态调整，根据网络状态变化。</li>
</ul>
</li>
<li><strong>慢启动阈值（<code>ssthresh</code>）</strong><ul>
<li>表示从慢启动到拥塞避免的切换阈值。</li>
<li>当发生拥塞时，<code>ssthresh</code> 通常被设置为当前 <code>cwnd</code> 的一半。</li>
</ul>
</li>
<li><strong>重复 ACK</strong><ul>
<li>表示接收方收到乱序数据包后重发的确认。</li>
<li>多个重复 ACK 是丢包的信号。</li>
</ul>
</li>
<li><strong>超时重传</strong><ul>
<li>当发送方未能在指定时间内收到 ACK 时，会认为数据包丢失，重新传输。</li>
</ul>
</li>
</ol>
<p><strong>TCP 拥塞控制的状态转换示例</strong></p>
<ol>
<li><strong>连接开始</strong>：<ul>
<li>发送方从慢启动阶段开始，<code>cwnd</code> 从 1 MSS 开始，指数增长直到达到 <code>ssthresh</code>。</li>
</ul>
</li>
<li><strong>网络拥塞发生（超时或丢包）</strong>：<ul>
<li><code>ssthresh</code> 被设置为当前 <code>cwnd</code> 的一半。</li>
<li><code>cwnd</code> 被重置为 1 MSS，重新进入慢启动阶段。</li>
</ul>
</li>
<li><strong>丢包检测（通过重复 ACK）</strong>：<ul>
<li>进入快速重传和快速恢复阶段，<code>ssthresh</code> 减半，<code>cwnd</code> 被调整为 <code>ssthresh</code>。</li>
</ul>
</li>
<li><strong>数据传输恢复</strong>：<ul>
<li>进入拥塞避免阶段，<code>cwnd</code> 线性增长。</li>
</ul>
</li>
</ol>
<p><strong>TCP 拥塞控制的关键特性</strong></p>
<ol>
<li><strong>可靠性</strong>：通过慢启动、拥塞避免、快速重传等机制，确保丢包和网络拥塞情况下的数据可靠传输。</li>
<li><strong>动态性</strong>：通过动态调整 <code>cwnd</code>，适应不同网络负载和带宽条件。</li>
<li><strong>公平性</strong>：多个 TCP 流共享带宽时，拥塞控制机制尽可能公平地分配资源。</li>
<li><strong>响应性</strong>：能够快速响应网络拥塞或丢包，调整发送速率，减少网络压力。</li>
</ol>
<p><strong>TCP 拥塞控制与现代改进</strong></p>
<ol>
<li><strong>经典 TCP 拥塞控制算法</strong><ul>
<li>Reno：增加了快速重传和快速恢复机制。</li>
<li>Tahoe：只有慢启动和拥塞避免机制。</li>
<li>New Reno：改进了 Reno 的快速恢复过程。</li>
</ul>
</li>
<li><strong>现代 TCP 拥塞控制算法</strong><ul>
<li>CUBIC：适用于高带宽高延迟网络。</li>
<li>BBR（Bottleneck Bandwidth and RTT）：通过实时测量瓶颈带宽和往返时间来决定发送速率，突破了传统 TCP 的窗口限制。</li>
</ul>
</li>
</ol>
<p><strong>总结</strong></p>
<p>TCP 拥塞控制通过一系列机制（慢启动、拥塞避免、快速重传和快速恢复）动态适应网络负载，确保数据可靠传输，并避免网络拥塞对通信效率的影响。现代改进算法在提高吞吐量和响应速度方面进一步优化，为各种复杂网络环境提供了更高效的解决方案。</p>
<hr>
<h2 id="三-HTTP"><a href="#三-HTTP" class="headerlink" title="三. HTTP"></a>三. HTTP</h2><h4 id="问：简单谈谈对HTTP的了解？"><a href="#问：简单谈谈对HTTP的了解？" class="headerlink" title="问：简单谈谈对HTTP的了解？"></a>问：简单谈谈对HTTP的了解？</h4><p><strong>HTTP 的基本概念</strong></p>
<p>HTTP（HyperText Transfer Protocol，超文本传输协议）是用于在客户端（浏览器）和服务器之间传输数据的应用层协议。它是万维网的基础，主要用于传输 HTML 文档、图片、视频等各种资源。</p>
<p><strong>HTTP 的特点</strong></p>
<ol>
<li><strong>无状态</strong><ul>
<li>HTTP 是无状态协议，每次请求都是独立的，服务器不会自动保留前一次请求的信息。</li>
<li>可以通过 <strong>Cookie</strong>、<strong>Session</strong> 等机制实现状态管理。</li>
</ul>
</li>
<li><strong>简单灵活</strong><ul>
<li>HTTP 协议简单易懂，传输的内容可以是文本、图片、音频、视频等，扩展性强。</li>
</ul>
</li>
<li><strong>基于请求-响应模型</strong><ul>
<li>每次通信由客户端发起请求，服务器响应后结束。</li>
</ul>
</li>
<li><strong>明文传输</strong><ul>
<li>HTTP 数据默认不加密，通信内容容易被窃听或篡改。</li>
</ul>
</li>
<li><strong>可扩展性</strong><ul>
<li>支持多种方法（GET、POST 等），以及通过头部字段扩展功能。</li>
</ul>
</li>
</ol>
<p><strong>HTTP 的主要组成部分</strong></p>
<ol>
<li><strong>请求</strong><ul>
<li><strong>方法</strong>：指示服务器要执行的动作（如 GET、POST、PUT、DELETE 等）。</li>
<li><strong>URL</strong>：指定要访问的资源。</li>
<li><strong>头部（Header）</strong>：附加信息（如身份认证、数据格式、缓存控制）。</li>
<li><strong>请求体（Body）</strong>：可选，用于传输数据（如表单数据）。</li>
</ul>
</li>
<li><strong>响应</strong><ul>
<li><strong>状态码</strong>：服务器返回的处理结果（如 200 成功、404 未找到、500 服务器错误）。</li>
<li><strong>头部（Header）</strong>：附加信息（如内容类型、长度）。</li>
<li><strong>响应体（Body）</strong>：实际返回的内容（如 HTML、JSON 数据等）。</li>
</ul>
</li>
</ol>
<p><strong>HTTP 的版本</strong></p>
<ol>
<li><strong>HTTP/0.9</strong><ul>
<li>最早的版本，只支持 GET 请求和简单的文本传输。</li>
</ul>
</li>
<li><strong>HTTP/1.0</strong><ul>
<li>引入了请求头和响应头，支持多种媒体类型。</li>
<li>每次请求需要重新建立连接。</li>
</ul>
</li>
<li><strong>HTTP/1.1</strong>（最广泛使用）<ul>
<li>支持 <strong>长连接</strong>（Connection: keep-alive）。</li>
<li>引入了分块传输编码（Chunked Transfer Encoding）。</li>
<li>支持更多请求方法（如 OPTIONS、PUT 等）。</li>
<li>增强了缓存控制和错误处理机制。</li>
</ul>
</li>
<li><strong>HTTP/2</strong><ul>
<li>引入 <strong>二进制传输</strong>，取代文本传输，性能更高。</li>
<li>支持 <strong>多路复用</strong>，同一连接中可同时发送多个请求。</li>
<li>支持服务器推送（Server Push），主动向客户端发送资源。</li>
<li>压缩了头部，减少冗余。</li>
</ul>
</li>
<li><strong>HTTP/3</strong>（基于 QUIC 协议）<ul>
<li>使用 UDP 传输，提高了传输速度和可靠性。</li>
<li>内置 TLS 加密，默认加密传输。</li>
<li>进一步优化了多路复用和连接复用。</li>
</ul>
</li>
</ol>
<p><strong>常见的 HTTP 方法</strong></p>
<ol>
<li><strong>GET</strong>：获取资源，常用于获取网页数据。</li>
<li><strong>POST</strong>：提交数据给服务器（如表单提交）。</li>
<li><strong>PUT</strong>：更新或创建资源。</li>
<li><strong>DELETE</strong>：删除指定资源。</li>
<li><strong>HEAD</strong>：获取资源的头部信息，不返回主体。</li>
<li><strong>OPTIONS</strong>：获取服务器支持的请求方法。</li>
<li><strong>PATCH</strong>：部分更新资源。</li>
</ol>
<p><strong>HTTP 的缺点和改进</strong></p>
<ol>
<li><strong>缺点</strong><ul>
<li>无状态：无法直接记录会话。</li>
<li>明文传输：不安全，容易被窃听和篡改。</li>
<li>延迟高：HTTP/1.x 每次请求需等待上一个请求完成。</li>
<li>头部冗余：HTTP/1.x 的头部字段较多且重复。</li>
</ul>
</li>
<li><strong>改进</strong><ul>
<li>使用 HTTPS：通过 SSL/TLS 加密通信，保证安全性。</li>
<li>升级到 HTTP/2 或 HTTP/3：减少延迟，提高传输效率。</li>
<li>状态管理：通过 Cookie、Session、JWT 等机制实现状态跟踪。</li>
</ul>
</li>
</ol>
<p><strong>HTTP 在实际应用中的重要性</strong></p>
<ol>
<li><strong>网页访问</strong>：浏览器与服务器之间的通信基础。</li>
<li><strong>API 接口</strong>：RESTful API 通常使用 HTTP 协议作为数据传输的媒介。</li>
<li><strong>CDN</strong>：内容分发网络通过 HTTP 协议将资源分发到全球节点。</li>
<li><strong>负载均衡</strong>：HTTP 协议是负载均衡和反向代理的核心基础。</li>
</ol>
<p><strong>总结</strong></p>
<p>HTTP 是互联网通信的基础协议，尽管其最初版本有诸多不足，但通过升级（HTTP/2、HTTP/3）和结合 HTTPS，它在性能、安全性和扩展性方面得到了极大提升，广泛应用于各种网络场景。</p>
<h4 id="问：HTTPS和HTTP的区别？"><a href="#问：HTTPS和HTTP的区别？" class="headerlink" title="问：HTTPS和HTTP的区别？"></a>问：HTTPS和HTTP的区别？</h4><ol>
<li><strong>HTTP (HyperText Transfer Protocol)</strong></li>
</ol>
<p>HTTP 是一种应用层协议，主要用于客户端（如浏览器）和服务器之间的通信。它是一种无状态、无连接的协议，用于在互联网上请求和传输超文本数据。HTTP 协议本身没有加密功能，通信过程中的数据是明文传输的，容易受到各种攻击。</p>
<p>特点：</p>
<ul>
<li><strong>无状态性</strong>：每次请求都是独立的，与之前的请求没有任何联系。</li>
<li><strong>无连接性</strong>：每次请求和响应完成后，连接会关闭，不会保持长时间连接。</li>
<li><strong>简单和灵活</strong>：HTTP 支持多种请求方法，如 GET、POST、PUT、DELETE 等，能适应各种不同类型的请求。</li>
<li><strong>端口</strong>：默认使用 80 端口。</li>
</ul>
<p>优缺点：</p>
<ul>
<li><p>优点：</p>
<ul>
<li>实现简单，广泛应用于Web服务。</li>
<li>支持多种媒体类型（HTML、图片、视频等）和请求方式。</li>
</ul>
</li>
<li><p>缺点：</p>
<ul>
<li>没有安全性，数据明文传输，容易遭受中间人攻击（如窃听、篡改）。</li>
</ul>
</li>
<li><p>无法提供身份验证，无法确认服务器的真实性。</p>
</li>
</ul>
<ol start="2">
<li><strong>HTTPS (HyperText Transfer Protocol Secure)</strong></li>
</ol>
<p>HTTPS 是 HTTP 协议的安全版本，它通过 SSL/TLS 协议在 HTTP 层之上增加了一层加密保护。这样，HTTPS 能够保障数据在传输过程中不会被窃取或篡改，并且能够验证服务器的身份。</p>
<p>特点：</p>
<ul>
<li><strong>加密</strong>：使用 SSL/TLS 对数据进行加密，保证数据的机密性。</li>
<li><strong>完整性</strong>：通过数据的哈希校验和签名，保证数据在传输过程中不被篡改。</li>
<li><strong>身份验证</strong>：通过 SSL/TLS 证书，客户端可以验证服务器的身份，防止假冒网站。</li>
<li><strong>端口</strong>：默认使用 443 端口。</li>
</ul>
<p>优缺点：</p>
<ul>
<li><p>优点：</p>
<ul>
<li>提供加密保护，防止数据泄露。</li>
<li>提供数据完整性，防止数据篡改。</li>
<li>提供身份验证，防止伪造服务器。</li>
<li>适用于需要传输敏感信息的场景，如在线支付、登录认证等。</li>
</ul>
</li>
<li><p>缺点：</p>
<ul>
<li>相比 HTTP，多了加密和解密的过程，稍微影响性能。</li>
</ul>
</li>
<li><p>配置 SSL/TLS 证书和管理成本较高。</p>
</li>
</ul>
<p><strong>HTTP 与 HTTPS 的对比总结：</strong></p>
<table>
<thead>
<tr>
<th>特性</th>
<th>HTTP</th>
<th>HTTPS</th>
</tr>
</thead>
<tbody><tr>
<td><strong>安全性</strong></td>
<td>不加密，数据明文传输</td>
<td>加密传输，防止中间人攻击</td>
</tr>
<tr>
<td><strong>使用的端口</strong></td>
<td>80</td>
<td>443</td>
</tr>
<tr>
<td><strong>加密机制</strong></td>
<td>无加密</td>
<td>使用 SSL/TLS 加密</td>
</tr>
<tr>
<td><strong>数据完整性</strong></td>
<td>无保护，容易篡改</td>
<td>使用哈希校验，防篡改</td>
</tr>
<tr>
<td><strong>身份验证</strong></td>
<td>无法验证服务器身份</td>
<td>通过 SSL 证书验证服务器身份</td>
</tr>
<tr>
<td><strong>性能</strong></td>
<td>较快</td>
<td>稍慢（因加密解密过程）</td>
</tr>
<tr>
<td><strong>应用场景</strong></td>
<td>公开信息，非敏感数据传输</td>
<td>需要保密或验证身份的数据传输</td>
</tr>
</tbody></table>
<p><strong>HTTPS 的工作原理：</strong></p>
<p>HTTPS 的工作过程包括三个主要步骤：</p>
<ol>
<li><strong>客户端发起连接请求</strong>：客户端向服务器发起 HTTPS 请求（如输入 <a target="_blank" rel="noopener" href="https://www.example.com)./">https://www.example.com）。</a></li>
<li><strong>SSL/TLS 握手</strong>：客户端与服务器通过 SSL/TLS 协议进行握手，协商加密算法并交换密钥。</li>
<li><strong>数据传输</strong>：双方通过对称加密传输数据，确保数据在传输过程中被加密且完整。</li>
</ol>
<p><strong>SSL/TLS 的角色：</strong></p>
<ul>
<li>**SSL (Secure Sockets Layer)**：早期的加密协议，现在已经被认为不再安全。</li>
<li>**TLS (Transport Layer Security)**：SSL 的继任者，提供更强的加密和安全性。现在使用的 HTTPS 协议通常使用的是 TLS。</li>
</ul>
<p>总的来说，HTTPS 是对 HTTP 的一个安全增强版，主要通过加密传输和身份验证来确保通信安全，是现代互联网应用中处理敏感信息的标准。</p>
<p>HTTPS（HyperText Transfer Protocol Secure）和HTTP（HyperText Transfer Protocol）的区别如下：</p>
<ol>
<li><strong>加密：</strong><ul>
<li><strong>HTTP</strong>：传输的数据是明文的，不加密，容易被中间人攻击，数据可能会被窃取或篡改。</li>
<li><strong>HTTPS</strong>：通过SSL/TLS协议加密数据，确保数据的保密性和完整性，防止中间人攻击。</li>
</ul>
</li>
<li><strong>端口：</strong><ul>
<li><strong>HTTP</strong>：默认使用端口80。</li>
<li><strong>HTTPS</strong>：默认使用端口443。</li>
</ul>
</li>
<li><strong>安全性：</strong><ul>
<li><strong>HTTP</strong>：不提供任何安全保护，容易受到各种攻击，如窃听和篡改。</li>
<li><strong>HTTPS</strong>：提供了加密、身份验证和数据完整性保护，安全性较高。</li>
</ul>
</li>
<li><strong>协议：</strong><ul>
<li><strong>HTTP</strong>：基于TCP/IP协议，但没有加密层。</li>
<li><strong>HTTPS</strong>：在HTTP协议基础上增加了SSL/TLS协议层，通过该层提供加密和安全验证。</li>
</ul>
</li>
<li><strong>证书：</strong><ul>
<li><strong>HTTP</strong>：没有证书，通信双方的身份无法验证。</li>
<li><strong>HTTPS</strong>：需要使用SSL证书，证书由受信任的证书颁发机构（CA）颁发，用于验证服务器身份。</li>
</ul>
</li>
<li><strong>性能：</strong><ul>
<li><strong>HTTP</strong>：由于没有加密过程，性能相对较快。</li>
<li><strong>HTTPS</strong>：由于加密和解密的过程，性能稍慢一些，但现代硬件和优化算法能最大程度地减少影响。</li>
</ul>
</li>
</ol>
<p>总结：HTTPS是在HTTP的基础上增加了加密层、身份验证和数据完整性保护，更加安全，适合传输敏感信息（如登录凭证、支付信息等）。</p>
<h4 id="问：说一下post和put的数据是放在哪个字段？"><a href="#问：说一下post和put的数据是放在哪个字段？" class="headerlink" title="问：说一下post和put的数据是放在哪个字段？"></a>问：说一下post和put的数据是放在哪个字段？</h4><p>在 <strong>HTTP</strong> 协议中，<strong>POST</strong> 和 <strong>PUT</strong> 方法通常用于向服务器发送数据。它们传递的数据位置如下：</p>
<p><strong>POST 和 PUT 数据存放的位置</strong></p>
<p><strong>数据放在请求体（Request Body）中</strong></p>
<ul>
<li><strong>POST</strong> 和 <strong>PUT</strong> 方法的主要区别不在于数据的位置，而在于语义上的不同。</li>
<li>数据通常通过 <strong>Request Body（请求体）</strong> 发送到服务器。</li>
</ul>
<p><strong>请求格式</strong></p>
<p><strong>POST 示例</strong></p>
<p>POST 方法通常用于提交数据，例如表单数据、文件上传等。</p>
<figure class="highlight http"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">POST</span> <span class="string">/api/users</span> <span class="meta">HTTP/1.1</span></span><br><span class="line"><span class="attribute">Host</span><span class="punctuation">: </span>example.com</span><br><span class="line"><span class="attribute">Content-Type</span><span class="punctuation">: </span>application/json</span><br><span class="line"><span class="attribute">Content-Length</span><span class="punctuation">: </span>33</span><br><span class="line"></span><br><span class="line"><span class="json">&#123;</span></span><br><span class="line"><span class="json">  <span class="attr">&quot;name&quot;</span>: <span class="string">&quot;Alice&quot;</span>,</span></span><br><span class="line"><span class="json">  <span class="attr">&quot;age&quot;</span>: <span class="number">25</span></span></span><br><span class="line"><span class="json">&#125;</span></span><br></pre></td></tr></table></figure>

<ul>
<li><strong>URL</strong>：<code>/api/users</code></li>
<li><strong>数据</strong>：放在请求体中，格式可以是 JSON、XML、表单数据（<code>application/x-www-form-urlencoded</code> 或 <code>multipart/form-data</code>）。</li>
</ul>
<p><strong>PUT 示例</strong></p>
<p>PUT 方法通常用于更新或替换资源，或创建资源（如果资源不存在）。</p>
<figure class="highlight http"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">PUT</span> <span class="string">/api/users/123</span> <span class="meta">HTTP/1.1</span></span><br><span class="line"><span class="attribute">Host</span><span class="punctuation">: </span>example.com</span><br><span class="line"><span class="attribute">Content-Type</span><span class="punctuation">: </span>application/json</span><br><span class="line"><span class="attribute">Content-Length</span><span class="punctuation">: </span>33</span><br><span class="line"></span><br><span class="line"><span class="json">&#123;</span></span><br><span class="line"><span class="json">  <span class="attr">&quot;name&quot;</span>: <span class="string">&quot;Alice&quot;</span>,</span></span><br><span class="line"><span class="json">  <span class="attr">&quot;age&quot;</span>: <span class="number">30</span></span></span><br><span class="line"><span class="json">&#125;</span></span><br></pre></td></tr></table></figure>

<ul>
<li><strong>URL</strong>：<code>/api/users/123</code>（通常指定目标资源的标识符）。</li>
<li><strong>数据</strong>：同样放在请求体中，格式可以是 JSON、XML 等。</li>
</ul>
<p><strong>POST 和 PUT 的数据传输方式</strong></p>
<ol>
<li><p><strong>常见数据格式</strong></p>
<ul>
<li><p><strong>JSON</strong>：<code>Content-Type: application/json</code></p>
</li>
<li><p><strong>XML</strong>：<code>Content-Type: application/xml</code></p>
</li>
<li><p>表单数据：</p>
<ul>
<li>URL 编码的键值对：<code>Content-Type: application/x-www-form-urlencoded</code></li>
</ul>
</li>
<li><p>文件上传：<code>Content-Type: multipart/form-data</code></p>
</li>
</ul>
</li>
<li><p><strong>请求体的长度</strong></p>
<ul>
<li>使用 <code>Content-Length</code> 标头指定请求体的字节长度。</li>
<li>或使用分块传输编码（<code>Transfer-Encoding: chunked</code>）处理动态数据。</li>
</ul>
</li>
</ol>
<p><strong>总结</strong></p>
<ul>
<li><strong>POST</strong> 和 <strong>PUT</strong> 的数据都存放在 <strong>请求体（Request Body）</strong> 中。</li>
<li>区别在于使用场景：<ul>
<li><strong>POST</strong>：用于创建资源或提交数据（通常是非幂等的操作）。</li>
<li><strong>PUT</strong>：用于更新或替换资源（通常是幂等的操作）。</li>
</ul>
</li>
</ul>
<h4 id="问：HTTP状态码含义：503，504，505，403，200？"><a href="#问：HTTP状态码含义：503，504，505，403，200？" class="headerlink" title="问：HTTP状态码含义：503，504，505，403，200？"></a>问：HTTP状态码含义：503，504，505，403，200？</h4><p><strong>HTTP 状态码及其含义</strong></p>
<p>HTTP 状态码是服务器在响应 HTTP 请求时返回的代码，用于表明请求的处理结果。这些状态码分为 5 大类，其中每个代码的含义如下：</p>
<p><strong>常见状态码解析</strong></p>
<p><strong>1. 503 - Service Unavailable（服务不可用）</strong></p>
<ul>
<li><p><strong>含义</strong>：服务器当前无法处理请求。</p>
</li>
<li><p>原因：</p>
<ul>
<li>服务器过载。</li>
<li>正在进行维护或升级。</li>
</ul>
</li>
<li><p><strong>特点</strong>：通常是临时性的，服务器可能会通过响应头 <code>Retry-After</code> 告知客户端稍后重试。</p>
</li>
</ul>
<p><strong>2. 504 - Gateway Timeout（网关超时）</strong></p>
<ul>
<li><p><strong>含义</strong>：作为网关或代理的服务器未能在规定时间内从上游服务器收到响应。</p>
</li>
<li><p>原因：</p>
<ul>
<li>上游服务器未响应。</li>
<li>网络延迟或超时。</li>
</ul>
</li>
<li><p>解决：</p>
<ul>
<li>检查上游服务的运行状态。</li>
</ul>
</li>
<li><p>优化网络环境或调整超时时间。</p>
</li>
</ul>
<p><strong>3. 505 - HTTP Version Not Supported（HTTP 版本不支持）</strong></p>
<ul>
<li><p><strong>含义</strong>：服务器不支持客户端使用的 HTTP 协议版本。</p>
</li>
<li><p>原因：</p>
<ul>
<li>客户端请求的 HTTP 版本（如 HTTP/2）不兼容。</li>
<li>服务器配置不支持该版本。</li>
</ul>
</li>
<li><p>解决：</p>
<ul>
<li>使用支持的 HTTP 版本（通常是 HTTP/1.1 或 HTTP/2）。</li>
</ul>
</li>
</ul>
<p><strong>4. 403 - Forbidden（禁止访问）</strong></p>
<ul>
<li><p><strong>含义</strong>：服务器理解请求，但拒绝执行操作。</p>
</li>
<li><p>原因：</p>
<ul>
<li>客户端没有权限访问目标资源。</li>
<li>请求未通过身份验证或权限验证。</li>
</ul>
</li>
<li><p>解决：</p>
<ul>
<li>检查用户权限。</li>
</ul>
</li>
<li><p>确保正确配置访问控制规则（如 ACL、身份验证）。</p>
</li>
</ul>
<p><strong>5. 200 - OK（请求成功）</strong></p>
<ul>
<li><p><strong>含义</strong>：服务器成功处理了请求。</p>
</li>
<li><p>特点：</p>
<ul>
<li>是最常见的状态码。</li>
</ul>
</li>
<li><p>响应体中包含请求的内容（如网页、JSON 数据等）。</p>
</li>
</ul>
<p><strong>状态码总结</strong></p>
<table>
<thead>
<tr>
<th><strong>状态码</strong></th>
<th><strong>类别</strong></th>
<th><strong>含义</strong></th>
</tr>
</thead>
<tbody><tr>
<td>503</td>
<td>5xx（服务器错误）</td>
<td>服务暂时不可用，建议稍后重试。</td>
</tr>
<tr>
<td>504</td>
<td>5xx（服务器错误）</td>
<td>网关超时，网关或代理未能及时接收到上游服务器的响应。</td>
</tr>
<tr>
<td>505</td>
<td>5xx（服务器错误）</td>
<td>HTTP 版本不受支持，客户端使用了服务器不支持的协议版本。</td>
</tr>
<tr>
<td>403</td>
<td>4xx（客户端错误）</td>
<td>请求被服务器拒绝，通常是权限问题。</td>
</tr>
<tr>
<td>200</td>
<td>2xx（成功）</td>
<td>请求成功，服务器返回请求的资源。</td>
</tr>
</tbody></table>
<p>每个状态码代表一个特定的含义，有助于诊断和解决客户端和服务器之间的通信问题。</p>
<h4 id="问：GET和POST区别？"><a href="#问：GET和POST区别？" class="headerlink" title="问：GET和POST区别？"></a>问：GET和POST区别？</h4><p><strong>GET 和 POST 的主要区别</strong></p>
<p>GET 和 POST 是 HTTP 协议中最常用的两种请求方法，用于在客户端和服务器之间进行数据通信。它们的主要区别如下：</p>
<p><strong>1. 功能与用途</strong></p>
<table>
<thead>
<tr>
<th><strong>GET</strong></th>
<th><strong>POST</strong></th>
</tr>
</thead>
<tbody><tr>
<td>用于从服务器获取资源或数据。</td>
<td>用于向服务器发送数据，通常用于提交表单或上传数据。</td>
</tr>
<tr>
<td>示例：浏览器访问网页。</td>
<td>示例：用户提交登录表单或上传文件。</td>
</tr>
</tbody></table>
<p><strong>2. 请求参数的传递方式</strong></p>
<table>
<thead>
<tr>
<th><strong>GET</strong></th>
<th><strong>POST</strong></th>
</tr>
</thead>
<tbody><tr>
<td>参数通过 <strong>URL 查询字符串</strong> 传递（如 <code>?key=value</code>）。</td>
<td>参数存放在 <strong>请求体（Request Body）</strong> 中，不直接显示在 URL 中。</td>
</tr>
<tr>
<td>URL 示例：<code>https://example.com/api?name=Alice&amp;age=25</code></td>
<td>请求体示例：<code>&#123; &quot;name&quot;: &quot;Alice&quot;, &quot;age&quot;: 25 &#125;</code></td>
</tr>
<tr>
<td><strong>不适合传输敏感信息</strong>，因为参数暴露在 URL 中。</td>
<td>更适合传输敏感信息，参数不会直接暴露。</td>
</tr>
</tbody></table>
<p><strong>3. 数据长度限制</strong></p>
<table>
<thead>
<tr>
<th><strong>GET</strong></th>
<th><strong>POST</strong></th>
</tr>
</thead>
<tbody><tr>
<td>受 URL 长度限制（一般约为 2048 字符，视浏览器和服务器而定）。</td>
<td>无明显限制，可发送较大数据（取决于服务器配置）。</td>
</tr>
</tbody></table>
<p><strong>4. 缓存</strong></p>
<table>
<thead>
<tr>
<th><strong>GET</strong></th>
<th><strong>POST</strong></th>
</tr>
</thead>
<tbody><tr>
<td>浏览器会缓存 GET 请求，因此可能会返回缓存结果。</td>
<td>POST 请求默认不被缓存。</td>
</tr>
<tr>
<td>适合用于获取静态资源，如图片或文档。</td>
<td>不适合缓存的动态数据操作，如用户提交表单。</td>
</tr>
</tbody></table>
<p><strong>5. 幂等性</strong></p>
<table>
<thead>
<tr>
<th><strong>GET</strong></th>
<th><strong>POST</strong></th>
</tr>
</thead>
<tbody><tr>
<td>幂等：多次发送 GET 请求不会改变服务器状态。</td>
<td>非幂等：多次发送 POST 请求可能重复创建资源或导致副作用。</td>
</tr>
</tbody></table>
<p><strong>6. 安全性</strong></p>
<table>
<thead>
<tr>
<th><strong>GET</strong></th>
<th><strong>POST</strong></th>
</tr>
</thead>
<tbody><tr>
<td><strong>不安全</strong>，参数暴露在 URL 中，可能被记录或泄露。</td>
<td><strong>相对安全</strong>，但仍需要配合 HTTPS 加密传输。</td>
</tr>
</tbody></table>
<p><strong>7. 使用场景</strong></p>
<table>
<thead>
<tr>
<th><strong>GET</strong></th>
<th><strong>POST</strong></th>
</tr>
</thead>
<tbody><tr>
<td>获取数据，如页面内容、图片、文件等。</td>
<td>提交表单、上传文件、发送 JSON 数据等。</td>
</tr>
<tr>
<td>不需要对服务器进行修改操作。</td>
<td>需要向服务器发送数据并执行创建或修改操作。</td>
</tr>
</tbody></table>
<p><strong>总结</strong></p>
<ul>
<li><strong>GET</strong>：用于从服务器获取数据，参数通过 URL 传递，适合无副作用的请求（如查询数据）。</li>
<li><strong>POST</strong>：用于向服务器发送数据或进行修改操作，参数放在请求体中，适合敏感信息传递和数据上传。</li>
</ul>
<p>选择 <strong>GET</strong> 或 <strong>POST</strong> 应根据实际需求和业务场景来决定。</p>
<h4 id="问：知道HTTP1-0和1-1的区别么？"><a href="#问：知道HTTP1-0和1-1的区别么？" class="headerlink" title="问：知道HTTP1.0和1.1的区别么？"></a>问：知道HTTP1.0和1.1的区别么？</h4><p><strong>HTTP/1.0 与 HTTP/1.1 的区别</strong></p>
<p>HTTP/1.1 是 HTTP/1.0 的改进版本，引入了许多新特性和优化措施，解决了 HTTP/1.0 的不足，提升了性能、可靠性和扩展性。</p>
<p><strong>1. 持久连接（Persistent Connection）</strong></p>
<ul>
<li><strong>HTTP/1.0</strong><ul>
<li>每次请求都需要新建一个 TCP 连接，响应完成后立即断开连接。</li>
<li>这种方式导致大量的连接建立和拆除，增加了网络负担。</li>
</ul>
</li>
<li><strong>HTTP/1.1</strong><ul>
<li>默认启用了 <strong>持久连接</strong>（Persistent Connection），即在 <code>Connection: keep-alive</code> 的情况下，TCP 连接可以被复用，减少了连接建立和断开的开销。</li>
<li>同一个连接上可以传输多个请求和响应，提高了性能。</li>
</ul>
</li>
</ul>
<p><strong>2. 分块传输编码（Chunked Transfer Encoding）</strong></p>
<ul>
<li><strong>HTTP/1.0</strong><ul>
<li>在响应数据前，必须知道内容的完整长度，并通过 <code>Content-Length</code> 标头指定。</li>
<li>如果内容是动态生成的，可能无法提前确定长度。</li>
</ul>
</li>
<li><strong>HTTP/1.1</strong><ul>
<li>引入了 <strong>分块传输编码</strong>，允许服务器将数据分块传输，每个块都有自己的长度标识。</li>
<li>支持动态内容的传输，不需要提前知道总长度。</li>
</ul>
</li>
</ul>
<p><strong>3. 请求管道化（Pipelining）</strong></p>
<ul>
<li><strong>HTTP/1.0</strong><ul>
<li>不支持请求管道化，每次只能等待上一个请求完成后再发送下一个。</li>
</ul>
</li>
<li><strong>HTTP/1.1</strong><ul>
<li>支持 <strong>请求管道化</strong>，客户端可以在同一个连接中同时发送多个请求，而不必等待前一个请求完成（虽然服务器的响应仍是按顺序返回）。</li>
</ul>
</li>
</ul>
<p><strong>4. 缓存控制</strong></p>
<ul>
<li><strong>HTTP/1.0</strong><ul>
<li>缓存机制较为简单，依赖于 <code>Expires</code> 头来控制资源的过期时间。</li>
</ul>
</li>
<li><strong>HTTP/1.1</strong><ul>
<li>引入了更多缓存控制的头部字段，例如 <code>Cache-Control</code>，可以更细粒度地控制缓存行为（如 <code>max-age</code>、<code>no-cache</code> 等）。</li>
</ul>
</li>
</ul>
<p><strong>5. 带宽优化与错误处理</strong></p>
<ul>
<li><strong>HTTP/1.0</strong><ul>
<li>不支持内容压缩，导致带宽利用率较低。</li>
<li>错误状态处理较为简单。</li>
</ul>
</li>
<li><strong>HTTP/1.1</strong><ul>
<li>支持 <code>Range</code> 请求，可以请求部分资源（断点续传）。</li>
<li>增强了错误处理机制，例如更多的状态码（如 409 冲突，414 URI 太长）。</li>
<li>支持内容压缩（如 GZIP），优化了带宽使用。</li>
</ul>
</li>
</ul>
<p><strong>6. 更多的 HTTP 方法</strong></p>
<ul>
<li><strong>HTTP/1.0</strong><ul>
<li>仅支持 GET、POST、HEAD 方法。</li>
</ul>
</li>
<li><strong>HTTP/1.1</strong><ul>
<li>增加了更多方法，例如：<ul>
<li><strong>PUT</strong>：用于更新资源。</li>
<li><strong>DELETE</strong>：用于删除资源。</li>
<li><strong>OPTIONS</strong>：获取服务器支持的请求方法。</li>
<li><strong>TRACE</strong>：追踪请求路径。</li>
</ul>
</li>
</ul>
</li>
</ul>
<p><strong>7. 虚拟主机支持</strong></p>
<ul>
<li><strong>HTTP/1.0</strong><ul>
<li>不支持虚拟主机，无法通过同一个 IP 地址区分不同域名的请求。</li>
</ul>
</li>
<li><strong>HTTP/1.1</strong><ul>
<li>引入了 <code>Host</code> 头部字段，使得同一 IP 上可以托管多个域名的服务。</li>
</ul>
</li>
</ul>
<p><strong>8. 安全性与扩展性</strong></p>
<ul>
<li><strong>HTTP/1.0</strong><ul>
<li>安全性较低，没有对请求和响应的严格定义。</li>
<li>扩展能力有限。</li>
</ul>
</li>
<li><strong>HTTP/1.1</strong><ul>
<li>改进了错误状态码和头部字段解析的严格性。</li>
<li>支持更多扩展头部字段，便于协议扩展。</li>
</ul>
</li>
</ul>
<p><strong>总结</strong></p>
<table>
<thead>
<tr>
<th><strong>功能</strong></th>
<th><strong>HTTP/1.0</strong></th>
<th><strong>HTTP/1.1</strong></th>
</tr>
</thead>
<tbody><tr>
<td><strong>连接</strong></td>
<td>每次请求建立新连接</td>
<td>默认支持持久连接（Keep-Alive）</td>
</tr>
<tr>
<td><strong>传输</strong></td>
<td>必须知道内容长度</td>
<td>支持分块传输编码</td>
</tr>
<tr>
<td><strong>请求并发</strong></td>
<td>不支持请求管道化</td>
<td>支持请求管道化</td>
</tr>
<tr>
<td><strong>缓存机制</strong></td>
<td>简单缓存控制</td>
<td>增强缓存控制</td>
</tr>
<tr>
<td><strong>支持方法</strong></td>
<td>GET、POST、HEAD</td>
<td>增加 PUT、DELETE 等方法</td>
</tr>
<tr>
<td><strong>虚拟主机</strong></td>
<td>不支持</td>
<td>支持，通过 Host 头区分</td>
</tr>
<tr>
<td><strong>内容压缩与范围请求</strong></td>
<td>不支持</td>
<td>支持（如 GZIP、Range 请求）</td>
</tr>
</tbody></table>
<p>HTTP/1.1 解决了 HTTP/1.0 的许多性能和功能限制，是目前最广泛使用的 HTTP 协议版本。</p>
<h4 id="问：谈谈什么是HTTP的长连接和短连接？"><a href="#问：谈谈什么是HTTP的长连接和短连接？" class="headerlink" title="问：谈谈什么是HTTP的长连接和短连接？"></a>问：谈谈什么是HTTP的长连接和短连接？</h4><p>HTTP的长连接和短连接本质上是TCP长连接和短连接。HTTP属于应用层协议，在传输层使用TCP协议，在网络层使用IP协议。IP协议主要解决网络路由和寻址问题，TCP协议主要解决如何在IP层之上可靠的传递数据包，使在网络上的另一端收到发端发出的所有包，并且顺序与发出顺序一致。TCP有可靠，面向连接的特点。</p>
<p><strong>HTTP 长连接与短连接的区别</strong></p>
<p>HTTP 协议基于 TCP 协议，而 TCP 的连接管理方式直接影响 HTTP 请求的长连接与短连接的行为。两者的主要区别在于是否保持 TCP 连接。</p>
<p><strong>1. 短连接</strong></p>
<ul>
<li><p><strong>定义</strong>：每次请求/响应后，客户端与服务器都会关闭 TCP 连接。</p>
</li>
<li><p>过程：</p>
<ol>
<li>客户端发起请求，与服务器建立 TCP 连接。</li>
<li>服务器完成响应后立即关闭连接。</li>
</ol>
</li>
<li><p>特性：</p>
<ul>
<li>每个请求都需要重新建立和断开连接。</li>
<li>每次都经过 TCP 的三次握手和四次挥手，开销较大。</li>
</ul>
</li>
<li><p>优点：</p>
<ul>
<li>简单直观，适合少量、不频繁的请求。</li>
<li>连接关闭后，系统资源立即释放，适合并发用户较多但单用户请求少的场景。</li>
</ul>
</li>
<li><p>缺点：</p>
<ul>
<li>请求频繁时，频繁建立和释放连接会增加服务器压力。</li>
</ul>
</li>
<li><p>网络延迟较高，整体性能较低。</p>
</li>
</ul>
<p><strong>2. 长连接</strong></p>
<ul>
<li><p><strong>定义</strong>：客户端与服务器建立一次 TCP 连接后，连接保持打开状态，可以处理多个请求。</p>
</li>
<li><p>过程：</p>
<ol>
<li>客户端发起第一次请求，与服务器建立 TCP 连接。</li>
<li>后续的请求和响应复用该连接，直到一方主动关闭连接。</li>
</ol>
</li>
<li><p>特性：</p>
<ul>
<li>TCP 连接在多个请求间共享，减少了连接建立和断开的开销。</li>
<li>默认在 HTTP/1.1 中启用长连接，通过头部字段 <code>Connection: keep-alive</code> 表示保持连接。</li>
</ul>
</li>
<li><p>优点：</p>
<ul>
<li>提高了请求性能，特别是在频繁请求的场景下。</li>
<li>降低了服务器的压力，因为减少了连接建立和释放的次数。</li>
</ul>
</li>
<li><p>缺点：</p>
<ul>
<li>需要更多的服务器资源（如连接数、内存）来维护长时间的连接。</li>
</ul>
</li>
<li><p>可能出现空闲连接浪费资源的问题。</p>
</li>
</ul>
<p><strong>3. 长连接与短连接的区别对比</strong></p>
<table>
<thead>
<tr>
<th><strong>特性</strong></th>
<th><strong>短连接</strong></th>
<th><strong>长连接</strong></th>
</tr>
</thead>
<tbody><tr>
<td><strong>连接生命周期</strong></td>
<td>请求完成后立即关闭</td>
<td>连接保持一定时间，处理多个请求</td>
</tr>
<tr>
<td><strong>性能</strong></td>
<td>每次请求需重新建立连接，性能较低</td>
<td>多次请求复用连接，性能较高</td>
</tr>
<tr>
<td><strong>开销</strong></td>
<td>频繁建立和关闭连接，增加开销</td>
<td>减少了连接的建立与断开开销</td>
</tr>
<tr>
<td><strong>适用场景</strong></td>
<td>请求少或并发用户多的场景</td>
<td>请求多且频繁的场景</td>
</tr>
</tbody></table>
<p><strong>4. 应用场景</strong></p>
<p><strong>短连接适用场景</strong></p>
<ul>
<li>请求量少，或者请求间隔较大的场景。</li>
<li>并发用户多，且每个用户的请求次数较少（如普通网页浏览）。</li>
</ul>
<p><strong>长连接适用场景</strong></p>
<ul>
<li>请求频繁、延迟要求较高的场景（如 API 接口、聊天系统）。</li>
<li>需要保持一定的会话状态的场景（如 WebSocket）。</li>
</ul>
<p><strong>总结</strong></p>
<ul>
<li><strong>短连接</strong>：简单但效率低，适合请求少的场景。</li>
<li><strong>长连接</strong>：提高性能但占用资源，适合频繁通信的场景。</li>
<li>在 HTTP/1.1 中，默认支持 <strong>长连接</strong>，通过 <code>Connection: close</code> 显式关闭连接。</li>
</ul>
<h4 id="问：cookie、session、token三者区别以及优缺点？"><a href="#问：cookie、session、token三者区别以及优缺点？" class="headerlink" title="问：cookie、session、token三者区别以及优缺点？"></a>问：cookie、session、token三者区别以及优缺点？</h4><p><strong>Cookie、Session、Token 的区别与优缺点</strong></p>
<p>在 Web 开发中，<strong>Cookie</strong>、<strong>Session</strong> 和 <strong>Token</strong> 都是常用的会话管理和身份认证机制。它们的作用、实现方式以及适用场景各有不同。</p>
<p><strong>1. 概念</strong></p>
<ul>
<li><strong>Cookie</strong>：<ul>
<li>存储在客户端浏览器中的数据，用于保存状态信息或传递少量数据。</li>
<li>由服务器生成，附加到 HTTP 响应头中，随后浏览器在后续请求时携带该 Cookie。</li>
</ul>
</li>
<li><strong>Session</strong>：<ul>
<li>存储在服务器端的会话信息，用于保存用户的状态和数据。</li>
<li>通常通过一个唯一的 <code>Session ID</code> 识别，<code>Session ID</code> 存储在 Cookie 中或直接通过 URL 传递。</li>
</ul>
</li>
<li><strong>Token</strong>：<ul>
<li>一种加密字符串，通常由服务器生成并颁发，用于客户端认证身份。</li>
<li>无状态化，不需要在服务器端存储会话数据。</li>
</ul>
</li>
</ul>
<p><strong>2. 工作原理</strong></p>
<table>
<thead>
<tr>
<th><strong>机制</strong></th>
<th><strong>存储位置</strong></th>
<th><strong>传递方式</strong></th>
</tr>
</thead>
<tbody><tr>
<td><strong>Cookie</strong></td>
<td>客户端浏览器</td>
<td>自动随每次请求发送到服务器。</td>
</tr>
<tr>
<td><strong>Session</strong></td>
<td>服务器端</td>
<td><code>Session ID</code> 存储在客户端 Cookie 中。</td>
</tr>
<tr>
<td><strong>Token</strong></td>
<td>客户端（通常是前端）</td>
<td>作为请求头（如 <code>Authorization</code>）传递。</td>
</tr>
</tbody></table>
<p><strong>3. 区别</strong></p>
<table>
<thead>
<tr>
<th><strong>属性</strong></th>
<th><strong>Cookie</strong></th>
<th><strong>Session</strong></th>
<th><strong>Token</strong></th>
</tr>
</thead>
<tbody><tr>
<td><strong>存储位置</strong></td>
<td>客户端浏览器</td>
<td>服务器端</td>
<td>客户端</td>
</tr>
<tr>
<td><strong>安全性</strong></td>
<td>较低，容易被窃取或篡改，需要配合 HTTPS</td>
<td>较高，数据存储在服务器端</td>
<td>较高，常使用加密算法防篡改</td>
</tr>
<tr>
<td><strong>传递方式</strong></td>
<td>随每次请求自动传递给服务器</td>
<td><code>Session ID</code> 存在 Cookie 或 URL 中传递</td>
<td>通过 <code>Authorization</code> 或参数传递</td>
</tr>
<tr>
<td><strong>适用场景</strong></td>
<td>小型数据存储、状态跟踪</td>
<td>保存用户会话状态</td>
<td>分布式系统或无状态认证</td>
</tr>
<tr>
<td><strong>服务器压力</strong></td>
<td>无需存储数据</td>
<td>需要存储用户会话数据</td>
<td>无需存储会话，减少服务器压力</td>
</tr>
<tr>
<td><strong>持久性</strong></td>
<td>持久性由 Cookie 设置的过期时间决定</td>
<td>会话通常在用户关闭浏览器或超时后失效</td>
<td>持久性由 Token 的有效期决定</td>
</tr>
<tr>
<td><strong>扩展性</strong></td>
<td>适合单点部署，不适合分布式</td>
<td>多服务器共享会话需额外配置</td>
<td>天然支持分布式，无需额外配置</td>
</tr>
</tbody></table>
<p><strong>4. 优缺点</strong></p>
<p><strong>Cookie</strong></p>
<ul>
<li><p>优点：</p>
<ul>
<li>存储在客户端，无需占用服务器资源。</li>
<li>跨请求自动携带，无需手动处理。</li>
</ul>
</li>
<li><p>缺点：</p>
<ul>
<li>数据量有限（一般 4 KB 左右）。</li>
<li>安全性较低，容易被窃取和篡改。</li>
<li>浏览器限制单域名的 Cookie 数量。</li>
</ul>
</li>
</ul>
<p><strong>Session</strong></p>
<ul>
<li><p>优点：</p>
<ul>
<li>数据存储在服务器端，安全性更高。</li>
<li>支持更复杂的会话状态管理。</li>
</ul>
</li>
<li><p>缺点：</p>
<ul>
<li>占用服务器资源。</li>
<li>需要处理多服务器共享会话的问题。</li>
<li>依赖客户端的 <code>Session ID</code> 来维持会话。</li>
</ul>
</li>
</ul>
<p><strong>Token</strong></p>
<ul>
<li><p>优点：</p>
<ul>
<li>无状态化，服务器无需存储会话信息，适合分布式系统。</li>
<li>天然支持跨域和多设备共享认证状态。</li>
<li>支持移动端、前后端分离等现代化架构。</li>
</ul>
</li>
<li><p>缺点：</p>
<ul>
<li>Token 长度较大，增加网络开销。</li>
<li>过期后需要重新获取，增加了客户端逻辑复杂度。</li>
<li>一旦泄露，攻击者可伪装合法用户直到 Token 失效。</li>
</ul>
</li>
</ul>
<p><strong>5. 应用场景</strong></p>
<table>
<thead>
<tr>
<th><strong>机制</strong></th>
<th><strong>场景</strong></th>
</tr>
</thead>
<tbody><tr>
<td><strong>Cookie</strong></td>
<td>保存用户偏好设置、记录用户行为（如购物车）</td>
</tr>
<tr>
<td><strong>Session</strong></td>
<td>用户登录后的会话管理（如传统 Web 系统的认证和权限控制）</td>
</tr>
<tr>
<td><strong>Token</strong></td>
<td>前后端分离、分布式系统、移动端应用（如 OAuth2.0 中的 JWT Token）</td>
</tr>
</tbody></table>
<p><strong>6. 总结</strong></p>
<ul>
<li><strong>Cookie</strong>：轻量、便捷，适合少量、非敏感的数据存储和传递。</li>
<li><strong>Session</strong>：适合需要保存复杂会话状态的传统 Web 应用，但扩展性差。</li>
<li><strong>Token</strong>：适合分布式系统和现代化应用架构，尤其是在前后端分离或跨平台场景中。</li>
</ul>
<p>根据具体业务需求选择合适的机制，同时配合 HTTPS 和相关安全策略，确保数据的安全性。</p>
<h2 id="网络安全"><a href="#网络安全" class="headerlink" title="网络安全"></a>网络安全</h2><p>DDos</p>

    </div>

    
    
    

    <footer class="post-footer">
          

<div class="post-copyright">
<ul>
  <li class="post-copyright-author">
      <strong>本文作者： </strong>Lys
  </li>
  <li class="post-copyright-link">
      <strong>本文链接：</strong>
      <a href="http://linyishui.top/2019102601.html" title="面试整理——网络">http://linyishui.top/2019102601.html</a>
  </li>
  <li class="post-copyright-license">
    <strong>版权声明： </strong>本博客所有文章除特别声明外，均采用 <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/deed.zh" rel="noopener" target="_blank"><i class="fab fa-fw fa-creative-commons"></i>BY-NC-SA</a> 许可协议。转载请注明出处！
  </li>
</ul>
</div>

          <div class="post-tags">
              <a href="/tags/Q-A/" rel="tag"><i class="fa fa-tag"></i> Q&A</a>
              <a href="/tags/updating/" rel="tag"><i class="fa fa-tag"></i> updating</a>
          </div>

        

          <div class="post-nav">
            <div class="post-nav-item">
                <a href="/2019102501.html" rel="prev" title="面试整理——算法">
                  <i class="fa fa-chevron-left"></i> 面试整理——算法
                </a>
            </div>
            <div class="post-nav-item">
                <a href="/2019102701.html" rel="next" title="面试整理——操作系统">
                  面试整理——操作系统 <i class="fa fa-chevron-right"></i>
                </a>
            </div>
          </div>
    </footer>
  </article>
</div>






    <div class="comments utterances-container"></div>
</div>
  </main>

  <footer class="footer">
    <div class="footer-inner">


<div class="copyright">
  &copy; 2018 – 
  <span itemprop="copyrightYear">2025</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">Lys</span>
</div>
<div class="wordcount">
  <span class="post-meta-item">
    <span class="post-meta-item-icon">
      <i class="fa fa-chart-line"></i>
    </span>
      <span>站点总字数：</span>
    <span title="站点总字数">5.4m</span>
  </span>
  <span class="post-meta-item">
    <span class="post-meta-item-icon">
      <i class="fa fa-coffee"></i>
    </span>
      <span>站点阅读时长 &asymp;</span>
    <span title="站点阅读时长">82:05</span>
  </span>
</div>
  <div class="powered-by">由 <a href="https://hexo.io/" rel="noopener" target="_blank">Hexo</a> & <a href="https://theme-next.js.org/pisces/" rel="noopener" target="_blank">NexT.Pisces</a> 强力驱动
  </div>

    </div>
  </footer>

  
  <script src="https://cdn.jsdelivr.net/npm/animejs@3.2.1/lib/anime.min.js" integrity="sha256-XL2inqUJaslATFnHdJOi9GfQ60on8Wx1C2H8DYiN1xY=" crossorigin="anonymous"></script>
  <script src="https://cdn.jsdelivr.net/npm/jquery@3.6.0/dist/jquery.min.js" integrity="sha256-/xUj+3OJU5yExlq6GSYGSHk7tPXikynS7ogEvDej/m4=" crossorigin="anonymous"></script>
  <script src="https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@3.5.7/dist/jquery.fancybox.min.js" integrity="sha256-yt2kYMy0w8AbtF89WXb2P1rfjcP/HTHLT7097U8Y5b8=" crossorigin="anonymous"></script>
<script src="/js/comments.js"></script><script src="/js/utils.js"></script><script src="/js/motion.js"></script><script src="/js/next-boot.js"></script><script src="/js/bookmark.js"></script>

  
<script src="/js/third-party/search/local-search.js"></script>



  <script class="next-config" data-name="nprogress" type="application/json">{"enable":true,"spinner":true}</script>
  <script src="/js/third-party/nprogress.js"></script>

  




<script src="https://cdn.jsdelivr.net/npm/darkmode-js@1.5.7/lib/darkmode-js.min.js"></script>

<script>
var options = {
  bottom: '64px',
  right: '32px',
  left: 'unset',
  time: '0.5s',
  mixColor: 'transparent',
  backgroundColor: 'transparent',
  buttonColorDark: '#100f2c',
  buttonColorLight: '#fff',
  saveInCookies: true,
  label: '🌓',
  autoMatchOsTheme: true
}
const darkmode = new Darkmode(options);
window.darkmode = darkmode;
darkmode.showWidget();
</script>
<script class="next-config" data-name="utterances" type="application/json">{"enable":true,"repo":"LAILAIWA/LAILAIWA.github.io","issue_term":"pathname","theme":"github-light"}</script>
<script src="/js/third-party/comments/utterances.js"></script>



</body>
</html>
