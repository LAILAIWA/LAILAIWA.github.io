<!DOCTYPE html>



  


<html class="theme-next pisces use-motion" lang="zh-Hans">
<head>
  <meta charset="UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=edge" />
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"/>
<meta name="theme-color" content="#222">



  
  
    
    
  <script src="/lib/pace/pace.min.js?v=1.0.2"></script>
  <link href="/lib/pace/pace-theme-minimal.min.css?v=1.0.2" rel="stylesheet">







<meta http-equiv="Cache-Control" content="no-transform" />
<meta http-equiv="Cache-Control" content="no-siteapp" />
















  
  
  <link href="/lib/fancybox/source/jquery.fancybox.css?v=2.1.5" rel="stylesheet" type="text/css" />







<link href="/lib/font-awesome/css/font-awesome.min.css?v=4.6.2" rel="stylesheet" type="text/css" />

<link href="/css/main.css?v=5.1.4" rel="stylesheet" type="text/css" />


  <link rel="apple-touch-icon" sizes="180x180" href="/images/gamepad playstation.png?v=5.1.4">


  <link rel="icon" type="image/png" sizes="32x32" href="/images/Mario.ico?v=5.1.4">


  <link rel="icon" type="image/png" sizes="16x16" href="/images/gamepad playstation.png?v=5.1.4">


  <link rel="mask-icon" href="/images/gamepad playstation.svg?v=5.1.4" color="#222">





  <meta name="keywords" content="java,jvm," />





  <link rel="alternate" href="/atom.xml" title="沂水博客" type="application/atom+xml" />






<meta name="description" content="简单介绍Java虚拟机中的虚拟机调优案例分析与实战，包括：概述，案例分析（高性能硬件上的程序部署策略、集群间同步导致的内存溢出、堆外内存导致的溢出错误、外部命令导致系统缓慢、服务器JVM进程崩溃、不恰当数据结构导致内存占用过大、由Windows虚拟内存导致的长时间停顿），实战：Eclipse运行速度调优（调优前的程序运行状态、升级JDK 1.6的性能变化及兼容问题、编译时间和类加载时间的优化、调整">
<meta name="keywords" content="java,jvm">
<meta property="og:type" content="article">
<meta property="og:title" content="虚拟机调优案例分析与实战">
<meta property="og:url" content="http://linyishui.top/2019120101.html">
<meta property="og:site_name" content="沂水博客">
<meta property="og:description" content="简单介绍Java虚拟机中的虚拟机调优案例分析与实战，包括：概述，案例分析（高性能硬件上的程序部署策略、集群间同步导致的内存溢出、堆外内存导致的溢出错误、外部命令导致系统缓慢、服务器JVM进程崩溃、不恰当数据结构导致内存占用过大、由Windows虚拟内存导致的长时间停顿），实战：Eclipse运行速度调优（调优前的程序运行状态、升级JDK 1.6的性能变化及兼容问题、编译时间和类加载时间的优化、调整">
<meta property="og:locale" content="zh-Hans">
<meta property="og:image" content="https://pic-1258215793.cos.ap-shanghai.myqcloud.com/content/20191201/201912010101.png">
<meta property="og:image" content="https://pic-1258215793.cos.ap-shanghai.myqcloud.com/content/20191201/201912010102.png">
<meta property="og:image" content="https://pic-1258215793.cos.ap-shanghai.myqcloud.com/content/20191201/201912010103.png">
<meta property="og:image" content="https://pic-1258215793.cos.ap-shanghai.myqcloud.com/content/20191201/201912010104.png">
<meta property="og:image" content="https://pic-1258215793.cos.ap-shanghai.myqcloud.com/content/20191201/201912010105.png">
<meta property="og:image" content="https://pic-1258215793.cos.ap-shanghai.myqcloud.com/content/20191201/201912010106.png">
<meta property="og:image" content="https://pic-1258215793.cos.ap-shanghai.myqcloud.com/content/20191201/201912010107.png">
<meta property="og:image" content="https://pic-1258215793.cos.ap-shanghai.myqcloud.com/content/20191201/201912010108.png">
<meta property="og:image" content="https://pic-1258215793.cos.ap-shanghai.myqcloud.com/content/20191201/201912010109.png">
<meta property="og:image" content="https://pic-1258215793.cos.ap-shanghai.myqcloud.com/content/20191201/201912010110.png">
<meta property="og:image" content="https://pic-1258215793.cos.ap-shanghai.myqcloud.com/content/20191201/201912010111.png">
<meta property="og:image" content="https://pic-1258215793.cos.ap-shanghai.myqcloud.com/content/20191201/201912010113.png">
<meta property="og:updated_time" content="2020-01-10T03:12:26.494Z">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="虚拟机调优案例分析与实战">
<meta name="twitter:description" content="简单介绍Java虚拟机中的虚拟机调优案例分析与实战，包括：概述，案例分析（高性能硬件上的程序部署策略、集群间同步导致的内存溢出、堆外内存导致的溢出错误、外部命令导致系统缓慢、服务器JVM进程崩溃、不恰当数据结构导致内存占用过大、由Windows虚拟内存导致的长时间停顿），实战：Eclipse运行速度调优（调优前的程序运行状态、升级JDK 1.6的性能变化及兼容问题、编译时间和类加载时间的优化、调整">
<meta name="twitter:image" content="https://pic-1258215793.cos.ap-shanghai.myqcloud.com/content/20191201/201912010101.png">



<script type="text/javascript" id="hexo.configurations">
  var NexT = window.NexT || {};
  var CONFIG = {
    root: '/',
    scheme: 'Pisces',
    version: '5.1.4',
    sidebar: {"position":"left","display":"post","offset":12,"b2t":false,"scrollpercent":false,"onmobile":false},
    fancybox: true,
    tabs: true,
    motion: {"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}},
    duoshuo: {
      userId: '0',
      author: '博主'
    },
    algolia: {
      applicationID: '',
      apiKey: '',
      indexName: '',
      hits: {"per_page":10},
      labels: {"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}
    }
  };
</script>



  <link rel="canonical" href="http://linyishui.top/2019120101.html"/>





  <title>虚拟机调优案例分析与实战 | 沂水博客</title>
  








</head>

<body itemscope itemtype="http://schema.org/WebPage" lang="zh-Hans">

  
  
    
  

  <div class="container sidebar-position-left page-post-detail">
    <div class="headband"></div>

    <header id="header" class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-wrapper">
  <div class="site-meta ">
    

    <div class="custom-logo-site-title">
      <a href="/"  class="brand" rel="start">
        <span class="logo-line-before"><i></i></span>
        <span class="site-title">沂水博客</span>
        <span class="logo-line-after"><i></i></span>
      </a>
    </div>
      
        <p class="site-subtitle">编程和心历记录</p>
      
  </div>

  <div class="site-nav-toggle">
    <button>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
    </button>
  </div>
</div>

<nav class="site-nav">
  

  
    <ul id="menu" class="menu">
      
        
        <li class="menu-item menu-item-home">
          <a href="/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-home"></i> <br />
            
            首页
          </a>
        </li>
      
        
        <li class="menu-item menu-item-about">
          <a href="/about/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-user"></i> <br />
            
            关于
          </a>
        </li>
      
        
        <li class="menu-item menu-item-tags">
          <a href="/tags/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-tags"></i> <br />
            
            标签
          </a>
        </li>
      
        
        <li class="menu-item menu-item-categories">
          <a href="/categories/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-th"></i> <br />
            
            分类
          </a>
        </li>
      
        
        <li class="menu-item menu-item-archives">
          <a href="/archives/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-archive"></i> <br />
            
            归档
          </a>
        </li>
      
        
        <li class="menu-item menu-item-schedule">
          <a href="/schedule/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-calendar"></i> <br />
            
            日程表
          </a>
        </li>
      
        
        <li class="menu-item menu-item-sitemap">
          <a href="/sitemap.xml" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-sitemap"></i> <br />
            
            站点地图
          </a>
        </li>
      
        
        <li class="menu-item menu-item-commonweal">
          <a href="/404/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-heartbeat"></i> <br />
            
            公益404
          </a>
        </li>
      

      
    </ul>
  

  
</nav>



 </div>
    </header>

    <main id="main" class="main">
      <div class="main-inner">
        <div class="content-wrap">
          <div id="content" class="content">
            

  <div id="posts" class="posts-expand">
    

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://linyishui.top/2019120101.html">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="沂水">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="https://pic-1258215793.cos.ap-shanghai.myqcloud.com/cover/riho_yoshioka1.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="沂水博客">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">虚拟机调优案例分析与实战</h1>
        

        <div class="post-meta">
          
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2019-12-01T20:53:58+08:00">
                2019-12-01
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/技术文档/" itemprop="url" rel="index">
                    <span itemprop="name">技术文档</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          
            <div class="post-wordcount">
              
                
                <span class="post-meta-item-icon">
                  <i class="fa fa-file-word-o"></i>
                </span>
                
                  <span class="post-meta-item-text">字数统计&#58;</span>
                
                <span title="字数统计">
                  14,844
                </span>
              

              
                <span class="post-meta-divider">|</span>
              

              
                <span class="post-meta-item-icon">
                  <i class="fa fa-clock-o"></i>
                </span>
                
                  <span class="post-meta-item-text">阅读时长 &asymp;</span>
                
                <span title="阅读时长">
                  56
                </span>
              
            </div>
          

          
              <div class="post-description">
                  简单介绍Java虚拟机中的虚拟机调优案例分析与实战，包括：概述，案例分析（高性能硬件上的程序部署策略、集群间同步导致的内存溢出、堆外内存导致的溢出错误、外部命令导致系统缓慢、服务器JVM进程崩溃、不恰当数据结构导致内存占用过大、由Windows虚拟内存导致的长时间停顿），实战：Eclipse运行速度调优（调优前的程序运行状态、升级JDK 1.6的性能变化及兼容问题、编译时间和类加载时间的优化、调整内存设置控制垃圾收集频率、选择收集器降低延迟），总结等内容。
              </div>
          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        <h1 id="虚拟机调优案例分析与实战"><a href="#虚拟机调优案例分析与实战" class="headerlink" title="虚拟机调优案例分析与实战"></a><strong>虚拟机调优案例分析与实战</strong></h1><h2 id="第一节-概述"><a href="#第一节-概述" class="headerlink" title="第一节 概述"></a><strong>第一节 概述</strong></h2><p>&emsp;&emsp;<a href="../2019112501.html" title="Title">虚拟机性能监控和故障处理工具</a>介绍了处理Java虚拟机内存问题的知识与工具，在处理实际项目的问题时，除了知识与工具外，经验也是一个很重要的因素。因此本章将分享几个比较有代表性的实际案例。考虑到虚拟机故障处理和调优主要面向各类服务端应用，而大部分Java程序员较少有机会直接接触生产环境的服务器，因此本章还准备了一个所有开发人员都能够进行“亲身实战”的练习，希望通过实践使读者获得故障处理和调优的经验。</p>
<hr>
<h2 id="第二节-案例分析"><a href="#第二节-案例分析" class="headerlink" title="第二节 案例分析"></a><strong>第二节 案例分析</strong></h2><p>&emsp;&emsp;本章中的案例大部分来源于作者处理过的一些问题，还有一小部分来源于网上有特色和代表性的案例总结。出于对客户商业信息保护的目的，在不影响前后逻辑的前提下，作者对实际环境和用户业务做了一些屏蔽和精简。</p>
<h3 id="2-1-高性能硬件上的程序部署策略"><a href="#2-1-高性能硬件上的程序部署策略" class="headerlink" title="2.1 高性能硬件上的程序部署策略"></a><strong>2.1 高性能硬件上的程序部署策略</strong></h3><p>&emsp;&emsp;例如一个15万PV/天左右的在线文档类型网站最近更换了硬件系统，新的硬件为4个CPU、16GB物理内存，操作系统为64位CentOS 5.4，Resin作为Web服务器。整个服务器暂时没有部署别的应用，所有硬件资源都可以提供给访问量并不算太大的网站使用。管理员为了尽量利用硬件资源选用了64位的JDK 1.5，并通过-Xmx和-Xms参数将Java堆固定在12GB。使用一段时间后发现使用效果并不理想，网站经常不定期出现长时间没有响应的现象。</p>
<p>&emsp;&emsp;监控服务器运行状况后发现网站没有响应是由GC停顿导致的，虚拟机运行在Server模式，默认使用吞吐量优先收集器，回收12GB的堆，一次Full GC的停顿时间高达14秒。并且由于程序设计的关系，访问文档时要把文档从磁盘提取到内存中，导致内存中出现很多由文档序列化产生的大对象，这些大对象很多都进入了老年代，没有在Minor GC中清理掉。这种情况下即使有12GB的堆，内存也很快会被消耗殆尽，由此导致每隔十几分钟出现十几秒的停顿，令网站开发人员和管理员感到很沮丧。</p>
<p>&emsp;&emsp;这里先不延伸讨论程序代码问题，程序部署上的主要问题显然是<strong>过大的堆内存进行回收时带来的长时间的停顿</strong>。硬件升级前使用32位系统1.5GB的堆，用户只感到访问网站比较缓慢，但不会发生十分明显的停顿，因此才考虑升级硬件提升程序效能，如果重新缩小给Java堆分配的内存，那么硬件上的投资就浪费了。</p>
<blockquote>
<p>在高性能硬件上部署程序，目前主要有两种方式：</p>
<ul>
<li>通过64位JDK来使用大内存。</li>
<li>使用若干个32位虚拟机建立逻辑集群来利用硬件资源。</li>
</ul>
</blockquote>
<p>&emsp;&emsp;此案例中的管理员采用了第一种部署方式。对于用户交互性强、对停顿时间敏感的系统，可以给Java虚拟机分配超大堆的前提是有把握把应用程序的Full GC频率控制得足够低，至少要低到不会影响用户使用，譬如十几个小时乃至一天才出现一次Full GC，这样可以<strong>通过在深夜执行定时任务的方式触发Full GC甚至自动重启应用服务器来将内存可用空间保持在一个稳定的水平</strong>。</p>
<p>&emsp;&emsp;控制Full GC频率的关键是看应用中绝大多数对象能否符合“朝生夕灭”的原则，即大多数对象的生存时间不应当太长，尤其是不能产生成批量的、长生存时间的大对象，这样才能保障老年代空间的稳定。</p>
<p>&emsp;&emsp;在大多数网站形式的应用里，主要对象的生存周期都应该是请求级或页面级的，会话级和全局级的长生命对象相对很少。只要代码写得合理，应当都能实现在超大堆中正常使用而没有Full GC，这样的话，使用超大堆内存时，网站响应的速度才比较有保证。除此之外，如果读者计划使用64位JDK来管理大内存，还需要考虑下面可能面临的问题：</p>
<blockquote>
<ul>
<li>内存回收导致的长时间停顿。</li>
<li>现阶段，64位JDK的性能测试结果普遍低于32位JDK。</li>
<li>需要保证程序足够稳定，因为这种应用要是产生堆溢出几乎就无法产生堆转储快照 （因为要产生十几GB乃至更大的dump文件），哪怕产生了快照也几乎无法进行分 析。</li>
<li>相同的程序在64位JDK中消耗的内存一般比32位JDK大，这是由指针膨胀及数据类型对齐补白等因素导致的。</li>
</ul>
</blockquote>
<p>&emsp;&emsp;上面的问题听起来有点吓人，所以现阶段不少管理员还是选择第二种方式：使用若干个32位虚拟机建立逻辑集群来利用硬件资源。具体做法是<strong>在一台物理机器上启动多个应用服务器进程，给每个服务器进程分配不同的端口，然后在前端搭建一个负载均衡器，以反向代理的方式来分配访问请求</strong>。读者不需要太在意均衡器转发所消耗的性能，即使使用64位JDK，许多应用也不止有一台服务器，因此在许多应用中前端的均衡器总是要存在的。</p>
<p>&emsp;&emsp;考虑到在一台物理机器上建立逻辑集群的目的仅仅是尽可能地利用硬件资源，并不需要关心状态保留、热转移之类的高可用性需求，也不需要保证每个虚拟机进程有绝对准确的均衡负载，因此使用无Session复制的亲合式集群是一个相当不错的选择。我们仅仅需要保障集群具备亲和性，也就是均衡器按一定的规则算法（一般根 据SessionID分配）将一个固定的用户请求永远分配到固定的一个集群节点进行处理即可，这样程序开发阶段就基本不用为集群环境做什么特别的考虑。</p>
<p>&emsp;&emsp;当然，很少有没有缺点的方案，如果读者计划使用逻辑集群的方式来部署程序，可能会遇到下面一些问题：</p>
<blockquote>
<ul>
<li>尽量避免节点竞争全局的资源，最典型的就是磁盘竞争，各个节点如果同时访问某个磁盘文件的话（尤其是并发写操作容易出现问题），很容易导致IO异常。</li>
<li>很难最高效率地利用某些资源池，譬如连接池，一般都是在各个节点建立自己独立的连接池，这样有可能导致一些节点池满了而另外一些节点仍有较多空余。尽管可以使用集中式的JNDI，但这有一定的复杂性并且可能带来额外的性能代价。</li>
<li>各个节点仍然不可避免地受到32位的内存限制，在32位Windows平台中每个进程只能使用2GB的内存，考虑到堆以外的内存开销，堆一般最多只能开到1.5GB。在某些 Linux, Unix系统（如Solaris）中，可以提升到3GB乃至接近4GB的内存，但32位中仍然受最高4GB（2^32）内存的限制。</li>
<li>大量使用本地缓存（如大量使用HashMap作为K/V缓存）的应用，在逻辑集群中会造成较大的内存浪费，因为每个逻辑节点上都有一份缓存，这时可以考虑把本地缓存改为集中式缓存。</li>
</ul>
</blockquote>
<p>&emsp;&emsp;介绍完这两种部署方式，再重新回到这个案例之中，最后的部署方案调整为建立5个32位JDK的逻辑集群，每个进程按2GB内存计算（其中堆固定为1.5GB），占用了10GB的内存。另外建立一个Apache服务作为前端均衡代理访问门户。考虑到用户对响应速度比较关心，并且文档服务的主要压力集中在磁盘和内存访问上，CPU资源敏感度较低，因此改为CMS收集器进行垃圾回收。部署方式调整后，服务再没有出现长时间停顿，速度比硬件升级前有较大提升。</p>
<h3 id="2-2-集群间同步导致的内存溢出"><a href="#2-2-集群间同步导致的内存溢出" class="headerlink" title="2.2 集群间同步导致的内存溢出"></a><strong>2.2 集群间同步导致的内存溢出</strong></h3><p>&emsp;&emsp;一个基于B/S的MIS系统，硬件为两台2个CPU、8GB内存的HP小型机，服务器是WebLogic 9.2，每台机器启动了3个WebLogic实例，构成一个6个节点的亲合式集群。由于是亲合式集群，节点之间没有进行Session同步，但是有一些需求要实现部分数据在各个节点间共享。开始这些数据存放在数据库中，但由于读写频繁竞争很激烈，对性能的影响较大，后面使用JBossCache构建了一个全局缓存。全局缓存启用后，服务正常使用了较长的一段时间。但最近不定期地多次出现内存溢出问题。</p>
<p>&emsp;&emsp;在不出现内存溢出异常的时候，服务内存回收状况一直正常，每次内存回收后都能恢复到一个稳定的可用空间，开始怀疑是程序的某些不常用的代码路径中存在内存泄漏，但管理员反映最近程序并未更新或升级过，也没有进行什么特别的操作。只好让服务带着-XX：+HeapDumpOnOutOfMemoryError参数运行了一段时间。在最近一次溢出之后，管理员发回了heapdump文件，发现里面存在着大量的org.jgroups.protocols.pbcast.NAKACK对象。</p>
<p>&emsp;&emsp;JBossCache是基于自家的JGroups进行集群间的数据通信，JGroups使用协议栈的方式来实现收发数据包的各种所需特性的自由组合，数据包接收和发送时要经过每层协议栈的up()和down()方法，其中的NAKACK栈用于保障各个包的有效顺序及重发。JBossCache协议栈如图5-1所示。</p>
<p><img src="https://pic-1258215793.cos.ap-shanghai.myqcloud.com/content/20191201/201912010101.png" alt="JBossCache协议栈"></p>
<p>&emsp;&emsp;由于信息有传输失败需要重发的可能性，在确认所有注册在GMS（Group Membership Service）的节点都收到正确的信息前，发送的信息必须在内存中保 留。而此MIS的服务端中有一个负责安全校验的全局Filter，每当接收到请求时，均会更新一次最后的操作时间，并且将这个时间同步到所有的节点中，使得一个用户在一段时间内不能在多台机器上登录。在服务使用过程中，往往一个页面会产生数次乃至数十次的请求，因此这个过滤器导致集群各个节点之间的网络交互非常频繁。当网络情况不能满足传输要求时，重发数据在内存中不断地堆积，很快就产生了内存溢出。</p>
<p>&emsp;&emsp;这个案例中的问题，既有JBossCache的缺陷，也有MIS系统实现方式上的缺陷。JBossCache官方的maillist中讨论过很多次类似的内存溢出异常问题，据说后续版本有了改进。而更重要的缺陷是这一类被集群共享的数据如果要使用类似JBossCache这种集群缓存来同步的话，可以允许读操作频繁，因为数据在本地内存有一份副本，读取的动作不会耗费多少资源，但不应当有过于频繁的写操作，这会带来很大的网络同步的开销。</p>
<h3 id="2-3-堆外内存导致的溢出错误"><a href="#2-3-堆外内存导致的溢出错误" class="headerlink" title="2.3 堆外内存导致的溢出错误"></a><strong>2.3 堆外内存导致的溢出错误</strong></h3><p>&emsp;&emsp;这是一个学校的小型项目：基于B/S的电子考试系统，为了实现客户端能实时地从服务端接收考试数据，系统使用了逆向AJAX技术（也称为Comet或Server Side Push），选用CometD 1.1.1作为服务端推送框架，服务器是Jetty 7.1.4，硬件为一台普通PC机，Core i5 CPU，4GB内存，运行32位Windows操作系统。</p>
<p>&emsp;&emsp;测试期间发现服务端不定时抛出内存溢出异常，服务器不一定每次都会出现异常，但假如正式考试时崩溃一次，那估计整场电子考试都会乱套，网站管理员尝试过把堆开到最大，32位系统最多到1.6GB基本无法再加大了，而且开大了也基本没效果，抛出内存溢出异常好像更加频繁了。加入-XX: +HeapDumpOnOutOfMemoryError，居然也没有任何反应，抛出内存溢出异常时什么文件都没有产生。无奈之下只好挂着jstat使劲盯屏幕，发现GC并不频繁，Eden 区、Survivor区、老年代及永久代内存全部都表示“情绪稳定，压力不大”，但照样不停地抛出内存溢出异常，管理员压力很大。最后，在内存溢出后从系统日志中找到异常堆栈，如代码清单5-1所示。</p>
<figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">代码清单<span class="number">5</span>-<span class="number">1</span> 异常堆栈<span class="number">1</span></span><br><span class="line">[org<span class="selector-class">.eclipse</span><span class="selector-class">.jetty</span><span class="selector-class">.util</span><span class="selector-class">.log</span>]handle failed java<span class="selector-class">.lang</span><span class="selector-class">.OutOfMemoryError</span>：null</span><br><span class="line">at sun<span class="selector-class">.misc</span><span class="selector-class">.Unsafe</span><span class="selector-class">.allocateMemory</span>(Native Method)</span><br><span class="line">at java<span class="selector-class">.nio</span><span class="selector-class">.DirectByteBuffer</span>.&lt;init&gt;(DirectByteBuffer.java：<span class="number">99</span>)</span><br><span class="line">at java<span class="selector-class">.nio</span><span class="selector-class">.ByteBuffer</span><span class="selector-class">.allocateDirect</span>(ByteBuffer.java：<span class="number">288</span>)</span><br><span class="line">at org<span class="selector-class">.eclipse</span><span class="selector-class">.jetty</span><span class="selector-class">.io</span><span class="selector-class">.nio</span><span class="selector-class">.DirectNIOBuffer</span>.&lt;init&gt;</span><br><span class="line">……</span><br></pre></td></tr></table></figure>
<p>&emsp;&emsp;如果认真阅读过本书的第2章，看到异常堆栈就应该清楚这个内存溢出异常是怎么回事了。大家知道操作系统对每个进程能管理的内存是有限制的，这台服务器使用的32位Windows平台的限制是2GB，其中给了Java堆1.6GB，而Direct Memory并不算在1.6GB的堆之内，因此它只能在剩余的0.4GB空间中分出一部分。在此应用中导致溢出的关键是：垃圾收集进行时，虚拟机虽然会对Direct Memory进行回收，但是Direct Memory却不能像新生代和老年代那样，发现空间不足了就通知收集器进行垃圾回收，它只能等待老年代满了后Full GC，然后“顺便地”帮它清理掉内存的废弃对象。否则，它只能等到抛出内存溢出异常时，先catch掉，再在catch块里面“大喊”一声：“System.gc()！”。要是虚拟机还是不听（譬如打开了-XX:+DisableExplicitGC开关），那就只能眼睁睁地看着堆中还有许多空闲内存，自己却不得不抛出内存溢出异常了。而本案例中使用的CometD 1.1.1框架，正好有大量的NIO操作需要用到Direct Memory。</p>
<p>&emsp;&emsp;从实践经验的角度出发，除了Java堆和永久代之外，我们注意到下面这些区域还会占用较多的内存，这里所有的内存总和会受到操作系统进程最大内存的限制：</p>
<blockquote>
<ul>
<li>Direct Memory：可通过-XX:MaxDirectMemorySize调整大小，内存不足时抛出OutOfMemoryError或OutOfMemoryError：Direct buffer memory。</li>
<li>线程堆栈：可通过-Xss调整大小，内存不足时抛出StackOverflowError（纵向无法分配，即无法分配新的栈帧）或OutOfMemoryError：unable to create new native thread（横向无法分配，即无法建立新的线程）。</li>
<li>Socket缓存区：每个Socket连接都Receive和Send两个缓存区，分别占大约37KB和25KB的内存，连接多的话这块内存占用也比较可观。如果无法分配，则可能会抛出IOException：Too many open files异常。</li>
<li>JNI代码：如果代码中使用JNI调用本地库，那本地库使用的内存也不在堆中。</li>
<li>虚拟机和GC：虚拟机和GC的代码执行也要消耗一定的内存。</li>
</ul>
</blockquote>
<h3 id="2-4-外部命令导致系统缓慢"><a href="#2-4-外部命令导致系统缓慢" class="headerlink" title="2.4 外部命令导致系统缓慢"></a><strong>2.4 外部命令导致系统缓慢</strong></h3><p>&emsp;&emsp;这是一个来自网络的案例：一个数字校园应用系统，运行在一台4个CPU的Solaris 10操作系统上，中间件为GlassFish服务器。系统在进行大并发压力测试的时候，发现请求响应时间比较慢，通过操作系统的mpstat工具发现CPU使用率很高，并且占用绝大多数CPU资源的程序并不是应用系统本身。这是个不正常的现象，通常情况下用户应用的CPU占用率应该占主要地位，才能说明系统是正常工作的。</p>
<p>&emsp;&emsp;通过Solaris 10的Dtrace脚本可以查看当前情况下哪些系统调用花费了最多的CPU资源，Dtrace运行后发现最消耗CPU资源的竟然是“fork”系统调用。众所周知，“fork”系统调用是Linux用来产生新进程的，在Java虚拟机中，用户编写的Java代码最多只有线程的概念，不应当有进程的产生。</p>
<p>&emsp;&emsp;这是个非常异常的现象。通过本系统的开发人员最终找到了答案：每个用户请求的处理都需要执行一个外部shell脚本来获得系统的一些信息。执行这个shell脚本是通过Java的Runtime.getRuntime().exec()方法来调用的。这种调用方式可以达到目的，但是它在Java虚拟机中非常消耗资源，即使外部命令本身能很快执行完毕，频繁调用时创建进程的开销也非常可观。Java虚拟机执行这个命令的过程是：首先克隆一个和当前虚拟机拥有一样环境变量的进程，再用这个新的进程去执行外部命令，最后再退出这个进程。如果频繁执行这个操作，系统的消耗会很大，不仅是CPU，内存的负担也很重。</p>
<p>&emsp;&emsp;用户根据建议去掉这个shell脚本执行的语句，改为使用Java的API去获取这些信息后，系统很快就恢复了正常。</p>
<h3 id="2-5-服务器JVM进程崩溃"><a href="#2-5-服务器JVM进程崩溃" class="headerlink" title="2.5 服务器JVM进程崩溃"></a><strong>2.5 服务器JVM进程崩溃</strong></h3><p>&emsp;&emsp;一个基于B/S的MIS系统，硬件为两台2个CPU、8GB内存的HP系统，服务器是 WebLogic 9.2（就是第二个案例中的那套系统）。正常运行一段时间后，最近发现在运行期间频繁出现集群节点的虚拟机进程自动关闭的现象，留下了一个hs_err_pid###.log文件后，进程就消失了，两台物理机器里的每个节点都出现过进程崩溃的现象。从系统日志中注意到，每个节点的虚拟机进程在崩溃前不久，都发生过大量相同的异常，见代码清单5-2。</p>
<figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">代码清单<span class="number">5</span>-<span class="number">2</span> 异常堆栈<span class="number">2</span></span><br><span class="line">java<span class="selector-class">.net</span><span class="selector-class">.SocketException</span>：Connection reset</span><br><span class="line">at java<span class="selector-class">.net</span><span class="selector-class">.SocketInputStream</span><span class="selector-class">.read</span>(SocketInputStream.java：<span class="number">168</span>)</span><br><span class="line">at java<span class="selector-class">.io</span><span class="selector-class">.BufferedInputStream</span><span class="selector-class">.fill</span>(BufferedInputStream.java： <span class="number">218</span>)</span><br><span class="line">at java<span class="selector-class">.io</span><span class="selector-class">.BufferedInputStream</span><span class="selector-class">.read</span>(BufferedInputStream.java：<span class="number">235</span>)</span><br><span class="line">at org<span class="selector-class">.apache</span><span class="selector-class">.axis</span><span class="selector-class">.transport</span><span class="selector-class">.http</span><span class="selector-class">.HTTPSender</span><span class="selector-class">.readHeadersFromSocket</span>(HTTPSe <span class="number">583</span>)</span><br><span class="line">at org<span class="selector-class">.apache</span><span class="selector-class">.axis</span><span class="selector-class">.transport</span><span class="selector-class">.http</span><span class="selector-class">.HTTPSender</span><span class="selector-class">.invoke</span>(HTTPSender.java： <span class="number">143</span>)</span><br><span class="line">……<span class="number">99</span> more</span><br></pre></td></tr></table></figure>
<p>&emsp;&emsp;这是一个远端断开连接的异常，通过系统管理员了解到系统最近与一个OA门户做了集成，在MIS系统工作流的待办事项变化时，要通过Web服务通知OA门户系统，把待办事项的变化同步到OA门户之中。通过SoapUI测试了一下同步待办事项的几个Web服务，发现调用后竟然需要长达3分钟才能返回，并且返回的结果都是连接中断。</p>
<p>&emsp;&emsp;由于MIS系统的用户多，待办事项变化很快，为了不被OA系统的速度拖累，使用了异步的方式调用Web服务，但由于两边服务的速度完全不对等，时间越长就累积了越多Web服务没有调用完成，导致在等待的线程和Socket连接越来越多，最终超过虚拟机的承受能力后使得虚拟机进程崩溃。通知OA门户方修复无法使用的集成接口，并将异步调用改为生产者/消费者模式的消息队列实现后，系统恢复正常。</p>
<h3 id="2-6-不恰当数据结构导致内存占用过大"><a href="#2-6-不恰当数据结构导致内存占用过大" class="headerlink" title="2.6 不恰当数据结构导致内存占用过大"></a><strong>2.6 不恰当数据结构导致内存占用过大</strong></h3><p>&emsp;&emsp;例如，有一个后台RPC服务器，使用64位虚拟机，内存配置为-Xms4g -Xmx8g -Xmnlg，使用ParNew+CMS的收集器组合。平时对外服务的Minor GC时间约在30毫秒以内，完全可以接受。但业务上需要每10分钟加载一个约80MB的数据文件到内存进行数据分析，这些数据会在内存中形成超过100万个HashMap&lt;Long, Long&gt;Entry，在这段时间里面Minor GC就会造成超过500毫秒的停顿，这个时间就有些接受不了了，具体情况如下面GC日志所示。</p>
<figure class="highlight x86asm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">&#123;Heap before GC invocations=<span class="number">95</span>(full <span class="number">4</span>):</span><br><span class="line">    par new generation total 903168K,used 803142K[<span class="number">0x00002aaaae770000</span>，<span class="number">0x00002aaaebb70000</span>，<span class="number">0x00002aaaebb70000</span>)</span><br><span class="line">    eden space 802816K，<span class="number">100</span>%used[<span class="number">0x00002aaaae770000</span>，<span class="number">0x00002aaadf770000</span>，<span class="number">0x00002aaadf770000</span>)</span><br><span class="line">    from space 100352K，<span class="number">0</span>%used[<span class="number">0x00002aaae5970000</span>，<span class="number">0x00002aaae59c1910</span>，<span class="number">0x00002aaaebb70000</span>)</span><br><span class="line">    to space 100352K，<span class="number">0</span>%used[<span class="number">0x00002aaadf770000</span>，<span class="number">0x00002aaadf770000</span>，<span class="number">0x00002aaae5970000</span>)</span><br><span class="line">    concurrent mark-sweep generation total 5845540K,used 3898978K[<span class="number">0x00002aaaebb70000</span>，<span class="number">0x00002aac507f9000</span>，<span class="number">0x00002aacae770000</span>)</span><br><span class="line">    concurrent-mark-sweep perm gen total 65536K,used 40333K[<span class="number">0x00002aacae770000</span>，<span class="number">0x00002aacb2770000</span>，<span class="number">0x00002aacb2770000</span>)</span><br><span class="line">    <span class="number">2011</span>-<span class="number">10</span>-<span class="number">28</span> T <span class="number">11</span>:<span class="number">40</span>:<span class="number">45.162</span>+<span class="number">0800</span>: <span class="number">226.504</span>:[GC <span class="number">226.504</span>: [ParNew:803142K-&gt;100352K(903168K)，<span class="number">0.5995670</span> secs] 4702120K-&gt; 4056332K(6748708K)，<span class="number">0.5997560</span> secs][<span class="built_in">Times</span>:user=<span class="number">1.46</span> sys=<span class="number">0.04</span>，real=<span class="number">0.60</span> secs]</span><br><span class="line">    Heap after GC invocations=<span class="number">96</span>(full <span class="number">4</span>):</span><br><span class="line">    par new generation total 903168K,used 100352K[<span class="number">0x00002aaaae770000</span>，<span class="number">0x00002aaaebb70000</span>，<span class="number">0x00002aaaebb70000</span>)</span><br><span class="line">    eden space 802816K，<span class="number">0</span>%used[<span class="number">0x00002aaaae770000</span>，<span class="number">0x00002aaaae770000</span>，<span class="number">0x00002aaadf770000</span>)</span><br><span class="line">    from space 100352K，<span class="number">100</span>%used[<span class="number">0x00002aaadf770000</span>，<span class="number">0x00002aaae5970000</span>，<span class="number">0x00002aaae5970000</span>)</span><br><span class="line">    to space 100352K，<span class="number">0x00002aaaebb70000</span>)<span class="number">0</span>%used[<span class="number">0x00002aaae5970000</span>，<span class="number">0x00002aaae5970000</span>，</span><br><span class="line">    concurrent mark-sweep generation total 5845540K,used 3955980K[<span class="number">0x00002aaaebb70000</span>，<span class="number">0x00002aac507f9000</span>，<span class="number">0x00002aacae770000</span>)</span><br><span class="line">    concurrent-mark-sweep perm gen total 65536K,used 40333K[<span class="number">0x00002aacae770000</span>，<span class="number">0x00002aacb2770000</span>，<span class="number">0x00002aacb2770000</span>)</span><br><span class="line">&#125;</span><br><span class="line">Total time for which application threads were stopped:<span class="number">0.6070570</span> seconds</span><br></pre></td></tr></table></figure>
<p>&emsp;&emsp;观察这个案例，发现平时的Minor GC时间很短，原因是新生代的绝大部分对象都是可清除的，在Minor GC之后Eden和Survivor基本上处于完全空闲的状态。而在分析数据文件期间，800MB的Eden空间很快被填满从而引发GC，但Minor GC之后，新生代中绝大部分对象依然是存活的。我们知道ParNew收集器使用的是复制算法，这个算法的高效是建立在大部分对象都“朝生夕灭”的特性上的，如果存活对象过多，把这些对象复制到Survivor并维持这些对象引用的正确就成为一个沉重的负担，因此导致GC暂停时间明显变长。</p>
<p>&emsp;&emsp;如果不修改程序，仅从GC调优的角度去解决这个问题，可以考虑将Survivor空间去掉（加入参数-XX:SurvivorRatio=65536、-XX:MaxTenuringThreshold=0或者-XX:+AlwaysTenure），让新生代中存活的对象在第一次Minor GC后立即进入老年代，等到Major GC的时候再清理它们。这种措施可以治标，但也有很大副作用，治本的方案需要修改程序，因为这里的问题产生的根本原因是用HashMap&lt;Long, Long&gt;结构来存储数据文件空间效率太低。</p>
<p>&emsp;&emsp;下面具体分析一下空间效率。在HashMap&lt;Long, Long&gt;结构中，只有Key和Value所存放的两个长整型数据是有效数据，共16B（2×8B）。这两个长整型数据包装成java.lang.Long对象之后，就分别具有8B的MarkWord、8B的Klass指针，在加8B存储数据的long值。在这两个Long对象组成Map.Entry之后，又多了16B的对象头，然后一个8B的next字段和4B的int型的hash字段，为了对齐，还必须添加4B的空白填充，最后还有HashMap中对这个Entry的8B的引用，这样增加两个长整型数字，实际耗费的内存为(Long(24B)×2) + Entry(32B) + HashMap Ref (8B) = 88B，空间效率为16B/88B=18%，实在太低了。</p>
<h3 id="2-7-由Windows虚拟内存导致的长时间停顿"><a href="#2-7-由Windows虚拟内存导致的长时间停顿" class="headerlink" title="2.7 由Windows虚拟内存导致的长时间停顿"></a><strong>2.7 由Windows虚拟内存导致的长时间停顿</strong></h3><p>&emsp;&emsp;例如，有一个带心跳检测功能的GUI桌面程序，每15秒会发送一次心跳检测信号，如果对方30秒以内都没有信号返回，那就认为和对方程序的连接已经断开。程序上线后发现心跳检测有误报的概率，查询日志发现误报的原因是程序会偶尔出现间隔约一分钟左右的时间完全无日志输出，处于停顿状态。</p>
<p>&emsp;&emsp;因为是桌面程序，所需的内存并不大（-Xmx256m），所以开始并没有想到是GC导致的程序停顿，但是加入参数-XX:+PrintGCApplicationStoppedTime -XX:+PrintGCDateStamps Xloggc:gclog.log后，从GC日志文件中确认了停顿确实是由GC导致的，大部分GC时间都控制在100毫秒以内，但偶尔就会出现一次接近1分钟的GC。</p>
<figure class="highlight applescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">Total <span class="built_in">time</span> <span class="keyword">for</span> which <span class="built_in">application</span> threads were stopped：<span class="number">0.0112389</span> seconds</span><br><span class="line">Total <span class="built_in">time</span> <span class="keyword">for</span> which <span class="built_in">application</span> threads were stopped：<span class="number">0.0001335</span> seconds</span><br><span class="line">Total <span class="built_in">time</span> <span class="keyword">for</span> which <span class="built_in">application</span> threads were stopped：<span class="number">0.0003246</span> seconds</span><br><span class="line">Total <span class="built_in">time</span> <span class="keyword">for</span> which <span class="built_in">application</span> threads were stopped：<span class="number">41.4731411</span> seconds</span><br><span class="line">Total <span class="built_in">time</span> <span class="keyword">for</span> which <span class="built_in">application</span> threads were stopped：<span class="number">0.0489481</span> seconds</span><br><span class="line">Total <span class="built_in">time</span> <span class="keyword">for</span> which <span class="built_in">application</span> threads were stopped：<span class="number">0.1110761</span> seconds</span><br><span class="line">Total <span class="built_in">time</span> <span class="keyword">for</span> which <span class="built_in">application</span> threads were stopped：<span class="number">0.0007286</span> seconds</span><br><span class="line">Total <span class="built_in">time</span> <span class="keyword">for</span> which <span class="built_in">application</span> threads were stopped：<span class="number">0.0001268</span> seconds</span><br></pre></td></tr></table></figure>
<p>&emsp;&emsp;从GC日志中找到长时间停顿的具体日志信息（添加了-XX:+PrintReferenceGC参数），找到的日志片段如下所示。从日志中可以看出，真正执行GC动作的时间不是很长，但从准备开始GC，到真正开始GC之间所消耗的时间却占了绝大部分。</p>
<figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">2012-08-29T19：14：30.968+0800：10069.800：[<span class="string">GC10099.225：[SoftReference，0 refs，0.0000109 secs</span>]10099.226：[<span class="string">WeakReference，4072 refs，0.0012099 secs</span>]10099.227：[<span class="string">FinalReference，984 refs，1.5822450 secs</span>]10100.809：[<span class="string">PhantomReference，251 refs，0.0001394 secs</span>]10100.809：[<span class="string">JNI Weak Reference，0.0994015 secs</span>] [<span class="string">PSYoungGen：175672K-＞8528K（167360K）</span>]251523K-＞100182K（353152K），31.1580402 secs][Times：user=0.61 sys=0.52，real=31.16 secs]</span><br></pre></td></tr></table></figure>
<p>&emsp;&emsp;除GC日志之外，还观察到这个GUI程序内存变化的一个特点，当它最小化的时候，资源管理中显示的占用内存大幅度减小，但是虚拟内存则没有变化，因此怀疑程序在最小化时它的工作内存被自动交换到磁盘的页面文件之中了，这样发生GC时就有可能因为恢复页面文件的操作而导致不正常的GC停顿。</p>
<p>&emsp;&emsp;在MSDN上查证后确认了这种猜想，因此，在Java的GUI程序中要避免这种现象，可以加入参数“-Dsun.awt.keepWorkingSetOnMinimize=true”来解决。这个参数在许多AWT的程序上都有应用，例如JDK自带的Visual VM，用于保证程序在恢复最小化时能够立即响应。在这个案例中加入该参数后，问题得到解决。</p>
<hr>
<h2 id="第三节-实战：Eclipse运行速度调优"><a href="#第三节-实战：Eclipse运行速度调优" class="headerlink" title="第三节 实战：Eclipse运行速度调优"></a><strong>第三节 实战：Eclipse运行速度调优</strong></h2><p>&emsp;&emsp;很多Java开发人员都有这样一种观念：系统调优的工作都是针对服务端应用而言的，规模越大的系统，需要越专业的调优运维团队参与。这个观点不能说不对，上一节中作者所列举的案例确实都是服务端运维和调优的例子，但服务端应用需要调优，并不说明其他应用就不需要了，作为一个普通的Java开发人员，前面讲的各种 虚拟机的原理和最佳实践的方法距离我们并不遥远，开发者身边的很多场景都可以使用上面这些知识。下面就通过一个普通程序员日常工作中可以随时接触到的开发工具开始这次实战。</p>
<h3 id="3-1-调优前的程序运行状态"><a href="#3-1-调优前的程序运行状态" class="headerlink" title="3.1 调优前的程序运行状态"></a><strong>3.1 调优前的程序运行状态</strong></h3><p>&emsp;&emsp;作者使用Eclipse 3.5作为日常工作中的主要IDE工具，由于安装的插件比较大（如 Klocwork、ClearCase LT等）、代码也很多，启动Eclipse直到所有项目编译完成需要四五分钟。一直对开发环境的速度感到不满意，趁着编写这本书的机会，决定对Eclipse进行“动刀”调优。</p>
<p>&emsp;&emsp;作者机器的Eclipse运行平台是32位Windows 7系统，虚拟机为HotSpot VM 1.5 b64，硬件为ThinkPad X201，Intel i5 CPU，4GB物理内存。在初始的配置文件eclipse.ini中，除了指定JDK的路径、设置最大堆为512MB及开启了JMX管理（需要在VisualVM中收集原始数据）外，未作任何改动，原始配置内容如代码清单5-3 所示。</p>
<figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">代码清单<span class="number">5</span>-<span class="number">3</span> Eclipse <span class="number">3.5</span>初始配置</span><br><span class="line">-vm</span><br><span class="line">D：/_DevSpace/jdk1.<span class="number">5.0</span>/bin/javaw.exe</span><br><span class="line">-startup</span><br><span class="line">plugins/org<span class="selector-class">.eclipse</span><span class="selector-class">.equinox</span><span class="selector-class">.launcher_1</span>.<span class="number">0.201</span><span class="selector-class">.R35x_v20090715</span><span class="selector-class">.jar</span></span><br><span class="line">--launcher.library</span><br><span class="line">plugins/org<span class="selector-class">.eclipse</span><span class="selector-class">.equinox</span><span class="selector-class">.launcher</span><span class="selector-class">.win32</span><span class="selector-class">.win32</span><span class="selector-class">.x86_1</span>.<span class="number">0.200</span>.v20090519</span><br><span class="line">-product</span><br><span class="line">org<span class="selector-class">.eclipse</span><span class="selector-class">.epp</span><span class="selector-class">.package</span><span class="selector-class">.jee</span><span class="selector-class">.product</span></span><br><span class="line">--launcher.XXMaxPermSize</span><br><span class="line"><span class="number">256</span>M</span><br><span class="line">-showsplash</span><br><span class="line">org<span class="selector-class">.eclipse</span><span class="selector-class">.platform</span></span><br><span class="line">-vmargs</span><br><span class="line">-Dosgi.requiredJavaVersion=<span class="number">1.5</span></span><br><span class="line">-Xmx512m</span><br><span class="line">-Dcom<span class="selector-class">.sun</span><span class="selector-class">.management</span><span class="selector-class">.jmxremote</span></span><br></pre></td></tr></table></figure>
<p>&emsp;&emsp;为了与调优后的结果进行量化对比，调优开始前作者先做了一次初始数据测试。测试用例很简单，就是收集从Eclipse启动开始，直到所有插件加载完成为止的总耗时及运行状态数据，虚拟机的运行数据通过VisualVM及其扩展插件VisualGC进行采集。测试过程中反复启动Eclipse数次直到测试结果稳定后，取最后一次运行的结果作为数据样本（为了避免操作系统未能及时进行磁盘缓存而产生的影响），数据样本如图5-2所示。</p>
<p><img src="https://pic-1258215793.cos.ap-shanghai.myqcloud.com/content/20191201/201912010102.png" alt="Eclipse原始运行数据"></p>
<p>&emsp;&emsp;Eclipse启动的总耗时没有办法从监控工具中直接获得，因为VisualVM不可能知道Eclipse运行到什么阶段才算是启动完成。为了保证测试的准确性，作者写了一个简单的Eclipse插件，用于统计Eclipse的启动耗时。由于代码很简单，并且本书不是Eclispe RCP的开发教程，所以只列出代码清单5-4供读者参考，不再延伸讲解。</p>
<figure class="highlight actionscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line">--代码清单<span class="number">5</span><span class="number">-4</span> Eclipse启动耗时统计插件ShowTime.java代码：</span><br><span class="line"></span><br><span class="line"><span class="meta"><span class="meta-keyword">import</span> org.eclipse.jface.dialogs.MessageDialog;</span></span><br><span class="line"><span class="meta"><span class="meta-keyword">import</span> org.eclipse.swt.widgets.Display;</span></span><br><span class="line"><span class="meta"><span class="meta-keyword">import</span> org.eclipse.swt.widgets.Shell;</span></span><br><span class="line"><span class="meta"><span class="meta-keyword">import</span> org.eclipse.ui.IStartup;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">*统计Eclipse启动耗时</span></span><br><span class="line"><span class="comment">*@author zzm</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ShowTime</span> <span class="keyword">implements</span> <span class="title">IStartup</span></span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> earlyStartup()&#123;</span><br><span class="line">        Display.getDefault().syncExec(<span class="keyword">new</span> Runnable()&#123;</span><br><span class="line">            <span class="keyword">public</span> <span class="keyword">void</span> run()&#123;</span><br><span class="line">                long eclipseStartTime = Long.parseLong(System.getProperty(<span class="string">"eclipse.startTime"</span>));</span><br><span class="line">                long costTime = System.currentTimeMillis() - eclipseStartTime;</span><br><span class="line">                Shell shell = Display.getDefault().getActiveShell();</span><br><span class="line">                String message = <span class="string">"Eclipse启动耗时："</span> + costTime+<span class="string">"ms"</span>;</span><br><span class="line">                MessageDialog.openInformation(shell, <span class="string">"Information"</span>, message);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">--plugin.xml代码：</span><br><span class="line">&lt;?xml version=<span class="string">"1.0"</span>encoding=<span class="string">"UTF-8"</span>?&gt;</span><br><span class="line">&lt;?eclipse version=<span class="string">"3.4"</span>?&gt;</span><br><span class="line">&lt;plugin&gt;</span><br><span class="line">    &lt;extension point=<span class="string">"org.eclipse.ui.startup"</span>&gt;</span><br><span class="line">        &lt;startup <span class="class"><span class="keyword">class</span>="<span class="title">eclipsestarttime</span>.<span class="title">actions</span>.<span class="title">ShowTime</span>"/&gt;</span></span><br><span class="line"><span class="class">    &lt;/<span class="title">extension</span>&gt;</span></span><br><span class="line"><span class="class">&lt;/<span class="title">plugin</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>&emsp;&emsp;上述代码打包成jar后放到Eclipse的plugins目录中，反复启动几次后，插件显示的平均时间稳定在15秒左右，如图5-3所示。</p>
<p><img src="https://pic-1258215793.cos.ap-shanghai.myqcloud.com/content/20191201/201912010103.png" alt="耗时统计插件运行效果"></p>
<p>&emsp;&emsp;根据VisualGC和Eclipse插件收集到的信息，总结原始配置下的测试结果如下：</p>
<blockquote>
<ul>
<li>整个启动过程平均耗时约15秒。</li>
<li>最后一次启动的数据样本中，垃圾收集总耗时4.149秒，其中：Full GC被触发了19次，共耗时3.166秒；Minor GC被触发了378次，共耗时0.983秒。</li>
<li>加载类9115个，耗时4.114秒。</li>
<li>JIT的编译时间为1.999秒。</li>
<li>虚拟机512MB的堆内存被分配为40MB的新生代（31.5MB的Eden空间和2个4MB的 Surviver空间）及472MB的老年代。</li>
</ul>
</blockquote>
<p>&emsp;&emsp;客观地说，由于机器硬件还不错（请读者以2010年普通PC机的标准来衡量），15秒的启动时间其实还在可接受的范围以内，但是从VisualGC中反映的数据来看，主要问题是非用户程序时间（图5-2中的Compile Time、Class Loader Time、GC Time）非常高，占了整个启动过程耗时的一半以上（这里存在少许夸张成分，因为<br>如果JIT编译等动作是在后台线程完成的，用户程序在此期间也正常执行，所以并没有占用一半以上的绝对时间）。虚拟机后台占用太多时间也直接导致Eclipse在启动后的使用过程中经常有停顿的感觉，所以进行调优有较大的价值。</p>
<h3 id="3-2-升级JDK-1-6的性能变化及兼容问题"><a href="#3-2-升级JDK-1-6的性能变化及兼容问题" class="headerlink" title="3.2 升级JDK 1.6的性能变化及兼容问题"></a><strong>3.2 升级JDK 1.6的性能变化及兼容问题</strong></h3><p>&emsp;&emsp;对Eclipse进行调优的第一步就是先把虚拟机的版本做个升级，希望能先从虚拟机 版本上得到一些“免费的”性能提升。</p>
<p>&emsp;&emsp;每次JDK的大版本发布时，开发商肯定都会宣称虚拟机的运行速度比上一版本有了很大的提高，这虽然是个广告性质的宣言，经常被人从升级列表或技术白皮书中直接忽略过去，但从国内外的第三方评测数据来看，版本升级在某些方面确实带来了一定的性能改善，以下是一个第三方网站对JDK 1.5、1.6、1.7三个版本做的性能评测，分别测试了以下四个用例：</p>
<blockquote>
<ul>
<li>生成500万个字符串。</li>
<li>500万次ArrayList<string>数据插入，使用第一点生成的数据。</string></li>
<li>生成500万个HashMap&lt;String, Integer&gt;，每个键-值对通过并发线程计算，测试并发能力。</li>
<li>打印500万个ArrayList<string>中的值到文件，并重读回内存。</string></li>
</ul>
</blockquote>
<p>&emsp;&emsp;三个版本的JDK分别运行这些用例的测试程序，测试结果如图5-4所示。</p>
<p><img src="https://pic-1258215793.cos.ap-shanghai.myqcloud.com/content/20191201/201912010104.png" alt="JDK横向性能对比"></p>
<p>&emsp;&emsp;从这4个用例的测试结果来看，JDK 1.6比1.5有大约15%的性能提升，尽管对JDK仅测试这4个用例并不能说明什么问题，需要通过测试数据来量化描述一个JDK比旧版提升了多少是很难做到非常科学准确的（要做稍微靠谱一点的测试，可以使用SPECjvm2008来完成，或者把相应版本的TCK中数万个测试用例的性能数据对比一<br>下可能更有说服力），但我还是选择相信这次“软广告”性质的测试，把JDK版本升级到1.6 Update 21，升级的最主要理由是：本书是基于JDK 1.6编写的。</p>
<p>&emsp;&emsp;这次升级到JDK 1.6之后，性能有什么变化暂且不谈，在使用几分钟之后，作者的Eclipse就和前面几个服务端的案例一样“不负众望”地发生了内存溢出，如图5-5所示。</p>
<p><img src="https://pic-1258215793.cos.ap-shanghai.myqcloud.com/content/20191201/201912010105.png" alt="Eclipse OutOfMemoryError"></p>
<p>&emsp;&emsp;这次内存溢出完全出乎作者的意料：决定对Eclipse做调优是因为速度慢，但开发环境一直都很稳定，至少没有出现过内存溢出的问题，而这次升级除了eclipse.ini中的JVM路径改了之外，还未进行任何运行参数的调整，进到Eclipse主界面之后随便开了几个文件居然就抛出内存溢出异常了，难道JDK 1.6 Update21有哪个API出现了严重的泄漏问题吗？</p>
<p>&emsp;&emsp;事实上并不是JDK 1.6出现了什么问题，根据前面讲解的原理和工具，我们要查明这个异常的原因并且解决它一点也不困难。打开VisualVM，监视页签中的内存曲线部分，如图5-6和图5-7所示。</p>
<p><img src="https://pic-1258215793.cos.ap-shanghai.myqcloud.com/content/20191201/201912010106.png" alt="Java堆监视曲线"></p>
<p><img src="https://pic-1258215793.cos.ap-shanghai.myqcloud.com/content/20191201/201912010107.png" alt="永久代监视曲线"></p>
<p>&emsp;&emsp;在Java堆的监视曲线里，“堆大小”曲线与“使用的堆”曲线一直都有很大的间隔距离，每当两条曲线开始出现互相靠近的趋势时，“最大堆”曲线就会快速向上转向，而“使用的堆”曲线会向下转向。“最大堆”曲线向上是虚拟机内部在进行堆扩容，运行参数中并没有指定最小堆（-Xms）的值与最大堆（-Xmx）相等，所以堆容量一开始并没有扩展到最大值，而是根据使用情况进行伸缩扩展。“使用的堆”曲线向下是因为虚拟机内部触发了一次垃圾收集，一些废弃对象的空间被回收后，内存用量相应少，从图形上看，Java堆运作是完全正常的。但永久代的监视曲线就很有问题了，“PermGen大小”曲线与“使用的PermGen”曲线几乎完全重合在一起，这说明永久代中没有可回收的资源，所以“使用的PermGen”曲线不会向下发展，永久代中也没有空间可以扩展，所以“PermGen大小”曲线不能向上扩展。那么这次很明显是永久代导致的内存溢出。</p>
<p>&emsp;&emsp;再注意看图5-7中永久代的最大容量：“67，108，864个字节”，也就是64MB，这恰好是JDK在未使用-XX:MaxPermSize参数明确指定永久代最大容量时的默认值，无论JDK 1.5还是JDK 1.6，这个默认值都是64MB。对于Eclipse这种规模的Java程序来说，64MB的永久代内存空间显然是不够的，溢出很正常，那为何在JDK 1.5中没有发生过溢出呢？</p>
<p>&emsp;&emsp;在VisualVM的“概述-JVM参数”页签中，分别检查使用JDK 1.5和JDK 1.6运行Eclipse时的JVM参数，发现使用JDK 1.6时只有以下3个JVM参数，如代码清单5-5 所示。</p>
<figure class="highlight haml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">代码清单5-5 JDK 1.6的Eclipse运行期参数</span><br><span class="line">-<span class="ruby">Dcom.sun.management.jmxremote</span></span><br><span class="line"><span class="ruby">-Dosgi.requiredJavaVersion=<span class="number">1.5</span></span></span><br><span class="line"><span class="ruby">-Xmx512m</span></span><br></pre></td></tr></table></figure>
<p>&emsp;&emsp;而使用JDK 1.5运行时有4个JVM参数，其中多出来的一个正好就是设置永久代最大 容量的-XX：MaxPermSize=256M，如代码清单5-6所示。</p>
<figure class="highlight haml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">代码清单5-6 JDK 1.5的Eclipse运行期参数</span><br><span class="line">-<span class="ruby">Dcom.sun.management.jmxremote</span></span><br><span class="line"><span class="ruby">-Dosgi.requiredJavaVersion=<span class="number">1.5</span></span></span><br><span class="line"><span class="ruby">-Xmx512m</span></span><br><span class="line"><span class="ruby">-XX：MaxPermSize=<span class="number">256</span>M</span></span><br></pre></td></tr></table></figure>
<p>&emsp;&emsp;为什么会这样呢？作者从Eclipse的Bug List网站上找到答案：使用JDK 1.5时之所以有永久代容量这个参数，是因为在eclipse.ini中存在“-launcher.XXMaxPermSize 256M”这项设置，当launcher—Windows下的可执行程序eclipse.exe检测到是Eclipse运行在Sun公司的虚拟机上的话，就会把参数值转化为-XX:MaxPermSize传递给虚拟机进程，因为三大商用虚拟机中只有Sun系列的虚拟机才有永久代的概念，即只有HotSpot虚拟机需要设置这个参数，JRockit虚拟机和IBM J9虚拟机都不需要设置。</p>
<p>&emsp;&emsp;2010年4月10日，Oracle正式完成了对Sun的收购，此后无论是网页还是具体的程序产品，提供商都从Sun变为了Oracle，而eclipse.exe就是根据程序提供商判断是否是Sun的虚拟机，当JDK 1.6 Update21中java.exe、javaw.exe 的“Company”属性从“Sun Microsystems Inc.”变为“Oracle Corporation”之后，Eclipse就完全不认识这个虚拟机了，因此没有把最大永久代的参数传递过去。</p>
<p>&emsp;&emsp;了解原因之后，解决方案就简单了，launcher不认识就只好由人来告诉它，在eclipse.ini中明确指定-XX：MaxPermSize=256M这个参数就可以了。</p>
<h3 id="3-3-编译时间和类加载时间的优化"><a href="#3-3-编译时间和类加载时间的优化" class="headerlink" title="3.3 编译时间和类加载时间的优化"></a><strong>3.3 编译时间和类加载时间的优化</strong></h3><p>&emsp;&emsp;从Eclipse启动时间上看，升级到JDK 1.6所带来的性能提升是……嗯？基本上没有 提升？多次测试的平均值与JDK 1.5的差距完全在实验误差范围之内。</p>
<p>&emsp;&emsp;各位读者不必失望，Sun JDK 1.6性能白皮书描述的众多相对于JDK 1.5的提升不至于全部是广告，虽然总启动时间没有减少，但在查看运行细节的时候，却发现了一件很值得注意的事情：在JDK 1.6中启动完Eclipse所消耗的类加载时间比JDK 1.5长了接近一倍，不要看反了，这里写的是1.6的类加载比1.5慢一倍，测试结果 如代码清单5-7所示，反复测试多次仍然是相似的结果。</p>
<figure class="highlight lsl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">代码清单<span class="number">5</span><span class="number">-7</span> JDK <span class="number">1.5</span>和<span class="number">1.6</span>中的类加载时间对比</span><br><span class="line"></span><br><span class="line">使用JDK <span class="number">1.6</span>的类加载时间：</span><br><span class="line">C：\Users\IcyFenix＞jps</span><br><span class="line"><span class="number">3552</span></span><br><span class="line"><span class="number">6372</span> org.eclipse.equinox.launcher_1<span class="number">.0</span><span class="number">.201</span>.R35x_v20090715.jar</span><br><span class="line"><span class="number">6900</span> Jps</span><br><span class="line"></span><br><span class="line">C：\Users\IcyFenix＞jstat-class <span class="number">6372</span></span><br><span class="line">Loaded Bytes Unloaded Bytes Time</span><br><span class="line"><span class="number">7917</span> <span class="number">10190.3</span> <span class="number">0</span> <span class="number">0.0</span> <span class="number">8.18</span></span><br><span class="line"></span><br><span class="line">使用JDK <span class="number">1.5</span>的类加载时间：</span><br><span class="line">C：\Users\IcyFenix＞jps</span><br><span class="line"><span class="number">3552</span></span><br><span class="line"><span class="number">7272</span> Jps</span><br><span class="line"><span class="number">7216</span> org.eclipse.equinox.launcher_1<span class="number">.0</span><span class="number">.201</span>.R35x_v20090715.jar</span><br><span class="line"></span><br><span class="line">C：\Users\IcyFenix＞jstat-class <span class="number">7216</span></span><br><span class="line">Loaded Bytes Unloaded Bytes Time</span><br><span class="line"><span class="number">7902</span> <span class="number">9691.2</span> <span class="number">3</span> <span class="number">2.6</span> <span class="number">4.34</span></span><br></pre></td></tr></table></figure>
<p>&emsp;&emsp;在本例中类加载时间上的差距并不能作为一个普遍性的测试结果去说明JDK 1.6的类加载必然比1.5慢，作者测试了自己机器上的Tomcat和ClassFish启动过程，并没有出现类似的差距。在国内最大的Java社区中，作者发起过关于此问题的讨论，从参与者反馈的测试结果来看，此问题只在一部分机器上存在，而且JDK 1.6的各<br>个update版之间也存在很大差异。</p>
<p>&emsp;&emsp;多次试验后，发现在作者机器上的两个JDK进行类加载时，字节码验证部分的耗时差 距尤其严重。考虑到实际情况：Eclipse使用者甚多，它的编译代码我们认为是可靠的，不需要在加载的时候再进行字节码验证，因此通过参数-Xverify:none禁止掉字节码验证过程也可作为一项优化措施。加入这个参数后，两个版本的JDK类加载速度都有所提高，JDK 1.6的类加载速度仍然比1.5慢，但是两者的耗时已经接近了许多，测试数据如代码清单5-8所示。关于类与类加载的话题，譬如刚刚提到的字节码验证是怎么回事，本书专门规划了两个章节进行详细讲解，在此不再延伸。</p>
<figure class="highlight lsl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">代码清单<span class="number">5</span><span class="number">-8</span> JDK <span class="number">1.5</span>和<span class="number">1.6</span>中取消字节码验证后的类加载时间对比</span><br><span class="line"></span><br><span class="line">使用JDK <span class="number">1.6</span>的类加载时间：</span><br><span class="line">C：\Users\IcyFenix＞jps</span><br><span class="line"><span class="number">5512</span> org.eclipse.equinox.launcher_1<span class="number">.0</span><span class="number">.201</span>.R35x_v20090715.jar</span><br><span class="line"><span class="number">5596</span> Jps</span><br><span class="line"></span><br><span class="line">C：\Users\IcyFenix＞jstat-class <span class="number">5512</span></span><br><span class="line">Loaded Bytes Unloaded Bytes Time</span><br><span class="line"><span class="number">6749</span> <span class="number">8837.0</span> <span class="number">0</span> <span class="number">0.0</span> <span class="number">3.94</span></span><br><span class="line"></span><br><span class="line">使用JDK <span class="number">1.5</span>的类加载时间：</span><br><span class="line">C：\Users\IcyFenix＞jps</span><br><span class="line"><span class="number">4724</span> org.eclipse.equinox.launcher_1<span class="number">.0</span><span class="number">.201</span>.R35x_v20090715.jar</span><br><span class="line"><span class="number">5412</span> Jps</span><br><span class="line"></span><br><span class="line">C：\Users\IcyFenix＞jstat-class <span class="number">4724</span></span><br><span class="line">Loaded Bytes Unloaded Bytes Time</span><br><span class="line"><span class="number">6885</span> <span class="number">9109.7</span> <span class="number">3</span> <span class="number">2.6</span> <span class="number">3.10</span></span><br></pre></td></tr></table></figure>
<p>&emsp;&emsp;在取消字节码验证之后，JDK 1.5的平均启动时间降到了13秒，而JDK 1.6的测试数 据平均比JDK 1.5快1秒，平均下降到12秒左右，如图5-8所示。在类加载时间仍然落后的情况下，依然可以看到JDK 1.6在性能上比JDK 1.5略有优势，说明至少在Eclipse启动这个测试用例上，升级JDK版本确实能带来一些“免费的”性能提升。</p>
<p><img src="https://pic-1258215793.cos.ap-shanghai.myqcloud.com/content/20191201/201912010108.png" alt="运行在JDK 1.6下取消字节码验证的启动时间"></p>
<p>&emsp;&emsp;前面说过，除了类加载时间以外，在VisualGC的监视曲线中显示了两项很大的非用户程序耗时：编译时间（Compile Time）和垃圾收集时间（GC Time）。垃圾收集时间读者应该非常清楚了，而编译时间是什么？程序在运行之前不是已经编译了吗？虚拟机的JIT编译与垃圾收集一样，是本书的一个重要部分，后面有专门章节讲解，这里先简单介绍一下：<strong>编译时间</strong>是指虚拟机的<strong>JIT编译器</strong>（Just In Time Compiler）编译<strong>热点代码</strong>（Hot Spot Code）的耗时。我们知道Java语言为了实现跨平台的特性，Java代码编译出来后形成的Class文件中储存的是字节码（ByteCode），虚拟机通过解释方式执行字节码命令，比起C/C++编译成本地二进制代码来说，速度要慢不少。为了解决程序解释执行的速度问题，JDK 1.2以后，虚拟机内置了两个运行时编译器，如果一段Java方法被调用的次数到达一定程度，就会被判定为热代码，从而交给JIT编译器即时编译为本地代码，以提高运行速度（这就是HotSpot虚拟机名字的由来）。甚至有可能在运行期动态编译比C/C++的编译器静态编译出来的代码更优秀，因为运行期可以收集很多编译器无法知道的信息，甚至可以采用一些很激进的优化手段，在优化条件不成立的时候再逆优化退回来。所以Java程序只要代码没有问题（主要是泄漏问题，如内存泄漏、连接泄漏），随着代码被编译得越来越彻底，运行速度应当是越来越快。Java运行期编译最大的缺点就是编译需要消耗程序正常的运行时间，也就是上面所说的“编译时间”。</p>
<p>&emsp;&emsp;虚拟机提供了一个参数-Xint禁止编译器运作，强制虚拟机对字节码采用纯解释方式执行。如果读者想使用这个参数省下Eclipse启动中那2秒的编译时间获得一个“更好看”的成绩的话，那恐怕要失望了，加上这个参数之后虽然编译时间确实下降到0，但Eclipse启动的总时间将剧增到27秒。看来这个参数现在最大的作用就是让用户缅怀一下JDK 1.2之前那令人心酸和心碎的运行速度。</p>
<p>&emsp;&emsp;与解释执行相对应的另一方面，虚拟机还有力度更强的编译器：当虚拟机运行在client模式的时候，使用的是一个代号为C1的轻量级编译器，另外还有一个代号为C2的相对重量级的编译器，它能提供更多的优化措施。如果使用-server模式的虚拟机启动Eclipse将会用到C2编译器，这时从VisualGC可以看到启动过程中虚拟机 使用了超过15秒的时间去进行代码编译。如果读者的工作习惯是长时间不关闭Eclipse的话，C2编译器所消耗的额外编译时间最终还是会在运行速度的提升之中赚回来，这样使用-server模式也是一个不错的选择。不过至少在本次实战中，我们还是继续选用-client虚拟机来运行Eclipse。</p>
<h3 id="3-4-调整内存设置控制垃圾收集频率"><a href="#3-4-调整内存设置控制垃圾收集频率" class="headerlink" title="3.4 调整内存设置控制垃圾收集频率"></a><strong>3.4 调整内存设置控制垃圾收集频率</strong></h3><p>&emsp;&emsp;三大块非用户程序时间中，还剩下GC时间没有调整，而GC时间却是其中最重要的一块，并不只是因为它是耗时最长的一块，更因为它是一个持续稳定的过程。由于我们所做的测试是在检测程序的启动时间，类加载和编译时间在这项测试中的影响力被大幅度放大了。在绝大多数的应用中，不可能出现持续不断的类被加载和卸载。 在程序运行一段时间后，热点方法不断被编译，新的热点方法数量也总会下降，但是垃圾收集是随着程序的运行而不断运作的，所以它对性能的影响才尤为重要。</p>
<p>&emsp;&emsp;在Eclipse启动的原始数据样本中，短短15秒类共发生了19次Full GC和378次 Minor GC，一共397次GC，共造成了超过4秒的停顿，也就是超过1/4的时间都是在进行垃圾收集，这个运行数据看起来实在是太糟糕了。</p>
<p>&emsp;&emsp;首先来解决新生代中的Minor GC，虽然GC的总时间只有不到1秒，但却发生了378次之多。从VisualGC的线程监视中看到Eclipse启动期间一共发起了超过70个线程，同时在运行的线程数超过25个，每当发生一次垃圾收集的动作，所有的用户线程都必须跑到最近的一个安全点（SafePoint），然后挂起线程等待垃圾回收。这样 过于频繁的GC就会导致很多没有必要的安全点检测、线程挂起及恢复操作。</p>
<p>&emsp;&emsp;新生代GC频繁发生，很明显是由于虚拟机分配给新生代的空间太小而导致的，Eden区加上一个Survivor区还不到35MB，因此很有必要使用-Xmn参数调整新生代的大小。</p>
<p>&emsp;&emsp;再来看一看那19次Full GC，看起来19次并“不多”（相对于378次Minor GC来说），但总共消耗了3.166秒，占了绝大部分的GC时间，降低GC时间的主要目标就 是降低这部分时间。从VisualGC的曲线图上看得不够精确，这次直接从GC日志中分析一下这些Full GC是如何产生的，代码清单5-9中是启动最开始的2.5秒内发生的 10次Full GC的记录。</p>
<figure class="highlight lsl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">代码清单<span class="number">5</span><span class="number">-9</span> Full GC记录</span><br><span class="line"><span class="number">0.278</span>：[GC <span class="number">0.278</span>：[DefNew：<span class="number">574</span>K-＞<span class="number">33</span>K（<span class="number">576</span>K），<span class="number">0.0012562</span> secs]<span class="number">0.279</span>：[Tenured：<span class="number">1467</span>K-＞<span class="number">997</span>K（<span class="number">1536</span>K），<span class="number">0.0181775</span> secs]<span class="number">1920</span>K-＞ <span class="number">997</span>K（<span class="number">2112</span>K），<span class="number">0.0195257</span> secs]</span><br><span class="line"><span class="number">0.312</span>：[GC <span class="number">0.312</span>：[DefNew：<span class="number">575</span>K-＞<span class="number">64</span>K（<span class="number">576</span>K），<span class="number">0.0004974</span> secs]<span class="number">0.312</span>：[Tenured：<span class="number">1544</span>K-＞<span class="number">1608</span>K（<span class="number">1664</span>K），<span class="number">0.0191592</span> secs]<span class="number">1980</span>K＞<span class="number">1608</span>K（<span class="number">2240</span>K），<span class="number">0.0197396</span> secs]</span><br><span class="line"><span class="number">0.590</span>：[GC <span class="number">0.590</span>：[DefNew：<span class="number">576</span>K-＞<span class="number">64</span>K（<span class="number">576</span>K），<span class="number">0.0006360</span> secs]<span class="number">0.590</span>：[Tenured：<span class="number">2675</span>K-＞<span class="number">2219</span>K（<span class="number">2684</span>K），<span class="number">0.0256020</span> secs]<span class="number">3090</span>K＞<span class="number">2219</span>K（<span class="number">3260</span>K），<span class="number">0.0263501</span> secs]</span><br><span class="line"><span class="number">0.958</span>：[GC <span class="number">0.958</span>：[DefNew：<span class="number">551</span>K-＞<span class="number">64</span>K（<span class="number">576</span>K），<span class="number">0.0011433</span> secs]<span class="number">0.959</span>：[Tenured：<span class="number">3979</span>K-＞<span class="number">3470</span>K（<span class="number">4084</span>K），<span class="number">0.0419335</span> secs]<span class="number">4222</span>K＞<span class="number">3470</span>K（<span class="number">4660</span>K），<span class="number">0.0431992</span> secs]</span><br><span class="line"><span class="number">1.575</span>：[Full GC <span class="number">1.575</span>：[Tenured：<span class="number">4800</span>K-＞<span class="number">5046</span>K（<span class="number">5784</span>K），<span class="number">0.0543136</span> secs]<span class="number">5189</span>K-＞<span class="number">5046</span>K（<span class="number">6360</span>K），[Perm：<span class="number">12287</span>K-＞<span class="number">12287</span>K（<span class="number">12288</span>K）]， <span class="number">0.0544163</span> secs]</span><br><span class="line"><span class="number">1.703</span>：[GC <span class="number">1.703</span>：[DefNew：<span class="number">703</span>K-＞<span class="number">63</span>K（<span class="number">704</span>K），<span class="number">0.0012609</span> secs]<span class="number">1.705</span>：[Tenured：<span class="number">8441</span>K-＞<span class="number">8505</span>K（<span class="number">8540</span>K），<span class="number">0.0607638</span> secs]<span class="number">8691</span>K＞<span class="number">8505</span>K（<span class="number">9244</span>K），<span class="number">0.0621470</span> secs]</span><br><span class="line"><span class="number">1.837</span>：[GC <span class="number">1.837</span>：[DefNew：<span class="number">1151</span>K-＞<span class="number">64</span>K（<span class="number">1152</span>K），<span class="number">0.0020698</span> secs]<span class="number">1.839</span>：[Tenured：<span class="number">14616</span>K-＞<span class="number">14680</span>K（<span class="number">14688</span>K），<span class="number">0.0708748</span> secs]<span class="number">15035</span>K-＞<span class="number">14680</span>K（<span class="number">15840</span>K），<span class="number">0.0730947</span> secs]</span><br><span class="line"><span class="number">2.144</span>：[GC <span class="number">2.144</span>：[DefNew：<span class="number">1856</span>K-＞<span class="number">191</span>K（<span class="number">1856</span>K），<span class="number">0.0026810</span> secs]<span class="number">2.147</span>：[Tenured：<span class="number">25092</span>K-＞<span class="number">24656</span>K（<span class="number">25108</span>K），<span class="number">0.1112429</span> secs]<span class="number">26172</span>K-＞<span class="number">24656</span>K（<span class="number">26964</span>K），<span class="number">0.1141099</span> secs]</span><br><span class="line"><span class="number">2.337</span>：[GC <span class="number">2.337</span>：[DefNew：<span class="number">1914</span>K-＞<span class="number">0</span>K（<span class="number">3136</span>K），<span class="number">0.0009697</span> secs]<span class="number">2.338</span>：[Tenured：<span class="number">41779</span>K-＞<span class="number">27347</span>K（<span class="number">42056</span>K），<span class="number">0.0954341</span> secs]<span class="number">42733</span>K-＞<span class="number">27347</span>K（<span class="number">45192</span>K），<span class="number">0.0965513</span> secs]</span><br><span class="line"><span class="number">2.465</span>：[GC <span class="number">2.465</span>：[DefNew：<span class="number">2490</span>K-＞<span class="number">0</span>K（<span class="number">3456</span>K），<span class="number">0.0011044</span> secs]<span class="number">2.466</span>：[Tenured：<span class="number">46379</span>K-＞<span class="number">27635</span>K（<span class="number">46828</span>K），<span class="number">0.0956937</span> secs]<span class="number">47621</span>K-＞<span class="number">27635</span>K（<span class="number">50284</span>K），<span class="number">0.0969918</span> secs]</span><br></pre></td></tr></table></figure>
<p>&emsp;&emsp;括号中的数字代表着老年代的容量，这组GC日志显示了10次Full GC发生的原因全部都是老年代空间耗尽，每发生一次Full GC都伴随着一次老年代空间扩容：1536KB→1664KB→2684KB→……→42056KB→46828KB，10次GC以后老年代容量从起始的1536KB扩大到46828KB，当15秒后Eclipse启动完成时，老年代容量扩大到了103428KB，代码编译开始后，老年代容量达到顶峰473MB，整个Java堆达到最大容量512MB。</p>
<p>&emsp;&emsp;日志还显示有些时候内存回收状况很不理想，空间扩容成为获取可用内存的最主要手段，譬如，“Tenured：25092K→24656K（25108K），0.1112429 secs”代表老年代的当前容量为25108KB，内存使用到25092KB的时候发生Full GC，花费0.11秒把内存使用降低到24656KB，只回收了不到500KB的内存，这次GC基本没有什么回收效果，仅仅做了扩容，扩容过程比起回收过程可以看做是基本不需要花费时间的，所以说这0.11秒几乎是白白浪费了。</p>
<p>&emsp;&emsp;由上述分析可以得出结论：Eclipse启动时Full GC大多数是由于老年代容量扩展而导致的，由永久代空间扩展而导致的也有一部分。为了避免这些扩展所带来的性能浪费，我们可以把-Xms和-XX:PermSize参数值分别设置为-Xmx和-XX: PermSizeMax参数值，强制虚拟机在启动的时候就把老年代和永久代的容量固定下来，避免运行时自动扩展。</p>
<p>&emsp;&emsp;根据分析，优化计划确定为：把新生代容量提升到128MB，避免新生代频繁GC；把Java堆、永久代的容量分别固定为512MB和96MB，避免内存扩展。这几个数值都是根据机器硬件、Eclipse插件和工程数量来决定的，读者实战的时候应根据VisualGC中收集到的实际数据进行设置。改动后的eclipse.ini配置如代码清单510所示。</p>
<figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">代码清单<span class="number">5</span>-<span class="number">10</span> 内存调整后的Eclipse配置文件</span><br><span class="line">-vm</span><br><span class="line">D：/_DevSpace/jdk1.<span class="number">6.0</span>_21/bin/javaw.exe</span><br><span class="line">-startup</span><br><span class="line">plugins/org<span class="selector-class">.eclipse</span><span class="selector-class">.equinox</span><span class="selector-class">.launcher_1</span>.<span class="number">0.201</span><span class="selector-class">.R35x_v20090715</span><span class="selector-class">.jar</span></span><br><span class="line">--launcher.library</span><br><span class="line">plugins/org<span class="selector-class">.eclipse</span><span class="selector-class">.equinox</span><span class="selector-class">.launcher</span><span class="selector-class">.win32</span><span class="selector-class">.win32</span><span class="selector-class">.x86_1</span>.<span class="number">0.200</span>.v20090519</span><br><span class="line">-product</span><br><span class="line">org<span class="selector-class">.eclipse</span><span class="selector-class">.epp</span><span class="selector-class">.package</span><span class="selector-class">.jee</span><span class="selector-class">.product</span></span><br><span class="line">-showsplash</span><br><span class="line">org<span class="selector-class">.eclipse</span><span class="selector-class">.platform</span></span><br><span class="line">-vmargs</span><br><span class="line">-Dosgi.requiredJavaVersion=<span class="number">1.5</span></span><br><span class="line">-Xverify：<span class="attribute">none</span></span><br><span class="line">-Xmx512m</span><br><span class="line">-Xms512m</span><br><span class="line">-Xmn128m</span><br><span class="line">-XX：PermSize=<span class="number">96</span>m</span><br><span class="line">-XX：MaxPermSize=<span class="number">96</span>m</span><br></pre></td></tr></table></figure>
<p>&emsp;&emsp;现在的这个配置之下，GC次数已经大幅度降低，图5-9是Eclipse启动后1分钟的监视曲线，只发生了8次Minor GC和4次Full GC，总耗时为1.928秒。</p>
<p><img src="https://pic-1258215793.cos.ap-shanghai.myqcloud.com/content/20191201/201912010109.png" alt="GC调整后的运行数据"></p>
<p>&emsp;&emsp;这个结果已经算是基本正常，但是还存在一点瑕疵：从Old Gen曲线上看，永久代直接固定在384MB，而内存使用量只有66MB，并且一直很平滑，完全不应该发生Full GC才对，那4次Full GC是怎么来的？使用jstat-gccause查询一下最近一次GC的原因，见代码清单5-11。</p>
<figure class="highlight lsl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">代码清单<span class="number">5</span><span class="number">-11</span> 查询GC原因</span><br><span class="line">C：\Users\IcyFenix&gt;jps</span><br><span class="line"><span class="number">9772</span> Jps</span><br><span class="line"><span class="number">4068</span> org.eclipse.equinox.launcher_1<span class="number">.0</span><span class="number">.201</span>.R35x_v20090715.jar</span><br><span class="line">C：\Users\IcyFenix&gt;jstat-gccause <span class="number">4068</span></span><br><span class="line">S0 S1 E O P YGC YGCT FGC FGCT GCT LGCC GCC</span><br><span class="line"><span class="number">0.00</span> <span class="number">0.00</span> <span class="number">1.00</span> <span class="number">14.81</span> <span class="number">39.29</span> <span class="number">6</span> <span class="number">0.422</span> <span class="number">20</span> <span class="number">5.992</span> <span class="number">6.414</span></span><br><span class="line">System.gc() No GC</span><br></pre></td></tr></table></figure>
<p>&emsp;&emsp;从LGCC（Last GC Cause）中看到原来是代码调用System.gc()显式触发的GC，在内存设置调整后，这种显式GC不符合我们的期望，因此在eclipse.ini中加入参数-XX:+DisableExplicitGC屏蔽掉System.gc()。再次测试发现启动期间的Full GC已经完全没有了，只有6次Minor GC，耗时417毫秒，与调优前4.149秒的测试样本相比，正好是十分之一。进行GC调优后Eclipse的启动时间下降非常明显，比整个GC时间降低的绝对值还大，现在启动只需要7秒多，如图5-10所示。</p>
<p><img src="https://pic-1258215793.cos.ap-shanghai.myqcloud.com/content/20191201/201912010110.png" alt="Eclipse启动时间"></p>
<h3 id="3-5-选择收集器降低延迟"><a href="#3-5-选择收集器降低延迟" class="headerlink" title="3.5 选择收集器降低延迟"></a><strong>3.5 选择收集器降低延迟</strong></h3><p>&emsp;&emsp;现在Eclipse启动已经比较迅速了，但我们的调优实战还没有结束，毕竟Eclipse是拿来写程序的，不是拿来测试启动速度的。我们不妨再在Eclipse中测试一个非常常用但又比较耗时的操作：代码编译。图5-11是当前配置下Eclipse进行代码编译时的运行数据，从图中可以看出，新生代每次回收耗时约65毫秒，老年代每次回收 耗时约725毫秒。对于用户来说，新生代GC的耗时还好，65毫秒在使用中无法察觉到，而老年代每次GC停顿的时间接近1秒钟，虽然比较长时间才会出现一次，但停顿还是太长了一些。</p>
<p><img src="https://pic-1258215793.cos.ap-shanghai.myqcloud.com/content/20191201/201912010111.png" alt="编译期间运行数据"></p>
<p>&emsp;&emsp;再注意看一下编译期间的CPU资源使用状况，图5-12是Eclipse在编译期间的CPU使用率曲线图，整个编译过程中平均只使用了不到30%的CPU资源，垃圾收集的CPU使用率曲线更是几乎与坐标横轴紧贴在一起，这说明CPU资源还有很多可利用的余地。</p>
<p>&emsp;&emsp;列举GC停顿时间、CPU资源富余的目的，都是为接下来替换掉Client模式的虚拟机 中默认的新生代及老年代串行收集器做铺垫。</p>
<p>&emsp;&emsp;Eclipse应当算是与使用者交互非常频繁的应用程序，由于代码太多，作者习惯在做全量编译或清理动作的时候，使用“Run in Backgroup”功能一边编译一边继续工作。回顾一下在第3章提到的几种收集器，很容易想到CMS是最符合这类场景的收集器。因此尝试在eclipse.ini中再加入两个参数-XX:+UseConcMarkSweepGC和XX:+UseParNewGC（ParNew收集器是使用CMS收集器后的默认新生代收集器，写上仅是为了使得配置更加清晰），要求虚拟机在新生代和老年代分别使用ParNew和CMS收集器进行垃圾回收。指定收集器之后，再次测试的结果如图5-13所示，与原来使用的串行收集器对比，新生代停顿从每次65毫秒下降到了每次53毫秒，而老年代的停顿时间更是从725毫秒大幅下降到了36毫秒。</p>
<p><img src="https://pic-1258215793.cos.ap-shanghai.myqcloud.com/content/20191201/201912010113.png" alt="指定ParNew和CMS收集器后的GC数据"></p>
<p>&emsp;&emsp;当然，CMS的停顿阶段只是收集过程中的一小部分，并不是真的把垃圾收集时间从 725毫秒变成36毫秒了。在GC日志中可以看到CMS与程序并发的时间约为400毫秒。不过由于CMS默认老年代使用了68%就进行收集，所以Full GC次数上升到了6次，为了避免总体吞吐量下降得太厉害，使用-XX:CMSInitiatingOccupancyFraction=85将GC临界值提升到85%，修改-XX:CMSInitiatingOccupancyFraction参数后，Full GC次数下降至3次，这样收集器的运作结果就比较令人满意了。</p>
<p>&emsp;&emsp;到这里为止，对于虚拟机内存的调优就基本结束了，这次实战可以看做是一次简化的服务端调优过程，服务端调优有可能还会出现在更多方面，如数据库、资源池、 磁盘I/O等，对于虚拟机内存部分的优化，与这次实战中的思路没有太大差别。即使读者实际工作中接触不到服务器，根据自己的工作环境做一些试验，总结几个参数让自己日常工作环境的速度有较大幅度的提升也是很划算的。最终eclipse.ini的配置如代码清单5-12所示。</p>
<figure class="highlight haml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">代码清单5-12 修改收集器配置后的Eclipse配置</span><br><span class="line">-<span class="ruby">vm</span></span><br><span class="line"><span class="ruby">D：/_DevSpace/jdk1.<span class="number">6.0_21</span>/bin/javaw.exe</span></span><br><span class="line"><span class="ruby">-startup</span></span><br><span class="line"><span class="ruby">plugins/org.eclipse.equinox.launcher_1.<span class="number">0</span>.<span class="number">201</span>.R35x_v20090715.jar</span></span><br><span class="line"><span class="ruby">--launcher.library</span></span><br><span class="line"><span class="ruby">plugins/org.eclipse.equinox.launcher.win32.win32.x86_1.<span class="number">0</span>.<span class="number">200</span>.v20090519</span></span><br><span class="line"><span class="ruby">-product</span></span><br><span class="line"><span class="ruby">org.eclipse.epp.package.jee.product</span></span><br><span class="line"><span class="ruby">-showsplash</span></span><br><span class="line"><span class="ruby">org.eclipse.platform</span></span><br><span class="line"><span class="ruby">-vmargs</span></span><br><span class="line"><span class="ruby">-Dcom.sun.management.jmxremote</span></span><br><span class="line"><span class="ruby">-Dosgi.requiredJavaVersion=<span class="number">1.5</span></span></span><br><span class="line"><span class="ruby">-Xverify：none</span></span><br><span class="line"><span class="ruby">-Xmx512m</span></span><br><span class="line"><span class="ruby">-Xms512m</span></span><br><span class="line"><span class="ruby">-Xmn128m</span></span><br><span class="line"><span class="ruby">-XX：PermSize=<span class="number">96</span>m</span></span><br><span class="line"><span class="ruby">-XX：MaxPermSize=<span class="number">96</span>m</span></span><br><span class="line"><span class="ruby">-XX：+DisableExplicitGC</span></span><br><span class="line"><span class="ruby">-Xnoclassgc</span></span><br><span class="line"><span class="ruby">-XX：+UseParNewGC</span></span><br><span class="line"><span class="ruby">-XX：+UseConcMarkSweepGC</span></span><br><span class="line"><span class="ruby">-XX：CMSInitiatingOccupancyFraction=<span class="number">85</span></span></span><br></pre></td></tr></table></figure>
<hr>
<h2 id="第四节-总结"><a href="#第四节-总结" class="headerlink" title="第四节 总结"></a><strong>第四节 总结</strong></h2><p>&emsp;&emsp;Java虚拟机的内存管理与垃圾收集是虚拟机结构体系中最重要的组成部分，对我们程序的性能和稳定性有着非常大的影响，在本书的第2～5章中，作者从理论知识、异常现象、代码、工具、案例和实战等几个方面对其进行讲解，希望读者能有所收获。</p>
<p>&emsp;&emsp;本书关于虚拟机内存管理的部分到此为止就结束了，下一章我们将开始学习Class文件与虚拟机执行子系统方面的知识。</p>
<hr>
<p><em>参考博客和文章书籍等：</em></p>
<blockquote>
<p>《深入理解Java虚拟机》</p>
</blockquote>
<p><em>因博客主等未标明不可引用，若部分内容涉及侵权请及时告知，我会尽快修改和删除相关内容</em></p>

      
    </div>
    
    
    

    

    

    

    
      <div>
         ﻿<div>
    
        <div style="text-align:center;color: #ccc;font-size:14px;">-------------本文结束<i class="fa fa-paw"></i>感谢您的阅读-------------</div>
    
</div>

      </div>
    
    
    <footer class="post-footer">
      
        <div class="post-tags">
          
            <a href="/tags/java/" rel="tag"># java</a>
          
            <a href="/tags/jvm/" rel="tag"># jvm</a>
          
        </div>
      

      
      
      

      
        <div class="post-nav">
          <div class="post-nav-next post-nav-item">
            
              <a href="/2019112501.html" rel="next" title="虚拟机性能监控和故障处理工具">
                <i class="fa fa-chevron-left"></i> 虚拟机性能监控和故障处理工具
              </a>
            
          </div>

          <span class="post-nav-divider"></span>

          <div class="post-nav-prev post-nav-item">
            
              <a href="/2019120301.html" rel="prev" title="类文件结构">
                类文件结构 <i class="fa fa-chevron-right"></i>
              </a>
            
          </div>
        </div>
      

      
      
    </footer>
  </div>
  
  
  
  </article>



    <div class="post-spread">
      
    </div>
  </div>


          </div>
          


          

  
     <div class="comments" id="comments">
       

<script src="https://utteranc.es/client.js"
        repo="LAILAIWA/LAILAIWA.github.io"
        issue-term="pathname"
        label="💬Comments"
        theme="github-light"
        crossorigin="anonymous"
        async>
</script>



     </div>
  



        </div>
        
          
  
  <div class="sidebar-toggle">
    <div class="sidebar-toggle-line-wrap">
      <span class="sidebar-toggle-line sidebar-toggle-line-first"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-middle"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-last"></span>
    </div>
  </div>

  <aside id="sidebar" class="sidebar">
    
    <div class="sidebar-inner">

      

      
        <ul class="sidebar-nav motion-element">
          <li class="sidebar-nav-toc sidebar-nav-active" data-target="post-toc-wrap">
            文章目录
          </li>
          <li class="sidebar-nav-overview" data-target="site-overview-wrap">
            站点概览
          </li>
        </ul>
      

      <section class="site-overview-wrap sidebar-panel">
        <div class="site-overview">
          <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
            
              <img class="site-author-image" itemprop="image"
                src="https://pic-1258215793.cos.ap-shanghai.myqcloud.com/cover/riho_yoshioka1.jpg"
                alt="沂水" />
            
              <p class="site-author-name" itemprop="name">沂水</p>
              <p class="site-description motion-element" itemprop="description">记录编程点滴，写点生活中的酸甜</p>
          </div>

          <nav class="site-state motion-element">

            
              <div class="site-state-item site-state-posts">
              
                <a href="/archives/">
              
                  <span class="site-state-item-count">238</span>
                  <span class="site-state-item-name">日志</span>
                </a>
              </div>
            

            
              
              
              <div class="site-state-item site-state-categories">
                <a href="/categories/index.html">
                  <span class="site-state-item-count">8</span>
                  <span class="site-state-item-name">分类</span>
                </a>
              </div>
            

            
              
              
              <div class="site-state-item site-state-tags">
                <a href="/tags/index.html">
                  <span class="site-state-item-count">84</span>
                  <span class="site-state-item-name">标签</span>
                </a>
              </div>
            

          </nav>

          
            <div class="feed-link motion-element">
              <a href="/atom.xml" rel="alternate">
                <i class="fa fa-rss"></i>
                RSS
              </a>
            </div>
          

          
            <div class="links-of-author motion-element">
                
                  <span class="links-of-author-item">
                    <a href="https://github.com/LAILAIWA" target="_blank" title="GitHub">
                      
                        <i class="fa fa-fw fa-github"></i>GitHub</a>
                  </span>
                
                  <span class="links-of-author-item">
                    <a href="mailto:linyishui168@outlook.com" target="_blank" title="E-Mail">
                      
                        <i class="fa fa-fw fa-envelope"></i>E-Mail</a>
                  </span>
                
                  <span class="links-of-author-item">
                    <a href="https://twitter.com/linyishui618" target="_blank" title="Twitter">
                      
                        <i class="fa fa-fw fa-twitter"></i>Twitter</a>
                  </span>
                
                  <span class="links-of-author-item">
                    <a href="https://instagram.com/linyishui618" target="_blank" title="Instagram">
                      
                        <i class="fa fa-fw fa-instagram"></i>Instagram</a>
                  </span>
                
                  <span class="links-of-author-item">
                    <a href="https://weibo.com/u/5340162234" target="_blank" title="Weibo">
                      
                        <i class="fa fa-fw fa-weibo.com"></i>Weibo</a>
                  </span>
                
            </div>
          

          
          

          
          

          
        </div>
      </section>

      
      <!--noindex-->
        <section class="post-toc-wrap motion-element sidebar-panel sidebar-panel-active">
          <div class="post-toc">

            
              
            

            
              <div class="post-toc-content"><ol class="nav"><li class="nav-item nav-level-1"><a class="nav-link" href="#虚拟机调优案例分析与实战"><span class="nav-number">1.</span> <span class="nav-text">虚拟机调优案例分析与实战</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#第一节-概述"><span class="nav-number">1.1.</span> <span class="nav-text">第一节 概述</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#第二节-案例分析"><span class="nav-number">1.2.</span> <span class="nav-text">第二节 案例分析</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#2-1-高性能硬件上的程序部署策略"><span class="nav-number">1.2.1.</span> <span class="nav-text">2.1 高性能硬件上的程序部署策略</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#2-2-集群间同步导致的内存溢出"><span class="nav-number">1.2.2.</span> <span class="nav-text">2.2 集群间同步导致的内存溢出</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#2-3-堆外内存导致的溢出错误"><span class="nav-number">1.2.3.</span> <span class="nav-text">2.3 堆外内存导致的溢出错误</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#2-4-外部命令导致系统缓慢"><span class="nav-number">1.2.4.</span> <span class="nav-text">2.4 外部命令导致系统缓慢</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#2-5-服务器JVM进程崩溃"><span class="nav-number">1.2.5.</span> <span class="nav-text">2.5 服务器JVM进程崩溃</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#2-6-不恰当数据结构导致内存占用过大"><span class="nav-number">1.2.6.</span> <span class="nav-text">2.6 不恰当数据结构导致内存占用过大</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#2-7-由Windows虚拟内存导致的长时间停顿"><span class="nav-number">1.2.7.</span> <span class="nav-text">2.7 由Windows虚拟内存导致的长时间停顿</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#第三节-实战：Eclipse运行速度调优"><span class="nav-number">1.3.</span> <span class="nav-text">第三节 实战：Eclipse运行速度调优</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#3-1-调优前的程序运行状态"><span class="nav-number">1.3.1.</span> <span class="nav-text">3.1 调优前的程序运行状态</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#3-2-升级JDK-1-6的性能变化及兼容问题"><span class="nav-number">1.3.2.</span> <span class="nav-text">3.2 升级JDK 1.6的性能变化及兼容问题</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#3-3-编译时间和类加载时间的优化"><span class="nav-number">1.3.3.</span> <span class="nav-text">3.3 编译时间和类加载时间的优化</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#3-4-调整内存设置控制垃圾收集频率"><span class="nav-number">1.3.4.</span> <span class="nav-text">3.4 调整内存设置控制垃圾收集频率</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#3-5-选择收集器降低延迟"><span class="nav-number">1.3.5.</span> <span class="nav-text">3.5 选择收集器降低延迟</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#第四节-总结"><span class="nav-number">1.4.</span> <span class="nav-text">第四节 总结</span></a></li></ol></li></ol></div>
            

          </div>
        </section>
      <!--/noindex-->
      

      

    </div>
  </aside>


        
      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="footer-inner">
        ﻿<script async src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script>
<div class="copyright">&copy; 2018 &mdash; <span itemprop="copyrightYear">2020</span>
  <span class="with-love" id="heart">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">沂水</span>

  
</div>

<div class="powered-by">
  <i class="fa fa-user-md">
  </i>
  <span id="busuanzi_container_site_pv">本站总访问量<span id="busuanzi_value_site_pv"></span>次</span>
</div>

<!-- 

  <div class="powered-by">由 <a class="theme-link" target="_blank" href="https://hexo.io">Hexo</a> 强力驱动</div>



  <span class="post-meta-divider">|</span>



  <div class="theme-info">主题 &mdash; <a class="theme-link" target="_blank" href="https://github.com/iissnan/hexo-theme-next">NexT.Pisces</a> v5.1.4</div>

-->



        







        
      </div>
    </footer>

    
      <div class="back-to-top">
        <i class="fa fa-arrow-up"></i>
        
      </div>
    

    
   <script src="/live2dw/lib/L2Dwidget.min.js?094cbace49a39548bed64abff5988b05"></script><script>L2Dwidget.init({"tagMode":true,"model":{"jsonPath":"/live2dw/assets/shizuku.model.json"},"display":{"position":"left","width":125,"height":250},"mobile":{"show":false},"log":false,"pluginJsPath":"lib/","pluginModelPath":"assets/","pluginRootPath":"live2dw/"});</script>

  </div>

  

<script type="text/javascript">
  if (Object.prototype.toString.call(window.Promise) !== '[object Function]') {
    window.Promise = null;
  }
</script>









  


  











  
  
    <script type="text/javascript" src="/lib/jquery/index.js?v=2.1.3"></script>
  

  
  
    <script type="text/javascript" src="/lib/fastclick/lib/fastclick.min.js?v=1.0.6"></script>
  

  
  
    <script type="text/javascript" src="/lib/jquery_lazyload/jquery.lazyload.js?v=1.9.7"></script>
  

  
  
    <script type="text/javascript" src="/lib/velocity/velocity.min.js?v=1.2.1"></script>
  

  
  
    <script type="text/javascript" src="/lib/velocity/velocity.ui.min.js?v=1.2.1"></script>
  

  
  
    <script type="text/javascript" src="/lib/fancybox/source/jquery.fancybox.pack.js?v=2.1.5"></script>
  

  
  
    <script type="text/javascript" src="/lib/canvas-nest/canvas-nest.min.js"></script>
  


  


  <script type="text/javascript" src="/js/src/utils.js?v=5.1.4"></script>

  <script type="text/javascript" src="/js/src/motion.js?v=5.1.4"></script>



  
  


  <script type="text/javascript" src="/js/src/affix.js?v=5.1.4"></script>

  <script type="text/javascript" src="/js/src/schemes/pisces.js?v=5.1.4"></script>



  
  <script type="text/javascript" src="/js/src/scrollspy.js?v=5.1.4"></script>
<script type="text/javascript" src="/js/src/post-details.js?v=5.1.4"></script>



  


  <script type="text/javascript" src="/js/src/bootstrap.js?v=5.1.4"></script>



  


  




	





  





  












  





  

  

  

  
  

  

  

  

</body>
</html>
