<!DOCTYPE html>
<html lang="zh-CN">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width">
<meta name="theme-color" content="#222">
<meta name="generator" content="Hexo 5.4.0">


  <link rel="apple-touch-icon" sizes="180x180" href="/images/gamepad%20playstation.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/Dig%20Dug.ico">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/gamepad%20playstation.png">
  <link rel="mask-icon" href="/images/gamepad%20playstation.svg" color="#222">

<link rel="stylesheet" href="/css/main.css">

<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Monda:300,300italic,400,400italic,700,700italic%7CMa+Shan+Zheng:300,300italic,400,400italic,700,700italic%7CNoto+Serif+SC:300,300italic,400,400italic,700,700italic&display=swap&subset=latin,latin-ext">

<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free@5.15.3/css/all.min.css" integrity="sha256-2H3fkXt6FEmrReK448mDVGKb3WW2ZZw35gI7vqHOE4Y=" crossorigin="anonymous">
  <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/animate.css@3.1.1/animate.min.css" integrity="sha256-PR7ttpcvz8qrF57fur/yAx1qXMFJeJFiA6pSzWi0OIE=" crossorigin="anonymous">
  <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@3.5.7/dist/jquery.fancybox.min.css" integrity="sha256-Vzbj7sDDS/woiFS3uNKo8eIuni59rjyNGtXfstRzStA=" crossorigin="anonymous">
  <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/nprogress@0.2.0/nprogress.css" integrity="sha256-no0c5ccDODBwp+9hSmV5VvPpKwHCpbVzXHexIkupM6U=" crossorigin="anonymous">
  <script src="https://cdn.jsdelivr.net/npm/nprogress@0.2.0/nprogress.js" integrity="sha256-a5YRB27CcBwBFcT5EF/f3E4vzIqyHrSR878nseNYw64=" crossorigin="anonymous"></script>

<script class="next-config" data-name="main" type="application/json">{"hostname":"linyishui.top","root":"/","images":"/images","scheme":"Pisces","version":"8.6.0","exturl":false,"sidebar":{"position":"left","display":"always","padding":18,"offset":12},"copycode":true,"bookmark":{"enable":true,"color":"#222","save":"manual"},"fancybox":true,"mediumzoom":false,"lazyload":false,"pangu":false,"comments":{"style":"tabs","active":"utterances","storage":true,"lazyload":false,"nav":null,"activeClass":"utterances"},"motion":{"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"fadeInDown","post_body":"fadeInDown","coll_header":"fadeInLeft","sidebar":"fadeInUp"}},"prism":false,"i18n":{"placeholder":"搜索...","empty":"没有找到任何搜索结果：${query}","hits_time":"找到 ${hits} 个搜索结果（用时 ${time} 毫秒）","hits":"找到 ${hits} 个搜索结果"},"path":"/search.xml","localsearch":{"enable":true,"trigger":"auto","top_n_per_article":1,"unescape":false,"preload":false}}</script><script src="/js/config.js"></script>
<meta name="description" content="整理面试中常问的Spring和SpringMVC相关问题，持续更新中。">
<meta property="og:type" content="article">
<meta property="og:title" content="面试整理——Spring、SpringMVC和Spring Boot">
<meta property="og:url" content="http://linyishui.top/2019110101.html">
<meta property="og:site_name" content="俺的部落格">
<meta property="og:description" content="整理面试中常问的Spring和SpringMVC相关问题，持续更新中。">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="https://img2020.cnblogs.com/blog/2096812/202011/2096812-20201117160054595-970034678.jpg">
<meta property="article:published_time" content="2019-11-01T09:42:38.000Z">
<meta property="article:modified_time" content="2025-02-04T10:21:55.861Z">
<meta property="article:author" content="Lys">
<meta property="article:tag" content="Q&amp;A">
<meta property="article:tag" content="updating">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://img2020.cnblogs.com/blog/2096812/202011/2096812-20201117160054595-970034678.jpg">


<link rel="canonical" href="http://linyishui.top/2019110101.html">



<script class="next-config" data-name="page" type="application/json">{"sidebar":"","isHome":false,"isPost":true,"lang":"zh-CN","comments":true,"permalink":"http://linyishui.top/2019110101.html","path":"2019110101.html","title":"面试整理——Spring、SpringMVC和Spring Boot"}</script>

<script class="next-config" data-name="calendar" type="application/json">""</script>
<title>面试整理——Spring、SpringMVC和Spring Boot | 俺的部落格</title>
  




  <noscript>
    <link rel="stylesheet" href="/css/noscript.css">
  </noscript>
<link rel="alternate" href="/atom.xml" title="俺的部落格" type="application/atom+xml">
<style>.darkmode--activated{--body-bg-color:#282828;--content-bg-color:#333;--card-bg-color:#555;--text-color:#ccc;--blockquote-color:#bbb;--link-color:#ccc;--link-hover-color:#eee;--brand-color:#ddd;--brand-hover-color:#ddd;--table-row-odd-bg-color:#282828;--table-row-hover-bg-color:#363636;--menu-item-bg-color:#555;--btn-default-bg:#222;--btn-default-color:#ccc;--btn-default-border-color:#555;--btn-default-hover-bg:#666;--btn-default-hover-color:#ccc;--btn-default-hover-border-color:#666;--highlight-background:#282b2e;--highlight-foreground:#a9b7c6;--highlight-gutter-background:#34393d;--highlight-gutter-foreground:#9ca9b6}.darkmode--activated img{opacity:.75}.darkmode--activated img:hover{opacity:.9}.darkmode--activated code{color:#69dbdc;background:0 0}button.darkmode-toggle{z-index:9999}</style></head>

<body itemscope itemtype="http://schema.org/WebPage" class="use-motion">
  <div class="headband"></div>

  <main class="main">
    <header class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="切换导航栏" role="button">
        <span class="toggle-line"></span>
        <span class="toggle-line"></span>
        <span class="toggle-line"></span>
    </div>
  </div>

  <div class="site-meta">

    <a href="/" class="brand" rel="start">
      <i class="logo-line"></i>
      <h1 class="site-title">俺的部落格</h1>
      <i class="logo-line"></i>
    </a>
      <p class="site-subtitle" itemprop="description">俺寻思俺需要记点东西</p>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger">
        <i class="fa fa-search fa-fw fa-lg"></i>
    </div>
  </div>
</div>



<nav class="site-nav">
  <ul class="main-menu menu">
        <li class="menu-item menu-item-home"><a href="/" rel="section"><i class="fa fa-home fa-fw"></i>首页</a></li>
        <li class="menu-item menu-item-about"><a href="/about/" rel="section"><i class="fa fa-user fa-fw"></i>关于</a></li>
        <li class="menu-item menu-item-tags"><a href="/tags/" rel="section"><i class="fa fa-tags fa-fw"></i>标签</a></li>
        <li class="menu-item menu-item-categories"><a href="/categories/" rel="section"><i class="fa fa-th fa-fw"></i>分类</a></li>
        <li class="menu-item menu-item-archives"><a href="/archives/" rel="section"><i class="fa fa-archive fa-fw"></i>归档</a></li>
        <li class="menu-item menu-item-sitemap"><a href="/sitemap.xml" rel="section"><i class="fa fa-sitemap fa-fw"></i>站点地图</a></li>
        <li class="menu-item menu-item-tools"><a href="/links/" rel="section"><i class="fa fa-link fa-fw"></i>工具</a></li>
        <li class="menu-item menu-item-books"><a href="/books/" rel="section"><i class="fa fa-book fa-fw"></i>书架</a></li>
        <li class="menu-item menu-item-movies"><a href="/movies/" rel="section"><i class="fa fa-video fa-fw"></i>剧院</a></li>
        <li class="menu-item menu-item-games"><a href="/games/" rel="section"><i class="fa fa-gamepad fa-fw"></i>游戏</a></li>
        <li class="menu-item menu-item-commonweal"><a href="/404/" rel="section"><i class="fa fa-heartbeat fa-fw"></i>公益</a></li>
      <li class="menu-item menu-item-search">
        <a role="button" class="popup-trigger"><i class="fa fa-search fa-fw"></i>搜索
        </a>
      </li>
  </ul>
</nav>



  <div class="search-pop-overlay">
    <div class="popup search-popup"><div class="search-header">
  <span class="search-icon">
    <i class="fa fa-search"></i>
  </span>
  <div class="search-input-container">
    <input autocomplete="off" autocapitalize="off" maxlength="80"
           placeholder="搜索..." spellcheck="false"
           type="search" class="search-input">
  </div>
  <span class="popup-btn-close" role="button">
    <i class="fa fa-times-circle"></i>
  </span>
</div>
<div class="search-result-container no-result">
  <div class="search-result-icon">
    <i class="fa fa-spinner fa-pulse fa-5x"></i>
  </div>
</div>

    </div>
  </div>

</div>
        
  
  <div class="toggle sidebar-toggle" role="button">
    <span class="toggle-line"></span>
    <span class="toggle-line"></span>
    <span class="toggle-line"></span>
  </div>

  <aside class="sidebar">

    <div class="sidebar-inner sidebar-nav-active sidebar-toc-active">
      <ul class="sidebar-nav">
        <li class="sidebar-nav-toc">
          文章目录
        </li>
        <li class="sidebar-nav-overview">
          站点概览
        </li>
      </ul>

      <div class="sidebar-panel-container">
        <!--noindex-->
        <div class="post-toc-wrap sidebar-panel">
            <div class="post-toc animated"><ol class="nav"><li class="nav-item nav-level-1"><a class="nav-link" href="#Spring%E3%80%81SpringMVC%E5%92%8CSpring-Boot"><span class="nav-text">Spring、SpringMVC和Spring Boot</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#%E4%B8%80-Spring"><span class="nav-text">一.Spring</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#1-1-Spring%E5%9F%BA%E7%A1%80"><span class="nav-text">1.1 Spring基础</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E9%97%AE%EF%BC%9ASpring%E5%B8%B8%E7%94%A8%E6%A8%A1%E5%9D%97%EF%BC%9F"><span class="nav-text">问：Spring常用模块？</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E9%97%AE%EF%BC%9A%E4%BB%8B%E7%BB%8D%E4%B8%80%E4%B8%8BSpring%EF%BC%9FSpring%E5%92%8CSpring-MVC%E7%9A%84%E5%85%B3%E7%B3%BB%EF%BC%9F"><span class="nav-text">问：介绍一下Spring？Spring和Spring MVC的关系？</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E9%97%AE%EF%BC%9ASpringMVC%E7%9A%84%E6%89%A7%E8%A1%8C%E6%B5%81%E7%A8%8B%EF%BC%9F%E4%BB%8E%E7%94%A8%E6%88%B7%E8%AF%B7%E6%B1%82%E5%88%B0%E5%93%8D%E5%BA%94%EF%BC%9F%E2%AD%90%E2%AD%90%E2%AD%90"><span class="nav-text">问：SpringMVC的执行流程？从用户请求到响应？⭐⭐⭐</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E9%97%AE%EF%BC%9ASpring%E7%9A%84%E6%89%A9%E5%B1%95%E7%82%B9%EF%BC%9F%E2%AD%90%E2%AD%90"><span class="nav-text">问：Spring的扩展点？⭐⭐</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#1-2-Spring-IoC"><span class="nav-text">1.2 Spring IoC</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E9%97%AE%EF%BC%9A%E8%AE%B2%E4%B8%80%E4%B8%8BIoC%E7%9A%84%E5%8E%9F%E7%90%86%E4%B8%8E%E5%88%9D%E5%A7%8B%E5%8C%96%E6%B5%81%E7%A8%8B%EF%BC%9FBeanDefinition%E5%8A%A0%E8%BD%BD%E6%B5%81%E7%A8%8B%EF%BC%9FSpring-%E5%AF%B9%E4%BA%8E-IOC-%E7%9A%84%E6%89%A9%E5%B1%95%E7%82%B9%E6%9C%89%E5%93%AA%E4%BA%9B%EF%BC%9F%E2%AD%90%E2%AD%90%E2%AD%90"><span class="nav-text">问：讲一下IoC的原理与初始化流程？BeanDefinition加载流程？Spring 对于 IOC 的扩展点有哪些？⭐⭐⭐</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E9%97%AE%EF%BC%9AIOC%E7%9A%84%E5%BA%95%E5%B1%82%E5%AE%9E%E7%8E%B0%EF%BC%9F%E2%AD%90%E2%AD%90%E2%AD%90"><span class="nav-text">问：IOC的底层实现？⭐⭐⭐</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E9%97%AE%EF%BC%9A%E8%AE%B2%E4%B8%80%E4%B8%8B%E4%BE%9D%E8%B5%96%E6%B3%A8%E5%85%A5%EF%BC%9FDI%E4%BE%9D%E8%B5%96%E6%B3%A8%E5%85%A5%E6%B5%81%E7%A8%8B-%E5%A6%82%E4%BD%95%E5%AE%9E%E4%BE%8B%E5%8C%96%EF%BC%8C%E6%80%8E%E4%B9%88%E5%A4%84%E7%90%86bean%E4%B9%8B%E9%97%B4%E7%9A%84%E4%BE%9D%E8%B5%96%E5%85%B3%E7%B3%BB"><span class="nav-text">问：讲一下依赖注入？DI依赖注入流程? 如何实例化，怎么处理bean之间的依赖关系?</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E9%97%AE%EF%BC%9A%E7%BB%99%E4%BD%A0spring%E7%9A%84jar%E5%8C%85%E4%BD%A0%E8%A6%81%E6%80%8E%E4%B9%88%E8%AE%A9%E5%AE%83%E5%90%AF%E5%8A%A8%EF%BC%9F"><span class="nav-text">问：给你spring的jar包你要怎么让它启动？</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#1-3-Spring-Bean"><span class="nav-text">1.3 Spring Bean</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E9%97%AE%EF%BC%9A%E8%AE%B2%E4%B8%80%E8%AE%B2Spring-Bean%E6%98%AF%E4%BB%80%E4%B9%88%EF%BC%9F"><span class="nav-text">问：讲一讲Spring Bean是什么？</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E9%97%AE%EF%BC%9ASpring-Bean%E5%AE%9A%E4%B9%895%E7%A7%8D%E4%BD%9C%E7%94%A8%E5%9F%9F%EF%BC%9F%E2%AD%90"><span class="nav-text">问：Spring Bean定义5种作用域？⭐</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E9%97%AE%EF%BC%9ASpring%E7%9A%84%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F%EF%BC%9FSpring-bean%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F%EF%BC%9F%EF%BC%88%E6%BA%90%E7%A0%81%E7%BB%86%E8%8A%82%EF%BC%8C%E4%BB%A5%E5%8F%8A%E5%90%84%E4%B8%AA%E4%BD%8D%E7%BD%AE%E7%9A%84%E8%AE%BE%E8%AE%A1%E6%80%9D%E8%B7%AF%EF%BC%8C%E6%9C%89%E4%BB%80%E4%B9%88%E5%8F%AF%E6%89%A9%E5%B1%95%E7%9A%84%EF%BC%89%E2%AD%90%E2%AD%90%E2%AD%90"><span class="nav-text">问：Spring的生命周期？Spring bean生命周期？（源码细节，以及各个位置的设计思路，有什么可扩展的）⭐⭐⭐</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E9%97%AE%EF%BC%9A%E8%AE%B2%E4%B8%80%E4%B8%8Bbean%E6%88%90%E5%91%98%E5%8F%98%E9%87%8F%E7%9A%84%E5%8F%82%E6%95%B0%E6%B3%A8%E5%85%A5%E6%9C%89%E5%93%AA%E7%A7%8D%E6%96%B9%E5%BC%8F%EF%BC%9F%E2%AD%90"><span class="nav-text">问：讲一下bean成员变量的参数注入有哪种方式？⭐</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E9%97%AE%EF%BC%9A%E4%B8%BA%E4%BB%80%E4%B9%88Spring%E4%B8%8D%E6%8E%A8%E8%8D%90%E4%BD%BF%E7%94%A8%E5%B1%9E%E6%80%A7%E6%B3%A8%E5%85%A5%EF%BC%9F"><span class="nav-text">问：为什么Spring不推荐使用属性注入？</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E9%97%AE%EF%BC%9ASpring%E4%B8%AD%E7%9A%84BeanFactory-%E3%80%81FactoryBean%E3%80%81ObjectFactory%E2%AD%90"><span class="nav-text">问：Spring中的BeanFactory 、FactoryBean、ObjectFactory⭐</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E9%97%AE%EF%BC%9A%E5%8D%95%E4%BE%8B%E6%A8%A1%E5%BC%8F%E7%9A%84%E5%87%A0%E7%A7%8D%E5%AE%9E%E7%8E%B0%E6%96%B9%E5%BC%8F%EF%BC%9FSpring%E7%9A%84%E5%8D%95%E4%BE%8B%E6%98%AF%E6%80%8E%E4%B9%88%E5%AE%9E%E7%8E%B0%E7%9A%84%EF%BC%9F%E5%8D%95%E4%BE%8B%E7%9A%84%E6%83%85%E5%86%B5%E4%B8%8B%E6%80%8E%E4%B9%88%E5%AE%9E%E4%BE%8B%E5%8C%96%EF%BC%8C%E4%BB%80%E4%B9%88%E6%97%B6%E5%80%99%EF%BC%8C%E5%A4%9A%E4%BE%8B%E5%91%A2%EF%BC%9F"><span class="nav-text">问：单例模式的几种实现方式？Spring的单例是怎么实现的？单例的情况下怎么实例化，什么时候，多例呢？</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#1-4-%E5%BE%AA%E7%8E%AF%E4%BE%9D%E8%B5%96"><span class="nav-text">1.4 循环依赖</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E9%97%AE%EF%BC%9A%E4%BB%80%E4%B9%88%E6%98%AF%E5%BE%AA%E7%8E%AF%E4%BE%9D%E8%B5%96%EF%BC%9F"><span class="nav-text">问：什么是循环依赖？</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E9%97%AE%EF%BC%9A%E6%80%8E%E4%B9%88%E6%A3%80%E6%B5%8B%E6%98%AF%E5%90%A6%E5%AD%98%E5%9C%A8%E5%BE%AA%E7%8E%AF%E4%BE%9D%E8%B5%96%EF%BC%9F"><span class="nav-text">问：怎么检测是否存在循环依赖？</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E9%97%AE%EF%BC%9ASpring%E4%B8%AD%E5%BE%AA%E7%8E%AF%E4%BE%9D%E8%B5%96%E5%9C%BA%E6%99%AF%EF%BC%9F"><span class="nav-text">问：Spring中循环依赖场景？</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E9%97%AE%EF%BC%9ASpring-%E6%80%8E%E4%B9%88%E8%A7%A3%E5%86%B3%E5%8D%95%E4%BE%8B-Bean-%E7%9A%84%E5%BE%AA%E7%8E%AF%E4%BE%9D%E8%B5%96%E9%97%AE%E9%A2%98%EF%BC%9F%E2%AD%90%E2%AD%90%E2%AD%90"><span class="nav-text">问：Spring 怎么解决单例 Bean 的循环依赖问题？⭐⭐⭐</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E9%97%AE%EF%BC%9ASpring%E8%A7%A3%E5%86%B3%E4%B8%8D%E4%BA%86%E7%9A%84%E5%BE%AA%E7%8E%AF%E4%BE%9D%E8%B5%96%E5%9C%BA%E6%99%AF-%E2%AD%90"><span class="nav-text">问：Spring解决不了的循环依赖场景?⭐</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E9%97%AE%EF%BC%9A%E4%B8%BA%E4%BB%80%E4%B9%88%E4%B8%80%E5%AE%9A%E8%A6%81%E4%B8%89%E7%BA%A7%E7%BC%93%E5%AD%98%EF%BC%8C%E5%8F%AF%E4%BB%A5%E5%8F%AA%E7%94%A8%E4%BA%8C%E7%BA%A7%E7%BC%93%E5%AD%98%E5%90%97%EF%BC%9F%E2%AD%90%E2%AD%90"><span class="nav-text">问：为什么一定要三级缓存，可以只用二级缓存吗？⭐⭐</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E9%97%AE%EF%BC%9A-Async%E4%B8%BA%E4%BB%80%E4%B9%88%E4%BC%9A%E5%AF%BC%E8%87%B4%E5%BE%AA%E7%8E%AF%E4%BE%9D%E8%B5%96%E8%A7%A3%E5%86%B3%E4%B8%8D%E4%BA%86"><span class="nav-text">问：@Async为什么会导致循环依赖解决不了</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E9%97%AE%EF%BC%9A-Lazy%E6%B3%A8%E8%A7%A3%E5%A6%82%E4%BD%95%E8%A7%A3%E5%86%B3%E5%BE%AA%E7%8E%AF%E4%BE%9D%E8%B5%96%E9%97%AE%E9%A2%98%EF%BC%9F"><span class="nav-text">问：@Lazy注解如何解决循环依赖问题？</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#1-5-Spring-AOP"><span class="nav-text">1.5 Spring AOP</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E9%97%AE%EF%BC%9A%E4%BB%80%E4%B9%88%E6%98%AFAOP%EF%BC%9F%E9%9D%A2%E5%90%91%E5%88%87%E9%9D%A2%E7%9A%84%E5%9F%BA%E6%9C%AC%E6%A6%82%E5%BF%B5%EF%BC%9F"><span class="nav-text">问：什么是AOP？面向切面的基本概念？</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E9%97%AE%EF%BC%9AAOP-%E4%B8%BB%E8%A6%81%E5%BA%94%E7%94%A8%E5%9C%BA%E6%99%AF%EF%BC%9FAOP%E5%9C%A8%E4%BB%80%E4%B9%88%E5%9C%BA%E6%99%AF%E4%B8%8B%E4%BC%9A%E5%A4%B1%E6%95%88%EF%BC%9F"><span class="nav-text">问：AOP 主要应用场景？AOP在什么场景下会失效？</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E9%97%AE%EF%BC%9A%E8%AE%B2%E4%B8%80%E4%B8%8BSpring-AOP-%E7%9A%84%E5%8E%9F%E7%90%86%EF%BC%9FAOP%E4%BD%BF%E7%94%A8%E5%93%AA%E7%A7%8D%E5%8A%A8%E6%80%81%E4%BB%A3%E7%90%86%EF%BC%9FJDK%E5%8A%A8%E6%80%81%E4%BB%A3%E7%90%86%E4%B8%8ECGlib%E7%9A%84%E5%8C%BA%E5%88%AB%EF%BC%9F%E2%AD%90%E2%AD%90%E2%AD%90"><span class="nav-text">问：讲一下Spring AOP 的原理？AOP使用哪种动态代理？JDK动态代理与CGlib的区别？⭐⭐⭐</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E9%97%AE%EF%BC%9A%E4%BB%A3%E7%90%86%E5%AF%B9%E8%B1%A1%E8%B0%83%E7%94%A8%E8%BF%87%E7%A8%8B%EF%BC%88%E8%B4%A3%E4%BB%BB%E9%93%BE-%E9%80%92%E5%BD%92%E8%B0%83%E7%94%A8%EF%BC%89%EF%BC%9F"><span class="nav-text">问：代理对象调用过程（责任链+递归调用）？</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E9%97%AE%EF%BC%9AAOP%E5%A6%82%E4%BD%95%E5%AE%9E%E7%8E%B0%EF%BC%9F%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90%EF%BC%9FTODO"><span class="nav-text">问：AOP如何实现？源码分析？TODO</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#1-6-Spring-%E4%BA%8B%E5%8A%A1"><span class="nav-text">1.6 Spring 事务</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E9%97%AE%EF%BC%9A%E8%AE%B2%E4%B8%80%E4%B8%8BSpring%E4%BA%8B%E5%8A%A1%E7%AE%A1%E7%90%86%E6%9C%BA%E5%88%B6%E5%8F%8A%E6%89%A7%E8%A1%8C%E6%B5%81%E7%A8%8B%EF%BC%9F%E2%AD%90%E2%AD%90%E2%AD%90"><span class="nav-text">问：讲一下Spring事务管理机制及执行流程？⭐⭐⭐</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E9%97%AE%EF%BC%9A-Transaction%EF%BC%9F"><span class="nav-text">问：@Transaction？</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E9%97%AE%EF%BC%9ASpring%E4%BA%8B%E5%8A%A1%E5%A6%82%E4%BD%95%E5%9B%9E%E6%BB%9A%EF%BC%9F"><span class="nav-text">问：Spring事务如何回滚？</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E9%97%AE%EF%BC%9ASpring%E4%BA%8B%E5%8A%A1%E4%BC%A0%E6%92%AD%EF%BC%9F%E2%AD%90%E2%AD%90%E2%AD%90"><span class="nav-text">问：Spring事务传播？⭐⭐⭐</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#1-7-%E5%85%B6%E4%BB%96"><span class="nav-text">1.7 其他</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E9%97%AE%EF%BC%9A%E8%AE%B2%E4%B8%80%E4%B8%8Bspring%E5%B8%B8%E7%94%A8%E7%9A%84%E6%B3%A8%E8%A7%A3%E6%9C%89%E5%93%AA%E4%BA%9B%EF%BC%9F%E9%83%BD%E6%9C%89%E4%BB%80%E4%B9%88%E4%BD%9C%E7%94%A8%EF%BC%9F-Autowired%E5%92%8C-Resource%E7%9A%84%E5%8C%BA%E5%88%AB%EF%BC%9F"><span class="nav-text">问：讲一下spring常用的注解有哪些？都有什么作用？@Autowired和@Resource的区别？</span></a></li></ol></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E6%9D%A5%E6%BA%90%E5%92%8C%E9%80%82%E7%94%A8%E6%80%A7%EF%BC%9A"><span class="nav-text">来源和适用性：</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%8F%AF%E9%80%89%E6%80%A7%EF%BC%9A"><span class="nav-text">可选性：</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E9%97%AE%EF%BC%9A%E6%9C%89%E7%94%A8%E8%BF%87Spring%E6%8F%90%E4%BE%9B%E7%9A%84%E6%89%A9%E5%B1%95%E7%BB%84%E4%BB%B6%E5%90%97%EF%BC%9F%E6%AF%94%E5%A6%82%E6%8B%A6%E6%88%AA%E5%99%A8%EF%BC%9F%E8%AF%B7%E8%AF%B4%E4%B8%8B%E8%BF%99%E4%B8%AA%E6%8B%A6%E6%88%AA%E5%99%A8%E7%9A%84api%EF%BC%9F%E8%BF%98%E6%9C%89%E6%B2%A1%E7%94%A8%E8%BF%87%E5%85%B6%E5%AE%83%E7%9A%84%E7%BB%84%E4%BB%B6%EF%BC%9F"><span class="nav-text">问：有用过Spring提供的扩展组件吗？比如拦截器？请说下这个拦截器的api？还有没用过其它的组件？</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E9%97%AE%EF%BC%9A%E7%99%BB%E5%BD%95%E6%80%81%E6%80%8E%E4%B9%88%E5%8E%BB%E5%A4%84%E7%90%86%E7%9A%84%EF%BC%9F"><span class="nav-text">问：登录态怎么去处理的？</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E9%97%AE%EF%BC%9ASpring-%E4%BD%BF%E7%94%A8%E4%BA%86%E5%93%AA%E4%BA%9B%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%EF%BC%9F%E2%AD%90%E2%AD%90%E2%AD%90"><span class="nav-text">问：Spring 使用了哪些设计模式？⭐⭐⭐</span></a></li></ol></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E4%BA%8C-Spring-MVC"><span class="nav-text">二.Spring MVC</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E9%97%AE%EF%BC%9A%E8%AE%B2%E4%B8%80%E4%B8%8BSpringMVC%E7%9A%84%E5%85%A8%E6%B5%81%E7%A8%8B%EF%BC%8C%E5%8F%AF%E4%BB%A5%E7%94%BB%E4%B8%80%E4%B8%8BUML%E6%97%B6%E5%BA%8F%E5%9B%BE%E5%90%97%EF%BC%9F"><span class="nav-text">问：讲一下SpringMVC的全流程，可以画一下UML时序图吗？</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E9%97%AE%EF%BC%9A%E8%AE%B2%E4%B8%80%E4%B8%8BSpringMVC%E4%B8%8D%E5%90%8C%E7%94%A8%E6%88%B7%E7%99%BB%E5%BD%95%E7%9A%84%E4%BF%A1%E6%81%AF%E6%80%8E%E4%B9%88%E4%BF%9D%E8%AF%81%E7%BA%BF%E7%A8%8B%E5%AE%89%E5%85%A8%E7%9A%84%EF%BC%9F"><span class="nav-text">问：讲一下SpringMVC不同用户登录的信息怎么保证线程安全的？</span></a></li></ol></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E4%B8%89-Spring-Boot"><span class="nav-text">三.Spring Boot</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E9%97%AE%EF%BC%9ASpringBoot%E5%92%8CSpring%E7%9A%84%E5%8C%BA%E5%88%AB%EF%BC%9F%E2%AD%90%E2%AD%90%E2%AD%90"><span class="nav-text">问：SpringBoot和Spring的区别？⭐⭐⭐</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E9%97%AE%EF%BC%9ASpringBoot%E5%90%AF%E5%8A%A8%E6%B5%81%E7%A8%8B%EF%BC%9F%E2%AD%90%E2%AD%90%E2%AD%90"><span class="nav-text">问：SpringBoot启动流程？⭐⭐⭐</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E9%97%AE%EF%BC%9ASpring-Boot%E7%9A%84%E6%A0%B8%E5%BF%83%E6%B3%A8%E8%A7%A3%EF%BC%9F"><span class="nav-text">问：Spring Boot的核心注解？</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E9%97%AE%EF%BC%9A%E8%AF%B4%E8%AF%B4Spring-Boot%E7%9A%84%E6%9D%A1%E4%BB%B6%E6%B3%A8%E8%A7%A3%EF%BC%9F"><span class="nav-text">问：说说Spring Boot的条件注解？</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E9%97%AE%EF%BC%9ASpringBoot%E5%B8%B8%E7%94%A8starter%E9%83%BD%E6%9C%89%E5%93%AA%E4%BA%9B%EF%BC%9F%E5%A6%82%E4%BD%95%E8%87%AA%E5%AE%9A%E4%B9%89starter%EF%BC%9F%E2%AD%90"><span class="nav-text">问：SpringBoot常用starter都有哪些？如何自定义starter？⭐</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E9%97%AE%EF%BC%9ASpringBootStarter%E5%A6%82%E4%BD%95%E7%90%86%E8%A7%A3%EF%BC%9F%E2%AD%90"><span class="nav-text">问：SpringBootStarter如何理解？⭐</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E9%97%AE%EF%BC%9ASpring-Boot%E5%B8%B8%E7%94%A8%E9%85%8D%E7%BD%AE%E6%96%B9%E5%BC%8F%EF%BC%9F%E9%85%8D%E7%BD%AE%E4%BC%98%E5%85%88%E7%BA%A7%EF%BC%9F"><span class="nav-text">问：Spring Boot常用配置方式？配置优先级？</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E9%97%AE%EF%BC%9ASpringBoot%E8%87%AA%E5%8A%A8%E9%85%8D%E7%BD%AE%E7%9A%84%E5%8E%9F%E7%90%86%EF%BC%9F%E2%AD%90%E2%AD%90%E2%AD%90"><span class="nav-text">问：SpringBoot自动配置的原理？⭐⭐⭐</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E9%97%AE%EF%BC%9ASpringBoot%E7%9A%84%E8%87%AA%E5%8A%A8%E9%85%8D%E7%BD%AE%E6%B5%81%E7%A8%8B%EF%BC%9F"><span class="nav-text">问：SpringBoot的自动配置流程？</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E9%97%AE%EF%BC%9ASpringBoot%E6%8A%8A%E5%AF%B9%E8%B1%A1%E6%B3%A8%E5%85%A5%E5%AE%B9%E5%99%A8%E7%9A%84%E5%87%A0%E7%A7%8D%E6%96%B9%E6%B3%95%EF%BC%9F"><span class="nav-text">问：SpringBoot把对象注入容器的几种方法？</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E9%97%AE%EF%BC%9A%E5%81%87%E5%A6%82%E7%8E%B0%E5%9C%A8%E5%9C%A8%E4%B8%80%E4%B8%AA%E7%B1%BB%E4%BA%86%E8%A6%81%E5%BC%95%E7%94%A8%E5%88%B0%E5%87%A0%E5%8D%81%E4%B8%AABean%EF%BC%8C%E9%9A%BE%E9%81%93%E8%A6%81%E5%9C%A8%E7%B1%BB%E9%87%8C%E5%A3%B0%E6%98%8E%E8%BF%99%E4%BA%9Bbean%E7%84%B6%E5%90%8E%E5%8A%A0%E6%B3%A8%E8%A7%A3%E5%90%97%EF%BC%8C%E6%9C%89%E6%B2%A1%E6%9C%89%E6%9B%B4%E5%A5%BD%E7%9A%84%E5%81%9A%E6%B3%95%EF%BC%9F"><span class="nav-text">问：假如现在在一个类了要引用到几十个Bean，难道要在类里声明这些bean然后加注解吗，有没有更好的做法？</span></a></li><li class="nav-item nav-level-4"><a class="nav-link"><span class="nav-text"></span></a></li></ol></li></ol></li></ol></li></ol></div>
        </div>
        <!--/noindex-->

        <div class="site-overview-wrap sidebar-panel">
          <div class="site-overview">
            <div class="site-author site-overview-item animated" itemprop="author" itemscope itemtype="http://schema.org/Person">
    <img class="site-author-image" itemprop="image" alt="Lys"
      src="https://pic-1258215793.cos.ap-shanghai.myqcloud.com/cover/IMG_0759.JPG">
  <p class="site-author-name" itemprop="name">Lys</p>
  <div class="site-description" itemprop="description">记录编程点滴，写点生活中的酸甜</div>
</div>
<div class="site-state-wrap site-overview-item animated">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
          <a href="/archives/">
        
          <span class="site-state-item-count">340</span>
          <span class="site-state-item-name">日志</span>
        </a>
      </div>
      <div class="site-state-item site-state-categories">
            <a href="/categories/">
          
        <span class="site-state-item-count">13</span>
        <span class="site-state-item-name">分类</span></a>
      </div>
      <div class="site-state-item site-state-tags">
            <a href="/tags/">
          
        <span class="site-state-item-count">113</span>
        <span class="site-state-item-name">标签</span></a>
      </div>
  </nav>
</div>
  <div class="links-of-author site-overview-item animated">
      <span class="links-of-author-item">
        <a href="https://github.com/LAILAIWA" title="GitHub → https:&#x2F;&#x2F;github.com&#x2F;LAILAIWA" rel="noopener" target="_blank"><i class="fab fa-github fa-fw"></i>GitHub</a>
      </span>
      <span class="links-of-author-item">
        <a href="mailto:linyishui168@outlook.com" title="E-Mail → mailto:linyishui168@outlook.com" rel="noopener" target="_blank"><i class="fa fa-envelope fa-fw"></i>E-Mail</a>
      </span>
      <span class="links-of-author-item">
        <a href="https://weibo.com/u/5340162234" title="Weibo → https:&#x2F;&#x2F;weibo.com&#x2F;u&#x2F;5340162234" rel="noopener" target="_blank"><i class="fab fa-weibo fa-fw"></i>Weibo</a>
      </span>
      <span class="links-of-author-item">
        <a href="https://twitter.com/linyishui618" title="Twitter → https:&#x2F;&#x2F;twitter.com&#x2F;linyishui618" rel="noopener" target="_blank"><i class="fab fa-twitter fa-fw"></i>Twitter</a>
      </span>
      <span class="links-of-author-item">
        <a href="https://stackoverflow.com/users/13018339/lin-yishui" title="StackOverflow → https:&#x2F;&#x2F;stackoverflow.com&#x2F;users&#x2F;13018339&#x2F;lin-yishui" rel="noopener" target="_blank"><i class="fab fa-stack-overflow fa-fw"></i>StackOverflow</a>
      </span>
      <span class="links-of-author-item">
        <a href="https://instagram.com/linyishui618" title="Instagram → https:&#x2F;&#x2F;instagram.com&#x2F;linyishui618" rel="noopener" target="_blank"><i class="fab fa-instagram fa-fw"></i>Instagram</a>
      </span>
  </div>
  <div class="cc-license site-overview-item animated" itemprop="license">
    <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/deed.zh" class="cc-opacity" rel="noopener" target="_blank"><img src="https://cdn.jsdelivr.net/npm/@creativecommons/vocabulary@2020.11.3/assets/license_badges/small/by_nc_sa.svg" alt="Creative Commons"></a>
  </div>


  <div class="links-of-blogroll site-overview-item animated">
    <div class="links-of-blogroll-title"><i class="far fa-smile-wink fa-fw"></i>
      个人
    </div>
    <ul class="links-of-blogroll-list">
        <li class="links-of-blogroll-item">
          <a href="https://music.163.com/#/user/home?id=68425607" title="https:&#x2F;&#x2F;music.163.com&#x2F;#&#x2F;user&#x2F;home?id&#x3D;68425607" rel="noopener" target="_blank">网易云音乐</a>
        </li>
    </ul>
  </div>

          </div>
        </div>
    </div>
  </aside>
  <div class="sidebar-dimmer"></div>


    </header>

    
  <div class="back-to-top" role="button" aria-label="返回顶部">
    <i class="fa fa-arrow-up"></i>
    <span>0%</span>
  </div>
  <a role="button" class="book-mark-link book-mark-link-fixed"></a>

  <a href="https://github.com/LAILAIWA" class="github-corner" title="Follow me on GitHub" aria-label="Follow me on GitHub" rel="noopener" target="_blank"><svg width="80" height="80" viewBox="0 0 250 250" aria-hidden="true"><path d="M0,0 L115,115 L130,115 L142,142 L250,250 L250,0 Z"></path><path d="M128.3,109.0 C113.8,99.7 119.0,89.6 119.0,89.6 C122.0,82.7 120.5,78.6 120.5,78.6 C119.2,72.0 123.4,76.3 123.4,76.3 C127.3,80.9 125.5,87.3 125.5,87.3 C122.9,97.6 130.6,101.9 134.4,103.2" fill="currentColor" style="transform-origin: 130px 106px;" class="octo-arm"></path><path d="M115.0,115.0 C114.9,115.1 118.7,116.5 119.8,115.4 L133.7,101.6 C136.9,99.2 139.9,98.4 142.2,98.6 C133.8,88.0 127.5,74.4 143.8,58.0 C148.5,53.4 154.0,51.2 159.7,51.0 C160.3,49.4 163.2,43.6 171.4,40.1 C171.4,40.1 176.1,42.5 178.8,56.2 C183.1,58.6 187.2,61.8 190.9,65.4 C194.5,69.0 197.7,73.2 200.1,77.6 C213.8,80.2 216.3,84.9 216.3,84.9 C212.7,93.1 206.9,96.0 205.4,96.6 C205.1,102.4 203.0,107.8 198.3,112.5 C181.9,128.9 168.3,122.5 157.7,114.1 C157.9,116.9 156.7,120.9 152.7,124.9 L141.0,136.5 C139.8,137.7 141.6,141.9 141.8,141.8 Z" fill="currentColor" class="octo-body"></path></svg></a>

<noscript>
  <div class="noscript-warning">Theme NexT works best with JavaScript enabled</div>
</noscript>


    <div class="main-inner post posts-expand">


  


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://linyishui.top/2019110101.html">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="https://pic-1258215793.cos.ap-shanghai.myqcloud.com/cover/IMG_0759.JPG">
      <meta itemprop="name" content="Lys">
      <meta itemprop="description" content="记录编程点滴，写点生活中的酸甜">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="俺的部落格">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          面试整理——Spring、SpringMVC和Spring Boot
        </h1>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>

      <time title="创建时间：2019-11-01 17:42:38" itemprop="dateCreated datePublished" datetime="2019-11-01T17:42:38+08:00">2019-11-01</time>
    </span>
      <span class="post-meta-item">
        <span class="post-meta-item-icon">
          <i class="far fa-calendar-check"></i>
        </span>
        <span class="post-meta-item-text">更新于</span>
        <time title="修改时间：2025-02-04 18:21:55" itemprop="dateModified" datetime="2025-02-04T18:21:55+08:00">2025-02-04</time>
      </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">分类于</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/%E9%9D%A2%E8%AF%95%E6%95%B4%E7%90%86/" itemprop="url" rel="index"><span itemprop="name">面试整理</span></a>
        </span>
    </span>

  
      </div>
      <div class="post-meta">
    <span class="post-meta-item" title="本文字数">
      <span class="post-meta-item-icon">
        <i class="far fa-file-word"></i>
      </span>
      <span class="post-meta-item-text">本文字数：</span>
      <span>94k</span>
    </span>
    <span class="post-meta-item" title="阅读时长">
      <span class="post-meta-item-icon">
        <i class="far fa-clock"></i>
      </span>
      <span class="post-meta-item-text">阅读时长 &asymp;</span>
      <span>1:25</span>
    </span>
</div>

            <div class="post-description">整理面试中常问的Spring和SpringMVC相关问题，持续更新中。</div>
        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
        <h1 id="Spring、SpringMVC和Spring-Boot"><a href="#Spring、SpringMVC和Spring-Boot" class="headerlink" title="Spring、SpringMVC和Spring Boot"></a>Spring、SpringMVC和Spring Boot</h1><h2 id="一-Spring"><a href="#一-Spring" class="headerlink" title="一.Spring"></a>一.Spring</h2><h3 id="1-1-Spring基础"><a href="#1-1-Spring基础" class="headerlink" title="1.1 Spring基础"></a>1.1 Spring基础</h3><h4 id="问：Spring常用模块？"><a href="#问：Spring常用模块？" class="headerlink" title="问：Spring常用模块？"></a>问：Spring常用模块？</h4><ul>
<li><strong>Spring Core</strong>：框架的最基础部分，提供 <code>IoC</code> 容器，对 <code>bean</code> 进行管理。</li>
<li><strong>Spring Context</strong>：继承 <code>BeanFactory</code> ，提供上下文信息，扩展出 <code>JNDI</code> 、<code>EJB</code> 、电子邮件、国际化等功能。</li>
<li><strong>Spring DAO</strong>：提供了 <code>JDBC</code> 的抽象层，还提供了声明 性事务管理方法。</li>
<li><strong>Spring ORM</strong>：提供了 <code>JPA</code> 、<code>JDO</code> 、<code>Hibernate</code> 、<code>MyBatis</code> 等ORM映射层（Object Relational Mapping，对象关系映射）。</li>
<li><strong>Spring AOP</strong>：集成了所有 <code>AOP</code> 功能。</li>
<li><strong>Spring Web</strong>：提供了基础的 <code>Web</code> 开发的上下文信息，现有的Web框架，如 <code>JSF</code> 、 <code>Tapestry</code> 、<code>Structs</code> 等，提供了集成。</li>
<li><strong>Spring Web MVC</strong>：提供了 <code>Web</code> 应用的 <code>Model-View-Controller</code> 全功能实现。</li>
</ul>
<h4 id="问：介绍一下Spring？Spring和Spring-MVC的关系？"><a href="#问：介绍一下Spring？Spring和Spring-MVC的关系？" class="headerlink" title="问：介绍一下Spring？Spring和Spring MVC的关系？"></a>问：介绍一下Spring？Spring和Spring MVC的关系？</h4><p>Spring 是一个开源的 Java 框架，用于构建企业级应用程序。</p>
<p>核心特性包括：</p>
<ol>
<li><p><strong>IoC 容器（Inversion of Control）：</strong> <strong>管理对象的生命周期和依赖关系</strong>，通过将对象的创建和组装工作委托给容器，实现了对象之间的解耦。</p>
</li>
<li><p><strong>AOP（面向切面编程）：</strong> 可以通过配置方式实现横切关注点的模块化，例如事务管理、日志记录等。</p>
</li>
<li><p><strong>数据访问：</strong> 提供了对 JDBC、ORM 框架（如 Hibernate、MyBatis）、JPA 等的集成支持，简化了数据访问的操作。</p>
</li>
<li><p><strong>事务管理：</strong> 提供了声明式的事务管理，支持编程式和声明式两种事务管理方式。</p>
</li>
<li><p><strong>MVC 框架：</strong> Spring MVC 是 Spring 框架中的一个模块，用于构建基于模型-视图-控制器（MVC）设计模式的 Web 应用程序。</p>
</li>
<li><p><strong>安全性：</strong> 提供了综合的安全性解决方案，包括认证（Authentication）和授权（Authorization）等。</p>
</li>
<li><p><strong>集成支持：</strong>Spring 支持与各种其他框架和技术的集成，如消息队列、缓存、远程调用等。</p>
</li>
</ol>
<p>Spring MVC 则是 Spring 框架中的 Web 模块，用于构建基于 MVC 设计模式的 Web 应用程序。</p>
<p>Spring 和 Spring MVC 的关系？</p>
<ul>
<li><p>Spring可以看作一个集成了多种特性、多种功能模块的平台（如IoC、AOP、事务、ORM等）。</p>
</li>
<li><p>Spring MVC 是 Spring 框架的一个模块，用于构建 Web 层。</p>
</li>
<li><p>Spring 框架提供了全面的基础设施支持，而 Spring MVC 则专注于提供用于构建 Web 应用程序的 MVC 框架。</p>
</li>
<li><p>MVC模型则是一个Web框架不可缺少的内容，Spring MVC就是建立在Spring平台上的MVC模型，需要基于Spring支撑才能运行。</p>
</li>
</ul>
<h4 id="问：SpringMVC的执行流程？从用户请求到响应？⭐⭐⭐"><a href="#问：SpringMVC的执行流程？从用户请求到响应？⭐⭐⭐" class="headerlink" title="问：SpringMVC的执行流程？从用户请求到响应？⭐⭐⭐"></a>问：SpringMVC的执行流程？从用户请求到响应？⭐⭐⭐</h4><figure class="highlight asciidoc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line"><span class="section">SpringMVC执行流程图：</span></span><br><span class="line"><span class="section">+-----------------+</span></span><br><span class="line"><span class="section">|   User Request   |</span></span><br><span class="line"><span class="section">+--------+---------+</span></span><br><span class="line"><span class="code">         |</span></span><br><span class="line"><span class="section">         v</span></span><br><span class="line"><span class="section">+--------+---------+</span></span><br><span class="line"><span class="section">| DispatcherServlet |</span></span><br><span class="line"><span class="section">+--------+---------+</span></span><br><span class="line"><span class="code">         |</span></span><br><span class="line"><span class="section">         v</span></span><br><span class="line"><span class="section">+--------+---------+</span></span><br><span class="line"><span class="section">|  HandlerMapping  |</span></span><br><span class="line"><span class="section">+--------+---------+</span></span><br><span class="line"><span class="code">         |</span></span><br><span class="line"><span class="section">         v</span></span><br><span class="line"><span class="section">+--------+---------+</span></span><br><span class="line"><span class="section">| HandlerExecutionChain |</span></span><br><span class="line"><span class="section">+--------+---------+</span></span><br><span class="line"><span class="code">         |</span></span><br><span class="line"><span class="section">         v</span></span><br><span class="line"><span class="section">+--------+---------+</span></span><br><span class="line"><span class="section">|  HandlerAdapter  |</span></span><br><span class="line"><span class="section">+--------+---------+</span></span><br><span class="line"><span class="code">         |</span></span><br><span class="line"><span class="section">         v</span></span><br><span class="line"><span class="section">+--------+---------+</span></span><br><span class="line"><span class="section">|      Handler     |</span></span><br><span class="line"><span class="section">+--------+---------+</span></span><br><span class="line"><span class="code">         |</span></span><br><span class="line"><span class="section">         v</span></span><br><span class="line"><span class="section">+--------+---------+</span></span><br><span class="line"><span class="section">|   ModelAndView   |</span></span><br><span class="line"><span class="section">+--------+---------+</span></span><br><span class="line"><span class="code">         |</span></span><br><span class="line"><span class="section">         v</span></span><br><span class="line"><span class="section">+--------+---------+</span></span><br><span class="line"><span class="section">|   ViewResolver   |</span></span><br><span class="line"><span class="section">+--------+---------+</span></span><br><span class="line"><span class="code">         |</span></span><br><span class="line"><span class="section">         v</span></span><br><span class="line"><span class="section">+--------+---------+</span></span><br><span class="line"><span class="section">|      View      |</span></span><br><span class="line"><span class="section">+--------+---------+</span></span><br><span class="line"><span class="code">         |</span></span><br><span class="line"><span class="section">         v</span></span><br><span class="line"><span class="section">+--------+---------+</span></span><br><span class="line"><span class="section">|  User Response  |</span></span><br><span class="line"><span class="section">+-----------------+</span></span><br></pre></td></tr></table></figure>





<p><strong>1. 用户发起请求</strong></p>
<ul>
<li>用户通过浏览器或其他客户端发起 HTTP 请求，请求到达 Spring MVC 应用。</li>
<li>如 <code>http://localhost:8080/user/getUser?id=1</code> </li>
</ul>
<p><strong>2. DispatcherServlet 接收请求</strong></p>
<ul>
<li><code>DispatcherServlet</code> 是 Spring MVC 的前端控制器（Front Controller），负责接收所有请求并分发。解析请求（路径、请求方法、参数等）。交给 <code>HandlerMapping</code> 进行处理。</li>
</ul>
<p><strong>3. HandlerMapping 解析请求，查找 Handler（处理器）</strong></p>
<ul>
<li><code>HandlerMapping</code> 负责根据请求的 URL 找到对应的处理器（Handler）。</li>
<li><code>HandlerMapping</code> 返回一个 <code>HandlerExecutionChain</code>，包含目标处理器（Handler）和拦截器（Interceptor）。</li>
<li>SpringMVC 提供了多种 HandlerMapping 实现，例如 RequestMappingHandlerMapping、BeanNameUrlHandlerMapping、SimpleUrlHandlerMapping 等。</li>
</ul>
<p><strong>4. 执行拦截器 HandlerInterceptor</strong></p>
<ul>
<li><code>HandlerExecutionChain</code> 中的拦截器 <code>HandlerInterceptor</code> 在处理器执行前后执行拦截逻辑（如权限检查、日志记录等）。</li>
</ul>
<p><strong>5. HandlerAdapter 适配和执行处理器 Handler</strong></p>
<ul>
<li><code>HandlerAdapter</code> 负责调用处理器（Handler）的具体方法。DispatcherServlet 接收到 HandlerExecutionChain 对象后，会调用 HandlerAdapter 来执行 Handler。调用 Handler 的 handleRequest 方法处理请求。</li>
<li><strong>流程</strong>：<ul>
<li><code>DispatcherServlet</code> 调用 <code>HandlerAdapter</code> 的 <code>handle()</code> 方法。</li>
<li><code>HandlerAdapter</code> 根据处理器的类型（如 <code>@Controller</code>、<code>HttpRequestHandler</code> 等）调用对应的处理方法。</li>
</ul>
</li>
</ul>
<p><strong>6. 执行处理器（Handler）</strong></p>
<ul>
<li><code>@Controller</code> 或 <code>HttpRequestHandler</code> 处理器执行业务逻辑，处理请求并返回结果。</li>
<li>Handler 通常是一个 Controller，它负责处理业务逻辑，并返回一个 ModelAndView 对象。ModelAndView 对象包含了模型数据和视图信息。</li>
<li><strong>流程</strong>：<ul>
<li>处理器方法（如 <code>@RequestMapping</code> 注解的方法）被调用。</li>
<li>处理器方法返回一个 <code>ModelAndView</code> 对象或直接返回数据（如 JSON）。</li>
</ul>
</li>
</ul>
<p><strong>7. DispatcherServlet 查找 ViewResolver 处理返回结果</strong></p>
<ul>
<li>DispatcherServlet 接收到 ModelAndView 对象后，会调用 ViewResolver 接口的实现类来查找合适的 View。ViewResolver 负责将视图名称解析为具体的 View 对象。</li>
<li><strong>核心类</strong>：<code>ModelAndView</code>、<code>ViewResolver</code></li>
<li><strong>作用</strong>：<ul>
<li>如果处理器返回 <code>ModelAndView</code>，<code>DispatcherServlet</code> 会解析视图名称并渲染视图。</li>
<li>如果处理器直接返回数据（如 JSON），<code>DispatcherServlet</code> 会直接返回响应。</li>
</ul>
</li>
<li><strong>流程</strong>：<ul>
<li><code>DispatcherServlet</code> 调用 <code>ViewResolver</code> 的 <code>resolveViewName()</code> 方法，将视图名称解析为具体的 <code>View</code> 对象。</li>
<li><code>View</code> 对象负责渲染视图（如 JSP、Thymeleaf 等）。</li>
</ul>
</li>
</ul>
<p><strong>9. 渲染视图</strong></p>
<ul>
<li><strong>核心类</strong>：<code>View</code></li>
<li><strong>作用</strong>：将模型数据渲染到视图（如 HTML、JSON 等）。</li>
<li><strong>流程</strong>：<code>View</code> 对象的 <code>render()</code> 方法被调用，生成最终的响应内容。</li>
</ul>
<p><strong>10. 返回响应</strong></p>
<ul>
<li><strong>核心类</strong>：<code>DispatcherServlet</code></li>
<li><strong>作用</strong>：将最终的响应返回给客户端。</li>
<li><strong>流程</strong>：<code>DispatcherServlet</code> 将渲染后的视图或数据写入 HTTP 响应，返回给客户端。</li>
</ul>
<p><strong>总结：Spring MVC 执行流程</strong></p>
<ol>
<li><strong>用户发起请求</strong> → 2. <strong>DispatcherServlet 接收请求</strong> → 3. <strong>HandlerMapping 查找 Handler</strong> → 4. <strong>拦截器 preHandle</strong> → 5. <strong>HandlerAdapter 适配 Handler</strong> → 6. <strong>处理器执行业务逻辑</strong> → 7. <strong>处理返回结果</strong> → 8. <strong>拦截器 postHandle</strong> → 9. <strong>渲染视图</strong> → 10. <strong>拦截器 afterCompletion</strong> → 11. <strong>返回响应</strong></li>
</ol>
<p><strong>涉及的核心类</strong></p>
<table>
<thead>
<tr>
<th align="left">类名</th>
<th align="left">作用</th>
</tr>
</thead>
<tbody><tr>
<td align="left"><code>DispatcherServlet</code></td>
<td align="left">前端控制器，负责接收请求并协调处理流程。</td>
</tr>
<tr>
<td align="left"><code>HandlerMapping</code></td>
<td align="left">根据请求 URL 找到对应的处理器（Handler）。</td>
</tr>
<tr>
<td align="left"><code>HandlerAdapter</code></td>
<td align="left">调用处理器（Handler）的具体方法。</td>
</tr>
<tr>
<td align="left"><code>HandlerInterceptor</code></td>
<td align="left">拦截器，在处理器执行前后执行逻辑。</td>
</tr>
<tr>
<td align="left"><code>@Controller</code></td>
<td align="left">处理器，执行业务逻辑并返回结果。</td>
</tr>
<tr>
<td align="left"><code>ModelAndView</code></td>
<td align="left">封装模型数据和视图名称。</td>
</tr>
<tr>
<td align="left"><code>ViewResolver</code></td>
<td align="left">解析视图名称并返回具体的 <code>View</code> 对象。</td>
</tr>
<tr>
<td align="left"><code>View</code></td>
<td align="left">负责渲染视图（如 JSP、Thymeleaf 等）。</td>
</tr>
</tbody></table>
<h4 id="问：Spring的扩展点？⭐⭐"><a href="#问：Spring的扩展点？⭐⭐" class="headerlink" title="问：Spring的扩展点？⭐⭐"></a>问：Spring的扩展点？⭐⭐</h4><table>
<thead>
<tr>
<th>扩展接口</th>
<th>作用</th>
</tr>
</thead>
<tbody><tr>
<td>BeanPostProcessor</td>
<td>支持在 Bean 初始化前、后对 Bean 进行处理</td>
</tr>
<tr>
<td>BeanFactoryPostProcessor</td>
<td>处理所有 Bean 前，对 BeanFactory 进行预处理</td>
</tr>
<tr>
<td>BeanDefinitionRegistryPostProcessor</td>
<td>可以添加自定义的Bean</td>
</tr>
<tr>
<td>initializingBean</td>
<td>在 Bean 创建完成，所有属性注入完成之后执行</td>
</tr>
<tr>
<td>DisposableBean</td>
<td>在 Bean 销毁前执行</td>
</tr>
<tr>
<td>Aware 接口族</td>
<td>获得 Spring 容器资源</td>
</tr>
<tr>
<td>FactoryBean</td>
<td>复杂 Bean 注入</td>
</tr>
<tr>
<td>ApplicationListener</td>
<td>监听响应容器事件</td>
</tr>
</tbody></table>
<h3 id="1-2-Spring-IoC"><a href="#1-2-Spring-IoC" class="headerlink" title="1.2 Spring IoC"></a>1.2 Spring IoC</h3><h4 id="问：讲一下IoC的原理与初始化流程？BeanDefinition加载流程？Spring-对于-IOC-的扩展点有哪些？⭐⭐⭐"><a href="#问：讲一下IoC的原理与初始化流程？BeanDefinition加载流程？Spring-对于-IOC-的扩展点有哪些？⭐⭐⭐" class="headerlink" title="问：讲一下IoC的原理与初始化流程？BeanDefinition加载流程？Spring 对于 IOC 的扩展点有哪些？⭐⭐⭐"></a>问：讲一下IoC的原理与初始化流程？BeanDefinition加载流程？Spring 对于 IOC 的扩展点有哪些？⭐⭐⭐</h4><ul>
<li><p>IoC，即<strong>控制反转（Inversion of Control）</strong>。将对象的创建通过<strong>依赖注入（Dependency Injection）</strong>的方式由 <code>Spring IoC</code>容器来实现。</p>
</li>
<li><p>原理：控制反转即将对象的创建和管理交给Spring容器，而不是由应用程序自己负责。通过依赖注入的方式将对象的依赖关系在容器启动时进行注入。</p>
</li>
<li><p>Spring容器的创建流程？</p>
<ol>
<li><p><strong>初始化配置</strong>：创建Spring容器<strong>ApplicationContext</strong>，在启动时扫描所有的Bean配置信息，包括XML配置和注解配置；</p>
<ul>
<li><strong>XML 配置文件方式</strong>：Spring 容器会通过解析 <code>applicationContext.xml</code>（或类似文件）来加载定义的 bean，存储成 <code>BeanDefinition</code> 对象。这个过程主要是由 <code>BeanDefinitionReader</code> 完成。</li>
<li><strong>注解配置方式</strong>：如果使用注解配置，Spring 会扫描指定包下的所有类，并检查是否有 <code>@Component</code>、<code>@Service</code>、<code>@Repository</code>、<code>@Controller</code> 等注解。然后将这些类注册为容器中的 bean。</li>
</ul>
</li>
<li><p><strong>创建和注册BeanDefinition对象</strong>：Spring容器会根据配置信息创建BeanDefinition对象，并将其注册到 <code>BeanFactory</code> 中。</p>
<ul>
<li>BeanDefinition对象包含了Bean的详细信息，如Bean的类名、依赖关系、生命周期等；</li>
<li><strong>BeanFactory</strong>：<code>BeanFactory</code> 是 Spring 中用于管理和存储 <code>BeanDefinition</code> 的容器。<code>DefaultListableBeanFactory</code> 是常见的 <code>BeanFactory</code> 实现，它用于存储和管理所有的 bean 定义。</li>
</ul>
</li>
<li><p><strong>Bean实例化</strong>：Spring 容器根据 <code>BeanDefinition</code> 反射实例化 bean。这个过程通常是懒加载的，即只有在真正需要该 bean 时才会被实例化。</p>
<ul>
<li>这一过程会调用Bean的构造方法；</li>
<li>会调用Bean的setter方法，完成Bean的属性注入。</li>
</ul>
</li>
<li><p><strong>初始化 Bean</strong>：依赖注入和对象赋值/属性填充，调用Aware子类方法。调用BeanPostProcessor前置处理方法。调用<code>init-method</code> 。调用BeanPostProcessor后置处理方法。</p>
<p>在实例化 bean 后，Spring 容器会注入该 bean 所依赖的其他 bean：</p>
<ul>
<li><strong>字段注入</strong>：Spring 会通过反射机制向 bean 的字段注入依赖。</li>
<li><strong>构造函数注入</strong>：如果 bean 使用了构造函数注入方式，Spring 会解析构造函数的参数并注入相应的依赖。</li>
<li><strong>setter 注入</strong>：如果 bean 使用了 setter 方法注入方式，Spring 会通过反射调用 setter 方法并注入依赖。</li>
</ul>
<p>在完成依赖注入后，Spring 会检查该 bean 是否有需要执行的初始化方法。可以通过以下几种方式指定初始化方法：</p>
<ul>
<li><strong><code>@PostConstruct</code> 注解</strong>：如果 bean 类上有 <code>@PostConstruct</code> 注解，Spring 会在 bean 完成依赖注入后调用该方法。</li>
<li><strong><code>InitializingBean</code> 接口</strong>：如果 bean 实现了 <code>InitializingBean</code> 接口，Spring 会调用 <code>afterPropertiesSet()</code> 方法进行初始化。</li>
<li><strong><code>init-method</code> 属性</strong>：在 XML 配置中，可以通过 <code>init-method</code> 属性指定初始化方法。</li>
</ul>
</li>
<li><p><strong>使用 Bean</strong>：当 bean 初始化完成后，容器就可以将其提供给应用程序使用。通过getBean方法直接获取。如果是单例 bean，Spring 会将其保存在容器中，直到容器关闭。如果是原型 bean，Spring 会每次创建新的实例。</p>
</li>
<li><p><strong>销毁 Bean</strong>：当容器关闭时，Spring 会销毁容器中的所有 bean。销毁过程会按照以下步骤进行：</p>
<ul>
<li><strong><code>@PreDestroy</code> 注解</strong>：如果 bean 类上有 <code>@PreDestroy</code> 注解，Spring 会调用该方法。</li>
<li><strong><code>DisposableBean</code> 接口</strong>：如果 bean 实现了 <code>DisposableBean</code> 接口，Spring 会调用 <code>destroy()</code> 方法进行销毁。</li>
<li><strong><code>destroy-method</code> 属性</strong>：在 XML 配置中，可以通过 <code>destroy-method</code> 属性指定销毁方法。</li>
</ul>
</li>
<li><p><strong>容器关闭</strong>：销毁所有的 singleton beans，并释放容器中持有的所有资源。这通常通过调用 <code>ApplicationContext</code> 的 <code>close()</code> 方法来触发。</p>
</li>
</ol>
</li>
<li><p>BeanDefinition加载流程：</p>
<ol>
<li><p><strong>Resource资源定位</strong>：即容器寻找数据，寻找用户定义的bean资源，由ResourceLoader通过统一的接口Resource接口来完成。资源一般以XML配置文件、注解或Java配置类等形式存在。</p>
</li>
<li><p><strong>BeanDefinition载入</strong>：Bean将配置文件中描述的Bean信息转化为Spring容器内部的数据结构BeanDefinition。通过不同的BeanDefinitionReader读取、解析Resource定位的资源，转换成BeanDefinition，并载入到IoC中。</p>
</li>
<li><p><strong>BeanDefinition注册</strong>：即向IOC容器注册这些BeanDefinition，以便后续能够根据配置信息实例化和管理Bean。</p>
<ul>
<li><p>在 Spring 容器初始化时，会创建一个 <code>DefaultListableBeanFactory</code> 对象作为 BeanFactory。</p>
</li>
<li><p>注册BeanDefinition：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 向 DefaultListableBeanFactory 注册 BeanDefinition</span></span><br><span class="line">beanFactory.registerBeanDefinition(<span class="string">&quot;myBean&quot;</span>, beanDefinition);</span><br></pre></td></tr></table></figure></li>
<li><p>注册过程就是<strong>将beanDefinition放入到维护的ConcurrentHashMap中</strong>。</p>
</li>
<li><p><code>DefaultListableBeanFactory</code> 是 <code>BeanFactory</code> 和 <code>BeanDefinitionRegistry</code> 的默认实现类，它同时实现了这两个接口，用于承担 Bean 的注册和管理的职责。</p>
</li>
</ul>
</li>
</ol>
</li>
<li><p><code>BeanFactory</code> 接口：是 Spring IoC 容器的基础接口，定义了 IoC 容器的基本行为。<code>BeanFactory</code> 的典型实现是 <code>DefaultListableBeanFactory</code>，它是 Spring 中最简单的 IoC 容器实现。</p>
<ul>
<li>获取 Bean 实例</li>
<li>检查 Bean 是否存在</li>
<li>获取 Bean 的类型</li>
<li>控制 Bean 的生命周期</li>
<li>解决 Bean 之间的依赖关系</li>
</ul>
</li>
<li><p><code>ApplicationContext</code> 接口：是 <code>BeanFactory</code> 的子接口，提供了更多的功能，使得应用程序开发更加方便。<code>ApplicationContext</code> 继承了 <code>BeanFactory</code>，同时还包含了一些额外的功能。<code>ApplicationContext</code> 是 <code>BeanFactory</code> 的功能扩展，提供了更多的企业级特性，适用于绝大多数的 Spring 应用程序。</p>
<ul>
<li>支持国际化<ul>
<li>事件传播机制</li>
<li>资源加载</li>
<li>AOP 支持</li>
<li>事务管理</li>
</ul>
</li>
</ul>
<p>典型实现包括：</p>
<ul>
<li><code>ClassPathXmlApplicationContext</code>: 从类路径加载 XML 配置文件创建容器。</li>
<li><code>FileSystemXmlApplicationContext</code>: 从文件系统中加载 XML 配置文件创建容器。</li>
<li><code>AnnotationConfigApplicationContext</code>: 基于注解的配置创建容器。</li>
</ul>
</li>
</ul>
<p>Spring IoC的扩展点：</p>
<ol>
<li><p><strong>BeanPostProcessor：</strong> 允许在每个Bean的初始化前后进行自定义处理。开发者可以通过实现<code>BeanPostProcessor</code>接口来定义在Bean初始化前后进行的操作。</p>
</li>
<li><p><strong>BeanFactoryPostProcessor：</strong> 允许在BeanFactory实例化Bean之前对BeanFactory进行自定义处理。通过实现<code>BeanFactoryPostProcessor</code>接口，开发者可以在容器实例化Bean之前修改或添加Bean的定义信息。如PlaceHolderConfigurSupport、ConfigurationClassPostProcessor</p>
</li>
<li><p><strong>FactoryBean：</strong> 允许定义产生一个或多个对象的工厂Bean。通过实现<code>FactoryBean</code>接口，可以自定义创建Bean的逻辑，返回的对象将成为Spring容器中的一个Bean。</p>
</li>
<li><p><strong>ApplicationContextInitializer：</strong> 允许在容器初始化时对<code>ApplicationContext</code>进行扩展。通过实现<code>ApplicationContextInitializer</code>接口，可以在容器初始化的早期执行自定义逻辑。</p>
</li>
<li><p><strong>ApplicationListener：</strong> 允许监听容器中发布的事件。通过实现<code>ApplicationListener</code>接口，可以监听容器中各种事件，例如Bean初始化完成、容器启动完成等。</p>
</li>
</ol>
<p>这些扩展点提供了灵活性，使得开发者可以在Spring容器的不同阶段插入自定义逻辑，实现更高度的定制和扩展。</p>
<h4 id="问：IOC的底层实现？⭐⭐⭐"><a href="#问：IOC的底层实现？⭐⭐⭐" class="headerlink" title="问：IOC的底层实现？⭐⭐⭐"></a>问：IOC的底层实现？⭐⭐⭐</h4><p>核心方法：</p>
<ul>
<li><strong>createBeanFactory</strong>：是创建 <code>BeanFactory</code> 的核心方法，它初始化一个 Spring 容器（通常是 <code>DefaultListableBeanFactory</code>）来存储和管理所有的 bean 定义。<ul>
<li>会根据配置文件（如 XML 配置文件、注解配置等）加载 bean 定义。</li>
<li><code>BeanFactory</code> 是一个核心接口，它的实现 <code>DefaultListableBeanFactory</code> 用于存储和管理 <code>BeanDefinition</code>，并为 bean 提供实例化、依赖注入和生命周期管理等功能。</li>
</ul>
</li>
<li><strong>getBean、doGetBean</strong>：是获取容器中定义的 bean 的方法。<code>doGetBean</code> 是内部方法，负责从 <code>BeanFactory</code> 中获取或创建 bean 的实例。<ul>
<li><code>getBean</code> 会根据给定的 bean 名称（或类型）从容器中查找 bean。</li>
<li>若容器中已有该 bean（对于单例 bean），则直接返回已缓存的实例。</li>
<li>如果容器中没有该 bean，则调用 <code>doGetBean</code>，通常会调用 <code>createBean</code> 创建一个新的实例。</li>
</ul>
</li>
<li><strong>createBean、doCreateBean</strong>：负责实例化 bean。<code>doCreateBean</code> 是 <code>createBean</code> 的内部调用，具体负责如何通过反射机制实例化对象。<ul>
<li>它首先检查是否有该 bean 的定义（<code>BeanDefinition</code>）。然后根据 <code>BeanDefinition</code> 中的信息（如类名、构造函数参数等）创建该 bean。</li>
<li>Spring 使用反射机制来实例化 bean，这通常是通过 <code>getDeclaredConstructor</code> 获取无参构造函数，然后使用 <code>newInstance</code> 创建对象。</li>
</ul>
</li>
<li><strong>createBeanInstance</strong>：负责通过反射机制或工厂方法实例化一个新的 bean 对象。它是 Spring bean 创建的最底层方法，负责通过构造方法实例化对象。<ul>
<li><strong>getDeclaredConstructor</strong>：是反射 API 中的方法，Spring 使用它来获取类的构造函数。如果容器配置的是无参构造函数，Spring 会优先使用该构造函数创建实例。</li>
<li><strong>newInstance</strong>：通过反射机制实例化一个新的对象。</li>
</ul>
</li>
<li><strong>populateBean</strong>：负责给 bean 进行属性填充的过程，即将 bean 的依赖注入到实例中。<ul>
<li>在实例化 bean 后，<code>populateBean</code> 会根据 <code>BeanDefinition</code> 中的定义，通过构造函数注入、Setter 注入或字段注入的方式填充属性。</li>
<li>它会通过反射来设置属性值，通常会调用 <code>set</code> 方法，或者直接注入字段的值。</li>
</ul>
</li>
<li><strong>initializingBean</strong>：是 Spring 提供的一种接口，用于在 bean 完成属性注入后执行初始化操作。<ul>
<li>调用 <code>BeanPostProcessor</code> 的前置处理方法。</li>
<li>在 Spring 容器将依赖注入完成后，会调用实现了 <code>InitializingBean</code> 接口的 <code>afterPropertiesSet()</code> 方法进行初始化操作。</li>
<li>如果在 bean 定义中配置了初始化方法（如 <code>init-method</code>），Spring 还会调用这个方法进行自定义初始化操作。</li>
<li>此外，Spring 还会处理通过注解（如 <code>@PostConstruct</code>）标记的方法。</li>
<li>调用 <code>BeanPostProcessor</code> 的后置处理方法。</li>
</ul>
</li>
</ul>
<ol>
<li>先通过createBeanFactory创建出一个DefaultListableBeanFactory</li>
<li>开始循环创建对象，bean默认单例，通过getBean在容器中查找。</li>
<li>若未找到，通过createBean以反射的方式创建对象。一般通过无参构造方法getDeclaredConstructor，以及newInstance创建。</li>
<li>通过populateBean进行属性填充。</li>
<li>通过initializingBean进行其它初始化操作。</li>
</ol>
<h4 id="问：讲一下依赖注入？DI依赖注入流程-如何实例化，怎么处理bean之间的依赖关系"><a href="#问：讲一下依赖注入？DI依赖注入流程-如何实例化，怎么处理bean之间的依赖关系" class="headerlink" title="问：讲一下依赖注入？DI依赖注入流程? 如何实例化，怎么处理bean之间的依赖关系?"></a>问：讲一下依赖注入？DI依赖注入流程? 如何实例化，怎么处理bean之间的依赖关系?</h4><p><strong>依赖注入（Dependency Injection，DI）</strong>是一种设计模式，用于处理对象之间的依赖关系。在 DI 中，对象的依赖关系不是由对象本身负责获取，而是由外部的容器（通常是 IoC 容器）负责注入。这使得系统更加灵活、松耦合，易于测试和维护。</p>
<p>依赖注入的流程：</p>
<ul>
<li>如果设置lazy-init=true，会在第一次getBean的时候才初始化bean，lazy-init=false，会容器启动的时候直接初始化（singleton bean）；</li>
<li>调用 <code>BeanFactory.getBean()</code> 生成bean的；</li>
<li>生成bean过程运用装饰器模式产生的bean都是beanWrapper（bean的增强）；</li>
</ul>
<p>依赖注入怎么处理bean之间的依赖关系?  </p>
<ul>
<li>其实就是通过在beanDefinition载入时，如果bean有依赖关系，通过<strong>占位符</strong>来代替，在调用getbean时候，如果遇到占位符，从ioc里获取bean注入到本实例来。</li>
</ul>
<h4 id="问：给你spring的jar包你要怎么让它启动？"><a href="#问：给你spring的jar包你要怎么让它启动？" class="headerlink" title="问：给你spring的jar包你要怎么让它启动？"></a>问：给你spring的jar包你要怎么让它启动？</h4><p>使用 <code>nohup</code> 和 <code>java</code> 命令启动 Spring Boot 项目。添加 <code>&amp;</code> 让项目在后台运行，并使用 <code>nohup</code> 避免在 SSH 断开连接时关闭项目。</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">nohup java -jar your-project.jar &amp;</span><br></pre></td></tr></table></figure>



<h3 id="1-3-Spring-Bean"><a href="#1-3-Spring-Bean" class="headerlink" title="1.3 Spring Bean"></a>1.3 Spring Bean</h3><h4 id="问：讲一讲Spring-Bean是什么？"><a href="#问：讲一讲Spring-Bean是什么？" class="headerlink" title="问：讲一讲Spring Bean是什么？"></a>问：讲一讲Spring Bean是什么？</h4><p><code>Bean</code> 通常代表一个对象的实例，这个对象可以是任何 Java 类的实例，包括自定义的类。<strong>Bean是由 <code>Spring IoC</code> 容器所初始化、装配及管理的对象。</strong></p>
<h4 id="问：Spring-Bean定义5种作用域？⭐"><a href="#问：Spring-Bean定义5种作用域？⭐" class="headerlink" title="问：Spring Bean定义5种作用域？⭐"></a>问：Spring Bean定义5种作用域？⭐</h4><p>在 Spring 框架中，<code>Bean</code> 可以具有不同的作用域，表示 <code>Bean</code> 实例的生命周期和可见性范围，这些作用域可以通过 XML 配置文件或通过 Java 注解的方式指定。</p>
<p>选择合适的作用域取决于 <code>Bean</code> 的用途和生命周期需求。：</p>
<ul>
<li><p><strong>Singleton（单例）：</strong> 单例作用域是默认的作用域，Spring IoC 容器中仅存在一个Bean实例，Bean以单例的形式存在，无论有多少次请求，都返回同一个实例。适合Service类、工具类等。</p>
 <figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;mySingletonBean&quot;</span> <span class="attr">class</span>=<span class="string">&quot;com.example.MyBean&quot;</span> <span class="attr">scope</span>=<span class="string">&quot;singleton&quot;</span>/&gt;</span></span><br></pre></td></tr></table></figure>

<p> 或者通过 Java 注解：</p>
 <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="meta">@Scope(&quot;singleton&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MySingletonBean</span> </span>&#123;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>Prototype（原型）：</strong> 表示每次请求都创建一个新的 <code>Bean</code> 实例。每次注入或获取 <code>Bean</code> 时，都会创建一个新的对象。即每次调用 <code>getBean()</code> 时，相当于执行 <code>new XxxBean()</code> 。适合控制器、命令对象等。</p>
 <figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;myPrototypeBean&quot;</span> <span class="attr">class</span>=<span class="string">&quot;com.example.MyBean&quot;</span> <span class="attr">scope</span>=<span class="string">&quot;prototype&quot;</span>/&gt;</span></span><br></pre></td></tr></table></figure>

<p> 或者通过 Java 注解：</p>
 <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="meta">@Scope(&quot;prototype&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyPrototypeBean</span> </span>&#123;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>Request（请求）：</strong> 请求作用域表示在每个 HTTP 请求中都创建一个新的 <code>Bean</code> 实例。该作用域仅适用于 Spring Web 应用程序 <code>WebApplicationContext</code> 环境，适合Web请求。</p>
 <figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;myRequestBean&quot;</span> <span class="attr">class</span>=<span class="string">&quot;com.example.MyBean&quot;</span> <span class="attr">scope</span>=<span class="string">&quot;request&quot;</span>/&gt;</span></span><br></pre></td></tr></table></figure></li>
<li><p><strong>Session（会话）：</strong> 表示在每个用户会话中都创建一个新的 <code>Bean</code> 实例。该作用域同样仅适用于 Spring Web 应用程序 <code>WebApplicationContext</code> 环境。同一个 <code>HTTP Session</code> 共享一个Bean，不同Session使用不同Bean，适合用户的购物车、个性化设置等。</p>
 <figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;mySessionBean&quot;</span> <span class="attr">class</span>=<span class="string">&quot;com.example.MyBean&quot;</span> <span class="attr">scope</span>=<span class="string">&quot;session&quot;</span>/&gt;</span></span><br></pre></td></tr></table></figure></li>
<li><p><strong>GlobalSession（全局会话）：</strong> 全局会话作用域是在一个全局 HTTP 会话中创建一个 <code>Bean</code> 实例。通常仅适用于分布式的 Spring Web 应用程序 <code>WebApplicationContext</code> 环境，适合集群共享的对象。</p>
 <figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;myGlobalSessionBean&quot;</span> <span class="attr">class</span>=<span class="string">&quot;com.example.MyBean&quot;</span> <span class="attr">scope</span>=<span class="string">&quot;globalsession&quot;</span>/&gt;</span></span><br></pre></td></tr></table></figure></li>
</ul>
<h4 id="问：Spring的生命周期？Spring-bean生命周期？（源码细节，以及各个位置的设计思路，有什么可扩展的）⭐⭐⭐"><a href="#问：Spring的生命周期？Spring-bean生命周期？（源码细节，以及各个位置的设计思路，有什么可扩展的）⭐⭐⭐" class="headerlink" title="问：Spring的生命周期？Spring bean生命周期？（源码细节，以及各个位置的设计思路，有什么可扩展的）⭐⭐⭐"></a>问：Spring的生命周期？Spring bean生命周期？（源码细节，以及各个位置的设计思路，有什么可扩展的）⭐⭐⭐</h4><p>参考：<a href="../2020021001.html" title="Title">Spring Bean</a></p>
<ol>
<li><strong>实例化（Instantiation）：</strong> Ioc容器通过获取BeanDefinition对象中的信息进行实例化。读取bean的xml配置文件，将bean元素分别转换成一个BeanDefinition对象。然后通过BeanDefinitionRegistry将这些bean注册到beanFactory中，保存在它的一个ConcurrentHashMap中。</li>
<li><strong>属性赋值（Populate Properties）：</strong> 通过BeanWrapper提供的设置属性的接口完成属性依赖注入；实例化对象被包装在BeanWrapper对象中，BeanWrapper提供了设置对象属性的接口，从而避免了使用反射机制设置属性。</li>
<li><strong>注入Aware接口</strong>：Spring会检测该对象是否实现了xxxAware接口，并将相关的xxxAware实例注入给bean。通过invokeAwareMethod完成BeanName、BeanFactory、BeanClassLoader对象的属性设置。</li>
<li><strong>BeanPostProcessor 的前置处理：</strong> 经过前几步，bean对象已经正确的构造。如果需要在使用对象前再进行一些自定义的步骤，就通过该接口来实现。如果应用中存在实现了 <code>BeanPostProcessor</code> 接口的类，容器会在 Bean 初始化前后调用这些处理器的方法。这提供了自定义初始化逻辑的扩展点。<ul>
<li><code>BeanPostProcessor</code> 接口中的两个方法是 <code>postProcessBeforeInitialization</code> 和 <code>postProcessAfterInitialization</code>，分别代表前置处理和后置处理。</li>
</ul>
</li>
<li><strong>初始化方法调用（InitializingBean与init-method）</strong>：执行我们自己定义的初始化方法。如果 Bean 配置中指定了初始化方法，容器会在属性赋值后调用该初始化方法。<ul>
<li>如果 Bean 实现了 <code>InitializingBean</code> 接口，容器也会调用其 <code>afterPropertiesSet</code> 方法。</li>
<li>如果bean配置了自定义的 <code>init-method</code> ，若声明则调用对应方法。</li>
</ul>
</li>
<li><strong>BeanPostProcessor 的后置处理：</strong> 类似于前置处理，如果应用中存在实现了 <code>BeanPostProcessor</code> 接口的类，容器会在 Bean 初始化后调用这些处理器的方法。这提供了自定义后置处理逻辑的扩展点。AOP在此实现，AbstractAutoProxyCreator。</li>
<li><strong>Bean 使用中：</strong> 在初始化后，Bean 可以被应用程序使用。在这个阶段，Bean 执行它的业务逻辑。</li>
<li><strong>销毁阶段（destroy）：</strong> 如果 Bean 的作用域是 singleton，并且配置了销毁方法，容器在关闭时会调用 Bean 的销毁方法。<ul>
<li>如果bean实现了 <code>DisposableBean</code> 接口，Spring将调用 <code>destroy()</code> 方法。</li>
<li>如果bean配置了自定义 <code>destroy-method</code> ，则会调用对应销毁方法。</li>
</ul>
</li>
</ol>
<p>可扩展：</p>
<ul>
<li>实现BeanPostProcessor接口的前置处理和后置处理。</li>
<li>自定义初始化方法和销毁方法，在 Bean 配置中使用 <code>init-method</code> 和 <code>destroy-method</code> 属性，或者实现 <code>InitializingBean</code> 和 <code>DisposableBean</code> 接口。</li>
</ul>
<h4 id="问：讲一下bean成员变量的参数注入有哪种方式？⭐"><a href="#问：讲一下bean成员变量的参数注入有哪种方式？⭐" class="headerlink" title="问：讲一下bean成员变量的参数注入有哪种方式？⭐"></a>问：讲一下bean成员变量的参数注入有哪种方式？⭐</h4><ol>
<li><p><strong>构造器注入（Constructor Injection）</strong>：通过构造函数来注入依赖项。这是一种推荐的注入方式，因为它可以保证 Bean 在实例化后就拥有所有必需的依赖项。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> Dependency dependency;</span><br><span class="line">   </span><br><span class="line">   <span class="comment">// 构造器注入</span></span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="title">Example</span><span class="params">(Dependency dependency)</span> </span>&#123;</span><br><span class="line">       <span class="keyword">this</span>.dependency = dependency;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure></li>
<li><p><strong>Setter 方法注入（Setter Injection）：</strong> 通过 setter 方法为 Bean 的成员变量注入依赖项。这是最常见的注入方式，可以提供更灵活的配置。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> Dependency dependency;</span><br><span class="line">   </span><br><span class="line"><span class="comment">// Setter 方法注入</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setDependency</span><span class="params">(Dependency dependency)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.dependency = dependency;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li><p><strong>注解注入（Annotation-based Injection）：</strong> 使用注解（如 <code>@Autowired</code>、<code>@Inject</code> 等）在字段、方法或构造器上标注，容器在创建对象时通过反射机制将依赖注入。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Autowired</span></span><br><span class="line">   <span class="keyword">private</span> Dependency dependency;</span><br><span class="line">   </span><br><span class="line">   <span class="comment">// 或者通过构造器注入</span></span><br><span class="line">   <span class="meta">@Autowired</span></span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="title">Example</span><span class="params">(Dependency dependency)</span> </span>&#123;</span><br><span class="line">       <span class="keyword">this</span>.dependency = dependency;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure></li>
<li><p><strong>接口注入（Interface-based Injection）：</strong> 通过接口定义依赖注入的方法，类实现该接口，并在实现类中实现依赖的注入逻辑。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">DependencyInjector</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">injectDependency</span><span class="params">(Dependency dependency)</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Example</span> <span class="keyword">implements</span> <span class="title">DependencyInjector</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> Dependency dependency;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 接口注入</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">injectDependency</span><span class="params">(Dependency dependency)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.dependency = dependency;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ol>
<ul>
<li>构造器注入通常用于强制依赖关系，确保对象在创建时就拥有所需的依赖。</li>
<li>Setter 方法注入提供了更灵活的依赖注入方式，允许在对象创建后进行动态变更。</li>
<li>注解注入是一种简洁的方式，通过注解标注字段或方法，容器可以自动完成依赖注入。</li>
<li>接口注入可通过定义接口实现依赖注入的方法，但相对来说较少使用。</li>
</ul>
<h4 id="问：为什么Spring不推荐使用属性注入？"><a href="#问：为什么Spring不推荐使用属性注入？" class="headerlink" title="问：为什么Spring不推荐使用属性注入？"></a>问：为什么Spring不推荐使用属性注入？</h4><p>使用@Autowired等进行属性注入时，其本质是通过反射机制，所以<strong>执行时刻是在对象创建完成后</strong>。而Spring推荐使用构造器注入，执行时刻是在对象创建过程中init阶段：</p>
<ol>
<li>注入在对象创建过程中，而不是之后通过新增一个阶段，没有破坏流程。</li>
<li>相比反射，在项目启动时性能提升了。</li>
</ol>
<h4 id="问：Spring中的BeanFactory-、FactoryBean、ObjectFactory⭐"><a href="#问：Spring中的BeanFactory-、FactoryBean、ObjectFactory⭐" class="headerlink" title="问：Spring中的BeanFactory 、FactoryBean、ObjectFactory⭐"></a>问：Spring中的BeanFactory 、FactoryBean、ObjectFactory⭐</h4><p>BeanFactory 、FactoryBean都创建Bean对象，BeanFactory是IOC容器，创建的对象要遵循严格的生命周期。若想自定义某个对象的创建，并最终把对象交给Spring来管理，则由FactoryBean实现。</p>
<ul>
<li><p>BeanFactory 即IOC容器，有多种实现，负责管理Spring中的Bean。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">BeanFactory</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    ...</span><br><span class="line">        </span><br><span class="line">	<span class="function">Object <span class="title">getBean</span><span class="params">(String name)</span> <span class="keyword">throws</span> BeansException</span>;</span><br><span class="line">	&lt;T&gt; <span class="function">T <span class="title">getBean</span><span class="params">(String name, Class&lt;T&gt; requiredType)</span> <span class="keyword">throws</span> BeansException</span>;</span><br><span class="line">	<span class="function">Object <span class="title">getBean</span><span class="params">(String name, Object... args)</span> <span class="keyword">throws</span> BeansException</span>;</span><br><span class="line">    </span><br><span class="line">    ...</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">boolean</span> <span class="title">isSingleton</span><span class="params">(String name)</span> <span class="keyword">throws</span> NoSuchBeanDefinitionException</span>;</span><br><span class="line">	<span class="function"><span class="keyword">boolean</span> <span class="title">isPrototype</span><span class="params">(String name)</span> <span class="keyword">throws</span> NoSuchBeanDefinitionException</span>;</span><br><span class="line">	<span class="function"><span class="keyword">boolean</span> <span class="title">isTypeMatch</span><span class="params">(String name, ResolvableType typeToMatch)</span> <span class="keyword">throws</span> NoSuchBeanDefinitionException</span>;</span><br><span class="line"></span><br><span class="line">    ...</span><br><span class="line">        </span><br><span class="line">	Class&lt;?&gt; getType(String name) <span class="keyword">throws</span> NoSuchBeanDefinitionException;</span><br><span class="line"></span><br><span class="line">    ...</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li><p>FactoryBean是一种Bean，要获取某个 Bean 的时候容器会调用 FactoryBean#getObject() 方法，该方法封装了对象<strong>复杂的创建过程</strong>。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">FactoryBean</span>&lt;<span class="title">T</span>&gt; </span>&#123;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 自定义创建对象的过程</span></span><br><span class="line">	<span class="function">T <span class="title">getObject</span><span class="params">()</span> <span class="keyword">throws</span> Exception</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 获取对象类型</span></span><br><span class="line">	Class&lt;?&gt; getObjectType();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 是否单例</span></span><br><span class="line">	<span class="function"><span class="keyword">default</span> <span class="keyword">boolean</span> <span class="title">isSingleton</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li><p>ObjectFactory用于延迟查找的场景（三级缓存），它就是一个普通工厂，当得到 ObjectFactory 对象时，相当于 Bean 没有被创建，只有当 getObject() 方法时，才会触发 Bean 实例化等生命周期。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">ObjectFactory</span>&lt;<span class="title">T</span>&gt; </span>&#123;</span><br><span class="line"></span><br><span class="line">	<span class="function">T <span class="title">getObject</span><span class="params">()</span> <span class="keyword">throws</span> BeansException</span>;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
<h4 id="问：单例模式的几种实现方式？Spring的单例是怎么实现的？单例的情况下怎么实例化，什么时候，多例呢？"><a href="#问：单例模式的几种实现方式？Spring的单例是怎么实现的？单例的情况下怎么实例化，什么时候，多例呢？" class="headerlink" title="问：单例模式的几种实现方式？Spring的单例是怎么实现的？单例的情况下怎么实例化，什么时候，多例呢？"></a>问：单例模式的几种实现方式？Spring的单例是怎么实现的？单例的情况下怎么实例化，什么时候，多例呢？</h4><p>单例模式有三种实现方式：</p>
<ol>
<li><p><strong>饿汉式：</strong> 在类加载的时候就创建单例实例。这意味着无论是否需要使用该单例对象，它都会在类加载时创建。这样可以确保在多线程环境下也能保持唯一性。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Singleton</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> Singleton instance = <span class="keyword">new</span> Singleton();</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="title">Singleton</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 私有构造方法</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Singleton <span class="title">getInstance</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> instance;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li><p><strong>懒汉式：</strong> 在需要使用单例对象的时候才创建实例。这样可以延迟实例的创建，避免在应用启动时就占用资源。它使用同步方法或双重检查锁定来确保线程安全。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">LazySingleton</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> LazySingleton instance;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="title">LazySingleton</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 私有构造方法</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">synchronized</span> LazySingleton <span class="title">getInstance</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (instance == <span class="keyword">null</span>) &#123;</span><br><span class="line">            instance = <span class="keyword">new</span> LazySingleton();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> instance;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ol>
<ol start="3">
<li><p>单例注册表：通过一个ConcurrentHashMap存储Bean对象，保证Bean名称唯一的情况下也能保证线程安全。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">RegSingleton</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">static</span> Map&lt;String, Object&gt; singletonObjects = <span class="keyword">new</span> ConcurrentHashMap&lt;&gt;(<span class="number">16</span>);</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="title">RegSingleton</span><span class="params">()</span></span>&#123;&#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Object <span class="title">getInstance</span><span class="params">(String className)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (StringUtils.isEmpty(className)) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (singletonObjects.get(className) == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                singletonObjects.put(className, Class.forName(className).newInstance());</span><br><span class="line">            &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> singletonObjects.get(className);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ol>
<p><strong>Spring使用单例注册表来实现单例模式</strong>，单例注册表（Singleton Registry）是通过<code>DefaultSingletonBeanRegistry</code>这个类来实现的。其是负责管理单例bean的默认实现。它维护了一个单例缓存（通过ConcurrentHashMap实现的singletonObjects）来保存已经创建的单例bean实例，以及一个早期单例缓存（earlySingletonObjects）来保存在bean的实例化过程中早期暴露的bean实例。</p>
<p><strong>实例化时机：</strong> </p>
<ul>
<li><strong>单例：</strong> Bean 的实例化发生在容器启动阶段。当容器启动时，会根据配置或注解信息创建并初始化所有单例 Bean，并将它们放入容器中供后续使用。</li>
<li><strong>多例：</strong> 多例Bean在每次被请求时都会创建一个新的实例，因此实例化时机是在每次请求该Bean时。</li>
</ul>
<h3 id="1-4-循环依赖"><a href="#1-4-循环依赖" class="headerlink" title="1.4 循环依赖"></a>1.4 循环依赖</h3><h4 id="问：什么是循环依赖？"><a href="#问：什么是循环依赖？" class="headerlink" title="问：什么是循环依赖？"></a>问：什么是循环依赖？</h4><p>什么是循环依赖？</p>
<ul>
<li><p>如代码所示，即 A 里面注入 B，B 里面又注入 A。此时，就发生了「循环依赖」。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">A</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> B b;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">B</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> A a;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
<h4 id="问：怎么检测是否存在循环依赖？"><a href="#问：怎么检测是否存在循环依赖？" class="headerlink" title="问：怎么检测是否存在循环依赖？"></a>问：怎么检测是否存在循环依赖？</h4><ul>
<li>通过<code>DefaultSingletonBeanRegistry</code>类中的<code>singletonsCurrentlyInCreation</code>集合。这个集合用于跟踪当前正在创建的单例Bean的名称，如果发现正在创建中，说明存在循环依赖，抛出<code>BeanCurrentlyInCreationException</code>异常。</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> Set&lt;String&gt; singletonsCurrentlyInCreation = Collections.newSetFromMap(<span class="keyword">new</span> ConcurrentHashMap(<span class="number">16</span>));</span><br></pre></td></tr></table></figure>





<h4 id="问：Spring中循环依赖场景？"><a href="#问：Spring中循环依赖场景？" class="headerlink" title="问：Spring中循环依赖场景？"></a>问：Spring中循环依赖场景？</h4><ul>
<li><p>属性的循环依赖：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">A</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> B b;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">B</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> A a;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li><p>构造器的循环依赖：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ClassA</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> ClassB b;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">ClassA</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 构造器中依赖ClassB</span></span><br><span class="line">        <span class="keyword">this</span>.b = <span class="keyword">new</span> ClassB(<span class="keyword">this</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ClassB</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> ClassA a;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">ClassB</span><span class="params">(ClassA a)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 构造器中依赖ClassA</span></span><br><span class="line">        <span class="keyword">this</span>.a = a;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
<h4 id="问：Spring-怎么解决单例-Bean-的循环依赖问题？⭐⭐⭐"><a href="#问：Spring-怎么解决单例-Bean-的循环依赖问题？⭐⭐⭐" class="headerlink" title="问：Spring 怎么解决单例 Bean 的循环依赖问题？⭐⭐⭐"></a>问：Spring 怎么解决单例 Bean 的循环依赖问题？⭐⭐⭐</h4><ol>
<li><p><strong>解决方案</strong>：<strong>三级缓存</strong>，只针对单例模式的属性循环依赖，不能解决其它模式的循环依赖问题。</p>
</li>
<li><p><strong>哪三级缓存</strong>：三级缓存对应类 <code>DefaultSingletonBeanRegistry</code> 以及调用方 <code>AbstractAutowireCapableBeanFactory</code> 工厂类的doCreateBean</p>
<ul>
<li><p><strong>singletonObjects</strong>：第一级缓存，里面放置的是实例化好的单例对象，是最终的成品对象； <strong>对象完成属性赋值和初始化，生成完整对象后放入一级缓存。</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> Map&lt;String, Object&gt; singletonObjects = <span class="keyword">new</span> ConcurrentHashMap&lt;String, Object&gt;(<span class="number">256</span>);</span><br></pre></td></tr></table></figure></li>
<li><p><strong>earlySingletonObjects</strong>：第二级缓存，里面存放的是提前曝光的单例对象（尚未填充属性、未执行init方法），半成品对象； <strong>从三级缓存中判断是否需要代理，决定返回代理对象还是普通对象后，放入二级缓存。</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> Map&lt;String, Object&gt; earlySingletonObjects = <span class="keyword">new</span> HashMap&lt;String, Object&gt;(<span class="number">16</span>);</span><br></pre></td></tr></table></figure></li>
<li><p><strong>singletonFactories</strong>：第三级缓存，存放 bean 工厂对象，是要被实例化的对象的对象工厂。ObjectFactory是函数接口，定义了getObject()方法，传入Bean名字和实例，通过AOP来创建，但不会立即调用。<strong>当对象调用createBeanInstance实例化后放入三级缓存，还未属性赋值和初始化</strong>。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> Map&lt;String, ObjectFactory&lt;?&gt;&gt; singletonFactories = <span class="keyword">new</span> HashMap&lt;String, ObjectFactory&lt;?&gt;&gt;(<span class="number">16</span>);</span><br></pre></td></tr></table></figure></li>
</ul>
</li>
<li><p><strong>核心方法</strong>：<strong>getSingleton(name, ObjectFactory)：</strong> 获取指定名称的单例bean，如果不存在，则使用提供的<code>ObjectFactory</code>接口创建一个新的实例。</p>
<ol>
<li>尝试从一级缓存中获取。</li>
<li>若是获取不到，而且对象正在建立中，则尝试从二级缓存中获取。</li>
<li>若还是获取不到，且允许从三级缓存中经过 singletonFactory 的 <code>getObject()</code> 方法获取 Bean 对象，就会尝试从三级缓存中获取 Bean。</li>
<li>若是在三级缓存中获取到了 Bean，会将该 Bean 存放到二级缓存中。</li>
</ol>
</li>
<li><p><strong>三级缓存解决循环依赖的原因</strong>：<strong>提前曝光半成品对象</strong>，当对象实例化后（还未进行属性赋值和初始化），会被放入三级缓存，提前曝光给IoC容器。</p>
</li>
<li><p>流程：</p>
<ol>
<li><p>创建对象A，通过<strong>AbstractBeanFactory.createBean</strong>方法创建Bean（是DefaultSingletonBeanRegistry的子类），先进行<strong>实例化</strong>，实例化后<strong>加入三级缓存</strong>。调用 <code>doCreateBean</code> 方法时会调用 <code>addSingletonFactory</code> 方法，将已实例化但未属性赋值未初始化的对象 A 放入三级缓存 <code>singletonFactories</code> 中。<strong>即将对象 A 提早曝光给 IoC 容器。</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">    <span class="keyword">boolean</span> earlySingletonExposure = mbd.isSingleton() &amp;&amp; <span class="keyword">this</span>.allowCircularReferences &amp;&amp; <span class="keyword">this</span>.isSingletonCurrentlyInCreation(beanName);</span><br><span class="line">    <span class="keyword">if</span> (earlySingletonExposure) &#123;</span><br><span class="line">        <span class="comment">// 传入lambda到三级缓存</span></span><br><span class="line">        <span class="keyword">this</span>.addSingletonFactory(beanName, () -&gt; &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">this</span>.getEarlyBeanReference(beanName, mbd, bean);</span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;</span><br><span class="line">      </span><br><span class="line"><span class="function"><span class="keyword">protected</span> Object <span class="title">getEarlyBeanReference</span><span class="params">(String beanName, RootBeanDefinition mbd, Object bean)</span> </span>&#123;</span><br><span class="line">    Object exposedObject = bean;</span><br><span class="line">    <span class="keyword">if</span> (!mbd.isSynthetic() &amp;&amp; <span class="keyword">this</span>.hasInstantiationAwareBeanPostProcessors()) &#123;</span><br><span class="line">        <span class="comment">// 遍历beanPostProcessors找到SmartInstantiationAwareBeanPostProcessor接口</span></span><br><span class="line">        Iterator var5 = <span class="keyword">this</span>.getBeanPostProcessors().iterator();</span><br><span class="line">      </span><br><span class="line">        <span class="keyword">while</span>(var5.hasNext()) &#123;</span><br><span class="line">            BeanPostProcessor bp = (BeanPostProcessor)var5.next();</span><br><span class="line">            <span class="keyword">if</span> (bp <span class="keyword">instanceof</span> SmartInstantiationAwareBeanPostProcessor) &#123;</span><br><span class="line">                SmartInstantiationAwareBeanPostProcessor ibp = (SmartInstantiationAwareBeanPostProcessor)bp;</span><br><span class="line">                <span class="comment">// 通过判断是否满足AOP条件，返回包装后的代理对象</span></span><br><span class="line">                exposedObject = ibp.getEarlyBeanReference(exposedObject, beanName);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    </span><br><span class="line">      </span><br><span class="line">    <span class="keyword">return</span> exposedObject;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li><p>实例化后继续为对象A进行<strong>属性赋值</strong>，发现A依赖对象B，尝试获取对象B。</p>
</li>
<li><p>发现B对象未创建，尝试创建对象B。</p>
</li>
<li><p>创建对象B，同A，执行实例化和属性赋值后，发现依赖对象A。</p>
</li>
<li><p>尝试在缓存中查找对象A：一级缓存未发现（因为A是半成品），二级缓存未发现A（还未完成属性赋值），<strong>三级缓存找到对象A</strong>。<strong>若实现了AOP则调用，否则返回传入函数接口的Bean实例，将对象A放入二级缓存，避免重复创建。</strong></p>
</li>
<li><p>对象B找到对象A后，继续执行属性赋值和<strong>初始化</strong>操作，完成后<strong>放入一级缓存，移除二级和三级缓存</strong>。</p>
</li>
<li><p>此时对象A可以从一级缓存中找到对象B，继续完成后续操作。</p>
</li>
</ol>
</li>
</ol>
<p>源码分析：</p>
<ul>
<li><p>首先是<code>DefaultSingletonBeanRegistry</code>的一些关键方法和属性：</p>
<ol>
<li><strong>singletonObjects：</strong> 一级缓存，保存已经实例化的单例bean。使用<code>ConcurrentHashMap</code>来保证线程安全。</li>
<li><strong>earlySingletonObjects：</strong> 二级缓存，保存在bean实例化过程中早期暴露的bean实例，即尚未完全初始化的bean。</li>
<li><strong>singletonFactories：</strong> 三级缓存，保存创建bean的工厂实例。</li>
<li><strong>singletonsCurrentlyInCreation：</strong> 检查是否存在循环依赖，用于快速检查某个bean是否已经注册。</li>
<li><strong>getSingleton(name, ObjectFactory)：</strong> 获取指定名称的单例bean，如果不存在，则使用提供的<code>ObjectFactory</code>创建一个新的实例。</li>
<li><strong>createSingleton(name, ObjectFactory)：</strong> 创建指定名称的单例bean实例。</li>
<li><strong>beforeSingletonCreation(name)：</strong> 标记bean的创建过程已经开始。</li>
<li><strong>afterSingletonCreation(name)：</strong> 标记bean的创建过程已经完成。</li>
<li><strong>destroySingleton(name)：</strong> 销毁指定名称的单例bean。</li>
</ol>
<p>Spring通过以上方法和数据结构来维护单例bean的生命周期。在容器启动时，Spring会遍历配置文件或注解扫描的结果，通过<code>createSingleton</code>方法创建并注册所有的单例bean。在整个应用程序运行过程中，Spring负责维护这些单例bean的生命周期，包括初始化、依赖注入、销毁等阶段。</p>
</li>
<li><p>函数调用过程：</p>
<ol>
<li>AbstractBeanFactory.getBean(A)</li>
<li>AbstractBeanFactory.doGetBean(A)</li>
<li>DefaultSingletonBeanRegistry.getSingleton(A, true)：首次检查一级缓存到三级缓存</li>
<li>DefaultSingletonBeanRegistry.getSingleton(A, createBean(A))：检查并创建一个Bean实例，调用doCreateBean。</li>
<li>AbstractAutowireCapableBeanFactory.doCreateBean(A)：<ul>
<li>首先<strong>实例化</strong>：createBeanInstance()</li>
<li>实例化后先调用addSingletonFactory(beanName, () -&gt; getEarlyBeanReference(beanName, mbd, bean))：<strong>先放入三级缓存</strong></li>
<li>然后<strong>属性赋值</strong>：populateBean()，在这里注入依赖的属性。<ul>
<li>发现依赖对象B，B创建过程同A，在B属性赋值时发现A，此时再次getBean(A) -&gt;  doGetBean(A) -&gt; getSingleton(A, true) ，此时发现三级缓存有A，则调用getObject()实例化并<strong>存入二级缓存</strong>。</li>
<li>B继续完成初始化，并放入一级缓存。</li>
</ul>
</li>
<li>最后<strong>初始化</strong>：initializeBean()</li>
<li>初始化后<strong>再次检查一级缓存</strong>：DefaultSingletonBeanRegistry.getSingleton(A, false)，因为传入false，此时不放入二级缓存。</li>
</ul>
</li>
<li>DefaultSingletonBeanRegistry.getSingleton(A, createBean(A)) -&gt; DefaultSingletonBeanRegistry.addSingleton：返回doGetBean函数，并通过addSingleton放入一级缓存，移除二级和三级缓存。</li>
<li>returnBean</li>
</ol>
</li>
<li><p>AbstractBeanFactory源码解析：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br></pre></td><td class="code"><pre><span class="line">  </span><br><span class="line"><span class="keyword">public</span> &lt;T&gt; <span class="function">T <span class="title">getBean</span><span class="params">(String name, <span class="meta">@Nullable</span> Class&lt;T&gt; requiredType, <span class="meta">@Nullable</span> Object... args)</span></span></span><br><span class="line"><span class="function">		<span class="keyword">throws</span> BeansException </span>&#123;</span><br><span class="line">  </span><br><span class="line">	<span class="keyword">return</span> doGetBean(name, requiredType, args, <span class="keyword">false</span>);</span><br><span class="line">&#125;</span><br><span class="line">  </span><br><span class="line"><span class="keyword">protected</span> &lt;T&gt; <span class="function">T <span class="title">doGetBean</span><span class="params">(</span></span></span><br><span class="line"><span class="params"><span class="function">		String name, <span class="meta">@Nullable</span> Class&lt;T&gt; requiredType, <span class="meta">@Nullable</span> Object[] args, <span class="keyword">boolean</span> typeCheckOnly)</span></span></span><br><span class="line"><span class="function">		<span class="keyword">throws</span> BeansException </span>&#123;</span><br><span class="line">  </span><br><span class="line">       <span class="comment">// 得到标准的Bean名称，确保Bean名称的一致性</span></span><br><span class="line">	String beanName = transformedBeanName(name);</span><br><span class="line">       <span class="comment">// 定义一个变量用于存储最终获取到的Bean实例</span></span><br><span class="line">	Object beanInstance;</span><br><span class="line">  </span><br><span class="line">	<span class="comment">// Eagerly check singleton cache for manually registered singletons.</span></span><br><span class="line">       <span class="comment">// 首次尝试从一级缓存获取Bean，调用getSingleton(beanName, true)，检查一级到三级缓存</span></span><br><span class="line">	Object sharedInstance = getSingleton(beanName);</span><br><span class="line">	<span class="keyword">if</span> (sharedInstance != <span class="keyword">null</span> &amp;&amp; args == <span class="keyword">null</span>) &#123;</span><br><span class="line">		<span class="keyword">if</span> (logger.isTraceEnabled()) &#123;</span><br><span class="line">			<span class="keyword">if</span> (isSingletonCurrentlyInCreation(beanName)) &#123;</span><br><span class="line">				logger.trace(<span class="string">&quot;Returning eagerly cached instance of singleton bean &#x27;&quot;</span> + beanName +</span><br><span class="line">						<span class="string">&quot;&#x27; that is not fully initialized yet - a consequence of a circular reference&quot;</span>);</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="keyword">else</span> &#123;</span><br><span class="line">				logger.trace(<span class="string">&quot;Returning cached instance of singleton bean &#x27;&quot;</span> + beanName + <span class="string">&quot;&#x27;&quot;</span>);</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">           <span class="comment">// 若该Bean已实例化过，则封装并返回从缓存中获取到的单例Bean实例</span></span><br><span class="line">		beanInstance = getObjectForBeanInstance(sharedInstance, name, beanName, <span class="keyword">null</span>);</span><br><span class="line">	&#125;</span><br><span class="line">  </span><br><span class="line">	<span class="keyword">else</span> &#123;</span><br><span class="line">           <span class="comment">// 缓存中不存在对应名称的单例Bean实例，或参数不为空</span></span><br><span class="line">		<span class="comment">// Fail if we&#x27;re already creating this bean instance:</span></span><br><span class="line">		<span class="comment">// We&#x27;re assumably within a circular reference.</span></span><br><span class="line">		<span class="keyword">if</span> (isPrototypeCurrentlyInCreation(beanName)) &#123;</span><br><span class="line">               <span class="comment">// 检查是否正在创建原型Bean的实例，如果是，则抛出BeanCurrentlyInCreationException异常，防止出现循环引用</span></span><br><span class="line">			<span class="keyword">throw</span> <span class="keyword">new</span> BeanCurrentlyInCreationException(beanName);</span><br><span class="line">		&#125;</span><br><span class="line">  </span><br><span class="line">		<span class="comment">// Check if bean definition exists in this factory.</span></span><br><span class="line">		BeanFactory parentBeanFactory = getParentBeanFactory();</span><br><span class="line">		<span class="keyword">if</span> (parentBeanFactory != <span class="keyword">null</span> &amp;&amp; !containsBeanDefinition(beanName)) &#123;</span><br><span class="line">               <span class="comment">// 如果存在父BeanFactory且当前工厂中不包含对应名称的Bean定义，则委托给父BeanFactory进行获取</span></span><br><span class="line">			<span class="comment">// Not found -&gt; check parent.</span></span><br><span class="line">			String nameToLookup = originalBeanName(name);</span><br><span class="line">			<span class="keyword">if</span> (parentBeanFactory <span class="keyword">instanceof</span> AbstractBeanFactory abf) &#123;</span><br><span class="line">                   <span class="comment">// 如果父BeanFactory是AbstractBeanFactory的实例，则调用其doGetBean方法，获取Bean实例</span></span><br><span class="line">				<span class="keyword">return</span> abf.doGetBean(nameToLookup, requiredType, args, typeCheckOnly);</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="keyword">else</span> <span class="keyword">if</span> (args != <span class="keyword">null</span>) &#123;</span><br><span class="line">				<span class="comment">// Delegation to parent with explicit args.</span></span><br><span class="line">				<span class="keyword">return</span> (T) parentBeanFactory.getBean(nameToLookup, args);</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="keyword">else</span> <span class="keyword">if</span> (requiredType != <span class="keyword">null</span>) &#123;</span><br><span class="line">				<span class="comment">// No args -&gt; delegate to standard getBean method.</span></span><br><span class="line">				<span class="keyword">return</span> parentBeanFactory.getBean(nameToLookup, requiredType);</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="keyword">else</span> &#123;</span><br><span class="line">				<span class="keyword">return</span> (T) parentBeanFactory.getBean(nameToLookup);</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">  </span><br><span class="line">		<span class="keyword">if</span> (!typeCheckOnly) &#123;</span><br><span class="line">			markBeanAsCreated(beanName);</span><br><span class="line">		&#125;</span><br><span class="line">  </span><br><span class="line">		StartupStep beanCreation = <span class="keyword">this</span>.applicationStartup.start(<span class="string">&quot;spring.beans.instantiate&quot;</span>)</span><br><span class="line">				.tag(<span class="string">&quot;beanName&quot;</span>, name);</span><br><span class="line">		<span class="keyword">try</span> &#123;</span><br><span class="line">			<span class="keyword">if</span> (requiredType != <span class="keyword">null</span>) &#123;</span><br><span class="line">				beanCreation.tag(<span class="string">&quot;beanType&quot;</span>, requiredType::toString);</span><br><span class="line">			&#125;</span><br><span class="line">               <span class="comment">// 获取合并后的本地Bean定义</span></span><br><span class="line">			RootBeanDefinition mbd = getMergedLocalBeanDefinition(beanName);</span><br><span class="line">               <span class="comment">// 检查合并后的Bean定义，确保其有效性</span></span><br><span class="line">			checkMergedBeanDefinition(mbd, beanName, args);</span><br><span class="line">  </span><br><span class="line">			<span class="comment">// Guarantee initialization of beans that the current bean depends on.</span></span><br><span class="line">               <span class="comment">// 获取Bean定义中声明的依赖关系</span></span><br><span class="line">			String[] dependsOn = mbd.getDependsOn();</span><br><span class="line">			<span class="keyword">if</span> (dependsOn != <span class="keyword">null</span>) &#123;</span><br><span class="line">				<span class="keyword">for</span> (String dep : dependsOn) &#123;</span><br><span class="line">					<span class="keyword">if</span> (isDependent(beanName, dep)) &#123;</span><br><span class="line">						<span class="keyword">throw</span> <span class="keyword">new</span> BeanCreationException(mbd.getResourceDescription(), beanName,</span><br><span class="line">								<span class="string">&quot;Circular depends-on relationship between &#x27;&quot;</span> + beanName + <span class="string">&quot;&#x27; and &#x27;&quot;</span> + dep + <span class="string">&quot;&#x27;&quot;</span>);</span><br><span class="line">					&#125;</span><br><span class="line">					registerDependentBean(dep, beanName);</span><br><span class="line">					<span class="keyword">try</span> &#123;</span><br><span class="line">						getBean(dep);</span><br><span class="line">					&#125;</span><br><span class="line">					<span class="keyword">catch</span> (NoSuchBeanDefinitionException ex) &#123;</span><br><span class="line">						<span class="keyword">throw</span> <span class="keyword">new</span> BeanCreationException(mbd.getResourceDescription(), beanName,</span><br><span class="line">								<span class="string">&quot;&#x27;&quot;</span> + beanName + <span class="string">&quot;&#x27; depends on missing bean &#x27;&quot;</span> + dep + <span class="string">&quot;&#x27;&quot;</span>, ex);</span><br><span class="line">					&#125;</span><br><span class="line">				&#125;</span><br><span class="line">			&#125;</span><br><span class="line">  </span><br><span class="line">			<span class="comment">// Create bean instance.</span></span><br><span class="line">			<span class="keyword">if</span> (mbd.isSingleton()) &#123;</span><br><span class="line">                   <span class="comment">// 如果是单例Bean，则通过getSingleton(beanName, ObjectFactory&lt;?&gt; singletonFactory)方法获取单例Bean实例</span></span><br><span class="line">				sharedInstance = getSingleton(beanName, () -&gt; &#123;</span><br><span class="line">					<span class="keyword">try</span> &#123;</span><br><span class="line">                           <span class="comment">// 其中函数接口为AbstractAutowireCapableBeanFactory.doCreateBean，通过其最终完成Bean的实例化</span></span><br><span class="line">						<span class="keyword">return</span> createBean(beanName, mbd, args);</span><br><span class="line">					&#125;</span><br><span class="line">					<span class="keyword">catch</span> (BeansException ex) &#123;</span><br><span class="line">						<span class="comment">// Explicitly remove instance from singleton cache: It might have been put there</span></span><br><span class="line">						<span class="comment">// eagerly by the creation process, to allow for circular reference resolution.</span></span><br><span class="line">						<span class="comment">// Also remove any beans that received a temporary reference to the bean.</span></span><br><span class="line">						destroySingleton(beanName);</span><br><span class="line">						<span class="keyword">throw</span> ex;</span><br><span class="line">					&#125;</span><br><span class="line">				&#125;);</span><br><span class="line">                   <span class="comment">// 将获取到的单例Bean实例封装并赋值给beanInstance变量</span></span><br><span class="line">				beanInstance = getObjectForBeanInstance(sharedInstance, name, beanName, mbd);</span><br><span class="line">			&#125;</span><br><span class="line">  </span><br><span class="line">			<span class="keyword">else</span> <span class="keyword">if</span> (mbd.isPrototype()) &#123;</span><br><span class="line">				<span class="comment">// It&#x27;s a prototype -&gt; create a new instance.</span></span><br><span class="line">				Object prototypeInstance = <span class="keyword">null</span>;</span><br><span class="line">				<span class="keyword">try</span> &#123;</span><br><span class="line">					beforePrototypeCreation(beanName);</span><br><span class="line">					prototypeInstance = createBean(beanName, mbd, args);</span><br><span class="line">				&#125;</span><br><span class="line">				<span class="keyword">finally</span> &#123;</span><br><span class="line">					afterPrototypeCreation(beanName);</span><br><span class="line">				&#125;</span><br><span class="line">				beanInstance = getObjectForBeanInstance(prototypeInstance, name, beanName, mbd);</span><br><span class="line">			&#125;</span><br><span class="line">  </span><br><span class="line">			<span class="keyword">else</span> &#123;</span><br><span class="line">				String scopeName = mbd.getScope();</span><br><span class="line">				<span class="keyword">if</span> (!StringUtils.hasLength(scopeName)) &#123;</span><br><span class="line">					<span class="keyword">throw</span> <span class="keyword">new</span> IllegalStateException(<span class="string">&quot;No scope name defined for bean &#x27;&quot;</span> + beanName + <span class="string">&quot;&#x27;&quot;</span>);</span><br><span class="line">				&#125;</span><br><span class="line">				Scope scope = <span class="keyword">this</span>.scopes.get(scopeName);</span><br><span class="line">				<span class="keyword">if</span> (scope == <span class="keyword">null</span>) &#123;</span><br><span class="line">					<span class="keyword">throw</span> <span class="keyword">new</span> IllegalStateException(<span class="string">&quot;No Scope registered for scope name &#x27;&quot;</span> + scopeName + <span class="string">&quot;&#x27;&quot;</span>);</span><br><span class="line">				&#125;</span><br><span class="line">				<span class="keyword">try</span> &#123;</span><br><span class="line">					Object scopedInstance = scope.get(beanName, () -&gt; &#123;</span><br><span class="line">						beforePrototypeCreation(beanName);</span><br><span class="line">						<span class="keyword">try</span> &#123;</span><br><span class="line">							<span class="keyword">return</span> createBean(beanName, mbd, args);</span><br><span class="line">						&#125;</span><br><span class="line">						<span class="keyword">finally</span> &#123;</span><br><span class="line">							afterPrototypeCreation(beanName);</span><br><span class="line">						&#125;</span><br><span class="line">					&#125;);</span><br><span class="line">					beanInstance = getObjectForBeanInstance(scopedInstance, name, beanName, mbd);</span><br><span class="line">				&#125;</span><br><span class="line">				<span class="keyword">catch</span> (IllegalStateException ex) &#123;</span><br><span class="line">					<span class="keyword">throw</span> <span class="keyword">new</span> ScopeNotActiveException(beanName, scopeName, ex);</span><br><span class="line">				&#125;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">catch</span> (BeansException ex) &#123;</span><br><span class="line">			beanCreation.tag(<span class="string">&quot;exception&quot;</span>, ex.getClass().toString());</span><br><span class="line">			beanCreation.tag(<span class="string">&quot;message&quot;</span>, String.valueOf(ex.getMessage()));</span><br><span class="line">			cleanupAfterBeanCreationFailure(beanName);</span><br><span class="line">			<span class="keyword">throw</span> ex;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">finally</span> &#123;</span><br><span class="line">			beanCreation.end();</span><br><span class="line">			<span class="keyword">if</span> (!isCacheBeanMetadata()) &#123;</span><br><span class="line">				clearMergedBeanDefinition(beanName);</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">  </span><br><span class="line">	<span class="keyword">return</span> adaptBeanInstance(name, beanInstance, requiredType);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li><p>AbstractAutowireCapableBeanFactory源码分析：</p>
<p>doCreateBean主要完成Bean实例的创建，主要包括：实例化 -&gt; 属性赋值 -&gt; 初始化。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> Object <span class="title">doCreateBean</span><span class="params">(String beanName, RootBeanDefinition mbd, <span class="meta">@Nullable</span> Object[] args)</span></span></span><br><span class="line"><span class="function">		<span class="keyword">throws</span> BeanCreationException </span>&#123;</span><br><span class="line">  </span><br><span class="line">	<span class="comment">// 1.实例化Bean Instantiate the bean.</span></span><br><span class="line">	BeanWrapper instanceWrapper = <span class="keyword">null</span>;</span><br><span class="line">	<span class="keyword">if</span> (mbd.isSingleton()) &#123;</span><br><span class="line">           <span class="comment">// 尝试从单例缓存中获取实例包装器</span></span><br><span class="line">		instanceWrapper = <span class="keyword">this</span>.factoryBeanInstanceCache.remove(beanName);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">if</span> (instanceWrapper == <span class="keyword">null</span>) &#123;</span><br><span class="line">           <span class="comment">// 实例化Bean</span></span><br><span class="line">		instanceWrapper = createBeanInstance(beanName, mbd, args);</span><br><span class="line">	&#125;</span><br><span class="line">	Object bean = instanceWrapper.getWrappedInstance();</span><br><span class="line">	Class&lt;?&gt; beanType = instanceWrapper.getWrappedClass();</span><br><span class="line">	<span class="keyword">if</span> (beanType != NullBean.class) &#123;</span><br><span class="line">		mbd.resolvedTargetType = beanType;</span><br><span class="line">	&#125;</span><br><span class="line">  </span><br><span class="line">	<span class="comment">// Allow post-processors to modify the merged bean definition.</span></span><br><span class="line">	<span class="keyword">synchronized</span> (mbd.postProcessingLock) &#123;</span><br><span class="line">		<span class="keyword">if</span> (!mbd.postProcessed) &#123;</span><br><span class="line">			<span class="keyword">try</span> &#123;</span><br><span class="line">				applyMergedBeanDefinitionPostProcessors(mbd, beanType, beanName);</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="keyword">catch</span> (Throwable ex) &#123;</span><br><span class="line">				<span class="keyword">throw</span> <span class="keyword">new</span> BeanCreationException(mbd.getResourceDescription(), beanName,</span><br><span class="line">						<span class="string">&quot;Post-processing of merged bean definition failed&quot;</span>, ex);</span><br><span class="line">			&#125;</span><br><span class="line">			mbd.markAsPostProcessed();</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">  </span><br><span class="line">	<span class="comment">// Eagerly cache singletons to be able to resolve circular references</span></span><br><span class="line">	<span class="comment">// even when triggered by lifecycle interfaces like BeanFactoryAware.</span></span><br><span class="line">       <span class="comment">// 2.提前暴露单例 Bean，解决循环引用的问题</span></span><br><span class="line">	<span class="keyword">boolean</span> earlySingletonExposure = (mbd.isSingleton() &amp;&amp; <span class="keyword">this</span>.allowCircularReferences &amp;&amp;</span><br><span class="line">			isSingletonCurrentlyInCreation(beanName));</span><br><span class="line">	<span class="keyword">if</span> (earlySingletonExposure) &#123;</span><br><span class="line">		<span class="keyword">if</span> (logger.isTraceEnabled()) &#123;</span><br><span class="line">			logger.trace(<span class="string">&quot;Eagerly caching bean &#x27;&quot;</span> + beanName +</span><br><span class="line">					<span class="string">&quot;&#x27; to allow for resolving potential circular references&quot;</span>);</span><br><span class="line">		&#125;</span><br><span class="line">           <span class="comment">// 若Bean还未创建到一级缓存，则先将lambda传入到三级缓存暂存</span></span><br><span class="line">		addSingletonFactory(beanName, () -&gt; getEarlyBeanReference(beanName, mbd, bean));</span><br><span class="line">	&#125;</span><br><span class="line">  </span><br><span class="line">	<span class="comment">// 3.初始化Bean Initialize the bean instance.</span></span><br><span class="line">	Object exposedObject = bean;</span><br><span class="line">	<span class="keyword">try</span> &#123;</span><br><span class="line">           <span class="comment">// 填充 Bean 属性，调用AbstractBeanFactory.doGetBean查找依赖属性，doGetBean中仍然通过getSingleton查找实例对象</span></span><br><span class="line">		populateBean(beanName, mbd, instanceWrapper);</span><br><span class="line">           <span class="comment">// 初始化 Bean 实例</span></span><br><span class="line">		exposedObject = initializeBean(beanName, exposedObject, mbd);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">catch</span> (Throwable ex) &#123;</span><br><span class="line">		<span class="keyword">if</span> (ex <span class="keyword">instanceof</span> BeanCreationException bce &amp;&amp; beanName.equals(bce.getBeanName())) &#123;</span><br><span class="line">			<span class="keyword">throw</span> bce;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">else</span> &#123;</span><br><span class="line">			<span class="keyword">throw</span> <span class="keyword">new</span> BeanCreationException(mbd.getResourceDescription(), beanName, ex.getMessage(), ex);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">  </span><br><span class="line">       <span class="comment">// 如果启用了提前暴露单例 Bean</span></span><br><span class="line">	<span class="keyword">if</span> (earlySingletonExposure) &#123;</span><br><span class="line">           <span class="comment">// 再次检查一级到二级缓存，此时应该返回一级或二级缓存中的Bean实例</span></span><br><span class="line">		Object earlySingletonReference = getSingleton(beanName, <span class="keyword">false</span>);</span><br><span class="line">		<span class="keyword">if</span> (earlySingletonReference != <span class="keyword">null</span>) &#123;</span><br><span class="line">			<span class="keyword">if</span> (exposedObject == bean) &#123;</span><br><span class="line">				exposedObject = earlySingletonReference;</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="keyword">else</span> <span class="keyword">if</span> (!<span class="keyword">this</span>.allowRawInjectionDespiteWrapping &amp;&amp; hasDependentBean(beanName)) &#123;</span><br><span class="line">				String[] dependentBeans = getDependentBeans(beanName);</span><br><span class="line">				Set&lt;String&gt; actualDependentBeans = <span class="keyword">new</span> LinkedHashSet&lt;&gt;(dependentBeans.length);</span><br><span class="line">				<span class="keyword">for</span> (String dependentBean : dependentBeans) &#123;</span><br><span class="line">					<span class="keyword">if</span> (!removeSingletonIfCreatedForTypeCheckOnly(dependentBean)) &#123;</span><br><span class="line">						actualDependentBeans.add(dependentBean);</span><br><span class="line">					&#125;</span><br><span class="line">				&#125;</span><br><span class="line">				<span class="keyword">if</span> (!actualDependentBeans.isEmpty()) &#123;</span><br><span class="line">					<span class="keyword">throw</span> <span class="keyword">new</span> BeanCurrentlyInCreationException(beanName,</span><br><span class="line">							<span class="string">&quot;Bean with name &#x27;&quot;</span> + beanName + <span class="string">&quot;&#x27; has been injected into other beans [&quot;</span> +</span><br><span class="line">							StringUtils.collectionToCommaDelimitedString(actualDependentBeans) +</span><br><span class="line">							<span class="string">&quot;] in its raw version as part of a circular reference, but has eventually been &quot;</span> +</span><br><span class="line">							<span class="string">&quot;wrapped. This means that said other beans do not use the final version of the &quot;</span> +</span><br><span class="line">							<span class="string">&quot;bean. This is often the result of over-eager type matching - consider using &quot;</span> +</span><br><span class="line">							<span class="string">&quot;&#x27;getBeanNamesForType&#x27; with the &#x27;allowEagerInit&#x27; flag turned off, for example.&quot;</span>);</span><br><span class="line">				&#125;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">  </span><br><span class="line">	<span class="comment">// Register bean as disposable.</span></span><br><span class="line">       <span class="comment">// 注册 Bean为可处理</span></span><br><span class="line">	<span class="keyword">try</span> &#123;</span><br><span class="line">		registerDisposableBeanIfNecessary(beanName, bean, mbd);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">catch</span> (BeanDefinitionValidationException ex) &#123;</span><br><span class="line">		<span class="keyword">throw</span> <span class="keyword">new</span> BeanCreationException(</span><br><span class="line">				mbd.getResourceDescription(), beanName, <span class="string">&quot;Invalid destruction signature&quot;</span>, ex);</span><br><span class="line">	&#125;</span><br><span class="line">  </span><br><span class="line">       <span class="comment">// 返回最终的 Bean 实例</span></span><br><span class="line">	<span class="keyword">return</span> exposedObject;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li><p>DefaultSingletonBeanRegistry源码分析：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br></pre></td><td class="code"><pre><span class="line">  </span><br><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">addSingletonFactory</span><span class="params">(String beanName, ObjectFactory&lt;?&gt; singletonFactory)</span> </span>&#123;</span><br><span class="line">	Assert.notNull(singletonFactory, <span class="string">&quot;Singleton factory must not be null&quot;</span>);</span><br><span class="line">       <span class="comment">// 锁定一级缓存</span></span><br><span class="line">	<span class="keyword">synchronized</span> (<span class="keyword">this</span>.singletonObjects) &#123;</span><br><span class="line">           <span class="comment">// 若一级缓存不存在Bean，则放入三级缓存</span></span><br><span class="line">		<span class="keyword">if</span> (!<span class="keyword">this</span>.singletonObjects.containsKey(beanName)) &#123;</span><br><span class="line">			<span class="keyword">this</span>.singletonFactories.put(beanName, singletonFactory);</span><br><span class="line">			<span class="keyword">this</span>.earlySingletonObjects.remove(beanName);</span><br><span class="line">			<span class="keyword">this</span>.registeredSingletons.add(beanName);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line">  </span><br><span class="line"><span class="function"><span class="keyword">public</span> Object <span class="title">getSingleton</span><span class="params">(String beanName)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">return</span> getSingleton(beanName, <span class="keyword">true</span>);</span><br><span class="line">&#125;</span><br><span class="line">  </span><br><span class="line"><span class="function"><span class="keyword">protected</span> Object <span class="title">getSingleton</span><span class="params">(String beanName, <span class="keyword">boolean</span> allowEarlyReference)</span> </span>&#123;</span><br><span class="line">	<span class="comment">// Quick check for existing instance without full singleton lock</span></span><br><span class="line">	Object singletonObject = <span class="keyword">this</span>.singletonObjects.get(beanName);</span><br><span class="line">       <span class="comment">// 首次检查</span></span><br><span class="line">	<span class="keyword">if</span> (singletonObject == <span class="keyword">null</span> &amp;&amp; isSingletonCurrentlyInCreation(beanName)) &#123;</span><br><span class="line">		singletonObject = <span class="keyword">this</span>.earlySingletonObjects.get(beanName);</span><br><span class="line">		<span class="keyword">if</span> (singletonObject == <span class="keyword">null</span> &amp;&amp; allowEarlyReference) &#123;</span><br><span class="line">               <span class="comment">// 加锁</span></span><br><span class="line">			<span class="keyword">synchronized</span> (<span class="keyword">this</span>.singletonObjects) &#123;</span><br><span class="line">				<span class="comment">// Consistent creation of early reference within full singleton lock</span></span><br><span class="line">				singletonObject = <span class="keyword">this</span>.singletonObjects.get(beanName);</span><br><span class="line">                   <span class="comment">// 二次检查</span></span><br><span class="line">				<span class="keyword">if</span> (singletonObject == <span class="keyword">null</span>) &#123;</span><br><span class="line">					singletonObject = <span class="keyword">this</span>.earlySingletonObjects.get(beanName);</span><br><span class="line">					<span class="keyword">if</span> (singletonObject == <span class="keyword">null</span>) &#123;</span><br><span class="line">                           <span class="comment">// 三级缓存能获取到</span></span><br><span class="line">						ObjectFactory&lt;?&gt; singletonFactory = <span class="keyword">this</span>.singletonFactories.get(beanName);</span><br><span class="line">						<span class="keyword">if</span> (singletonFactory != <span class="keyword">null</span>) &#123;</span><br><span class="line">                               <span class="comment">// 调用代理对象的函数，放入二级缓存，移除三级缓存</span></span><br><span class="line">							singletonObject = singletonFactory.getObject();</span><br><span class="line">							<span class="keyword">this</span>.earlySingletonObjects.put(beanName, singletonObject);</span><br><span class="line">							<span class="keyword">this</span>.singletonFactories.remove(beanName);</span><br><span class="line">						&#125;</span><br><span class="line">					&#125;</span><br><span class="line">				&#125;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> singletonObject;</span><br><span class="line">&#125;</span><br><span class="line">  </span><br><span class="line"><span class="function"><span class="keyword">public</span> Object <span class="title">getSingleton</span><span class="params">(String beanName, ObjectFactory&lt;?&gt; singletonFactory)</span> </span>&#123;</span><br><span class="line">	Assert.notNull(beanName, <span class="string">&quot;Bean name must not be null&quot;</span>);</span><br><span class="line">	<span class="keyword">synchronized</span> (<span class="keyword">this</span>.singletonObjects) &#123;</span><br><span class="line">           <span class="comment">// 从一级缓存获取Bean</span></span><br><span class="line">		Object singletonObject = <span class="keyword">this</span>.singletonObjects.get(beanName);</span><br><span class="line">		<span class="keyword">if</span> (singletonObject == <span class="keyword">null</span>) &#123;</span><br><span class="line">			<span class="keyword">if</span> (<span class="keyword">this</span>.singletonsCurrentlyInDestruction) &#123;</span><br><span class="line">				<span class="keyword">throw</span> <span class="keyword">new</span> BeanCreationNotAllowedException(beanName,</span><br><span class="line">						<span class="string">&quot;Singleton bean creation not allowed while singletons of this factory are in destruction &quot;</span> +</span><br><span class="line">						<span class="string">&quot;(Do not request a bean from a BeanFactory in a destroy method implementation!)&quot;</span>);</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="keyword">if</span> (logger.isDebugEnabled()) &#123;</span><br><span class="line">				logger.debug(<span class="string">&quot;Creating shared instance of singleton bean &#x27;&quot;</span> + beanName + <span class="string">&quot;&#x27;&quot;</span>);</span><br><span class="line">			&#125;</span><br><span class="line">               <span class="comment">// 创建单例Bean前的预处理的操作</span></span><br><span class="line">			beforeSingletonCreation(beanName);</span><br><span class="line">               <span class="comment">// 标记是否创建了新的单例Bean</span></span><br><span class="line">			<span class="keyword">boolean</span> newSingleton = <span class="keyword">false</span>;</span><br><span class="line">               <span class="comment">// 标记是否需要记录抑制的异常</span></span><br><span class="line">			<span class="keyword">boolean</span> recordSuppressedExceptions = (<span class="keyword">this</span>.suppressedExceptions == <span class="keyword">null</span>);</span><br><span class="line">			<span class="keyword">if</span> (recordSuppressedExceptions) &#123;</span><br><span class="line">				<span class="keyword">this</span>.suppressedExceptions = <span class="keyword">new</span> LinkedHashSet&lt;&gt;();</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="keyword">try</span> &#123;</span><br><span class="line">                   <span class="comment">// 通过传入的ObjectFactory实例创建新的单例Bean</span></span><br><span class="line">				singletonObject = singletonFactory.getObject();</span><br><span class="line">				newSingleton = <span class="keyword">true</span>;</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="keyword">catch</span> (IllegalStateException ex) &#123;</span><br><span class="line">				<span class="comment">// Has the singleton object implicitly appeared in the meantime -&gt;</span></span><br><span class="line">				<span class="comment">// if yes, proceed with it since the exception indicates that state.</span></span><br><span class="line">				singletonObject = <span class="keyword">this</span>.singletonObjects.get(beanName);</span><br><span class="line">				<span class="keyword">if</span> (singletonObject == <span class="keyword">null</span>) &#123;</span><br><span class="line">					<span class="keyword">throw</span> ex;</span><br><span class="line">				&#125;</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="keyword">catch</span> (BeanCreationException ex) &#123;</span><br><span class="line">				<span class="keyword">if</span> (recordSuppressedExceptions) &#123;</span><br><span class="line">					<span class="keyword">for</span> (Exception suppressedException : <span class="keyword">this</span>.suppressedExceptions) &#123;</span><br><span class="line">						ex.addRelatedCause(suppressedException);</span><br><span class="line">					&#125;</span><br><span class="line">				&#125;</span><br><span class="line">				<span class="keyword">throw</span> ex;</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="keyword">finally</span> &#123;</span><br><span class="line">				<span class="keyword">if</span> (recordSuppressedExceptions) &#123;</span><br><span class="line">					<span class="keyword">this</span>.suppressedExceptions = <span class="keyword">null</span>;</span><br><span class="line">				&#125;</span><br><span class="line">               	<span class="comment">// 创建单例Bean后的操作</span></span><br><span class="line">				afterSingletonCreation(beanName);</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="keyword">if</span> (newSingleton) &#123;</span><br><span class="line">                   <span class="comment">// 创建单例Bean成功，加入一级缓存</span></span><br><span class="line">				addSingleton(beanName, singletonObject);</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">return</span> singletonObject;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
<h4 id="问：Spring解决不了的循环依赖场景-⭐"><a href="#问：Spring解决不了的循环依赖场景-⭐" class="headerlink" title="问：Spring解决不了的循环依赖场景?⭐"></a>问：Spring解决不了的循环依赖场景?⭐</h4><p>不是所有的循环依赖Spring都能够解决的，三级缓存无法解决的：</p>
<ol>
<li><strong>构造器的循环依赖：</strong>因为构造器的调用发生在对象实例化之前，而三级缓存是在对象实例化过程中使用的。A和B都需要在构造函数中完成初始化，而此时二者都不在三级缓存中。  <ul>
<li><strong>对于构造器注入产生的循环依赖，可以使用 <code>@Lazy</code> 注解，延迟加载。</strong>在构造函数中使用Lazy注解延迟加载。在注入依赖时，先注入代理对象，等到第一次使用时才进行实际的创建。这就意味着即使存在构造器循环依赖，它们的实例化可以被推迟，从而避免了无法解决的循环依赖问题。</li>
<li>改用字段注入或setter方法注入。</li>
<li>代码重构，消除循环依赖场景。</li>
</ul>
</li>
<li><strong>prototype 原型作用域循环依赖：</strong>IoC 容器只会管理单例 Bean 的生命周期，并将单例 Bean 存放到缓存池中（三级缓存）。Spring 并不会管理 <code>prototype</code> 作用域的 Bean，也不会缓存该作用域的 Bean，而 Spring 中循环依赖的解决正是通过缓存来实现的。</li>
<li><strong>多例循环依赖：</strong>多实例 Bean 是每次调用 <code>getBean</code> 都会创建一个新的 Bean 对象，该 Bean 对象并不能缓存。而 Spring 中循环依赖的解决正是通过缓存来实现的。</li>
</ol>
<h4 id="问：为什么一定要三级缓存，可以只用二级缓存吗？⭐⭐"><a href="#问：为什么一定要三级缓存，可以只用二级缓存吗？⭐⭐" class="headerlink" title="问：为什么一定要三级缓存，可以只用二级缓存吗？⭐⭐"></a>问：为什么一定要三级缓存，可以只用二级缓存吗？⭐⭐</h4><p>只有三级缓存能满足<strong>构造方法实例化-&gt;依赖注入-&gt;动态代理</strong>这个完整流程。</p>
<ul>
<li>只有一级缓存：只存储初始化完成对象</li>
<li>只有二级缓存：一级存储初始化完成对象，二级存储早期曝光的半成品对象。无法支持动态代理<ul>
<li>假设对象A需要动态代理，A的代理对象在二级缓存时还未生成。</li>
<li>所以从二级缓存获取的A对象，与实际A经过AOP生成的对象不是同一个。</li>
</ul>
</li>
<li>三级缓存：存放的是ObjectFactory函数式接口，其getObject方法只有需要A时才会调用，直接创建代理对象A。<ul>
<li>实例化A，未填充属性，放入三级缓存，发现依赖B</li>
<li>实例化B，未填充属性，放入三级缓存，发现依赖A</li>
<li>从三级取到A，ObjectFactory#getObject()返回代理A，并放入二级缓存。</li>
<li>B填充属性，完成初始化，放入一级缓存。</li>
<li>A从一级找到B，填充属性，完成初始化，放入一级缓存。</li>
</ul>
</li>
<li><strong>是否可以把AOP调用提前到实例化来解决重复创建问题，并且不用三级缓存？</strong><ul>
<li>Spring是在初始化后，而不是实例化后直接调用AOP生成代理对象，实例化后仅仅保存一下lambda表达式，因为<strong>不希望破坏正常Bean的生命周期</strong>。三级缓存存放一个函数接口，出现循环依赖时判断对象是否需要进行AOP。</li>
<li>若提前创建AOP代理对象，此时依赖注入还未完成，代理对象会依赖于不完整的Bean。</li>
<li>Spring的AOP是在Bean初始化后进行的，通过AnnotationAwareAspectJAutoProxyCreator后置处理器完成。若Bean需要进行AOP，最终会得到一个代理对象。</li>
</ul>
</li>
</ul>
<p>可以不用二级缓存吗？  不可以，如果没有二级缓存，<strong>多重循环依赖时无法保证得到单例的对象</strong>。</p>
<ul>
<li>假设没有二级缓存，当对象B获取到对象A的三级缓存并创建成功，此时若又有依赖A的对象C创建，不管三级缓存能不能获取到A，最终得到的对象都可能不是同一个代理对象。</li>
<li>二级缓存无法解决<strong>避免多重循环依赖时，重复创建动态代理</strong>的问题：假如A被多个对象依赖，此时A还在实例化，其它对象每次getBean(A)时，都会创建一次动态代理，而通过二级缓存感知即可避免。</li>
</ul>
<h4 id="问：-Async为什么会导致循环依赖解决不了"><a href="#问：-Async为什么会导致循环依赖解决不了" class="headerlink" title="问：@Async为什么会导致循环依赖解决不了"></a>问：@Async为什么会导致循环依赖解决不了</h4><p><code>@Async</code> 注解用于声明一个方法是异步的，当这个方法被调用时，会在另一个线程中执行，而调用方不会等待它的完成。在 Spring 中，<code>@Async</code> 注解通常与 <code>@EnableAsync</code> 注解一起使用，以启用异步方法的支持。</p>
<p>循环依赖问题通常发生在 Spring 容器在创建 Bean 的过程中。循环依赖是指两个或多个 Bean 之间相互引用，形成一个闭环，而这种循环依赖的解决通常需要通过 Spring 容器在创建 Bean 的过程中暂时提供一个未完全初始化的 Bean。然而，异步方法的实现往往涉及到动态代理和 AOP，这使得容器可能无法正确地暂时提供未完全初始化的 Bean。</p>
<p>这是因为异步方法的代理对象在容器中的创建与原始 Bean 的创建过程有一定的耦合。</p>
<p>为了解决这个问题，可以考虑以下几种方式：</p>
<ol>
<li>尽量避免在存在循环依赖的 Bean 上使用 <code>@Async</code> 注解。</li>
<li>考虑使用其他方式实现异步操作，如使用 <code>TaskExecutor</code> 接口。</li>
<li>通过调整 Bean 的初始化顺序来规避循环依赖。</li>
</ol>
<p>总的来说，循环依赖和异步方法在某些情况下可能会产生冲突，需要谨慎设计和使用以避免出现问题。</p>
<h4 id="问：-Lazy注解如何解决循环依赖问题？"><a href="#问：-Lazy注解如何解决循环依赖问题？" class="headerlink" title="问：@Lazy注解如何解决循环依赖问题？"></a>问：@Lazy注解如何解决循环依赖问题？</h4><p>@Lazy注解：</p>
<ol>
<li>延迟创建：懒加载的Bean只有首次使用时才会被创建，和@Component、@Bean、@Configuration等配合。</li>
<li>延迟注入：@Lazy注解与@Autowired搭配、应用于构造方法、应用在构造方法的属性时，Spring会先给属性注入一个代理对象，当首次访问时才会执行代理对象的逻辑，注入一个真正的Bean。</li>
</ol>
<p>当对象A和B循环依赖时，A构造方法使用@Lazy，A完成实例化后，会给构造方法的参数B先注入一个代理对象，此时A可以完成后续对象创建步骤。</p>
<h3 id="1-5-Spring-AOP"><a href="#1-5-Spring-AOP" class="headerlink" title="1.5 Spring AOP"></a>1.5 Spring AOP</h3><h4 id="问：什么是AOP？面向切面的基本概念？"><a href="#问：什么是AOP？面向切面的基本概念？" class="headerlink" title="问：什么是AOP？面向切面的基本概念？"></a>问：什么是AOP？面向切面的基本概念？</h4><p>AOP（Aspect-Oriented Programming），面向切面编程，是一种软件开发的编程范式。AOP 的目标是通过将<strong>横切关注点</strong>（cross-cutting concerns）从主要业务逻辑中分离出来，以提高代码的模块化、可维护性和可重用性。在传统的面向对象编程（OOP）中，程序的功能被划分为各个类，而某些功能可能会分散在多个类中。例如，日志记录、事务管理、权限控制等功能可能会在多个类的方法中散布。AOP 的思想是将这些横切关注点独立出来，形成单独的切面（Aspect），然后通过横切（weaving）的方式将切面插入到程序的执行流程中。</p>
<p>AOP 的关键概念包括：</p>
<ol>
<li><strong>切面（Aspect）：</strong>切面是一个横切关注点的模块。它包含了一系列的通知（advice），定义了在哪些地方、何时执行这些通知。<strong>使用@Aspect注解标注的类</strong>。</li>
<li><strong>连接点（Join Point）：****目标方法执行的时机</strong>。通常连接点是程序中的方法调用，<strong>比如一个方法的执行</strong>，一个异常的处理，但也可以是字段的访问或其他某些事件。</li>
<li><strong>切入点（Pointcut）：</strong>切入点是一组连接点的集合。它定义了切面在哪里生效。<strong>通过 <code>@Pointcut(&quot;execution(* com.Service.*.*(..))&quot;)</code> 匹配目标方法的规则</strong>。</li>
<li><strong>通知（Advice）：</strong>通知定义了在程序的哪个时刻，以及在执行的哪个点上执行切面的代码。通知的类型包括：同时是注解名如@Before，@After，@AfterReturning，@AfterThrowing，@Around<ul>
<li>前置通知（before advice）：方法之前执行</li>
<li>后置通知（after advice）：方法return后执行，无论成功还是异常</li>
<li>异常通知（after-throwing advice）：方法抛异常后执行</li>
<li>返回通知（after-returning advice）：成功返回通知</li>
<li>最终通知（after-finally advice）：方法执行完finally后执行，比return更后执行</li>
<li>环绕通知（around advice）：方法执行的前后，可以自定义执行顺序，控制方法执行。</li>
</ul>
</li>
<li><strong>横切（Weaving）：</strong>横切是将切面的代码插入到程序的执行流程中的过程。横切可以在编译时、类加载时或运行时发生。</li>
</ol>
<p>AOP 的主要优势在于解耦关注点，提高代码的可维护性。通过 AOP，可以将横切关注点的代码从主要业务逻辑中分离出来，使得代码更加清晰、可读，并且易于维护。 Spring 框架是一个广泛使用 AOP 的典型例子，它提供了强大的 AOP 支持。</p>
<p>在这个示例中：</p>
<ul>
<li><code>@Aspect</code> 注解标识这是一个切面。</li>
<li><code>@Pointcut</code> 注解定义了切入点，匹配所有以 “Service” 结尾的类的所有方法。</li>
<li>不同类型的通知通过 <code>@Before</code>、<code>@After</code>、<code>@AfterReturning</code>、<code>@AfterThrowing</code> 和 <code>@Around</code> 注解定义。</li>
<li><code>JoinPoint</code> 用于获取连接点的信息，例如方法签名等。</li>
<li><code>@Around</code> 注解的方法中，通过 <code>ProceedingJoinPoint</code> 执行目标方法，并在前后进行处理。</li>
</ul>
<p>请注意，以上示例使用了Spring AOP和AspectJ的注解。这是基于Spring框架的AOP实现。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> org.aspectj.lang.JoinPoint;</span><br><span class="line"><span class="keyword">import</span> org.aspectj.lang.ProceedingJoinPoint;</span><br><span class="line"><span class="keyword">import</span> org.aspectj.lang.annotation.*;</span><br><span class="line"><span class="keyword">import</span> org.springframework.stereotype.Component;</span><br><span class="line"><span class="comment">// 定义切面</span></span><br><span class="line"><span class="meta">@Aspect</span></span><br><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyAspect</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 定义切入点，匹配所有以Service结尾的类的所有方法</span></span><br><span class="line">    <span class="meta">@Pointcut(&quot;execution(* *.*Service.*(..))&quot;)</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">serviceMethods</span><span class="params">()</span> </span>&#123;&#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 前置通知</span></span><br><span class="line">    <span class="meta">@Before(&quot;serviceMethods()&quot;)</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">beforeAdvice</span><span class="params">(JoinPoint joinPoint)</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;Before advice: Executing before &quot;</span> + joinPoint.getSignature().getName());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 后置通知</span></span><br><span class="line">    <span class="meta">@After(&quot;serviceMethods()&quot;)</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">afterAdvice</span><span class="params">(JoinPoint joinPoint)</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;After advice: Executing after &quot;</span> + joinPoint.getSignature().getName());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 后置返回通知</span></span><br><span class="line">    <span class="meta">@AfterReturning(pointcut = &quot;serviceMethods()&quot;, returning = &quot;result&quot;)</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">afterReturningAdvice</span><span class="params">(JoinPoint joinPoint, Object result)</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;After returning advice: Executing after returning from &quot;</span> + joinPoint.getSignature().getName() +</span><br><span class="line">                <span class="string">&quot;. Result: &quot;</span> + result);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 异常通知</span></span><br><span class="line">    <span class="meta">@AfterThrowing(pointcut = &quot;serviceMethods()&quot;, throwing = &quot;exception&quot;)</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">afterThrowingAdvice</span><span class="params">(JoinPoint joinPoint, Exception exception)</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;After throwing advice: Executing after throwing exception from &quot;</span> +</span><br><span class="line">                joinPoint.getSignature().getName() + <span class="string">&quot;. Exception: &quot;</span> + exception.getMessage());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 环绕通知</span></span><br><span class="line">    <span class="meta">@Around(&quot;serviceMethods()&quot;)</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Object <span class="title">aroundAdvice</span><span class="params">(ProceedingJoinPoint joinPoint)</span> <span class="keyword">throws</span> Throwable </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;Around advice: Executing around &quot;</span> + joinPoint.getSignature().getName());</span><br><span class="line">        Object result = joinPoint.proceed();</span><br><span class="line">        System.out.println(<span class="string">&quot;Around advice: Executing after &quot;</span> + joinPoint.getSignature().getName() +</span><br><span class="line">                <span class="string">&quot;. Result: &quot;</span> + result);</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h4 id="问：AOP-主要应用场景？AOP在什么场景下会失效？"><a href="#问：AOP-主要应用场景？AOP在什么场景下会失效？" class="headerlink" title="问：AOP 主要应用场景？AOP在什么场景下会失效？"></a>问：AOP 主要应用场景？AOP在什么场景下会失效？</h4><ol>
<li><strong>日志记录：</strong>AOP 可以用于在方法执行前、后或抛出异常时记录日志，避免在每个方法中都编写相似的日志记录代码。</li>
<li><strong>事务管理：</strong>AOP 可以用于将事务的开启、提交、回滚等操作织入到方法的执行过程中，使得事务管理更加方便。</li>
<li><strong>权限控制：</strong>AOP 可以用于实现权限控制，例如在方法执行前判断用户是否有权限执行该方法。</li>
<li><strong>性能监控：</strong>AOP 可以用于在方法执行前后统计方法的执行时间，帮助进行性能监控和优化。</li>
<li><strong>异常处理：</strong>AOP 可以用于处理方法执行过程中抛出的异常，进行统一的异常处理或记录异常信息。</li>
<li><strong>缓存管理：</strong>AOP 可以用于在方法执行前检查缓存，如果缓存中存在相应的结果，则直接返回缓存中的数据，避免重复计算。</li>
<li><strong>国际化：</strong>AOP 可以用于在方法执行前根据用户的语言偏好设置，实现国际化的功能。</li>
<li><strong>事件驱动：</strong>AOP 可以用于实现事件驱动的编程模型，例如在某个方法执行后触发某个事件。</li>
<li><strong>跟踪调试：</strong>AOP 可以用于在方法执行前后插入跟踪代码，帮助进行调试和排查问题。</li>
</ol>
<p>AOP 的主要优势在于解耦关注点，使得系统的各个模块更加独立，易于维护和扩展。通过将横切关注点（cross-cutting concerns）从主要业务逻辑中分离出来，提高了代码的可维护性和可重用性。 AOP 在实际应用中通常与其他设计模式和框架结合使用，以更好地满足系统的需求。</p>
<p>失效场景？</p>
<ul>
<li>当前类没有被Spring容器所管理：AOP是在Bean创建初始化后进行的，若类没有被容器管理就无法进行AOP。</li>
<li>同一个类中方法的调用：直接this.XXX()，而不是XXX.XXX();</li>
<li>内部类方法的调用：直接调用内部类实例对象的方法，而不是代理对象。</li>
<li>私有方法：代理对象无法调用私有方法。</li>
<li>static修饰的方法：属于类对象，而不是对象实例，无法被代理对象调用。</li>
<li>final修饰的方法：无法被重写，无法被代理对象调用。</li>
</ul>
<h4 id="问：讲一下Spring-AOP-的原理？AOP使用哪种动态代理？JDK动态代理与CGlib的区别？⭐⭐⭐"><a href="#问：讲一下Spring-AOP-的原理？AOP使用哪种动态代理？JDK动态代理与CGlib的区别？⭐⭐⭐" class="headerlink" title="问：讲一下Spring AOP 的原理？AOP使用哪种动态代理？JDK动态代理与CGlib的区别？⭐⭐⭐"></a>问：讲一下Spring AOP 的原理？AOP使用哪种动态代理？JDK动态代理与CGlib的区别？⭐⭐⭐</h4><p>Spring Bean创建过程中有许多扩展点，AOP本身就是扩展功能，在BeanPostProcessor阶段实现。Spring AOP（Aspect-Oriented Programming）的原理基于<strong>动态代理</strong>。在运行时生成代理对象，增强方法的功能，而不影响原始方法。主要使用两种方式实现 AOP 的动态代理：<strong>JDK 动态代理</strong>和 <strong>CGLIB（Code Generation Library）动态代理</strong>。在ProxyFactory类中进行了封装。</p>
<p>AOP流程：</p>
<ol>
<li><p><strong>生成代理对象</strong>，代理对象的创建过程：</p>
<ol>
<li><strong>识别切面（Aspect）</strong>：<ul>
<li>Spring在容器启动时，通过类路径扫描，查找标注了 <code>@Aspect</code> 注解的类，并将它们注册为切面。</li>
<li>切面是由切点（Pointcut）和通知（Advice）组成的，它定义了增强的逻辑。</li>
</ul>
</li>
<li><strong>解析切点（Pointcut）</strong>：<ul>
<li>切点用于指定哪些方法需要被代理，<code>@Pointcut(&quot;execution(* com.example.service.*.*(..))&quot;)</code> 表示匹配指定包下的所有方法。</li>
<li>Spring AOP使用<strong>表达式</strong>来定义切点，通常是基于方法签名、类路径等来选择目标方法。</li>
</ul>
</li>
<li><strong>创建通知（Advice）</strong>：<ul>
<li>通知是增强的逻辑，Spring支持多种类型的通知，比如：<ul>
<li><code>@Before</code>：在方法执行之前执行</li>
<li><code>@After</code>：方法执行后执行（无论方法是否抛出异常）</li>
<li><code>@AfterReturning</code>：方法正常执行后执行</li>
<li><code>@AfterThrowing</code>：方法抛出异常时执行</li>
<li><code>@Around</code>：环绕通知，既可以在方法执行前后增加逻辑</li>
</ul>
</li>
<li>通知是与切点结合的，只有切点匹配的方法才会执行对应的通知。</li>
</ul>
</li>
<li><strong>选择代理方式</strong>：根据目标类是否实现接口来选择JDK动态代理或CGLIB动态代理</li>
<li><strong>返回代理对象</strong>：Spring最终返回生成的代理对象，在调用该代理对象时，Spring会根据配置的切点和通知执行增强逻辑。</li>
</ol>
</li>
<li><p><strong>执行方法调用时，调用代理对象的 <code>intercept()</code> 方法</strong>：</p>
<ul>
<li>当调用代理对象的方法时，Spring会通过 <code>DynamicAdvisedInterceptor</code> 拦截方法调用。</li>
<li>代理对象的方法会被 <code>DynamicAdvisedInterceptor</code> 代理，这个类是代理机制的核心，负责方法的执行和增强。</li>
<li>在 <code>intercept()</code> 方法中，Spring会执行拦截器链，按照定义的顺序依次调用每个通知（如 <code>@Before</code>、<code>@After</code> 等）。</li>
</ul>
</li>
<li><p><strong>根据定义好的通知生成拦截器链</strong>：</p>
<ul>
<li>Spring AOP会根据切点和通知生成拦截器链。每个通知都会被包装成一个 <code>MethodInterceptor</code>，并按顺序加入到拦截器链中。</li>
<li>如果是环绕通知（<code>@Around</code>），则通过 <code>ProceedingJoinPoint</code> 可以控制是否继续执行目标方法。</li>
<li>其他通知（<code>@Before</code>, <code>@After</code>）会在目标方法执行之前或之后执行。</li>
</ul>
</li>
<li><p><strong>从拦截器链中依次获取每个通知</strong>：</p>
<ul>
<li>在代理对象方法执行时，Spring会逐个执行拦截器链中的每个通知（如：前置通知、后置通知等）。</li>
<li>对于环绕通知（<code>@Around</code>），通知方法可以决定是否继续执行目标方法，或者在目标方法执行前后增加额外的逻辑。</li>
<li>CGLIB生成的代理类会创建一个 <code>CGLibMethodInvocation</code> 对象，通过它实现方法的顺序执行，目标方法的返回结果和异常都会被捕获并传递给后续的通知。</li>
</ul>
</li>
</ol>
<p>源码：</p>
<ul>
<li><p>AbstractAutowireCapableBeanFactory中initializeBean方法初始化Bean：</p>
<ul>
<li><code>initializeBean</code> 会依次调用 BeanPostProcessor 进行后处理，比如 <code>applyBeanPostProcessorsAfterInitialization()</code>。</li>
</ul>
</li>
<li><p>随后调用applyBeanPostProcessorsAfterInitialization()遍历所有BeanPostProcessor：</p>
<ul>
<li>遍历所有注册的 <code>BeanPostProcessor</code>，并调用它们的 <code>postProcessAfterInitialization()</code> 方法。</li>
<li>如果 <code>BeanPostProcessor</code> 是 <code>InstantiationAwareBeanPostProcessor</code> 类型，Spring会在此时检查是否需要对该 Bean 进行增强（例如：AOP）。</li>
</ul>
</li>
<li><p><strong><code>wrapIfNecessary()</code> 方法</strong>：</p>
<ul>
<li>该方法会判断当前 Bean 是否需要进行 AOP 增强。如果是，Spring会通过 <code>AopProxyFactory</code> 创建代理对象。</li>
<li><strong><code>wrapIfNecessary()</code></strong> 会返回一个增强后的代理对象。</li>
</ul>
</li>
<li><p>若需要则调用<strong>createProxy</strong>方法生成代理对象并返回。</p>
<p>**<code>createProxy()</code>**：</p>
<ul>
<li><code>createProxy</code> 是 Spring AOP 代理对象生成的核心方法。根据目标对象的类型（是否有接口），它会选择 JDK 动态代理或 CGLIB 代理。</li>
<li>对于 JDK 动态代理，Spring会使用 <code>Proxy.newProxyInstance()</code> 创建代理对象。</li>
<li>对于 CGLIB，Spring通过 <code>Enhancer.create()</code> 来创建代理对象。</li>
</ul>
</li>
</ul>
<p><strong>JDK动态代理与CGlib的区别？</strong></p>
<ul>
<li><p><strong>JDK 动态代理</strong>：JDK 动态代理是<strong>基于 Java 的 <code>java.lang.reflect</code> 包提供的 <code>Proxy</code> 类和 <code>InvocationHandler</code> 接口实现的</strong>。代理类来自JDK类库，实现接口。通过反射来调用目标类。</p>
<p>包括：</p>
<ul>
<li><strong>定义一个接口（或者使用已有的接口）作为代理对象的接口。</strong></li>
<li><strong>实现 <code>InvocationHandler</code> 接口，编写代理逻辑。</strong></li>
<li><strong>使用 <code>Proxy.newProxyInstance()</code> 创建代理对象</strong>。</li>
</ul>
<p>示例：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 定义一个接口（或者使用已有的接口）作为代理对象的接口</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">UserService</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">addUser</span><span class="params">(String name)</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">UserServiceImpl</span> <span class="keyword">implements</span> <span class="title">UserService</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">addUser</span><span class="params">(String name)</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;User added: &quot;</span> + name);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 实现 `InvocationHandler` 接口，编写代理逻辑</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyInvocationHandler</span> <span class="keyword">implements</span> <span class="title">InvocationHandler</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> Object target;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">MyInvocationHandler</span><span class="params">(Object target)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.target = target;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Object <span class="title">invoke</span><span class="params">(Object proxy, Method method, Object[] args)</span> <span class="keyword">throws</span> Throwable </span>&#123;</span><br><span class="line">        <span class="comment">// 方法执行前，需要XXX</span></span><br><span class="line">        System.out.println(<span class="string">&quot;Before method execution&quot;</span>);</span><br><span class="line">        <span class="comment">// 执行方法</span></span><br><span class="line">        Object result = method.invoke(target, args);</span><br><span class="line">        <span class="comment">// 方法执行后，需要XXX</span></span><br><span class="line">        System.out.println(<span class="string">&quot;After method execution&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">JDKProxyExample</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 创建代理对象</span></span><br><span class="line">	UserService userService = <span class="keyword">new</span> UserServiceImpl();</span><br><span class="line">    </span><br><span class="line">	<span class="comment">// 使用 `Proxy.newProxyInstance()` 创建代理对象</span></span><br><span class="line">	UserService proxy = (UserService) Proxy.newProxyInstance(</span><br><span class="line">    	userService.getClass().getClassLoader(),</span><br><span class="line">    	userService.getClass().getInterfaces(),</span><br><span class="line">    	<span class="keyword">new</span> MyInvocationHandler(userService));</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 使用代理对象</span></span><br><span class="line">	proxy.addUser(<span class="string">&quot;Alice&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line">输出</span><br><span class="line">Before method execution</span><br><span class="line">User added: Alice</span><br><span class="line">After method execution</span><br></pre></td></tr></table></figure></li>
<li><p><strong>CGLIB 动态代理</strong>：CGLIB 是一个代码生成库，通过在运行时生成目标类的子类来实现动态代理。依赖第三方<strong>ASM框架</strong>生成代理类。通过 <code>Enhancer.create()</code> 生成代理对象。代理类直接<strong>继承</strong>目标类，通过子类代理目标类。</p>
<p>包括：</p>
<ul>
<li>CGLIB 利用字节码生成库，为目标类创建一个子类，并覆盖其中的方法。</li>
<li>在子类中，可以在目标方法的前后插入增强逻辑。</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyService</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">doSomething</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;Doing something...&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 实现MethodInterceptor接口来定义代理逻辑</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyMethodInterceptor</span> <span class="keyword">implements</span> <span class="title">MethodInterceptor</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Object <span class="title">intercept</span><span class="params">(Object obj, Method method, Object[] args, MethodProxy proxy)</span> <span class="keyword">throws</span> Throwable </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;Before method execution&quot;</span>);</span><br><span class="line">        Object result = proxy.invokeSuper(obj, args);</span><br><span class="line">        System.out.println(<span class="string">&quot;After method execution&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 创建代理对象</span></span><br><span class="line">Enhancer enhancer = <span class="keyword">new</span> Enhancer();</span><br><span class="line">enhancer.setSuperclass(MyService.class);</span><br><span class="line">enhancer.setCallback(<span class="keyword">new</span> MyMethodInterceptor());</span><br><span class="line">MyService proxy = (MyService) enhancer.create();</span><br><span class="line"></span><br><span class="line"><span class="comment">// 使用代理对象</span></span><br><span class="line">proxy.doSomething();</span><br></pre></td></tr></table></figure></li>
</ul>
<p>Spring AOP 中的选择：</p>
<ul>
<li>如果目标类实现了接口或者是Proxy的子类，Spring AOP 将使用 JDK 动态代理。</li>
<li>如果目标类没有实现接口，Spring AOP 将使用 CGLIB 动态代理。</li>
</ul>
<p>JDK动态代理和 CGLib区别：</p>
<ol>
<li><strong>代理方式：</strong><ul>
<li><strong>动态代理：</strong> 动态代理是基于接口的代理，要求目标类必须实现至少一个接口。</li>
<li><strong>CGLib：</strong> CGLib 是基于继承的代理，它通过生成目标类的子类来实现代理。不要求目标类必须实现接口。</li>
</ul>
</li>
<li><strong>生成代理类的方式：</strong><ul>
<li><strong>动态代理：</strong> 动态代理在运行时通过<strong>反射机制</strong>动态生成代理类。</li>
<li><strong>CGLib：</strong> CGLib 利用<strong>字节码</strong>生成技术，在运行时生成目标类的子类，该子类作为代理类。</li>
</ul>
</li>
<li><strong>性能：</strong><ul>
<li><strong>JDK：</strong> <ul>
<li>早期版本，因为反射，性能差于CGLIB。</li>
<li>JDK采用LambdaMetafactory直接生成字节码，性能提高。</li>
</ul>
</li>
<li><strong>CGLib：</strong> <ul>
<li>CGLib 的性能相对较高，因为它直接操作字节码，无需通过反射调用。</li>
</ul>
</li>
</ul>
</li>
</ol>
<h4 id="问：代理对象调用过程（责任链-递归调用）？"><a href="#问：代理对象调用过程（责任链-递归调用）？" class="headerlink" title="问：代理对象调用过程（责任链+递归调用）？"></a>问：代理对象调用过程（责任链+递归调用）？</h4><p><strong>责任链（Chain of Responsibility）</strong>是一种行为设计模式，其主要目的是将请求的发送者和接收者解耦，使多个对象都有机会处理请求。请求在一条链上依次经过多个处理者，每个处理者判断是否处理该请求，如果能够处理，则直接处理；否则，将请求传递给链上的下一个处理者。</p>
<p>责任链模式的核心思想是建立一个对象链，请求在链上传递，直到有一个对象处理它为止。这样做的好处是可以动态地改变链中的对象或顺序，而无需修改发送者和接收者的代码。</p>
<p>在责任链模式中，通常有以下角色：</p>
<ol>
<li><p><strong>Handler（处理者）：</strong> 定义一个处理请求的接口，并保持一个对下一个处理者的引用。如果自己能够处理请求，则直接处理；否则，将请求传递给下一个处理者。</p>
</li>
<li><p><strong>ConcreteHandler（具体处理者）：</strong> 实现Handler接口，具体处理请求的对象。</p>
</li>
<li><p><strong>Client（客户端）：</strong> 创建请求并将其发送到链上的第一个处理者。</p>
</li>
</ol>
<p>责任链模式常用于以下场景：</p>
<ul>
<li>有多个对象可以处理同一请求，但具体处理者在运行时确定。</li>
<li>在不明确指定接收者的情况下，向多个对象中的一个发送请求。</li>
<li>可动态指定处理链，增强系统的灵活性。</li>
</ul>
<p>在AOP（面向切面编程）中，责任链模式的概念被广泛应用。AOP中的切面（Aspect）就可以看作是责任链中的处理者，切入点（Pointcut）则是责任链的判断条件。 </p>
<p>在AOP的代理对象调用过程中，责任链和递归调用更多地体现在AOP的通知（Advice）执行的过程中。在AOP中，通知的执行顺序可以看作是责任链，而通知的调用过程可能涉及到递归调用。</p>
<ol>
<li><p><strong>责任链：</strong> AOP的通知执行顺序是由切面中的各个通知的顺序决定的。通常情况下，通知的执行顺序包括前置通知（Before）、后置通知（After）、返回通知（AfterReturning）、异常通知（AfterThrowing）、最终通知（After）。这些通知形成一个责任链，按照定义的顺序依次执行。</p>
</li>
<li><p><strong>递归调用：</strong> 在AOP中，特别是在环绕通知（Around）中，通知可以调用 <code>proceed()</code> 方法来继续执行下一个通知或目标方法。这种递归调用的方式允许在通知链中的某个点继续执行下一个通知。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Aspect</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyAspect</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Around(&quot;execution(* com.example.MyService.*(..))&quot;)</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Object <span class="title">aroundAdvice</span><span class="params">(ProceedingJoinPoint joinPoint)</span> <span class="keyword">throws</span> Throwable </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;Before method execution...&quot;</span>);</span><br><span class="line">        Object result = joinPoint.proceed(); <span class="comment">// 递归调用，继续执行下一个通知或目标方法</span></span><br><span class="line">        System.out.println(<span class="string">&quot;After method execution...&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ol>
<h4 id="问：AOP如何实现？源码分析？TODO"><a href="#问：AOP如何实现？源码分析？TODO" class="headerlink" title="问：AOP如何实现？源码分析？TODO"></a>问：AOP如何实现？源码分析？TODO</h4><ul>
<li>@EnableAspectJAutoProxy给容器（beanFactory）中注册一个AnnotationAwareAspectJAutoProxyCreator对象；</li>
<li>AnnotationAwareAspectJAutoProxyCreator对目标对象进行代理对象的创建，对象内部，是封装JDK和CGlib两个技术，实现动态代理对象创建的（创建代理对象过程中，会先创建一个代理工厂，获取到所有的增强器（通知方法），将这些增强器和目标类注入代理工厂，再用代理工厂创建对象）；</li>
<li>代理对象执行目标方法，得到目标方法的拦截器链，利用拦截器的链式机制，依次进入每一个拦截器进行执行</li>
</ul>
<h3 id="1-6-Spring-事务"><a href="#1-6-Spring-事务" class="headerlink" title="1.6 Spring 事务"></a>1.6 Spring 事务</h3><h4 id="问：讲一下Spring事务管理机制及执行流程？⭐⭐⭐"><a href="#问：讲一下Spring事务管理机制及执行流程？⭐⭐⭐" class="headerlink" title="问：讲一下Spring事务管理机制及执行流程？⭐⭐⭐"></a>问：讲一下Spring事务管理机制及执行流程？⭐⭐⭐</h4><p>Spring提供了编程式和声明式两种事务管理机制。</p>
<ul>
<li>编程式事务：调用Spring提供的相关API来手动操作和管理事务。<ul>
<li>通过<strong>TransactionTemplate</strong>或<strong>PlatformTransactionManager</strong>两种方式来实现。</li>
<li>优点：可以自定义、更加详细的管理事务。</li>
<li>缺点：对业务代码有一定侵入性，复杂度高。</li>
</ul>
</li>
<li>声明式事务：使用注解**@Transactional<strong>或</strong>XML配置**的方式来管理事务。<ul>
<li>最常用注解的方式，因为简单易用。</li>
<li>底层<strong>基于AOP实现</strong>，在目标方法被调用之前，代理对象会创建或加入一个事务，在目标方法执行完毕后，代理对象提交事务，若执行出现异常，代理对象回滚事务。</li>
<li>优点：对业务代码侵入性低，可维护性高。</li>
<li>缺点：只能做到方法级别的最小颗粒度。</li>
<li><strong>事务会影响数据库的QPS</strong>，并且使用时要考虑到各个场景的回滚方案，如缓存回滚、搜索引擎回滚、消息补偿、统计修正等。</li>
</ul>
</li>
</ul>
<p>代码示例：</p>
<ol>
<li><p><strong>编程式事务（使用TransactionTemplate）：</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> org.springframework.beans.factory.annotation.Autowired;</span><br><span class="line"><span class="keyword">import</span> org.springframework.jdbc.core.JdbcTemplate;</span><br><span class="line"><span class="keyword">import</span> org.springframework.stereotype.Service;</span><br><span class="line"><span class="keyword">import</span> org.springframework.transaction.TransactionStatus;</span><br><span class="line"><span class="keyword">import</span> org.springframework.transaction.support.TransactionCallbackWithoutResult;</span><br><span class="line"><span class="keyword">import</span> org.springframework.transaction.support.TransactionTemplate;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Service</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ProgrammaticTransactionService</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> JdbcTemplate jdbcTemplate;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> TransactionTemplate transactionTemplate;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">performTransaction</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        transactionTemplate.execute(<span class="keyword">new</span> TransactionCallbackWithoutResult() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">doInTransactionWithoutResult</span><span class="params">(TransactionStatus status)</span> </span>&#123;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    <span class="comment">// 执行业务逻辑，可能包含多个数据库操作</span></span><br><span class="line">                    jdbcTemplate.update(<span class="string">&quot;INSERT INTO users (username, password) VALUES (?, ?)&quot;</span>, <span class="string">&quot;user1&quot;</span>, <span class="string">&quot;pass1&quot;</span>);</span><br><span class="line">                    jdbcTemplate.update(<span class="string">&quot;UPDATE account SET balance = balance - 100 WHERE user_id = ?&quot;</span>, <span class="number">1</span>);</span><br><span class="line">                &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">                    <span class="comment">// 发生异常，回滚事务</span></span><br><span class="line">                    status.setRollbackOnly();</span><br><span class="line">                    <span class="keyword">throw</span> e;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li><p><strong>编程式事务（使用PlatformTransactionManager）：</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> org.springframework.beans.factory.annotation.Autowired;</span><br><span class="line"><span class="keyword">import</span> org.springframework.jdbc.core.JdbcTemplate;</span><br><span class="line"><span class="keyword">import</span> org.springframework.stereotype.Service;</span><br><span class="line"><span class="keyword">import</span> org.springframework.transaction.PlatformTransactionManager;</span><br><span class="line"><span class="keyword">import</span> org.springframework.transaction.TransactionDefinition;</span><br><span class="line"><span class="keyword">import</span> org.springframework.transaction.TransactionStatus;</span><br><span class="line"><span class="keyword">import</span> org.springframework.transaction.support.DefaultTransactionDefinition;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Service</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ProgrammaticTransactionService</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> JdbcTemplate jdbcTemplate;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> PlatformTransactionManager transactionManager;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">performTransaction</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 定义事务属性</span></span><br><span class="line">        DefaultTransactionDefinition transactionDefinition = <span class="keyword">new</span> DefaultTransactionDefinition();</span><br><span class="line">        transactionDefinition.setIsolationLevel(TransactionDefinition.ISOLATION_READ_COMMITTED);</span><br><span class="line">        transactionDefinition.setPropagationBehavior(TransactionDefinition.PROPAGATION_REQUIRED);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 开启事务</span></span><br><span class="line">        TransactionStatus status = transactionManager.getTransaction(transactionDefinition);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">// 执行业务逻辑，可能包含多个数据库操作</span></span><br><span class="line">            jdbcTemplate.update(<span class="string">&quot;INSERT INTO users (username, password) VALUES (?, ?)&quot;</span>, <span class="string">&quot;user1&quot;</span>, <span class="string">&quot;pass1&quot;</span>);</span><br><span class="line">            jdbcTemplate.update(<span class="string">&quot;UPDATE account SET balance = balance - 100 WHERE user_id = ?&quot;</span>, <span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 提交事务</span></span><br><span class="line">            transactionManager.commit(status);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            <span class="comment">// 发生异常，回滚事务</span></span><br><span class="line">            transactionManager.rollback(status);</span><br><span class="line">            <span class="keyword">throw</span> e;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li><p><strong>声明式事务（使用@Transactional）：</strong>在声明式事务中，通过<code>@Transactional</code>注解标记需要进行事务管理的方法，Spring会在方法开始前开启事务，在方法执行完毕后根据情况提交或回滚事务。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> org.springframework.beans.factory.annotation.Autowired;</span><br><span class="line"><span class="keyword">import</span> org.springframework.jdbc.core.JdbcTemplate;</span><br><span class="line"><span class="keyword">import</span> org.springframework.stereotype.Service;</span><br><span class="line"><span class="keyword">import</span> org.springframework.transaction.annotation.Transactional;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Service</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">DeclarativeTransactionService</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> JdbcTemplate jdbcTemplate;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Transactional</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">performTransaction</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 执行业务逻辑，可能包含多个数据库操作</span></span><br><span class="line">        jdbcTemplate.update(<span class="string">&quot;INSERT INTO users (username, password) VALUES (?, ?)&quot;</span>, <span class="string">&quot;user1&quot;</span>, <span class="string">&quot;pass1&quot;</span>);</span><br><span class="line">        jdbcTemplate.update(<span class="string">&quot;UPDATE account SET balance = balance - 100 WHERE user_id = ?&quot;</span>, <span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li><p><strong>声明式事务（使用XML）：</strong></p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">beans</span> <span class="attr">xmlns</span>=<span class="string">&quot;http://www.springframework.org/schema/beans&quot;</span></span></span><br><span class="line"><span class="tag">       <span class="attr">xmlns:xsi</span>=<span class="string">&quot;http://www.w3.org/2001/XMLSchema-instance&quot;</span></span></span><br><span class="line"><span class="tag">       <span class="attr">xmlns:tx</span>=<span class="string">&quot;http://www.springframework.org/schema/tx&quot;</span></span></span><br><span class="line"><span class="tag">       <span class="attr">xsi:schemaLocation</span>=<span class="string">&quot;http://www.springframework.org/schema/beans</span></span></span><br><span class="line"><span class="string"><span class="tag">                           http://www.springframework.org/schema/beans/spring-beans.xsd</span></span></span><br><span class="line"><span class="string"><span class="tag">                           http://www.springframework.org/schema/tx</span></span></span><br><span class="line"><span class="string"><span class="tag">                           http://www.springframework.org/schema/tx/spring-tx.xsd&quot;</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">&lt;!-- 数据源配置，省略 --&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">&lt;!-- 配置事务管理器 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;transactionManager&quot;</span> <span class="attr">class</span>=<span class="string">&quot;org.springframework.jdbc.datasource.DataSourceTransactionManager&quot;</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;dataSource&quot;</span> <span class="attr">ref</span>=<span class="string">&quot;dataSource&quot;</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">&lt;!-- 启用注解驱动的事务管理 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">tx:annotation-driven</span>/&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">&lt;!-- 声明式事务的服务类 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;declarativeTransactionService&quot;</span> <span class="attr">class</span>=<span class="string">&quot;com.example.DeclarativeTransactionService&quot;</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;jdbcTemplate&quot;</span> <span class="attr">ref</span>=<span class="string">&quot;jdbcTemplate&quot;</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">beans</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>然后，服务类 <code>DeclarativeTransactionService</code>：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> org.springframework.beans.factory.annotation.Autowired;</span><br><span class="line"><span class="keyword">import</span> org.springframework.jdbc.core.JdbcTemplate;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">DeclarativeTransactionService</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> JdbcTemplate jdbcTemplate;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setJdbcTemplate</span><span class="params">(JdbcTemplate jdbcTemplate)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.jdbcTemplate = jdbcTemplate;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">performTransaction</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 执行业务逻辑，可能包含多个数据库操作</span></span><br><span class="line">        jdbcTemplate.update(<span class="string">&quot;INSERT INTO users (username, password) VALUES (?, ?)&quot;</span>, <span class="string">&quot;user1&quot;</span>, <span class="string">&quot;pass1&quot;</span>);</span><br><span class="line">        jdbcTemplate.update(<span class="string">&quot;UPDATE account SET balance = balance - 100 WHERE user_id = ?&quot;</span>, <span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>此时，<code>DeclarativeTransactionService</code> 中的 <code>performTransaction</code> 方法上不需要添加 <code>@Transactional</code> 注解，而是通过XML配置中的 <code>&lt;tx:annotation-driven/&gt;</code> 启用了注解驱动的事务管理。 Spring 会在执行 <code>performTransaction</code> 方法时自动开启、提交或回滚事务。</p>
</li>
</ol>
<p>Spring为事务管理提供了一致的编程模板，在高层次建立了统一的事务抽象，像Spring DAO为不同的持久化提供了模板类一样，Spring也提供了<strong>事务模板类TransactionTemplate</strong>。通过模板类并配合使用事务回调TransactionCallback指定具体的持久化操作，就可以通过编程方式实现事务管理，而无需关注资源获取、复用、释放、事务同步和异常处理等操作。</p>
<p>Spring事务通过创建 <code>BeanFactoryTransactionAttributeSourceAdvisor</code> 并将 <code>TransactionInterceptor</code> 注入其中，实现了在Spring AOP中对事务的处理。<code>TransactionInterceptor</code> 实现了 <code>Advice</code> 接口，而Spring AOP会将Advisor中的Advice转换成拦截器链，然后调用。这种方式使得Spring事务能够通过AOP的方式插入到方法执行的流程中，实现了声明式事务管理。这种方式适用于希望通过注解或XML配置来声明事务属性，实现声明式事务管理的场景。</p>
<p>Spring事务管理主要涉及到以下几个关键的概念和接口：</p>
<ol>
<li><p><strong>事务管理器（Transaction Manager）：</strong> <code>PlatformTransactionManager</code> 接口是Spring事务管理的核心接口，定义了事务的开始、提交、回滚等基本操作。Spring提供了多个实现类，如<code>DataSourceTransactionManager</code>、<code>JtaTransactionManager</code>等，用于与不同的事务管理机制集成。</p>
</li>
<li><p><strong>事务定义（Transaction Definition）：</strong> <code>TransactionDefinition</code> 接口定义了事务的隔离级别、传播行为、超时时间等属性。在Spring中，通过<code>DefaultTransactionDefinition</code>等实现类来表示事务的属性。</p>
</li>
<li><p><strong>事务状态（TransactionStatus）：</strong> <code>TransactionStatus</code> 接口用于表示事务的状态，包括是否新的事务、是否已经完成、是否回滚等。</p>
</li>
<li><p><strong>事务注解：</strong> Spring提供了基于注解的事务管理，通过<code>@Transactional</code>注解可以在方法或类级别声明事务属性。</p>
</li>
</ol>
<p><strong>Spring事务的组成部分</strong></p>
<ol>
<li><p><strong>事务管理器（Transaction Manager）</strong>：</p>
<ul>
<li>Spring 提供了不同类型的事务管理器来支持不同的数据源：<ul>
<li><code>DataSourceTransactionManager</code>：支持 JDBC 事务</li>
<li><code>JpaTransactionManager</code>：支持 JPA 事务</li>
<li><code>HibernateTransactionManager</code>：支持 Hibernate 事务</li>
<li><code>JtaTransactionManager</code>：支持 JTA 事务，通常用于分布式事务</li>
</ul>
</li>
</ul>
<p>事务管理器的职责是开启、提交、回滚事务。</p>
</li>
<li><p><strong>事务代理（Transaction Proxy）</strong>：</p>
<ul>
<li>Spring AOP 使用代理来实现事务的自动管理，通常是基于 JDK 动态代理或 CGLIB 代理的方式。</li>
<li>Spring 会在切点处插入事务逻辑，决定何时开始事务、何时提交或回滚。</li>
</ul>
</li>
<li><p><strong>事务属性（Transaction Attributes）</strong>：</p>
<ul>
<li>Spring 提供了注解和 XML 配置来定义事务的属性。</li>
<li>最常用的事务属性包括：<ul>
<li><code>propagation</code>：事务传播行为（事务如何与其他事务交互）</li>
<li><code>isolation</code>：事务隔离级别（事务如何隔离其他事务的影响）</li>
<li><code>timeout</code>：事务的超时时间</li>
<li><code>readOnly</code>：指定事务是否为只读事务，优化数据库操作</li>
<li><code>rollbackFor</code>：指定哪些异常会导致事务回滚</li>
</ul>
</li>
</ul>
</li>
<li><p><strong>事务管理接口（PlatformTransactionManager）</strong>：</p>
<ul>
<li><code>PlatformTransactionManager</code> 是事务管理器的核心接口。它定义了开始、提交、回滚等方法，Spring 通过它来管理事务。</li>
<li>通常不会直接使用 <code>PlatformTransactionManager</code>，而是通过事务注解或 XML 配置来间接使用。</li>
</ul>
</li>
</ol>
<p>Spring事务的基本执行流程：</p>
<ol>
<li>获取对应事务属性，也就是获取 <code>@Transactional</code> 注解上的属性。事务的定义可以通过XML配置或使用<code>@Transactional</code>注解进行声明。定义事务的隔离级别、传播行为、超时时间等属性。判断是否需要开始新事务。</li>
<li>获取TransactionManager，常用的如DataSourceTransactionManager事务管理。Spring会根据配置选择合适的事务管理器。获取数据库连接、开启事务。</li>
<li>执行具体方法逻辑（如SQL）。</li>
<li>回调执行下一个调用链。</li>
<li>一旦出现异常，尝试异常处理，回滚事务。通过completeTransactionAfterThrowing来完成回滚操作，具体回滚逻辑通过doRollBack方法来实现。</li>
<li>正常执行完毕，提交事务，调用 <code>commit()</code> 方法。通过completeTransactionAfterReturning来完成提交操作，具体提交逻辑由doCommit方法来实现。</li>
<li>事务执行完毕，需要清除相关的事务信息，释放资源，cleanupTransactionInfo</li>
</ol>
<h4 id="问：-Transaction？"><a href="#问：-Transaction？" class="headerlink" title="问：@Transaction？"></a>问：@Transaction？</h4><p>@Transaction？底层实现是AOP，动态代理 </p>
<ol>
<li>实现是通过Spring代理来实现的。生成当前类的代理类，调用代理类的invoke（）方法，在invoke（）方法中调用 TransactionInterceptor拦截器的invoke（）方法；</li>
<li>非public方式其事务是失效的；</li>
<li>自调用也会失效，因为动态代理机制导致</li>
<li>多个方法外层加入try…catch，解决办法是可以在catch里 throw new RuntimeException（）来处理</li>
</ol>
<h4 id="问：Spring事务如何回滚？"><a href="#问：Spring事务如何回滚？" class="headerlink" title="问：Spring事务如何回滚？"></a>问：Spring事务如何回滚？</h4><p>在 Spring 中，事务回滚是通过 <strong>异常</strong> 来控制的。默认情况下，Spring 只有在 <strong>未检查异常（RuntimeException）</strong> 或 <strong>Error</strong> 时回滚事务。可以通过配置来定制回滚的行为。</p>
<p><strong>默认的回滚规则</strong>：</p>
<ul>
<li>事务会在遇到 <strong><code>RuntimeException</code></strong> 或 <strong><code>Error</code></strong> 时回滚。</li>
<li>事务 <strong>不会</strong> 在遇到 **<code>checked exceptions</code>**（如 <code>SQLException</code>）时回滚。</li>
</ul>
<p><strong>定制回滚规则</strong>：</p>
<ul>
<li><p>使用 @Transactional注解的 rollbackFor或 noRollbackFor</p>
<p> 属性可以定制哪些异常会触发回滚。例如：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Transactional(rollbackFor = Exception.class)</span> <span class="comment">// 所有异常都会触发回滚</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">someMethod</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 业务逻辑</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
<p><strong>回滚示例</strong>：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Transactional(rollbackFor = SQLException.class)</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">someMethod</span><span class="params">()</span> <span class="keyword">throws</span> SQLException </span>&#123;</span><br><span class="line">    <span class="comment">// 业务逻辑</span></span><br><span class="line">    <span class="keyword">if</span> (someCondition) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> SQLException(<span class="string">&quot;Database error!&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在这个例子中，即使是 <code>SQLException</code> 这样的 <code>checked exception</code>，Spring 也会回滚事务。</p>
<p><strong>方法级回滚配置</strong>：</p>
<p>可以在方法上使用 <code>@Transactional</code> 注解来定制回滚行为：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Transactional(rollbackFor = &#123;RuntimeException.class, SQLException.class&#125;)</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">methodWithCustomRollback</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 业务逻辑</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h4 id="问：Spring事务传播？⭐⭐⭐"><a href="#问：Spring事务传播？⭐⭐⭐" class="headerlink" title="问：Spring事务传播？⭐⭐⭐"></a>问：Spring事务传播？⭐⭐⭐</h4><p>事务传播机制决定了在一个事务方法调用另一个事务方法时，如何管理它们之间的事务关系。Spring 提供了以下几种事务传播方式：</p>
<ol>
<li>**<code>REQUIRED</code>**（默认）：<ul>
<li>如果当前方法有事务，则加入当前事务。如果没有事务，创建一个新的事务。</li>
<li>常用的传播行为。</li>
</ul>
</li>
<li>**<code>REQUIRES_NEW</code>**：<ul>
<li>总是创建一个新的事务，挂起当前事务（如果有的话），在新事务完成后再恢复当前事务。</li>
<li>用于某些操作需要独立的事务，即使外层事务回滚，内层事务也要提交。</li>
</ul>
</li>
<li>**<code>SUPPORTS</code>**：<ul>
<li>如果当前有事务，则加入当前事务。如果没有事务，方法将以非事务的方式执行。</li>
<li>适用于某些方法希望在有事务的环境下执行，而在没有事务时执行不受事务管理的操作。</li>
</ul>
</li>
<li>**<code>NOT_SUPPORTED</code>**：<ul>
<li>如果当前有事务，则挂起当前事务，以非事务的方式执行当前方法。</li>
<li>适用于方法不需要事务的情况，例如进行一些与数据库无关的操作。</li>
</ul>
</li>
<li>**<code>MANDATORY</code>**：<ul>
<li>如果当前没有事务，则抛出异常。</li>
<li>适用于必须在事务上下文中执行的方法。</li>
</ul>
</li>
<li>**<code>NEVER</code>**：<ul>
<li>如果当前有事务，则抛出异常。方法必须在没有事务的情况下执行。</li>
</ul>
</li>
<li>**<code>NESTED</code>**：<ul>
<li>如果当前有事务，则在当前事务中创建一个嵌套事务（savepoint），允许提交或回滚。如果没有事务，表现和 <code>REQUIRED</code> 相同。</li>
<li>适用于需要嵌套事务的场景。</li>
</ul>
</li>
</ol>
<p><strong>事务传播示例</strong>：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Transactional(propagation = Propagation.REQUIRED)</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">methodA</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 业务逻辑，当前事务存在</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Transactional(propagation = Propagation.REQUIRES_NEW)</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">methodB</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 业务逻辑，新的事务会被创建</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Transactional(propagation = Propagation.SUPPORTS)</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">methodC</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 业务逻辑，支持事务环境下运行</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p>在不同的方法嵌套调用过程中，事务要如何处理，是否用同一个事务？出现异常是否回滚或提交？</p>
<h3 id="1-7-其他"><a href="#1-7-其他" class="headerlink" title="1.7 其他"></a>1.7 其他</h3><h4 id="问：讲一下spring常用的注解有哪些？都有什么作用？-Autowired和-Resource的区别？"><a href="#问：讲一下spring常用的注解有哪些？都有什么作用？-Autowired和-Resource的区别？" class="headerlink" title="问：讲一下spring常用的注解有哪些？都有什么作用？@Autowired和@Resource的区别？"></a>问：讲一下spring常用的注解有哪些？都有什么作用？@Autowired和@Resource的区别？</h4><ol>
<li><strong>@ComponentScan：</strong> 用于指定要扫描的包，并自动注册标记为 <code>@Component</code>、<code>@Service</code>、<code>@Repository</code>、<code>@Controller</code> 等的类到Spring容器中。</li>
<li><strong>@Component：</strong> 用于将类标记为一个Spring组件，交给Spring容器管理。</li>
<li><strong>@Service：</strong> 用于标记业务层的组件，通常用在服务类上。</li>
<li><strong>@Repository：</strong> 用于标记数据访问层的组件，通常用在DAO类上。</li>
<li><strong>@Controller：</strong> 用于标记控制器层的组件，通常用在Spring MVC的Controller类上。</li>
<li><strong>@Autowired：</strong> 用于自动装配（依赖注入）Spring容器中的Bean，可以用在构造方法、属性、方法上。</li>
<li><strong>@Qualifier：</strong> 与 <code>@Autowired</code> 配合使用，指定具体要注入的Bean的名称。</li>
<li><strong>@Value：</strong> 用于注入简单类型的值或表达式到Bean的属性。</li>
<li><strong>@Configuration：</strong> 用于标记配置类，相当于传统的XML配置文件。</li>
<li><strong>@Bean：</strong> 用于在 <code>@Configuration</code> 类中声明Bean，Spring会自动托管这些Bean。</li>
<li><strong>@Scope：</strong> 用于指定Bean的作用域，如单例 (<code>Singleton</code>)、原型 (<code>Prototype</code>) 等。</li>
<li><strong>@Primary：</strong> 用于指定优先注入的Bean，当有多个相同类型的Bean时，被标记为 <code>@Primary</code> 的Bean会被优先选择。</li>
<li><strong>@Lazy：</strong> 用于延迟初始化Bean，即在第一次被请求时才进行实例化。</li>
<li><strong>@Transactional：</strong> 用于声明事务管理，可用在类或方法上，实现声明式事务。</li>
<li><strong>@RequestMapping：</strong> 用于映射处理请求的方法，常用于Spring MVC的Controller类中。</li>
<li><strong>@PathVariable：</strong> 用于提取请求URL中的占位符参数，通常用于RESTful风格的请求。</li>
<li><strong>@RequestParam：</strong> 用于获取请求参数的值，可用于方法的参数上。</li>
<li><strong>@ResponseBody：</strong> 用于指定方法返回的结果直接作为响应体，而不是视图名称。</li>
<li><strong>@ResponseStatus：</strong> 用于指定方法抛出特定异常时的HTTP响应状态。</li>
<li><strong>@ExceptionHandler：</strong> 用于处理控制器中抛出的异常，可以指定处理的异常类型。</li>
</ol>
<p>@Autowired、@Resource和@Inject的区别？</p>
<p>相同点：三个注解都用于进行依赖注入，将一个 Bean 注入到另一个 Bean 中，简化了在 Spring 容器中注入依赖对象的过程。</p>
<p><strong>不同点：</strong></p>
<ol>
<li><h2 id="来源和适用性："><a href="#来源和适用性：" class="headerlink" title="来源和适用性："></a><strong>来源和适用性：</strong></h2><p>- </p>
</li>
<li><p><strong>支持类型：</strong></p>
<ul>
<li><code>@Autowired</code> 支持按类型注入，可以与 <code>@Qualifier</code> 注解一起使用进行更精确的匹配。</li>
<li><code>@Resource</code> 可以按照名称注入，也可以按照类型注入，但是按照类型时需要结合 <code>@Named</code> 使用。</li>
<li><code>@Inject</code> 类似于 <code>@Autowired</code>，也是按类型注入，可以与 <code>@Qualifier</code> 注解一起使用。</li>
</ul>
</li>
<li><h2 id="可选性："><a href="#可选性：" class="headerlink" title="可选性："></a><strong>可选性：</strong></h2><ul>
<li></li>
<li><code>@Inject</code> 默认为 <code>required = true</code>，表示注入的对象必须存在，如果找不到匹配的 bean，会抛出异常。可以通过设置 <code>required = false</code> 来使注入变为可选。</li>
</ul>
</li>
<li><p><strong>支持的容器：</strong></p>
<ul>
<li><code>@Autowired</code> 主要用于 Spring 容器，是 Spring 框架的一部分。</li>
<li><code>@Resource</code> 是 Java EE 的一部分，可以在支持 Java EE 规范的容器中使用，同时也可以在 Spring 中使用。</li>
<li><code>@Inject</code> 是 JSR-330 的一部分，可以在支持 JSR-330 的容器中使用，Spring 也支持 JSR-330。</li>
</ul>
</li>
</ol>
<p>总体而言，这些注解在实际使用中可以根据具体的场景和需求进行选择，它们都提供了便捷的依赖注入方式，但在不同的容器和框架中可能有一些差异。</p>
<ul>
<li><code>@Autowired</code> 是 Spring 提供的注解，可以用于构造函数、属性、方法以及字段上。</li>
<li><code>@Resource</code> 是由 Java EE 提供的注解，可以用于字段、setter 方法和构造函数（需要和 <code>@Named</code> 注解一起使用）。</li>
</ul>
<p>不同点：</p>
<ol>
<li><strong>来源：</strong><ul>
<li><code>@Autowired</code> 是Spring提供的注解，它是按照类型（byType）进行自动装配的。</li>
<li><code>@Resource</code> 是JavaEE提供的注解，它是按照名称（byName）进行自动装配的。</li>
<li><code>@Inject</code> 是 JSR-330 提供的标准注解。</li>
</ul>
</li>
<li><strong>注入类型：</strong><ul>
<li><code>@Autowired</code> 可以用在字段、方法、构造方法、setter方法等地方，支持类型匹配的自动注入。</li>
<li><code>@Resource</code> 主要用在字段上，也可以用在setter方法上，不支持构造方法注入。</li>
<li><code>@Inject</code> 可以用在字段、方法、构造方法上</li>
</ul>
</li>
<li><strong>注解中的属性</strong>：<ul>
<li><code>@Autowired</code> 只有一个 <code>required</code> 属性默认为 <code>true</code>，表示注入的对象是否可以为null，如果找不到匹配的 bean，会抛出异常。可以通过设置 <code>required = false</code> 来使注入变为可选。</li>
<li><code>@Resource</code> 包含7个属性，最重要的两个属性为name和type，分别用于指定依赖注入的bean的名称和类型。</li>
<li><code>@Inject</code> 没有属性。</li>
</ul>
</li>
<li><strong>注入方式：</strong><ul>
<li><code>@Autowired</code> 默认按照类型（byType）进行注入，如果存在多个匹配的Bean，可以结合 <code>@Qualifier</code> 使用指定Bean的名称。</li>
<li><code>@Resource</code> 默认按照名称（byName）进行注入，通过 <code>name</code> 属性指定具体的Bean名称。@但Resource还有属性type，解析为bean的类型。如果使用name属性，则使用byName的自动注入策略，而使用type属性时则使用byType自动注入策略。默认使用byName自动注入策略。</li>
<li><code>@Inject</code> 默认按照类型（byType）进行注入，若想要按名称（byName）进行注入，需要搭配@Named注解使用</li>
</ul>
</li>
<li><strong>可选性：</strong><ul>
<li><code>@Autowired</code> 是默认必须找到匹配的Bean，如果找不到则抛出异常。可以通过 <code>required</code> 属性设置为 <code>false</code>，使其变为非必须的。</li>
<li><code>@Resource</code> 如果找不到匹配的Bean，则会尝试按照类型进行匹配，如果还找不到才会抛出异常。</li>
</ul>
</li>
<li><strong>适用范围：</strong><ul>
<li><code>@Autowired</code> 是Spring提供的注解，更通用，可以用于任何Bean的自动装配。</li>
<li><code>@Resource</code> 是JavaEE提供的注解，相对于 <code>@Autowired</code> 来说功能较少，主要用于注入其他JavaEE组件，如EJB等。</li>
</ul>
</li>
</ol>
<h4 id="问：有用过Spring提供的扩展组件吗？比如拦截器？请说下这个拦截器的api？还有没用过其它的组件？"><a href="#问：有用过Spring提供的扩展组件吗？比如拦截器？请说下这个拦截器的api？还有没用过其它的组件？" class="headerlink" title="问：有用过Spring提供的扩展组件吗？比如拦截器？请说下这个拦截器的api？还有没用过其它的组件？"></a>问：有用过Spring提供的扩展组件吗？比如拦截器？请说下这个拦截器的api？还有没用过其它的组件？</h4><p>Spring框架提供了许多扩展组件，其中拦截器（Interceptor）是常用的之一，主要用于<strong>在处理器执行过程中进行预处理、后处理，实现对请求的拦截和处理</strong>。</p>
<p>Spring的拦截器主要涉及以下接口和类：</p>
<ol>
<li><p><strong>HandlerInterceptor 接口：</strong></p>
<ul>
<li><code>preHandle</code>: 在处理器执行之前被调用，用于进行预处理，可以决定是否继续执行处理器。</li>
<li><code>postHandle</code>: 在处理器执行之后、视图渲染之前被调用，用于进行后处理。</li>
<li><code>afterCompletion</code>: 在整个请求完成后、视图渲染结束后被调用，用于进行资源清理等工作。</li>
</ul>
</li>
<li><p><strong>HandlerInterceptorAdapter 类：</strong></p>
<ul>
<li>是 <code>HandlerInterceptor</code> 接口的适配器类，可以继承这个类来简化拦截器的实现。</li>
</ul>
</li>
<li><p><strong>InterceptorRegistry 类：</strong></p>
<ul>
<li>用于配置拦截器，包括添加、顺序等。</li>
</ul>
</li>
</ol>
<p><strong>示例：</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyInterceptor</span> <span class="keyword">implements</span> <span class="title">HandlerInterceptor</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">preHandle</span><span class="params">(HttpServletRequest request, HttpServletResponse response, Object handler)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        <span class="comment">// 在处理器执行之前进行预处理</span></span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>; <span class="comment">// 返回 true 表示继续执行后续操作，返回 false 将中断执行链。</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">postHandle</span><span class="params">(HttpServletRequest request, HttpServletResponse response, Object handler, ModelAndView modelAndView)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        <span class="comment">// 在处理器执行之后、视图渲染之前进行后处理</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">afterCompletion</span><span class="params">(HttpServletRequest request, HttpServletResponse response, Object handler, Exception ex)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        <span class="comment">// 在整个请求完成后、视图渲染结束后进行清理工作</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>配置拦截器：</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">WebConfig</span> <span class="keyword">implements</span> <span class="title">WebMvcConfigurer</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">addInterceptors</span><span class="params">(InterceptorRegistry registry)</span> </span>&#123;</span><br><span class="line">        registry.addInterceptor(<span class="keyword">new</span> MyInterceptor()).addPathPatterns(<span class="string">&quot;/secure/**&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>





<p>除了拦截器，Spring还提供了许多其他的扩展组件，比如：</p>
<ul>
<li><strong>BeanPostProcessor 接口：</strong> 允许在Bean初始化前后进行一些处理。</li>
<li><strong>ApplicationListener 接口：</strong> 用于监听应用事件。</li>
<li><strong>HandlerMethodArgumentResolver 接口：</strong> 用于自定义方法参数解析器。</li>
<li><strong>HandlerMethodReturnValueHandler 接口：</strong> 用于自定义方法返回值处理器。</li>
</ul>
<h4 id="问：登录态怎么去处理的？"><a href="#问：登录态怎么去处理的？" class="headerlink" title="问：登录态怎么去处理的？"></a>问：登录态怎么去处理的？</h4><ul>
<li><p>什么是登录态？</p>
<ul>
<li>登录态是用于标识用户身份和维护用户登录状态的一种机制。区分<strong>无状态</strong>下HTTP协议的浏览器中用户的身份和状态。</li>
</ul>
</li>
<li><p>有哪些实现方案？</p>
<ol>
<li><p><strong>HTTP</strong>：HTTP本身是无状态的协议，每个请求都独立，不借助其它手段，难以实现既安全又可靠的登录态。</p>
</li>
<li><p><strong>Cookie、Session</strong>：</p>
<ul>
<li>Cookie：是客户端请求服务端时，由服务端创建并由客户端存储和管理的小文本文件。<ul>
<li><strong>工作原理：</strong> 服务器在响应中通过<strong>Set-Cookie</strong>头将Cookie信息发送给客户端，浏览器在后续请求中通过<strong>Cookie</strong>头将存储在客户端的信息发送给服务器。</li>
<li><strong>特点：</strong><ul>
<li>存储在客户端，对于敏感信息应该进行加密。</li>
<li>有大小限制，一般不超过4KB。</li>
<li>可以设置过期时间，可以是会话级别的（浏览器关闭后失效）或持久的。</li>
</ul>
</li>
</ul>
</li>
<li>Session：是服务器端存储的一种会话机制，用于跟踪用户的状态。客户端请求服务端时服务端会为这次请求创建一个数据结构，这个结构可以通过内存、文件、数据库等方式保存。<ul>
<li><strong>工作原理：</strong> 当用户首次访问服务器时，服务器为其创建一个唯一的<strong>Session ID</strong>，并将该ID存储在<strong>Cookie</strong>中或作为URL的一部分发送给客户端。客户端在后续请求中携带Session ID，服务器通过Session ID来识别用户，并在服务器端保存用户的状态信息。</li>
<li>特点：<ul>
<li>存储在服务器端，相对于Cookie更安全。</li>
<li>无大小限制，但服务器需要维护Session存储。</li>
<li>可以设置过期时间，一般在一段时间内没有访问会话将被销毁。</li>
</ul>
</li>
</ul>
</li>
<li>优点：<ul>
<li>Cookie由客户端管理，支持设定有效期、安全加密、防篡改、请求路径等属性。</li>
<li>Session由服务端管理，支持有效期，可以存储各类数据。</li>
</ul>
</li>
<li>缺点：<ul>
<li>Cookie只能存储字符串，有大小和数量限制，对移动APP端支持不好，同时有<strong>跨域限制</strong>（主域不同）。</li>
<li>Session存储在服务端，对服务端有性能开销，客户端量太大会影响性能。如果集中存储（如存储在Redis），会带来额外的部署维护成本。</li>
</ul>
</li>
</ul>
</li>
<li><p><strong>Token</strong>：是一种在客户端和服务器之间进行身份验证的令牌。在身份验证成功后，服务器生成一个Token并返回给客户端，客户端在后续请求中<strong>通过携带Token来进行身份验证</strong>。</p>
<ul>
<li><p><strong>工作原理：</strong> 用户在登录成功后，服务器生成一个Token，并将其返回给客户端。客户端将Token存储起来，通常通过Cookie或其他手段。在后续请求中，客户端将Token发送给服务器，服务器通过验证Token的有效性来确认用户身份。</p>
</li>
<li><p>一般由以下数据组成：</p>
<figure class="highlight isbl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="title">uid</span>(用户唯一的身份标识)</span></span><br><span class="line"><span class="function"><span class="title"><span class="built_in">time</span></span>(当前时间的时间戳)</span></span><br><span class="line"><span class="function"><span class="title">sign</span>(签名，由<span class="variable">token</span>的前几位+盐用哈希算法压缩成一定长的十六进制字符串)</span></span><br></pre></td></tr></table></figure></li>
<li><p>特点：</p>
<ul>
<li>存储在客户端，可通过多种方式传递，如HTTP头、URL参数等。</li>
<li>无大小限制，但需要注意安全性，可以进行签名或加密。</li>
<li>通常具有一定的时效性，避免长时间内使用相同的Token。</li>
</ul>
</li>
<li><p>优点：</p>
<ul>
<li>客户端可以用Cookie、LocalStorage等存储，服务端不需要存储。</li>
<li>安全性高（有签名校验）。</li>
<li>支持移动APP端。</li>
<li>支持跨域。</li>
</ul>
</li>
<li><p>缺点：</p>
<ul>
<li>占用额外传输宽带，因为Token比较大，可能会消耗一定的流量。</li>
<li>每次签名校验会消耗服务端性能。</li>
<li>有效期短（避免被盗用）。但是有效期太短会造成客户端不断重新登录，体验太差。解决： <code>Refresh Token</code> 就是再来一个Token，一个专门生成Token的Token。</li>
</ul>
</li>
</ul>
</li>
<li><p><strong>JWT</strong>：服务器端若频繁校验token是否有效，可能会因为查库而影响性能。可以通过JWT（<code>JSON Web Token</code>）来优化。</p>
<ul>
<li><p><code>JWT</code> 是 <code>Auth0</code> 提出的通过 <code>对JSON进行加密签名</code> 来实现授权验证的方案。</p>
</li>
<li><p>JWT也是一种Token，由三部分组成： <code>Header头部</code> 、 <code>Payload负载</code> 和 <code>Signature签名</code>。它是一个很长的字符串，中间用点（ <code>.</code> ）分隔成三个部分，如：</p>
<figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="attribute">eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9</span>.eyJzdWIiOiIxMjM<span class="number">0</span>NTY<span class="number">3</span>ODkwIiwibmFtZSI<span class="number">6</span>IkpvaG<span class="number">4</span>gRG<span class="number">9</span>lIiwiaWF<span class="number">0</span>IjoxNTE<span class="number">2</span>MjM<span class="number">5</span>MDIyfQ.SflKxwRJSMeKKF<span class="number">2</span>QT<span class="number">4</span>fwpMeJf<span class="number">36</span>POk<span class="number">6</span>yJV_adQssw<span class="number">5</span>c</span><br></pre></td></tr></table></figure></li>
<li><p>JWT的流程和Token的基本一样，因为已经携带了客户端信息（如用户ID等），所以服务端校验Token时不需要查询数据库了。</p>
</li>
</ul>
</li>
<li><p><strong>单点登陆</strong>：上面都是同一域名下的解决方案，当网站有诸多域名、要求一次登陆可以访问所有域名/系统时，即单点登陆问题（Single Sign On SSO）。</p>
<ul>
<li>常见的实现方式包括CAS（Central Authentication Service）等。</li>
<li><strong>认证中心（CAS Server）：</strong> CAS服务器是单点登录的核心，负责用户的认证和票据的颁发。它通常维护一个用户账户数据库，处理用户的登录请求，并生成用于标识用户身份的票据（Ticket）。</li>
<li><strong>票据（Ticket）：</strong> 用户在CAS服务器上成功登录后，CAS服务器会颁发一个票据</li>
</ul>
</li>
<li><p><strong>OAuth（开放授权）：</strong> OAuth是一种开放标准，允许用户授权第三方应用访问其在服务提供商上存储的资源，而无需将用户名和密码提供给第三方应用。OAuth在授权后会返回一个Token，该Token可以用于访问用户的资源。</p>
</li>
<li><p><strong>OpenID Connect：</strong> OpenID Connect是在OAuth 2.0基础上构建的身份认证协议，它允许客户端应用获取关于终端用户的信息，以及验证终端用户的身份。通过OpenID Connect，可以实现身份认证和用户信息的获取。</p>
</li>
</ol>
</li>
</ul>
<p>一般来说，登录态的处理包括以下几个方面：</p>
<ol>
<li><p><strong>用户认证：</strong> 在用户登录时，需要对用户进行认证，通常使用用户名和密码验证用户身份。认证成功后，生成并返回一个唯一的标识符（如Token）。</p>
</li>
<li><p><strong>Token管理：</strong> 将生成的Token保存在客户端，通常存储在Cookie或者LocalStorage/SessionStorage中。Token中包含用户的身份信息以及一些其他信息，用于后续的认证。</p>
</li>
<li><p><strong>请求认证：</strong> 客户端在每次请求时，需要将Token携带到服务端，通常通过请求头或者参数传递。服务端通过验证Token的有效性来判断用户的登录状态。</p>
</li>
<li><p><strong>Token刷新：</strong> 为了增加安全性，Token通常有一个过期时间。当Token即将过期时，可以通过刷新操作来延长Token的有效期，而不需要用户重新登录。</p>
</li>
<li><p><strong>安全性保护：</strong> 在登录态处理中需要注意保护用户的敏感信息，使用HTTPS来加密通信，避免使用明文传输密码等敏感信息。</p>
</li>
</ol>
<p>下面是一个简单的基于Token的登录态处理的示例（使用JWT作为Token）：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 1. 用户登录时生成Token</span></span><br><span class="line">String token = Jwts.builder()</span><br><span class="line">        .setSubject(userId)</span><br><span class="line">        .setExpiration(<span class="keyword">new</span> Date(System.currentTimeMillis() + EXPIRATION_TIME))</span><br><span class="line">        .signWith(SignatureAlgorithm.HS512, SECRET)</span><br><span class="line">        .compact();</span><br><span class="line"></span><br><span class="line"><span class="comment">// 2. 将Token返回给客户端，保存在Cookie中或者LocalStorage/SessionStorage中</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 3. 客户端每次请求时携带Token</span></span><br><span class="line"><span class="comment">// 请求头中添加 Authorization: Bearer &lt;Token&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 4. 服务端验证Token</span></span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">    Claims claims = Jwts.parser()</span><br><span class="line">            .setSigningKey(SECRET)</span><br><span class="line">            .parseClaimsJws(token)</span><br><span class="line">            .getBody();</span><br><span class="line">    <span class="comment">// 验证成功，从claims中获取用户信息</span></span><br><span class="line">    String userId = claims.getSubject();</span><br><span class="line">    <span class="comment">// 进行其他业务逻辑处理</span></span><br><span class="line">&#125; <span class="keyword">catch</span> (ExpiredJwtException | UnsupportedJwtException | MalformedJwtException | SignatureException | IllegalArgumentException e) &#123;</span><br><span class="line">    <span class="comment">// Token验证失败，处理异常</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在实际应用中，可以根据具体的需求选择不同的实现方式，比如使用第三方认证服务（OAuth、OpenID Connect）、Spring Security等。</p>
<h4 id="问：Spring-使用了哪些设计模式？⭐⭐⭐"><a href="#问：Spring-使用了哪些设计模式？⭐⭐⭐" class="headerlink" title="问：Spring 使用了哪些设计模式？⭐⭐⭐"></a>问：Spring 使用了哪些设计模式？⭐⭐⭐</h4><ul>
<li><p><strong>工厂模式</strong>：通常以*Factory形式呈现。proxyFactory</p>
<ul>
<li>简单工厂模式：Spring中的<strong>BeanFactory</strong>就是简单工厂模式的体现，根据传入唯一的标识beanName来获得bean对象</li>
<li>工厂方法模式：FactoryBean接口则体现了工厂方法，通过实现此接口的getObject()方法来自定义Bean对象。</li>
<li>抽象工厂模式：</li>
</ul>
</li>
<li><p><strong>单例模式</strong>：Spring依赖注入Bean实例默认是单例的。Spring的依赖注入（包括lazy-init方式）都是发生在AbstractBeanFactory的getBean里。getBean的doGetBean方法调用getSingleton进行bean的创建。</p>
<ul>
<li><p><strong>单例模式定义：</strong>保证一个类仅有一个实例，并提供一个访问它的全局访问点。</p>
<p><strong>spring对单例的实现：</strong> spring中的单例模式完成了后半句话，即提供了全局的访问点BeanFactory。但没有从构造器级别去控制单例，这是因为spring管理的是任意的java对象。</p>
</li>
</ul>
</li>
<li><p><strong>代理模式</strong>：  Spring AOP（面向切面编程）和事务管理使用了代理模式。动态代理cglib或JDK。</p>
</li>
<li><p><strong>适配器模式</strong>：可以作为两个不兼容的接口之间的桥梁，使不兼容的类可以一起工作，通常以*Adapter形式呈现。</p>
<ul>
<li>Spring 的 AOP 中，通过适配器模式实现不同通知类型的统一调用。AdvisorAdapter类通知。</li>
<li>SpringMVC中的适配器HandlerAdatper根据Handler规则执行不同的Handler。</li>
</ul>
</li>
<li><p><strong>责任链模式</strong>：为请求创建了一个接收者的链，每个接收者都有对另外一个接收者的引用。当一个接收者无法处理请求时就会传给下一个。通常以*Chain形式呈现。</p>
<ul>
<li>如Spring MVC的HandlerExecutionChain。</li>
<li>如使用AOP那些通知调用时先生成一个拦截器链。</li>
</ul>
</li>
<li><p><strong>装饰器模式</strong>： 允许我们向一个现有的对象添加新的功能，同时不改变其现有结构。Spring中用到的包装器模式在类名上有两种表现：一种是类名中含有Wrapper，另一种是类名中含有Decorator。</p>
<ul>
<li>Spring 的 <strong>BeanWrapper</strong> 使用了装饰者模式，对 Bean 进行装饰和增强。依赖注入就需要使用BeanWrapper。</li>
</ul>
</li>
<li><p><strong>观察者模式</strong>：定义了一种一对多的依赖关系，当一个对象状态发生变化时，所有依赖者都会收到通知。listener，event，multicast监听器，监听事件，广播器（多播器）</p>
<ul>
<li>spring 的<strong>事件监听机制</strong>基于观察者模式，通过 ApplicationEvent 和 ApplicationListener 实现。</li>
<li>使用 <code>ApplicationEventPublisher</code> 接口 <code>publishEvent()</code> 方法来发布事件。通常，这个接口由 <code>ApplicationContext</code> 实现。</li>
<li>事件类通常是继承自 <code>ApplicationEvent</code> 。</li>
<li>事件监听器类需要实现 <code>ApplicationListener</code> 接口。<code>ApplicationListener</code> 是一个函数式接口，只有一个 <code>onApplicationEvent()</code> 方法。</li>
<li>事件广播（Multicast）将事件传递给多个监听器。在一个应用中可能有多个监听器监听同一个事件，这时就需要使用 <strong>多播器（Multicaster）</strong>。Spring 提供的 <code>SimpleApplicationEventMulticaster</code> 是事件广播的实现类。它会遍历所有的 <code>ApplicationListener</code>（事件监听器），并调用其 <code>onApplicationEvent()</code> 方法来处理事件。当 Spring 容器启动时，<code>ApplicationContext</code> 会扫描并注册所有的监听器（实现了 <code>ApplicationListener</code> 接口的类或使用 <code>@EventListener</code> 注解的方法）。</li>
</ul>
</li>
<li><p><strong>策略模式</strong>： 定义了一系列算法或策略，将每个算法封装在独立的类中，可以互相替换，在运行时根据需要选择不同的算法。通常以*Strategy形式呈现。ClassPathXmlApplicationContext，FileSystemApplicationContext，XmlBeanDefinitionReader，PropertiesBeanDefinitionReader实例化策略（simple，cglib）</p>
<ul>
<li>Spring中的InstantiationStrategy接口，根据创建对象情况的不同，提供了Bean实例化的三种策略：默认构造方法、指定构造方法、工厂方法。</li>
<li>Spring 的事务管理机制中，通过不同的事务管理策略实现。</li>
</ul>
</li>
<li><p><strong>模板方法模式</strong>：抽象父类提供一套定义好的方法供子类使用，某些子类会根据自己情况进行定制。通常以*Template形式呈现。postProcessBeanFactory，onFresh，initPropertyValue</p>
<ul>
<li>在 Spring 的 JdbcTemplate 和 HibernateTemplate 中使用了模板方法模式。Spring 是模板方法模式和回调模式的结合，是Template Method不需要继承的另一种实现方式。Spring几乎所有的外接扩展都采用这种模式。引入回调原因：JdbcTemplate是抽象类，不能够独立使用，我们每次进行数据访问的时候都要给出一个相应的子类实现,这样肯定不方便，所以就引入了回调。</li>
<li>Spring事务管理的TransactionTemplate。</li>
</ul>
</li>
<li><p><strong>委托者模式</strong>：delegate，如BeanDefinitionParserDelegate</p>
</li>
<li><p><strong>访问者模式</strong>：BeanDefinitionVisitor</p>
</li>
<li><p><strong>构造者模式</strong>：BeanDefinitionBuilder</p>
</li>
<li><p>……</p>
</li>
</ul>
<h2 id="二-Spring-MVC"><a href="#二-Spring-MVC" class="headerlink" title="二.Spring MVC"></a>二.Spring MVC</h2><h4 id="问：讲一下SpringMVC的全流程，可以画一下UML时序图吗？"><a href="#问：讲一下SpringMVC的全流程，可以画一下UML时序图吗？" class="headerlink" title="问：讲一下SpringMVC的全流程，可以画一下UML时序图吗？"></a>问：讲一下SpringMVC的全流程，可以画一下UML时序图吗？</h4><p>参考：<a target="_blank" rel="noopener" href="https://www.cnblogs.com/StarChen20/p/13995258.html"><a target="_blank" rel="noopener" href="https://www.cnblogs.com/StarChen20/p/13995258.html">SpringMVC的工作流程及原理详解</a></a></p>
<p><img src="https://img2020.cnblogs.com/blog/2096812/202011/2096812-20201117160054595-970034678.jpg" alt="img"></p>
<ol>
<li><strong>客户端发送请求：</strong>客户端向服务器发送HTTP请求，请求到达SpringMVC前端控制器（<strong>DispatcherServlet</strong>）。</li>
<li><strong>DispatcherServlet接收请求：</strong> DispatcherServlet是SpringMVC的前端控制器，它接收所有的请求，并负责将请求分发给合适的处理器（Controller）。DispatcherServlet根据请求URI进行解析，找到相应的HandlerMapping（处理器映射器）。</li>
<li><strong>HandlerMapping定位处理器：</strong> DispatcherServlet通过HandlerMapping查找合适的处理器，HandlerMapping根据请求的URL映射到相应的Controller。</li>
<li><strong>HandlerAdapter（处理器适配器）</strong>：DispatcherServlet通过HandlerMapping获取到相应的HandlerExecutionChain（一个执行链对象），根据HandlerExecutionChain内的Handler对象来匹配相应的HandlerAdapter。HandlerAdapter请求映射，对处理器进行适配，以使其能正确处理请求。</li>
<li><strong>Controller控制器</strong>：HandlerAdapter执行handle方法将HandlerExecutionChain内的Handler运行（即我们写的Controller)，并且返回一个ModelAndView模型视图对象。</li>
<li><strong>HandlerIntercepter拦截器</strong>：中央控制器将接收到的ModelAndView对象进行检查，实际调用的是HandlerInterceptor的postHandle方法来检查视图是否存有异常。</li>
<li><strong>ViewResolver视图解析器</strong>：DispatcherServlet将ModelAndView传给ViewResolver解析生成View。</li>
<li><strong>View视图渲染</strong>：DispatcherServlet根据View进行渲染视图，即将模型数据填充至视图中，将结果返回给用户。</li>
</ol>
<p>HttpRequest-&gt;DispatcherServlet-&gt;HandlerMapping-&gt;Handler -&gt;DispatcherServlet-&gt;HandlerAdapter处理handler-&gt;ModelAndView -&gt;DispatcherServlet-&gt;ModelAndView-&gt;ViewReslover-&gt;View -&gt;DispatcherServlet-&gt;Response</p>
<h4 id="问：讲一下SpringMVC不同用户登录的信息怎么保证线程安全的？"><a href="#问：讲一下SpringMVC不同用户登录的信息怎么保证线程安全的？" class="headerlink" title="问：讲一下SpringMVC不同用户登录的信息怎么保证线程安全的？"></a>问：讲一下SpringMVC不同用户登录的信息怎么保证线程安全的？</h4><ul>
<li>Controller默认是单例的，无需为每个请求创建新的Controller，所以Controller非线程安全。</li>
<li>措施：<ol>
<li><strong>不要在Controller中定义成员变量</strong>，若有必要定义非静态变量，通过<code>@Scope(&quot;prototype&quot;)</code> ，将Controller设置为多例模式；或者<code>@Scope(&quot;request&quot;)</code> 在每个HTTP请求中创建一个新的实例。Controller也是一个Bean，默认的 Scope 属性为<strong>Singleton</strong>。</li>
<li><strong>在Controller 中使用 ThreadLocal 变量</strong>，每一个线程都有一个变量的副本。</li>
</ol>
</li>
</ul>
<h2 id="三-Spring-Boot"><a href="#三-Spring-Boot" class="headerlink" title="三.Spring Boot"></a>三.Spring Boot</h2><h4 id="问：SpringBoot和Spring的区别？⭐⭐⭐"><a href="#问：SpringBoot和Spring的区别？⭐⭐⭐" class="headerlink" title="问：SpringBoot和Spring的区别？⭐⭐⭐"></a>问：SpringBoot和Spring的区别？⭐⭐⭐</h4><ul>
<li>Spring提供了很多好用的功能：SpringJDBC、SpringMVC、SpringSecurity、SpringAOP、SpringORM、SpringTest等。</li>
<li>SpringBoot可以看作是Spring的扩展和进化。</li>
<li><strong>简化配置：</strong> 首先设计理念<strong>约定大于配置</strong>，使用大量默认配置，可以快速搭建项目。支持JavaConfig，减少了大量的XML配置，使得应用配置更加简洁。</li>
<li><strong>内嵌Web服务器：</strong> 嵌入应用服务器如Tomcat、 Jetty、 Undertow容器等，不需要再单独配置Web服务器，使得应用可以通过单个可执行JAR文件来运行。</li>
<li><strong>自动化配置：</strong> Spring Boot提供了大量的自动化配置，通过分析类路径下的各种库和框架，尽可能地为应用提供默认配置。</li>
</ul>
<ul>
<li><strong>微服务支持：</strong> Spring Boot天生支持微服务的开发，通过Spring Cloud等项目，可以更方便地构建和管理分布式系统。</li>
<li><strong>监控和管理：</strong> Spring Boot提供了一套丰富的监控和管理功能，包括应用信息端点、健康检查、性能指标等。</li>
</ul>
<table>
<thead>
<tr>
<th>特性</th>
<th>Spring</th>
<th>Spring Boot</th>
</tr>
</thead>
<tbody><tr>
<td>配置方式</td>
<td>需要手动配置大量的 XML 或注解</td>
<td>提供自动配置，减少手动配置</td>
</tr>
<tr>
<td>启动方式</td>
<td>需要部署到外部 Web 容器</td>
<td>可直接运行为独立的 JAR 文件</td>
</tr>
<tr>
<td>项目结构</td>
<td>项目结构复杂，手动配置 Bean 和依赖</td>
<td>项目结构简化，通过 @SpringBootApplication 启动</td>
</tr>
<tr>
<td>自动配置</td>
<td>无自动配置，需要手动设置配置</td>
<td>提供自动配置，自动推测依赖并配置应用</td>
</tr>
<tr>
<td>依赖管理</td>
<td>手动管理依赖，可能出现版本冲突</td>
<td>使用 Spring Boot Starters 自动管理依赖</td>
</tr>
<tr>
<td>事件驱动</td>
<td>支持应用事件机制</td>
<td>更加简化的事件驱动支持</td>
</tr>
<tr>
<td>异步执行</td>
<td>支持异步执行，但需要额外配置</td>
<td>提供内建的异步支持</td>
</tr>
</tbody></table>
<h4 id="问：SpringBoot启动流程？⭐⭐⭐"><a href="#问：SpringBoot启动流程？⭐⭐⭐" class="headerlink" title="问：SpringBoot启动流程？⭐⭐⭐"></a>问：SpringBoot启动流程？⭐⭐⭐</h4><p>SpringBoot在main()方法中调用SpringApplication.run()方法来启动项目。其中内置了常见的Web服务器，所以无需再依赖外部服务器（会在refreshContext()进行容器的启动，默认完成Tomcat容器的创建）。</p>
<p>总结：</p>
<ol>
<li>创建SpringApplication对象，初始化过程主要包括：<ul>
<li>推断并设置当前的web应用类型；</li>
<li><strong>配置基本的环境变量、资源、构造器、监听器</strong>；</li>
<li>根据当前线程的调用栈，推断主应用程序类。</li>
</ul>
</li>
<li>调用run()方法启动Spring Boot应用。</li>
<li>首先创建一个计时器。</li>
<li>设置headless 系统属性。</li>
<li>获取一个运行监听器。</li>
<li>创建应用参数对象。</li>
<li>加载环境变量。</li>
<li>打印启动界面Banner。</li>
<li>创建Spring容器。</li>
<li>容器启动前的处理。</li>
<li>启动Spring容器。</li>
<li>容器启动后的处理。</li>
<li>计算耗时时间。</li>
<li>发布容器已启动事件。</li>
<li>调用所有 ApplicationRunner 和 CommandLineRunner 接口的实现类的run()。</li>
<li>若发生异常则发布应用启动失败事件。</li>
<li>发布应用就绪事件。</li>
</ol>
<p>启动流程中的各个事件发布：</p>
<ol>
<li>通过 SpringFactoriesLoader 加载 <code>META-INF/spring.factories</code> 文件，获取并创建 SpringApplicationRunListener 对象。</li>
<li>然后由 SpringApplicationRunListener 来发出 <strong>starting</strong> 消息</li>
<li>创建参数，并配置当前 SpringBoot 应用将要使用的 Environment</li>
<li>完成之后，依然由 SpringApplicationRunListener 来发出 <strong>environmentPrepared</strong> 消息</li>
<li>创建 ApplicationContext</li>
<li>初始化 ApplicationContext，并设置 Environment，加载相关配置等</li>
<li>由 SpringApplicationRunListener 来发出 <strong>contextPrepared</strong> 消息，告知SpringBoot 应用使用的 ApplicationContext 已准备OK</li>
<li>将各种 beans 装载入 ApplicationContext，继续由 SpringApplicationRunListener 来发出 <strong>contextLoaded</strong> 消息，告知 SpringBoot 应用使用的 ApplicationContext 已装填OK</li>
<li>refresh ApplicationContext，完成IoC容器可用的最后一步</li>
<li>由 SpringApplicationRunListener 来发出 <strong>started</strong> 消息</li>
<li>完成最终的程序的启动</li>
<li>由 SpringApplicationRunListener 来发出 <strong>running</strong> 消息，告知程序已运行起来了。</li>
</ol>
<p>根据代码可以分为3个阶段：</p>
<ol>
<li><p>程序主入口main方法调用 <strong>SpringApplication.run</strong> 方法，该方法会创建一个<strong>SpringApplication</strong>对象，用来管理应用程序上下文和启动应用。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@SpringBootApplication</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">XxxApplication</span> </span>&#123;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        SpringApplication.run(XxxApplication.class, args);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> ConfigurableApplicationContext <span class="title">run</span><span class="params">(Class&lt;?&gt;[] primarySources, String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> (<span class="keyword">new</span> SpringApplication(primarySources)).run(args);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure></li>
<li><p>初始化SpringApplication：推断并设置当前的web应用类型；<strong>配置基本的环境变量、资源、构造器、监听器</strong>；根据当前线程的调用栈，推断主应用程序类。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><span class="line">   </span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="title">SpringApplication</span><span class="params">(Class&lt;?&gt;... primarySources)</span> </span>&#123;</span><br><span class="line">       <span class="keyword">this</span>((ResourceLoader)<span class="keyword">null</span>, primarySources);</span><br><span class="line">   &#125;</span><br><span class="line">   </span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">SpringApplication</span><span class="params">(ResourceLoader resourceLoader, Class&lt;?&gt;... primarySources)</span> </span>&#123;</span><br><span class="line">       <span class="keyword">this</span>.sources = <span class="keyword">new</span> LinkedHashSet();</span><br><span class="line">       <span class="keyword">this</span>.bannerMode = Mode.CONSOLE;</span><br><span class="line">       <span class="keyword">this</span>.logStartupInfo = <span class="keyword">true</span>;</span><br><span class="line">       <span class="keyword">this</span>.addCommandLineProperties = <span class="keyword">true</span>;</span><br><span class="line">       <span class="keyword">this</span>.addConversionService = <span class="keyword">true</span>;</span><br><span class="line">       <span class="keyword">this</span>.headless = <span class="keyword">true</span>;</span><br><span class="line">       <span class="keyword">this</span>.registerShutdownHook = <span class="keyword">true</span>;</span><br><span class="line">       <span class="keyword">this</span>.additionalProfiles = <span class="keyword">new</span> HashSet();</span><br><span class="line">       <span class="keyword">this</span>.isCustomEnvironment = <span class="keyword">false</span>;</span><br><span class="line">       <span class="keyword">this</span>.lazyInitialization = <span class="keyword">false</span>;</span><br><span class="line">       <span class="comment">// 资源加载器 NULL</span></span><br><span class="line">       <span class="keyword">this</span>.resourceLoader = resourceLoader;</span><br><span class="line">       Assert.notNull(primarySources, <span class="string">&quot;PrimarySources must not be null&quot;</span>);</span><br><span class="line">       <span class="comment">// 将传入的配置类赋值给primarySources</span></span><br><span class="line">       <span class="keyword">this</span>.primarySources = <span class="keyword">new</span> LinkedHashSet(Arrays.asList(primarySources));</span><br><span class="line">       <span class="comment">// 推测web应用类型（NONE、REACTIVE、SERVLET）</span></span><br><span class="line">       <span class="keyword">this</span>.webApplicationType = WebApplicationType.deduceFromClasspath();</span><br><span class="line">       <span class="comment">// 从spring.factories中获取初始化器、监听器等集合</span></span><br><span class="line">       <span class="keyword">this</span>.setInitializers(<span class="keyword">this</span>.getSpringFactoriesInstances(ApplicationContextInitializer.class));</span><br><span class="line">       <span class="keyword">this</span>.setListeners(<span class="keyword">this</span>.getSpringFactoriesInstances(ApplicationListener.class));</span><br><span class="line">       <span class="comment">// 推断主应用程序类，根据当前线程的调栈判断main()方法在哪个类</span></span><br><span class="line">       <span class="keyword">this</span>.mainApplicationClass = <span class="keyword">this</span>.deduceMainApplicationClass();</span><br><span class="line">   &#125;</span><br><span class="line">   </span><br><span class="line"><span class="comment">// 通过工厂模式获取一组实例集合</span></span><br><span class="line">   <span class="keyword">private</span> &lt;T&gt; <span class="function">Collection&lt;T&gt; <span class="title">getSpringFactoriesInstances</span><span class="params">(Class&lt;T&gt; type)</span> </span>&#123;</span><br><span class="line">       <span class="keyword">return</span> <span class="keyword">this</span>.getSpringFactoriesInstances(type, <span class="keyword">new</span> Class[<span class="number">0</span>]);</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="keyword">private</span> &lt;T&gt; <span class="function">Collection&lt;T&gt; <span class="title">getSpringFactoriesInstances</span><span class="params">(Class&lt;T&gt; type, Class&lt;?&gt;[] parameterTypes, Object... args)</span> </span>&#123;</span><br><span class="line">       ClassLoader classLoader = <span class="keyword">this</span>.getClassLoader();</span><br><span class="line">       <span class="comment">// 通过 SpringFactoriesLoader 从类路径中加载指定类型的工厂名字。SpringFactoriesLoader 是 Spring 框架提供的工具类，用于加载 META-INF/spring.factories 文件中的配置信息。</span></span><br><span class="line">       Set&lt;String&gt; names = <span class="keyword">new</span> LinkedHashSet(SpringFactoriesLoader.loadFactoryNames(type, classLoader));</span><br><span class="line">       <span class="comment">// 根据工厂名字和其他参数创建实例。</span></span><br><span class="line">       List&lt;T&gt; instances = <span class="keyword">this</span>.createSpringFactoriesInstances(type, parameterTypes, classLoader, args, names);</span><br><span class="line">       <span class="comment">// 对实例集合进行排序.排序是根据 @Order 注解的值来进行的。这确保了实例按照指定的顺序执行。</span></span><br><span class="line">       AnnotationAwareOrderComparator.sort(instances);</span><br><span class="line">       <span class="keyword">return</span> instances;</span><br><span class="line">   &#125;</span><br><span class="line"><span class="comment">// 通过配置 SpringApplication 的 initializers 属性，你可以将自定义的初始化器添加到应用中。这是 Spring Boot 提供的一种扩展机制，让开发者可以在 Spring Boot 启动过程中插入自己的逻辑。</span></span><br><span class="line"><span class="comment">// 这些初始化器在 SpringApplication 的 prepareContext 方法中被调用，用于在 ApplicationContext 创建之前对其进行定制。</span></span><br><span class="line"><span class="comment">// 一些典型的用例包括：加载额外的配置。注册额外的 bean 定义。修改 Environment 属性。</span></span><br><span class="line">   <span class="keyword">private</span> List&lt;ApplicationContextInitializer&lt;?&gt;&gt; initializers;</span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setInitializers</span><span class="params">(Collection&lt;? extends ApplicationContextInitializer&lt;?&gt;&gt; initializers)</span> </span>&#123;</span><br><span class="line">       <span class="keyword">this</span>.initializers = <span class="keyword">new</span> ArrayList(initializers);</span><br><span class="line">   &#125;</span><br><span class="line">   </span><br><span class="line">   <span class="keyword">private</span> List&lt;ApplicationListener&lt;?&gt;&gt; listeners;</span><br></pre></td></tr></table></figure></li>
<li><p>运行SpringApplication：过程中分别发送starting、environmentPrepared、contextPrepared和contextLoaded、started、running等事件。</p>
<ul>
<li><code>SpringApplicationRunListeners </code>引用启动监控模块</li>
<li><code>ConfigrableEnvironment</code>配置环境模块和监听：包括<strong>创建配置环境、加载属性配置文件和配置监听</strong></li>
<li><code>ConfigrableApplicationContext</code>配置应用上下文：包括<strong>配置应用上下文对象、配置基本属性和刷新应用上下文</strong></li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> ConfigurableApplicationContext <span class="title">run</span><span class="params">(String... args)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 1.计时器，统计启动耗时</span></span><br><span class="line">    StopWatch stopWatch = <span class="keyword">new</span> StopWatch();</span><br><span class="line">    stopWatch.start();</span><br><span class="line">    <span class="comment">// 2.上下文</span></span><br><span class="line">    ConfigurableApplicationContext context = <span class="keyword">null</span>;</span><br><span class="line">    <span class="comment">// 异常报告集合</span></span><br><span class="line">    Collection&lt;SpringBootExceptionReporter&gt; exceptionReporters = <span class="keyword">new</span> ArrayList();</span><br><span class="line">    <span class="comment">// 设置 java.awt.headless 系统属性</span></span><br><span class="line">    <span class="keyword">this</span>.configureHeadlessProperty();</span><br><span class="line">    <span class="comment">// 3.获取 Spring Boot 运行监听器，getRunListeners通过调用getSpringFactoriesInstances私有协议从META-INF/spring.factories文件中取得SpringApplicationRunListener监听器实例</span></span><br><span class="line">    SpringApplicationRunListeners listeners = <span class="keyword">this</span>.getRunListeners(args);</span><br><span class="line">    <span class="comment">// 发送启动事件，通知监听器 Spring Boot 应用即将启动</span></span><br><span class="line">    listeners.starting();</span><br><span class="line">    <span class="comment">// 当前事件监听器SpringApplicationRunListener中只有一个EventPublishingRunlistener广播事件监听器，它的starting方法会封装成SpringApplicatiionEvent事件广播出去，被SpringApplication中配置的listener监听。这一步骤执行完成后也会同时通知SpringBoot其他模块目前监听初始化已经完成，可以开始执行启动方案了。</span></span><br><span class="line">   </span><br><span class="line">    Collection exceptionReporters;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="comment">// 4.创建应用参数对象</span></span><br><span class="line">        ApplicationArguments applicationArguments = <span class="keyword">new</span> DefaultApplicationArguments(args);</span><br><span class="line">        <span class="comment">// 5.加载环境变量和配置信息，调用 prepareEnvironment 方法，返回配置好的 ConfigurableEnvironment 对象</span></span><br><span class="line">        <span class="comment">// 其中会加载环境配置文件，并发送environmentPrepared事件</span></span><br><span class="line">        ConfigurableEnvironment environment = <span class="keyword">this</span>.prepareEnvironment(listeners, applicationArguments);</span><br><span class="line">        <span class="keyword">this</span>.configureIgnoreBeanInfo(environment);</span><br><span class="line">        Banner printedBanner = <span class="keyword">this</span>.printBanner(environment);</span><br><span class="line">        <span class="comment">// 6.创建应用上下文对象，根据应用类型创建Spring容器，ConfigurableApplicationContext是Spring框架中负责Bean注入容器的主要载体，负责bean加载、配置管理、维护bean之间依赖关系及Bean生命周期管理。</span></span><br><span class="line">        context = <span class="keyword">this</span>.createApplicationContext();</span><br><span class="line">        exceptionReporters = <span class="keyword">this</span>.getSpringFactoriesInstances(SpringBootExceptionReporter.class, <span class="keyword">new</span> Class[]&#123;ConfigurableApplicationContext.class&#125;, context);</span><br><span class="line">        <span class="comment">// 7.准备应用上下文，spring容器启动前的处理。</span></span><br><span class="line">        <span class="comment">// 设置环境、监听器、应用参数等信息，将listener、environment、banner、applicationArguments等重要组件与Spring容器上下文对象关联。发送contextPrepared和contextLoaded事件</span></span><br><span class="line">        <span class="keyword">this</span>.prepareContext(context, environment, listeners, applicationArguments, printedBanner);</span><br><span class="line">        <span class="comment">// 8.刷新应用上下文，启动Spring容器，将通过工程模式产生应用上下文中所需的bean。实现spring-boot-starter-*(mybatis、redis等)自动化配置的关键，包括spring.factories的加载、bean的实例化、启动WebServer等核心工作。</span></span><br><span class="line">        <span class="keyword">this</span>.refreshContext(context);</span><br><span class="line">        <span class="comment">// 9.刷新后的回调，容器启动后的处理。执行一些刷新后的操作，默认为空</span></span><br><span class="line">        <span class="keyword">this</span>.afterRefresh(context, applicationArguments);</span><br><span class="line">        <span class="comment">// 10.计时结束，计算耗时</span></span><br><span class="line">        stopWatch.stop();</span><br><span class="line">        <span class="keyword">if</span> (<span class="keyword">this</span>.logStartupInfo) &#123;</span><br><span class="line">            (<span class="keyword">new</span> StartupInfoLogger(<span class="keyword">this</span>.mainApplicationClass)).logStarted(<span class="keyword">this</span>.getApplicationLog(), stopWatch);</span><br><span class="line">        &#125;</span><br><span class="line">   </span><br><span class="line">        <span class="comment">// 11.发送已启动事件</span></span><br><span class="line">        listeners.started(context);</span><br><span class="line">        <span class="comment">// 12.调用所有 ApplicationRunner 和 CommandLineRunner 接口的实现类的run();</span></span><br><span class="line">        <span class="keyword">this</span>.callRunners(context, applicationArguments);</span><br><span class="line">    &#125; <span class="keyword">catch</span> (Throwable var10) &#123;</span><br><span class="line">        <span class="comment">// 13.发布应用启动失败事件</span></span><br><span class="line">        <span class="keyword">this</span>.handleRunFailure(context, var10, exceptionReporters, listeners);</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> IllegalStateException(var10);</span><br><span class="line">    &#125;</span><br><span class="line">   </span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="comment">// 14.发送运行中事件</span></span><br><span class="line">        listeners.running(context);</span><br><span class="line">        <span class="keyword">return</span> context;</span><br><span class="line">    &#125; <span class="keyword">catch</span> (Throwable var9) &#123;</span><br><span class="line">        <span class="keyword">this</span>.handleRunFailure(context, var9, exceptionReporters, (SpringApplicationRunListeners)<span class="keyword">null</span>);</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> IllegalStateException(var9);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ol>
<p>Spring Boot 的启动流程大致可以分为 <strong>6 个核心步骤</strong>，涉及 <strong>SpringApplication</strong> 的初始化、<code>Environment</code> 配置、<code>ApplicationContext</code> 初始化、Bean 的创建等。</p>
<p><strong>Spring Boot 启动流程</strong></p>
<p>当我们运行一个 Spring Boot 应用时（比如 <code>SpringApplication.run(MainApplication.class, args);</code>），Spring Boot 会经历以下核心步骤：</p>
<p><strong>1. 创建 <code>SpringApplication</code> 对象</strong></p>
<p>Spring Boot 的启动从 <code>SpringApplication</code> 类开始：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">SpringApplication app = <span class="keyword">new</span> SpringApplication(MainApplication.class);</span><br><span class="line">app.run(args);</span><br></pre></td></tr></table></figure>

<p>这一步主要做了：</p>
<ul>
<li><strong>推断应用类型</strong>（<code>WebApplicationType</code>）：判断是 <code>REACTIVE</code>（响应式应用）、<code>SERVLET</code>（普通 Web 应用）还是 <code>NONE</code>（非 Web 应用）。</li>
<li><strong>设置 <code>ApplicationContext</code> 类型</strong>：如果是 Web 应用，使用 <code>AnnotationConfigServletWebServerApplicationContext</code>，否则使用 <code>AnnotationConfigApplicationContext</code>。</li>
<li>**加载 <code>SpringApplicationRunListener</code>**：用于监听 Spring Boot 的生命周期事件。</li>
<li><strong>推断 <code>main</code> 方法的主类</strong>（通常是带 <code>@SpringBootApplication</code> 的类）。</li>
</ul>
<p><strong>2. 运行 <code>SpringApplication#run()</code></strong></p>
<p>在 <code>SpringApplication.run(MainApplication.class, args)</code> 方法中，Spring Boot 进行一系列启动步骤，主要包括：</p>
<p><strong>2.1. 启动 <code>SpringApplicationRunListeners</code></strong></p>
<p>Spring Boot 通过 <code>SpringApplicationRunListeners</code> 监听启动过程，触发 <code>started</code>、<code>running</code> 等事件：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">listeners.starting();</span><br></pre></td></tr></table></figure>

<p>监听器可以通过 <code>META-INF/spring.factories</code> 进行扩展。</p>
<p><strong>2.2. 创建并配置 <code>Environment</code></strong></p>
<p>Spring Boot 创建 <code>ConfigurableEnvironment</code>，用于管理系统属性、环境变量、<code>application.properties</code> 配置：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">ConfigurableEnvironment environment = getOrCreateEnvironment();</span><br><span class="line">configureEnvironment(environment, args);</span><br></pre></td></tr></table></figure>

<p>这里会：</p>
<ul>
<li><strong>加载系统环境变量</strong>（如 <code>System.getenv()</code>）。</li>
<li>**解析 <code>application.properties</code> / <code>application.yml</code>**。</li>
<li><strong>支持 <code>spring.profiles.active</code></strong> 机制。</li>
</ul>
<p><strong>2.3. 创建 <code>ApplicationContext</code></strong></p>
<p>Spring Boot 创建 <strong>Spring 容器（<code>ApplicationContext</code>）</strong>：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">context = createApplicationContext();</span><br></pre></td></tr></table></figure>

<p>不同应用类型有不同的 <code>ApplicationContext</code>：</p>
<ul>
<li><strong>Web 应用</strong>：<code>AnnotationConfigServletWebServerApplicationContext</code></li>
<li><strong>普通应用</strong>：<code>AnnotationConfigApplicationContext</code></li>
<li><strong>响应式应用</strong>：<code>AnnotationConfigReactiveWebServerApplicationContext</code></li>
</ul>
<p><strong>2.4. <code>ApplicationContext</code> 准备</strong></p>
<p>Spring Boot 在 <code>prepareContext()</code> 方法中进行 <code>ApplicationContext</code> 的预处理：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">prepareContext(context, environment, listeners, applicationArguments, printedBanner);</span><br></pre></td></tr></table></figure>

<p>包括：</p>
<ul>
<li><strong>注册 <code>Environment</code></strong> 到 <code>ApplicationContext</code>。</li>
<li>**应用 <code>ApplicationContextInitializer</code>**，用于自定义 <code>ApplicationContext</code> 初始化逻辑。</li>
<li><strong>广播 <code>ApplicationPreparedEvent</code> 事件</strong>，可用于监听 <code>ApplicationContext</code> 初始化完成但未刷新前的操作。</li>
</ul>
<p><strong>2.5. <code>ApplicationContext</code> 刷新</strong></p>
<p>Spring Boot 通过 <code>refreshContext(context)</code> 完成 <code>ApplicationContext</code> 刷新：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">refreshContext(context);</span><br></pre></td></tr></table></figure>

<ul>
<li>解析 <code>@Configuration</code>、<code>@ComponentScan</code> 扫描 Bean。</li>
<li>调用 <code>@Bean</code> 方法创建 Bean。</li>
<li>解析 <code>@Import</code> 和 <code>@ComponentScan</code>。</li>
<li>处理 <code>@PostConstruct</code> 及 <code>InitializingBean</code> 相关生命周期回调。</li>
</ul>
<p><strong>2.6. 执行 <code>ApplicationRunner</code> 和 <code>CommandLineRunner</code></strong></p>
<p>Spring Boot 允许我们在应用启动后执行 <code>ApplicationRunner</code> 和 <code>CommandLineRunner</code>：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">callRunners(context, applicationArguments);</span><br></pre></td></tr></table></figure>

<ul>
<li><code>ApplicationRunner</code> 适用于需要解析 <code>ApplicationArguments</code> 参数的任务。</li>
<li><code>CommandLineRunner</code> 适用于直接处理 <code>String[] args</code> 参数的任务。</li>
</ul>
<p>示例：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyRunner</span> <span class="keyword">implements</span> <span class="title">CommandLineRunner</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">(String... args)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;应用启动完成，执行自定义逻辑...&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>3. Spring Boot 生命周期</strong></p>
<p>Spring Boot 主要的生命周期事件如下：</p>
<table>
<thead>
<tr>
<th><strong>阶段</strong></th>
<th><strong>事件</strong></th>
<th><strong>触发时机</strong></th>
</tr>
</thead>
<tbody><tr>
<td><strong>启动阶段</strong></td>
<td><code>starting()</code></td>
<td>Spring Boot 启动时</td>
</tr>
<tr>
<td><strong>环境准备阶段</strong></td>
<td><code>environmentPrepared()</code></td>
<td><code>Environment</code> 配置完成后</td>
</tr>
<tr>
<td><strong>容器初始化阶段</strong></td>
<td><code>contextPrepared()</code></td>
<td><code>ApplicationContext</code> 创建完成但未刷新</td>
</tr>
<tr>
<td><strong>容器刷新阶段</strong></td>
<td><code>contextLoaded()</code></td>
<td><code>ApplicationContext</code> 加载完成</td>
</tr>
<tr>
<td><strong>应用准备完成</strong></td>
<td><code>started()</code></td>
<td><code>ApplicationContext</code> 刷新完成</td>
</tr>
<tr>
<td><strong>应用运行</strong></td>
<td><code>running()</code></td>
<td>应用启动完成</td>
</tr>
<tr>
<td><strong>应用关闭</strong></td>
<td><code>failed()</code> / <code>closed()</code></td>
<td>发生异常 / 关闭应用</td>
</tr>
</tbody></table>
<p><strong>监听 Spring Boot 事件</strong></p>
<p>我们可以实现 <code>ApplicationListener</code> 监听这些事件：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyApplicationListener</span> <span class="keyword">implements</span> <span class="title">ApplicationListener</span>&lt;<span class="title">ApplicationReadyEvent</span>&gt; </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onApplicationEvent</span><span class="params">(ApplicationReadyEvent event)</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;Spring Boot 应用启动完成！&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>4. Spring Boot <code>SpringApplicationRunListener</code> 监听机制</strong></p>
<p><code>SpringApplicationRunListener</code> 用于监听 Spring Boot 的启动过程，例如：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MySpringApplicationRunListener</span> <span class="keyword">implements</span> <span class="title">SpringApplicationRunListener</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">starting</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;应用开始启动...&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">environmentPrepared</span><span class="params">(ConfigurableEnvironment environment)</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;环境变量准备完成...&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">contextPrepared</span><span class="params">(ConfigurableApplicationContext context)</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;ApplicationContext 创建完成...&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>Spring Boot 通过 <code>META-INF/spring.factories</code> 自动加载这些监听器。</p>
<p><strong>5. Spring Boot 的 <code>Exit</code> 关闭流程</strong></p>
<p>Spring Boot 通过 <code>SpringApplication.exit()</code> 触发应用关闭：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">SpringApplication.exit(context, () -&gt; <span class="number">0</span>);</span><br></pre></td></tr></table></figure>

<ul>
<li>关闭 <code>ApplicationContext</code>，销毁所有 Bean。</li>
<li>触发 <code>ApplicationListener&lt;ContextClosedEvent&gt;</code> 事件。</li>
<li>执行 <code>DisposableBean</code> 和 <code>@PreDestroy</code> 标注的方法。</li>
</ul>
<p><strong>示例：</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@PreDestroy</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">cleanUp</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    System.out.println(<span class="string">&quot;应用即将关闭，执行资源释放...&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>总结</strong></p>
<ol>
<li><strong>创建 <code>SpringApplication</code></strong></li>
<li><strong>配置 <code>Environment</code></strong></li>
<li><strong>创建 <code>ApplicationContext</code></strong></li>
<li><strong>初始化 <code>ApplicationContext</code></strong></li>
<li><strong>刷新 <code>ApplicationContext</code></strong></li>
<li><strong>执行 <code>ApplicationRunner</code> / <code>CommandLineRunner</code></strong></li>
<li><strong>应用启动完成，进入 <code>running</code> 状态</strong></li>
<li><strong>监听应用生命周期，处理 <code>Exit</code> 关闭</strong></li>
</ol>
<p><strong>Spring Boot 通过自动化配置和事件监听机制，极大地简化了应用的启动流程，使得开发者可以快速构建应用并进行扩展。</strong></p>
<h4 id="问：Spring-Boot的核心注解？"><a href="#问：Spring-Boot的核心注解？" class="headerlink" title="问：Spring Boot的核心注解？"></a>问：Spring Boot的核心注解？</h4><p>Spring Boot 的核心注解主要包括：</p>
<ol>
<li><p><strong>@SpringBootApplication：</strong> 该注解是一个复合注解，包含 <code>@Configuration</code>、<code>@EnableAutoConfiguration</code>、<code>@ComponentScan</code>。通常标注在应用的启动类上，用于启动 Spring Boot 应用。</p>
</li>
<li><p><strong>@SpringBootConfiguration：</strong>组合了 @Configuration 注解，实现配置文件的功能。</p>
</li>
<li><p><strong>@Configuration：</strong> 表明该类是一个配置类，类似于 XML 配置文件。</p>
</li>
<li><p><strong>@EnableAutoConfiguration：</strong> 启用 Spring Boot 的自动配置机制，让 Spring Boot 根据项目的依赖添加对应的配置。</p>
</li>
<li><p><strong>@ComponentScan：</strong> 扫描指定包及其子包下的组件，将其注册到 Spring 容器中。通常用于扫描 <code>@Component</code>、<code>@Service</code>、<code>@Repository</code> 等注解标识的类。</p>
</li>
<li><p><strong>@RestController：</strong> 标注在类上，表示该类中的所有方法返回的都是 JSON 格式的数据，等同于 <code>@Controller</code> + <code>@ResponseBody</code>。</p>
</li>
<li><p><strong>@RequestMapping：</strong> 用于映射 HTTP 请求路径，可以标注在类上，表示类中的所有方法的公共路径，也可以标注在方法上，表示单个方法的路径。</p>
</li>
<li><p><strong>@Autowired：</strong> 自动注入依赖对象，可以用于构造器、方法、字段上。Spring Boot 利用它实现了依赖注入。</p>
</li>
<li><p><strong>@Value：</strong> 用于从配置文件中读取值，例如读取 application.properties 中的配置。</p>
</li>
<li><p><strong>@SpringBootTest：</strong> 用于在测试中加载 Spring Boot 的应用上下文，可以进行集成测试。</p>
</li>
<li><p><strong>@ConfigurationProperties：</strong> 用于将配置文件中的属性绑定到 Java 对象上。</p>
</li>
</ol>
<p>这些注解是 Spring Boot 中常用的核心注解，通过它们，可以实现自动配置、依赖注入、路径映射等功能。</p>
<h4 id="问：说说Spring-Boot的条件注解？"><a href="#问：说说Spring-Boot的条件注解？" class="headerlink" title="问：说说Spring Boot的条件注解？"></a>问：说说Spring Boot的条件注解？</h4><p>在Spring Boot中，条件注解是一种基于条件判断的注解，用于根据满足特定条件来决定是否创建或加载一个Bean或配置。<code>@Conditional</code>注解需要实现Condition接口以及其matches方法，它标注在类和方法上，当条件成立时，配置的内容会生效。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Target(&#123;ElementType.TYPE, ElementType.METHOD&#125;)</span></span><br><span class="line"><span class="meta">@Retention(RetentionPolicy.RUNTIME)</span></span><br><span class="line"><span class="meta">@Documented</span></span><br><span class="line"><span class="comment">// 元注解，它标注在类和方法上。主要有一个value()属性，该属性定义了条件的具体实现类，这些实现类必须继承自Condition接口。</span></span><br><span class="line"><span class="keyword">public</span> <span class="meta">@interface</span> Conditional &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * All &#123;<span class="doctag">@link</span> Condition&#125; classes must be checked and all must return true.</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> the conditional classes that must all return true</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    Class&lt;? extends Condition&gt;[] value() <span class="keyword">default</span> &#123;&#125;;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@FunctionalInterface</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Condition</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Determine if the condition matches.</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> context the condition context</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> metadata metadata for the &#123;<span class="doctag">@link</span> org.springframework.core.type.AnnotationMetadata class&#125;</span></span><br><span class="line"><span class="comment">     * or &#123;<span class="doctag">@link</span> org.springframework.core.type.MethodMetadata method&#125; being checked</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> &#123;<span class="doctag">@code</span> true&#125; if the condition matches and the component can be registered,</span></span><br><span class="line"><span class="comment">     * or &#123;<span class="doctag">@code</span> false&#125; to veto the annotated component&#x27;s registration</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">boolean</span> <span class="title">matches</span><span class="params">(ConditionContext context, AnnotatedTypeMetadata metadata)</span></span>;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p>Spring Boot提供了一系列条件注解，主要使用在<code>@Conditional</code>注解之下，以实现在不同条件下的Bean或配置的动态加载。</p>
<p>以下是一些常见的Spring Boot条件注解：</p>
<ol>
<li><strong>@ConditionalOnClass：</strong>是否存在某个类<ul>
<li>该注解用于在类路径中存在指定的类时，创建或加载Bean。例如：<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="meta">@ConditionalOnClass(name = &quot;com.example.SomeClass&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyConfiguration</span> </span>&#123;</span><br><span class="line">    <span class="comment">// Bean definitions go here</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
</li>
<li><strong>@ConditionalOnMissingClass：</strong>是否缺少某个类<ul>
<li>与<code>@ConditionalOnClass</code>相反，用于在类路径中不存在指定的类时，创建或加载Bean。</li>
</ul>
</li>
<li><strong>@ConditionalOnBean：</strong>Spring容器是否存在某个类型或名字的Bean<ul>
<li>在容器中存在指定的Bean时，创建或加载当前Bean。例如：<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="meta">@ConditionalOnBean(name = &quot;myBean&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyConfiguration</span> </span>&#123;</span><br><span class="line">    <span class="comment">// Bean definitions go here</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
</li>
<li><strong>@ConditionalOnMissingBean：</strong>Spring容器是否缺少某个类型或名字的Bean<ul>
<li>与<code>@ConditionalOnBean</code>相反，用于在容器中不存在指定的Bean时，创建或加载当前Bean。</li>
</ul>
</li>
<li><strong>@ConditionalOnProperty：</strong>判断Environment环境变量中是否存在某个属性<ul>
<li>根据配置文件中的属性值来判断是否创建或加载Bean。例如：<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="meta">@ConditionalOnProperty(name = &quot;myapp.feature.enabled&quot;, havingValue = &quot;true&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyConfiguration</span> </span>&#123;</span><br><span class="line">    <span class="comment">// Bean definitions go here</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
</li>
<li><strong>@ConditionalOnExpression：</strong>指定的表达式返回的是true还是false<ul>
<li>基于SpEL表达式的条件判断，满足表达式时创建或加载Bean。</li>
</ul>
</li>
<li><strong>@ConditionalOnWebApplication：</strong>判断当前应用是不是一个Web应用<ul>
<li>在Web应用程序环境中才会创建或加载Bean。可选的参数<code>type</code>可以指定Web应用程序的类型，如<code>Type.SERVLET</code>或<code>Type.REACTIVE</code>。</li>
</ul>
</li>
<li><strong>@ConditionalOnResource：</strong><ul>
<li>当类路径中存在指定的资源文件时，创建或加载Bean。</li>
</ul>
</li>
</ol>
<p>这些条件注解允许根据应用程序的上下文、环境或配置动态地调整Bean的加载。在实际的应用中，可以根据具体的需求选择合适的条件注解进行使用。</p>
<h4 id="问：SpringBoot常用starter都有哪些？如何自定义starter？⭐"><a href="#问：SpringBoot常用starter都有哪些？如何自定义starter？⭐" class="headerlink" title="问：SpringBoot常用starter都有哪些？如何自定义starter？⭐"></a>问：SpringBoot常用starter都有哪些？如何自定义starter？⭐</h4><ol>
<li><strong>spring-boot-starter-web：</strong> 用于构建 Web 应用程序，包括 RESTful、Spring MVC 等。</li>
<li><strong>spring-boot-starter-data-jpa：</strong> 提供了 JPA 数据库支持。</li>
<li><strong>spring-boot-starter-data-redis：</strong> 集成了 Redis 缓存支持。</li>
<li><strong>spring-boot-starter-data-mongodb：</strong> 提供了 MongoDB 数据库支持。</li>
<li><strong>spring-boot-starter-data-rest：</strong>使用 Spring Data REST 公布简单的 REST 服务</li>
<li><strong>spring-boot-starter-security：</strong> 集成了 Spring Security，用于处理应用程序的安全性需求。</li>
<li><strong>spring-boot-starter-test：</strong> 包含了常用的测试依赖，例如 JUnit、TestNG 等。</li>
<li><strong>spring-boot-starter-log4j2：</strong> 集成了 Log4j2，用于日志记录。</li>
<li><strong>spring-boot-starter-logging：</strong> 集成了 Spring Boot 默认的日志框架。</li>
<li><strong>spring-boot-starter-thymeleaf：</strong> 集成了 Thymeleaf 模板引擎，用于构建视图。</li>
<li><strong>spring-boot-starter-cache：</strong> 集成了 Spring Cache，用于添加缓存支持。</li>
<li><strong>spring-boot-starter-mail：</strong> 提供了邮件发送的支持。</li>
<li><strong>spring-boot-starter-actuator：</strong> 集成了 Spring Boot Actuator，用于监控和管理应用程序。</li>
<li><strong>spring-boot-starter-tomcat：</strong> 嵌入式 Tomcat 的支持。</li>
<li><strong>spring-boot-starter-jdbc：</strong> 提供了 JDBC 数据库支持。</li>
</ol>
<p>命名规范：</p>
<ul>
<li>官方：spring-boot-starter-*</li>
<li>第三方：*-spring-boot-starter</li>
</ul>
<ul>
<li>使用两个模块分别来开发：<ul>
<li>starter：空项目，用来辅助依赖管理，包括自动配置类和其它类库</li>
<li>autoconfigure：用来开发自动配置类、声明配置文件消息等</li>
</ul>
</li>
<li>步骤：<ol>
<li>创建空的Maven项目作为父项目：springboot_starter</li>
<li>新建模块命名为xx-spring-boot-starter，注意模块为空</li>
<li>新建模块命名为xx-spring-boot-starter-autoconfigurer</li>
<li>模块2下新建XxProperties类，使用@ConfigurationProperties声明，其作用为声明一个配置文件</li>
<li>模块2下新建XxService类，该类注入了XxProperties对象，并定义一个getXx()方法</li>
<li>模块2下新建XxAutoConfiguration自动配置类，使用@EnableAutoConfiguration将其加入到Spring容器，另外在类中声明一个XxService的Bean</li>
<li>添加自动配置类的全限定名到文件中，若使用的SpringBoot版本低于2.7，则要在spring.factories文件下添加配置项；若高于2.7，则在AutoConfiguration.imports文件中添加内容。</li>
<li>执行Maven的install命令进行两个模块的安装</li>
<li>在新的项目中进行测试：引入依赖、在application.properties中配置、调用接口测试。</li>
</ol>
</li>
</ul>
<p><strong>如何自定义一个 Spring Boot Starter？</strong></p>
<p>假设我们要封装 <strong>Redis 组件</strong>，创建一个 <code>my-starter-redis</code>：</p>
<p><strong>(1) 创建 <code>my-starter-redis</code> 模块</strong></p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>com.example<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>my-starter-redis<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>1.0.0<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p><strong>(2) 提供自动配置类</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="meta">@ConditionalOnClass(RedisTemplate.class)</span>  <span class="comment">// 只有 Redis 依赖存在时才启用</span></span><br><span class="line"><span class="meta">@EnableConfigurationProperties(RedisProperties.class)</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">RedisAutoConfiguration</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="meta">@ConditionalOnMissingBean</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> RedisTemplate&lt;String, Object&gt; <span class="title">redisTemplate</span><span class="params">(RedisConnectionFactory factory)</span> </span>&#123;</span><br><span class="line">        RedisTemplate&lt;String, Object&gt; template = <span class="keyword">new</span> RedisTemplate&lt;&gt;();</span><br><span class="line">        template.setConnectionFactory(factory);</span><br><span class="line">        <span class="keyword">return</span> template;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>(3) 配置 <code>META-INF/spring.factories</code></strong></p>
<figure class="highlight properties"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">org.springframework.boot.autoconfigure.EnableAutoConfiguration</span>=<span class="string">\</span></span><br><span class="line"><span class="string">com.example.mystarter.redis.RedisAutoConfiguration</span></span><br></pre></td></tr></table></figure>

<p>这样 <strong>只需引入 <code>my-starter-redis</code> 依赖，就能自动配置 Redis</strong> 🎉。</p>
<h4 id="问：SpringBootStarter如何理解？⭐"><a href="#问：SpringBootStarter如何理解？⭐" class="headerlink" title="问：SpringBootStarter如何理解？⭐"></a>问：SpringBootStarter如何理解？⭐</h4><p>Spring Boot Starter 是 <strong>一组预定义的依赖集合</strong>，用于 <strong>简化项目的依赖管理</strong> 和 <strong>自动配置</strong>。<br>本质上，它是一个 <strong>Maven 或 Gradle 依赖</strong>，封装了 <strong>一组常用的 Spring 组件及其依赖</strong>。</p>
<p>如**<code>spring-boot-starter-web</code>** 内部封装了 <strong>Spring MVC、Tomcat、Jackson 等依赖</strong>，开发者只需要引入这个 Starter，即可使用 Web 相关功能，而不需要手动管理多个依赖。</p>
<table>
<thead>
<tr>
<th><strong>作用</strong></th>
<th><strong>描述</strong></th>
</tr>
</thead>
<tbody><tr>
<td><strong>封装常用依赖</strong></td>
<td>通过 Starter 一次性引入多个相关依赖，避免版本冲突。</td>
</tr>
<tr>
<td><strong>提供默认配置</strong></td>
<td>结合 Spring Boot 自动配置（<code>@EnableAutoConfiguration</code>），让开发者无需手动配置。</td>
</tr>
<tr>
<td><strong>提升开发效率</strong></td>
<td>开发者只需引入 Starter，即可使用相关功能，降低学习成本。</td>
</tr>
<tr>
<td><strong>统一维护版本</strong></td>
<td>Starter 通过 <code>spring-boot-dependencies</code> 统一管理版本，防止 JAR 版本不兼容问题。</td>
</tr>
<tr>
<td><strong>增强可扩展性</strong></td>
<td>可以自定义 Starter，封装企业级组件，提高代码复用率。</td>
</tr>
</tbody></table>
<h4 id="问：Spring-Boot常用配置方式？配置优先级？"><a href="#问：Spring-Boot常用配置方式？配置优先级？" class="headerlink" title="问：Spring Boot常用配置方式？配置优先级？"></a>问：Spring Boot常用配置方式？配置优先级？</h4><p>优先级由高到低：</p>
<ol>
<li><strong>命令行参数（Command Line Arguments）：</strong><ul>
<li>通过命令行传递的参数具有最高的优先级。可以通过<code>--</code>前缀和<code>=</code>符号来设置属性，例如：<code>--server.port=8080</code>。</li>
</ul>
</li>
<li><strong>Java系统属性（Java System Properties）/JVM环境变量：</strong><ul>
<li>通过在启动应用程序时使用<code>-D</code>参数设置的Java系统属性。例如：<code>-Dserver.port=8080</code>。</li>
</ul>
</li>
<li><strong>操作系统环境变量（OS Environment Variables）：</strong><ul>
<li>可以通过操作系统的环境变量来设置配置属性。环境变量的命名规则通常是全大写，使用下划线作为分隔符，例如：<code>SERVER_PORT=8080</code>。</li>
</ul>
</li>
<li><strong>配置文件（Application Properties或YAML Files）：</strong><ul>
<li><code>application.properties</code> 或 <code>application.yml</code> 文件中的配置。这些文件可以位于类路径下的<code>/config</code>目录中，或者在项目根目录中。同时，可以使用<code>spring.config.name</code>和<code>spring.config.location</code>属性指定自定义的配置文件名和位置。</li>
</ul>
</li>
<li><strong>默认值（Default Values）：</strong><ul>
<li>Spring Boot提供了一组默认的配置属性，可以在没有显式设置的情况下作为默认值使用。这些默认值通常在Spring Boot的各个模块中定义。</li>
</ul>
</li>
</ol>
<h4 id="问：SpringBoot自动配置的原理？⭐⭐⭐"><a href="#问：SpringBoot自动配置的原理？⭐⭐⭐" class="headerlink" title="问：SpringBoot自动配置的原理？⭐⭐⭐"></a>问：SpringBoot自动配置的原理？⭐⭐⭐</h4><p>什么是自动配置？</p>
<ul>
<li>在项目启动时，根据项目的依赖和配置，Spring Boot会自动地对项目进行一系列的配置，以简化开发者的工作。</li>
<li>使Spring Boot 应用可以 <strong>零配置</strong> 地启动所需组件。</li>
</ul>
<p>如何实现的自动配置？</p>
<ul>
<li>是 <strong>基于条件注解</strong> + <strong>SpringFactoriesLoader</strong> 机制实现的，spring-boot-autoconfigure包提供了大量的自动配置类。SPI机制。<ul>
<li>SPI（Service Provider Interface）是Java提供的一种服务发现机制。允许 <strong>在运行时动态加载实现类</strong>，而不需要硬编码。<strong>采用 <code>SpringFactoriesLoader</code> 作为 SPI 实现</strong>，读取 <code>spring.factories</code> 来加载自动配置类。</li>
</ul>
</li>
<li>Spring Boot 启动时，<code>@SpringBootApplication</code> 这个注解包含了 <code>@EnableAutoConfiguration</code>，它的作用是 <strong>开启自动配置</strong>，会触发 <code>AutoConfigurationImportSelector</code>，找到所有的自动配置类。</li>
<li>Spring Boot 通过 <code>SpringFactoriesLoader</code> 机制，从 <code>spring-boot-autoconfigure.jar</code> 包中的 <code>META-INF/spring.factories</code> 读取自动配置类。</li>
<li>自动配置并不是全部启用，而是通过 <strong>条件注解</strong> 控制：<code>@ConditionalOnXXX</code> 条件注解。<ul>
<li><code>@ConditionalOnClass</code>：类路径下是否存在某个类（如 <code>DataSource.class</code>）。</li>
<li><code>@ConditionalOnMissingBean</code>：容器中是否已经存在某个 Bean。</li>
<li><code>@ConditionalOnProperty</code>：是否配置了某个 <code>properties</code> 选项。</li>
</ul>
</li>
<li>如果符合条件，则自动注册 <code>@Bean</code>，如 <code>DataSourceAutoConfiguration</code> 注册数据库连接池。</li>
</ul>
<p>详细概述：</p>
<ol>
<li><p>SpringBoot的main方法通过调用SpringApplication.run(Application.class, args)来启动应用，第一个参数需要是一个使用@SpringBootApplication注解声明的类。@SpringBootApplication是一个复合注解，包含 <code>@Configuration</code>、<code>@EnableAutoConfiguration</code>、<code>@ComponentScan</code>。其中**@EnableAutoConfiguration实现了自动配置**。导入到AutoConfigurationImportSelector类。</p>
</li>
<li><p><code>@EnableAutoConfiguration</code> 注解是核心，它可以根据项目的依赖和配置自动配置 Spring 应用程序。</p>
</li>
<li><p>@EnableAutoConfiguration找到META-INF/spring.factories（需要创建的bean在里面）配置文件，读取每个starter中的spring.factories文件。</p>
</li>
<li><p>AutoConfigurationImportSelector实现了DeferredImportSelector接口的getImportGroup()方法，所以其不会直接调用selectImports()，而是依次调用其静态内部类的AutoConfigurationGroup.process()以及AutoConfigurationGroup.selectImports()。</p>
</li>
<li><p><strong>获取候选的自动配置类</strong>：AutoConfigurationImportSelector.getAutoConfigurationEntry()，早期版本通过SpringFactoriesLoader.loadFactoryNames()方法来读取 <code>spring.factories</code> 文件并匹配key为org.springframework.boot.qutoconfigure.EnableAutoConfiguration的值；2.7以后会直接一行行的读取classpath:/META-INF/spring/org.springframework.boot.qutoconfigure.AutoConfiguration.imports文件，其保存的就是所有的自动配置类。</p>
</li>
<li><p><strong>筛选项目需要的自动配置类</strong>：将获取到的自动配置类进行去重、排除等操作，进行关键的过滤操作。过滤的核心思想是通过@ConditionalOnClass、@ConditionalOnProperty等注解完成，判断项目中是否存在自动配置类指定的某些关键的类或特定的属性，若不存在就会被过滤掉。</p>
</li>
<li><p><strong>导入筛选到的自动配置类到Spring容器</strong>：自动配置类中的Bean能否被注册还要看Bean的条件注解是否满足。</p>
</li>
<li><p>Spring Boot 的自动配置是通过<strong>条件化的注解</strong>和<strong>条件匹配器</strong>实现的。</p>
</li>
</ol>
<p>自动配置的原理主要包括：</p>
<ol>
<li><p><strong>SpringFactoriesLoader：</strong> Spring Boot 使用 <code>spring.factories</code> 文件定义了各种自动配置的类。这个文件通常位于项目的 <code>META-INF</code> 目录下。在该文件中，使用全限定名定义了一系列自动配置类。</p>
</li>
<li><p><strong>EnableAutoConfiguration注解：</strong> 在主配置类上使用了 <code>@EnableAutoConfiguration</code> 注解，它会从 <code>spring.factories</code> 文件中加载一系列配置类，这些配置类将被注册到 Spring 容器中。</p>
</li>
<li><p><strong>条件化注解：</strong> 自动配置类上使用了多个条件化注解，例如 <code>@ConditionalOnClass</code>、<code>@ConditionalOnMissingBean</code> 等。这些注解用于根据条件判断是否应该应用该自动配置。条件判断由条件匹配器（ConditionEvaluator）完成。</p>
</li>
<li><p><strong>条件匹配器：</strong> 条件匹配器会检查项目的 classpath、配置、系统属性等，判断是否满足条件。如果满足条件，则相应的自动配置类将被注册到 Spring 容器中。</p>
</li>
<li><p><strong>自动配置的顺序：</strong> 在 <code>spring.factories</code> 文件中，每个自动配置类的条目都有一个优先级。Spring Boot 根据这个优先级来确定自动配置的顺序。较低优先级的配置类将在较高优先级的配置类之后被注册。</p>
</li>
</ol>
<h4 id="问：SpringBoot的自动配置流程？"><a href="#问：SpringBoot的自动配置流程？" class="headerlink" title="问：SpringBoot的自动配置流程？"></a>问：SpringBoot的自动配置流程？</h4><p>Spring Boot 的自动配置流程主要包括以下几个步骤：</p>
<ol>
<li><p><strong>SpringFactoriesLoader 加载配置类：</strong> Spring Boot 使用 <code>SpringFactoriesLoader</code> 机制加载 <code>spring.factories</code> 文件，该文件中定义了各种自动配置类的全限定名。这个文件通常位于项目的 <code>META-INF</code> 目录下。</p>
</li>
<li><p><strong>EnableAutoConfiguration 注解：</strong> 在主配置类上使用了 <code>@EnableAutoConfiguration</code> 注解，该注解会触发 Spring Boot 的自动配置机制。它将加载 <code>spring.factories</code> 中配置的自动配置类。</p>
</li>
<li><p><strong>条件化注解判断是否生效：</strong> 自动配置类上通常使用了条件化注解，例如 <code>@ConditionalOnClass</code>、<code>@ConditionalOnMissingBean</code> 等。这些注解根据条件判断是否应该应用该自动配置。条件判断由条件匹配器（<code>ConditionEvaluator</code>）完成。</p>
</li>
<li><p><strong>条件匹配器判断是否满足条件：</strong> 条件匹配器会检查项目的 classpath、配置、系统属性等，判断是否满足条件。如果满足条件，则相应的自动配置类将被注册到 Spring 容器中。</p>
</li>
<li><p><strong>自动配置的执行：</strong> 自动配置类中通常包含了一系列的 Bean 定义和配置。这些配置会在 Spring 容器初始化的过程中生效。</p>
</li>
<li><p><strong>自动配置的顺序：</strong> 在 <code>spring.factories</code> 文件中，每个自动配置类的条目都有一个优先级。Spring Boot 根据这个优先级来确定自动配置的顺序。较低优先级的配置类将在较高优先级的配置类之后被注册。</p>
</li>
</ol>
<h4 id="问：SpringBoot把对象注入容器的几种方法？"><a href="#问：SpringBoot把对象注入容器的几种方法？" class="headerlink" title="问：SpringBoot把对象注入容器的几种方法？"></a>问：SpringBoot把对象注入容器的几种方法？</h4><ul>
<li>通过注解注入：**@Configuration** + <strong>@Bean</strong> + <strong>new Object()</strong></li>
<li>通过构造方法注入：**@Component** + <strong>@Autowired</strong> + <strong>构造器</strong><ul>
<li>@Controller / @Service / @Repository / @ComponentScan 都是细化的 @Component</li>
</ul>
</li>
<li>通过set方法注入：**@Component** + <strong>@Autowired</strong> + <strong>set()</strong></li>
<li>通过属性注入：**@Autowired** + <strong>private Object obj</strong></li>
</ul>
<p>在 Spring Boot 中，将对象注入容器的主要方式是使用 <code>@Component</code> 及其衍生注解，以及使用 <code>@Bean</code> 注解。</p>
<p>以下是几种常见的注入方式：</p>
<ol>
<li><p><strong>使用 <code>@Component</code> 注解：</strong> <code>@Component</code> 注解用于标识一个类为 Spring Bean，并由 Spring 容器进行管理。其他衍生注解如 <code>@Service</code>、<code>@Repository</code>、<code>@Controller</code> 都是基于 <code>@Component</code> 的特化，用于表示不同层次的组件。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyComponent</span> </span>&#123;</span><br><span class="line">    <span class="comment">// Class implementation</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li><p><strong>使用 <code>@Bean</code> 注解：</strong> <code>@Bean</code> 注解用于在配置类中声明一个 Bean。该注解通常与 <code>@Configuration</code> 注解一起使用。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">AppConfig</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> MyComponent <span class="title">myComponent</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> MyComponent();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li><p><strong>使用 <code>@Autowired</code> 注解：</strong> <code>@Autowired</code> 用于在需要注入的地方标注，Spring 容器会自动将符合类型的 Bean 注入进来。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Service</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyService</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> MyComponent myComponent;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li><p><strong>使用构造器注入：</strong> 在类的构造器上使用 <code>@Autowired</code> 注解，Spring 容器会尝试将匹配类型的 Bean 注入到构造器中。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Service</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyService</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> MyComponent myComponent;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">MyService</span><span class="params">(MyComponent myComponent)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.myComponent = myComponent;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ol>
<p>这些方式可以根据具体情况和项目需求选择使用，它们都能够实现对象的注入和管理。</p>
<h4 id="问：假如现在在一个类了要引用到几十个Bean，难道要在类里声明这些bean然后加注解吗，有没有更好的做法？"><a href="#问：假如现在在一个类了要引用到几十个Bean，难道要在类里声明这些bean然后加注解吗，有没有更好的做法？" class="headerlink" title="问：假如现在在一个类了要引用到几十个Bean，难道要在类里声明这些bean然后加注解吗，有没有更好的做法？"></a>问：假如现在在一个类了要引用到几十个Bean，难道要在类里声明这些bean然后加注解吗，有没有更好的做法？</h4><ol>
<li><strong>使用<code>@Configuration</code>类集中管理Bean</strong></li>
</ol>
<p>将相关Bean集中在一个配置类中，通过<code>@Bean</code>方法定义，然后在需要的地方注入整个配置类。</p>
<figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyBeansConfig</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="keyword">public</span> MyBean1 <span class="function"><span class="title">myBean1</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> MyBean1();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="keyword">public</span> MyBean2 <span class="function"><span class="title">myBean2</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> MyBean2();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 其他Bean定义</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Service</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyService</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> final MyBeansConfig myBeansConfig;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">public</span> <span class="function"><span class="title">MyService</span>(<span class="params">MyBeansConfig myBeansConfig</span>)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.myBeansConfig = myBeansConfig;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="built_in">void</span> <span class="function"><span class="title">someMethod</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">        MyBean1 bean1 = myBeansConfig.myBean1();</span><br><span class="line">        MyBean2 bean2 = myBeansConfig.myBean2();</span><br><span class="line">        <span class="comment">// 使用Bean</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ol start="2">
<li><strong>使用<code>@Qualifier</code>和<code>@Autowired</code>按类型或名称注入</strong></li>
</ol>
<p>如果Bean有特定类型或名称，可以通过<code>@Qualifier</code>和<code>@Autowired</code>按需注入。</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Service</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyService</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> MyBean1 myBean1;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> MyBean2 myBean2;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">public</span> MyService(<span class="meta">@Qualifier(<span class="meta-string">&quot;myBean1&quot;</span>)</span> MyBean1 myBean1, </span><br><span class="line">                     <span class="meta">@Qualifier(<span class="meta-string">&quot;myBean2&quot;</span>)</span> MyBean2 myBean2) &#123;</span><br><span class="line">        <span class="keyword">this</span>.myBean1 = myBean1;</span><br><span class="line">        <span class="keyword">this</span>.myBean2 = myBean2;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ol start="3">
<li><strong>使用<code>@ComponentScan</code>自动扫描Bean</strong></li>
</ol>
<p>通过<code>@ComponentScan</code>自动扫描并注册Bean，减少手动配置。</p>
<figure class="highlight less"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable">@SpringBootApplication</span></span><br><span class="line"><span class="variable">@ComponentScan</span>(basePackages = &#123;<span class="string">&quot;com.example&quot;</span>&#125;)</span><br><span class="line">public class MyApp &#123;</span><br><span class="line">    <span class="selector-tag">public</span> <span class="selector-tag">static</span> <span class="selector-tag">void</span> <span class="selector-tag">main</span>(String[] args) &#123;</span><br><span class="line">        <span class="selector-tag">SpringApplication</span><span class="selector-class">.run</span>(MyApp.class, args);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ol start="4">
<li><strong>使用<code>@Autowired</code>注入集合</strong></li>
</ol>
<p>如果需要注入多个相同类型的Bean，可以直接注入集合。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Service</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyService</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> List&lt;MyBeanInterface&gt; myBeans;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">MyService</span><span class="params">(List&lt;MyBeanInterface&gt; myBeans)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.myBeans = myBeans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ol start="5">
<li><strong>使用<code>@Resource</code>按名称注入</strong></li>
</ol>
<p><code>@Resource</code>可以按名称注入Bean，适合需要特定Bean的场景。</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Service</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyService</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Resource(name = <span class="meta-string">&quot;myBean1&quot;</span>)</span></span><br><span class="line">    <span class="keyword">private</span> MyBean1 myBean1;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Resource(name = <span class="meta-string">&quot;myBean2&quot;</span>)</span></span><br><span class="line">    <span class="keyword">private</span> MyBean2 myBean2;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ol start="6">
<li><strong>使用<code>ApplicationContext</code>动态获取Bean</strong></li>
</ol>
<p>通过<code>ApplicationContext</code>动态获取Bean，避免在类中声明大量依赖。</p>
<figure class="highlight d"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">@Service</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> MyService &#123;</span><br><span class="line">    <span class="keyword">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> ApplicationContext applicationContext;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> someMethod() &#123;</span><br><span class="line">        MyBean1 bean1 = applicationContext.getBean(MyBean1.<span class="keyword">class</span>);</span><br><span class="line">        MyBean2 bean2 = applicationContext.getBean(MyBean2.<span class="keyword">class</span>);</span><br><span class="line">        <span class="comment">// 使用Bean</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ol start="7">
<li><strong>重构设计</strong></li>
</ol>
<p>如果类依赖过多Bean，可能是设计问题，考虑将功能拆分到多个类中，或使用设计模式如<strong>策略模式</strong>、<strong>工厂模式</strong>等。</p>
<p>总结</p>
<ul>
<li><strong>集中管理</strong>：使用<code>@Configuration</code>类集中管理Bean。</li>
<li><strong>按需注入</strong>：通过<code>@Qualifier</code>、<code>@Resource</code>或<code>@Autowired</code>按需注入。</li>
<li><strong>自动扫描</strong>：使用<code>@ComponentScan</code>减少手动配置。</li>
<li><strong>动态获取</strong>：通过<code>ApplicationContext</code>动态获取Bean。</li>
<li><strong>重构设计</strong>：考虑拆分功能或使用设计模式优化。</li>
</ul>
<h4 id=""><a href="#" class="headerlink" title=""></a></h4>
    </div>

    
    
    

    <footer class="post-footer">
          

<div class="post-copyright">
<ul>
  <li class="post-copyright-author">
      <strong>本文作者： </strong>Lys
  </li>
  <li class="post-copyright-link">
      <strong>本文链接：</strong>
      <a href="http://linyishui.top/2019110101.html" title="面试整理——Spring、SpringMVC和Spring Boot">http://linyishui.top/2019110101.html</a>
  </li>
  <li class="post-copyright-license">
    <strong>版权声明： </strong>本博客所有文章除特别声明外，均采用 <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/deed.zh" rel="noopener" target="_blank"><i class="fab fa-fw fa-creative-commons"></i>BY-NC-SA</a> 许可协议。转载请注明出处！
  </li>
</ul>
</div>

          <div class="post-tags">
              <a href="/tags/Q-A/" rel="tag"><i class="fa fa-tag"></i> Q&A</a>
              <a href="/tags/updating/" rel="tag"><i class="fa fa-tag"></i> updating</a>
          </div>

        

          <div class="post-nav">
            <div class="post-nav-item">
                <a href="/2019102901.html" rel="prev" title="面试整理——数据库">
                  <i class="fa fa-chevron-left"></i> 面试整理——数据库
                </a>
            </div>
            <div class="post-nav-item">
                <a href="/2019110201.html" rel="next" title="死亡会是解脱吗">
                  死亡会是解脱吗 <i class="fa fa-chevron-right"></i>
                </a>
            </div>
          </div>
    </footer>
  </article>
</div>






    <div class="comments utterances-container"></div>
</div>
  </main>

  <footer class="footer">
    <div class="footer-inner">


<div class="copyright">
  &copy; 2018 – 
  <span itemprop="copyrightYear">2025</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">Lys</span>
</div>
<div class="wordcount">
  <span class="post-meta-item">
    <span class="post-meta-item-icon">
      <i class="fa fa-chart-line"></i>
    </span>
      <span>站点总字数：</span>
    <span title="站点总字数">5.4m</span>
  </span>
  <span class="post-meta-item">
    <span class="post-meta-item-icon">
      <i class="fa fa-coffee"></i>
    </span>
      <span>站点阅读时长 &asymp;</span>
    <span title="站点阅读时长">82:05</span>
  </span>
</div>
  <div class="powered-by">由 <a href="https://hexo.io/" rel="noopener" target="_blank">Hexo</a> & <a href="https://theme-next.js.org/pisces/" rel="noopener" target="_blank">NexT.Pisces</a> 强力驱动
  </div>

    </div>
  </footer>

  
  <script src="https://cdn.jsdelivr.net/npm/animejs@3.2.1/lib/anime.min.js" integrity="sha256-XL2inqUJaslATFnHdJOi9GfQ60on8Wx1C2H8DYiN1xY=" crossorigin="anonymous"></script>
  <script src="https://cdn.jsdelivr.net/npm/jquery@3.6.0/dist/jquery.min.js" integrity="sha256-/xUj+3OJU5yExlq6GSYGSHk7tPXikynS7ogEvDej/m4=" crossorigin="anonymous"></script>
  <script src="https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@3.5.7/dist/jquery.fancybox.min.js" integrity="sha256-yt2kYMy0w8AbtF89WXb2P1rfjcP/HTHLT7097U8Y5b8=" crossorigin="anonymous"></script>
<script src="/js/comments.js"></script><script src="/js/utils.js"></script><script src="/js/motion.js"></script><script src="/js/next-boot.js"></script><script src="/js/bookmark.js"></script>

  
<script src="/js/third-party/search/local-search.js"></script>



  <script class="next-config" data-name="nprogress" type="application/json">{"enable":true,"spinner":true}</script>
  <script src="/js/third-party/nprogress.js"></script>

  




<script src="https://cdn.jsdelivr.net/npm/darkmode-js@1.5.7/lib/darkmode-js.min.js"></script>

<script>
var options = {
  bottom: '64px',
  right: '32px',
  left: 'unset',
  time: '0.5s',
  mixColor: 'transparent',
  backgroundColor: 'transparent',
  buttonColorDark: '#100f2c',
  buttonColorLight: '#fff',
  saveInCookies: true,
  label: '🌓',
  autoMatchOsTheme: true
}
const darkmode = new Darkmode(options);
window.darkmode = darkmode;
darkmode.showWidget();
</script>
<script class="next-config" data-name="utterances" type="application/json">{"enable":true,"repo":"LAILAIWA/LAILAIWA.github.io","issue_term":"pathname","theme":"github-light"}</script>
<script src="/js/third-party/comments/utterances.js"></script>



</body>
</html>
