<!DOCTYPE html>



  


<html class="theme-next pisces use-motion" lang="zh-Hans">
<head>
  <meta charset="UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=edge" />
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"/>
<meta name="theme-color" content="#222">



  
  
    
    
  <script src="/lib/pace/pace.min.js?v=1.0.2"></script>
  <link href="/lib/pace/pace-theme-minimal.min.css?v=1.0.2" rel="stylesheet">







<meta http-equiv="Cache-Control" content="no-transform" />
<meta http-equiv="Cache-Control" content="no-siteapp" />
















  
  
  <link href="/lib/fancybox/source/jquery.fancybox.css?v=2.1.5" rel="stylesheet" type="text/css" />







<link href="/lib/font-awesome/css/font-awesome.min.css?v=4.6.2" rel="stylesheet" type="text/css" />

<link href="/css/main.css?v=5.1.4" rel="stylesheet" type="text/css" />


  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png?v=5.1.4">


  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon.ico?v=5.1.4">


  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png?v=5.1.4">


  <link rel="mask-icon" href="/images/logo.svg?v=5.1.4" color="#222">





  <meta name="keywords" content="algorithm," />





  <link rel="alternate" href="/atom.xml" title="沂水博客" type="application/atom+xml" />






<meta name="description" content="算法复习 (二) 查找-平衡查找树，主要内容包括：2-3查找树（查找、向2-结点中插入新键、向一棵只含有一个3-结点的树中插入新键、向一个父结点为2-结点的3-结点中插入新键、向一个父结点为3-结点的3-结点中插入新键、分解根结点、局部变换、全局性质、性能分析），红黑查找树（替换3-结点、一种等价的定义、一一对应、颜色表示、旋转、在旋转后重置父结点的链接、向单个2-结点中插入新键、向树底部的2-结">
<meta name="keywords" content="algorithm">
<meta property="og:type" content="article">
<meta property="og:title" content="算法复习 (二) 查找-平衡查找树">
<meta property="og:url" content="http://linyishui.top/2019110801.html">
<meta property="og:site_name" content="沂水博客">
<meta property="og:description" content="算法复习 (二) 查找-平衡查找树，主要内容包括：2-3查找树（查找、向2-结点中插入新键、向一棵只含有一个3-结点的树中插入新键、向一个父结点为2-结点的3-结点中插入新键、向一个父结点为3-结点的3-结点中插入新键、分解根结点、局部变换、全局性质、性能分析），红黑查找树（替换3-结点、一种等价的定义、一一对应、颜色表示、旋转、在旋转后重置父结点的链接、向单个2-结点中插入新键、向树底部的2-结">
<meta property="og:locale" content="zh-Hans">
<meta property="og:image" content="https://pic-1258215793.cos.ap-shanghai.myqcloud.com/content/20191101/201911010101.png">
<meta property="og:image" content="https://pic-1258215793.cos.ap-shanghai.myqcloud.com/content/20191101/201911010102.png">
<meta property="og:image" content="https://pic-1258215793.cos.ap-shanghai.myqcloud.com/content/20191101/201911010103.png">
<meta property="og:image" content="https://pic-1258215793.cos.ap-shanghai.myqcloud.com/content/20191101/201911010104.png">
<meta property="og:image" content="https://pic-1258215793.cos.ap-shanghai.myqcloud.com/content/20191101/201911010105.png">
<meta property="og:image" content="https://pic-1258215793.cos.ap-shanghai.myqcloud.com/content/20191101/201911010106.png">
<meta property="og:image" content="https://pic-1258215793.cos.ap-shanghai.myqcloud.com/content/20191101/201911010107.png">
<meta property="og:image" content="https://pic-1258215793.cos.ap-shanghai.myqcloud.com/content/20191101/201911010108.png">
<meta property="og:image" content="https://pic-1258215793.cos.ap-shanghai.myqcloud.com/content/20191101/201911010109.png">
<meta property="og:image" content="https://pic-1258215793.cos.ap-shanghai.myqcloud.com/content/20191101/201911010110.png">
<meta property="og:image" content="https://pic-1258215793.cos.ap-shanghai.myqcloud.com/content/20191101/201911010111.png">
<meta property="og:image" content="https://pic-1258215793.cos.ap-shanghai.myqcloud.com/content/20191101/201911010112.png">
<meta property="og:image" content="https://pic-1258215793.cos.ap-shanghai.myqcloud.com/content/20191101/201911010113.png">
<meta property="og:image" content="https://pic-1258215793.cos.ap-shanghai.myqcloud.com/content/20191101/201911010114.png">
<meta property="og:image" content="https://pic-1258215793.cos.ap-shanghai.myqcloud.com/content/20191101/201911010115.png">
<meta property="og:image" content="https://pic-1258215793.cos.ap-shanghai.myqcloud.com/content/20191101/201911010116.png">
<meta property="og:image" content="https://pic-1258215793.cos.ap-shanghai.myqcloud.com/content/20191101/201911010117.png">
<meta property="og:image" content="https://pic-1258215793.cos.ap-shanghai.myqcloud.com/content/20191101/201911010118.png">
<meta property="og:image" content="https://pic-1258215793.cos.ap-shanghai.myqcloud.com/content/20191101/201911010119.png">
<meta property="og:image" content="https://pic-1258215793.cos.ap-shanghai.myqcloud.com/content/20191101/201911010120.png">
<meta property="og:image" content="https://pic-1258215793.cos.ap-shanghai.myqcloud.com/content/20191101/201911010121.png">
<meta property="og:image" content="https://pic-1258215793.cos.ap-shanghai.myqcloud.com/content/20191101/201911010122.png">
<meta property="og:image" content="https://pic-1258215793.cos.ap-shanghai.myqcloud.com/content/20191101/201911010123.png">
<meta property="og:image" content="https://pic-1258215793.cos.ap-shanghai.myqcloud.com/content/20191101/201911010124.png">
<meta property="og:image" content="https://pic-1258215793.cos.ap-shanghai.myqcloud.com/content/20191101/201911010125.png">
<meta property="og:image" content="https://pic-1258215793.cos.ap-shanghai.myqcloud.com/content/20191101/201911010126.png">
<meta property="og:image" content="https://pic-1258215793.cos.ap-shanghai.myqcloud.com/content/20191101/201911010127.png">
<meta property="og:image" content="https://pic-1258215793.cos.ap-shanghai.myqcloud.com/content/20191101/201911010128.png">
<meta property="og:image" content="https://pic-1258215793.cos.ap-shanghai.myqcloud.com/content/20191101/201911010129.png">
<meta property="og:image" content="https://pic-1258215793.cos.ap-shanghai.myqcloud.com/content/20191101/201911010130.png">
<meta property="og:image" content="https://pic-1258215793.cos.ap-shanghai.myqcloud.com/content/20191101/201911010131.png">
<meta property="og:updated_time" content="2019-12-20T10:46:14.051Z">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="算法复习 (二) 查找-平衡查找树">
<meta name="twitter:description" content="算法复习 (二) 查找-平衡查找树，主要内容包括：2-3查找树（查找、向2-结点中插入新键、向一棵只含有一个3-结点的树中插入新键、向一个父结点为2-结点的3-结点中插入新键、向一个父结点为3-结点的3-结点中插入新键、分解根结点、局部变换、全局性质、性能分析），红黑查找树（替换3-结点、一种等价的定义、一一对应、颜色表示、旋转、在旋转后重置父结点的链接、向单个2-结点中插入新键、向树底部的2-结">
<meta name="twitter:image" content="https://pic-1258215793.cos.ap-shanghai.myqcloud.com/content/20191101/201911010101.png">



<script type="text/javascript" id="hexo.configurations">
  var NexT = window.NexT || {};
  var CONFIG = {
    root: '/',
    scheme: 'Pisces',
    version: '5.1.4',
    sidebar: {"position":"left","display":"post","offset":12,"b2t":false,"scrollpercent":false,"onmobile":false},
    fancybox: true,
    tabs: true,
    motion: {"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}},
    duoshuo: {
      userId: '0',
      author: '博主'
    },
    algolia: {
      applicationID: '',
      apiKey: '',
      indexName: '',
      hits: {"per_page":10},
      labels: {"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}
    }
  };
</script>



  <link rel="canonical" href="http://linyishui.top/2019110801.html"/>





  <title>算法复习 (二) 查找-平衡查找树 | 沂水博客</title>
  








</head>

<body itemscope itemtype="http://schema.org/WebPage" lang="zh-Hans">

  
  
    
  

  <div class="container sidebar-position-left page-post-detail">
    <div class="headband"></div>

    <header id="header" class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-wrapper">
  <div class="site-meta ">
    

    <div class="custom-logo-site-title">
      <a href="/"  class="brand" rel="start">
        <span class="logo-line-before"><i></i></span>
        <span class="site-title">沂水博客</span>
        <span class="logo-line-after"><i></i></span>
      </a>
    </div>
      
        <p class="site-subtitle">编程和心历记录</p>
      
  </div>

  <div class="site-nav-toggle">
    <button>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
    </button>
  </div>
</div>

<nav class="site-nav">
  

  
    <ul id="menu" class="menu">
      
        
        <li class="menu-item menu-item-home">
          <a href="/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-home"></i> <br />
            
            首页
          </a>
        </li>
      
        
        <li class="menu-item menu-item-tags">
          <a href="/tags/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-tags"></i> <br />
            
            标签
          </a>
        </li>
      
        
        <li class="menu-item menu-item-categories">
          <a href="/categories/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-th"></i> <br />
            
            分类
          </a>
        </li>
      
        
        <li class="menu-item menu-item-archives">
          <a href="/archives/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-archive"></i> <br />
            
            归档
          </a>
        </li>
      
        
        <li class="menu-item menu-item-sitemap">
          <a href="/sitemap.xml" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-sitemap"></i> <br />
            
            站点地图
          </a>
        </li>
      

      
    </ul>
  

  
</nav>



 </div>
    </header>

    <main id="main" class="main">
      <div class="main-inner">
        <div class="content-wrap">
          <div id="content" class="content">
            

  <div id="posts" class="posts-expand">
    

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://linyishui.top/2019110801.html">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="沂水">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="https://pic-1258215793.cos.ap-shanghai.myqcloud.com/cover/riho_yoshioka1.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="沂水博客">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">算法复习 (二) 查找-平衡查找树</h1>
        

        <div class="post-meta">
          
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2019-11-08T18:44:43+08:00">
                2019-11-08
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/技术文档/" itemprop="url" rel="index">
                    <span itemprop="name">技术文档</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          
            <div class="post-wordcount">
              
                
                <span class="post-meta-item-icon">
                  <i class="fa fa-file-word-o"></i>
                </span>
                
                  <span class="post-meta-item-text">字数统计&#58;</span>
                
                <span title="字数统计">
                  10,753
                </span>
              

              
                <span class="post-meta-divider">|</span>
              

              
                <span class="post-meta-item-icon">
                  <i class="fa fa-clock-o"></i>
                </span>
                
                  <span class="post-meta-item-text">阅读时长 &asymp;</span>
                
                <span title="阅读时长">
                  38
                </span>
              
            </div>
          

          
              <div class="post-description">
                  算法复习 (二) 查找-平衡查找树，主要内容包括：2-3查找树（查找、向2-结点中插入新键、向一棵只含有一个3-结点的树中插入新键、向一个父结点为2-结点的3-结点中插入新键、向一个父结点为3-结点的3-结点中插入新键、分解根结点、局部变换、全局性质、性能分析），红黑查找树（替换3-结点、一种等价的定义、一一对应、颜色表示、旋转、在旋转后重置父结点的链接、向单个2-结点中插入新键、向树底部的2-结点插入新键、向一棵双键树（即一个3-结点）中插入新键、颜色转换、根结点总是黑色、向树底部的3-结点插入新键、将红链接在树中向上传递），实现，删除操作（自顶向下的2-3-4树、删除最小键、删除操作）红黑树的性质（性能分析、有序符号表API、答疑）等
              </div>
          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        <h1 id="平衡查找树"><a href="#平衡查找树" class="headerlink" title="平衡查找树"></a><strong>平衡查找树</strong></h1><p>&emsp;&emsp;一棵有N个节点的树，我们希望它的树高为lgN，这样可以保证所有查找都在lgN次比较内结束，但可惜在动态插入中保证树的完美平衡代价太高了。</p>
<h2 id="第一节-2-3查找树"><a href="#第一节-2-3查找树" class="headerlink" title="第一节 2-3查找树"></a><strong>第一节 2-3查找树</strong></h2><p>&emsp;&emsp;二叉树中的节点可以称作2-结点：含有一个键和两个链接，现在我们引入3-结点，含有两个键和三个链接。每条链接都对应着其中保存的键所分割产生的一个区间。</p>
<p><img src="https://pic-1258215793.cos.ap-shanghai.myqcloud.com/content/20191101/201911010101.png" alt="2-3查找树示意图"></p>
<p>&emsp;&emsp;一棵完美平衡的2-3查找树中的所有空链接到根结点的距离都应该是相同的。</p>
<h3 id="1-1-查找"><a href="#1-1-查找" class="headerlink" title="1.1 查找"></a><strong>1.1 查找</strong></h3><p>&emsp;&emsp;将二叉查找树的查找算法一般化我们就能够直接得到 2-3 树的查找算法。要判断一个键是否在树中，我们先将它和根结点中的键比较。如果它和其中任意一个相等，查找命中；否则我们就根据比较的结果找到指向相应区间的链接，并在其指向的子树中递归地继续查找。如果这是个空链接，查找未命中。具体查找过程如图 3.3.2 所示。</p>
<p><img src="https://pic-1258215793.cos.ap-shanghai.myqcloud.com/content/20191101/201911010102.png" alt="2-3树中的查找命中（左）和未命中（右）">
　</p>
<h3 id="1-2-向2-结点中插入新键"><a href="#1-2-向2-结点中插入新键" class="headerlink" title="1.2 向2-结点中插入新键"></a><strong>1.2 向2-结点中插入新键</strong></h3><p>&emsp;&emsp;要在2-3树中插入一个新结点，我们可以和二叉查找树一样先进行一次未命中的查找，然后把新结点挂在树的底部。但这样的话树无法保持完美平衡性。我们使用2-3树的主要原因就在于它能够在插入后继续保持平衡。如果未命中的查找结束于一个2-结点，事情就好办了：我们<strong>只要把这个2-结点替换为一个3-结点，将要插入的键保存在其中即可</strong>。如果未命中的查找结束于一个3-结点，事情就要麻烦一些。</p>
<p><img src="https://pic-1258215793.cos.ap-shanghai.myqcloud.com/content/20191101/201911010103.png" alt="向2-结点中插入新的键"></p>
<h3 id="1-3-向一棵只含有一个3-结点的树中插入新键"><a href="#1-3-向一棵只含有一个3-结点的树中插入新键" class="headerlink" title="1.3 向一棵只含有一个3-结点的树中插入新键"></a><strong>1.3 向一棵只含有一个3-结点的树中插入新键</strong></h3><p>&emsp;&emsp;在考虑一般情况之前，先假设我们需要向一棵只含有一个3-结点的树中插入一个新键。这棵树中有两个键，所以在它唯一的结点中已经没有可插入新键的空间了。为了将新键插入，我们先临时将新键存入该结点中，使之成为一个4-结点。它很自然地扩展了以前的结点并含有3个键和4条链接。创建一个4-结点很方便，因为很容易将它转换为一棵由3个2-结点组成的2-3树，其中一个结点（根）含有中键，一个结点含有3个键中的最小者（和根结点的左链接相连），一个结点含有3个键中的最大者（和根结点的右链接相连）。这棵树既是一棵含有3个结点的二叉查找树，同时也是一棵完美平衡的2-3树，因为其中所有的空链接到根结点的距离都相等。插入前树的高度为0，插入后树的高度为1。</p>
<p><img src="https://pic-1258215793.cos.ap-shanghai.myqcloud.com/content/20191101/201911010104.png" alt="向一棵只含有一个3-结点的树中插入新键"></p>
<h3 id="1-4-向一个父结点为2-结点的3-结点中插入新键"><a href="#1-4-向一个父结点为2-结点的3-结点中插入新键" class="headerlink" title="1.4 向一个父结点为2-结点的3-结点中插入新键"></a><strong>1.4 向一个父结点为2-结点的3-结点中插入新键</strong></h3><p>&emsp;&emsp;作为第二轮热身，假设未命中的查找结束于一个3-结点，而它的父结点是一个2-结点。在这种情况下我们需要在维持树的完美平衡的前提下为新键腾出空间。我们先像刚才一样构造一个临时的4-结点并将其分解，但此时我们不会为中键创建一个新结点，而是将其移动至原来的父结点中。你可以将这次转换看成将指向原3-结点的一条链接替换为新父结点中的原中键左右两边的两条链接，并分别指向两个新的2-结点。根据我们的假设，父结点中是有空间的：父结点是一个2-结点（一个键两条链接），插入之后变为了一个3-结点（两个键3条链接）。另外，这次转换也并不影响（完美平衡的）2-3树的主要性质。树仍然是有序的，因为中键被移动到父结点中去了；树仍然是完美平衡的，插入后所有的空链接到根结点的距离仍然相同。请确认你完全理解了这次转换——它是2-3 树的动态变化的核心，其过程如图 3.3.5 所示。</p>
<p><img src="https://pic-1258215793.cos.ap-shanghai.myqcloud.com/content/20191101/201911010105.png" alt="向一个父结点为2-结点的3-结点中插入新键"></p>
<h3 id="1-5-向一个父结点为3-结点的3-结点中插入新键"><a href="#1-5-向一个父结点为3-结点的3-结点中插入新键" class="headerlink" title="1.5 向一个父结点为3-结点的3-结点中插入新键"></a><strong>1.5 向一个父结点为3-结点的3-结点中插入新键</strong></h3><p>&emsp;&emsp;现在假设未命中的查找结束于一个父结点为3-结点的结点。我们再次和刚才一样构造一个临时的4-结点并分解它，然后将它的中键插入它的父结点中。但父结点也是一个3-结点，因此我们再用这个中键构造一个新的临时4-结点，然后在这个结点上进行相同的变换，即分解这个父结点并将它的中键插入到它的父结点中去。推广到一般情况，我们就这样一直向上不断分解临时的4-结点并将中键插入更高层的父结点，直至遇到一个2-结点并将它替换为一个不需要继续分解的3-结点，或者是到达3-结点的根。该过程如图 3.3.6 所示。</p>
<p><img src="https://pic-1258215793.cos.ap-shanghai.myqcloud.com/content/20191101/201911010106.png" alt="向一个父结点为3-结点的3-结点中插入新键"></p>
<h3 id="1-6-分解根结点"><a href="#1-6-分解根结点" class="headerlink" title="1.6 分解根结点"></a><strong>1.6 分解根结点</strong></h3><p>&emsp;&emsp;如果从插入结点到根结点的路径上全都是3-结点，我们的根结点最终变成一个临时的4-结点。此时我们可以按照向一棵只有一个3-结点的树中插入新键的方法处理这个问题。我们将临时的4-结点分解为3个2-结点，使得树高加1，如图 3.3.7 所示。请注意，这次最后的变换仍然保持了树的完美平衡性，因为它变换的是根结点。</p>
<p><img src="https://pic-1258215793.cos.ap-shanghai.myqcloud.com/content/20191101/201911010107.png" alt="分解根结点"></p>
<h3 id="1-7-局部变换"><a href="#1-7-局部变换" class="headerlink" title="1.7 局部变换"></a><strong>1.7 局部变换</strong></h3><p>&emsp;&emsp;将一个4-结点分解为一棵2-3树可能有6种情况，都总结在了图 3.3.8 中。这个4-结点可能是根结点，可能是一个2-结点的左子结点或者右子结点，也可能是一个3-结点的左子结点、中子结点或者右子结点。23树插入算法的根本在于这些变换都是局部的：<strong>除了相关的结点和链接之外不必修改或者检查树的其他部分</strong>。每次变换中，变更的链接数量不会超过一个很小的常数。需要特别指出的是，不光是在树的底部，树中的任何地方只要符合相应的模式，变换都可以进行。每个变换都会将4结点中的一个键送入它的父结点中，并重构相应的链接而不必涉及树的其他部分。</p>
<p><img src="https://pic-1258215793.cos.ap-shanghai.myqcloud.com/content/20191101/201911010108.png" alt="在一棵2-3树中分解一个4-结点的情况汇总"></p>
<h3 id="1-8-全局性质"><a href="#1-8-全局性质" class="headerlink" title="1.8 全局性质"></a><strong>1.8 全局性质</strong></h3><p>&emsp;&emsp;这些局部变换不会影响树的全局有序性和平衡性：<strong>任意空链接到根结点的路径长度都是相等的</strong>。作为参考，图 3.3.9 所示的是当一个4-结点是一个 3-结点的中子结点时的完整变换情况。如果在变换之前根结点到所有空链接的路径长度为h，那么变换之后该长度仍然为h。所有的变换都具有这个性质，即使是将一个4-结点分解为两个2-结点并将其父结点由2-结点变为3-结点，或是由3-结点变为一个临时的4-结点时也是如此。当根结点被分解为3个2-结点时，所有空链接到根结点的路径长度才会加1。</p>
<p><img src="https://pic-1258215793.cos.ap-shanghai.myqcloud.com/content/20191101/201911010109.png" alt="4-结点的分解是一次局部变换，不会影响树的有序性和平衡性"></p>
<p>&emsp;&emsp;和标准的二叉查找树由上向下生长不同，2-3树的生长是由下向上的。 如果你花点时间仔细研究一下图 3.3.10，就能很好地理解2-3树的构造方式。它给出了我们的标准索引测试用例中产生的一系列2-3树，以及一系列由同一组键按照升序依次插入到树中时所产生的所有2-3树。还记得在二叉查找树中，按照升序插入10 个键会得到高度为9的一棵最差查找树吗？如果使用2-3树，树的高度是2。</p>
<p><img src="https://pic-1258215793.cos.ap-shanghai.myqcloud.com/content/20191101/201911010110.png" alt="2-3树的构造轨迹"></p>
<h3 id="1-9-性能分析"><a href="#1-9-性能分析" class="headerlink" title="1.9 性能分析"></a><strong>1.9 性能分析</strong></h3><p>&emsp;&emsp;2-3树的分析和二叉查找树的分析大不相同，因为我们主要感兴趣的是最坏情况下的性能，而非一般情况（这种情况下我们会用随机键模型分析预期的性能）。在符号表的实现中，一般我们无法控制用例会按照什么顺序向表中插入键，因此对最坏情况的分析是唯一能够提供性能保证的办法。</p>
<blockquote>
<ul>
<li>命题 F。在一棵大小为的2-3树中，查找和插入操作访问的结点必然不超过lgN个。</li>
<li>证明。一棵含有N个结点的2-3树的高度在log3(N)=[lgN / lg3]（如果树中全是3-结点）和[lgN]（如果树中全是2-结点）之间。</li>
</ul>
</blockquote>
<p>&emsp;&emsp;因此我们可以确定2-3树在最坏情况下仍有较好的性能。每个操作中处理每个结点的时间都不会超过一个很小的常数，且这两个操作都只会访问一条路径上的结点，所以任何查找或者插入的成本都肯定不会超过对数级别。通过对比图 3.3.11 中的2-3树和图 3.2.8 中由相同的键构造的二叉查找树，你也可以看到，完美平衡的 2-3树要平展得多。例如，含有 10 亿个结点的一棵2-3树的高度仅在19到30之间。我们最多只需 访问30个结点就能够在10亿个键中进行任意查找和插入操作，这是相当惊人的。</p>
<p><img src="https://pic-1258215793.cos.ap-shanghai.myqcloud.com/content/20191101/201911010111.png" alt="由随机键构造的一棵典型的2-3树"></p>
<p>&emsp;&emsp;但是，我们和真正的实现还有一段距离。尽管我们可以用不同的数据类型表示2-结点和3-结点并写出变换所需的代码，但用这种直白的表示方法实现大多数的操作并不方便，因为需要处理的情况实在太多。我们需要维护两种不同类型的结点，将被查找的键和结点中的每个键进行比较，将链接和其他信息从一种结点复制到另一种结点，将结点从一种数据类型转换到另一种数据类型，等等。实现这些不仅需要大量的代码，而且它们所产生的额外开销可能会使算法比标准的二叉查找树更慢。平衡一棵树的初衷是为了消除最坏情况，但我们希望这种保障所需的代码能够越少越好。幸运的是你将看到，我们只需要一点点代价就能用一种统一的方式完成所有变换。</p>
<hr>
<h2 id="第二节-红黑查找树"><a href="#第二节-红黑查找树" class="headerlink" title="第二节 红黑查找树"></a><strong>第二节 红黑查找树</strong></h2><h3 id="2-1-替换3-结点"><a href="#2-1-替换3-结点" class="headerlink" title="2.1 替换3-结点"></a><strong>2.1 替换3-结点</strong></h3><p>&emsp;&emsp;红黑二叉查找树背后的基本思想是用标准的二叉查找树（完全由2-结点构成）和一些额外的信息（替换3-结点）来表示2-3树。我们将树中的链接分为两种类型：<strong>红链接将两个2-结点连接起来构成一个3-结点，黑链接则是2-3树中的普通链接</strong>。确切地说，我们<strong>将3-结点表示为由一条左斜的红色链接相连的两个2-结点</strong>，如图 3.3.12 所示。这种表示法的一个优点是，我们无需修改就可以直接使用标准二叉查找树的get()方法。对于任意的2-3树，只要对结点进行转换，我们都可以立即派生出一棵对应的二叉查找树。我们将用这种方式表示2-3树的二叉查找树称为红黑二叉查找树（以下简称为红黑树）。</p>
<p><img src="https://pic-1258215793.cos.ap-shanghai.myqcloud.com/content/20191101/201911010112.png" alt="由一条红色左链接相连的两个2-结点表示一个3-结点"></p>
<h3 id="2-2-一种等价的定义"><a href="#2-2-一种等价的定义" class="headerlink" title="2.2 一种等价的定义"></a><strong>2.2 一种等价的定义</strong></h3><p>&emsp;&emsp;红黑树的另一种定义是含有红黑链接并满足下列条件的二叉查找树：</p>
<blockquote>
<ul>
<li>红链接均为左链接；</li>
<li>没有任何一个结点同时和两条红链接相连； </li>
<li>该树是完美黑色平衡的，即任意空链接到根结点的路径上的黑链接数量相同。</li>
</ul>
</blockquote>
<p>&emsp;&emsp;满足这样定义的红黑树和相应的 2-3 树是<strong>一一对应</strong>的。</p>
<h3 id="2-3-一一对应"><a href="#2-3-一一对应" class="headerlink" title="2.3 一一对应"></a><strong>2.3 一一对应</strong></h3><p>&emsp;&emsp;如果我们将一棵红黑树中的红链接画平，那么所有的空链接到根结点的距离都将是相同的（如图 3.3.13 所示）。如果我们将由红链接相连的结点合并，得到的就是一棵2-3树。相反，如果将一棵2-3树中的3-结点画作由红色左链接相连的两个2-结点，那么不会存在能够和两条红链接相连的结点，且树必然是完美黑色平衡的，因为黑链接即2-3树中的普通链接，根据定义这些链接必然是完美平衡的。无论我们选择用何种方式去定义它们，红黑树都既是二叉查找树，也是2-3树，如图 3.3.14 所示。因此，如果我们能够在保持一一对应关系的基础上实现2-3树的插入算法，那么我们就能够将两个算法的优点结合起来：二叉查找树中简洁高效的查找方法和2-3树中高效的平衡插入算法。</p>
<p><img src="https://pic-1258215793.cos.ap-shanghai.myqcloud.com/content/20191101/201911010113.png" alt="将红链接画平时，一棵红黑树就是一棵2-3树"></p>
<p><img src="https://pic-1258215793.cos.ap-shanghai.myqcloud.com/content/20191101/201911010114.png" alt="红黑树和2-3树的一一对应关系"></p>
<h3 id="2-4-颜色表示"><a href="#2-4-颜色表示" class="headerlink" title="2.4 颜色表示"></a><strong>2.4 颜色表示</strong></h3><p>&emsp;&emsp;方便起见，因为每个结点都只会有一条指向自己的链接（从它的父结点指向它），我们将链接的颜色保存在表示结点的Node数据类型的布尔变量 color 中。如果指向它的链接是红色的，那么该变量为true，黑色则为false。我们约定空链接为黑色。为了代码的清晰我们定义了两个常量 RED 和 BLACK 来设置和测试这个变量。我们使用私有方法 isRed() 来测试一个结点和它的父结点之间的链接的颜色。颜色表示的代码实现如图 3.3.15 所示。</p>
<p><img src="https://pic-1258215793.cos.ap-shanghai.myqcloud.com/content/20191101/201911010115.png" alt="红黑树的结点表示"></p>
<h3 id="2-5-旋转"><a href="#2-5-旋转" class="headerlink" title="2.5 旋转"></a><strong>2.5 旋转</strong></h3><p>&emsp;&emsp;在我们实现的某些操作中可能会出现红色右链接或者两条连续的红链接，但在操作完成前这些情况都会被小心地旋转并修复。旋转操作会改变红链接的指向。首先，假设我们有一条红色的右链接需要被转化为左链接（请见图 3.3.16）。这个操作叫做<strong>左旋转</strong>，它对应的方法接受一条指向红黑树中的某个结点的链接作为参<br>数。假设被指向的结点的右链接是红色的，这个方法会对树进行必要的调整并返回一个指向包含同一组键的子树且其左链接为红色的根结点的链接。<strong>我们只是将用两个键中的较小者作为根结点变为将较大者作为根结点</strong>。实现将一个红色左链接转换为一个红色右链接的一个右旋转的代码完全相同，只需要将 left 和 right 互换即可（如图 3.3.17 所示）。</p>
<p><img src="https://pic-1258215793.cos.ap-shanghai.myqcloud.com/content/20191101/201911010116.png" alt="左旋转h的右链接"></p>
<p><img src="https://pic-1258215793.cos.ap-shanghai.myqcloud.com/content/20191101/201911010117.png" alt="右旋转h的左链接"></p>
<h3 id="2-6-在旋转后重置父结点的链接"><a href="#2-6-在旋转后重置父结点的链接" class="headerlink" title="2.6 在旋转后重置父结点的链接"></a><strong>2.6 在旋转后重置父结点的链接</strong></h3><p>&emsp;&emsp;无论左旋转还是右旋转，旋转操作都会返回一条链接。我们总是会用rotateRight()或rotateLeft()的返回值重置父结点（或是根结点）中相应的链接。返回的链接可能是左链接也可能是右链接，但是我们总会将它赋予父结点中的链接。这个链接可能是红色也可能是黑色——rotateLeft()和rotateRight()都通过将x.color设为h.color保留它原来的颜色。这可能会产生两条连续的红链接，但我们的算法会继续用旋转操作修正这种情况。例如，代码h = rotateLeft(h); 将旋转结点h的红色右链接，使得h指向了旋转后的子树的根结点（组成该子树中的所有键和旋转前相同，只是根结点发生了变化）。这种简洁的代码是我们使用递归实现二叉查找树的各种方法的主要原因。你会看到，它使得旋转操作成为了普通插入操作的一个简单补充。</p>
<p>&emsp;&emsp;在插入新的键时我们可以使用旋转操作帮助我们保证2-3树和红黑树之间的一一对应关系，因为旋转操作可以保持红黑树的两个重要性质：有序性和完美平衡性。也就是说，我们在红黑树中进行旋转时无需为树的有序性或者完美平衡性担心。下面我们来看看应该如何使用旋转操作来保持红黑树的另外两个重要性质（不存在两条连续的红链接和不存在红色的右链接）。我们先用一些简单的情况热热身。</p>
<h3 id="2-7-向单个2-结点中插入新键"><a href="#2-7-向单个2-结点中插入新键" class="headerlink" title="2.7 向单个2-结点中插入新键"></a><strong>2.7 向单个2-结点中插入新键</strong></h3><p>&emsp;&emsp;一棵只含有一个键的红黑树只含有一个2-结点。插入另一个键之后，我们马上就需要将它们旋转。如果新键小于老键，我们只需要新增一个红色的结点即可，新的红黑树和单个3-结点完全等价。如果新键大于老键，那么新增的红色结点将会产生一条红色的右链接。我们需要使用 root = rotateLeft(root); 来将其旋转为红色左链接并修正根结点的链接，插入操作才算完成。两种情况的结果均为一棵和单个3- 结点等价的红黑树，其中含有两个键，一条红链接，树的黑链接高度为1， 如图 3.3.18 所示。</p>
<p><img src="https://pic-1258215793.cos.ap-shanghai.myqcloud.com/content/20191101/201911010118.png" alt="向单个2-结点中插入一个新键"></p>
<h3 id="2-8-向树底部的2-结点插入新键"><a href="#2-8-向树底部的2-结点插入新键" class="headerlink" title="2.8 向树底部的2-结点插入新键"></a><strong>2.8 向树底部的2-结点插入新键</strong></h3><p>&emsp;&emsp;用和二叉查找树相同的方式向一棵红黑树中插入一个新键会在树的底部新增一个结点（为了保证有序性），但总是用红链接将新结点和它的父结点相连。如果它的父结点是一个2-结点，那么刚才讨论的两种处理方法仍然适用。如果指向新结点的是父结点的左链接，那么父结点就直接成为了一个3-结点；如果指向新结点的是父结点的右链接，这就是一个错误的3-结点，但一次左旋转就能够修正它，如图 3.3.19 所示。</p>
<p><img src="https://pic-1258215793.cos.ap-shanghai.myqcloud.com/content/20191101/201911010119.png" alt="向树底部的2-结点插入一个新键"></p>
<h3 id="2-9-向一棵双键树（即一个3-结点）中插入新键"><a href="#2-9-向一棵双键树（即一个3-结点）中插入新键" class="headerlink" title="2.9 向一棵双键树（即一个3-结点）中插入新键"></a><strong>2.9 向一棵双键树（即一个3-结点）中插入新键</strong></h3><p>&emsp;&emsp;这种情况又可分为三种子情况：<strong>新键小于树中的两个键</strong>，<strong>在两者之间</strong>，<strong>或是大于树中的两个键</strong>。每种情况中都会产生一个同时连接到两条红链接的结点，而我们的目标就是修正这一点。</p>
<blockquote>
<ul>
<li>三者中最简单的情况是新键大于原树中的两个键，因此它被连接到3-结点的右链接。此时树是平衡的，根结点为中间大小的键，它有两条红链接分别和较小和较大的结点相连。如果我们将两条链接的颜色都由红变黑，那么我们就得到了一棵由三个结点组成、高为2的平衡树。它正好能够对应一棵2-3树，如图 3.3.20（左）。其他两种情况最终也会转化为这种情况。 </li>
<li>如果新键小于原树中的两个键，它会被连接到最左边的空链接，这样就产生了两条连续的红链接，如图 3.3.20（中）。此时我们只需要将上层的红链接右旋转即可得到第一种情况（中值键为根结点并和其他两个结点用红链接相连）。 </li>
<li>如果新键介于原树中的两个键之间，这又会产生两条连续的红链接，一条红色左链接接一条红色右链接，如图 3.3.20（右）。此时我们只需要将下层的红链接左旋转即可得到第二种情况（两条连续的红色左链接）。</li>
</ul>
</blockquote>
<p><img src="https://pic-1258215793.cos.ap-shanghai.myqcloud.com/content/20191101/201911010120.png" alt="向一棵双键树（即一个3-结点）中插入一个新键的三种情况"></p>
<p>&emsp;&emsp;总的来说，我们通过 0 次、1 次和 2 次旋转以及颜色的变化得到了期望的结果。在 2-3 树中，请确认你完全理解了这些转换，它们是红黑树的动态变化的关键。</p>
<h3 id="2-10-颜色转换"><a href="#2-10-颜色转换" class="headerlink" title="2.10 颜色转换"></a><strong>2.10 颜色转换</strong></h3><p>&emsp;&emsp;如图 3.3.21 所示，我们专门用一个方法 flipColors() 来转换一个结点的两个红色子结点的颜色。除了将子结点的颜色由红变黑之外，我们同时还要将父结点的颜色由黑变红。这项操作最重要的性质在于它和旋转操作一样是局部变换，不会影响整棵树的黑色平衡性。根据这一点，我们马上能够在下面完整地实现红黑树。</p>
<p><img src="https://pic-1258215793.cos.ap-shanghai.myqcloud.com/content/20191101/201911010121.png" alt="通过转换链接的颜色来分解4-结点"></p>
<h3 id="2-11-根结点总是黑色"><a href="#2-11-根结点总是黑色" class="headerlink" title="2.11 根结点总是黑色"></a><strong>2.11 根结点总是黑色</strong></h3><p>&emsp;&emsp;在 3.3.2.9 所述的情况中，颜色转换会使根结点变为红色。这也可能出现在很大的红黑树中。严格地说，红色的根结点说明根结点是一个3结点的一部分，但实际情况并不是这样。因此我们在每次插入后都会将根结点设为黑色。注意，每当根结点由红变黑时树的黑链接高度就会加1。</p>
<h3 id="2-12-向树底部的3-结点插入新键"><a href="#2-12-向树底部的3-结点插入新键" class="headerlink" title="2.12 向树底部的3-结点插入新键"></a><strong>2.12 向树底部的3-结点插入新键</strong></h3><p>&emsp;&emsp;现在假设我们需要在树的底部的一个3-结点下加入一个新结点。前面讨论过的三种情况都会出现，如图 3.3.22 所示。指向新结点的链接可能是3-结点的右链接（此时我们只需要转换颜色即可），或是左链接（此时我们需要进行右旋转然后再转换颜色），或是中链接（此时我们 需要先左旋转下层链接然后右旋转上层链接，最后再转换颜色）。颜色转换会使到中结点的链接变红，相当于将它送入了父结点。这意味着在父结点中继续插入一个新键，我们也会继续用相同的办法解决这个问题。</p>
<p><img src="https://pic-1258215793.cos.ap-shanghai.myqcloud.com/content/20191101/201911010122.png" alt="向树底部的3-结点插入一个新键"></p>
<h3 id="2-13-将红链接在树中向上传递"><a href="#2-13-将红链接在树中向上传递" class="headerlink" title="2.13 将红链接在树中向上传递"></a><strong>2.13 将红链接在树中向上传递</strong></h3><p>&emsp;&emsp;2-3 树中的插入算法需要我们分解 3- 结点，将中间键插入父结点，如此这般直到遇到一个2-结点或是根结点。我们所考虑过的所有情况都正是为了达成这个目标：每次必要的旋转之后我们都会进行颜色转换，这使得中结点变红。在父结点看来，处理这样一个红色结点的方式和处理一个新插入的红色结点完全相同，即继续把红链接转移到中结点上去。图 3.3.23 中总结的三种情况显示了在红黑树中实现2-3树的插入算法的 关键操作所需的步骤：要在一个3-结点下插入新键，先创建一个临时 的4-结点，将其分解并将红链接由中间键传递给它的父结点。重复这个过程，我们就能将红链接在树中向上传递，直至遇到一个2-结点或者根结点。</p>
<p><img src="https://pic-1258215793.cos.ap-shanghai.myqcloud.com/content/20191101/201911010123.png" alt="红黑树中红链接向上传递"></p>
<p>&emsp;&emsp;总之，只要谨慎地使用左旋转、右旋转和颜色转换这三种简单的操作，我们就能够保证插入操作后红黑树和2-3树的一一对应关系。在沿着插入点到根结点的路径向上移动时在所经过的每个结点中顺序完成以下操作，我们就能完成插入操作：</p>
<blockquote>
<ul>
<li>如果右子结点是红色的而左子结点是黑色的，进行左旋转； </li>
<li>如果左子结点是红色的且它的左子结点也是红色的，进行右旋转；</li>
<li>如果左右子结点均为红色，进行颜色转换。</li>
</ul>
</blockquote>
<p>&emsp;&emsp;你应该花点时间确认以上步骤处理了前文描述的所有情况。请注意，第一个操作表示将一个2-结点变为一个3-结点和插入的新结点与树底部的3-结点通过它的中链接相连的两种情况。</p>
<hr>
<h2 id="第三节-实现"><a href="#第三节-实现" class="headerlink" title="第三节 实现"></a><strong>第三节 实现</strong></h2><p>&emsp;&emsp;因为保持树的平衡性所需的操作是由下向上在每个所经过的结点中进行的，将它们植入我们已有的实现中十分简单：只需要在递归调用之后完成这些操作即可，如算法 3.4 所示。上一段中列出的三种操作都可以通过一个检测两个结点的颜色的if语句完成。尽管实现所需的代码量很小，但如果没有我们学习过的两种抽象数据结构（2-3 树和红黑树）作为铺垫，这段实现仍然会非常难以理解。在检查了三到五个结点的颜色之后（也许还需要进行一两次旋转以及颜色转换），我们就可以得到一棵近乎完美平衡的二叉查找树。</p>
<figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line">public <span class="class"><span class="keyword">class</span> <span class="title">RedBlackBST&lt;Key</span> <span class="keyword">extends</span> <span class="title">Comparable&lt;Key&gt;</span>, <span class="title">Value&gt;</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">Node</span> root;</span><br><span class="line">   </span><br><span class="line">    <span class="keyword">private</span> <span class="class"><span class="keyword">class</span> <span class="title">Node</span> <span class="title">//</span> <span class="title">含有color变量的Node对象（请见3</span>.3.2.4<span class="title">节）</span></span></span><br><span class="line"><span class="class"></span></span><br><span class="line"><span class="class">    <span class="title">private</span> <span class="title">boolean</span> <span class="title">isRed</span>(<span class="params"><span class="type">Node</span> h</span>)    <span class="title">//</span> <span class="title">请见3</span>.3.2.4<span class="title">节</span>   </span></span><br><span class="line"><span class="class">    <span class="title">private</span> <span class="title">Node</span> <span class="title">rotateLeft</span>(<span class="params"><span class="type">Node</span> h</span>)  <span class="title">//</span> <span class="title">请见图3</span>.3.16   </span></span><br><span class="line"><span class="class">    <span class="title">private</span> <span class="title">Node</span> <span class="title">rotateRight</span>(<span class="params"><span class="type">Node</span> h</span>) <span class="title">//</span> <span class="title">请见图3</span>.3.17   </span></span><br><span class="line"><span class="class">    <span class="title">private</span> <span class="title">void</span> <span class="title">flipColors</span>(<span class="params"><span class="type">Node</span> h</span>)  <span class="title">//</span> <span class="title">请见图3</span>.3.21</span></span><br><span class="line"><span class="class"></span></span><br><span class="line"><span class="class">    <span class="title">private</span> <span class="title">int</span> <span class="title">size</span>(<span class="params"></span>)               <span class="title">//</span> <span class="title">请见算法3</span>.3</span></span><br><span class="line"><span class="class"></span></span><br><span class="line"><span class="class">    <span class="title">public</span> <span class="title">void</span> <span class="title">put</span>(<span class="params"><span class="type">Key</span> key, <span class="type">Value</span> val</span>)</span>&#123;  </span><br><span class="line">       <span class="comment">// 查找key，找到则更新其值，否则为它新建一个结点      </span></span><br><span class="line">       root = put(root, key, <span class="keyword">val</span>);      </span><br><span class="line">       root.color = <span class="type">BLACK</span>;   </span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="type">Node</span> put(<span class="type">Node</span> h, <span class="type">Key</span> key, <span class="type">Value</span> <span class="keyword">val</span>)   &#123;     </span><br><span class="line">        <span class="comment">// 标准的插入操作，和父结点用红链接相连    </span></span><br><span class="line">        <span class="keyword">if</span> (h == <span class="literal">null</span>)       </span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">new</span> <span class="type">Node</span>(key, <span class="keyword">val</span>, <span class="number">1</span>, <span class="type">RED</span>);</span><br><span class="line"></span><br><span class="line">        int cmp = key.compareTo(h.key);      </span><br><span class="line">        <span class="keyword">if</span> (cmp &lt; <span class="number">0</span>) </span><br><span class="line">            h.left  = put(h.left,  key, <span class="keyword">val</span>);      </span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (cmp &gt; <span class="number">0</span>) </span><br><span class="line">            h.right = put(h.right, key, <span class="keyword">val</span>);      </span><br><span class="line">        <span class="keyword">else</span> h.<span class="keyword">val</span> = <span class="keyword">val</span>;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">if</span> (isRed(h.right) &amp;&amp; !isRed(h.left))  h = rotateLeft(h);             </span><br><span class="line">        <span class="keyword">if</span> (isRed(h.left) &amp;&amp; isRed(h.left.left))  h = rotateRight(h);             </span><br><span class="line">        <span class="keyword">if</span> (isRed(h.left) &amp;&amp; isRed(h.right))  flipColors(h);</span><br><span class="line">            </span><br><span class="line">        h.<span class="type">N</span> = size(h.left) + size(h.right) + <span class="number">1</span>;      </span><br><span class="line">        <span class="keyword">return</span> h;  </span><br><span class="line">    &#125; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>&emsp;&emsp;除了递归调用后的三条 if 语句，红黑树中 put() 的递归实现和二叉查找树中 put() 的实现完全相同。它们在查找路径上保证了红黑树和2-3树的一一对应关系，使得树的平衡性接近完美。第一条 if 语句会将任意含有红色右链接的3-结点（或临时的4-结点）向左旋转；第二条 if 语句会将临时的4-结点中两条连续红链接中的上层链接向右旋转；第三条 if 语句会进行颜色转换并将红链接在树中向上传递（详情请见正文）。</p>
<p>&emsp;&emsp;图 3.3.24 给出了使用我们的标准索引测试用例进行测试的轨迹和用同一组键按照升序构造一棵红黑树的测试轨迹。仅从红黑树的三种标准操作的角度分析这些例子对我们理解问题很有帮助，之前我们也是这样做的。另一个基本练习是检查它们和2-3树的一一对应关系（可以对比图 3.3.10 中由同一组键构造的2-3树）。在两种情况中你都能通过思考将 P 插入红黑树所需的转换来检验你对算法的理解程度（请见练习 3.3.12）。</p>
<p><img src="https://pic-1258215793.cos.ap-shanghai.myqcloud.com/content/20191101/201911010124.png" alt="红黑树的构造轨迹"></p>
<hr>
<h2 id="第四节-删除操作"><a href="#第四节-删除操作" class="headerlink" title="第四节 删除操作"></a><strong>第四节 删除操作</strong></h2><p>&emsp;&emsp;算法3.4中的 put() 方法是本书中最复杂的实现之一，而红黑树的 deleteMin()、deleteMax() 和 delete() 的实现更麻烦，我们将它们的完整实现留做练习，但这里仍然需要学习它们的基本原理。要描述删除算法，首先我们要回到2-3树。和插入操作一样，我们也可以定义一系列局部变换来在删除一个结点的同时保持树的完美平衡性。这个过程比插入一个结点更加复杂，因为我们不仅要在（为了删除一个结点而）构造临时4-结点时沿着查找路径向下进行变换，还要在分解遗留的4-结点时沿着查找路径向上进行变换（同插入操作）。</p>
<h3 id="4-1-自顶向下的2-3-4树"><a href="#4-1-自顶向下的2-3-4树" class="headerlink" title="4.1 自顶向下的2-3-4树"></a><strong>4.1 自顶向下的2-3-4树</strong></h3><p>&emsp;&emsp;作为第一轮热身，我们先学习一个沿查找路径既能向上也能向下进行变换的稍简单的算法：2-3-4树的插入算法，2-3-4树中允许存在我们以前见过的4-结点。它的插入算法沿查找路径向下进行变换是为了保证当前结点不是4-结点（这样树底才有空间来插入新的键），沿查找路径向上进行变换是为了将之前创建的4-结点配平，如图 3.3.25 所示。向下的变换和我们在2-3树中分解4-结点所进行的变换完全相同。如果 根结点是4-结点，我们就将它分解成三个2-结点，使得树高加1。在向下查找的过程中，如果遇到一个父结点为2-结点的4-结点，我们将4-结点分解为两个2-结点并将中间键传递给它的父结点，使得父结点 变为一个3-结点；如果遇到一个父结点为3-结点的4-结点，我们将4-结点分解为两个2-结点并将中间键传递给它的父结点，使得父结点变为一个4-结点；我们不必担心会遇到父结点为4-结点的4-结点，因为插入算法本身就保证了这种情况不会出现。到达树的底部之后，我们也只会遇到2-结点或者3-结点，所以我们可以插入新的键。要用红黑树实现这个算法，我们需要：</p>
<blockquote>
<ul>
<li>将4-结点表示为由三个2-结点组成的一棵平衡的子树，根结点和两个子结点都用红链接相连； </li>
<li>在向下的过程中分解所有4-结点并进行颜色转换； </li>
<li>和插入操作一样，在向上的过程中用旋转将4-结点配平 。</li>
</ul>
</blockquote>
<p>&emsp;&emsp;因为4-结点可以存在，所以可以允许一个结点同时连接到两条链接。——译者注</p>
<p><img src="https://pic-1258215793.cos.ap-shanghai.myqcloud.com/content/20191101/201911010125.png" alt="自顶向下的2-3-4树的插入算法中的变换"></p>
<p>&emsp;&emsp;令人惊讶的是，你只需要移动算法3.4的 put() 方法中的一行代码就能实现2-3-4树中的插入操作：将 colorFlip() 语句（及其 if 语句）移动到递归调用之前（null 测试和比较操作之间）。在多个进程可以同时访问同一棵树的应用中这个算法优于2-3树，因为它操作的总是当前结点的一个或两个链接。我们下面要讲的删除算法和它的插入算法类似，而且也适用于2-3树。</p>
<h3 id="4-2-删除最小键"><a href="#4-2-删除最小键" class="headerlink" title="4.2 删除最小键"></a><strong>4.2 删除最小键</strong></h3><p>&emsp;&emsp;在第二轮热身中我们要学习2-3树中删除最小键的操作。我们注意到从 树底部的3-结点中删除键是很简单的，但2-结点则不然。从2-结点中删除一个键会留下一个空结点，一般我们会将它替换为一个空链接，但这样会破坏树的完美平衡性。所以我们需要这样做：为了保证我们不会 删除一个2-结点，我们沿着左链接向下进行变换，确保当前结点不是2-结点（可能是3-结点，也可能是临时的4-结点）。首先，根结点可 能有两种情况。如果根是2-结点且它的两个子结点都是2-结点，我们可以直接将这三个结点变成一个4-结点；否则我们需要保证根结点的左子结点不是2-结点，如有必要可以从它右侧的兄弟结点“借”一个键 来。以上情况如图 3.3.26 所示。在沿着左链接向下的过程中，保证以下情况之一成立：</p>
<blockquote>
<ul>
<li>如果当前结点的左子结点不是2-结点，完成； </li>
<li>如果当前结点的左子结点是2-结点而它的亲兄弟结点不是2-结点，将左子结点的兄弟结点中的一个键移动到左子结点中； </li>
<li>如果当前结点的左子结点和它的亲兄弟结点都是2-结点，将左子结点、父结点中的最小键和左子结点最近的兄弟结点合并为一个 4结点，使父结点由3-结点变为2-结点或者由4-结点变为3-结点。</li>
</ul>
</blockquote>
<p><img src="https://pic-1258215793.cos.ap-shanghai.myqcloud.com/content/20191101/201911010126.png" alt="删除最小键操作中的变换"></p>
<p>&emsp;&emsp;在遍历的过程中执行这个过程，最后能够得到一个含有最小键的3-结点或者4-结点，然后我们就可以直接从中将其删除，将3-结点变为2结点，或者将4-结点变为3-结点。然后我们再回头向上分解所有临时的4-结点。</p>
<h3 id="4-3-删除操作"><a href="#4-3-删除操作" class="headerlink" title="4.3 删除操作"></a><strong>4.3 删除操作</strong></h3><p>&emsp;&emsp;在查找路径上进行和删除最小键相同的变换同样可以保证在查找过程中任意当前结点均不是2-结点。如果被查找的键在树的底部，我们可以直接删除它。如果不在，我们需要将它和它的后继结点交换，就和二叉查找树一样。因为当前结点必然不是 2-结点，问题已经转化为在一棵根结点不是2-结点的子树中删除最小的键，我们可以在这棵子树中使用前文所述的算法。和以前一样，删除之后我们需要向上回溯并分解余下的4-结点。</p>
<p>&emsp;&emsp;本节末尾的练习中有几道是关于这些删除算法的例子和实现的。有兴趣理解或实现删除算法的读者应该掌握这些练习中的细节。对算法研究感兴趣的读者应该认识到这些方法的重要性，因为这是我们见过的第一种能够同时实现高效的查找、插入和删除操作的符号表实现。下面我们将会验证这一点。</p>
<hr>
<h2 id="第五节-红黑树的性质"><a href="#第五节-红黑树的性质" class="headerlink" title="第五节 红黑树的性质"></a><strong>第五节 红黑树的性质</strong></h2><p>&emsp;&emsp;研究红黑树的性质就是要检查对应的2-3树并对相应的2-3树进行分析的过程。我们的最终结论是所有基于红黑树的符号表实现都能保证操作的运行时间为对数级别（范围查找除外，它所需的额外时间和返回的键的数量成正比）。我们重复并强调这一点是因为它十分重要。</p>
<h3 id="5-1-性能分析"><a href="#5-1-性能分析" class="headerlink" title="5.1 性能分析"></a><strong>5.1 性能分析</strong></h3><p>&emsp;&emsp;首先，无论键的插入顺序如何，红黑树都几乎是完美平衡的（请见图 3.3.27）。这从它和2-3树的一一对应关系以及 2-3 树的重要性质可以得到。</p>
<p><img src="https://pic-1258215793.cos.ap-shanghai.myqcloud.com/content/20191101/201911010127.png" alt="使用随机键构造的典型红黑树，没有画出空链接"></p>
<p>&emsp;&emsp;命题 G。一棵大小为N的红黑树的高度不会超过2lgN。</p>
<p>&emsp;&emsp;简略的证明。红黑树的最坏情况是它所对应的 2-3 树中构成最左边 的路径结点全部都是 3- 结点而其余均为 2- 结点。最左边的路径长 度是只包含 2- 结点的路径长度（~lgN）的两倍。要按照某种顺序 构造一棵平均路径长度为2lgN的最差红黑树虽然可能，但并不容 易。如果你喜欢数学，你也许会喜欢在练习 3.3.24 中探究这个问题 的答案。</p>
<p>&emsp;&emsp;这个上界是比较保守的。使用随机的键序列和典型应用中常见的键序列 进行的实验都证明，在一棵大小为N的红黑树中一次查找所需的比较 次数约为（1.00lgN - 0.5）。另外，在实际情况下你不太可能遇到比这个数字高得多的平均比较次数，如表 3.3.1 所示。</p>
<p><img src="https://pic-1258215793.cos.ap-shanghai.myqcloud.com/content/20191101/201911010128.png" alt="使用RedBlackBST的FrequencyCounter的每次put()操作平均所需的比较次数"></p>
<p>&emsp;&emsp;命题H。一棵大小为N的红黑树中，根结点到任意结点的平均路径长度为~1.00lgN。</p>
<p>&emsp;&emsp;例证。和典型的二叉查找树（例如图 3.2.8 中所示的树）相比，一棵典型的红黑树的平衡性是很好的，例如图 3.3.27 所示（甚至是图 3.3.28 中由升序键列构造的红黑树）。表 3.3.1 显示的数据表明FrequencyCounter在运行中构造的红黑树的路径长度（即查找成本）比初等二叉查找树低40%左右，和预期相符。自红黑树的发明以来，无数的实验和实际应用都印证了这种性能改进。</p>
<p><img src="https://pic-1258215793.cos.ap-shanghai.myqcloud.com/content/20191101/201911010129.png" alt="使用升序键列构造的一棵红黑树，没有画出空链接"></p>
<p>&emsp;&emsp;以使用 FrequencyCounter 在处理长度大于等于8的单词时put()操作的成本为例，我们可以看到平均成本降低得更多（如图 3.3.29 所示）。这又一次验证了理论模型所预测的对数级别的运行时间，只不过这次的惊喜比二叉查找树的小，因为性质G已经向我们保证了这一点。节约的总成本低于在查找上节约的40%的成本，因为除了比较我们也统计了旋转和颜色变换的次数。</p>
<p><img src="https://pic-1258215793.cos.ap-shanghai.myqcloud.com/content/20191101/201911010130.png" alt="使用RedBlackBST，运行java FrequencyCounter 8 &lt; tale.txt的成本"></p>
<p>&emsp;&emsp;红黑树的get()方法不会检查结点的颜色，因此平衡性相关的操作不会产生任何负担；因为树是平衡的，所以查找比二叉查找树更快。每个键只会被插入一次，但却可能被查找无数次，因此最后我们只用了很小的代价（和二分查找不同，我们可以保证插入操作是对数级别的）就取得了和最优情况近似的查找时间（因为树是接近完美平衡的，且查找过程中不会进行任何平衡性的操作）。查找的内循环只会进行一次比较并更新一条链接，非常简短，和二分查找的内循环类似（只有比较和索引运算）。这是我们见到的第一个能够保证对数级别的查找和插入操作的实现，它的内循环更紧凑。它通过了各种应用的考验，包括许多库实现。</p>
<h3 id="5-2-有序符号表API"><a href="#5-2-有序符号表API" class="headerlink" title="5.2 有序符号表API"></a><strong>5.2 有序符号表API</strong></h3><p>&emsp;&emsp;红黑树最吸引人的一点是它的实现中最复杂的代码仅限于 put()（和删除）方法。二叉查找树中的查找最大和最小 键、select()、rank()、floor()、ceiling() 和范围查找方法不做任何变动即可继续使用，因为红黑树也是二叉查找树而这些操作也不会涉及结点的颜色。算法 3.4 和这些方法（以及删除方法）一起完整地实现了我们的有序符号表 API。这些方法都能从红黑树近乎完美的平衡性中受益，因为它们最多所需的时间都和树高成正比。因此命题G和命题E一起保证了所有操作的运行时间是对数级别的。</p>
<p>&emsp;&emsp;命题I。在一棵红黑树中，以下操作在最坏情况下所需的时间是对数级别的：查找（get()）、插入（put()）、查找最小键、查找最大键、floor()、ceiling()、rank()、select()、删除最小键（deleteMin()）、删除最大键（deleteMax()）、删除（delete()）和范围查询（range()）。</p>
<p>&emsp;&emsp;证明。我们已经讨论过 put()、get() 和 delete() 方法。对于其他方法，代码可以从3.2节中照搬（它们不涉及结点颜色）。命题G和命题E可以保证算法是对数级别的，所有操作在所经过的结点上只会进行常数次数的操作也说明了这一点。</p>
<p>&emsp;&emsp;各种符号表实现的性能总结如表 3.3.2 所示。</p>
<p><img src="https://pic-1258215793.cos.ap-shanghai.myqcloud.com/content/20191101/201911010131.png" alt="各种符号表实现的性能总结"></p>
<p>&emsp;&emsp;想想看，这样的保证是一个非凡的成就。在信息世界的汪洋大海中，表的大小可能上千亿，但我们仍能够确保在几十次比较之内就完成这些操作。</p>
<h3 id="5-3-答疑"><a href="#5-3-答疑" class="headerlink" title="5.3 答疑"></a><strong>5.3 答疑</strong></h3><blockquote>
<ul>
<li>问　为什么不允许存在红色右链接和4-结点？</li>
<li>答　它们都是可用的，并且已经应用了几十年了。在练习中你会遇到它们。只允许红色左链接的存在能够减少可能出现的情况，因此实现所需的代码会少得多。</li>
</ul>
</blockquote>
<blockquote>
<ul>
<li>问　为什么不在Node类型中使用一个Key类型的数组来表示2-结点、 3-结点和4-结点？</li>
<li>答　问得好。这正是我们在B-树（请见第６章）的实现中使用的方案，它的每个结点中可以保存更多的键。因为2-3树中的结点较少，数组所带来的额外开销太高了。</li>
</ul>
</blockquote>
<blockquote>
<ul>
<li>问　在分解一个4-结点时，我们有时会在 rotateRight() 中将右结点的颜色设为RED（红）然后立即在 flipColors() 中将它的颜色变为BLACK（黑）。这不是浪费时间吗？</li>
<li>答　是的，有时我们还会不必要地反复改变中结点的颜色。从整体来看，多余的几次颜色变换和将所有方法的运行时间的增长数量级从线性级别提升到对数级别不是一个级别的。当然，在有性能要求的应用中，你可以将 rotateRight() 和 flipColors() 的代码在所需要的地方展开来消除那些额外的开销。我们在删除中也会使用这两个方法。在能够保证树的完美平衡的前提下，它们更加容易使用、理解和维护。</li>
</ul>
</blockquote>
<hr>
<p><em>参考博客和文章书籍等：</em></p>
<blockquote>
<p>《算法 第4版》</p>
</blockquote>
<p><em>因博客主等未标明不可引用，若部分内容涉及侵权请及时告知，我会尽快修改和删除相关内容</em></p>

      
    </div>
    
    
    

    

    

    

    
      <div>
         ﻿<div>
    
        <div style="text-align:center;color: #ccc;font-size:14px;">-------------本文结束<i class="fa fa-paw"></i>感谢您的阅读-------------</div>
    
</div>

      </div>
    
    
    <footer class="post-footer">
      
        <div class="post-tags">
          
            <a href="/tags/algorithm/" rel="tag"># algorithm</a>
          
        </div>
      

      
      
      

      
        <div class="post-nav">
          <div class="post-nav-next post-nav-item">
            
              <a href="/2019110601.html" rel="next" title="ConcurrentHashMap源码解读-1.8版">
                <i class="fa fa-chevron-left"></i> ConcurrentHashMap源码解读-1.8版
              </a>
            
          </div>

          <span class="post-nav-divider"></span>

          <div class="post-nav-prev post-nav-item">
            
              <a href="/2019110901.html" rel="prev" title="SpringBoot入门">
                SpringBoot入门 <i class="fa fa-chevron-right"></i>
              </a>
            
          </div>
        </div>
      

      
      
    </footer>
  </div>
  
  
  
  </article>



    <div class="post-spread">
      
    </div>
  </div>


          </div>
          


          

  
     <div class="comments" id="comments">
       

<script src="https://utteranc.es/client.js"
        repo="LAILAIWA/LAILAIWA.github.io"
        issue-term="pathname"
        label="💬Comments"
        theme="github-light"
        crossorigin="anonymous"
        async>
</script>



     </div>
  



        </div>
        
          
  
  <div class="sidebar-toggle">
    <div class="sidebar-toggle-line-wrap">
      <span class="sidebar-toggle-line sidebar-toggle-line-first"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-middle"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-last"></span>
    </div>
  </div>

  <aside id="sidebar" class="sidebar">
    
    <div class="sidebar-inner">

      

      
        <ul class="sidebar-nav motion-element">
          <li class="sidebar-nav-toc sidebar-nav-active" data-target="post-toc-wrap">
            文章目录
          </li>
          <li class="sidebar-nav-overview" data-target="site-overview-wrap">
            站点概览
          </li>
        </ul>
      

      <section class="site-overview-wrap sidebar-panel">
        <div class="site-overview">
          <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
            
              <img class="site-author-image" itemprop="image"
                src="https://pic-1258215793.cos.ap-shanghai.myqcloud.com/cover/riho_yoshioka1.jpg"
                alt="沂水" />
            
              <p class="site-author-name" itemprop="name">沂水</p>
              <p class="site-description motion-element" itemprop="description">记录编程点滴，写点生活中的酸甜</p>
          </div>

          <nav class="site-state motion-element">

            
              <div class="site-state-item site-state-posts">
              
                <a href="/archives/">
              
                  <span class="site-state-item-count">238</span>
                  <span class="site-state-item-name">日志</span>
                </a>
              </div>
            

            
              
              
              <div class="site-state-item site-state-categories">
                <a href="/categories/index.html">
                  <span class="site-state-item-count">8</span>
                  <span class="site-state-item-name">分类</span>
                </a>
              </div>
            

            
              
              
              <div class="site-state-item site-state-tags">
                <a href="/tags/index.html">
                  <span class="site-state-item-count">84</span>
                  <span class="site-state-item-name">标签</span>
                </a>
              </div>
            

          </nav>

          
            <div class="feed-link motion-element">
              <a href="/atom.xml" rel="alternate">
                <i class="fa fa-rss"></i>
                RSS
              </a>
            </div>
          

          
            <div class="links-of-author motion-element">
                
                  <span class="links-of-author-item">
                    <a href="https://github.com/LAILAIWA" target="_blank" title="GitHub">
                      
                        <i class="fa fa-fw fa-github"></i>GitHub</a>
                  </span>
                
                  <span class="links-of-author-item">
                    <a href="mailto:linyishui168@outlook.com" target="_blank" title="E-Mail">
                      
                        <i class="fa fa-fw fa-envelope"></i>E-Mail</a>
                  </span>
                
                  <span class="links-of-author-item">
                    <a href="https://instagram.com/linyishui618" target="_blank" title="Instagram">
                      
                        <i class="fa fa-fw fa-instagram"></i>Instagram</a>
                  </span>
                
                  <span class="links-of-author-item">
                    <a href="https://weibo.com/u/5340162234" target="_blank" title="Weibo">
                      
                        <i class="fa fa-fw fa-weibo.com"></i>Weibo</a>
                  </span>
                
            </div>
          

          
          

          
          

          
        </div>
      </section>

      
      <!--noindex-->
        <section class="post-toc-wrap motion-element sidebar-panel sidebar-panel-active">
          <div class="post-toc">

            
              
            

            
              <div class="post-toc-content"><ol class="nav"><li class="nav-item nav-level-1"><a class="nav-link" href="#平衡查找树"><span class="nav-number">1.</span> <span class="nav-text">平衡查找树</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#第一节-2-3查找树"><span class="nav-number">1.1.</span> <span class="nav-text">第一节 2-3查找树</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#1-1-查找"><span class="nav-number">1.1.1.</span> <span class="nav-text">1.1 查找</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#1-2-向2-结点中插入新键"><span class="nav-number">1.1.2.</span> <span class="nav-text">1.2 向2-结点中插入新键</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#1-3-向一棵只含有一个3-结点的树中插入新键"><span class="nav-number">1.1.3.</span> <span class="nav-text">1.3 向一棵只含有一个3-结点的树中插入新键</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#1-4-向一个父结点为2-结点的3-结点中插入新键"><span class="nav-number">1.1.4.</span> <span class="nav-text">1.4 向一个父结点为2-结点的3-结点中插入新键</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#1-5-向一个父结点为3-结点的3-结点中插入新键"><span class="nav-number">1.1.5.</span> <span class="nav-text">1.5 向一个父结点为3-结点的3-结点中插入新键</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#1-6-分解根结点"><span class="nav-number">1.1.6.</span> <span class="nav-text">1.6 分解根结点</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#1-7-局部变换"><span class="nav-number">1.1.7.</span> <span class="nav-text">1.7 局部变换</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#1-8-全局性质"><span class="nav-number">1.1.8.</span> <span class="nav-text">1.8 全局性质</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#1-9-性能分析"><span class="nav-number">1.1.9.</span> <span class="nav-text">1.9 性能分析</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#第二节-红黑查找树"><span class="nav-number">1.2.</span> <span class="nav-text">第二节 红黑查找树</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#2-1-替换3-结点"><span class="nav-number">1.2.1.</span> <span class="nav-text">2.1 替换3-结点</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#2-2-一种等价的定义"><span class="nav-number">1.2.2.</span> <span class="nav-text">2.2 一种等价的定义</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#2-3-一一对应"><span class="nav-number">1.2.3.</span> <span class="nav-text">2.3 一一对应</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#2-4-颜色表示"><span class="nav-number">1.2.4.</span> <span class="nav-text">2.4 颜色表示</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#2-5-旋转"><span class="nav-number">1.2.5.</span> <span class="nav-text">2.5 旋转</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#2-6-在旋转后重置父结点的链接"><span class="nav-number">1.2.6.</span> <span class="nav-text">2.6 在旋转后重置父结点的链接</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#2-7-向单个2-结点中插入新键"><span class="nav-number">1.2.7.</span> <span class="nav-text">2.7 向单个2-结点中插入新键</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#2-8-向树底部的2-结点插入新键"><span class="nav-number">1.2.8.</span> <span class="nav-text">2.8 向树底部的2-结点插入新键</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#2-9-向一棵双键树（即一个3-结点）中插入新键"><span class="nav-number">1.2.9.</span> <span class="nav-text">2.9 向一棵双键树（即一个3-结点）中插入新键</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#2-10-颜色转换"><span class="nav-number">1.2.10.</span> <span class="nav-text">2.10 颜色转换</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#2-11-根结点总是黑色"><span class="nav-number">1.2.11.</span> <span class="nav-text">2.11 根结点总是黑色</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#2-12-向树底部的3-结点插入新键"><span class="nav-number">1.2.12.</span> <span class="nav-text">2.12 向树底部的3-结点插入新键</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#2-13-将红链接在树中向上传递"><span class="nav-number">1.2.13.</span> <span class="nav-text">2.13 将红链接在树中向上传递</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#第三节-实现"><span class="nav-number">1.3.</span> <span class="nav-text">第三节 实现</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#第四节-删除操作"><span class="nav-number">1.4.</span> <span class="nav-text">第四节 删除操作</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#4-1-自顶向下的2-3-4树"><span class="nav-number">1.4.1.</span> <span class="nav-text">4.1 自顶向下的2-3-4树</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#4-2-删除最小键"><span class="nav-number">1.4.2.</span> <span class="nav-text">4.2 删除最小键</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#4-3-删除操作"><span class="nav-number">1.4.3.</span> <span class="nav-text">4.3 删除操作</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#第五节-红黑树的性质"><span class="nav-number">1.5.</span> <span class="nav-text">第五节 红黑树的性质</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#5-1-性能分析"><span class="nav-number">1.5.1.</span> <span class="nav-text">5.1 性能分析</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#5-2-有序符号表API"><span class="nav-number">1.5.2.</span> <span class="nav-text">5.2 有序符号表API</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#5-3-答疑"><span class="nav-number">1.5.3.</span> <span class="nav-text">5.3 答疑</span></a></li></ol></li></ol></li></ol></div>
            

          </div>
        </section>
      <!--/noindex-->
      

      

    </div>
  </aside>


        
      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="footer-inner">
        ﻿<script async src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script>
<div class="copyright">&copy; <span itemprop="copyrightYear">2020</span>
  <span class="with-love">
    <i class="fa fa-user"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">沂水</span>

  
</div>

<div class="powered-by">
  <i class="fa fa-user-md">
  </i>
  <span id="busuanzi_container_site_pv">本站总访问量<span id="busuanzi_value_site_pv"></span>次</span>
</div>

<!-- 

  <div class="powered-by">由 <a class="theme-link" target="_blank" href="https://hexo.io">Hexo</a> 强力驱动</div>



  <span class="post-meta-divider">|</span>



  <div class="theme-info">主题 &mdash; <a class="theme-link" target="_blank" href="https://github.com/iissnan/hexo-theme-next">NexT.Pisces</a> v5.1.4</div>

-->



        







        
      </div>
    </footer>

    
      <div class="back-to-top">
        <i class="fa fa-arrow-up"></i>
        
      </div>
    

    
   <script src="/live2dw/lib/L2Dwidget.min.js?094cbace49a39548bed64abff5988b05"></script><script>L2Dwidget.init({"tagMode":true,"model":{"jsonPath":"/live2dw/assets/shizuku.model.json"},"display":{"position":"left","width":125,"height":250},"mobile":{"show":false},"log":false,"pluginJsPath":"lib/","pluginModelPath":"assets/","pluginRootPath":"live2dw/"});</script>

  </div>

  

<script type="text/javascript">
  if (Object.prototype.toString.call(window.Promise) !== '[object Function]') {
    window.Promise = null;
  }
</script>









  


  











  
  
    <script type="text/javascript" src="/lib/jquery/index.js?v=2.1.3"></script>
  

  
  
    <script type="text/javascript" src="/lib/fastclick/lib/fastclick.min.js?v=1.0.6"></script>
  

  
  
    <script type="text/javascript" src="/lib/jquery_lazyload/jquery.lazyload.js?v=1.9.7"></script>
  

  
  
    <script type="text/javascript" src="/lib/velocity/velocity.min.js?v=1.2.1"></script>
  

  
  
    <script type="text/javascript" src="/lib/velocity/velocity.ui.min.js?v=1.2.1"></script>
  

  
  
    <script type="text/javascript" src="/lib/fancybox/source/jquery.fancybox.pack.js?v=2.1.5"></script>
  

  
  
    <script type="text/javascript" src="/lib/canvas-nest/canvas-nest.min.js"></script>
  


  


  <script type="text/javascript" src="/js/src/utils.js?v=5.1.4"></script>

  <script type="text/javascript" src="/js/src/motion.js?v=5.1.4"></script>



  
  


  <script type="text/javascript" src="/js/src/affix.js?v=5.1.4"></script>

  <script type="text/javascript" src="/js/src/schemes/pisces.js?v=5.1.4"></script>



  
  <script type="text/javascript" src="/js/src/scrollspy.js?v=5.1.4"></script>
<script type="text/javascript" src="/js/src/post-details.js?v=5.1.4"></script>



  


  <script type="text/javascript" src="/js/src/bootstrap.js?v=5.1.4"></script>



  


  




	





  





  












  





  

  

  

  
  

  

  

  

</body>
</html>
