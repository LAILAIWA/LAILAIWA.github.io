<!DOCTYPE html>
<html lang="zh-CN">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width">
<meta name="theme-color" content="#222">
<meta name="generator" content="Hexo 5.4.0">


  <link rel="apple-touch-icon" sizes="180x180" href="/images/gamepad%20playstation.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/Dig%20Dug.ico">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/gamepad%20playstation.png">
  <link rel="mask-icon" href="/images/gamepad%20playstation.svg" color="#222">

<link rel="stylesheet" href="/css/main.css">

<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Monda:300,300italic,400,400italic,700,700italic%7CMa+Shan+Zheng:300,300italic,400,400italic,700,700italic%7CNoto+Serif+SC:300,300italic,400,400italic,700,700italic&display=swap&subset=latin,latin-ext">

<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free@5.15.3/css/all.min.css" integrity="sha256-2H3fkXt6FEmrReK448mDVGKb3WW2ZZw35gI7vqHOE4Y=" crossorigin="anonymous">
  <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/animate.css@3.1.1/animate.min.css" integrity="sha256-PR7ttpcvz8qrF57fur/yAx1qXMFJeJFiA6pSzWi0OIE=" crossorigin="anonymous">
  <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@3.5.7/dist/jquery.fancybox.min.css" integrity="sha256-Vzbj7sDDS/woiFS3uNKo8eIuni59rjyNGtXfstRzStA=" crossorigin="anonymous">
  <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/nprogress@0.2.0/nprogress.css" integrity="sha256-no0c5ccDODBwp+9hSmV5VvPpKwHCpbVzXHexIkupM6U=" crossorigin="anonymous">
  <script src="https://cdn.jsdelivr.net/npm/nprogress@0.2.0/nprogress.js" integrity="sha256-a5YRB27CcBwBFcT5EF/f3E4vzIqyHrSR878nseNYw64=" crossorigin="anonymous"></script>

<script class="next-config" data-name="main" type="application/json">{"hostname":"linyishui.top","root":"/","images":"/images","scheme":"Pisces","version":"8.6.0","exturl":false,"sidebar":{"position":"left","display":"always","padding":18,"offset":12},"copycode":true,"bookmark":{"enable":true,"color":"#222","save":"manual"},"fancybox":true,"mediumzoom":false,"lazyload":false,"pangu":false,"comments":{"style":"tabs","active":"utterances","storage":true,"lazyload":false,"nav":null,"activeClass":"utterances"},"motion":{"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"fadeInDown","post_body":"fadeInDown","coll_header":"fadeInLeft","sidebar":"fadeInUp"}},"prism":false,"i18n":{"placeholder":"搜索...","empty":"没有找到任何搜索结果：${query}","hits_time":"找到 ${hits} 个搜索结果（用时 ${time} 毫秒）","hits":"找到 ${hits} 个搜索结果"},"path":"/search.xml","localsearch":{"enable":true,"trigger":"auto","top_n_per_article":1,"unescape":false,"preload":false}}</script><script src="/js/config.js"></script>
<meta name="description" content="整理面试中常问的Java基础相关问题，持续更新中。">
<meta property="og:type" content="article">
<meta property="og:title" content="面试整理——Java基础">
<meta property="og:url" content="http://linyishui.top/2019102002.html">
<meta property="og:site_name" content="俺的部落格">
<meta property="og:description" content="整理面试中常问的Java基础相关问题，持续更新中。">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="https://pic-1258215793.cos.ap-shanghai.myqcloud.com/content/20200501/202005010137.jpg">
<meta property="article:published_time" content="2019-10-20T08:05:59.000Z">
<meta property="article:modified_time" content="2025-02-04T12:23:09.529Z">
<meta property="article:author" content="Lys">
<meta property="article:tag" content="Q&amp;A">
<meta property="article:tag" content="updating">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://pic-1258215793.cos.ap-shanghai.myqcloud.com/content/20200501/202005010137.jpg">


<link rel="canonical" href="http://linyishui.top/2019102002.html">



<script class="next-config" data-name="page" type="application/json">{"sidebar":"","isHome":false,"isPost":true,"lang":"zh-CN","comments":true,"permalink":"http://linyishui.top/2019102002.html","path":"2019102002.html","title":"面试整理——Java基础"}</script>

<script class="next-config" data-name="calendar" type="application/json">""</script>
<title>面试整理——Java基础 | 俺的部落格</title>
  




  <noscript>
    <link rel="stylesheet" href="/css/noscript.css">
  </noscript>
<link rel="alternate" href="/atom.xml" title="俺的部落格" type="application/atom+xml">
<style>.darkmode--activated{--body-bg-color:#282828;--content-bg-color:#333;--card-bg-color:#555;--text-color:#ccc;--blockquote-color:#bbb;--link-color:#ccc;--link-hover-color:#eee;--brand-color:#ddd;--brand-hover-color:#ddd;--table-row-odd-bg-color:#282828;--table-row-hover-bg-color:#363636;--menu-item-bg-color:#555;--btn-default-bg:#222;--btn-default-color:#ccc;--btn-default-border-color:#555;--btn-default-hover-bg:#666;--btn-default-hover-color:#ccc;--btn-default-hover-border-color:#666;--highlight-background:#282b2e;--highlight-foreground:#a9b7c6;--highlight-gutter-background:#34393d;--highlight-gutter-foreground:#9ca9b6}.darkmode--activated img{opacity:.75}.darkmode--activated img:hover{opacity:.9}.darkmode--activated code{color:#69dbdc;background:0 0}button.darkmode-toggle{z-index:9999}</style></head>

<body itemscope itemtype="http://schema.org/WebPage" class="use-motion">
  <div class="headband"></div>

  <main class="main">
    <header class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="切换导航栏" role="button">
        <span class="toggle-line"></span>
        <span class="toggle-line"></span>
        <span class="toggle-line"></span>
    </div>
  </div>

  <div class="site-meta">

    <a href="/" class="brand" rel="start">
      <i class="logo-line"></i>
      <h1 class="site-title">俺的部落格</h1>
      <i class="logo-line"></i>
    </a>
      <p class="site-subtitle" itemprop="description">俺寻思俺需要记点东西</p>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger">
        <i class="fa fa-search fa-fw fa-lg"></i>
    </div>
  </div>
</div>



<nav class="site-nav">
  <ul class="main-menu menu">
        <li class="menu-item menu-item-home"><a href="/" rel="section"><i class="fa fa-home fa-fw"></i>首页</a></li>
        <li class="menu-item menu-item-about"><a href="/about/" rel="section"><i class="fa fa-user fa-fw"></i>关于</a></li>
        <li class="menu-item menu-item-tags"><a href="/tags/" rel="section"><i class="fa fa-tags fa-fw"></i>标签</a></li>
        <li class="menu-item menu-item-categories"><a href="/categories/" rel="section"><i class="fa fa-th fa-fw"></i>分类</a></li>
        <li class="menu-item menu-item-archives"><a href="/archives/" rel="section"><i class="fa fa-archive fa-fw"></i>归档</a></li>
        <li class="menu-item menu-item-sitemap"><a href="/sitemap.xml" rel="section"><i class="fa fa-sitemap fa-fw"></i>站点地图</a></li>
        <li class="menu-item menu-item-tools"><a href="/links/" rel="section"><i class="fa fa-link fa-fw"></i>工具</a></li>
        <li class="menu-item menu-item-books"><a href="/books/" rel="section"><i class="fa fa-book fa-fw"></i>书架</a></li>
        <li class="menu-item menu-item-movies"><a href="/movies/" rel="section"><i class="fa fa-video fa-fw"></i>剧院</a></li>
        <li class="menu-item menu-item-games"><a href="/games/" rel="section"><i class="fa fa-gamepad fa-fw"></i>游戏</a></li>
        <li class="menu-item menu-item-commonweal"><a href="/404/" rel="section"><i class="fa fa-heartbeat fa-fw"></i>公益</a></li>
      <li class="menu-item menu-item-search">
        <a role="button" class="popup-trigger"><i class="fa fa-search fa-fw"></i>搜索
        </a>
      </li>
  </ul>
</nav>



  <div class="search-pop-overlay">
    <div class="popup search-popup"><div class="search-header">
  <span class="search-icon">
    <i class="fa fa-search"></i>
  </span>
  <div class="search-input-container">
    <input autocomplete="off" autocapitalize="off" maxlength="80"
           placeholder="搜索..." spellcheck="false"
           type="search" class="search-input">
  </div>
  <span class="popup-btn-close" role="button">
    <i class="fa fa-times-circle"></i>
  </span>
</div>
<div class="search-result-container no-result">
  <div class="search-result-icon">
    <i class="fa fa-spinner fa-pulse fa-5x"></i>
  </div>
</div>

    </div>
  </div>

</div>
        
  
  <div class="toggle sidebar-toggle" role="button">
    <span class="toggle-line"></span>
    <span class="toggle-line"></span>
    <span class="toggle-line"></span>
  </div>

  <aside class="sidebar">

    <div class="sidebar-inner sidebar-nav-active sidebar-toc-active">
      <ul class="sidebar-nav">
        <li class="sidebar-nav-toc">
          文章目录
        </li>
        <li class="sidebar-nav-overview">
          站点概览
        </li>
      </ul>

      <div class="sidebar-panel-container">
        <!--noindex-->
        <div class="post-toc-wrap sidebar-panel">
            <div class="post-toc animated"><ol class="nav"><li class="nav-item nav-level-1"><a class="nav-link" href="#Java%E5%9F%BA%E7%A1%80"><span class="nav-text">Java基础</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#%E4%B8%80-%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1"><span class="nav-text">一. 面向对象</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E9%97%AE%EF%BC%9A%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E7%9A%84%E4%B8%89%E5%A4%A7%E7%89%B9%E6%80%A7%EF%BC%9F%E5%88%86%E5%88%AB%E6%98%AF%E6%80%8E%E4%B9%88%E4%BD%BF%E7%94%A8%E7%9A%84%EF%BC%8C%E7%BB%99%E4%B8%AA%E4%BE%8B%E5%AD%90"><span class="nav-text">问：面向对象的三大特性？分别是怎么使用的，给个例子?</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E9%97%AE%EF%BC%9A%E5%A4%9A%E6%80%81%E7%9A%84%E5%8E%9F%E7%90%86%E6%98%AF%E4%BB%80%E4%B9%88%EF%BC%9F"><span class="nav-text">问：多态的原理是什么？</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E9%97%AE%EF%BC%9A%E8%AE%B2%E4%B8%80%E4%B8%8B%E9%87%8D%E8%BD%BD%E5%92%8C%E9%87%8D%E5%86%99"><span class="nav-text">问：讲一下重载和重写?</span></a></li></ol></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E4%BA%8C-%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B"><span class="nav-text">二. 数据类型</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E9%97%AE%EF%BC%9AJava%E7%9A%84%E5%9F%BA%E6%9C%AC%E7%B1%BB%E5%9E%8B%E6%9C%89%E5%93%AA%E5%87%A0%E4%B8%AA%EF%BC%9F%E5%90%84%E8%87%AA%E5%8D%A0%E4%BA%86%E5%A4%9A%E5%B0%91%E4%BD%8D%EF%BC%9F%E4%B8%80%E4%B8%AAchar%E8%83%BD%E6%94%BE%E4%B8%80%E4%B8%AA%E6%B1%89%E5%AD%97%E5%90%97%EF%BC%9F"><span class="nav-text">问：Java的基本类型有哪几个？各自占了多少位？一个char能放一个汉字吗？</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E9%97%AE%EF%BC%9A%E5%9F%BA%E6%9C%AC%E7%B1%BB%E5%9E%8B%E5%92%8C%E5%8C%85%E8%A3%85%E7%B1%BB%E5%9E%8B%E7%9A%84%E5%8C%BA%E5%88%AB%EF%BC%9F%E6%B6%89%E5%8F%8A%E8%87%AA%E5%8A%A8%E8%A3%85%E7%AE%B1%E5%92%8C%E6%8B%86%E7%AE%B1%EF%BC%8C%E6%80%8E%E4%B9%88%E5%81%9A%E7%9A%84%EF%BC%8C%E5%8E%9F%E7%90%86%EF%BC%9F"><span class="nav-text">问：基本类型和包装类型的区别？涉及自动装箱和拆箱，怎么做的，原理？</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E9%97%AE%EF%BC%9A%E4%BC%A0%E5%80%BC%E5%92%8C%E4%BC%A0%E5%BC%95%E7%94%A8%E7%9A%84%E5%8C%BA%E5%88%AB%EF%BC%9F%E4%B8%BA%E4%BB%80%E4%B9%88%E8%AF%B4Java%E5%8F%AA%E6%9C%89%E5%80%BC%E4%BC%A0%E9%80%92%EF%BC%9F"><span class="nav-text">问：传值和传引用的区别？为什么说Java只有值传递？</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E9%97%AE%EF%BC%9A%E8%B4%A7%E5%B8%81%E7%94%A8%E5%93%AA%E7%A7%8D%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B%EF%BC%9F"><span class="nav-text">问：货币用哪种数据类型？</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E9%97%AE%EF%BC%9Ai-%E5%92%8C-i-%E7%9A%84%E5%8C%BA%E5%88%AB%EF%BC%9F"><span class="nav-text">问：i++ 和 ++i 的区别？</span></a></li></ol></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E4%B8%89-%E5%85%B3%E9%94%AE%E5%AD%97"><span class="nav-text">三. 关键字</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E9%97%AE%EF%BC%9A%E8%AE%B2%E8%AE%B2Java%E4%B8%AD%E7%94%A8%E6%9D%A5%E6%8F%8F%E8%BF%B0%E4%BD%9C%E7%94%A8%E5%9F%9F%E7%9A%84%E4%BF%AE%E9%A5%B0%E7%AC%A6%EF%BC%9F"><span class="nav-text">问：讲讲Java中用来描述作用域的修饰符？</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E9%97%AE%EF%BC%9Aassert%EF%BC%9F"><span class="nav-text">问：assert？</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E9%97%AE%EF%BC%9AJava%E6%9C%89%E5%93%AA%E5%87%A0%E7%A7%8D%E7%A7%BB%E4%BD%8D%E8%BF%90%E7%AE%97%E7%AC%A6%EF%BC%9F"><span class="nav-text">问：Java有哪几种移位运算符？</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E9%97%AE%EF%BC%9ASwitch-%E6%98%AF%E5%90%A6%E8%83%BD%E4%BD%9C%E7%94%A8%E5%9C%A8-Byte-%E4%B8%8A%EF%BC%8C%E6%98%AF%E5%90%A6%E8%83%BD%E4%BD%9C%E7%94%A8%E5%9C%A8-Long-%E4%B8%8A%EF%BC%8C%E6%98%AF%E5%90%A6%E8%83%BD%E4%BD%9C%E7%94%A8%E5%9C%A8-String-%E4%B8%8A-%EF%BC%9F"><span class="nav-text">问：Switch 是否能作用在 Byte 上，是否能作用在 Long 上，是否能作用在 String 上 ？</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E9%97%AE%EF%BC%9Aswitch%E3%80%81if-else%E3%80%81map%E7%9A%84%E5%AF%B9%E6%AF%94%EF%BC%9F"><span class="nav-text">问：switch、if-else、map的对比？</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E9%97%AE%EF%BC%9A%E8%B0%88%E8%B0%88-final-finally-finalize-%EF%BC%9F"><span class="nav-text">问：谈谈 final, finally, finalize ？</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E9%97%AE%EF%BC%9A%E8%B0%88%E8%B0%88-static-%EF%BC%9F%E4%BB%A5%E5%8F%8A%E4%B8%BA%E4%BB%80%E4%B9%88Java%E4%B8%8D%E5%85%81%E8%AE%B8%E9%9D%99%E6%80%81%E6%96%B9%E6%B3%95%E8%AE%BF%E9%97%AE%E9%9D%9E%E9%9D%99%E6%80%81%E5%8F%98%E9%87%8F"><span class="nav-text">问：谈谈 static ？以及为什么Java不允许静态方法访问非静态变量?</span></a></li></ol></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%9B%9B-%E5%AD%97%E7%AC%A6%E4%B8%B2%E5%92%8C%E5%AF%B9%E8%B1%A1"><span class="nav-text">四. 字符串和对象</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E9%97%AE%EF%BC%9AString%E6%98%AF%E4%B8%8D%E6%98%AFjava%E7%9A%84%E5%9F%BA%E6%9C%AC%E7%B1%BB%E5%9E%8B%EF%BC%9F"><span class="nav-text">问：String是不是java的基本类型？</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E9%97%AE%EF%BC%9AString%E4%B8%BA%E4%BB%80%E4%B9%88%E8%A6%81%E6%98%AFfinal%E7%B1%BB%E5%9E%8B%E7%9A%84%EF%BC%9F"><span class="nav-text">问：String为什么要是final类型的？</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E9%97%AE%EF%BC%9AString%EF%BC%8CStringBuffer%EF%BC%8CStringBuilder%E7%9A%84%E5%8C%BA%E5%88%AB%EF%BC%9F"><span class="nav-text">问：String，StringBuffer，StringBuilder的区别？</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E9%97%AE%EF%BC%9A%E4%BA%AB%E5%85%83%E6%A8%A1%E5%BC%8F%EF%BC%9F"><span class="nav-text">问：享元模式？</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E9%97%AE%EF%BC%9A%E5%AD%97%E7%AC%A6%E4%B8%B2%E7%BC%96%E7%A0%81%E7%9A%84%E5%8C%BA%E5%88%AB%EF%BC%9F"><span class="nav-text">问：字符串编码的区别？</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E9%97%AE%EF%BC%9Achar-%E5%9E%8B%E5%8F%98%E9%87%8F%E4%B8%AD%E8%83%BD%E4%B8%8D%E8%83%BD%E5%AD%98%E8%B4%AE%E4%B8%80%E4%B8%AA%E4%B8%AD%E6%96%87%E6%B1%89%E5%AD%97%EF%BC%9F"><span class="nav-text">问：char 型变量中能不能存贮一个中文汉字？</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E9%97%AE%EF%BC%9A%E7%AE%80%E5%8D%95%E6%8F%8F%E8%BF%B0String%E7%9A%84%E5%8E%9F%E7%94%9F%E6%96%B9%E6%B3%95intern%EF%BC%9F"><span class="nav-text">问：简单描述String的原生方法intern？</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E9%97%AE%EF%BC%9A%E5%88%9B%E5%BB%BA%E5%AD%97%E7%AC%A6%E4%B8%B2%E6%97%B6%E7%9A%84%E5%86%85%E9%83%A8%E6%B5%81%E7%A8%8B%EF%BC%9F%E4%B8%A4%E7%A7%8D%E5%AD%97%E7%AC%A6%E4%B8%B2%E5%AE%9E%E4%BE%8B%E5%8C%96%E6%96%B9%E5%BC%8F%E5%9C%A8%E5%86%85%E5%AD%98%E5%88%86%E9%85%8D%E4%B8%8A%E6%9C%89%E5%8C%BA%E5%88%AB%E5%90%97%EF%BC%9F"><span class="nav-text">问：创建字符串时的内部流程？两种字符串实例化方式在内存分配上有区别吗？</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E9%97%AE%EF%BC%9A%E8%B0%88%E4%B8%8Bequals%E5%92%8C-%E7%9A%84%E5%8C%BA%E5%88%AB%EF%BC%9Fequals%E5%92%8Chashcode%E7%9A%84%E7%94%A8%E6%B3%95%E5%8F%8A%E5%8C%BA%E5%88%AB%EF%BC%9F%E4%B8%BA%E4%BB%80%E4%B9%88%E9%87%8D%E5%86%99equals%E6%96%B9%E6%B3%95%E6%97%B6%E8%BF%98%E8%A6%81%E9%87%8D%E5%86%99hashcode%E6%96%B9%E6%B3%95%EF%BC%9F"><span class="nav-text">问：谈下equals和&#x3D;&#x3D;的区别？equals和hashcode的用法及区别？为什么重写equals方法时还要重写hashcode方法？</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E9%97%AE%EF%BC%9A%E6%B7%B1%E6%8B%B7%E8%B4%9D%E4%B8%8E%E6%B5%85%E6%8B%B7%E8%B4%9D%EF%BC%9F"><span class="nav-text">问：深拷贝与浅拷贝？</span></a></li></ol></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E4%BA%94-%E7%B1%BB%E4%B8%8E%E6%8E%A5%E5%8F%A3"><span class="nav-text">五. 类与接口</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E9%97%AE%EF%BC%9A%E4%BB%80%E4%B9%88%E6%98%AF%E6%B3%9B%E5%9E%8B%EF%BC%9F%E7%B1%BB%E5%9E%8B%E6%93%A6%E9%99%A4%EF%BC%9F"><span class="nav-text">问：什么是泛型？类型擦除？</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E9%97%AE%EF%BC%9AComparable-%E5%92%8C-Comparator-%E6%8E%A5%E5%8F%A3%E6%98%AF%E5%B9%B2%E4%BB%80%E4%B9%88%E7%9A%84%EF%BC%8C%E5%85%B6%E5%8C%BA%E5%88%AB%EF%BC%9F"><span class="nav-text">问：Comparable 和 Comparator 接口是干什么的，其区别？</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E9%97%AE%EF%BC%9A%E6%8E%A5%E5%8F%A3%E5%92%8C%E6%8A%BD%E8%B1%A1%E7%B1%BB%EF%BC%8C%E4%BD%A0%E6%98%AF%E6%80%8E%E4%B9%88%E7%90%86%E8%A7%A3%E7%9A%84%EF%BC%9F"><span class="nav-text">问：接口和抽象类，你是怎么理解的？</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E9%97%AE%EF%BC%9A%E5%BC%82%E5%B8%B8%E7%B1%BB%EF%BC%9F%E7%BB%A7%E6%89%BF%E7%BB%93%E6%9E%84%EF%BC%9F"><span class="nav-text">问：异常类？继承结构？</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E9%97%AE%EF%BC%9A%E5%8F%97%E6%A3%80%E5%BC%82%E5%B8%B8%E5%92%8C%E8%BF%90%E8%A1%8C%E6%97%B6%E5%BC%82%E5%B8%B8%E7%9A%84%E5%8C%BA%E5%88%AB%EF%BC%9F"><span class="nav-text">问：受检异常和运行时异常的区别？</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E9%97%AE%EF%BC%9AJava%E4%B8%AD%E7%9A%84%E5%BC%82%E5%B8%B8%E5%A4%84%E7%90%86%E6%9C%BA%E5%88%B6%EF%BC%9F"><span class="nav-text">问：Java中的异常处理机制？</span></a></li></ol></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%85%AD-%E6%96%87%E4%BB%B6%E4%B8%8E%E6%B5%81"><span class="nav-text">六. 文件与流</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#6-1-%E6%96%87%E4%BB%B6"><span class="nav-text">6.1 文件</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E9%97%AE%EF%BC%9A%E8%AF%B4%E4%B8%8B%E5%A6%82%E4%BD%95%E6%93%8D%E6%8E%A7%E6%96%87%E4%BB%B6-%EF%BC%88%E8%BE%93%E5%85%A5%E8%BE%93%E5%87%BA%EF%BC%89%E6%80%8E%E4%B9%88%E5%85%B3%E9%97%AD%E5%91%A2-%E5%8F%91%E7%94%9F%E5%BC%82%E5%B8%B8%E6%80%8E%E4%B9%88%E5%8A%9E"><span class="nav-text">问：说下如何操控文件?（输入输出）怎么关闭呢? 发生异常怎么办?</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E9%97%AE%EF%BC%9A%E5%A6%82%E4%BD%95%E6%8F%90%E9%AB%98%E6%96%87%E4%BB%B6%E8%AF%BB%E5%86%99%E7%9A%84%E6%80%A7%E8%83%BD%EF%BC%9F%E5%A6%82%E4%BD%95%E5%A4%84%E7%90%86%E5%A4%A7%E6%96%87%E4%BB%B6%E8%80%8C%E4%B8%8D%E5%AF%BC%E8%87%B4%E5%86%85%E5%AD%98%E6%BA%A2%E5%87%BA%EF%BC%9F"><span class="nav-text">问：如何提高文件读写的性能？如何处理大文件而不导致内存溢出？</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E9%97%AE%EF%BC%9A%E6%96%87%E4%BB%B6%E7%9A%84%E5%BA%8F%E5%88%97%E5%8C%96%E5%92%8C%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96%EF%BC%9F%E5%A6%82%E4%BD%95%E5%9C%A8-Java-%E4%B8%AD%E5%B0%86%E5%AF%B9%E8%B1%A1%E5%BA%8F%E5%88%97%E5%8C%96%E5%88%B0%E6%96%87%E4%BB%B6%E4%B8%AD%EF%BC%9F%E5%A6%82%E4%BD%95%E4%BB%8E%E6%96%87%E4%BB%B6%E4%B8%AD%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96%E5%AF%B9%E8%B1%A1%EF%BC%9F"><span class="nav-text">问：文件的序列化和反序列化？如何在 Java 中将对象序列化到文件中？如何从文件中反序列化对象？</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E9%97%AE%EF%BC%9A%E8%AE%B2%E8%AE%B2%E5%BA%8F%E5%88%97%E5%8C%96%EF%BC%9F"><span class="nav-text">问：讲讲序列化？</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#IO%E6%B5%81"><span class="nav-text">IO流</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E9%97%AE%EF%BC%9A%E8%AE%B2%E8%AE%B2%E4%BD%A0%E6%89%80%E7%9F%A5%E9%81%93%E7%9A%84IO%E6%B5%81%EF%BC%9F"><span class="nav-text">问：讲讲你所知道的IO流？</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E9%97%AE%EF%BC%9A%E8%AE%B2%E8%AE%B2%E5%AD%97%E7%AC%A6%E6%B5%81%E5%92%8C%E5%AD%97%E8%8A%82%E6%B5%81%E7%9A%84%E5%8C%BA%E5%88%AB%EF%BC%9F"><span class="nav-text">问：讲讲字符流和字节流的区别？</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#NIO"><span class="nav-text">NIO</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E9%97%AE%EF%BC%9A%E5%A6%82%E4%BD%95%E7%90%86%E8%A7%A3%E5%90%8C%E6%AD%A5%E5%BC%82%E6%AD%A5%EF%BC%9F%E9%98%BB%E5%A1%9E%E4%B8%8E%E9%9D%9E%E9%98%BB%E5%A1%9E%EF%BC%9F"><span class="nav-text">问：如何理解同步异步？阻塞与非阻塞？</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E9%97%AE%EF%BC%9A%E5%90%8C%E6%AD%A5I-O%E5%92%8C%E5%BC%82%E6%AD%A5I-O%E7%9A%84%E5%8C%BA%E5%88%AB%EF%BC%9F"><span class="nav-text">问：同步I&#x2F;O和异步I&#x2F;O的区别？</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E9%97%AE%EF%BC%9A%E8%B0%88%E8%B0%885%E7%A7%8DIO%E6%A8%A1%E5%9E%8B%EF%BC%9F"><span class="nav-text">问：谈谈5种IO模型？</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E9%97%AE%EF%BC%9A%E4%BB%80%E4%B9%88%E6%98%AFI-O%E5%A4%9A%E8%B7%AF%E5%A4%8D%E7%94%A8%EF%BC%9F%E7%9B%B8%E6%AF%94%E9%9D%9E%E9%98%BB%E5%A1%9EI-O%E4%B8%BA%E4%BD%95%E6%95%88%E7%8E%87%E6%9B%B4%E9%AB%98%EF%BC%9F"><span class="nav-text">问：什么是I&#x2F;O多路复用？相比非阻塞I&#x2F;O为何效率更高？</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E9%97%AE%EF%BC%9A%E7%9F%A5%E9%81%93NIO%E5%90%97%EF%BC%9F%E5%AF%B9%E6%AF%94IO%E7%AE%80%E5%8D%95%E8%B0%88%E4%B8%80%E4%B8%8B%E5%8C%BA%E5%88%AB%EF%BC%9FJava-BIO%E6%98%AF%E4%BB%80%E4%B9%88%EF%BC%9F"><span class="nav-text">问：知道NIO吗？对比IO简单谈一下区别？Java BIO是什么？</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E9%97%AE%EF%BC%9A%E4%BB%80%E4%B9%88%E6%98%AF-Reactor-%E6%A8%A1%E5%9E%8B%EF%BC%9F-Proactor%E4%B8%8EReactor%EF%BC%9F"><span class="nav-text">问：什么是 Reactor 模型？ Proactor与Reactor？</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E9%97%AE%EF%BC%9A%E5%A6%82%E4%BD%95%E4%BD%BF%E7%94%A8-FileChannel-%E8%BF%9B%E8%A1%8C%E6%96%87%E4%BB%B6%E8%AF%BB%E5%86%99%EF%BC%9F%E5%A6%82%E4%BD%95%E4%BD%BF%E7%94%A8-MappedByteBuffer-%E5%AE%9E%E7%8E%B0%E5%86%85%E5%AD%98%E6%98%A0%E5%B0%84%E6%96%87%E4%BB%B6%EF%BC%9F%E5%A6%82%E4%BD%95%E4%BD%BF%E7%94%A8-NIO-%E7%9A%84%E5%BC%82%E6%AD%A5-I-O-%E6%93%8D%E4%BD%9C%EF%BC%9F-%E5%A6%82%E4%BD%95%E4%BD%BF%E7%94%A8-java-nio-file-%E5%8C%85%EF%BC%9F%E5%A6%82%E4%BD%95%E4%BD%BF%E7%94%A8-Files-%E7%B1%BB%E8%AF%BB%E5%8F%96%E5%92%8C%E5%86%99%E5%85%A5%E6%96%87%E4%BB%B6%EF%BC%9F%E5%A6%82%E4%BD%95%E4%BD%BF%E7%94%A8-Path-%E7%B1%BB%E5%A4%84%E7%90%86%E6%96%87%E4%BB%B6%E8%B7%AF%E5%BE%84%EF%BC%9F"><span class="nav-text">问：如何使用 FileChannel 进行文件读写？如何使用 MappedByteBuffer 实现内存映射文件？如何使用 NIO 的异步 I&#x2F;O 操作？ 如何使用 java.nio.file 包？如何使用 Files 类读取和写入文件？如何使用 Path 类处理文件路径？</span></a></li></ol></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E4%B8%83-%E5%8F%8D%E5%B0%84%E4%B8%8E%E5%8A%A8%E6%80%81%E4%BB%A3%E7%90%86"><span class="nav-text">七. 反射与动态代理</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E9%97%AE%EF%BC%9A%E5%8F%8D%E5%B0%84%E7%9A%84%E5%8E%9F%E7%90%86%EF%BC%8C%E6%80%8E%E4%B9%88%E7%A1%AE%E5%AE%9A%E7%B1%BB%EF%BC%8C%E6%80%8E%E4%B9%88%E8%B0%83%E6%96%B9%E6%B3%95%EF%BC%9F"><span class="nav-text">问：反射的原理，怎么确定类，怎么调方法？</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E9%97%AE%EF%BC%9A%E5%A6%82%E4%BD%95%E9%80%9A%E8%BF%87%E5%8F%8D%E5%B0%84%E5%92%8C%E8%AE%BE%E7%BD%AE%E5%AF%B9%E8%B1%A1%E7%A7%81%E6%9C%89%E5%AD%97%E6%AE%B5%E7%9A%84%E5%80%BC%EF%BC%9F"><span class="nav-text">问：如何通过反射和设置对象私有字段的值？</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E9%97%AE%EF%BC%9A%E5%8A%A8%E6%80%81%E4%BB%A3%E7%90%86%EF%BC%9F"><span class="nav-text">问：动态代理？</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E9%97%AE%EF%BC%9A%E4%B8%BA%E4%BB%80%E4%B9%88JDK%E5%8A%A8%E6%80%81%E4%BB%A3%E7%90%86%E5%8F%AA%E8%83%BD%E4%BB%A3%E7%90%86%E6%8E%A5%E5%8F%A3%EF%BC%9F"><span class="nav-text">问：为什么JDK动态代理只能代理接口？</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E9%97%AE%EF%BC%9A%E6%9C%89%E4%BA%BA%E8%AF%B4jdk%E5%8A%A8%E6%80%81%E4%BB%A3%E7%90%86%E6%80%A7%E8%83%BD%E6%AF%94cglib%E8%A6%81%E5%B7%AE%EF%BC%8C%E5%A6%82%E6%9E%9C%E6%98%AF%EF%BC%8C%E4%BE%9D%E6%8D%AE%E6%98%AF%E4%BB%80%E4%B9%88%EF%BC%9FJDK-%E5%8A%A8%E6%80%81%E4%BB%A3%E7%90%86%E4%B8%8E-CGLIB-%E4%BB%A3%E7%90%86%E7%9A%84%E5%8C%BA%E5%88%AB%E5%8F%88%E6%98%AF%E4%BB%80%E4%B9%88%EF%BC%9F"><span class="nav-text">问：有人说jdk动态代理性能比cglib要差，如果是，依据是什么？JDK 动态代理与 CGLIB 代理的区别又是什么？</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E9%97%AE%EF%BC%9ASpring%E4%B8%ADAOP%E7%9A%84%E5%AE%9E%E7%8E%B0%E9%87%87%E7%94%A8%E9%82%A3%E7%A7%8D%E4%BB%A3%E7%90%86%E6%96%B9%E5%BC%8F%EF%BC%9F"><span class="nav-text">问：Spring中AOP的实现采用那种代理方式？</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E9%97%AE%EF%BC%9AJava%E4%B8%AD%E7%9A%84%E4%BA%8B%E4%BB%B6%E6%9C%BA%E5%88%B6%EF%BC%9F"><span class="nav-text">问：Java中的事件机制？</span></a></li></ol></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%85%AB-%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F"><span class="nav-text">八. 设计模式</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E9%97%AE%EF%BC%9A%E9%A1%B9%E7%9B%AE%E4%B8%AD%E6%9C%89%E4%BD%BF%E7%94%A8%E8%BF%87%E5%93%AA%E4%BA%9B%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%EF%BC%9F"><span class="nav-text">问：项目中有使用过哪些设计模式？</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E9%97%AE%EF%BC%9A-JDK-%E4%B8%AD%E5%87%A0%E4%B8%AA%E5%B8%B8%E8%A7%81%E7%9A%84%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%EF%BC%9F"><span class="nav-text">问： JDK 中几个常见的设计模式？</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E9%97%AE%EF%BC%9A-Spring-%E4%B8%AD%E7%94%A8%E4%BA%86%E5%93%AA%E4%BA%9B%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%EF%BC%9F"><span class="nav-text">问： Spring 中用了哪些设计模式？</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E9%97%AE%EF%BC%9A%E5%8D%95%E4%BE%8B%E6%A8%A1%E5%BC%8F%E6%98%AF%E4%BB%80%E4%B9%88%EF%BC%9F%E5%8D%95%E4%BE%8B%E6%A8%A1%E5%BC%8F%E7%9A%84%E4%BC%98%E7%82%B9%EF%BC%9F%E4%BD%BF%E7%94%A8%E5%9C%BA%E6%99%AF%EF%BC%9F%E6%9C%89%E5%93%AA%E5%87%A0%E7%A7%8D%EF%BC%9F%E6%9C%89%E4%BB%80%E4%B9%88%E5%8C%BA%E5%88%AB%EF%BC%9F%E6%89%8B%E5%86%99%E5%87%BA%E7%BA%BF%E7%A8%8B%E5%AE%89%E5%85%A8%E7%9A%84%E5%8D%95%E4%BE%8B%E6%A8%A1%E5%BC%8F%EF%BC%9F"><span class="nav-text">问：单例模式是什么？单例模式的优点？使用场景？有哪几种？有什么区别？手写出线程安全的单例模式？</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E9%97%AE%EF%BC%9A%E5%B7%A5%E5%8E%82%E6%A8%A1%E5%BC%8F%E6%98%AF%E4%BB%80%E4%B9%88%EF%BC%9F"><span class="nav-text">问：工厂模式是什么？</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E9%97%AE%EF%BC%9A%E7%94%9F%E4%BA%A7%E8%80%85%E6%B6%88%E8%B4%B9%E8%80%85%E6%A8%A1%E5%BC%8F%EF%BC%9F%E8%A6%81%E6%B1%82%E6%89%8B%E5%86%99%E5%87%BA%E4%BB%A3%E7%A0%81"><span class="nav-text">问：生产者消费者模式？要求手写出代码</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E9%97%AE%EF%BC%9A%E8%A7%82%E5%AF%9F%E8%80%85%E6%A8%A1%E5%BC%8F%EF%BC%9F"><span class="nav-text">问：观察者模式？</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E9%97%AE%EF%BC%9A%E9%80%82%E9%85%8D%E5%99%A8%E6%A8%A1%E5%BC%8F%EF%BC%9F"><span class="nav-text">问：适配器模式？</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E9%97%AE%EF%BC%9A%E4%BB%A3%E7%90%86%E6%A8%A1%E5%BC%8F%EF%BC%9F"><span class="nav-text">问：代理模式？</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E9%97%AE%EF%BC%9A%E6%A8%A1%E6%9D%BF%E6%96%B9%E6%B3%95%E6%A8%A1%E5%BC%8F%EF%BC%9F"><span class="nav-text">问：模板方法模式？</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E9%97%AE%EF%BC%9A%E7%AD%96%E7%95%A5%E6%A8%A1%E5%BC%8F%EF%BC%9F"><span class="nav-text">问：策略模式？</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E9%97%AE%EF%BC%9A%E8%B4%A3%E4%BB%BB%E9%93%BE%E6%A8%A1%E5%BC%8F%EF%BC%9F"><span class="nav-text">问：责任链模式？</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E9%97%AE%EF%BC%9A%E8%A3%85%E9%A5%B0%E8%80%85%E6%A8%A1%E5%BC%8F%EF%BC%9F"><span class="nav-text">问：装饰者模式？</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E9%97%AE%EF%BC%9A%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E4%B8%AD%E5%B8%B8%E8%A7%81%E5%8E%9F%E5%88%99%E7%9F%A5%E9%81%93%E4%B8%80%E4%BA%9B%E5%90%97%EF%BC%9F%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E8%AE%BE%E8%AE%A1%E7%9A%84%E4%BA%94%E5%A4%A7%E5%9F%BA%E6%9C%AC%E5%8E%9F%E5%88%99%EF%BC%9F"><span class="nav-text">问：设计模式中常见原则知道一些吗？面向对象设计的五大基本原则？</span></a></li></ol></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E4%B9%9D-Java-8-%E6%96%B0%E7%89%B9%E6%80%A7"><span class="nav-text">九. Java 8 新特性</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E9%97%AE%EF%BC%9Ajava8%E6%9C%89%E4%BA%86%E8%A7%A3%E5%90%97%EF%BC%9F"><span class="nav-text">问：java8有了解吗？</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E9%97%AE%EF%BC%9A%E8%AE%B2%E8%AE%B2Lambda%E8%A1%A8%E8%BE%BE%E5%BC%8F%EF%BC%9F%E4%BD%BF%E7%94%A8%E5%9C%BA%E6%99%AF%EF%BC%9F%E4%BC%98%E7%82%B9%EF%BC%9F"><span class="nav-text">问：讲讲Lambda表达式？使用场景？优点？</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E9%97%AE%EF%BC%9A%E8%B0%88%E8%B0%88%E6%B5%81%EF%BC%9F%E5%92%8C%E9%9B%86%E5%90%88%E5%AF%B9%E6%AF%94%EF%BC%9F"><span class="nav-text">问：谈谈流？和集合对比？</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E9%97%AE%EF%BC%9Adefault%E5%85%B3%E9%94%AE%E5%AD%97-%EF%BC%9F"><span class="nav-text">问：default关键字 ？</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E9%97%AE%EF%BC%9A%E6%96%B0%E6%97%B6%E9%97%B4%E6%97%A5%E6%9C%9F-APILocalDate-LocalTime-LocalDateTime-%EF%BC%9F%E5%AF%B9%E6%AF%94%E6%97%A7%E6%97%B6%E9%97%B4%E6%97%A5%E6%9C%9F"><span class="nav-text">问：新时间日期 APILocalDate | LocalTime | LocalDateTime ？对比旧时间日期</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E9%97%AE%EF%BC%9AJDK1-7%E4%B8%8EJDK1-8-ConcurrentHashMap%E5%AF%B9%E6%AF%94-%EF%BC%9F"><span class="nav-text">问：JDK1.7与JDK1.8 ConcurrentHashMap对比 ？</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E9%97%AE%EF%BC%9AJDK1-8%E4%BD%BF%E7%94%A8synchronized%E6%9D%A5%E4%BB%A3%E6%9B%BF%E9%87%8D%E5%85%A5%E9%94%81ReentrantLock-%EF%BC%9F"><span class="nav-text">问：JDK1.8使用synchronized来代替重入锁ReentrantLock ？</span></a></li></ol></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%8D%81-Java-9-%E6%96%B0%E7%89%B9%E6%80%A7"><span class="nav-text">十. Java 9 新特性</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E9%97%AE%EF%BC%9AJava-9%E5%BC%95%E5%85%A5%E4%BA%86%E5%93%AA%E4%BA%9B%E6%96%B0%E7%89%B9%E6%80%A7%EF%BC%9F"><span class="nav-text">问：Java 9引入了哪些新特性？</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E9%97%AE%EF%BC%9A%E6%A8%A1%E5%9D%97%E5%8C%96%E7%B3%BB%E7%BB%9F-%EF%BC%9F"><span class="nav-text">问：模块化系统 ？</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E9%97%AE%EF%BC%9A%E9%9B%86%E5%90%88%E5%B7%A5%E5%8E%82%E6%96%B9%E6%B3%95-%EF%BC%9F"><span class="nav-text">问：集合工厂方法 ？</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E9%97%AE%EF%BC%9A%E6%94%B9%E8%BF%9B%E7%9A%84-Stream-API-%EF%BC%9F"><span class="nav-text">问：改进的 Stream API ？</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E9%97%AE%EF%BC%9A%E6%94%B9%E8%BF%9B%E7%9A%84-Javadoc-%EF%BC%9F"><span class="nav-text">问：改进的 Javadoc ？</span></a></li></ol></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%8D%81%E4%B8%80-Java-11-%E7%89%B9%E6%80%A7"><span class="nav-text">十一. Java 11 特性</span></a></li></ol></li></ol></div>
        </div>
        <!--/noindex-->

        <div class="site-overview-wrap sidebar-panel">
          <div class="site-overview">
            <div class="site-author site-overview-item animated" itemprop="author" itemscope itemtype="http://schema.org/Person">
    <img class="site-author-image" itemprop="image" alt="Lys"
      src="https://pic-1258215793.cos.ap-shanghai.myqcloud.com/cover/IMG_0759.JPG">
  <p class="site-author-name" itemprop="name">Lys</p>
  <div class="site-description" itemprop="description">记录编程点滴，写点生活中的酸甜</div>
</div>
<div class="site-state-wrap site-overview-item animated">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
          <a href="/archives/">
        
          <span class="site-state-item-count">340</span>
          <span class="site-state-item-name">日志</span>
        </a>
      </div>
      <div class="site-state-item site-state-categories">
            <a href="/categories/">
          
        <span class="site-state-item-count">13</span>
        <span class="site-state-item-name">分类</span></a>
      </div>
      <div class="site-state-item site-state-tags">
            <a href="/tags/">
          
        <span class="site-state-item-count">113</span>
        <span class="site-state-item-name">标签</span></a>
      </div>
  </nav>
</div>
  <div class="links-of-author site-overview-item animated">
      <span class="links-of-author-item">
        <a href="https://github.com/LAILAIWA" title="GitHub → https:&#x2F;&#x2F;github.com&#x2F;LAILAIWA" rel="noopener" target="_blank"><i class="fab fa-github fa-fw"></i>GitHub</a>
      </span>
      <span class="links-of-author-item">
        <a href="mailto:linyishui168@outlook.com" title="E-Mail → mailto:linyishui168@outlook.com" rel="noopener" target="_blank"><i class="fa fa-envelope fa-fw"></i>E-Mail</a>
      </span>
      <span class="links-of-author-item">
        <a href="https://weibo.com/u/5340162234" title="Weibo → https:&#x2F;&#x2F;weibo.com&#x2F;u&#x2F;5340162234" rel="noopener" target="_blank"><i class="fab fa-weibo fa-fw"></i>Weibo</a>
      </span>
      <span class="links-of-author-item">
        <a href="https://twitter.com/linyishui618" title="Twitter → https:&#x2F;&#x2F;twitter.com&#x2F;linyishui618" rel="noopener" target="_blank"><i class="fab fa-twitter fa-fw"></i>Twitter</a>
      </span>
      <span class="links-of-author-item">
        <a href="https://stackoverflow.com/users/13018339/lin-yishui" title="StackOverflow → https:&#x2F;&#x2F;stackoverflow.com&#x2F;users&#x2F;13018339&#x2F;lin-yishui" rel="noopener" target="_blank"><i class="fab fa-stack-overflow fa-fw"></i>StackOverflow</a>
      </span>
      <span class="links-of-author-item">
        <a href="https://instagram.com/linyishui618" title="Instagram → https:&#x2F;&#x2F;instagram.com&#x2F;linyishui618" rel="noopener" target="_blank"><i class="fab fa-instagram fa-fw"></i>Instagram</a>
      </span>
  </div>
  <div class="cc-license site-overview-item animated" itemprop="license">
    <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/deed.zh" class="cc-opacity" rel="noopener" target="_blank"><img src="https://cdn.jsdelivr.net/npm/@creativecommons/vocabulary@2020.11.3/assets/license_badges/small/by_nc_sa.svg" alt="Creative Commons"></a>
  </div>


  <div class="links-of-blogroll site-overview-item animated">
    <div class="links-of-blogroll-title"><i class="far fa-smile-wink fa-fw"></i>
      个人
    </div>
    <ul class="links-of-blogroll-list">
        <li class="links-of-blogroll-item">
          <a href="https://music.163.com/#/user/home?id=68425607" title="https:&#x2F;&#x2F;music.163.com&#x2F;#&#x2F;user&#x2F;home?id&#x3D;68425607" rel="noopener" target="_blank">网易云音乐</a>
        </li>
    </ul>
  </div>

          </div>
        </div>
    </div>
  </aside>
  <div class="sidebar-dimmer"></div>


    </header>

    
  <div class="back-to-top" role="button" aria-label="返回顶部">
    <i class="fa fa-arrow-up"></i>
    <span>0%</span>
  </div>
  <a role="button" class="book-mark-link book-mark-link-fixed"></a>

  <a href="https://github.com/LAILAIWA" class="github-corner" title="Follow me on GitHub" aria-label="Follow me on GitHub" rel="noopener" target="_blank"><svg width="80" height="80" viewBox="0 0 250 250" aria-hidden="true"><path d="M0,0 L115,115 L130,115 L142,142 L250,250 L250,0 Z"></path><path d="M128.3,109.0 C113.8,99.7 119.0,89.6 119.0,89.6 C122.0,82.7 120.5,78.6 120.5,78.6 C119.2,72.0 123.4,76.3 123.4,76.3 C127.3,80.9 125.5,87.3 125.5,87.3 C122.9,97.6 130.6,101.9 134.4,103.2" fill="currentColor" style="transform-origin: 130px 106px;" class="octo-arm"></path><path d="M115.0,115.0 C114.9,115.1 118.7,116.5 119.8,115.4 L133.7,101.6 C136.9,99.2 139.9,98.4 142.2,98.6 C133.8,88.0 127.5,74.4 143.8,58.0 C148.5,53.4 154.0,51.2 159.7,51.0 C160.3,49.4 163.2,43.6 171.4,40.1 C171.4,40.1 176.1,42.5 178.8,56.2 C183.1,58.6 187.2,61.8 190.9,65.4 C194.5,69.0 197.7,73.2 200.1,77.6 C213.8,80.2 216.3,84.9 216.3,84.9 C212.7,93.1 206.9,96.0 205.4,96.6 C205.1,102.4 203.0,107.8 198.3,112.5 C181.9,128.9 168.3,122.5 157.7,114.1 C157.9,116.9 156.7,120.9 152.7,124.9 L141.0,136.5 C139.8,137.7 141.6,141.9 141.8,141.8 Z" fill="currentColor" class="octo-body"></path></svg></a>

<noscript>
  <div class="noscript-warning">Theme NexT works best with JavaScript enabled</div>
</noscript>


    <div class="main-inner post posts-expand">


  


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://linyishui.top/2019102002.html">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="https://pic-1258215793.cos.ap-shanghai.myqcloud.com/cover/IMG_0759.JPG">
      <meta itemprop="name" content="Lys">
      <meta itemprop="description" content="记录编程点滴，写点生活中的酸甜">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="俺的部落格">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          面试整理——Java基础
        </h1>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>

      <time title="创建时间：2019-10-20 16:05:59" itemprop="dateCreated datePublished" datetime="2019-10-20T16:05:59+08:00">2019-10-20</time>
    </span>
      <span class="post-meta-item">
        <span class="post-meta-item-icon">
          <i class="far fa-calendar-check"></i>
        </span>
        <span class="post-meta-item-text">更新于</span>
        <time title="修改时间：2025-02-04 20:23:09" itemprop="dateModified" datetime="2025-02-04T20:23:09+08:00">2025-02-04</time>
      </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">分类于</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/%E9%9D%A2%E8%AF%95%E6%95%B4%E7%90%86/" itemprop="url" rel="index"><span itemprop="name">面试整理</span></a>
        </span>
    </span>

  
      </div>
      <div class="post-meta">
    <span class="post-meta-item" title="本文字数">
      <span class="post-meta-item-icon">
        <i class="far fa-file-word"></i>
      </span>
      <span class="post-meta-item-text">本文字数：</span>
      <span>101k</span>
    </span>
    <span class="post-meta-item" title="阅读时长">
      <span class="post-meta-item-icon">
        <i class="far fa-clock"></i>
      </span>
      <span class="post-meta-item-text">阅读时长 &asymp;</span>
      <span>1:32</span>
    </span>
</div>

            <div class="post-description">整理面试中常问的Java基础相关问题，持续更新中。</div>
        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
        <h1 id="Java基础"><a href="#Java基础" class="headerlink" title="Java基础"></a>Java基础</h1><h2 id="一-面向对象"><a href="#一-面向对象" class="headerlink" title="一. 面向对象"></a>一. 面向对象</h2><h4 id="问：面向对象的三大特性？分别是怎么使用的，给个例子"><a href="#问：面向对象的三大特性？分别是怎么使用的，给个例子" class="headerlink" title="问：面向对象的三大特性？分别是怎么使用的，给个例子?"></a>问：面向对象的三大特性？分别是怎么使用的，给个例子?</h4><ul>
<li>封装：比如类把属性和行为封装起来，只提供公共方法被外界访问，限制直接访问对象内部数据。</li>
<li>继承：允许一个类从另一个类获得属性和方法，从而实现代码的复用。比如父子类间的继承关系，子类继承父类的属性方法。</li>
<li>多态：允许一个对象在不同的上下文中表现为不同的形态。包括两种形式：<strong>编译时多态or静态多态</strong>（方法重载）<strong>运行时多态or动态多态</strong>（方法重写）。比如方法重载在同一个类中存在多个同名方法，参数不同；方法重写在子类通过继承并重写父类方法，同样的方法会有不同的实现。</li>
</ul>
<h4 id="问：多态的原理是什么？"><a href="#问：多态的原理是什么？" class="headerlink" title="问：多态的原理是什么？"></a>问：多态的原理是什么？</h4><ul>
<li><strong>多态</strong>是面向对象编程中的核心概念，它允许一个对象在不同的上下文中表现出不同的行为。多态的实现主要依赖于 <strong>继承</strong> 和 <strong>方法重写</strong>。</li>
<li>多态的底层实现是<strong>动态绑定（Dynamic Binding）</strong> 或 <strong>后期绑定（Late Binding）</strong>，以及通过父类引用指向子类对象来实现。<ul>
<li>通过父类引用指向子类对象：即我们可以通过声明父类的引用变量存储子类对象的引用，即引用实际上指向子类对象，如 <code>Animal animal = new Dog(); </code>。</li>
<li>动态绑定OR后期绑定：在运行时根据对象的实际类型来绑定的，而不是在编译时就确定好。<strong>在运行时才把方法调用与方法实现关联起来</strong>，通过<strong>方法表</strong>来实现，表中记录了类定义方法的指针，指向具体的方法代码，当类重写了父类方法，对应的表项就会指向新的代码实现，所以无论引用变量是父类还是子类，最终运行时都能执行正确的代码。</li>
</ul>
</li>
<li><a href="../2020021301.html" title="Title">面向对象-多态</a></li>
</ul>
<h4 id="问：讲一下重载和重写"><a href="#问：讲一下重载和重写" class="headerlink" title="问：讲一下重载和重写?"></a>问：讲一下重载和重写?</h4><ul>
<li> <strong>重载（Overloading） <strong>：指在同一个类中定义多个方法，这些方法的名字相同，但参数列表不同（参数类型、数量或顺序不同）。重载是一种</strong>编译时多态性</strong>（也叫静态多态性），在编译时决定调用哪一个方法。</li>
<li> <strong>重写（Overriding）</strong>：指在子类中重新定义父类中已有的方法。重写是继承机制的一部分，用于<strong>运行时多态性</strong>（也叫动态多态性），即在运行时根据对象的实际类型调用相应的方法。子类通过重写父类的方法，可以提供自己的实现。</li>
</ul>
<table>
<thead>
<tr>
<th>特性</th>
<th>重载（Overloading）</th>
<th>重写（Overriding）</th>
</tr>
</thead>
<tbody><tr>
<td>方法名称</td>
<td>相同</td>
<td>相同</td>
</tr>
<tr>
<td>参数列表</td>
<td>必须不同</td>
<td>必须相同</td>
</tr>
<tr>
<td>返回类型</td>
<td>可以不同</td>
<td>必须相同</td>
</tr>
<tr>
<td>发生时机</td>
<td>编译时（静态多态性）</td>
<td>运行时（动态多态性）</td>
</tr>
<tr>
<td>所属关系</td>
<td>同一个类中</td>
<td>子类与父类之间</td>
</tr>
<tr>
<td>访问修饰符</td>
<td>无要求</td>
<td>访问权限不能比父类方法更严格</td>
</tr>
<tr>
<td>@Override</td>
<td>不需要</td>
<td>必须用 <code>@Override</code> 标注，表示方法被重写</td>
</tr>
</tbody></table>
<h2 id="二-数据类型"><a href="#二-数据类型" class="headerlink" title="二. 数据类型"></a>二. 数据类型</h2><h4 id="问：Java的基本类型有哪几个？各自占了多少位？一个char能放一个汉字吗？"><a href="#问：Java的基本类型有哪几个？各自占了多少位？一个char能放一个汉字吗？" class="headerlink" title="问：Java的基本类型有哪几个？各自占了多少位？一个char能放一个汉字吗？"></a>问：Java的基本类型有哪几个？各自占了多少位？一个char能放一个汉字吗？</h4><ul>
<li>8个，byte，short，int，long，float，double，boolean，char</li>
<li>1个字节Byte是8位bit。<ul>
<li>整型：byte是8位，short是16位，int是32位，long是64位</li>
<li>浮点型：float是32位（单精度），double是64位（双精度）</li>
<li>字符型：char则是16位，存储一个Unicode字符</li>
<li>布尔型：boolean是1位</li>
</ul>
</li>
<li>可以，char是16位Unicode字符，一个汉字占两个字节，所以够放。</li>
</ul>
<h4 id="问：基本类型和包装类型的区别？涉及自动装箱和拆箱，怎么做的，原理？"><a href="#问：基本类型和包装类型的区别？涉及自动装箱和拆箱，怎么做的，原理？" class="headerlink" title="问：基本类型和包装类型的区别？涉及自动装箱和拆箱，怎么做的，原理？"></a>问：基本类型和包装类型的区别？涉及自动装箱和拆箱，怎么做的，原理？</h4><p>基本类型和包装类型的区别？</p>
<ul>
<li>基本类型是原始数据类型，而包装类型是基本类型的对象封装。</li>
<li>基本类型有固定的存储空间，包装类则都是对象。</li>
<li><strong>包装类作为对象存放在堆中，而基本类型存放在栈里</strong>。随着方法的结束，栈内存会自动释放，因此不需要 GC 管理。如果频繁创建包装类型对象，GC 会更频繁地进行对象回收，影响性能。</li>
<li>缺省值不同，基本类型根据类型有不同的缺省值，而包装类型则为null。</li>
</ul>
<p><strong>自动装箱（Auto-boxing）</strong>：基本类型自动转换为包装类型。</p>
<p><strong>拆箱（Unboxing）</strong>：包装类型自动转换为基本类型。</p>
<ul>
<li>Java 编译器在处理装箱和拆箱时，实际上是通过在编译阶段插入必要的转换代码来实现的。如 整型通过 <code>Integer.valueOf()</code> 以及 <code>Integer.intValue()</code> 分别完成装箱和拆箱。</li>
<li>Java 为包装类型提供了一定的缓存优化 IntegerCache（如 <code>Integer</code> 的值在 <code>-128</code> 到 <code>127</code> 范围内时会复用对象）。然而，超过这个范围时，Java 需要为每个新的值分配新的对象，造成额外的内存分配和管理开销。</li>
<li>自动装箱和拆箱过程增加了额外的性能开销，尤其是在频繁进行算术运算或集合操作时。如果频繁装箱、拆箱，会导致更多的内存分配、垃圾回收，影响性能。</li>
</ul>
<h4 id="问：传值和传引用的区别？为什么说Java只有值传递？"><a href="#问：传值和传引用的区别？为什么说Java只有值传递？" class="headerlink" title="问：传值和传引用的区别？为什么说Java只有值传递？"></a>问：传值和传引用的区别？为什么说Java只有值传递？</h4><ul>
<li>首先什么是值传递和引用传递？<ul>
<li>首先这两个专有名词有其特指定义，属于函数调用时参数的求值策略，是对调用函数时，求值和传值方式的描述，而不是对传递内容类型的描述。</li>
<li>应该是根据<strong>是否会创建副本</strong>，以及<strong>是否会影响到原始对象</strong>来判断。<ul>
<li><strong>传值</strong>（Pass-by-Value）：将<strong>变量的值</strong>复制一份传递给方法。方法内对该参数的修改不会影响到原始变量，因为方法操作的是值的副本。</li>
<li><strong>传引用</strong>（Pass-by-Reference）：传递的是变量的<strong>内存地址</strong>，方法操作的是真正的变量本身。方法内对该参数的修改会影响到原始变量，因为方法操作的是实际的对象或数据，而不是副本。</li>
</ul>
</li>
<li>值传递和引用传递是<strong>区分两种内存分配方式</strong>，<strong>值类型在调用栈上分配，引用类型在堆上分配</strong>。值传递会创建副本，无法在函数内改变原值。引用传递则不会创建副本，可以在函数内改变原值。</li>
<li>这些区别和参数类型是值类型或是引用类型无关，如果是值传递，不管是何种类型都会在调用栈上创建一个副本，区别在值类型的副本是原值的复制，引用类型的实例在堆上，在栈上只有它的引用，其副本是引用的复制。</li>
</ul>
</li>
<li>为什么说Java只有值传递？<ul>
<li>根据值传递和引用传递的定义，Java中应该只有值传递。因为不管形参是哪种数据类型，<strong>最终传递给形参的都是实参的拷贝</strong>，函数对形参的赋值操作也不能被调用者感知。这种设计其实对应着求值策略中的传共享对象调用。</li>
<li>即使是对象类型的参数传递，传递的依然是对象引用的副本。</li>
</ul>
</li>
<li>什么是求值策略中的传共享对象调用？<ul>
<li><strong>传共享对象调用</strong>（Call by Sharing），也称为<strong>共享对象传递</strong>，是一种参数传递策略，主要应用在某些编程语言（如 Python、Java、Ruby）中。</li>
<li>当方法或函数接收一个对象作为参数时，传递的是<strong>对象引用的副本</strong>，而不是对象的值或对象的引用本身。</li>
</ul>
</li>
</ul>
<h4 id="问：货币用哪种数据类型？"><a href="#问：货币用哪种数据类型？" class="headerlink" title="问：货币用哪种数据类型？"></a>问：货币用哪种数据类型？</h4><ul>
<li><p>BigDecimal，因为BigDecimal可以表示精确的浮点数。</p>
</li>
<li><p><code>float</code> 和 <code>double</code> 是浮点数类型，使用<strong>二进制存储小数</strong>。这些类型在进行加减乘除等运算时容易出现精度问题，尤其是在涉及到货币计算时（例如财务计算需要非常精确的结果），这种精度损失是不允许的。</p>
<p>如：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">double</span> value1 = <span class="number">2.15</span>;</span><br><span class="line"><span class="keyword">double</span> value2 = <span class="number">1.10</span>;</span><br><span class="line">System.out.println(value1 - value2);  <span class="comment">// 输出 1.0499999999999998</span></span><br></pre></td></tr></table></figure></li>
<li><p><code>BigDecimal</code> 是基于<strong>十进制</strong>实现的，还提供了多种<strong>舍入模式</strong>，高精度的加减乘除运算。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">BigDecimal value1 = <span class="keyword">new</span> BigDecimal(<span class="string">&quot;2.15&quot;</span>);</span><br><span class="line">BigDecimal value2 = <span class="keyword">new</span> BigDecimal(<span class="string">&quot;1.10&quot;</span>);</span><br><span class="line">System.out.println(value1.subtract(value2));  <span class="comment">// 输出 1.05，精度正确</span></span><br></pre></td></tr></table></figure></li>
</ul>
<h4 id="问：i-和-i-的区别？"><a href="#问：i-和-i-的区别？" class="headerlink" title="问：i++ 和 ++i 的区别？"></a>问：<code>i++</code> 和 <code>++i</code> 的区别？</h4><ul>
<li>二者区别在于进行自增操作的<strong>时机</strong>。</li>
<li><code>i++</code> 是先赋值再运算，<code>++i</code> 是先运算再赋值。<ul>
<li><code>i++</code>（<strong>后置自增，Post-increment</strong>）表示在使用变量 <code>i</code> 的当前值之后，再对其进行自增操作。</li>
<li><code>++i</code>（<strong>前置自增，Pre-increment</strong>），表示在使用变量 <code>i</code> 之前，先对其进行自增操作。</li>
</ul>
</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> i = <span class="number">0</span>, j = <span class="number">0</span>, k = <span class="number">0</span>;</span><br><span class="line">j = i++; <span class="comment">// j值为0，i为1</span></span><br><span class="line">k = ++j; <span class="comment">// k值为1，j为1</span></span><br></pre></td></tr></table></figure>



<h2 id="三-关键字"><a href="#三-关键字" class="headerlink" title="三. 关键字"></a>三. 关键字</h2><h4 id="问：讲讲Java中用来描述作用域的修饰符？"><a href="#问：讲讲Java中用来描述作用域的修饰符？" class="headerlink" title="问：讲讲Java中用来描述作用域的修饰符？"></a>问：讲讲Java中用来描述作用域的修饰符？</h4><table>
<thead>
<tr>
<th align="center">作用域</th>
<th align="center">当前类</th>
<th align="center">同一package</th>
<th align="center">子类</th>
<th align="center">其他package非子类</th>
</tr>
</thead>
<tbody><tr>
<td align="center">public</td>
<td align="center">√</td>
<td align="center">√</td>
<td align="center">√</td>
<td align="center">√</td>
</tr>
<tr>
<td align="center">protected</td>
<td align="center">√</td>
<td align="center">√</td>
<td align="center">√</td>
<td align="center">×</td>
</tr>
<tr>
<td align="center">default</td>
<td align="center">√</td>
<td align="center">√</td>
<td align="center">×</td>
<td align="center">×</td>
</tr>
<tr>
<td align="center">private</td>
<td align="center">√</td>
<td align="center">×</td>
<td align="center">×</td>
<td align="center">×</td>
</tr>
</tbody></table>
<p>使用场景：</p>
<ol>
<li>public：希望让代码中的某个部分可以被所有外部访问时使用。</li>
<li>protected：在继承体系中，希望允许子类访问父类的某些属性或方法时，可以使用 <code>protected</code>。这样保证了继承关系中的灵活性。</li>
<li>default：希望某个成员仅限于同一包中使用时，可以不使用任何访问修饰符，让其默认为包级访问。</li>
<li>private：希望封装类的实现细节，避免外部代码直接访问类的某些字段或方法时使用。</li>
</ol>
<h4 id="问：assert？"><a href="#问：assert？" class="headerlink" title="问：assert？"></a>问：assert？</h4><ul>
<li><p><code>assert</code> 是 Java 中的<strong>断言机制</strong>，用于在代码中设置检查点，验证某个条件是否成立。如果条件不成立，程序将抛出一个 <code>AssertionError</code>。断言通常用于在开发和测试阶段捕捉程序中的逻辑错误。</p>
</li>
<li><p>基本格式：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">assert</span> condition;</span><br><span class="line"><span class="keyword">assert</span> condition : expression;</span><br></pre></td></tr></table></figure>

<p>如：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> age = <span class="number">15</span>;</span><br><span class="line">        <span class="keyword">assert</span> age &gt;= <span class="number">18</span> : <span class="string">&quot;Age must be 18 or older&quot;</span>;</span><br><span class="line">        System.out.println(<span class="string">&quot;Age is valid&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li><p>在 Java 中，断言默认是<strong>禁用</strong>的，只有显式启用后才会生效。断言通常在开发阶段使用，而生产环境中一般不启用。在运行程序时，使用 <code>-ea</code>（<code>-enableassertions</code>）参数启用断言：<code>java -ea Test</code> 。通过 <code>-da</code>（<code>-disableassertions</code>）参数禁用断言（默认状态）：<code>java -da Test</code> 。</p>
</li>
</ul>
<h4 id="问：Java有哪几种移位运算符？"><a href="#问：Java有哪几种移位运算符？" class="headerlink" title="问：Java有哪几种移位运算符？"></a>问：Java有哪几种移位运算符？</h4><ul>
<li><p><code>&lt;&lt;</code> ：左移运算符。将 <code>x</code> 的所有位向左移动 <code>n</code> 位，右边补 <code>0</code>。相当于将 <code>x</code> 乘以 <code>2^n</code>。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> x = <span class="number">3</span>;   <span class="comment">// 3 的二进制是 0000 0011</span></span><br><span class="line"><span class="keyword">int</span> result = x &lt;&lt; <span class="number">2</span>;  <span class="comment">// 将 3 向左移动 2 位，结果是 0000 1100，也就是 12</span></span><br><span class="line">System.out.println(result);  <span class="comment">// 输出 12</span></span><br></pre></td></tr></table></figure></li>
<li><p><code>&gt;&gt;</code>   ：有符号右移运算符。将 <code>x</code> 的所有位向右移动 <code>n</code> 位，左边用符号位（即原最高位）填充。正数补 <code>0</code>，负数补 <code>1</code>。相当于将 <code>x</code> 除以 <code>2^n</code>（向下取整）。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> x = <span class="number">12</span>;  <span class="comment">// 12 的二进制是 0000 1100</span></span><br><span class="line"><span class="keyword">int</span> result = x &gt;&gt; <span class="number">2</span>;  <span class="comment">// 将 12 向右移动 2 位，结果是 0000 0011，也就是 3</span></span><br><span class="line">System.out.println(result);  <span class="comment">// 输出 3</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> x = -<span class="number">12</span>;  <span class="comment">// -12 的二进制是 1111 0100（补码形式）</span></span><br><span class="line"><span class="keyword">int</span> result = x &gt;&gt; <span class="number">2</span>;  <span class="comment">// 向右移动 2 位，结果是 1111 1101，也就是 -3</span></span><br><span class="line">System.out.println(result);  <span class="comment">// 输出 -3</span></span><br></pre></td></tr></table></figure></li>
<li><p><code>&gt;&gt;&gt;</code>  ：无符号右移运算符。将 <code>x</code> 的所有位向右移动 <code>n</code> 位，左边总是补 <code>0</code>，不考虑符号位。无符号右移运算只在处理无符号数时有用。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">nt x = -<span class="number">12</span>;  <span class="comment">// -12 的二进制是 1111 0100（补码形式）</span></span><br><span class="line"><span class="keyword">int</span> result = x &gt;&gt;&gt; <span class="number">2</span>;  <span class="comment">// 无符号右移 2 位，结果是 0011 1101，也就是 1073741821</span></span><br><span class="line">System.out.println(result);  <span class="comment">// 输出 1073741821</span></span><br></pre></td></tr></table></figure></li>
</ul>
<h4 id="问：Switch-是否能作用在-Byte-上，是否能作用在-Long-上，是否能作用在-String-上-？"><a href="#问：Switch-是否能作用在-Byte-上，是否能作用在-Long-上，是否能作用在-String-上-？" class="headerlink" title="问：Switch 是否能作用在 Byte 上，是否能作用在 Long 上，是否能作用在 String 上 ？"></a>问：Switch 是否能作用在 Byte 上，是否能作用在 Long 上，是否能作用在 String 上 ？</h4><p><code>switch(expr1)</code> 中，<code>expr1</code> 是一个<strong>整数表达式</strong>，且只支持较小的整数类型。传递给 switch 和 case 语句的参数应该是 <code>int</code> 、 <code>short</code> 、 <code>char</code> 或者  <code>byte</code> 。JDK 1.5引入enum后也可以支持。Java 7开始支持String。综上所述switch支持：<code>byte</code>、<code>short</code>、<code>char</code>、<code>int</code> 以及包装类 <code>Byte</code>、<code>Short</code>、<code>Character</code>、<code>Integer</code>，还有 <code>enum</code> 枚举类型。long则不支持。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">byte</span> b = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">switch</span> (b) &#123;</span><br><span class="line">    <span class="keyword">case</span> <span class="number">1</span>:</span><br><span class="line">        System.out.println(<span class="string">&quot;It&#x27;s 1&quot;</span>);</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">case</span> <span class="number">2</span>:</span><br><span class="line">        System.out.println(<span class="string">&quot;It&#x27;s 2&quot;</span>);</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">default</span>:</span><br><span class="line">        System.out.println(<span class="string">&quot;Default case&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p>对于特定需要对特殊类型进行判断的场景，可以使用if-else或map来代替switch。</p>
<h4 id="问：switch、if-else、map的对比？"><a href="#问：switch、if-else、map的对比？" class="headerlink" title="问：switch、if-else、map的对比？"></a>问：switch、if-else、map的对比？</h4><ol>
<li>switch：<ul>
<li>最简洁、代码可读性高，对于常量值（如 <code>int</code>、<code>char</code>、<code>enum</code> 等），编译器可以生成高效的查找表或跳转表，从而提高执行效率。适用于固定且有限的离散值判断。</li>
<li>不支持 <code>long</code> 类型以及复杂的条件表达式。不能用于范围条件（如 <code>x &gt; 10 &amp;&amp; x &lt; 20</code>）。</li>
</ul>
</li>
<li>if-else：<ul>
<li>灵活性高，可以处理任意布尔表达式和复杂的条件判断，包括范围判断、逻辑运算等。可以支持所有数据类型。适用于复杂条件判断。</li>
<li>条件过多时，代码可读性差。</li>
</ul>
</li>
<li>map：<ul>
<li>查找效率高。当编译时无法确定条件值时，可以动态进行条件判断。</li>
<li>需要额外内存，代码可读性差。</li>
</ul>
</li>
</ol>
<h4 id="问：谈谈-final-finally-finalize-？"><a href="#问：谈谈-final-finally-finalize-？" class="headerlink" title="问：谈谈 final, finally, finalize ？"></a>问：谈谈 final, finally, finalize ？</h4><ul>
<li><p>final：修饰符，用于定义不可变的变量、不可继承的类以及不可覆盖的方法。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 值不能被修改，且必须在声明时初始化，或者在构造函数中初始化。</span></span><br><span class="line"><span class="keyword">final</span> <span class="keyword">int</span> MAX_VALUE = <span class="number">100</span>;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 不能在子类中被重写（Override）</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title">display</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;Display method in Parent&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 不能被继承（Subclass）</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">FinalClass</span> </span>&#123;</span><br><span class="line">    <span class="comment">// class content</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li><p>finally：是一个块，用于异常处理中的 <code>try-catch</code> 结构中。<code>finally</code> 块中的代码无论是否发生异常都会执行。一般用来执行清除工作或缺省处理。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">    <span class="comment">// code that may throw an exception</span></span><br><span class="line">&#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">    <span class="comment">// handle the exception</span></span><br><span class="line">&#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">    <span class="comment">// code that will always execute, regardless of whether an exception occurred</span></span><br><span class="line">    <span class="comment">// e.g., closing files, releasing resources</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li><p>finalize：是 <code>Object</code> 类中的一个方法，目的是在垃圾回收器决定销毁对象之前，进行资源的清理工作。垃圾收集器会确认对象是否已没有引用。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">finalize</span><span class="params">()</span> <span class="keyword">throws</span> Throwable </span>&#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="comment">// cleanup code</span></span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        <span class="keyword">super</span>.finalize();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>finalize</code> 方法的调用时机不可预测，可能导致性能问题。建议使用 <code>try-with-resources</code> 语句和显式的资源管理来替代 <code>finalize</code>。在 Java 9 及更高版本中，<code>finalize</code> 方法已被标记为过时，建议使用 <code>java.lang.ref.Cleaner</code> 或 <code>java.lang.ref.PhantomReference</code> 作为替代方案。</p>
</li>
</ul>
<h4 id="问：谈谈-static-？以及为什么Java不允许静态方法访问非静态变量"><a href="#问：谈谈-static-？以及为什么Java不允许静态方法访问非静态变量" class="headerlink" title="问：谈谈 static ？以及为什么Java不允许静态方法访问非静态变量?"></a>问：谈谈 static ？以及为什么Java不允许静态方法访问非静态变量?</h4><ul>
<li><p><code>static</code> 是一个修饰符，用于声明类级别的成员（变量、方法和块）。</p>
<ul>
<li><p>静态变量：所有实例共享的，所有对象都访问同一份数据。只在类加载时初始化，并且只初始化一次。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Counter</span> </span>&#123;</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">int</span> count = <span class="number">0</span>;  <span class="comment">// 类变量</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">increment</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        count++;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 每个 Counter 类的实例都会共享同一个 count 变量。</span></span><br></pre></td></tr></table></figure></li>
<li><p>静态方法：可以在没有创建类实例的情况下被调用。可以通过类名直接调用 <code>static</code> 方法。<code>static</code> 方法只能访问 <code>static</code> 变量和调用其他 <code>static</code> 方法。不能直接访问实例变量和实例方法（非静态）。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MathUtils</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">static</span> <span class="keyword">int</span> <span class="title">add</span><span class="params">(<span class="keyword">int</span> a, <span class="keyword">int</span> b)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> a + b;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">int</span> sum = MathUtils.add(<span class="number">5</span>, <span class="number">10</span>);  <span class="comment">// 通过类名调用 static 方法</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li><p>静态块：用于初始化 <code>static</code> 变量。它在类加载时执行，并且在类的所有 <code>static</code> 变量初始化之前执行一次。在类加载时，<code>static</code> 块的执行顺序早于任何静态变量的初始化。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Example</span> </span>&#123;</span><br><span class="line">    <span class="keyword">static</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;Static block executed&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">int</span> value = <span class="number">10</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li><p>静态内部类：是一个静态嵌套类，它与外部类的实例无关。只能访问外部类的 <code>static</code> 成员，不能直接访问外部类的实例成员。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Outer</span> </span>&#123;</span><br><span class="line">    <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Inner</span> </span>&#123;</span><br><span class="line">        <span class="function"><span class="keyword">void</span> <span class="title">display</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;Inside static nested class&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
</li>
</ul>
<p>为什么Java不允许静态方法访问非静态变量?</p>
<ul>
<li>非静态变量需要关联一个实例化对象。静态方法在没有对象实例的情况下也可以被调用。</li>
<li>静态方法的生命周期和作用范围是整个类，而非静态变量的生命周期和作用范围是对象实例。</li>
</ul>
<h2 id="四-字符串和对象"><a href="#四-字符串和对象" class="headerlink" title="四. 字符串和对象"></a>四. 字符串和对象</h2><h4 id="问：String是不是java的基本类型？"><a href="#问：String是不是java的基本类型？" class="headerlink" title="问：String是不是java的基本类型？"></a>问：String是不是java的基本类型？</h4><p>答：不是，String是引用类型，虽然有常量的一些特性。是 Java 标准库中的一个类，定义在 <code>java.lang</code> 包中。</p>
<h4 id="问：String为什么要是final类型的？"><a href="#问：String为什么要是final类型的？" class="headerlink" title="问：String为什么要是final类型的？"></a>问：String为什么要是final类型的？</h4><ol>
<li>要<strong>保证字符串的不可变性</strong>，从而保证使用字符串时的<strong>安全</strong>和<strong>高效</strong>。<ul>
<li>字符串常量池的设计采用享元模式，需要字符串的不可变性。假如字符串可变，共享元素在一处被改变，所有使用者都会感知到变化。</li>
</ul>
</li>
<li><strong>线程安全</strong>：如果字符串可变性会使软件安全性降低，不可变就意味着不会被篡改，同样也意味着线程安全。</li>
<li><strong>哈希码缓存</strong>：<code>String</code> 对象在作为键使用时（如在 <code>HashMap</code> 中），其哈希码计算是昂贵的。如果 <code>String</code> 是可变的，每次访问 <code>hashCode</code> 时都可能产生不同的值，因此不能依赖哈希码来维护一致性。</li>
<li><strong>性能优化</strong>：将 <code>String</code> 类声明为 <code>final</code> 允许 JVM 优化 <code>String</code> 对象的存储和重用。常量池技术可以重用相同的 <code>String</code> 实例，减少内存占用和创建开销，提高性能。</li>
</ol>
<h4 id="问：String，StringBuffer，StringBuilder的区别？"><a href="#问：String，StringBuffer，StringBuilder的区别？" class="headerlink" title="问：String，StringBuffer，StringBuilder的区别？"></a>问：String，StringBuffer，StringBuilder的区别？</h4><ul>
<li>String是字符串常量，是不可变的，一旦创建了一个 <code>String</code> 对象，它的内容不能被改变。对 <code>String</code> 对象的任何修改都会创建一个新的 <code>String</code> 对象。<ul>
<li>适用于对字符串进行少量操作或不需要频繁修改的场景，例如常量和配置。</li>
</ul>
</li>
<li>StringBuffer 是可变的，允许对字符串进行修改而不会创建新的对象。其所有方法都被 <code>synchronized</code> 修饰，以确保在多线程环境中的安全性。<ul>
<li>适用于多线程环境中需要频繁修改字符串的场景。由于同步开销，在单线程环境下性能较差。</li>
</ul>
</li>
<li>StringBuilder也是可变的，但不进行同步。字符串的拼接操作会隐性的转换为StringBuilder。<ul>
<li>适用于单线程环境中需要频繁修改字符串的场景。</li>
</ul>
</li>
</ul>
<h4 id="问：享元模式？"><a href="#问：享元模式？" class="headerlink" title="问：享元模式？"></a>问：享元模式？</h4><ul>
<li><p>享元模式（Flyweight Pattern）旨在通过共享对象来减少内存消耗和提高性能。核心思想是将对象的共享和不可变部分与每个对象独有的部分分开，以减少系统的内存占用。</p>
</li>
<li><p>概念：</p>
<ul>
<li><strong>享元（Flyweight）</strong>：是可以被共享的对象，主要用来复用对象实例。享元对象包含了对象的共有部分（内蕴状态），这部分是可以被多个对象共享的。</li>
<li><strong>内蕴状态（Intrinsic State）</strong>：享元对象中可以被共享的部分。内蕴状态是不变的，对象的内部状态，不会随着对象的使用而变化。</li>
<li><strong>外蕴状态（Extrinsic State）</strong>：享元对象中不能共享的部分，需要在对象外部维护的状态。这部分状态是变化的，可以根据上下文传递给享元对象。</li>
<li><strong>享元工厂（Flyweight Factory）</strong>：负责创建和管理享元对象，并确保对象的共享。在工厂中可以查找和重用已经创建的享元对象。</li>
</ul>
</li>
<li><p>示例：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 1. 定义享元接口</span></span><br><span class="line"><span class="class"><span class="keyword">interface</span> <span class="title">Tree</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">display</span><span class="params">(String location)</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 2. 实现具体享元类</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">TreeType</span> <span class="keyword">implements</span> <span class="title">Tree</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> String type; <span class="comment">// 内蕴状态</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">TreeType</span><span class="params">(String type)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.type = type;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">display</span><span class="params">(String location)</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;Tree Type: &quot;</span> + type + <span class="string">&quot; at location: &quot;</span> + location);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 3. 创建享元工厂</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">TreeFactory</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> Map&lt;String, Tree&gt; treeMap = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Tree <span class="title">getTree</span><span class="params">(String type)</span> </span>&#123;</span><br><span class="line">        Tree tree = treeMap.get(type);</span><br><span class="line">        <span class="keyword">if</span> (tree == <span class="keyword">null</span>) &#123;</span><br><span class="line">            tree = <span class="keyword">new</span> TreeType(type);</span><br><span class="line">            treeMap.put(type, tree);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> tree;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 4. 使用享元模式</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">FlyweightPatternExample</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Tree tree1 = TreeFactory.getTree(<span class="string">&quot;Pine&quot;</span>);</span><br><span class="line">        tree1.display(<span class="string">&quot;Forest&quot;</span>);</span><br><span class="line"></span><br><span class="line">        Tree tree2 = TreeFactory.getTree(<span class="string">&quot;Oak&quot;</span>);</span><br><span class="line">        tree2.display(<span class="string">&quot;Park&quot;</span>);</span><br><span class="line"></span><br><span class="line">        Tree tree3 = TreeFactory.getTree(<span class="string">&quot;Pine&quot;</span>);</span><br><span class="line">        tree3.display(<span class="string">&quot;Garden&quot;</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// Output:</span></span><br><span class="line">        <span class="comment">// Tree Type: Pine at location: Forest</span></span><br><span class="line">        <span class="comment">// Tree Type: Oak at location: Park</span></span><br><span class="line">        <span class="comment">// Tree Type: Pine at location: Garden</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
<h4 id="问：字符串编码的区别？"><a href="#问：字符串编码的区别？" class="headerlink" title="问：字符串编码的区别？"></a>问：字符串编码的区别？</h4><ul>
<li>字符串编码是将字符集中的字符转换成计算机可识别的字节序列的过程。</li>
<li>字符串编码用固定的字节来表示一系列字符，常见的如ASCII，Unicode 和 UTF-8等。最早由美国制定的ASCII只包含常见的英文字母和数字等，后来各个国家制定了包含自家语言的编码格式如包含中文的GB2312等。多种标准的诞生也带来了各种冲突和乱码的现象，所以便催生出Unicode标准统一所有语言。</li>
<li>ASCII编码是1个字节，Unicode编码通常是2个字节。</li>
<li>因此如果是纯英文文本使用Unicode就要多出一倍的存储空间，为了减少这种浪费，又出现了可变长编码：UTF-8。将一个Unicode字符根据不同的数字大小编码成1-6个字节，英文字母是1个字节，汉字则是3个字节。UTF-8这种特性同时也使它兼容了ASCII编码，使得一些上了历史的软件也能在新的编码标准下工作。目前计算机内存中统一使用Unicode编码，当需要保存到硬盘或进行传输时就转换为UTF-8编码。</li>
</ul>
<h4 id="问：char-型变量中能不能存贮一个中文汉字？"><a href="#问：char-型变量中能不能存贮一个中文汉字？" class="headerlink" title="问：char 型变量中能不能存贮一个中文汉字？"></a>问：char 型变量中能不能存贮一个中文汉字？</h4><ul>
<li>可以，每个 <code>char</code> 类型变量占用 16 位（2 个字节），足以存放绝大多数正在使用的汉字。</li>
</ul>
<h4 id="问：简单描述String的原生方法intern？"><a href="#问：简单描述String的原生方法intern？" class="headerlink" title="问：简单描述String的原生方法intern？"></a>问：简单描述String的原生方法intern？</h4><ul>
<li>String的 <code>intern()</code> 方法是一个 native原生方法。<strong>将字符串对象添加到常量池中的方法，使得相同内容的字符串对象在内存中只存在一份</strong>。如果常量池中存在当前字符串，就会直接返回此字符串，若常量池没有，则先将字符串放入常量池内再返回。</li>
<li>字符串常量池（string pool）是一个有固定大小的HashTable，所以当存入的字符串变多时就会导致哈希冲突，使链表过长，导致 <code>String.intern()</code> 性能大幅下降。可以通过参数 <code>-XX:StringTableSize</code> 指定常量池大小。</li>
<li>字符串常量池在Java 7版本前位于<strong>非堆区</strong>的<strong>Perm Gen</strong>（永久代，HotSpot独有），后迁移到堆中，而Perm Gen在Java 8时被移除，其中的方法区移到了Metaspace（元空间），Metaspace不位于虚拟机内，而是使用本地内存，所以理论上最大可用空间是系统整个内存空间，将元数据剥离出Perm Gen提高GC效率，字符串与类元数据分开提升了独立性。</li>
<li>编译阶段字面量存入Class文件中的常量池表，当类在运行阶段被加载，常量池表会被加载到方法区，并将对应数据存放到运行时常量池。</li>
</ul>
<h4 id="问：创建字符串时的内部流程？两种字符串实例化方式在内存分配上有区别吗？"><a href="#问：创建字符串时的内部流程？两种字符串实例化方式在内存分配上有区别吗？" class="headerlink" title="问：创建字符串时的内部流程？两种字符串实例化方式在内存分配上有区别吗？"></a>问：创建字符串时的内部流程？两种字符串实例化方式在内存分配上有区别吗？</h4><ol>
<li>字符串可以通过两种方式创建：<strong>直接使用字面量</strong> 和 <strong>通过 <code>new</code> 关键字</strong>。</li>
<li>内部流程：<ul>
<li>字面量：<ol>
<li><strong>编译时</strong>：编译器将字符串字面量 <code>&quot;hello&quot;</code> 存储在 <code>.class</code> 文件的常量池表中。</li>
<li><strong>类加载时</strong>：类加载器将常量池表中的字符串字面量加载到 <strong>运行时常量池</strong>。</li>
<li><strong>运行时</strong>：当程序执行到 <code>String str1 = &quot;hello&quot;;</code> 语句时：<ul>
<li>JVM 检查字符串常量池中是否已经存在 “hello” 字符串。<ul>
<li>如果存在，则直接返回该字符串对象的引用。</li>
<li>如果不存在，则在堆内存中的 <strong>字符串常量池</strong> 中创建一个 <code>&quot;hello&quot;</code> 字符串对象，并返回它的引用。</li>
</ul>
</li>
</ul>
</li>
</ol>
</li>
<li>关键字：<ol>
<li>JVM 首先查看字面量 <code>&quot;hello&quot;</code> 是否存在于 <strong>字符串常量池</strong> 中。<ul>
<li>如果不存在，首先在 <strong>字符串常量池</strong> 中创建一个 <code>&quot;hello&quot;</code> 字符串对象。</li>
<li>如果存在，则使用已有的字符串对象。</li>
</ul>
</li>
<li>JVM 接着在 <strong>堆内存</strong> 中创建一个新的字符串对象，该对象是对字符串 <code>&quot;hello&quot;</code> 的 <strong>副本</strong>，并将 <code>str2</code> 引用指向堆中的新对象。</li>
</ol>
</li>
</ul>
</li>
<li>内存分配的区别：字符串常量赋值方式在类加载阶段就实现了实例化，并将字符串驻留在字符串常量池，而 <code>new</code> 实例化对象需要等到执行阶段，并不会和字符串常量池有关联。<ul>
<li>字面量：在堆内存中的 <strong>字符串常量池</strong> 中创建一个 <code>&quot;hello&quot;</code> 字符串对象。</li>
<li>关键字：即使字符串常量池中已经存在相同的字符串对象，JVM 仍然会在堆中重新创建一个新的字符串对象。</li>
</ul>
</li>
</ol>
<h4 id="问：谈下equals和-的区别？equals和hashcode的用法及区别？为什么重写equals方法时还要重写hashcode方法？"><a href="#问：谈下equals和-的区别？equals和hashcode的用法及区别？为什么重写equals方法时还要重写hashcode方法？" class="headerlink" title="问：谈下equals和==的区别？equals和hashcode的用法及区别？为什么重写equals方法时还要重写hashcode方法？"></a>问：谈下equals和==的区别？equals和hashcode的用法及区别？为什么重写equals方法时还要重写hashcode方法？</h4><ul>
<li>谈下equals和==的区别？<ul>
<li>== 是<strong>运算符</strong>，<strong>基础数据类型直接比较值，引用类型则比较两个对象的引用是否相等</strong>，是否指向同一个内存地址。</li>
<li>equals<strong>比较两个对象的内容是否相等</strong>。默认实现来自 <code>Object</code> 类，通常比较对象的引用是否相等，但可以被子类重写以实现内容比较。</li>
</ul>
</li>
<li>equals和hashcode的用法及区别？<ul>
<li>hashcode方法用于创建散列表时<strong>获取对象的哈希码值</strong>，equals则用于<strong>对象的等值判断</strong>。当重写 <code>equals</code> 方法时，也应该重写 <code>hashCode</code> 方法，以确保对象的哈希码一致。</li>
<li>equals相等则hashcode必定相等，hashcode相等equals未必相等。前者是散列表取值时需要先判断hashcode（hashcode比较效率较高），所以只有hashcode相等才能取到正确的值。哈希值相等的两个对象未必是相等的（哈希冲突），因为哈希码并不是百分百可靠。</li>
</ul>
</li>
<li>为什么重写equals方法时还要重写hashcode方法？<ul>
<li><strong>重写equals后很可能导致equals相等时hashcode却不相同</strong>，会在许多散列表的使用场景下出错（Set或HashMap取值），哈希值不同导致对象存储在不同的桶中，所以重写equals时也要重写hashcode。</li>
</ul>
</li>
</ul>
<p><a href="../2018123101.html" title="Title">equals和hashCode异同</a></p>
<h4 id="问：深拷贝与浅拷贝？"><a href="#问：深拷贝与浅拷贝？" class="headerlink" title="问：深拷贝与浅拷贝？"></a>问：深拷贝与浅拷贝？</h4><ul>
<li><p><strong>浅拷贝</strong>是指创建一个新对象，然后将原对象的字段值复制到新对象中。对于基本数据类型字段，浅拷贝会直接复制值；对于引用类型字段，浅拷贝仅复制引用，指向同一个对象。因此，原对象和新对象的引用类型字段将指向同一个内存地址，导致它们共享同一份数据。浅拷贝通常通过 <code>Object.clone()</code> 方法实现。为了支持浅拷贝，需要实现 <code>Cloneable</code> 接口，并重写 <code>clone</code> 方法。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Person</span> <span class="keyword">implements</span> <span class="title">Cloneable</span> </span>&#123;</span><br><span class="line">    String name;</span><br><span class="line">    Address address; <span class="comment">// Address 是一个引用类型</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Person</span><span class="params">(String name, Address address)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.name = name;</span><br><span class="line">        <span class="keyword">this</span>.address = address;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> Object <span class="title">clone</span><span class="params">()</span> <span class="keyword">throws</span> CloneNotSupportedException </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">super</span>.clone(); <span class="comment">// 浅拷贝</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Address</span> </span>&#123;</span><br><span class="line">    String city;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Address</span><span class="params">(String city)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.city = city;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ShallowCopyExample</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> CloneNotSupportedException </span>&#123;</span><br><span class="line">        Address addr = <span class="keyword">new</span> Address(<span class="string">&quot;New York&quot;</span>);</span><br><span class="line">        Person person1 = <span class="keyword">new</span> Person(<span class="string">&quot;John&quot;</span>, addr);</span><br><span class="line">        Person person2 = (Person) person1.clone(); <span class="comment">// 浅拷贝</span></span><br><span class="line"></span><br><span class="line">        System.out.println(person1.address == person2.address); <span class="comment">// 输出 true，说明地址是共享的</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li><p><strong>深拷贝</strong>是指创建一个新对象，并且递归地复制原对象所引用的所有对象。这样，新对象及其内部对象都与原对象完全独立，不会共享任何数据。深拷贝通常需要手动实现，因为 Java 中没有提供内置的方法来自动进行深拷贝。可以通过序列化+反序列化、复制构造函数、手动递归复制、第三方类库（Apache Commons Lang、Jackson、Gson）等方法实现深拷贝。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Person</span> <span class="keyword">implements</span> <span class="title">Cloneable</span> </span>&#123;</span><br><span class="line">    String name;</span><br><span class="line">    Address address;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Person</span><span class="params">(String name, Address address)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.name = name;</span><br><span class="line">        <span class="keyword">this</span>.address = address;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> Object <span class="title">clone</span><span class="params">()</span> <span class="keyword">throws</span> CloneNotSupportedException </span>&#123;</span><br><span class="line">        Person cloned = (Person) <span class="keyword">super</span>.clone(); <span class="comment">// 浅拷贝</span></span><br><span class="line">        cloned.address = <span class="keyword">new</span> Address(<span class="keyword">this</span>.address.city); <span class="comment">// 手动深拷贝</span></span><br><span class="line">        <span class="keyword">return</span> cloned;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Address</span> </span>&#123;</span><br><span class="line">    String city;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Address</span><span class="params">(String city)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.city = city;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">DeepCopyExample</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> CloneNotSupportedException </span>&#123;</span><br><span class="line">        Address addr = <span class="keyword">new</span> Address(<span class="string">&quot;New York&quot;</span>);</span><br><span class="line">        Person person1 = <span class="keyword">new</span> Person(<span class="string">&quot;John&quot;</span>, addr);</span><br><span class="line">        Person person2 = (Person) person1.clone(); <span class="comment">// 深拷贝</span></span><br><span class="line"></span><br><span class="line">        System.out.println(person1.address == person2.address); <span class="comment">// 输出 false，说明地址是独立的</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure></li>
<li><p>深拷贝和浅拷贝主要区别在<strong>是否支持引用类型的拷贝</strong>，浅拷贝对于可变对象无法保证数据安全，深拷贝会把对象里面嵌套对象这种结构完整的拷贝下来。</p>
</li>
</ul>
<p><a href="../2018083001.html" title="Title">Java对象克隆</a></p>
<h2 id="五-类与接口"><a href="#五-类与接口" class="headerlink" title="五. 类与接口"></a>五. 类与接口</h2><h4 id="问：什么是泛型？类型擦除？"><a href="#问：什么是泛型？类型擦除？" class="headerlink" title="问：什么是泛型？类型擦除？"></a>问：什么是泛型？类型擦除？</h4><ul>
<li><p>泛型，即参数化类型，把类型当作参数一样传递，增强代码的 <strong>类型安全性</strong> 、 <strong>可重用性</strong> 、<strong>可读性与维护性</strong>。</p>
</li>
<li><p>使用：</p>
<ol>
<li><p>泛型类：允许在声明时定义一个或多个类型参数。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 定义泛型类，T 是类型参数</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Box</span>&lt;<span class="title">T</span>&gt; </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> T value;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setValue</span><span class="params">(T value)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.value = value;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> T <span class="title">getValue</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> value;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 使用</span></span><br><span class="line">Box&lt;String&gt; stringBox = <span class="keyword">new</span> Box&lt;&gt;();</span><br><span class="line">stringBox.setValue(<span class="string">&quot;Hello&quot;</span>);</span><br><span class="line">System.out.println(stringBox.getValue());  <span class="comment">// 输出 &quot;Hello&quot;</span></span><br><span class="line"></span><br><span class="line">Box&lt;Integer&gt; intBox = <span class="keyword">new</span> Box&lt;&gt;();</span><br><span class="line">intBox.setValue(<span class="number">100</span>);</span><br><span class="line">System.out.println(intBox.getValue());  <span class="comment">// 输出 100</span></span><br></pre></td></tr></table></figure></li>
<li><p>泛型方法：在方法中定义泛型类型，可以用于任何类或接口。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">GenericMethod</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 定义一个泛型方法，T 是类型参数</span></span><br><span class="line">    <span class="keyword">public</span> &lt;T&gt; <span class="function"><span class="keyword">void</span> <span class="title">printArray</span><span class="params">(T[] array)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (T element : array) &#123;</span><br><span class="line">            System.out.println(element);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 使用</span></span><br><span class="line">GenericMethod gm = <span class="keyword">new</span> GenericMethod();</span><br><span class="line">Integer[] intArray = &#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>&#125;;</span><br><span class="line">String[] strArray = &#123;<span class="string">&quot;A&quot;</span>, <span class="string">&quot;B&quot;</span>, <span class="string">&quot;C&quot;</span>&#125;;</span><br><span class="line">gm.&lt;Integer&gt;printArray(intArray);  <span class="comment">// 输出 1 2 3</span></span><br><span class="line">gm.&lt;String&gt;printArray(strArray);   <span class="comment">// 输出 A B C</span></span><br></pre></td></tr></table></figure></li>
<li><p>泛型接口：类似于泛型类，接口中也可以定义类型参数。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">GenericInterface</span>&lt;<span class="title">T</span>&gt; </span>&#123;</span><br><span class="line">    <span class="function">T <span class="title">getValue</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">setValue</span><span class="params">(T value)</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">GenericClass</span>&lt;<span class="title">T</span>&gt; <span class="keyword">implements</span> <span class="title">GenericInterface</span>&lt;<span class="title">T</span>&gt; </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> T value;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> T <span class="title">getValue</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> value;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setValue</span><span class="params">(T value)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.value = value;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 使用</span></span><br><span class="line">GenericClass&lt;String&gt; genericString = <span class="keyword">new</span> GenericClass&lt;&gt;();</span><br><span class="line">genericString.setValue(<span class="string">&quot;Hello&quot;</span>);</span><br><span class="line">System.out.println(genericString.getValue());</span><br></pre></td></tr></table></figure></li>
</ol>
</li>
<li><p>Java编译器生成的字节码是不包涵泛型信息的，泛型类型信息将在编译处理时被擦除，将泛型类型转换为它们的 <strong>原始类型</strong>（通常是 <code>Object</code> 或限定的上界类型），这个过程即<strong>类型擦除</strong>。</p>
</li>
<li><p>过程：编译期间，Java 会执行以下步骤</p>
<ol>
<li><strong>泛型类型替换</strong>：编译器会将泛型类型替换为其 <strong>限定的类型</strong> 或 <strong>Object</strong>。<ul>
<li>如果泛型声明了上限（如 <code>&lt;T extends Number&gt;</code>），编译器会将泛型替换为上限类型。用其最左边界（最顶级的父类型）类型替换。</li>
<li>如果没有指定上限，泛型将被替换为 <code>Object</code>。</li>
</ul>
</li>
<li><strong>插入类型检查和类型转换</strong>：在插入泛型类型的地方，编译器会自动插入类型检查和类型转换代码，以确保类型安全性。</li>
<li><strong>生成字节码</strong>：擦除后的代码与非泛型代码基本一致，泛型信息在运行时不可见。</li>
</ol>
</li>
<li><p>泛型方法进行类型擦除后是否会与多态矛盾？虚拟机生成<strong>桥方法</strong>来保持多态。在子类中生成一个桥方法，也就是对父类方法的重写。</p>
</li>
</ul>
<p>参考：<a href="../2019022101.html" title="Title">泛型和类型擦除</a></p>
<h4 id="问：Comparable-和-Comparator-接口是干什么的，其区别？"><a href="#问：Comparable-和-Comparator-接口是干什么的，其区别？" class="headerlink" title="问：Comparable 和 Comparator 接口是干什么的，其区别？"></a>问：Comparable 和 Comparator 接口是干什么的，其区别？</h4><ul>
<li><p>Comparable 是<strong>排序</strong>接口，表示实现类支持排序，就可以通过工具类Collections.sort或Arrays.sort等进行排序。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Person</span> <span class="keyword">implements</span> <span class="title">Comparable</span>&lt;<span class="title">Person</span>&gt; </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> age;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Person</span><span class="params">(String name, <span class="keyword">int</span> age)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.name = name;</span><br><span class="line">        <span class="keyword">this</span>.age = age;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">compareTo</span><span class="params">(Person other)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">this</span>.age - other.age;  <span class="comment">// 按照年龄升序排序</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">toString</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> name + <span class="string">&quot;: &quot;</span> + age;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">List&lt;Person&gt; people = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">people.add(<span class="keyword">new</span> Person(<span class="string">&quot;Alice&quot;</span>, <span class="number">30</span>));</span><br><span class="line">people.add(<span class="keyword">new</span> Person(<span class="string">&quot;Bob&quot;</span>, <span class="number">25</span>));</span><br><span class="line">people.add(<span class="keyword">new</span> Person(<span class="string">&quot;Charlie&quot;</span>, <span class="number">35</span>));</span><br><span class="line"></span><br><span class="line">Collections.sort(people);  <span class="comment">// 自动按年龄排序</span></span><br><span class="line">System.out.println(people);</span><br></pre></td></tr></table></figure></li>
<li><p>Comparator 则是<strong>比较器</strong>接口，实现类本身不支持排序，而是支持对另一个类进行排序的比较器。是一个<strong>外部比较器</strong>，它用于定义任意两个对象之间的比较方式。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">AgeComparator</span> <span class="keyword">implements</span> <span class="title">Comparator</span>&lt;<span class="title">Person</span>&gt; </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">compare</span><span class="params">(Person p1, Person p2)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> p1.getAge() - p2.getAge();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">NameComparator</span> <span class="keyword">implements</span> <span class="title">Comparator</span>&lt;<span class="title">Person</span>&gt; </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">compare</span><span class="params">(Person p1, Person p2)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> p1.getName().compareTo(p2.getName());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">List&lt;Person&gt; people = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">people.add(<span class="keyword">new</span> Person(<span class="string">&quot;Alice&quot;</span>, <span class="number">30</span>));</span><br><span class="line">people.add(<span class="keyword">new</span> Person(<span class="string">&quot;Bob&quot;</span>, <span class="number">25</span>));</span><br><span class="line">people.add(<span class="keyword">new</span> Person(<span class="string">&quot;Charlie&quot;</span>, <span class="number">35</span>));</span><br><span class="line"></span><br><span class="line"><span class="comment">// 使用自定义的比较器排序</span></span><br><span class="line">Collections.sort(people, <span class="keyword">new</span> NameComparator());  <span class="comment">// 按名字排序</span></span><br><span class="line">System.out.println(people);</span><br></pre></td></tr></table></figure></li>
<li><p>Comparable实现类具有排序属性，相当于内部比较器。Comparator实现类就是一个比较类，相当于外部比较器。**<code>Comparable</code>** 适用于对象有固定的、自然的排序需求，例如数字、日期、姓名按字母顺序排序等。**<code>Comparator</code>** 适用于当你需要对同一类对象使用多种排序逻辑（例如按年龄、按名字等）或对外部无法修改的类进行排序。</p>
</li>
<li><p>在 Java 8 中，<code>Comparator</code> 接口提供了许多实用的默认方法，如 <code>comparing()</code>、<code>thenComparing()</code>、<code>reversed()</code> 等，可以更加简洁地创建比较器。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">List&lt;Person&gt; people = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">people.add(<span class="keyword">new</span> Person(<span class="string">&quot;Alice&quot;</span>, <span class="number">30</span>));</span><br><span class="line">people.add(<span class="keyword">new</span> Person(<span class="string">&quot;Bob&quot;</span>, <span class="number">25</span>));</span><br><span class="line">people.add(<span class="keyword">new</span> Person(<span class="string">&quot;Charlie&quot;</span>, <span class="number">35</span>));</span><br><span class="line"></span><br><span class="line"><span class="comment">// 按年龄排序</span></span><br><span class="line">people.sort(Comparator.comparingInt(Person::getAge));</span><br><span class="line"></span><br><span class="line"><span class="comment">// 按名字排序，先按字母升序，再按年龄升序</span></span><br><span class="line">people.sort(Comparator.comparing(Person::getName)</span><br><span class="line">                      .thenComparing(Person::getAge));</span><br></pre></td></tr></table></figure></li>
</ul>
<h4 id="问：接口和抽象类，你是怎么理解的？"><a href="#问：接口和抽象类，你是怎么理解的？" class="headerlink" title="问：接口和抽象类，你是怎么理解的？"></a>问：接口和抽象类，你是怎么理解的？</h4><ul>
<li>从设计来讲接口是<strong>对动作的抽象</strong>，而抽象类是对<strong>根源的抽象</strong>。例如员工是抽象类，而部门经理、研发人员等是实现类，而员工的行为可以抽象为接口，如工作接口、休息接口、吃饭接口等。</li>
<li>从语法来讲，抽象被类继承、接口被类实现，抽象类可以没有抽象方法，但一旦有抽象方法就必须是抽象类，<strong>接口则默认声明方法是 public abstract ，而成员变量默认是 public static final</strong> 。自 Java 8 以来，接口中可以包含<strong>默认方法</strong>（<code>default</code>）和<strong>静态方法</strong>，这使得接口的功能更接近于抽象类。默认方法允许接口定义部分实现，而不破坏现有接口的契约。</li>
<li>继承只能单一继承，而实现可以实现多个，所以抽象类成本要比接口大，接口扩展性更强。</li>
<li>当希望类可以实现多个不相关的行为时，使用接口。例如，一个类可能既是一个 <code>Movable</code>（可以移动的）对象，也可以是 <code>Serializable</code>（可序列化的）对象，类可以实现这些不同的接口。</li>
<li>当多个类有相同的基本行为，且需要共享这些行为的实现时，使用抽象类。例如，<code>Animal</code> 类可以提供 <code>sleep()</code> 的实现，所有动物都需要休眠，但不同的动物会有不同的声音。</li>
</ul>
<h4 id="问：异常类？继承结构？"><a href="#问：异常类？继承结构？" class="headerlink" title="问：异常类？继承结构？"></a>问：异常类？继承结构？</h4><p>所有异常都继承自<strong>Throwable</strong>，并分解为<strong>Error</strong>（错误）和<strong>Exception</strong>（异常）。</p>
<p>Throwable：</p>
<ul>
<li><p>Error（错误）：Error分支的类结构主要负责描述<strong>运行时系统的内部错误和资源耗尽错误</strong>。程序不应该抛出此类错误，出现此错误时除了告诉客户外还应该使程序安全的终止。</p>
<ul>
<li>OutOfMemoryError：当 JVM 内存不足时抛出。</li>
<li>StackOverflowError：当程序调用堆栈溢出（如无限递归）时抛出。</li>
<li>VirtualMachineError：当 JVM 出现严重问题时抛出。</li>
</ul>
</li>
<li><p>Exception（异常）：Exception分为两个分支，<strong>RuntimeException</strong>和<strong>受检异常</strong>。</p>
<ul>
<li>RuntimeException（运行时异常）：<strong>由程序错误导致的异常</strong><ul>
<li>NullPointerException：当程序尝试访问空对象的属性或方法时抛出。</li>
<li>ArrayIndexOutOfBoundsException：当数组索引越界时抛出。</li>
<li>ArithmeticException：当数学运算异常（如除以零）时抛出。</li>
<li>ClassCastException：当对象强制转换失败时抛出。</li>
<li>IllegalArgumentException：当传递给方法的参数不合法时抛出。</li>
<li>等等…</li>
</ul>
</li>
<li>CheckedException（受检异常）：程序本身没问题但因为IO等错误导致的异常。受检异常是编译时检查的异常，必须在方法中声明 <code>throws</code> 或用 <code>try-catch</code> 块处理，否则编译器会报错。<ul>
<li>IOException：表示输入输出操作失败时的异常。</li>
<li>SQLException：表示数据库操作失败时的异常。</li>
<li>FileNotFoundException：表示文件未找到时的异常。</li>
<li>ClassNotFoundException：表示找不到类时的异常。</li>
<li>等等…</li>
</ul>
</li>
</ul>
</li>
</ul>
<p>Java语言规范将派生于Error和RuntimeException的异常称为<strong>非受查异常</strong>unchecked，其它异常成为<strong>受查异常</strong>checked。若子类重写了父类的方法，其声明的受查异常不能比父类声明异常更通用。</p>
<h4 id="问：受检异常和运行时异常的区别？"><a href="#问：受检异常和运行时异常的区别？" class="headerlink" title="问：受检异常和运行时异常的区别？"></a>问：受检异常和运行时异常的区别？</h4><ol>
<li>首先所有异常都继承自<strong>Throwable</strong>，并分解为<strong>Error</strong>（错误）和<strong>Exception</strong>（异常）。</li>
<li>Error分支的类结构主要负责描述<strong>运行时系统的内部错误和资源耗尽错误</strong>。程序不应该抛出此类错误，出现此错误时除了告诉客户外还应该使程序安全的终止。</li>
<li>Exception分为RuntimeException（运行时异常）和CheckedException（受检异常）。<ul>
<li>受检异常是编译时检查的异常，必须在方法中声明 <code>throws</code> 或用 <code>try-catch</code> 块处理，否则编译器会报错。</li>
<li>RuntimeException（运行时异常则是<strong>由程序错误导致的异常</strong>。</li>
</ul>
</li>
</ol>
<h4 id="问：Java中的异常处理机制？"><a href="#问：Java中的异常处理机制？" class="headerlink" title="问：Java中的异常处理机制？"></a>问：Java中的异常处理机制？</h4><ol>
<li>通过面向对象的思想设计，将异常分类处理，并且可以自定义异常类。</li>
<li>提供 <code>try-catch-finally</code> 语句来捕获和处理异常，保证程序不会因为异常而崩溃。</li>
<li>通过 throw 关键字来抛出异常，通过 throws 声明方法可能抛出的异常。</li>
</ol>
<h2 id="六-文件与流"><a href="#六-文件与流" class="headerlink" title="六. 文件与流"></a>六. 文件与流</h2><h3 id="6-1-文件"><a href="#6-1-文件" class="headerlink" title="6.1 文件"></a>6.1 文件</h3><h4 id="问：说下如何操控文件-（输入输出）怎么关闭呢-发生异常怎么办"><a href="#问：说下如何操控文件-（输入输出）怎么关闭呢-发生异常怎么办" class="headerlink" title="问：说下如何操控文件?（输入输出）怎么关闭呢? 发生异常怎么办?"></a>问：说下如何操控文件?（输入输出）怎么关闭呢? 发生异常怎么办?</h4><p>答：</p>
<ul>
<li>通过<strong>I/O流</strong>来对文件进行操作，为了确保流的关闭会在finally语句块中进行close。Java 7后增加了带资源的try语句（try-with-resources），try块退出后会自动关闭资源。这样即使发生异常，也能确保不会因为流未关闭而造成内存泄漏或一直占用文件的情况。</li>
<li>最基本的文件读取类是 <code>FileInputStream</code> 或 <code>FileReader</code>，但通常推荐使用带缓冲的 <code>BufferedReader</code> 以提高效率。写入则可以通过 <code>FileWriter</code> 或 <code>BufferedWriter</code> 实现。</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">FileReadExample</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        BufferedReader reader = <span class="keyword">null</span>;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            reader = <span class="keyword">new</span> BufferedReader(<span class="keyword">new</span> FileReader(<span class="string">&quot;input.txt&quot;</span>));</span><br><span class="line">            String line;</span><br><span class="line">            <span class="keyword">while</span> ((line = reader.readLine()) != <span class="keyword">null</span>) &#123;</span><br><span class="line">                System.out.println(line);  <span class="comment">// 逐行读取并打印文件内容</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">            e.printStackTrace();  <span class="comment">// 处理可能的 IO 异常</span></span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            <span class="comment">// 确保资源关闭</span></span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                <span class="keyword">if</span> (reader != <span class="keyword">null</span>) &#123;</span><br><span class="line">                    reader.close();  <span class="comment">// 关闭文件流，避免资源泄漏</span></span><br><span class="line">                &#125;</span><br><span class="line">            &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">FileWriteExample</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        BufferedWriter writer = <span class="keyword">null</span>;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            writer = <span class="keyword">new</span> BufferedWriter(<span class="keyword">new</span> FileWriter(<span class="string">&quot;output.txt&quot;</span>));</span><br><span class="line">            writer.write(<span class="string">&quot;Hello, World!&quot;</span>);  <span class="comment">// 向文件写入数据</span></span><br><span class="line">            writer.newLine();  <span class="comment">// 写入换行符</span></span><br><span class="line">            writer.write(<span class="string">&quot;Java File I/O&quot;</span>);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">            e.printStackTrace();  <span class="comment">// 处理可能的 IO 异常</span></span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            <span class="comment">// 确保资源关闭</span></span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                <span class="keyword">if</span> (writer != <span class="keyword">null</span>) &#123;</span><br><span class="line">                    writer.close();  <span class="comment">// 关闭文件流，避免资源泄漏</span></span><br><span class="line">                &#125;</span><br><span class="line">            &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">FileReadWithResources</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">try</span> (BufferedReader reader = <span class="keyword">new</span> BufferedReader(<span class="keyword">new</span> FileReader(<span class="string">&quot;input.txt&quot;</span>))) &#123;</span><br><span class="line">            String line;</span><br><span class="line">            <span class="keyword">while</span> ((line = reader.readLine()) != <span class="keyword">null</span>) &#123;</span><br><span class="line">                System.out.println(line);  <span class="comment">// 逐行读取并打印文件内容</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">            e.printStackTrace();  <span class="comment">// 处理异常</span></span><br><span class="line">        &#125; </span><br><span class="line">        </span><br><span class="line">        <span class="keyword">try</span> (BufferedWriter writer = <span class="keyword">new</span> BufferedWriter(<span class="keyword">new</span> FileWriter(<span class="string">&quot;output.txt&quot;</span>))) &#123;</span><br><span class="line">            writer.write(<span class="string">&quot;Hello, World!&quot;</span>);  <span class="comment">// 写入文件</span></span><br><span class="line">            writer.newLine();</span><br><span class="line">            writer.write(<span class="string">&quot;Java File I/O&quot;</span>);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">            e.printStackTrace();  <span class="comment">// 处理异常</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h4 id="问：如何提高文件读写的性能？如何处理大文件而不导致内存溢出？"><a href="#问：如何提高文件读写的性能？如何处理大文件而不导致内存溢出？" class="headerlink" title="问：如何提高文件读写的性能？如何处理大文件而不导致内存溢出？"></a>问：如何提高文件读写的性能？如何处理大文件而不导致内存溢出？</h4><ol>
<li><p>使用缓冲流（<code>BufferedReader</code>、<code>BufferedWriter</code>）。与直接通过 <code>FileInputStream</code> 或 <code>FileOutputStream</code> 进行读写不同，缓冲流会先将数据存入内存中的缓冲区，减少实际的磁盘 I/O 操作，从而提高效率。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">BufferedFileReadWrite</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 使用缓冲流提高文件读写性能</span></span><br><span class="line">        <span class="keyword">try</span> (BufferedReader reader = <span class="keyword">new</span> BufferedReader(<span class="keyword">new</span> FileReader(<span class="string">&quot;input.txt&quot;</span>));</span><br><span class="line">             BufferedWriter writer = <span class="keyword">new</span> BufferedWriter(<span class="keyword">new</span> FileWriter(<span class="string">&quot;output.txt&quot;</span>))) &#123;</span><br><span class="line"></span><br><span class="line">            String line;</span><br><span class="line">            <span class="keyword">while</span> ((line = reader.readLine()) != <span class="keyword">null</span>) &#123;</span><br><span class="line">                writer.write(line);</span><br><span class="line">                writer.newLine();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>缓冲流减少了对磁盘的直接访问，通过在内存中累积数据后再一次性写入磁盘，减少了系统调用次数，提升了效率。</p>
</li>
<li><p>使用 NIO。提供了基于通道（Channel）和缓冲区（Buffer）的高效文件操作方式。NIO 的 <code>FileChannel</code> 是处理大文件时的理想选择，它允许文件的直接内存映射、随机读写和批量 I/O 操作。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">NIOFileCopy</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">        <span class="keyword">try</span> (FileChannel sourceChannel = <span class="keyword">new</span> FileInputStream(<span class="string">&quot;input.txt&quot;</span>).getChannel();</span><br><span class="line">             FileChannel targetChannel = <span class="keyword">new</span> FileOutputStream(<span class="string">&quot;output.txt&quot;</span>).getChannel()) &#123;</span><br><span class="line"></span><br><span class="line">            sourceChannel.transferTo(<span class="number">0</span>, sourceChannel.size(), targetChannel);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>NIO 的 <code>FileChannel</code> 支持直接内存映射，这意味着大文件的部分可以直接映射到内存，从而减少了不必要的内存开销和复制。</p>
</li>
<li><p>分批读写（分块处理大文件）处理大文件时，不应一次性将整个文件加载到内存中，这可能会<strong>导致内存溢出</strong>。可以通过分批次读取或写入的方式来避免这一问题。每次处理文件的一部分内容，将其分块读取。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">LargeFileProcessing</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        File inputFile = <span class="keyword">new</span> File(<span class="string">&quot;large_input.txt&quot;</span>);</span><br><span class="line">        <span class="keyword">long</span> fileSize = inputFile.length();</span><br><span class="line">        <span class="keyword">int</span> bufferSize = <span class="number">8</span> * <span class="number">1024</span>; <span class="comment">// 8KB 缓冲区大小</span></span><br><span class="line">        <span class="keyword">byte</span>[] buffer = <span class="keyword">new</span> <span class="keyword">byte</span>[bufferSize];</span><br><span class="line"></span><br><span class="line">        <span class="keyword">try</span> (InputStream in = <span class="keyword">new</span> FileInputStream(inputFile)) &#123;</span><br><span class="line">            <span class="keyword">int</span> bytesRead;</span><br><span class="line">            <span class="keyword">while</span> ((bytesRead = in.read(buffer)) != -<span class="number">1</span>) &#123;</span><br><span class="line">                <span class="comment">// 处理数据，例如写入到另一个文件中</span></span><br><span class="line">                processBuffer(buffer, bytesRead);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">processBuffer</span><span class="params">(<span class="keyword">byte</span>[] buffer, <span class="keyword">int</span> length)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 处理缓冲区的数据</span></span><br><span class="line">        System.out.println(<span class="string">&quot;Processing &quot;</span> + length + <span class="string">&quot; bytes&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li><p>内存映射文件（Memory Mapped File）是 NIO 中的高级功能，它允许将文件的一部分或全部直接映射到内存中。这种方式对于处理大文件和高性能 I/O 是非常高效的，尤其<strong>适用于随机访问大文件</strong>。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MemoryMappedFileExample</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        RandomAccessFile file = <span class="keyword">new</span> RandomAccessFile(<span class="string">&quot;large_input.txt&quot;</span>, <span class="string">&quot;rw&quot;</span>);</span><br><span class="line">        FileChannel channel = file.getChannel();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 将文件的前 1GB 映射到内存</span></span><br><span class="line">        MappedByteBuffer buffer = channel.map(FileChannel.MapMode.READ_WRITE, <span class="number">0</span>, <span class="number">1024</span> * <span class="number">1024</span> * <span class="number">1024</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 读取文件内容</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; buffer.limit(); i++) &#123;</span><br><span class="line">            <span class="keyword">byte</span> b = buffer.get(i);</span><br><span class="line">            <span class="comment">// 处理数据...</span></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        file.close();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li><p>多线程读写：对于非常大的文件，可以通过<strong>多线程并发读写</strong>来进一步提升性能。将文件分成多个块，每个块由不同的线程并发处理。需要注意的是，文件的多线程写入操作可能需要额外的同步机制。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MultiThreadFileReader</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 使用多个线程分别处理文件的不同部分</span></span><br><span class="line">        <span class="keyword">int</span> numberOfThreads = <span class="number">4</span>; <span class="comment">// 假设使用4个线程</span></span><br><span class="line">        File file = <span class="keyword">new</span> File(<span class="string">&quot;large_input.txt&quot;</span>);</span><br><span class="line">        <span class="keyword">long</span> fileSize = file.length();</span><br><span class="line">        <span class="keyword">long</span> partSize = fileSize / numberOfThreads;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; numberOfThreads; i++) &#123;</span><br><span class="line">            <span class="keyword">long</span> start = i * partSize;</span><br><span class="line">            <span class="keyword">long</span> end = (i == numberOfThreads - <span class="number">1</span>) ? fileSize : (i + <span class="number">1</span>) * partSize;</span><br><span class="line">            <span class="keyword">new</span> Thread(<span class="keyword">new</span> FileReadTask(file, start, end)).start();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">FileReadTask</span> <span class="keyword">implements</span> <span class="title">Runnable</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> File file;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">long</span> start;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">long</span> end;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">FileReadTask</span><span class="params">(File file, <span class="keyword">long</span> start, <span class="keyword">long</span> end)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.file = file;</span><br><span class="line">        <span class="keyword">this</span>.start = start;</span><br><span class="line">        <span class="keyword">this</span>.end = end;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">try</span> (RandomAccessFile raf = <span class="keyword">new</span> RandomAccessFile(file, <span class="string">&quot;r&quot;</span>)) &#123;</span><br><span class="line">            raf.seek(start);</span><br><span class="line">            <span class="keyword">byte</span>[] buffer = <span class="keyword">new</span> <span class="keyword">byte</span>[<span class="number">8</span> * <span class="number">1024</span>]; <span class="comment">// 8KB缓冲区</span></span><br><span class="line">            <span class="keyword">int</span> bytesRead;</span><br><span class="line">            <span class="keyword">long</span> totalBytesRead = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">while</span> ((bytesRead = raf.read(buffer)) != -<span class="number">1</span> &amp;&amp; totalBytesRead &lt; (end - start)) &#123;</span><br><span class="line">                totalBytesRead += bytesRead;</span><br><span class="line">                <span class="comment">// 处理数据</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ol>
<h4 id="问：文件的序列化和反序列化？如何在-Java-中将对象序列化到文件中？如何从文件中反序列化对象？"><a href="#问：文件的序列化和反序列化？如何在-Java-中将对象序列化到文件中？如何从文件中反序列化对象？" class="headerlink" title="问：文件的序列化和反序列化？如何在 Java 中将对象序列化到文件中？如何从文件中反序列化对象？"></a>问：文件的序列化和反序列化？如何在 Java 中将对象序列化到文件中？如何从文件中反序列化对象？</h4><h4 id="问：讲讲序列化？"><a href="#问：讲讲序列化？" class="headerlink" title="问：讲讲序列化？"></a>问：讲讲序列化？</h4><p>  <a href="../2020042501.html" title="Title">对象序列化</a></p>
<ul>
<li>序列化指<strong>将一个Java对象转化为二进制序列</strong>，可以看作一个 <code>byte[]</code> 字节数组。Java序列化基于两个接口：Serializable和Externalizable，Serializable接口有默认序列化机制。</li>
<li><strong>文件的序列化和反序列化？</strong>序列化和反序列化是将对象状态转换为字节流的过程，以及将字节流恢复为对象状态的过程。这通常用于将对象持久化到磁盘或通过网络传输对象。<ul>
<li>序列化（Serialization）是将对象的状态保存到字节流中，这样可以将对象存储到文件中、数据库中，或通过网络传输。必须让对象的类实现 <code>java.io.Serializable</code> 接口。<strong>然后使用 <code>ObjectOutputStream</code> 写对象到文件。</strong></li>
<li>反序列化（Deserialization）是将字节流恢复为对象状态的过程。这涉及到从文件或其他输入源中读取字节流，并将其转换回原始对象。反序列化过程要求对象的类与序列化时相同，并且实现了 <code>Serializable</code> 接口。<strong>使用 <code>ObjectInputStream</code> 从文件中读取对象</strong>。</li>
</ul>
</li>
<li><strong>如何在 Java 中将对象序列化到文件中？如何从文件中反序列化对象？</strong><ul>
<li>分别使用 <code>ObjectOutputStream</code> 和 <code>ObjectInputStream</code>。</li>
</ul>
</li>
<li>注意事项：<ol>
<li>**<code>serialVersionUID</code>**：<ul>
<li><code>serialVersionUID</code> 是一个版本控制标识符，用于确保序列化和反序列化过程中的兼容性。</li>
<li>如果类的 <code>serialVersionUID</code> 不匹配，将会抛出 <code>InvalidClassException</code> 异常。</li>
</ul>
</li>
<li><strong><code>transient</code> 关键字</strong>：<ul>
<li>使用 <code>transient</code> 关键字修饰的字段在序列化过程中会被忽略，即这些字段的值不会被写入到字节流中。</li>
<li>反序列化时，这些字段的值将被初始化为默认值。</li>
</ul>
</li>
<li><strong>可序列化的对象</strong>：<ul>
<li>序列化的对象必须实现 <code>Serializable</code> 接口。</li>
<li>序列化对象的字段也必须是可序列化的；如果字段是不可序列化的，可以标记为 <code>transient</code>。</li>
</ul>
</li>
<li><strong>性能和安全</strong>：<ul>
<li>反序列化操作可能会带来安全风险，特别是在处理来自不信任来源的数据时。</li>
<li>序列化和反序列化可以影响性能，特别是对于大对象或复杂对象图。</li>
</ul>
</li>
</ol>
</li>
</ul>
<p><strong>示例代码</strong>：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line">javaCopy code<span class="keyword">import</span> java.io.FileOutputStream;</span><br><span class="line"><span class="keyword">import</span> java.io.IOException;</span><br><span class="line"><span class="keyword">import</span> java.io.ObjectOutputStream;</span><br><span class="line"><span class="keyword">import</span> java.io.Serializable;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Person</span> <span class="keyword">implements</span> <span class="title">Serializable</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">long</span> serialVersionUID = <span class="number">1L</span>; <span class="comment">// 推荐定义</span></span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">transient</span> <span class="keyword">int</span> age; <span class="comment">// transient 关键字表示此字段不会被序列化</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Person</span><span class="params">(String name, <span class="keyword">int</span> age)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.name = name;</span><br><span class="line">        <span class="keyword">this</span>.age = age;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">toString</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;Person&#123;name=&#x27;&quot;</span> + name + <span class="string">&quot;&#x27;, age=&quot;</span> + age + <span class="string">&quot;&#125;&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SerializationExample</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Person person = <span class="keyword">new</span> Person(<span class="string">&quot;John&quot;</span>, <span class="number">30</span>);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">try</span> (ObjectOutputStream oos = <span class="keyword">new</span> ObjectOutputStream(<span class="keyword">new</span> FileOutputStream(<span class="string">&quot;person.ser&quot;</span>))) &#123;</span><br><span class="line">            oos.writeObject(person); <span class="comment">// 序列化对象到文件</span></span><br><span class="line">        &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">DeserializationExample</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">try</span> (ObjectInputStream ois = <span class="keyword">new</span> ObjectInputStream(<span class="keyword">new</span> FileInputStream(<span class="string">&quot;person.ser&quot;</span>))) &#123;</span><br><span class="line">            Person person = (Person) ois.readObject(); <span class="comment">// 从文件中反序列化对象</span></span><br><span class="line">            System.out.println(person); <span class="comment">// 输出反序列化后的对象</span></span><br><span class="line">        &#125; <span class="keyword">catch</span> (IOException | ClassNotFoundException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h3 id="IO流"><a href="#IO流" class="headerlink" title="IO流"></a>IO流</h3><h4 id="问：讲讲你所知道的IO流？"><a href="#问：讲讲你所知道的IO流？" class="headerlink" title="问：讲讲你所知道的IO流？"></a>问：讲讲你所知道的IO流？</h4><ol>
<li>根据传输的基本单位分为<strong>字节流</strong>和<strong>字符流</strong>，字节流一般以Stream命名，字符流则以Reader/Writer命名。</li>
<li>字节流用来处理字节（字节流一次只能操作一个字节，适合处理二进制文件）。字符流用来处理字节流不方便处理的Unicode格式（字符流以字符为单位处理数据，适用于处理文本文件）。</li>
<li>根据读出或写入一个字节序列可以把字节流分为输出流和输入流，流处理的对象可以是文件、网络连接或内存块。</li>
</ol>
<ul>
<li>字节输入流（InputStream）：<ul>
<li><strong>FileInputStream</strong>：从文件中读取字节数据。</li>
<li><strong>BufferedInputStream</strong>：为输入流提供缓冲功能，提高读取性能。</li>
<li><strong>ByteArrayInputStream</strong>：从字节数组中读取数据。</li>
<li><strong>ObjectInputStream</strong>：用于读取序列化对象。</li>
</ul>
</li>
<li>字节输出流（OutputStream）：<ul>
<li><strong>FileOutputStream</strong>：将字节数据写入文件。</li>
<li><strong>BufferedOutputStream</strong>：为输出流提供缓冲功能，提高写入性能。</li>
<li><strong>ByteArrayOutputStream</strong>：将数据写入字节数组中。</li>
<li><strong>ObjectOutputStream</strong>：用于序列化对象并写入流中。</li>
</ul>
</li>
<li>字符输入流（Reader）：<ul>
<li><strong>FileReader</strong>：从文件中读取字符数据。</li>
<li><strong>BufferedReader</strong>：为字符输入流提供缓冲功能，并提供按行读取的功能。</li>
<li><strong>InputStreamReader</strong>：将字节输入流转换为字符输入流，通常用于处理带有编码的字节数据。</li>
</ul>
</li>
<li>字符输出流（Writer）：<ul>
<li><strong>FileWriter</strong>：将字符数据写入文件。</li>
<li><strong>BufferedWriter</strong>：为字符输出流提供缓冲功能，支持批量写入。</li>
<li><strong>OutputStreamWriter</strong>：将字节输出流转换为字符输出流，通常用于处理带有编码的字节数据。</li>
</ul>
</li>
</ul>
<h4 id="问：讲讲字符流和字节流的区别？"><a href="#问：讲讲字符流和字节流的区别？" class="headerlink" title="问：讲讲字符流和字节流的区别？"></a>问：讲讲字符流和字节流的区别？</h4><ul>
<li>处理对象不同，虽然本质上计算机传输都是字节，但字符流提供了对Unicode的直接操作，字节流则只能处理字节。</li>
<li>字节流操作时不会用到缓冲区，直接在文件操作，而字符流则会先在缓冲区上操作，在关闭时再强制性的把缓冲区内容输出，缓冲区其实就是一块特殊的内存区域，读取速度要远远高于读取磁盘的速度。</li>
<li>字符流通过字节流来实现。</li>
</ul>
<h3 id="NIO"><a href="#NIO" class="headerlink" title="NIO"></a>NIO</h3><h4 id="问：如何理解同步异步？阻塞与非阻塞？"><a href="#问：如何理解同步异步？阻塞与非阻塞？" class="headerlink" title="问：如何理解同步异步？阻塞与非阻塞？"></a>问：如何理解同步异步？阻塞与非阻塞？</h4><p>理解这些概念要<strong>结合相应的语境</strong>，一般主要在<strong>进程通信</strong>或<strong>I/O系统调用</strong>方面讨论这些概念。</p>
<ul>
<li><p>什么是进程通信？</p>
<ul>
<li>进程间通信由send()和receive()两种动作完成，消息的传递可能是<strong>阻塞</strong>或<strong>非阻塞</strong>的，也可以叫做<strong>同步</strong>或<strong>异步</strong>的，<strong>此处二者指相同概念</strong>。指进程访问数据时，数据是否准备就绪。</li>
</ul>
</li>
<li><p>发送和接收可以根据阻塞分为？</p>
<ul>
<li>阻塞式发送（blocking send）：发送方进程会被一直阻塞， 直到消息被接受方进程收到。</li>
<li>非阻塞式发送（nonblocking send）： 发送方进程调用 send() 后， 立即就可以其他操作。</li>
<li>阻塞式接收（blocking receive）：接收方调用 receive() 后一直阻塞， 直到消息到达可用。</li>
<li>非阻塞式接受（nonblocking receive）： 接收方调用 receive() 函数后， 要么得到一个有效的结果，要么得到一个空值， 即不会被阻塞。</li>
</ul>
</li>
<li><p>什么是阻塞？</p>
<ul>
<li><strong>阻塞</strong>是指进程在发起一个<strong>系统调用</strong>（System Call）后，数据还未就绪，等待调用操作完成时，内核将进程挂起为<strong>等待</strong>（waiting）状态，以确保它此时不会被调度执行。</li>
<li><strong>I/O System Call</strong>：阻塞与系统调用紧密相关，现代计算机中物理通信操作通常是异步的，而操作系统则默认提供<strong>阻塞式的I/O系统调用</strong>接口（blocking systemcall），这样使应用代码编写更简单（代码执行顺序与编写顺序一致）。当然也会提供<strong>非阻塞式的I/O系统调用</strong>接口（nonblocking systemcall），不会挂起程序，而是立刻返回一个值。</li>
</ul>
</li>
<li><p>IO操作包括哪两个阶段？  </p>
<ul>
<li>1.查看数据是否就绪；</li>
<li>2.进行数据拷贝，内核将数据拷贝到用户线程。</li>
</ul>
</li>
<li><p>同步异步主要针对<strong>用户线程和内核交互</strong>。</p>
<ul>
<li><strong>阻塞式I/O系统调用</strong>：进程发起系统调用后挂起，直到调用操作完成。</li>
<li><strong>非阻塞式I/O系统调用</strong>：进程发起系统调用后立刻返回一个值，而不会挂起。</li>
<li><strong>同步I/O系统调用</strong>：用户线程发起I/O请求后，用户线程或内核不断轮询数据是否就绪，就绪后将数据从内核拷贝回用户线程。</li>
<li><strong>异步I/O系统调用</strong>：用户线程发起I/O请求，之后都由内核完成，完成后通知用户线程。与非阻塞式的I/O系统调用<strong>类似</strong>的是，二者不会等待I/O操作完成，应用程序可以继续执行其他操作，待I/O完成时操作系统通知调用进程。二者的<strong>区别</strong>是非阻塞会立即返回数据（无论数据是否完整），而异步则要求结果是完整的，允许延迟获取。</li>
</ul>
</li>
</ul>
<p>来源：<a target="_blank" rel="noopener" href="https://www.zhihu.com/question/19732473/answer/241673170">怎样理解阻塞非阻塞与同步异步的区别？萧萧</a></p>
<h4 id="问：同步I-O和异步I-O的区别？"><a href="#问：同步I-O和异步I-O的区别？" class="headerlink" title="问：同步I/O和异步I/O的区别？"></a>问：同步I/O和异步I/O的区别？</h4><ul>
<li>同步IO用户线程会阻塞，数据拷贝阶段由用户线程完成。</li>
<li>异步IO用户线程不会阻塞，数据拷贝阶段由内核完成，且会延迟等待完整结果。</li>
</ul>
<h4 id="问：谈谈5种IO模型？"><a href="#问：谈谈5种IO模型？" class="headerlink" title="问：谈谈5种IO模型？"></a>问：谈谈5种IO模型？</h4><p><img src="https://pic-1258215793.cos.ap-shanghai.myqcloud.com/content/20200501/202005010137.jpg"></p>
<ul>
<li>有哪5种IO模型？<ul>
<li>阻塞IO、非阻塞IO、IO多路复用、信号驱动IO、异步IO。</li>
</ul>
</li>
<li>这5种IO模型哪些是同步的，哪些是异步的？<ul>
<li>前四种都是同步IO，只有异步IO是真正的异步式IO，因为前四种都至少会在IO操作的第二个阶段使用户线程阻塞，且前四种只有第一阶段不同，第二阶段都是阻塞拷贝。</li>
<li>阻塞IO：即读写操作都需要等待；</li>
<li>非阻塞IO：则是当数据未就绪时返回一个错误信息，用户线程持续轮询；</li>
<li>IO多路复用：用一个线程就可以管理多个socket，同时检测多个资源，但线程会阻塞直到有资源可用，轮询也是通过内核而非用户线程执行；</li>
<li>信号驱动IO：在数据未就绪时不会阻塞，等接收到就绪信号时再通过信号函数调用IO读写操作；</li>
<li>异步IO：用户线程发起请求后立刻可以去做其它操作，内核收到信号后也立刻返回。后续由内核完成数据拷贝到用户线程，最终通知用户线程。两个阶段都由内核完成。</li>
</ul>
</li>
</ul>
<h4 id="问：什么是I-O多路复用？相比非阻塞I-O为何效率更高？"><a href="#问：什么是I-O多路复用？相比非阻塞I-O为何效率更高？" class="headerlink" title="问：什么是I/O多路复用？相比非阻塞I/O为何效率更高？"></a>问：什么是I/O多路复用？相比非阻塞I/O为何效率更高？</h4><ul>
<li>什么是IO多路复用？<ul>
<li>通过一个线程同时监控多个Socket，当某个Socket就绪时，线程执行IO操作，无需为每个Socket创建一个线程。</li>
</ul>
</li>
<li>相比非阻塞I/O为何效率更高？<ul>
<li>多个Socket只需一个线程管理，只有真正进行读写操作时才会使用IO资源。</li>
<li>非阻塞的轮询由用户线程来做，而多路复用<strong>由内核来轮询Socket状态</strong>，用户线程处于阻塞状态。</li>
</ul>
</li>
</ul>
<h4 id="问：知道NIO吗？对比IO简单谈一下区别？Java-BIO是什么？"><a href="#问：知道NIO吗？对比IO简单谈一下区别？Java-BIO是什么？" class="headerlink" title="问：知道NIO吗？对比IO简单谈一下区别？Java BIO是什么？"></a>问：知道NIO吗？对比IO简单谈一下区别？Java BIO是什么？</h4><ul>
<li><p>什么是BIO？</p>
<ul>
<li>BIO即Blocking IO，是一个同步并阻塞的IO模式，<strong>传统的  java.io 包</strong>，它基于流模型实现，提供了我们最熟知的一些 IO 功能，比如<strong>File抽象、输入输出流</strong>等。<strong>交互方式是同步、阻塞的方式</strong>，也就是说，在读取输入流或者写入输出流时，在读、写动作完成之前，线程会一直阻塞在那里，它们之间的调用是可靠的线性顺序。</li>
</ul>
</li>
<li><p>什么是NIO？</p>
<ul>
<li>NIO即New IO，NIO 是一种同步非阻塞的 I/O 模型，实际上是一种多路复用IO。在JDK 1.4时引入，对应 java.nio 包，提供了 Channel , Selector，Buffer 等抽象。</li>
<li>它支持面向缓冲的，基于通道的 I/O 操作方法。NIO 提供了与传统 BIO 模型中的 <code>Socket</code> 和 <code>ServerSocket</code> 相对应的 <code>SocketChannel</code> 和 <code>ServerSocketChannel</code> 两种不同的套接字通道实现,两种通道都支持阻塞和非阻塞两种模式。</li>
<li>IO主要包括类File，outputStream，inputStream，writer，reader，seralizable（5类1接口）</li>
<li>NIO则包含三大核心内容 <strong>selector</strong>（选择器，用于监听channel），<strong>channel</strong>（通道），<strong>buffer</strong>（缓冲区）。NIO选择器允许一个单独的线程监视多个输入通道。数据则无论读写都是放入缓冲区来处理。通道则用于在文件/Socket和缓冲区之间传输数据。传统Stream是单向的，而Channel则是双向。</li>
</ul>
</li>
<li><p>IO与NIO的区别有？二者有相同的作用但实现方式不同。NIO效率要比IO高很多。</p>
<ul>
<li><strong>IO是面向流设计，NIO则面向缓冲</strong>。因为IO面向流，所以意味着每次直接从流读取字节直到读取完毕。NIO因为面向缓冲，可以将缓冲区的数据任意移动位置。</li>
<li><strong>IO属于阻塞式IO，NIO则属于非阻塞式IO</strong>。IO的流是阻塞的，这意味着当一个线程读写数据时，此线程不能同时处理其他事情。而NIO会让线程从通道获取当前可用的数据，当数据还未能读取或写入前，线程可以去做其他事情。线程通常会将在非阻塞式IO上的空闲时间用于去其他通道执行IO操作，所以一个线程可以管理多个输入和输出通道。</li>
</ul>
</li>
</ul>
<table>
<thead>
<tr>
<th align="left">IO模型</th>
<th align="left">BIO</th>
<th align="left">NIO</th>
</tr>
</thead>
<tbody><tr>
<td align="left">通信</td>
<td align="left">面向流</td>
<td align="left">面向缓冲</td>
</tr>
<tr>
<td align="left">处理</td>
<td align="left">阻塞  IO</td>
<td align="left">非阻塞  IO</td>
</tr>
<tr>
<td align="left">触发</td>
<td align="left">无</td>
<td align="left">选择器</td>
</tr>
</tbody></table>
<p>NIO的特点：</p>
<ol>
<li>一个线程可以处理多个通道，减少线程创建数量；</li>
<li>读写非阻塞，节约资源：没有可读／可写数据时，不会发生阻塞导致线程资源的浪费</li>
</ol>
<h4 id="问：什么是-Reactor-模型？-Proactor与Reactor？"><a href="#问：什么是-Reactor-模型？-Proactor与Reactor？" class="headerlink" title="问：什么是 Reactor 模型？ Proactor与Reactor？"></a>问：什么是 Reactor 模型？ Proactor与Reactor？</h4><ul>
<li>什么是 Reactor 模型？<ul>
<li>IO复用需要<strong>事件分发器</strong>（event dispatcher），将读写事件分发给各个处理者Handler。事件分发有两种模式：<strong>Reactor</strong>和<strong>Proactor</strong>。</li>
<li><strong>Reactor模式</strong>：将IO操作分为事件检测和事件处理两阶段，通过一个或多个 Reactor 对象来检测 I/O 事件，并将这些事件分派给相应的事件处理器（Handler）进行处理。</li>
<li><strong>Proactor模式</strong>：Proactor直接发起一个异步 I/O 操作，实际工作由操作系统完成，I/O 操作完成后，通知 Proactor。Proactor 再调用相应的 Handler处理完成的IO事件。</li>
</ul>
</li>
<li>Proactor与Reactor？<ul>
<li>二者都是事件驱动的设计模式。</li>
<li>Reactor的IO操作由Handler完成，Proactor则由操作系统完成。</li>
<li>当回调Handler时，Proactor异步表示IO操作已完成，Reactor则表示可以进行IO操作。</li>
</ul>
</li>
</ul>
<h4 id="问：如何使用-FileChannel-进行文件读写？如何使用-MappedByteBuffer-实现内存映射文件？如何使用-NIO-的异步-I-O-操作？-如何使用-java-nio-file-包？如何使用-Files-类读取和写入文件？如何使用-Path-类处理文件路径？"><a href="#问：如何使用-FileChannel-进行文件读写？如何使用-MappedByteBuffer-实现内存映射文件？如何使用-NIO-的异步-I-O-操作？-如何使用-java-nio-file-包？如何使用-Files-类读取和写入文件？如何使用-Path-类处理文件路径？" class="headerlink" title="问：如何使用 FileChannel 进行文件读写？如何使用 MappedByteBuffer 实现内存映射文件？如何使用 NIO 的异步 I/O 操作？ 如何使用 java.nio.file 包？如何使用 Files 类读取和写入文件？如何使用 Path 类处理文件路径？"></a>问：如何使用 FileChannel 进行文件读写？如何使用 MappedByteBuffer 实现内存映射文件？如何使用 NIO 的异步 I/O 操作？ 如何使用 java.nio.file 包？如何使用 Files 类读取和写入文件？如何使用 Path 类处理文件路径？</h4><ol>
<li><p>使用 FileChannel 进行文件读写：允许我们更高效地进行文件的读写操作。相比传统的 <code>FileInputStream</code> 和 <code>FileOutputStream</code>，<code>FileChannel</code> 支持随机访问文件、部分读写以及映射文件到内存等高级操作。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">FileChannelReadExample</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        <span class="comment">// 使用 RandomAccessFile 打开文件通道</span></span><br><span class="line">        RandomAccessFile file = <span class="keyword">new</span> RandomAccessFile(<span class="string">&quot;example.txt&quot;</span>, <span class="string">&quot;r&quot;</span>);</span><br><span class="line">        FileChannel fileChannel = file.getChannel();</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 创建一个 ByteBuffer 来存储数据</span></span><br><span class="line">        ByteBuffer buffer = ByteBuffer.allocate(<span class="number">1024</span>);</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 读取数据到缓冲区</span></span><br><span class="line">        <span class="keyword">int</span> bytesRead = fileChannel.read(buffer);</span><br><span class="line">        <span class="keyword">while</span> (bytesRead != -<span class="number">1</span>) &#123;</span><br><span class="line">            buffer.flip(); <span class="comment">// 切换读模式</span></span><br><span class="line">            </span><br><span class="line">            <span class="keyword">while</span> (buffer.hasRemaining()) &#123;</span><br><span class="line">                System.out.print((<span class="keyword">char</span>) buffer.get());</span><br><span class="line">            &#125;</span><br><span class="line">            </span><br><span class="line">            buffer.clear(); <span class="comment">// 清空缓冲区，准备下一次读取</span></span><br><span class="line">            bytesRead = fileChannel.read(buffer);</span><br><span class="line">        &#125;</span><br><span class="line">        fileChannel.close();</span><br><span class="line">        file.close();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">FileChannelWriteExample</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        <span class="comment">// 打开一个文件，准备写入</span></span><br><span class="line">        RandomAccessFile file = <span class="keyword">new</span> RandomAccessFile(<span class="string">&quot;output.txt&quot;</span>, <span class="string">&quot;rw&quot;</span>);</span><br><span class="line">        FileChannel fileChannel = file.getChannel();</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 准备写入的数据</span></span><br><span class="line">        String data = <span class="string">&quot;Hello, FileChannel!&quot;</span>;</span><br><span class="line">        ByteBuffer buffer = ByteBuffer.allocate(<span class="number">1024</span>);</span><br><span class="line">        buffer.put(data.getBytes());</span><br><span class="line">        </span><br><span class="line">        buffer.flip(); <span class="comment">// 切换到读模式</span></span><br><span class="line">        fileChannel.write(buffer); <span class="comment">// 将缓冲区中的数据写入文件</span></span><br><span class="line">        </span><br><span class="line">        fileChannel.close();</span><br><span class="line">        file.close();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li><p>使用 MappedByteBuffer 实现内存映射文件：可以将文件映射到内存中，这样就可以像操作内存一样操作文件。它允许直接访问大文件中的特定部分而不必一次性加载整个文件，适合处理大文件。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MappedByteBufferExample</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        <span class="comment">// 打开文件通道</span></span><br><span class="line">        RandomAccessFile file = <span class="keyword">new</span> RandomAccessFile(<span class="string">&quot;example.txt&quot;</span>, <span class="string">&quot;rw&quot;</span>);</span><br><span class="line">        FileChannel fileChannel = file.getChannel();</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 将文件的一部分映射到内存中</span></span><br><span class="line">        MappedByteBuffer buffer = fileChannel.map(FileChannel.MapMode.READ_WRITE, <span class="number">0</span>, file.length());</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 读取文件内容</span></span><br><span class="line">        <span class="keyword">while</span> (buffer.hasRemaining()) &#123;</span><br><span class="line">            System.out.print((<span class="keyword">char</span>) buffer.get());</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 写入文件内容</span></span><br><span class="line">        buffer.put(<span class="number">0</span>, (<span class="keyword">byte</span>) <span class="string">&#x27;H&#x27;</span>); <span class="comment">// 修改文件的第一个字节</span></span><br><span class="line">        fileChannel.close();</span><br><span class="line">        file.close();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li><p>使用 NIO 的异步 I/O 操作：通过 <code>AsynchronousFileChannel</code> 可以实现非阻塞的文件操作</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">AsyncFileReadExample</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">        AsynchronousFileChannel asyncFileChannel = AsynchronousFileChannel.open(</span><br><span class="line">                Paths.get(<span class="string">&quot;example.txt&quot;</span>), StandardOpenOption.READ);</span><br><span class="line">        </span><br><span class="line">        ByteBuffer buffer = ByteBuffer.allocate(<span class="number">1024</span>);</span><br><span class="line">        Future&lt;Integer&gt; result = asyncFileChannel.read(buffer, <span class="number">0</span>);</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">while</span> (!result.isDone()) &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;Reading file asynchronously...&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        buffer.flip();</span><br><span class="line">        <span class="keyword">while</span> (buffer.hasRemaining()) &#123;</span><br><span class="line">            System.out.print((<span class="keyword">char</span>) buffer.get());</span><br><span class="line">        &#125;</span><br><span class="line">        asyncFileChannel.close();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li><p>如何使用 java.nio.file 包？如何使用 Files 类读取和写入文件？如何使用 Path 类处理文件路径？</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">FilesReadExample</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        List&lt;String&gt; lines = Files.readAllLines(Paths.get(<span class="string">&quot;example.txt&quot;</span>));</span><br><span class="line">        <span class="keyword">for</span> (String line : lines) &#123;</span><br><span class="line">            System.out.println(line);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">FilesWriteExample</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        Files.write(Paths.get(<span class="string">&quot;output.txt&quot;</span>), Arrays.asList(<span class="string">&quot;Hello, World!&quot;</span>, <span class="string">&quot;Java NIO is great!&quot;</span>));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">PathExample</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Path path = Paths.get(<span class="string">&quot;example.txt&quot;</span>);</span><br><span class="line">        </span><br><span class="line">        System.out.println(<span class="string">&quot;File Name: &quot;</span> + path.getFileName());</span><br><span class="line">        System.out.println(<span class="string">&quot;Parent Directory: &quot;</span> + path.getParent());</span><br><span class="line">        System.out.println(<span class="string">&quot;Absolute Path: &quot;</span> + path.toAbsolutePath());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ol>
<h2 id="七-反射与动态代理"><a href="#七-反射与动态代理" class="headerlink" title="七. 反射与动态代理"></a>七. 反射与动态代理</h2><h4 id="问：反射的原理，怎么确定类，怎么调方法？"><a href="#问：反射的原理，怎么确定类，怎么调方法？" class="headerlink" title="问：反射的原理，怎么确定类，怎么调方法？"></a>问：反射的原理，怎么确定类，怎么调方法？</h4><ul>
<li><p>Java 反射机制是一种<strong>运行时动态获取类信息和操作对象的能力</strong>，它允许在运行时确定类和方法，并且可以动态地调用方法和访问字段。对于类，反射可以获取类的完整信息，对于对象可以调用任意属性和方法。</p>
</li>
<li><p>当 JVM 加载一个类时，会在方法区为该类生成一个 <code>Class</code> 对象，这个对象封装了该类的所有信息（如类的名称、包的名称、方法、字段等）。获取类的字节码对象(Class)的三种方式：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 1. 使用类的全限定名</span></span><br><span class="line">Class&lt;?&gt; cls1 = Class.forName(<span class="string">&quot;com.example.MyClass&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 2. 通过对象的 `getClass()` 方法</span></span><br><span class="line">MyClass myObject = <span class="keyword">new</span> MyClass();</span><br><span class="line">Class&lt;?&gt; cls2 = myObject.getClass();</span><br><span class="line"></span><br><span class="line"><span class="comment">// 3. 直接通过类名的 .class 属性</span></span><br><span class="line">Class&lt;?&gt; cls3 = MyClass.class;</span><br></pre></td></tr></table></figure></li>
<li><p>通过 <code>Class</code> 对象获取类的构造方法，从而动态创建对象：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 获取所有的构造方法</span></span><br><span class="line">Constructor&lt;?&gt;[] constructors = cls1.getConstructors();</span><br><span class="line"></span><br><span class="line"><span class="comment">// 获取指定参数类型的构造方法</span></span><br><span class="line">Constructor&lt;?&gt; constructor = cls1.getConstructor(String.class, <span class="keyword">int</span>.class);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 使用构造方法创建对象</span></span><br><span class="line">Object obj = constructor.newInstance(<span class="string">&quot;Alice&quot;</span>, <span class="number">25</span>);</span><br></pre></td></tr></table></figure></li>
<li><p>通过 <code>getDeclaredFields()</code> 方法获取类的字段（包括私有字段），并可以对字段进行操作：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 获取所有字段，包括私有字段</span></span><br><span class="line">Field[] fields = cls1.getDeclaredFields();</span><br><span class="line"></span><br><span class="line"><span class="comment">// 获取指定的字段</span></span><br><span class="line">Field field = cls1.getDeclaredField(<span class="string">&quot;name&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 设置私有字段的可访问性</span></span><br><span class="line">field.setAccessible(<span class="keyword">true</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 获取字段的值</span></span><br><span class="line">Object value = field.get(obj);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 设置字段的值</span></span><br><span class="line">field.set(obj, <span class="string">&quot;Bob&quot;</span>);</span><br></pre></td></tr></table></figure></li>
<li><p>通过 <code>getDeclaredMethods()</code> 方法获得类的所有方法， <code>getDeclaredMethod(String)</code> 方法获取指定方法名的方法，并通过 <code>Method.invoke()</code> 调用此方法。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 获取所有方法</span></span><br><span class="line">Method[] methods = cls1.getMethods();  <span class="comment">// 获取包括父类和接口的公共方法</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 获取所有声明的方法（包括私有方法）</span></span><br><span class="line">Method[] declaredMethods = cls1.getDeclaredMethods();</span><br><span class="line"></span><br><span class="line"><span class="comment">// 获取指定的方法</span></span><br><span class="line">Method method = cls1.getMethod(<span class="string">&quot;sayHello&quot;</span>, String.class);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 调用方法</span></span><br><span class="line">Object result = method.invoke(obj, <span class="string">&quot;Hello&quot;</span>);</span><br></pre></td></tr></table></figure></li>
</ul>
<h4 id="问：如何通过反射和设置对象私有字段的值？"><a href="#问：如何通过反射和设置对象私有字段的值？" class="headerlink" title="问：如何通过反射和设置对象私有字段的值？"></a>问：如何通过反射和设置对象私有字段的值？</h4><ul>
<li>首先使用反射提供的setAccessible(true)，使我们可以访问到非public的变量。</li>
<li>然后使用反射提供的getDeclaredFields()方法获取某个类的所有声明字段或getDeclaredField()方法获取指定字段。</li>
</ul>
<h4 id="问：动态代理？"><a href="#问：动态代理？" class="headerlink" title="问：动态代理？"></a>问：动态代理？</h4><ul>
<li>什么是动态代理？<ul>
<li>Java 动态代理是一种设计模式，它允许在运行时动态生成代理类，用于代理目标对象的方法调用。</li>
</ul>
</li>
<li>与静态代理的区别？<ul>
<li>动态代理指代理类在运行时创建，而非编译阶段生成的代理模式。解决了静态代理存在的代码冗余等问题，动态生成代理对象，用完即销毁。</li>
<li><strong>静态代理</strong>：需要为每一个目标类编写一个代理类，编译时就确定了代理类，增加了代码量和维护成本。</li>
<li><strong>动态代理</strong>：不需要手动编写代理类，而是通过 Java 反射机制在运行时动态生成代理对象。</li>
</ul>
</li>
<li>动态代理基于 <code>java.lang.reflect.Proxy</code> 类和 <code>java.lang.reflect.InvocationHandler</code> 接口来实现。它通过实现接口的代理类来控制对目标对象方法的调用。<ul>
<li><strong><code>Proxy</code> 类</strong>：用于动态生成代理类的类。通过 <code>Proxy.newProxyInstance()</code> 方法，Java 可以在运行时创建一个代理对象，而不需要事先编写代理类。</li>
<li><strong><code>InvocationHandler</code> 接口</strong>：定义了代理类方法调用时的处理逻辑。</li>
</ul>
</li>
</ul>
<p>动态代理步骤：</p>
<ol>
<li>获取 <code>RealSubject</code>上的所有接口列表；</li>
<li>确定要生成的代理类的类名，默认为：<code>com.sun.proxy.$ProxyXXXX</code>；</li>
<li>根据需要实现的接口信息，在代码中动态创建该 <code>Proxy</code> 类的字节码；</li>
<li>将对应的字节码转换为对应的 <code>Class</code> 对象；</li>
<li>创建 <code>InvocationHandler</code> 实例 handler，用来处理 <code>Proxy</code> 所有方法调用；</li>
<li><code>Proxy</code> 的 <code>Class</code> 对象以创建的 handler 对象为参数，实例化一个 proxy 对象。</li>
</ol>
<p>代理类命名格式固定，一旦在运行中创建则和普通类无异。代理类都继承自Proxy类，通过实现接口的方式来实现代理。</p>
<p>使用示例：</p>
<ol>
<li><p>创建接口和目标对象</p>
<p>首先，定义一个接口及其实现类。假设有一个 <code>HelloService</code> 接口及其实现类：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">HelloService</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">sayHello</span><span class="params">(String name)</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">HelloServiceImpl</span> <span class="keyword">implements</span> <span class="title">HelloService</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">sayHello</span><span class="params">(String name)</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;Hello, &quot;</span> + name);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li><p>实现 <code>InvocationHandler</code> 接口</p>
<p><code>InvocationHandler</code> 接口定义了代理类的方法调用逻辑，它需要实现 <code>invoke()</code> 方法，代理类的所有方法调用都会被转发到 <code>invoke()</code> 方法中。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.lang.reflect.InvocationHandler;</span><br><span class="line"><span class="keyword">import</span> java.lang.reflect.Method;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">HelloServiceInvocationHandler</span> <span class="keyword">implements</span> <span class="title">InvocationHandler</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> Object target;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">HelloServiceInvocationHandler</span><span class="params">(Object target)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.target = target; <span class="comment">// 目标对象</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Object <span class="title">invoke</span><span class="params">(Object proxy, Method method, Object[] args)</span> <span class="keyword">throws</span> Throwable </span>&#123;</span><br><span class="line">        <span class="comment">// 在方法执行之前可以添加一些自定义逻辑</span></span><br><span class="line">        System.out.println(<span class="string">&quot;Before method: &quot;</span> + method.getName());</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 调用目标对象的方法</span></span><br><span class="line">        Object result = method.invoke(target, args);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 在方法执行之后可以添加一些自定义逻辑</span></span><br><span class="line">        System.out.println(<span class="string">&quot;After method: &quot;</span> + method.getName());</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li><p>生成代理对象并使用</p>
<p>通过 <code>Proxy.newProxyInstance()</code> 方法创建代理对象：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.lang.reflect.Proxy;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">DynamicProxyDemo</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 创建目标对象</span></span><br><span class="line">        HelloService helloService = <span class="keyword">new</span> HelloServiceImpl();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 创建 InvocationHandler 实例，将目标对象传入</span></span><br><span class="line">        HelloServiceInvocationHandler handler = <span class="keyword">new</span> HelloServiceInvocationHandler(helloService);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 通过 Proxy 动态生成代理对象</span></span><br><span class="line">        HelloService proxy = (HelloService) Proxy.newProxyInstance(</span><br><span class="line">                helloService.getClass().getClassLoader(),  <span class="comment">// 类加载器</span></span><br><span class="line">                helloService.getClass().getInterfaces(),   <span class="comment">// 目标对象实现的接口</span></span><br><span class="line">                handler);                                  <span class="comment">// InvocationHandler 实例</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// 通过代理对象调用方法</span></span><br><span class="line">        proxy.sayHello(<span class="string">&quot;World&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li><p>输出结果：</p>
<figure class="highlight oxygene"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">plaintextCopy codeBefore <span class="function"><span class="keyword">method</span>:</span> sayHello</span><br><span class="line">Hello, World</span><br><span class="line">After <span class="function"><span class="keyword">method</span>:</span> sayHello</span><br></pre></td></tr></table></figure></li>
</ol>
<p>动态代理常用于以下场景：</p>
<ul>
<li><strong>AOP（面向切面编程）</strong>：可以在方法执行前后添加横切逻辑，如日志、权限验证、事务管理等。</li>
<li><strong>远程调用代理</strong>：在分布式系统中，动态代理常用于创建远程服务的代理对象，简化远程调用的复杂性。</li>
<li><strong>权限验证</strong>：在方法执行之前动态检查用户权限。</li>
<li><strong>事务管理</strong>：动态代理可以在方法执行之前和之后进行事务的开启、提交或回滚。</li>
</ul>
<h4 id="问：为什么JDK动态代理只能代理接口？"><a href="#问：为什么JDK动态代理只能代理接口？" class="headerlink" title="问：为什么JDK动态代理只能代理接口？"></a>问：为什么JDK动态代理只能代理接口？</h4><ul>
<li>因为JDK动态代理创建代理对象需要继承标准类库中的 <code>Proxy</code> 类， <code>Proxy</code> 类是通过接口来创建代理对象的，它需要代理类实现某些接口。</li>
<li>且Java遵守<strong>单继承多实现</strong>，所以JDK只能通过实现来代理接口。</li>
</ul>
<p>通过<strong>CGLIB 代理</strong>可以代理没有实现接口的类。</p>
<h4 id="问：有人说jdk动态代理性能比cglib要差，如果是，依据是什么？JDK-动态代理与-CGLIB-代理的区别又是什么？"><a href="#问：有人说jdk动态代理性能比cglib要差，如果是，依据是什么？JDK-动态代理与-CGLIB-代理的区别又是什么？" class="headerlink" title="问：有人说jdk动态代理性能比cglib要差，如果是，依据是什么？JDK 动态代理与 CGLIB 代理的区别又是什么？"></a>问：有人说jdk动态代理性能比cglib要差，如果是，依据是什么？JDK 动态代理与 CGLIB 代理的区别又是什么？</h4><p>二者的区别：</p>
<ul>
<li><strong>JDK 动态代理</strong>：只能代理实现了接口的类，基于接口生成代理类。<ul>
<li>基于反射机制，JDK 动态代理会在运行时生成代理类，并且代理类实现目标对象的接口。代理类的每个方法调用都会通过 <code>InvocationHandler</code> 的 <code>invoke</code> 方法来转发。</li>
<li>基于 Java 的反射机制，代理对象实际上是实现了接口的一个代理类，调用方法时通过反射来执行。</li>
</ul>
</li>
<li><strong>CGLIB 代理</strong>：可以代理没有实现接口的类，基于继承目标类生成代理类，通过字节码操作生成代理类。<ul>
<li>CGLIB 使用底层字节码生成技术（ASM）在运行时生成目标类的子类，并通过方法覆盖的方式实现方法拦截。</li>
<li>通过继承目标类，代理类会覆盖目标类的非 <code>final</code> 方法，并在代理时通过字节码生成技术（如 ASM）来动态生成新的代理类。</li>
</ul>
</li>
</ul>
<p><strong>JDK 动态代理的局限性</strong>：</p>
<ul>
<li>只能代理实现了接口的类，不能代理没有接口的普通类。</li>
<li>代理类在每次调用方法时，都会通过反射来执行目标对象的方法，性能稍低。</li>
</ul>
<p><strong>CGLIB 动态代理的优势</strong>：</p>
<ul>
<li>CGLIB 通过继承目标类生成代理类，因此即使没有接口也能实现代理。</li>
<li>CGLIB 直接生成目标类的子类，调用方法时无需反射，性能更高。</li>
</ul>
<ol>
<li>说jdk动态代理性能比cglib要差，依据应该是JDK动态代理依赖于反射机制，带来了性能开销，而CGLIB则通过ASM操作字节码直接生成类，且调用方法时性能接近于直接调用，而JDK则需要反射机制进行中转。</li>
<li>但在JDK 1.8之前的版本或许JDK动态代理生成的代理类运行效率要弱于CGLib，但之后的版本JDK明显优化过后应该区别不大。</li>
<li>1.8版本的改进：引入方法句柄（MethodHandles）替代传统反射机制；支持动态语言的调用 <code>invokedynamic</code> 指令优化了方法调用的性能。</li>
</ol>
<h4 id="问：Spring中AOP的实现采用那种代理方式？"><a href="#问：Spring中AOP的实现采用那种代理方式？" class="headerlink" title="问：Spring中AOP的实现采用那种代理方式？"></a>问：Spring中AOP的实现采用那种代理方式？</h4><ul>
<li>Spring虽然采用了AspectJ的标准注解，但未采用其静态代理的模式（特定的编译器和语法在编译阶段实现代理），而是动态代理。</li>
<li>其支持的动态代理实现方式有两种：JDK动态代理和CGLib，Spring会<strong>默认使用JDK动态代理</strong>，<strong>当目标对象非接口时会强制转换为CGLib</strong>。Spring Boot则<strong>在2.x版本后默认使用CGlib</strong>（理由是相比JDK动态代理更少出现转换问题）。可以通过在 Spring 的配置中设置 <code>proxyTargetClass=true</code> 来实现强制使用 CGLIB 代理。</li>
</ul>
<h4 id="问：Java中的事件机制？"><a href="#问：Java中的事件机制？" class="headerlink" title="问：Java中的事件机制？"></a>问：Java中的事件机制？</h4><ol>
<li><p>Java 中的事件机制是一种基于<strong>观察者模式</strong>（Observer Pattern）的模型，允许对象之间通过事件进行解耦和通信。</p>
</li>
<li><p>核心概念：</p>
<ul>
<li><strong>事件对象（Event Object）</strong>：一般继承自 <code>java.util.EventObject</code> 类，封装了<strong>事件源</strong>对象及跟事件相关的信息。 </li>
<li><strong>事件源（Event Source）</strong>：事件发生的地方，由于事件源的某项属性或状态发生了改变（比如 BUTTON 被单击、TEXTBOX 的值发生改变等等）导致某项事件发生。换句话说就是生成了相应的事件对象。因为事件监听器要注册在事件源上,所以事件源类中应该要有盛装监听器的容器（List,Set 等等）。</li>
<li><strong>事件监听器（Event Listener）</strong>：实现 <code>java.util.EventListener</code> 接口，注册在事件源上，当事件源的属性或状态改变时，取得相应的监听器调用其内部的<strong>回调方法</strong>。 Java 的事件监听器通常是接口，如 <code>ActionListener</code>、<code>MouseListener</code>、<code>KeyListener</code> 等。</li>
<li><strong>事件处理（Event Handling）</strong>：当事件发生时，事件源会调用所有注册的事件监听器的处理方法，触发相应的处理逻辑。</li>
</ul>
</li>
<li><p>流程：</p>
<ol>
<li><p><strong>定义事件监听器接口</strong>：Java 提供了多个事件监听器接口，例如：</p>
<ul>
<li><code>ActionListener</code>：处理按钮、菜单等的点击事件。</li>
<li><code>MouseListener</code>：处理鼠标事件，如点击、进入、离开等。</li>
<li><code>KeyListener</code>：处理键盘事件。</li>
</ul>
</li>
<li><p><strong>注册事件监听器</strong>：通过事件源的 <code>addXXXListener</code> 方法来注册事件监听器。例如：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">JButton button = <span class="keyword">new</span> JButton(<span class="string">&quot;Click Me&quot;</span>);</span><br><span class="line">button.addActionListener(<span class="keyword">new</span> ActionListener() &#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">actionPerformed</span><span class="params">(ActionEvent e)</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;Button clicked!&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure></li>
<li><p><strong>事件触发</strong>：当用户点击按钮时，事件源触发 <code>ActionEvent</code>，然后调用注册的 <code>ActionListener</code> 的 <code>actionPerformed</code> 方法。</p>
</li>
</ol>
</li>
</ol>
<h2 id="八-设计模式"><a href="#八-设计模式" class="headerlink" title="八. 设计模式"></a>八. 设计模式</h2><h4 id="问：项目中有使用过哪些设计模式？"><a href="#问：项目中有使用过哪些设计模式？" class="headerlink" title="问：项目中有使用过哪些设计模式？"></a>问：项目中有使用过哪些设计模式？</h4><ul>
<li>单例模式（Singleton Pattern）确保一个类只有一个实例，并提供一个全局访问点。例如在整个系统中共享资源，如数据库连接池、配置管理类等。</li>
<li>工厂模式（Factory Pattern）创建对象时不直接实例化对象，而是通过工厂方法创建，便于管理和扩展。常用于解耦对象创建与使用。比如根据不同的订单类型创建不同的订单处理类。</li>
<li>观察者模式（Observer Pattern）当一个对象的状态改变时，所有依赖它的对象都能得到通知并自动更新。主要用于事件驱动的系统。比如消息推送系统</li>
<li>适配器模式（Adapter Pattern）将一个类的接口转换为用户所期望的另一个接口。它的目的是通过适配器类将两个不兼容的接口结合在一起，从而使得原本因接口不兼容而无法一起工作的类能够协同工作。比如我们系统支持某个旧的视频播放器，需要支持新的格式，为了不修改原有代码，可以使用该模式。</li>
<li>代理模式（Proxy Pattern）为其他对象提供代理以控制对这个对象的访问。常用于远程代理、虚拟代理、保护代理等。比如事务管理、日志记录。</li>
<li>模板方法模式（Template Method Pattern）定义算法的骨架，而将某些步骤延迟到子类中实现。模板方法允许子类在不改变算法结构的情况下，重新定义算法的某些步骤。在电商项目中，订单处理的流程大致相同，但具体的支付方式或物流方式有所不同，使用模板方法可以统一流程，同时允许不同子类扩展具体实现。</li>
<li>策略模式（Strategy Pattern）定义一系列算法，将每个算法封装起来，使它们可以相互替换。这种模式让算法独立于使用它的客户端。比如支付系统中定义不同的支付方式。</li>
<li>责任链模式（Chain of Responsibility Pattern）将多个处理器串联起来，形成一个处理链，处理链中的每个处理器负责处理不同的任务。常用于日志处理、权限校验等场景。在权限系统中，不同的角色有不同的权限，通过责任链模式可以将不同的权限处理逻辑组合在一起，按顺序进行处理。</li>
<li>装饰者模式（Decorator Pattern）动态地为对象增加新的功能，而不影响其结构。适合在不修改现有类的情况下扩展功能。</li>
</ul>
<h4 id="问：-JDK-中几个常见的设计模式？"><a href="#问：-JDK-中几个常见的设计模式？" class="headerlink" title="问： JDK 中几个常见的设计模式？"></a>问： JDK 中几个常见的设计模式？</h4><ul>
<li>单例模式：用于 Runtime，Calendar 和其他的一些类中<ul>
<li>如通过 <code>Runtime.getRuntime()</code> 获取单例实例。</li>
</ul>
</li>
<li>工厂模式：被用于各种不可变的类如 Boolean，像 Boolean.valueOf。<ul>
<li><code>java.util.Calendar.getInstance()</code> 使用了工厂模式创建 <code>Calendar</code> 对象。</li>
<li><code>java.sql.DriverManager.getConnection()</code> 也是工厂模式的应用，用于获取数据库连接。</li>
</ul>
</li>
<li>策略模式：<ul>
<li><code>java.util.Comparator</code> 就是典型的策略模式，用户可以定义不同的排序策略传递给 <code>Collections.sort()</code> 方法。</li>
<li><code>javax.crypto.Cipher</code> 使用不同的加密策略。</li>
</ul>
</li>
<li>观察者模式：被用于 Swing 和很多的事件监听中。<ul>
<li><code>java.util.Observer</code> 和 <code>java.util.Observable</code> 使用观察者模式实现数据更新。</li>
<li>GUI 组件的事件监听器也是观察者模式的实现，例如 <code>ActionListener</code>。</li>
</ul>
</li>
<li>装饰器模式： 被用于 Java IO 中的各种字节和字符流，InputStream和XXInputStream，如BufferedReader和BufferedWriter，增强了 Reader和Writer，通过Buffer读写提高性能。 <ul>
<li><code>java.io.BufferedReader</code> 和 <code>java.io.FileReader</code> 是装饰器模式的经典应用，<code>BufferedReader</code> 给 <code>Reader</code> 对象增加了缓冲功能。</li>
<li><code>java.util.Collections.synchronizedList()</code> 为 <code>List</code> 对象添加线程安全的职责。</li>
</ul>
</li>
<li>迭代器模式：java.util.Iterator</li>
<li>代理模式：java.lang.reflect.Proxy</li>
</ul>
<h4 id="问：-Spring-中用了哪些设计模式？"><a href="#问：-Spring-中用了哪些设计模式？" class="headerlink" title="问： Spring 中用了哪些设计模式？"></a>问： Spring 中用了哪些设计模式？</h4><ul>
<li>单例模式：Spring 的默认 Bean 作用域是 <strong>Singleton</strong>，即每个 Spring 容器中一个 Bean 只有一个实例。这意味着通过 <code>@Bean</code> 或 XML 配置定义的 Bean 在容器中都是单例的。</li>
<li>简单工厂模式：如BeanFactory等。</li>
<li>工厂模式：AbstractFactoryBean。</li>
<li>代理模式：<ul>
<li>Spring AOP（面向切面编程）使用了代理模式。使用 <code>@Transactional</code> 或其他 AOP 注解时，Spring 会通过代理模式为目标方法添加事务管理。</li>
</ul>
</li>
<li>适配器模式：<ul>
<li>Spring 的 <strong><code>HandlerAdapter</code></strong> 就是典型的适配器模式，它使得不同类型的控制器（如 <code>@Controller</code> 和 <code>SimpleController</code>）可以被 <code>DispatcherServlet</code> 处理。</li>
</ul>
</li>
<li>装饰器模式：<ul>
<li>**<code>HttpServletRequestWrapper</code> 和 <code>HttpServletResponseWrapper</code>**：这两个类是 Java Servlet API 的一部分，而 Spring 中也经常用到。它们允许在不改变原始请求或响应对象的情况下，扩展请求和响应的功能。</li>
</ul>
</li>
<li>观察者模式：<ul>
<li>Spring 的事件驱动模型基于观察者模式。通过 <strong><code>ApplicationEvent</code></strong> 和 **<code>ApplicationListener</code>**，Spring 提供了事件发布和监听机制。<code>ApplicationContext</code> 会作为事件源，触发事件，监听者会收到通知并处理。</li>
</ul>
</li>
<li>策略模式：<ul>
<li>**<code>Spring</code> 的 <code>ConversionService</code>**：Spring 的类型转换服务是策略模式的典型应用。<code>ConversionService</code> 定义了通用的接口，可以使用不同的策略来执行类型转换。Spring 提供了不同的 <code>Converter</code> 实现，用于在不同类型之间进行转换，而开发者也可以自己定义新的 <code>Converter</code>。</li>
<li><strong>Spring 的事务管理</strong>：Spring 的事务管理使用策略模式定义了不同的事务传播行为（如 <code>REQUIRED</code>、<code>REQUIRES_NEW</code>、<code>SUPPORTS</code> 等），通过 <code>@Transactional</code> 注解或编程方式，用户可以选择合适的事务策略。</li>
<li><strong><code>BeanFactory</code> 的后置处理器</strong>：当 Spring 容器初始化时，<code>BeanFactoryPostProcessor</code> 和 <code>BeanPostProcessor</code> 可以定义不同的处理策略，来在 Bean 创建的不同生命周期中定制处理逻辑。</li>
</ul>
</li>
<li>模板方法模式：<ul>
<li>Spring 提供了一些模板类，如 **<code>JdbcTemplate</code><strong>、</strong><code>RestTemplate</code>**，这些类封装了常见操作的流程，开发者只需定义具体的回调操作</li>
</ul>
</li>
<li> 责任链模式 (Chain of Responsibility Pattern)：</li>
<li>Spring 的拦截器机制（HandlerInterceptor）使用了责任链模式。当请求到达时，多个拦截器可以按顺序处理请求，直到最终目标处理器。</li>
<li>依赖注入模式 (Dependency Injection Pattern)：Spring 的核心理念就是 **依赖注入 (DI)**，通过 <code>@Autowired</code>、<code>@Inject</code> 等注解，Spring 自动注入依赖的 Bean。</li>
</ul>
<h4 id="问：单例模式是什么？单例模式的优点？使用场景？有哪几种？有什么区别？手写出线程安全的单例模式？"><a href="#问：单例模式是什么？单例模式的优点？使用场景？有哪几种？有什么区别？手写出线程安全的单例模式？" class="headerlink" title="问：单例模式是什么？单例模式的优点？使用场景？有哪几种？有什么区别？手写出线程安全的单例模式？"></a>问：单例模式是什么？单例模式的优点？使用场景？有哪几种？有什么区别？手写出线程安全的单例模式？</h4><ul>
<li><p>什么是单例模式？</p>
<ul>
<li>通过该模式创建的<strong>类只能有一个实例，且该实例可以被全局访问</strong>。</li>
<li>构造器必须是私有的，外部类无法通过调用构造器方法创建该实例。</li>
<li>没有公开的set方法，外部类无法调用set方法创建该实例。</li>
<li>提供一个公开的get方法获取唯一的这个实例。</li>
</ul>
</li>
<li><p>单例模式的优点？</p>
<ul>
<li>避免了对象的重复创建，减轻GC压力。</li>
<li>保证系统中某个类的实例对象是唯一的，可以通过全局的访问点访问该实例。</li>
</ul>
</li>
<li><p>使用场景？</p>
<ul>
<li><strong>日志记录类</strong>：日志记录系统通常要求全局唯一的访问点，使用单例模式可以避免多个日志类实例。</li>
<li><strong>数据库连接池</strong>：避免频繁创建和销毁数据库连接，保证资源的有效使用。</li>
<li><strong>线程池管理</strong>：通过单例模式管理线程池，避免创建多余的线程池实例。</li>
<li><strong>配置文件读取类</strong>：确保应用程序读取配置文件的类全局唯一。</li>
</ul>
</li>
<li><p>JDK中的使用案例：用于 Runtime，Calendar 和其他的一些类中</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Runtime</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 饿汉式</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> Runtime currentRuntime = <span class="keyword">new</span> Runtime();</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Runtime <span class="title">getRuntime</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> currentRuntime;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 工厂模式</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">Calendar</span> <span class="keyword">implements</span> <span class="title">Serializable</span>, <span class="title">Cloneable</span>, <span class="title">Comparable</span>&lt;<span class="title">Calendar</span>&gt; </span>&#123;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Calendar <span class="title">getInstance</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> createCalendar(TimeZone.getDefault(), Locale.getDefault(Locale.Category.FORMAT));</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 懒汉式线程不安全</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> Calendar <span class="title">createCalendar</span><span class="params">(TimeZone zone,</span></span></span><br><span class="line"><span class="params"><span class="function">                                           Locale aLocale)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        CalendarProvider provider =</span><br><span class="line">            LocaleProviderAdapter.getAdapter(CalendarProvider.class, aLocale)</span><br><span class="line">                                 .getCalendarProvider();</span><br><span class="line">        <span class="comment">// 省略</span></span><br><span class="line">        Calendar cal = <span class="keyword">null</span>;</span><br><span class="line">            </span><br><span class="line">        <span class="comment">// 省略</span></span><br><span class="line">        <span class="keyword">return</span> cal;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li><p>Spring中的使用案例：Spring 的默认 Bean 作用域是 <strong>Singleton</strong>，即每个 Spring 容器中一个 Bean 只有一个实例。这意味着通过 <code>@Bean</code> 或 XML 配置定义的 Bean 在容器中都是单例的。</p>
<ul>
<li>Spring使用单例注册表来实现单例模式，单例注册表（Singleton Registry）是通过<code>DefaultSingletonBeanRegistry</code>这个类来实现的。其是负责管理单例bean的默认实现。它维护了一个单例缓存（通过ConcurrentHashMap实现的singletonObjects）来保存已经创建的单例bean实例，以及一个早期单例缓存（earlySingletonObjects）来保存在bean的实例化过程中早期暴露的bean实例。</li>
</ul>
</li>
<li><p>分为哪几种？</p>
<ul>
<li><p>饿汉式：提前创建对象，首次获取即有对象。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Singleton</span> </span>&#123;</span><br><span class="line">  <span class="comment">// 创建一个实例对象</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> Singleton instance = <span class="keyword">new</span> Singleton();</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 私有构造方法，防止被实例化</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="title">Singleton</span><span class="params">()</span></span>&#123;&#125;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 静态get方法</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Singleton <span class="title">getInstance</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> instance;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li><p>懒汉式：首次调用时，对象是空的，然后再去初始化赋值。需要考虑线程安全问题。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Singleton</span> </span>&#123;  </span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> Singleton instance;  </span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="title">Singleton</span> <span class="params">()</span></span>&#123;&#125;  </span><br><span class="line">  </span><br><span class="line">    <span class="comment">// 线程不安全</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Singleton <span class="title">getInstance</span><span class="params">()</span> </span>&#123;  </span><br><span class="line">    	<span class="keyword">if</span> (instance == <span class="keyword">null</span>) &#123;  </span><br><span class="line">        	instance = <span class="keyword">new</span> Singleton();  </span><br><span class="line">    	&#125;  </span><br><span class="line">    	<span class="keyword">return</span> instance;  </span><br><span class="line">    &#125;  </span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 通过volatile修饰的变量，不会被线程本地缓存，所有线程对该对象的读写都会第一时间同步到主内存，从而保证多个线程间该对象的准确性</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">volatile</span> <span class="keyword">static</span> Singleton instance = <span class="keyword">null</span>;</span><br><span class="line">    <span class="comment">// 通过双检锁保证线程安全，只有在instance为null，并创建对象的时候才需要加锁，对性能有一定的提升。</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Singleton <span class="title">getInstance</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="comment">// 先检查实例是否存在，如果不存在才进入下面的同步块</span></span><br><span class="line">        <span class="keyword">if</span>(instance == <span class="keyword">null</span>)&#123;</span><br><span class="line">            <span class="comment">// 同步块，线程安全的创建实例</span></span><br><span class="line">            <span class="keyword">synchronized</span> (Singleton.class) &#123;</span><br><span class="line">                <span class="comment">// 再次检查实例是否存在，如果不存在才真正的创建实例</span></span><br><span class="line">                <span class="keyword">if</span>(instance == <span class="keyword">null</span>)&#123;</span><br><span class="line">                    <span class="comment">// 在Java指令中创建对象和赋值操作是分开进行的，也就是说instance = new Singleton();语句是分两步执行的。但是JVM并不保证这两个操作的先后顺序，可能导致A线程先赋值给instance，但未完成对象初始化，释放锁后B线程直接调用instance出错。</span></span><br><span class="line">                    instance = <span class="keyword">new</span> Singleton();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> instance;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 由于volatile关键字可能会屏蔽掉虚拟机中一些必要的代码优化，所以运行效率并不是很高，还有更优的写法吗？</span></span><br><span class="line"><span class="comment">// 使用静态内部类，JVM内部的机制能够保证当一个类被加载的时候，这个类的加载过程是线程互斥的。</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Singleton</span> </span>&#123;  </span><br><span class="line">  </span><br><span class="line">    <span class="comment">/* 私有构造方法，防止被实例化 */</span>  </span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="title">Singleton</span><span class="params">()</span> </span>&#123;  </span><br><span class="line">    &#125;  </span><br><span class="line">  </span><br><span class="line">    <span class="comment">/* 此处使用一个内部类来维护单例 */</span>  </span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">SingletonFactory</span> </span>&#123;  </span><br><span class="line">        <span class="comment">// 当我们第一次调用getInstance的时候，JVM能够帮我们保证instance只被创建一次，并且会保证把赋值给instance的内存初始化完毕</span></span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">static</span> Singleton instance = <span class="keyword">new</span> Singleton();  </span><br><span class="line">    &#125;  </span><br><span class="line">  </span><br><span class="line">    <span class="comment">/* 获取实例 */</span>  </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Singleton <span class="title">getInstance</span><span class="params">()</span> </span>&#123;  </span><br><span class="line">        <span class="keyword">return</span> SingletonFactory.instance;  </span><br><span class="line">    &#125;  </span><br><span class="line">  </span><br><span class="line">    <span class="comment">/* 如果该对象被用于序列化，可以保证对象在序列化前后保持一致 */</span>  </span><br><span class="line">    <span class="function"><span class="keyword">public</span> Object <span class="title">readResolve</span><span class="params">()</span> </span>&#123;  </span><br><span class="line">        <span class="keyword">return</span> getInstance();  </span><br><span class="line">    &#125;  </span><br><span class="line">&#125;  </span><br><span class="line"></span><br><span class="line"><span class="comment">// 使用枚举是最简单高效实现单例模式的方案</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">enum</span> <span class="title">Singleton</span> </span>&#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 定义一个枚举的元素，它就代表了Singleton的一个实例。</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    Instance;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
</li>
<li><p>为什么不采用静态方法而是单例模式？</p>
<ul>
<li>静态方法或单例模式都能实现加载的最终目的，区别在于是否需要维护一份对象。</li>
</ul>
</li>
</ul>
<h4 id="问：工厂模式是什么？"><a href="#问：工厂模式是什么？" class="headerlink" title="问：工厂模式是什么？"></a>问：工厂模式是什么？</h4><ul>
<li><p>工厂模式是什么？</p>
<ul>
<li>一种设计模式，提供了一种将对象创建的过程与其具体实现分离的方法，使得代码具有更好的扩展性和可维护性。</li>
</ul>
</li>
<li><p>分为哪几类？</p>
<ul>
<li><p><strong>简单工厂模式</strong>（Simple Factory Pattern）：通过一个工厂类，根据传入的参数决定创建哪种具体类的实例。</p>
<ul>
<li>优点：简单易用，集中管理对象创建逻辑。</li>
<li>缺点：<strong>违反开闭原则</strong>，增加新的产品时需要修改工厂类代码。</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 产品接口</span></span><br><span class="line"><span class="class"><span class="keyword">interface</span> <span class="title">Product</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">use</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 具体产品A</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ProductA</span> <span class="keyword">implements</span> <span class="title">Product</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">use</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;Using Product A&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 具体产品B</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ProductB</span> <span class="keyword">implements</span> <span class="title">Product</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">use</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;Using Product B&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 工厂类</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">SimpleFactory</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 静态工厂模式，每次增加type要修改ifelse</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Product <span class="title">createProduct</span><span class="params">(String type)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (type.equals(<span class="string">&quot;A&quot;</span>)) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">new</span> ProductA();</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (type.equals(<span class="string">&quot;B&quot;</span>)) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">new</span> ProductB();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(<span class="string">&quot;Unknown product type&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 使用</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Main</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Product productA = SimpleFactory.createProduct(<span class="string">&quot;A&quot;</span>);</span><br><span class="line">        productA.use(); <span class="comment">// Output: Using Product A</span></span><br><span class="line">        </span><br><span class="line">        Product productB = SimpleFactory.createProduct(<span class="string">&quot;B&quot;</span>);</span><br><span class="line">        productB.use(); <span class="comment">// Output: Using Product B</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li><p>工厂方法模式（Factory Method Pattern）：工厂方法模式将对象的创建延迟到子类中，<strong>工厂类则会抽象化，通过子类来决定创建哪种具体类的实例</strong>。</p>
<ul>
<li>优点：遵循开闭原则，添加新产品时无需修改现有代码。</li>
<li>缺点：增加了系统的复杂性，需要为每个产品提供一个具体工厂类。</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 产品接口</span></span><br><span class="line"><span class="class"><span class="keyword">interface</span> <span class="title">Product</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">use</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 具体产品A</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ProductA</span> <span class="keyword">implements</span> <span class="title">Product</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">use</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;Using Product A&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 具体产品B</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ProductB</span> <span class="keyword">implements</span> <span class="title">Product</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">use</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;Using Product B&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 抽象工厂接口</span></span><br><span class="line"><span class="class"><span class="keyword">interface</span> <span class="title">Factory</span> </span>&#123;</span><br><span class="line">    <span class="function">Product <span class="title">createProduct</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 具体工厂A</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">FactoryA</span> <span class="keyword">implements</span> <span class="title">Factory</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> Product <span class="title">createProduct</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> ProductA();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 具体工厂B</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">FactoryB</span> <span class="keyword">implements</span> <span class="title">Factory</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> Product <span class="title">createProduct</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> ProductB();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 使用</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Main</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Factory factoryA = <span class="keyword">new</span> FactoryA();</span><br><span class="line">        Product productA = factoryA.createProduct();</span><br><span class="line">        productA.use(); <span class="comment">// Output: Using Product A</span></span><br><span class="line">        </span><br><span class="line">        Factory factoryB = <span class="keyword">new</span> FactoryB();</span><br><span class="line">        Product productB = factoryB.createProduct();</span><br><span class="line">        productB.use(); <span class="comment">// Output: Using Product B</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li><p>抽象工程模式（Abstract Factory Pattern）：抽象工厂模式提供一个接口，用于创建一系列相关或依赖的对象，而无需指定它们的具体类。工厂方法类中只有一个抽象方法，要想实现多种不同的类对象，只能去创建不同的具体工厂方法的子类来实列化，而抽象工厂 则是让一个工厂负责创建多个不同类型的对象。</p>
<ul>
<li><strong>优点</strong>：分离了具体类的创建，使得代码更加灵活和易于扩展。</li>
<li><strong>缺点</strong>：增加了系统的抽象性和复杂性。</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 产品A接口</span></span><br><span class="line"><span class="class"><span class="keyword">interface</span> <span class="title">ProductA</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">use</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 产品B接口</span></span><br><span class="line"><span class="class"><span class="keyword">interface</span> <span class="title">ProductB</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">consume</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 具体产品A1</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ProductA1</span> <span class="keyword">implements</span> <span class="title">ProductA</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">use</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;Using Product A1&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 具体产品A2</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ProductA2</span> <span class="keyword">implements</span> <span class="title">ProductA</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">use</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;Using Product A2&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 具体产品B1</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ProductB1</span> <span class="keyword">implements</span> <span class="title">ProductB</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">consume</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;Consuming Product B1&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 具体产品B2</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ProductB2</span> <span class="keyword">implements</span> <span class="title">ProductB</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">consume</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;Consuming Product B2&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 抽象工厂接口</span></span><br><span class="line"><span class="class"><span class="keyword">interface</span> <span class="title">AbstractFactory</span> </span>&#123;</span><br><span class="line">    <span class="function">ProductA <span class="title">createProductA</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="function">ProductB <span class="title">createProductB</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 具体工厂1</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Factory1</span> <span class="keyword">implements</span> <span class="title">AbstractFactory</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> ProductA <span class="title">createProductA</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> ProductA1();</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> ProductB <span class="title">createProductB</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> ProductB1();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 具体工厂2</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Factory2</span> <span class="keyword">implements</span> <span class="title">AbstractFactory</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> ProductA <span class="title">createProductA</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> ProductA2();</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> ProductB <span class="title">createProductB</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> ProductB2();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 使用</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Main</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        AbstractFactory factory1 = <span class="keyword">new</span> Factory1();</span><br><span class="line">        ProductA productA1 = factory1.createProductA();</span><br><span class="line">        ProductB productB1 = factory1.createProductB();</span><br><span class="line">        productA1.use(); <span class="comment">// Output: Using Product A1</span></span><br><span class="line">        productB1.consume(); <span class="comment">// Output: Consuming Product B1</span></span><br><span class="line">        </span><br><span class="line">        AbstractFactory factory2 = <span class="keyword">new</span> Factory2();</span><br><span class="line">        ProductA productA2 = factory2.createProductA();</span><br><span class="line">        ProductB productB2 = factory2.createProductB();</span><br><span class="line">        productA2.use(); <span class="comment">// Output: Using Product A2</span></span><br><span class="line">        productB2.consume(); <span class="comment">// Output: Consuming Product B2</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
</li>
<li><p>适用场景分别为？</p>
<ul>
<li><strong>简单工厂模式</strong>适用于创建逻辑简单、产品种类较少的场景。</li>
<li><strong>工厂方法模式</strong>适用于产品种类繁多，且需要增加新产品时不修改现有代码的场景。当对象的创建逻辑比较复杂，不只是简单的 new 一下就可以，而是要组合其他类对象，做各种初始化操作的时候，推荐使用工厂方法模式，将复杂的创建逻辑拆分到多个工厂类中，让每个工厂类都不至于过于复杂。而使用简单工厂模式，将所有的创建逻辑都放到一个工厂类中，会导致这个工厂类变得很复杂。</li>
<li><strong>抽象工厂模式</strong>适用于创建一系列相关或依赖的对象，提供更高的扩展性和灵活性。</li>
</ul>
</li>
<li><p>JDK中的使用案例：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">Boolean</span> <span class="keyword">implements</span> <span class="title">java</span>.<span class="title">io</span>.<span class="title">Serializable</span>,</span></span><br><span class="line"><span class="class">                                      <span class="title">Comparable</span>&lt;<span class="title">Boolean</span>&gt;</span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">    <span class="comment">// 简单工厂模式</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Boolean <span class="title">valueOf</span><span class="params">(<span class="keyword">boolean</span> b)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> (b ? TRUE : FALSE);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 简单工厂模式</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">Calendar</span> <span class="keyword">implements</span> <span class="title">Serializable</span>, <span class="title">Cloneable</span>, <span class="title">Comparable</span>&lt;<span class="title">Calendar</span>&gt; </span>&#123;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Calendar <span class="title">getInstance</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> createCalendar(TimeZone.getDefault(), Locale.getDefault(Locale.Category.FORMAT));</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 懒汉式线程不安全</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> Calendar <span class="title">createCalendar</span><span class="params">(TimeZone zone,</span></span></span><br><span class="line"><span class="params"><span class="function">                                           Locale aLocale)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        CalendarProvider provider =</span><br><span class="line">            LocaleProviderAdapter.getAdapter(CalendarProvider.class, aLocale)</span><br><span class="line">                                 .getCalendarProvider();</span><br><span class="line">        <span class="comment">// 省略</span></span><br><span class="line">        Calendar cal = <span class="keyword">null</span>;</span><br><span class="line">            </span><br><span class="line">        <span class="comment">// 省略</span></span><br><span class="line">        <span class="keyword">return</span> cal;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">DriverManager</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Connection <span class="title">getConnection</span><span class="params">(String url,</span></span></span><br><span class="line"><span class="params"><span class="function">        java.util.Properties info)</span> <span class="keyword">throws</span> SQLException </span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> (getConnection(url, info, Reflection.getCallerClass()));</span><br><span class="line">    &#125;    </span><br><span class="line"></span><br><span class="line">    <span class="comment">// 简单工厂模式</span></span><br><span class="line">	<span class="function"><span class="keyword">private</span> <span class="keyword">static</span> Connection <span class="title">getConnection</span><span class="params">(</span></span></span><br><span class="line"><span class="params"><span class="function">        String url, java.util.Properties info, Class&lt;?&gt; caller)</span> <span class="keyword">throws</span> SQLException </span>&#123;</span><br><span class="line">        </span><br><span class="line">        ClassLoader callerCL = caller != <span class="keyword">null</span> ? caller.getClassLoader() : <span class="keyword">null</span>;</span><br><span class="line">        <span class="keyword">synchronized</span>(DriverManager.class) &#123;</span><br><span class="line">            <span class="comment">// synchronize loading of the correct classloader.</span></span><br><span class="line">            <span class="keyword">if</span> (callerCL == <span class="keyword">null</span>) &#123;</span><br><span class="line">                callerCL = Thread.currentThread().getContextClassLoader();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span>(DriverInfo aDriver : registeredDrivers) &#123;</span><br><span class="line">            <span class="comment">// If the caller does not have permission to load the driver then</span></span><br><span class="line">            <span class="comment">// skip it.</span></span><br><span class="line">            <span class="keyword">if</span>(isDriverAllowed(aDriver.driver, callerCL)) &#123;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    Connection con = aDriver.driver.connect(url, info);</span><br><span class="line">                    <span class="keyword">if</span> (con != <span class="keyword">null</span>) &#123;</span><br><span class="line">                        <span class="comment">// Success!</span></span><br><span class="line">                        println(<span class="string">&quot;getConnection returning &quot;</span> + aDriver.driver.getClass().getName());</span><br><span class="line">                        <span class="keyword">return</span> (con);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125; <span class="keyword">catch</span> (SQLException ex) &#123;</span><br><span class="line">                    <span class="keyword">if</span> (reason == <span class="keyword">null</span>) &#123;</span><br><span class="line">                        reason = ex;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                println(<span class="string">&quot;    skipping: &quot;</span> + aDriver.getClass().getName());</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 省略</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li><p>Spring中的使用案例：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">// 简单工厂模式：如BeanFactory，根据 Bean 的名称来创建 Bean 实例。</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">BeanFactory</span> </span>&#123;</span><br><span class="line">	<span class="function">Object <span class="title">getBean</span><span class="params">(String name)</span> <span class="keyword">throws</span> BeansException</span>;</span><br><span class="line">&#125;</span><br><span class="line">    </span><br><span class="line"><span class="comment">// 工厂方法模式：如AbstractFactoryBean，提供了未实现的抽象方法createInstance()，将对象创建转移给子类来实现</span></span><br><span class="line"><span class="comment">// 其中实现FactoryBean接口会创建一个工厂类，getObject方法是Bean的实例化逻辑，返回由工厂创建的对象。</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">AbstractFactoryBean</span>&lt;<span class="title">T</span>&gt;</span></span><br><span class="line"><span class="class">		<span class="keyword">implements</span> <span class="title">FactoryBean</span>&lt;<span class="title">T</span>&gt;, <span class="title">BeanClassLoaderAware</span>, <span class="title">BeanFactoryAware</span>, <span class="title">InitializingBean</span>, <span class="title">DisposableBean</span> </span>&#123;</span><br><span class="line">    </span><br><span class="line">	<span class="meta">@Nullable</span></span><br><span class="line">	<span class="keyword">private</span> BeanFactory beanFactory;</span><br><span class="line">    </span><br><span class="line">	<span class="meta">@Override</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">final</span> T <span class="title">getObject</span><span class="params">()</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">		<span class="keyword">if</span> (isSingleton()) &#123;</span><br><span class="line">			<span class="keyword">return</span> (<span class="keyword">this</span>.initialized ? <span class="keyword">this</span>.singletonInstance : getEarlySingletonInstance());</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">else</span> &#123;</span><br><span class="line">			<span class="keyword">return</span> createInstance();</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 此处Spring未实现，方便自定义扩展</span></span><br><span class="line">	<span class="function"><span class="keyword">protected</span> <span class="keyword">abstract</span> T <span class="title">createInstance</span><span class="params">()</span> <span class="keyword">throws</span> Exception</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 如：ListFactoryBean，通过必需的sourceList，以及可选的targetListClass，将sourceList转换为指定类型的新数组result</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ListFactoryBean</span> <span class="keyword">extends</span> <span class="title">AbstractFactoryBean</span>&lt;<span class="title">List</span>&lt;<span class="title">Object</span>&gt;&gt; </span>&#123;</span><br><span class="line">    </span><br><span class="line">	<span class="keyword">private</span> List&lt;?&gt; sourceList;</span><br><span class="line">	<span class="keyword">private</span> Class&lt;? extends List&gt; targetListClass;</span><br><span class="line"></span><br><span class="line">	<span class="meta">@Override</span></span><br><span class="line">	<span class="meta">@SuppressWarnings(&quot;unchecked&quot;)</span></span><br><span class="line">	<span class="function"><span class="keyword">protected</span> List&lt;Object&gt; <span class="title">createInstance</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		<span class="keyword">if</span> (<span class="keyword">this</span>.sourceList == <span class="keyword">null</span>) &#123;</span><br><span class="line">			<span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(<span class="string">&quot;&#x27;sourceList&#x27; is required&quot;</span>);</span><br><span class="line">		&#125;</span><br><span class="line">		List&lt;Object&gt; result = <span class="keyword">null</span>;</span><br><span class="line">        <span class="comment">// 此处根据是否指定类型，决定List工厂创建怎样的数组对象，简单工厂模式</span></span><br><span class="line">		<span class="keyword">if</span> (<span class="keyword">this</span>.targetListClass != <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="comment">// 指定了类型，通过反射创建数组对象的实例</span></span><br><span class="line">			result = BeanUtils.instantiateClass(<span class="keyword">this</span>.targetListClass);</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">// 未指定类型，直接初始化ArrayList</span></span><br><span class="line">			result = <span class="keyword">new</span> ArrayList&lt;&gt;(<span class="keyword">this</span>.sourceList.size());</span><br><span class="line">		&#125;</span><br><span class="line">		Class&lt;?&gt; valueType = <span class="keyword">null</span>;</span><br><span class="line">		<span class="keyword">if</span> (<span class="keyword">this</span>.targetListClass != <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="comment">// 指定了类型</span></span><br><span class="line">			valueType = ResolvableType.forClass(<span class="keyword">this</span>.targetListClass).asCollection().resolveGeneric();</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">if</span> (valueType != <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="comment">// 循环转换数组中各个元素的类型</span></span><br><span class="line">			TypeConverter converter = getBeanTypeConverter();</span><br><span class="line">			<span class="keyword">for</span> (Object elem : <span class="keyword">this</span>.sourceList) &#123;</span><br><span class="line">				result.add(converter.convertIfNecessary(elem, valueType));</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">// 未指定类型，简单的复制数组</span></span><br><span class="line">			result.addAll(<span class="keyword">this</span>.sourceList);</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">return</span> result;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 抽象工厂模式：如AbstractBeanFactory实现了如getBean()等的基础逻辑，留了如createBean()等抽象接口扩展，支持不同类型的Bean，由具体的子类工厂来决定产品Bean的生成逻辑，如 DefaultListableBeanFactory 和 XmlBeanFactory</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">AbstractBeanFactory</span> <span class="keyword">extends</span> <span class="title">FactoryBeanRegistrySupport</span> <span class="keyword">implements</span> <span class="title">ConfigurableBeanFactory</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 省略</span></span><br><span class="line">	<span class="function"><span class="keyword">protected</span> <span class="keyword">abstract</span> Object <span class="title">createBean</span><span class="params">(String beanName, RootBeanDefinition mbd, <span class="meta">@Nullable</span> Object[] args)</span></span></span><br><span class="line"><span class="function">			<span class="keyword">throws</span> BeanCreationException</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
<h4 id="问：生产者消费者模式？要求手写出代码"><a href="#问：生产者消费者模式？要求手写出代码" class="headerlink" title="问：生产者消费者模式？要求手写出代码"></a>问：生产者消费者模式？要求手写出代码</h4><ul>
<li><strong>生产者-消费者模式</strong>是一种常见的多线程设计模式，主要解决两个线程之间共享数据的问题。</li>
<li>生产者负责生产数据，消费者负责消费数据。两者通过一个<strong>共享的缓冲区</strong>进行交互，使用<strong>同步机制</strong>避免出现资源竞争问题。</li>
</ul>
<p>通常，生产者-消费者模式涉及以下几个关键点：</p>
<ol>
<li>共享资源（缓冲区）。</li>
<li>使用同步机制（如 <code>wait()</code> 和 <code>notify()</code>）来确保数据生产与消费的协调性，避免并发问题。</li>
<li>阻塞条件：生产者等待缓冲区有空间才能生产，消费者等待缓冲区有数据才能消费。</li>
</ol>
<p>以下是一个使用 Java 编写的基于 <code>wait()</code> 和 <code>notify()</code> 实现的经典生产者-消费者模式：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 生产者和消费者共享的缓冲区</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">SharedQueue</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 使用 LinkedList 作为内部的队列来存储数据</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> Queue&lt;Integer&gt; queue = <span class="keyword">new</span> LinkedList&lt;&gt;();</span><br><span class="line">    <span class="comment">// 容量 capacity 限制了队列的最大大小</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">int</span> capacity;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">SharedQueue</span><span class="params">(<span class="keyword">int</span> capacity)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.capacity = capacity;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 使用 synchronized 来确保线程安全</span></span><br><span class="line">    <span class="comment">// 生产者方法：生产者调用该方法生产数据，如果缓冲区已满，生产者进入等待状态，直到消费者消费了数据。</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">produce</span><span class="params">(<span class="keyword">int</span> value)</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">        <span class="comment">// 如果队列已满，等待消费者消费</span></span><br><span class="line">        <span class="keyword">while</span> (queue.size() == capacity) &#123;</span><br><span class="line">            wait();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 生产数据并通知消费者</span></span><br><span class="line">        queue.offer(value);</span><br><span class="line">        System.out.println(<span class="string">&quot;Produced: &quot;</span> + value);</span><br><span class="line">        <span class="comment">// 通知所有等待的线程</span></span><br><span class="line">        notifyAll();  </span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 消费者方法：消费者调用该方法消费数据，如果缓冲区为空，消费者进入等待状态，直到生产者生产了数据。</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">int</span> <span class="title">consume</span><span class="params">()</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">        <span class="comment">// 如果队列为空，等待生产者生产</span></span><br><span class="line">        <span class="keyword">while</span> (queue.isEmpty()) &#123;</span><br><span class="line">            wait();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 消费数据并通知生产者</span></span><br><span class="line">        <span class="keyword">int</span> value = queue.poll();</span><br><span class="line">        System.out.println(<span class="string">&quot;Consumed: &quot;</span> + value);</span><br><span class="line">        <span class="comment">// 通知所有等待的线程</span></span><br><span class="line">        notifyAll();  </span><br><span class="line">        <span class="keyword">return</span> value;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Producer</span> <span class="keyword">implements</span> <span class="title">Runnable</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> SharedQueue sharedQueue;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Producer</span><span class="params">(SharedQueue sharedQueue)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.sharedQueue = sharedQueue;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> value = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">while</span> (<span class="keyword">true</span>) &#123;</span><br><span class="line">                sharedQueue.produce(value++);</span><br><span class="line">                <span class="comment">// 模拟生产过程的延时</span></span><br><span class="line">                Thread.sleep(<span class="number">500</span>);  </span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">            Thread.currentThread().interrupt();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Consumer</span> <span class="keyword">implements</span> <span class="title">Runnable</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> SharedQueue sharedQueue;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Consumer</span><span class="params">(SharedQueue sharedQueue)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.sharedQueue = sharedQueue;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">while</span> (<span class="keyword">true</span>) &#123;</span><br><span class="line">                sharedQueue.consume();</span><br><span class="line">                <span class="comment">// 模拟消费过程的延时</span></span><br><span class="line">                Thread.sleep(<span class="number">1000</span>);  </span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">            Thread.currentThread().interrupt();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ProducerConsumerTest</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 创建一个容量为5的共享队列</span></span><br><span class="line">        SharedQueue sharedQueue = <span class="keyword">new</span> SharedQueue(<span class="number">5</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 启动生产者线程</span></span><br><span class="line">        Thread producerThread = <span class="keyword">new</span> Thread(<span class="keyword">new</span> Producer(sharedQueue));</span><br><span class="line">        producerThread.start();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 启动消费者线程</span></span><br><span class="line">        Thread consumerThread = <span class="keyword">new</span> Thread(<span class="keyword">new</span> Consumer(sharedQueue));</span><br><span class="line">        consumerThread.start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h4 id="问：观察者模式？"><a href="#问：观察者模式？" class="headerlink" title="问：观察者模式？"></a>问：观察者模式？</h4><ol>
<li><p>什么是观察者模式？</p>
<ul>
<li><strong>观察者模式</strong>（Observer Pattern）定义了一种<strong>一对多的依赖关系</strong>，当一个对象的状态发生改变时，所有依赖于它的对象都会得到通知并自动更新。它广泛用于系统中对象之间的解耦和异步通知。</li>
</ul>
</li>
<li><p>模式中有哪些角色？</p>
<ul>
<li><strong>Subject</strong>（主题/被观察者）：拥有状态，当状态发生变化时通知所有观察者。</li>
<li><strong>Observer</strong>（观察者）：观察被观察者的状态变化并做出响应。</li>
<li><strong>ConcreteSubject</strong>：具体的主题，持有观察者列表并通知观察者。</li>
<li><strong>ConcreteObserver</strong>：具体的观察者，实现更新方法，响应主题的状态变化。</li>
</ul>
</li>
<li><p>优缺点？</p>
<ul>
<li>优点：<ul>
<li><strong>解耦</strong>：观察者与被观察者之间通过接口或抽象类进行通信，被观察者不需要了解观察者的具体实现，降低了耦合度。</li>
<li><strong>扩展性好</strong>：可以方便地添加新的观察者，符合<strong>开闭原则</strong>。</li>
<li><strong>异步通信</strong>：被观察者状态改变后，通知可以通过事件机制异步触发，适用于实时数据更新的场景。</li>
</ul>
</li>
<li>缺点：<ul>
<li><strong>性能问题</strong>：如果观察者数量多，通知的开销大，可能导致系统性能下降。</li>
<li><strong>循环依赖</strong>：如果两个对象相互依赖且是彼此的观察者，可能会导致循环调用，甚至引发栈溢出。</li>
</ul>
</li>
</ul>
</li>
<li><p>使用场景？</p>
<ul>
<li>当一个对象的改变需要自动通知多个对象时，例如 GUI 中的事件监听机制。</li>
<li>实时系统中，当系统中某个对象发生变化时，希望能通知其他依赖对象。</li>
</ul>
</li>
<li><p>代码实现？</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 观察者接口</span></span><br><span class="line"><span class="class"><span class="keyword">interface</span> <span class="title">Observer</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">update</span><span class="params">(String message)</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 具体的观察者类</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ConcreteObserver</span> <span class="keyword">implements</span> <span class="title">Observer</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">ConcreteObserver</span><span class="params">(String name)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.name = name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">update</span><span class="params">(String message)</span> </span>&#123;</span><br><span class="line">        System.out.println(name + <span class="string">&quot; received message: &quot;</span> + message);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 被观察者接口</span></span><br><span class="line"><span class="class"><span class="keyword">interface</span> <span class="title">Subject</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">registerObserver</span><span class="params">(Observer observer)</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">removeObserver</span><span class="params">(Observer observer)</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">notifyObservers</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 具体的被观察者类</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ConcreteSubject</span> <span class="keyword">implements</span> <span class="title">Subject</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> List&lt;Observer&gt; observers = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">    <span class="keyword">private</span> String state;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">registerObserver</span><span class="params">(Observer observer)</span> </span>&#123;</span><br><span class="line">        observers.add(observer);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">removeObserver</span><span class="params">(Observer observer)</span> </span>&#123;</span><br><span class="line">        observers.remove(observer);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">notifyObservers</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (Observer observer : observers) &#123;</span><br><span class="line">            observer.update(state);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setState</span><span class="params">(String state)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.state = state;</span><br><span class="line">        notifyObservers();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 测试代码</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ObserverPatternDemo</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 创建主题</span></span><br><span class="line">        ConcreteSubject subject = <span class="keyword">new</span> ConcreteSubject();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 创建观察者</span></span><br><span class="line">        Observer observer1 = <span class="keyword">new</span> ConcreteObserver(<span class="string">&quot;Observer 1&quot;</span>);</span><br><span class="line">        Observer observer2 = <span class="keyword">new</span> ConcreteObserver(<span class="string">&quot;Observer 2&quot;</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 注册观察者</span></span><br><span class="line">        subject.registerObserver(observer1);</span><br><span class="line">        subject.registerObserver(observer2);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 修改状态</span></span><br><span class="line">        subject.setState(<span class="string">&quot;State changed to NEW&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li><p>JDK中有哪些地方使用了该模式？</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 观察者接口，定义了 update() 方法</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Observer</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">update</span><span class="params">(Observable o, Object arg)</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 被观察者类，提供了管理观察者的方法如 addObserver() 和 notifyObservers()</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Observable</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">boolean</span> changed = <span class="keyword">false</span>;</span><br><span class="line">    <span class="keyword">private</span> Vector&lt;Observer&gt; obs;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Observable</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        obs = <span class="keyword">new</span> Vector&lt;&gt;();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">addObserver</span><span class="params">(Observer o)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (o == <span class="keyword">null</span>)</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> NullPointerException();</span><br><span class="line">        <span class="keyword">if</span> (!obs.contains(o)) &#123;</span><br><span class="line">            obs.addElement(o);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">deleteObserver</span><span class="params">(Observer o)</span> </span>&#123;</span><br><span class="line">        obs.removeElement(o);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">notifyObservers</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        notifyObservers(<span class="keyword">null</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">notifyObservers</span><span class="params">(Object arg)</span> </span>&#123;</span><br><span class="line">        Object[] arrLocal;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">synchronized</span> (<span class="keyword">this</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> (!changed)</span><br><span class="line">                <span class="keyword">return</span>;</span><br><span class="line">            arrLocal = obs.toArray();</span><br><span class="line">            clearChanged();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = arrLocal.length-<span class="number">1</span>; i&gt;=<span class="number">0</span>; i--)</span><br><span class="line">            ((Observer)arrLocal[i]).update(<span class="keyword">this</span>, arg);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// ......</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 具体的被观察者</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ConcreteObservable</span> <span class="keyword">extends</span> <span class="title">Observable</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> String state;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setState</span><span class="params">(String state)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.state = state;</span><br><span class="line">        setChanged(); <span class="comment">// 标记状态已更改</span></span><br><span class="line">        notifyObservers(state); <span class="comment">// 通知所有观察者</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 具体的观察者</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ConcreteObserver</span> <span class="keyword">implements</span> <span class="title">Observer</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">update</span><span class="params">(Observable o, Object arg)</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;Received update: &quot;</span> + arg);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 测试</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ObserverPatternJDK</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        ConcreteObservable observable = <span class="keyword">new</span> ConcreteObservable();</span><br><span class="line">        ConcreteObserver observer = <span class="keyword">new</span> ConcreteObserver();</span><br><span class="line"></span><br><span class="line">        observable.addObserver(observer);</span><br><span class="line">        observable.setState(<span class="string">&quot;New State&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li><p>Spring有哪些地方使用了该模式？</p>
<p>Spring 的 <code>ApplicationContext</code> 支持事件发布和监听，这本质上就是观察者模式的实现。</p>
<ul>
<li>**<code>ApplicationEventPublisher</code>**：事件发布者，相当于主题。</li>
<li>**<code>ApplicationListener</code>**：事件监听器，相当于观察者。</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 观察者</span></span><br><span class="line"><span class="meta">@FunctionalInterface</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">ApplicationListener</span>&lt;<span class="title">E</span> <span class="keyword">extends</span> <span class="title">ApplicationEvent</span>&gt; <span class="keyword">extends</span> <span class="title">EventListener</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">onApplicationEvent</span><span class="params">(E var1)</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 被观察者</span></span><br><span class="line"><span class="meta">@FunctionalInterface</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">ApplicationEventPublisher</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">default</span> <span class="keyword">void</span> <span class="title">publishEvent</span><span class="params">(ApplicationEvent event)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.publishEvent((Object)event);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">publishEvent</span><span class="params">(Object var1)</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 自定义事件</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyEvent</span> <span class="keyword">extends</span> <span class="title">ApplicationEvent</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">MyEvent</span><span class="params">(Object source)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>(source);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 事件监听器</span></span><br><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyEventListener</span> <span class="keyword">implements</span> <span class="title">ApplicationListener</span>&lt;<span class="title">MyEvent</span>&gt; </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onApplicationEvent</span><span class="params">(MyEvent event)</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;Event received: &quot;</span> + event.getSource());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 事件发布</span></span><br><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">EventPublisher</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> ApplicationEventPublisher publisher;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">publishEvent</span><span class="params">(String message)</span> </span>&#123;</span><br><span class="line">        publisher.publishEvent(<span class="keyword">new</span> MyEvent(message));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure></li>
</ol>
<h4 id="问：适配器模式？"><a href="#问：适配器模式？" class="headerlink" title="问：适配器模式？"></a>问：适配器模式？</h4><ol>
<li><p>什么是适配器模式？</p>
<ul>
<li><p><strong>适配器模式</strong>（Adapter Pattern）将一个类的接口转换为用户所期望的另一个接口。它的目的是<strong>通过适配器类将两个不兼容的接口结合在一起</strong>，从而使得原本因接口不兼容而无法一起工作的类能够协同工作。</p>
<p>适配器模式主要<strong>解决的是接口不兼容</strong>的问题，常用于复用现有的类库或框架时，避免修改现有的代码，同时使新旧系统兼容。</p>
</li>
</ul>
</li>
<li><p>模式中有哪些角色？</p>
<ul>
<li><strong>目标接口（Target Interface）</strong>：客户端期望使用的接口。</li>
<li><strong>适配器（Adapter）</strong>：将适配者的接口转换为目标接口。</li>
<li><strong>适配者（Adaptee）</strong>：需要适配的接口或类。</li>
<li><strong>客户端（Client）</strong>：使用目标接口的客户代码。</li>
</ul>
</li>
<li><p>优缺点？</p>
<ul>
<li>优点：<ul>
<li><strong>提高代码的复用性</strong>：通过适配器，可以复用现有的代码，而不需要修改原来的类。</li>
<li><strong>提高系统的灵活性</strong>：客户端可以动态地选择合适的适配器，不影响系统的其他部分。</li>
</ul>
</li>
<li>缺点：<ul>
<li><strong>复杂度增加</strong>：引入适配器类增加了系统的复杂性，尤其是大量使用时。</li>
<li><strong>效率问题</strong>：某些情况下适配器模式可能会增加系统的开销，因为增加了一层间接调用。</li>
</ul>
</li>
</ul>
</li>
<li><p>使用场景？</p>
<ul>
<li>当你希望使用一个已经存在的类，但其接口与所需接口不兼容时，可以使用适配器模式。</li>
<li>系统中有多个类接口类似，但不相同，通过适配器模式可以统一接口。</li>
<li>希望将类和类之间的依赖解耦，但现有类接口不符合要求。</li>
</ul>
</li>
<li><p>代码实现？</p>
<p>假设我们有一个<code>VGA</code>接口，现在需要使用<code>HDMI</code>接口的设备，适配器模式可以将<code>HDMI</code>接口转换成<code>VGA</code>接口。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 目标接口</span></span><br><span class="line"><span class="class"><span class="keyword">interface</span> <span class="title">VGA</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">showVGA</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 适配者类：HDMI</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">HDMI</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">showHDMI</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;Displaying content via HDMI.&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 适配器类，将 HDMI 转换为 VGA</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">HDMItoVGAAdapter</span> <span class="keyword">implements</span> <span class="title">VGA</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> HDMI hdmi;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">HDMItoVGAAdapter</span><span class="params">(HDMI hdmi)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.hdmi = hdmi;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">showVGA</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 调用 HDMI 的方法</span></span><br><span class="line">        hdmi.showHDMI();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 客户端</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">AdapterPatternDemo</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 创建适配者对象</span></span><br><span class="line">        HDMI hdmiDevice = <span class="keyword">new</span> HDMI();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 使用适配器适配 HDMI 到 VGA</span></span><br><span class="line">        VGA vgaDevice = <span class="keyword">new</span> HDMItoVGAAdapter(hdmiDevice);</span><br><span class="line">        vgaDevice.showVGA(); <span class="comment">// 实际调用的是 HDMI 的 showHDMI()</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li><p>JDK中有哪些地方使用了该模式？</p>
<ul>
<li>**<code>java.util.Arrays#asList()</code>**：将数组适配为 <code>List</code>。</li>
<li>**<code>java.io.InputStreamReader</code> 和 <code>java.io.OutputStreamWriter</code>**：将字节流适配为字符流。</li>
<li>**<code>java.util.Collections#enumeration()</code> 和 <code>java.util.Collections#list()</code>**：将 <code>List</code> 和 <code>Enumeration</code> 互相转换。</li>
</ul>
</li>
<li><p>Spring有哪些地方使用了该模式？</p>
<ul>
<li>Spring 的 <strong><code>HandlerAdapter</code></strong> 就是典型的适配器模式，它使得不同类型的控制器（如 <code>@Controller</code> 和 <code>SimpleController</code>）可以被 <code>DispatcherServlet</code> 处理。如，<code>RequestMappingHandlerAdapter</code> 可以将 <code>@RequestMapping</code> 标注的方法适配为 <code>Handler</code>。</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">package</span> org.springframework.web.reactive;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> org.springframework.web.server.ServerWebExchange;</span><br><span class="line"><span class="keyword">import</span> reactor.core.publisher.Mono;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">HandlerAdapter</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">boolean</span> <span class="title">supports</span><span class="params">(Object var1)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="function">Mono&lt;HandlerResult&gt; <span class="title">handle</span><span class="params">(ServerWebExchange var1, Object var2)</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 当 DispatcherServlet 收到一个 HTTP 请求时，它首先会通过不同的 HandlerMapping 实现类来找到与该请求对应的处理器（Handler）。对于 @RequestMapping 注解的方法，RequestMappingHandlerMapping 会负责解析 URL 路径、HTTP 方法等信息，并找到对应的 HandlerMethod。</span></span><br><span class="line"><span class="comment">// 例如：找到一个标注了 @RequestMapping 的控制器方法</span></span><br><span class="line"><span class="meta">@Controller</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyController</span> </span>&#123;</span><br><span class="line">    <span class="meta">@RequestMapping(&quot;/greeting&quot;)</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">greeting</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;Hello, World!&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// RequestMappingHandlerMapping 将 @RequestMapping 注解解析为一个 HandlerMethod 对象，该对象包含了控制器类的实例（MyController）和方法对象（greeting() 方法）。</span></span><br><span class="line">HandlerMethod handlerMethod = <span class="keyword">new</span> HandlerMethod(controllerInstance, method);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 一旦 HandlerMapping 找到合适的 Handler，DispatcherServlet 会将该 Handler 传递给 RequestMappingHandlerAdapter。RequestMappingHandlerAdapter 的任务就是执行这个 HandlerMethod，并返回处理结果。</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">RequestMappingHandlerAdapter</span> <span class="keyword">implements</span> <span class="title">HandlerAdapter</span>, <span class="title">ApplicationContextAware</span>, <span class="title">InitializingBean</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// HTTP 消息读取器的列表，通常用于处理请求体</span></span><br><span class="line">    <span class="keyword">private</span> List&lt;HttpMessageReader&lt;?&gt;&gt; messageReaders = Collections.emptyList();</span><br><span class="line">    <span class="comment">// 用于初始化 Web 数据绑定的对象，比如初始化参数绑定</span></span><br><span class="line">    <span class="meta">@Nullable</span></span><br><span class="line">    <span class="keyword">private</span> WebBindingInitializer webBindingInitializer;</span><br><span class="line">    <span class="comment">// 处理控制器方法参数解析的配置</span></span><br><span class="line">    <span class="meta">@Nullable</span></span><br><span class="line">    <span class="keyword">private</span> ArgumentResolverConfigurer argumentResolverConfigurer;</span><br><span class="line">    <span class="comment">// 响应式编程的适配器注册表，用于处理响应式类型的转换</span></span><br><span class="line">    <span class="meta">@Nullable</span></span><br><span class="line">    <span class="keyword">private</span> ReactiveAdapterRegistry reactiveAdapterRegistry;</span><br><span class="line">    <span class="comment">// 应用上下文，用于获取 Bean 和依赖注入等</span></span><br><span class="line">    <span class="meta">@Nullable</span></span><br><span class="line">    <span class="keyword">private</span> ConfigurableApplicationContext applicationContext;</span><br><span class="line">    <span class="comment">// 控制器方法的解析器，用于解析请求映射的方法</span></span><br><span class="line">    <span class="meta">@Nullable</span></span><br><span class="line">    <span class="keyword">private</span> ControllerMethodResolver methodResolver;</span><br><span class="line">    <span class="comment">// 模型初始化器，用于处理请求时的模型数据初始化</span></span><br><span class="line">    <span class="meta">@Nullable</span></span><br><span class="line">    <span class="keyword">private</span> ModelInitializer modelInitializer;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 省略一些set get方法</span></span><br><span class="line">    <span class="comment">// 设置应用上下文，ApplicationContextAware接口的方法</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setApplicationContext</span><span class="params">(ApplicationContext applicationContext)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (applicationContext <span class="keyword">instanceof</span> ConfigurableApplicationContext) &#123;</span><br><span class="line">            <span class="keyword">this</span>.applicationContext = (ConfigurableApplicationContext)applicationContext;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 在所有属性设置之后进行初始化，InitializingBean接口的方法</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">afterPropertiesSet</span><span class="params">()</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        <span class="comment">// 确保应用上下文已经设置</span></span><br><span class="line">        Assert.notNull(<span class="keyword">this</span>.applicationContext, <span class="string">&quot;ApplicationContext is required&quot;</span>);</span><br><span class="line">        <span class="comment">// 如果消息读取器为空，则创建默认的读取器</span></span><br><span class="line">        <span class="keyword">if</span> (CollectionUtils.isEmpty(<span class="keyword">this</span>.messageReaders)) &#123;</span><br><span class="line">            ServerCodecConfigurer codecConfigurer = ServerCodecConfigurer.create();</span><br><span class="line">            <span class="keyword">this</span>.messageReaders = codecConfigurer.getReaders();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 如果参数解析器配置器为空，创建默认的配置器</span></span><br><span class="line">        <span class="keyword">if</span> (<span class="keyword">this</span>.argumentResolverConfigurer == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">this</span>.argumentResolverConfigurer = <span class="keyword">new</span> ArgumentResolverConfigurer();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 如果响应式适配器注册表为空，使用共享实例</span></span><br><span class="line">        <span class="keyword">if</span> (<span class="keyword">this</span>.reactiveAdapterRegistry == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">this</span>.reactiveAdapterRegistry = ReactiveAdapterRegistry.getSharedInstance();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 初始化方法解析器和模型初始化器</span></span><br><span class="line">        <span class="keyword">this</span>.methodResolver = <span class="keyword">new</span> ControllerMethodResolver(<span class="keyword">this</span>.argumentResolverConfigurer, <span class="keyword">this</span>.reactiveAdapterRegistry, <span class="keyword">this</span>.applicationContext, <span class="keyword">this</span>.messageReaders);</span><br><span class="line">        <span class="keyword">this</span>.modelInitializer = <span class="keyword">new</span> ModelInitializer(<span class="keyword">this</span>.methodResolver, <span class="keyword">this</span>.reactiveAdapterRegistry);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 判断是否支持给定的 handler，必须是 HandlerMethod 类型</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">supports</span><span class="params">(Object handler)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> handler <span class="keyword">instanceof</span> HandlerMethod;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 处理请求并返回 HandlerResult，核心方法</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Mono&lt;HandlerResult&gt; <span class="title">handle</span><span class="params">(ServerWebExchange exchange, Object handler)</span> </span>&#123;</span><br><span class="line">        HandlerMethod handlerMethod = (HandlerMethod)handler;</span><br><span class="line">        <span class="comment">// 确保 methodResolver 和 modelInitializer 已经初始化</span></span><br><span class="line">        Assert.state(<span class="keyword">this</span>.methodResolver != <span class="keyword">null</span> &amp;&amp; <span class="keyword">this</span>.modelInitializer != <span class="keyword">null</span>, <span class="string">&quot;Not initialized&quot;</span>);</span><br><span class="line">        <span class="comment">// 创建绑定上下文，用于数据绑定和校验</span></span><br><span class="line">        InitBinderBindingContext bindingContext = <span class="keyword">new</span> InitBinderBindingContext(<span class="keyword">this</span>.getWebBindingInitializer(), <span class="keyword">this</span>.methodResolver.getInitBinderMethods(handlerMethod));</span><br><span class="line">        <span class="comment">// 获取可执行的控制器方法</span></span><br><span class="line">        InvocableHandlerMethod invocableMethod = <span class="keyword">this</span>.methodResolver.getRequestMappingMethod(handlerMethod);</span><br><span class="line">        <span class="comment">// 定义异常处理函数，如果方法抛出异常则使用此函数处理</span></span><br><span class="line">        Function&lt;Throwable, Mono&lt;HandlerResult&gt;&gt; exceptionHandler = (ex) -&gt; &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">this</span>.handleException(ex, handlerMethod, bindingContext, exchange);</span><br><span class="line">        &#125;;</span><br><span class="line">        <span class="comment">// 初始化模型数据并调用控制器方法</span></span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">this</span>.modelInitializer.initModel(handlerMethod, bindingContext, exchange).then(Mono.defer(() -&gt; &#123;</span><br><span class="line">            <span class="keyword">return</span> invocableMethod.invoke(exchange, bindingContext, <span class="keyword">new</span> Object[<span class="number">0</span>]);</span><br><span class="line">        &#125;)).doOnNext((result) -&gt; &#123;</span><br><span class="line">            result.setExceptionHandler(exceptionHandler);</span><br><span class="line">        &#125;).doOnNext((result) -&gt; &#123;</span><br><span class="line">            bindingContext.saveModel();</span><br><span class="line">        &#125;).onErrorResume(exceptionHandler);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 省略异常处理函数</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 初始化请求处理过程中所需的模型数据</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ModelInitializer</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 用于解析控制器方法的解析器</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> ControllerMethodResolver methodResolver; </span><br><span class="line">    <span class="comment">// 响应式编程的适配器注册表</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> ReactiveAdapterRegistry adapterRegistry; </span><br><span class="line">    <span class="comment">// 省略构造函数</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 初始化模型数据，包括处理 @ModelAttribute 注解的方法，并且在需要时从会话中恢复模型数据</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Mono&lt;Void&gt; <span class="title">initModel</span><span class="params">(HandlerMethod handlerMethod, InitBinderBindingContext bindingContext, ServerWebExchange exchange)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 获取控制器中的 @ModelAttribute 方法</span></span><br><span class="line">        List&lt;InvocableHandlerMethod&gt; modelMethods = <span class="keyword">this</span>.methodResolver.getModelAttributeMethods(handlerMethod);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 获取与处理器方法相关联的会话属性处理器</span></span><br><span class="line">        SessionAttributesHandler sessionAttributesHandler = <span class="keyword">this</span>.methodResolver.getSessionAttributesHandler(handlerMethod);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 如果处理器没有 session attributes，则直接调用 @ModelAttribute 方法来初始化模型</span></span><br><span class="line">        <span class="keyword">return</span> !sessionAttributesHandler.hasSessionAttributes() ?</span><br><span class="line">                <span class="keyword">this</span>.invokeModelAttributeMethods(bindingContext, modelMethods, exchange) :</span><br><span class="line">                <span class="comment">// 如果有 session attributes，则从会话中获取数据并将其合并到模型中</span></span><br><span class="line">                exchange.getSession().flatMap((session) -&gt; &#123;</span><br><span class="line">                    Map&lt;String, Object&gt; attributes = sessionAttributesHandler.retrieveAttributes(session);</span><br><span class="line">                    bindingContext.getModel().mergeAttributes(attributes);</span><br><span class="line">                    bindingContext.setSessionContext(sessionAttributesHandler, session);</span><br><span class="line"></span><br><span class="line">                    <span class="comment">// 执行 @ModelAttribute 方法，并在成功后从 session 中恢复模型属性</span></span><br><span class="line">                    <span class="keyword">return</span> <span class="keyword">this</span>.invokeModelAttributeMethods(bindingContext, modelMethods, exchange).doOnSuccess((aVoid) -&gt; &#123;</span><br><span class="line">                        <span class="keyword">this</span>.findModelAttributes(handlerMethod, sessionAttributesHandler).forEach((name) -&gt; &#123;</span><br><span class="line">                            <span class="keyword">if</span> (!bindingContext.getModel().containsAttribute(name)) &#123;</span><br><span class="line">                                Object value = session.getRequiredAttribute(name);</span><br><span class="line">                                bindingContext.getModel().addAttribute(name, value);</span><br><span class="line">                            &#125;</span><br><span class="line">                        &#125;);</span><br><span class="line">                    &#125;);</span><br><span class="line">                &#125;);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 调用所有 @ModelAttribute 方法，初始化模型</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> Mono&lt;Void&gt; <span class="title">invokeModelAttributeMethods</span><span class="params">(BindingContext bindingContext, List&lt;InvocableHandlerMethod&gt; modelMethods, ServerWebExchange exchange)</span> </span>&#123;</span><br><span class="line">        List&lt;Mono&lt;HandlerResult&gt;&gt; resultList = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 遍历每个 @ModelAttribute 方法，并执行它们</span></span><br><span class="line">        modelMethods.forEach((invocable) -&gt; &#123;</span><br><span class="line">            resultList.add(invocable.invoke(exchange, bindingContext, <span class="keyword">new</span> Object[<span class="number">0</span>]));</span><br><span class="line">        &#125;);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 将所有方法的结果汇总并返回</span></span><br><span class="line">        <span class="keyword">return</span> Mono.zip(resultList, (objectArray) -&gt; &#123;</span><br><span class="line">            <span class="keyword">return</span> (List) Arrays.stream(objectArray)</span><br><span class="line">                .map((object) -&gt; <span class="keyword">this</span>.handleResult((HandlerResult) object, bindingContext))</span><br><span class="line">                .collect(Collectors.toList());</span><br><span class="line">        &#125;).flatMap(Mono::when);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 处理 @ModelAttribute 方法的返回值，将其添加到模型中</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> Mono&lt;Void&gt; <span class="title">handleResult</span><span class="params">(HandlerResult handlerResult, BindingContext bindingContext)</span> </span>&#123;</span><br><span class="line">        Object value = handlerResult.getReturnValue();</span><br><span class="line">        <span class="keyword">if</span> (value != <span class="keyword">null</span>) &#123;</span><br><span class="line">            ResolvableType type = handlerResult.getReturnType();</span><br><span class="line">            ReactiveAdapter adapter = <span class="keyword">this</span>.adapterRegistry.getAdapter(type.resolve(), value);</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 检查返回值是否是异步类型且为 void</span></span><br><span class="line">            <span class="keyword">if</span> (<span class="keyword">this</span>.isAsyncVoidType(type, adapter)) &#123;</span><br><span class="line">                <span class="keyword">return</span> Mono.from(adapter.toPublisher(value));</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 获取属性名并将值放入模型中</span></span><br><span class="line">            String name = <span class="keyword">this</span>.getAttributeName(handlerResult.getReturnTypeSource());</span><br><span class="line">            bindingContext.getModel().asMap().putIfAbsent(name, value);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> Mono.empty();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 省略一些方法</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ol>
<h4 id="问：代理模式？"><a href="#问：代理模式？" class="headerlink" title="问：代理模式？"></a>问：代理模式？</h4><ol>
<li><p>什么是代理模式？</p>
<ul>
<li><strong>代理模式</strong>（Proxy Pattern）允许为其他对象提供一个代理，以控制对该对象的访问。代理模式<strong>通过为目标对象提供一个代理对象</strong>，使得在调用目标对象的方法时，额外的逻辑可以在方法前后进行处理，比如权限控制、日志记录、延迟加载等。</li>
</ul>
</li>
<li><p>模式中有哪些角色？</p>
<ul>
<li><strong>Subject（抽象主题）</strong>：定义代理和目标对象的共同接口，使得客户端可以通过接口与目标对象进行交互。</li>
<li><strong>RealSubject（真实主题）</strong>：实现了 <code>Subject</code> 接口的真实业务类，包含业务逻辑。</li>
<li><strong>Proxy（代理类）</strong>：实现了 <code>Subject</code> 接口，控制对 <code>RealSubject</code> 的访问，可以在调用真实业务方法前后执行一些额外操作。</li>
</ul>
</li>
<li><p>优缺点？</p>
<ul>
<li>优点：<ul>
<li><strong>控制访问</strong>：代理模式可以控制对目标对象的访问，比如限制某些不符合条件的请求。</li>
<li><strong>增强功能</strong>：在不修改原始对象的情况下，可以通过代理类扩展功能，例如在方法执行前后添加日志、监控、事务处理等。</li>
<li><strong>延迟初始化</strong>：代理模式可以在目标对象需要时才创建它，节省内存和资源。</li>
</ul>
</li>
<li>缺点：<ul>
<li><strong>增加复杂性</strong>：引入代理类可能使系统结构变得复杂。</li>
<li><strong>性能开销</strong>：代理模式会在调用真实对象的方法时引入额外的调用开销。</li>
</ul>
</li>
</ul>
</li>
<li><p>使用场景？</p>
<ul>
<li><strong>权限控制</strong>：通过代理类控制对目标对象的访问权限。</li>
<li><strong>远程代理</strong>：为位于不同地址空间的对象提供本地代理，便于本地程序与远程对象通信。</li>
<li><strong>虚拟代理</strong>：在目标对象的创建开销很大时，可以通过虚拟代理进行延迟加载。</li>
<li><strong>缓存代理</strong>：为目标对象提供缓存功能，避免重复计算。</li>
<li><strong>日志监控</strong>：通过代理类在方法调用前后添加日志或性能监控。</li>
</ul>
</li>
<li><p>代码实现？</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 1. 抽象主题</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Subject</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">request</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 2. 真实主题</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">RealSubject</span> <span class="keyword">implements</span> <span class="title">Subject</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">request</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;RealSubject: Handling request.&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 3. 代理类</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Proxy</span> <span class="keyword">implements</span> <span class="title">Subject</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> RealSubject realSubject;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">request</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (realSubject == <span class="keyword">null</span>) &#123;</span><br><span class="line">            realSubject = <span class="keyword">new</span> RealSubject();</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(<span class="string">&quot;Proxy: Logging before request.&quot;</span>);</span><br><span class="line">        realSubject.request();</span><br><span class="line">        System.out.println(<span class="string">&quot;Proxy: Logging after request.&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 4. 客户端代码</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Client</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Subject proxy = <span class="keyword">new</span> Proxy();</span><br><span class="line">        proxy.request(); <span class="comment">// 使用代理对象来调用</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 输出：</span></span><br><span class="line">Proxy: Logging before request.</span><br><span class="line">RealSubject: Handling request.</span><br><span class="line">Proxy: Logging after request.</span><br></pre></td></tr></table></figure></li>
<li><p>JDK中有哪些地方使用了该模式？JDK 提供的动态代理可以在运行时动态生成代理类，而不需要手动定义代理类。JDK 动态代理通过 <code>java.lang.reflect.Proxy</code> 类和 <code>InvocationHandler</code> 接口实现，是 Java 内置的代理模式。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 1. 抽象主题</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Subject</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">request</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 2. 真实主题</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">RealSubject</span> <span class="keyword">implements</span> <span class="title">Subject</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">request</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;RealSubject: Handling request.&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 3. 动态代理类</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">DynamicProxyHandler</span> <span class="keyword">implements</span> <span class="title">InvocationHandler</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> Object realSubject;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">DynamicProxyHandler</span><span class="params">(Object realSubject)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.realSubject = realSubject;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Object <span class="title">invoke</span><span class="params">(Object proxy, Method method, Object[] args)</span> <span class="keyword">throws</span> Throwable </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;Proxy: Logging before request.&quot;</span>);</span><br><span class="line">        Object result = method.invoke(realSubject, args);</span><br><span class="line">        System.out.println(<span class="string">&quot;Proxy: Logging after request.&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 4. 客户端代码</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Client</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        RealSubject realSubject = <span class="keyword">new</span> RealSubject();</span><br><span class="line">        Subject proxyInstance = (Subject) Proxy.newProxyInstance(</span><br><span class="line">                realSubject.getClass().getClassLoader(),</span><br><span class="line">                realSubject.getClass().getInterfaces(),</span><br><span class="line">                <span class="keyword">new</span> DynamicProxyHandler(realSubject)</span><br><span class="line">        );</span><br><span class="line">        proxyInstance.request(); <span class="comment">// 使用动态代理调用方法</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure></li>
<li><p>Spring有哪些地方使用了该模式？Spring AOP（面向切面编程）使用了代理模式。使用 <code>@Transactional</code> 或其他 AOP 注解时，Spring 会通过代理模式为目标方法添加事务管理。</p>
<ul>
<li>JDK 动态代理：使用 <code>Proxy.newProxyInstance</code> 动态生成代理对象。</li>
<li>CGLIB 代理：通过生成目标类的子类来实现代理。</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line">   </span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Object <span class="title">newProxyInstance</span><span class="params">(ClassLoader loader,</span></span></span><br><span class="line"><span class="params"><span class="function">                                      Class&lt;?&gt;[] interfaces,</span></span></span><br><span class="line"><span class="params"><span class="function">                                      InvocationHandler h)</span></span></span><br><span class="line"><span class="function">    <span class="keyword">throws</span> IllegalArgumentException</span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    Objects.requireNonNull(h);</span><br><span class="line">   </span><br><span class="line">    <span class="keyword">final</span> Class&lt;?&gt;[] intfs = interfaces.clone();</span><br><span class="line">    <span class="keyword">final</span> SecurityManager sm = System.getSecurityManager();</span><br><span class="line">    <span class="keyword">if</span> (sm != <span class="keyword">null</span>) &#123;</span><br><span class="line">        checkProxyAccess(Reflection.getCallerClass(), loader, intfs);</span><br><span class="line">    &#125;</span><br><span class="line">   </span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">     * Look up or generate the designated proxy class.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    Class&lt;?&gt; cl = getProxyClass0(loader, intfs);</span><br><span class="line">   </span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">     * Invoke its constructor with the designated invocation handler.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (sm != <span class="keyword">null</span>) &#123;</span><br><span class="line">            checkNewProxyPermission(Reflection.getCallerClass(), cl);</span><br><span class="line">        &#125;</span><br><span class="line">   </span><br><span class="line">        <span class="keyword">final</span> Constructor&lt;?&gt; cons = cl.getConstructor(constructorParams);</span><br><span class="line">        <span class="keyword">final</span> InvocationHandler ih = h;</span><br><span class="line">        <span class="keyword">if</span> (!Modifier.isPublic(cl.getModifiers())) &#123;</span><br><span class="line">            AccessController.doPrivileged(<span class="keyword">new</span> PrivilegedAction&lt;Void&gt;() &#123;</span><br><span class="line">                <span class="function"><span class="keyword">public</span> Void <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">                    cons.setAccessible(<span class="keyword">true</span>);</span><br><span class="line">                    <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> cons.newInstance(<span class="keyword">new</span> Object[]&#123;h&#125;);</span><br><span class="line">    &#125; <span class="keyword">catch</span> (IllegalAccessException|InstantiationException e) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> InternalError(e.toString(), e);</span><br><span class="line">    &#125; <span class="keyword">catch</span> (InvocationTargetException e) &#123;</span><br><span class="line">        Throwable t = e.getCause();</span><br><span class="line">        <span class="keyword">if</span> (t <span class="keyword">instanceof</span> RuntimeException) &#123;</span><br><span class="line">            <span class="keyword">throw</span> (RuntimeException) t;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> InternalError(t.toString(), t);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">catch</span> (NoSuchMethodException e) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> InternalError(e.toString(), e);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ol>
<h4 id="问：模板方法模式？"><a href="#问：模板方法模式？" class="headerlink" title="问：模板方法模式？"></a>问：模板方法模式？</h4><ol>
<li><p>什么是模板方法模式？</p>
<ul>
<li><strong>模板方法模式</strong>（Template Method Pattern）定义了一个操作的算法框架，而将某些步骤的实现延迟到子类。通过模板方法模式，子类可以在不改变算法整体结构的情况下，重新定义某些特定步骤的实现。</li>
</ul>
</li>
<li><p>模式中有哪些角色？</p>
<ul>
<li><strong>AbstractClass（抽象类）</strong>：定义了算法的框架，包含一个模板方法 <code>templateMethod()</code> 和一些抽象方法，具体的步骤由子类实现。</li>
<li><strong>ConcreteClass（具体类）</strong>：实现了 <code>AbstractClass</code> 的抽象方法，完成算法的各个步骤。</li>
</ul>
</li>
<li><p>优缺点？</p>
<ul>
<li>优点：<ul>
<li><strong>复用代码</strong>：将算法的公共部分放在父类，减少了代码重复。</li>
<li><strong>灵活扩展</strong>：子类可以通过实现不同的具体步骤来扩展算法，保持了代码的灵活性。</li>
<li><strong>控制流程</strong>：父类通过定义模板方法控制整体流程，保证框架的稳定性。</li>
</ul>
</li>
<li>缺点：<ul>
<li><strong>增加复杂性</strong>：引入了抽象类和子类，可能导致类的数量增加，增加了系统的复杂性。</li>
<li><strong>扩展困难</strong>：如果新增的步骤需要改变模板方法的结构，则可能需要修改父类，这违反了开闭原则。</li>
</ul>
</li>
</ul>
</li>
<li><p>使用场景？</p>
<ul>
<li><strong>固定流程</strong>：某些算法流程是固定的，但其中某些步骤是可变的，可以通过子类实现不同的细节。</li>
<li><strong>代码复用</strong>：当多个类中存在相同的逻辑，但部分步骤不同，可以通过模板方法模式复用代码，减少重复。</li>
<li><strong>框架设计</strong>：在框架设计中，模板方法模式可以定义流程，用户通过继承并实现具体步骤来扩展功能。</li>
</ul>
</li>
<li><p>代码实现？</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 1. 抽象类，定义算法框架</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">Game</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 模板方法，定义了游戏的流程</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title">play</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        start();</span><br><span class="line">        playGame();</span><br><span class="line">        end();</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 固定步骤</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">start</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;Game started.&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 抽象方法，子类实现</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title">playGame</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 固定步骤</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">end</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;Game ended.&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 2. 具体类，实现不同的步骤</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Football</span> <span class="keyword">extends</span> <span class="title">Game</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">playGame</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;Playing Football.&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Basketball</span> <span class="keyword">extends</span> <span class="title">Game</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">playGame</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;Playing Basketball.&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 3. 客户端代码</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Client</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Game football = <span class="keyword">new</span> Football();</span><br><span class="line">        football.play();  <span class="comment">// 按照模板方法执行游戏流程</span></span><br><span class="line"></span><br><span class="line">        Game basketball = <span class="keyword">new</span> Basketball();</span><br><span class="line">        basketball.play();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 输出：</span></span><br><span class="line">Game started.</span><br><span class="line">Playing Football.</span><br><span class="line">Game ended.</span><br><span class="line">Game started.</span><br><span class="line">Playing Basketball.</span><br><span class="line">Game ended.</span><br></pre></td></tr></table></figure></li>
<li><p>JDK中有哪些地方使用了该模式？</p>
<ul>
<li><strong><code>java.util.AbstractList</code></strong> 和 **<code>java.util.AbstractSet</code>**：这些类使用了模板方法模式，在其中定义了某些通用的集合操作，而子类只需实现少量的具体方法。例如，在 <code>AbstractList</code> 中，<code>get()</code> 是抽象的，由子类实现，而 <code>add()</code>、<code>remove()</code> 等方法则是固定的。</li>
<li>**<code>java.io.InputStream</code> 和 <code>java.io.OutputStream</code>**：这些流类中，<code>read()</code> 和 <code>write()</code> 是模板方法的一种实现，具体的读取和写入操作由子类实现。</li>
</ul>
</li>
<li><p>Spring有哪些地方使用了该模式？Spring 提供了一些模板类，如 **<code>JdbcTemplate</code><strong>、</strong><code>RestTemplate</code>**，这些类封装了常见操作的流程，开发者只需定义具体的回调操作</p>
<p><strong><code>JdbcTemplate</code></strong> 和其他类似的模板类：Spring 提供了 <code>JdbcTemplate</code>、<code>RestTemplate</code>、<code>JmsTemplate</code> 等类，这些类通过模板方法封装了操作的通用流程。开发者只需提供特定的操作实现，如 SQL 查询、HTTP 请求等。例如，在 <code>JdbcTemplate</code> 中，SQL 执行的流程是固定的，开发者只需要通过回调函数提供具体的 SQL 执行逻辑。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">jdbcTemplate.query(<span class="string">&quot;SELECT * FROM users&quot;</span>, <span class="keyword">new</span> RowMapper&lt;User&gt;() &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> User <span class="title">mapRow</span><span class="params">(ResultSet rs, <span class="keyword">int</span> rowNum)</span> <span class="keyword">throws</span> SQLException </span>&#123;</span><br><span class="line">        User user = <span class="keyword">new</span> User();</span><br><span class="line">        user.setId(rs.getInt(<span class="string">&quot;id&quot;</span>));</span><br><span class="line">        user.setName(rs.getString(<span class="string">&quot;name&quot;</span>));</span><br><span class="line">        <span class="keyword">return</span> user;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>

<p>**<code>AbstractApplicationContext</code>**：在 Spring 的 <code>AbstractApplicationContext</code> 中，<code>refresh()</code> 方法是一个典型的模板方法，定义了启动 Spring 容器的整个流程。子类可以通过扩展某些步骤来实现不同的初始化逻辑。</p>
<p>**<code>AbstractPlatformTransactionManager</code>**：Spring 中的事务管理器类使用了模板方法模式，定义了事务的基本处理流程，具体的事务处理逻辑由子类实现，如 <code>DataSourceTransactionManager</code> 和 <code>JpaTransactionManager</code>。</p>
</li>
</ol>
<h4 id="问：策略模式？"><a href="#问：策略模式？" class="headerlink" title="问：策略模式？"></a>问：策略模式？</h4><ol>
<li><p>什么是策略模式？</p>
<ul>
<li><strong>策略模式</strong>（Strategy Pattern）定义了一系列算法，并将每种算法封装在独立的类中，使它们可以互相替换。策略模式允许客户端动态地选择不同的算法，避免使用条件语句来选择算法，从而实现算法的独立扩展和替换。</li>
</ul>
</li>
<li><p>模式中有哪些角色？</p>
<ul>
<li><strong>Context（上下文）</strong>：负责与客户端交互，并维护一个对策略对象的引用。</li>
<li><strong>Strategy（策略接口）</strong>：定义算法的通用接口。</li>
<li><strong>ConcreteStrategy（具体策略类）</strong>：实现具体的算法。</li>
</ul>
</li>
<li><p>优缺点？</p>
<ul>
<li>优点：<ul>
<li><strong>算法的独立性</strong>：不同的算法封装在独立的类中，易于理解和维护。</li>
<li><strong>扩展性好</strong>：增加新的算法时，只需要添加新的策略类，而不影响已有的代码。</li>
<li><strong>避免条件判断</strong>：通过使用策略类来代替多重条件或 <code>if-else</code> 语句，代码结构更加清晰。</li>
</ul>
</li>
<li>缺点：<ul>
<li><strong>类的数量增加</strong>：每个策略都需要定义为一个类，类的数量会增加。</li>
<li><strong>客户端必须了解所有策略</strong>：客户端必须知道有哪些可用的策略，并选择合适的策略。</li>
</ul>
</li>
</ul>
</li>
<li><p>使用场景？</p>
<ul>
<li><strong>多个算法可以互相替换</strong>：例如，在支付系统中，用户可以选择不同的支付方式（如微信、支付宝、信用卡等），这些支付方式都是策略模式的具体实现。</li>
<li><strong>避免多个条件判断</strong>：在某些情况下，系统中存在大量的条件语句，选择不同的算法时可以使用策略模式。</li>
<li><strong>需要动态地选择算法</strong>：策略模式允许在运行时根据条件动态地选择不同的算法。</li>
</ul>
</li>
<li><p>代码实现？</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 1. 策略接口</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">PaymentStrategy</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">pay</span><span class="params">(<span class="keyword">int</span> amount)</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 2. 具体策略类</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">CreditCardPayment</span> <span class="keyword">implements</span> <span class="title">PaymentStrategy</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> String cardNumber;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">CreditCardPayment</span><span class="params">(String cardNumber)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.cardNumber = cardNumber;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">pay</span><span class="params">(<span class="keyword">int</span> amount)</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;Paid &quot;</span> + amount + <span class="string">&quot; using Credit Card: &quot;</span> + cardNumber);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">PayPalPayment</span> <span class="keyword">implements</span> <span class="title">PaymentStrategy</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> String email;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">PayPalPayment</span><span class="params">(String email)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.email = email;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">pay</span><span class="params">(<span class="keyword">int</span> amount)</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;Paid &quot;</span> + amount + <span class="string">&quot; using PayPal: &quot;</span> + email);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 3. Context 类</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">PaymentContext</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> PaymentStrategy strategy;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">PaymentContext</span><span class="params">(PaymentStrategy strategy)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.strategy = strategy;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setPaymentStrategy</span><span class="params">(PaymentStrategy strategy)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.strategy = strategy;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">payAmount</span><span class="params">(<span class="keyword">int</span> amount)</span> </span>&#123;</span><br><span class="line">        strategy.pay(amount);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 4. 客户端代码</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Client</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        PaymentContext context = <span class="keyword">new</span> PaymentContext(<span class="keyword">new</span> CreditCardPayment(<span class="string">&quot;1234-5678-9012-3456&quot;</span>));</span><br><span class="line">        context.payAmount(<span class="number">100</span>);  <span class="comment">// 使用信用卡支付</span></span><br><span class="line"></span><br><span class="line">        context.setPaymentStrategy(<span class="keyword">new</span> PayPalPayment(<span class="string">&quot;user@example.com&quot;</span>));</span><br><span class="line">        context.payAmount(<span class="number">200</span>);  <span class="comment">// 使用 PayPal 支付</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 输出：</span></span><br><span class="line">Paid <span class="number">100</span> using Credit Card: <span class="number">1234</span>-<span class="number">5678</span>-<span class="number">9012</span>-<span class="number">3456</span></span><br><span class="line">Paid <span class="number">200</span> using PayPal: user<span class="meta">@example</span>.com</span><br></pre></td></tr></table></figure></li>
<li><p>JDK中有哪些地方使用了该模式？</p>
<p>**<code>java.util.Comparator</code>**：<code>Comparator</code> 接口就是策略模式的一个典型例子。它允许用户定义不同的排序策略，并且可以在 <code>Collections.sort</code> 等方法中使用不同的 <code>Comparator</code> 实现。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Comparator&lt;String&gt; byLength = (s1, s2) -&gt; Integer.compare(s1.length(), s2.length());</span><br><span class="line">List&lt;String&gt; list = Arrays.asList(<span class="string">&quot;apple&quot;</span>, <span class="string">&quot;banana&quot;</span>, <span class="string">&quot;cherry&quot;</span>);</span><br><span class="line">Collections.sort(list, byLength);</span><br></pre></td></tr></table></figure>

<p>**<code>javax.servlet.http.HttpServlet</code>**：<code>HttpServlet</code> 的 <code>doGet</code>、<code>doPost</code> 等方法实现了不同的 HTTP 请求方式处理策略。</p>
</li>
<li><p>Spring有哪些地方使用了该模式？</p>
<ul>
<li>**<code>Spring</code> 的 <code>ConversionService</code>**：Spring 的类型转换服务是策略模式的典型应用。<code>ConversionService</code> 定义了通用的接口，可以使用不同的策略来执行类型转换。Spring 提供了不同的 <code>Converter</code> 实现，用于在不同类型之间进行转换，而开发者也可以自己定义新的 <code>Converter</code>。</li>
<li><strong>Spring 的事务管理</strong>：Spring 的事务管理使用策略模式定义了不同的事务传播行为（如 <code>REQUIRED</code>、<code>REQUIRES_NEW</code>、<code>SUPPORTS</code> 等），通过 <code>@Transactional</code> 注解或编程方式，用户可以选择合适的事务策略。**<code>TransactionManagement</code>**：Spring 的事务管理器允许配置不同的事务策略，如编程式事务和声明式事务。这也是策略模式的应用，通过设置不同的事务策略，用户可以灵活选择事务的管理方式。</li>
<li><strong><code>BeanFactory</code> 的后置处理器</strong>：当 Spring 容器初始化时，<code>BeanFactoryPostProcessor</code> 和 <code>BeanPostProcessor</code> 可以定义不同的处理策略，来在 Bean 创建的不同生命周期中定制处理逻辑。Spring 的 IOC 容器中使用了策略模式来决定如何创建和管理 Beans。<code>BeanFactory</code> 允许通过不同的策略（例如单例、原型模式）来管理 Bean 的生命周期。</li>
<li><strong><code>Resource</code> 接口</strong>：<code>Resource</code> 是 Spring 用来抽象文件访问的接口，具体的实现包括 <code>ClassPathResource</code>、<code>FileSystemResource</code> 等。这些不同的资源访问方式可以通过策略模式轻松替换。</li>
<li><strong><code>Cache</code> 策略</strong>：Spring 的缓存抽象层也采用了策略模式，支持使用不同的缓存实现（如 <code>EhCache</code>、<code>Redis</code>、<code>Guava</code>），用户可以根据需求选择不同的缓存策略。</li>
</ul>
</li>
</ol>
<h4 id="问：责任链模式？"><a href="#问：责任链模式？" class="headerlink" title="问：责任链模式？"></a>问：责任链模式？</h4><ol>
<li><p>什么是责任链模式？</p>
<ul>
<li><strong>责任链模式</strong>（Chain of Responsibility Pattern）允许多个对象依次处理请求，直到其中一个对象处理该请求为止。通过这种方式，请求发送者无需指定处理者，处理者可以动态组合，灵活改变处理流程。</li>
</ul>
</li>
<li><p>模式中有哪些角色？</p>
<ul>
<li><strong>Handler（抽象处理者）</strong>：定义处理请求的接口，包含处理请求和将请求传递给下一个处理者的逻辑。</li>
<li><strong>ConcreteHandler（具体处理者）</strong>：具体处理请求的类，继承 Handler。如果自己能处理请求就处理，否则将请求传递给下一个处理者。</li>
<li><strong>Client（客户端）</strong>：向责任链的第一个处理者提交请求，不需要关心具体由哪个处理者处理。</li>
</ul>
</li>
<li><p>优缺点？</p>
<ul>
<li>优点：<ul>
<li><strong>解耦请求发送者和处理者</strong>：请求发送者不需要知道请求是由哪个处理者处理的，处理者之间的逻辑变得清晰。</li>
<li><strong>灵活性高</strong>：可以灵活地组合和修改责任链中的处理者。</li>
<li><strong>可扩展性强</strong>：通过添加新的处理者，可以扩展责任链而无需修改已有代码。</li>
</ul>
</li>
<li>缺点：<ul>
<li><strong>性能问题</strong>：如果链条过长，处理请求时可能会导致性能问题，因为每个请求都需要遍历链条上的每个处理者。</li>
<li><strong>调试困难</strong>：由于请求是沿着链条传递的，可能很难确定是哪一个处理者处理了请求。</li>
</ul>
</li>
</ul>
</li>
<li><p>使用场景？</p>
<ul>
<li><strong>多个对象可以处理同一请求</strong>：但只有一个对象处理该请求时使用责任链模式。</li>
<li><strong>动态指定处理者</strong>：当你希望在运行时动态指定处理者的顺序时，可以使用责任链模式。</li>
<li><strong>需要对请求进行预处理和后处理</strong>：如在表单验证、权限校验、日志记录等场景中，责任链模式比较适用。</li>
</ul>
</li>
<li><p>代码实现？</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 1. 抽象处理者</span></span><br><span class="line"><span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">Handler</span> </span>&#123;</span><br><span class="line">    <span class="keyword">protected</span> Handler nextHandler;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setNextHandler</span><span class="params">(Handler nextHandler)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.nextHandler = nextHandler;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title">handleRequest</span><span class="params">(String request)</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 2. 具体处理者</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ConcreteHandlerA</span> <span class="keyword">extends</span> <span class="title">Handler</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">handleRequest</span><span class="params">(String request)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (request.equals(<span class="string">&quot;A&quot;</span>)) &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;ConcreteHandlerA handled the request.&quot;</span>);</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (nextHandler != <span class="keyword">null</span>) &#123;</span><br><span class="line">            nextHandler.handleRequest(request);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ConcreteHandlerB</span> <span class="keyword">extends</span> <span class="title">Handler</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">handleRequest</span><span class="params">(String request)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (request.equals(<span class="string">&quot;B&quot;</span>)) &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;ConcreteHandlerB handled the request.&quot;</span>);</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (nextHandler != <span class="keyword">null</span>) &#123;</span><br><span class="line">            nextHandler.handleRequest(request);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 3. 客户端代码</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Client</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 创建处理者链</span></span><br><span class="line">        Handler handlerA = <span class="keyword">new</span> ConcreteHandlerA();</span><br><span class="line">        Handler handlerB = <span class="keyword">new</span> ConcreteHandlerB();</span><br><span class="line">        handlerA.setNextHandler(handlerB);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 提交请求</span></span><br><span class="line">        handlerA.handleRequest(<span class="string">&quot;A&quot;</span>); <span class="comment">// ConcreteHandlerA handled the request.</span></span><br><span class="line">        handlerA.handleRequest(<span class="string">&quot;B&quot;</span>); <span class="comment">// ConcreteHandlerB handled the request.</span></span><br><span class="line">        handlerA.handleRequest(<span class="string">&quot;C&quot;</span>); <span class="comment">// 没有处理者处理该请求</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 输出：</span></span><br><span class="line">ConcreteHandlerA handled the request.</span><br><span class="line">ConcreteHandlerB handled the request.</span><br></pre></td></tr></table></figure></li>
<li><p>JDK中有哪些地方使用了该模式？</p>
<p>**<code>java.util.logging.Logger</code>**：Java 的日志框架中使用了责任链模式。<code>Logger</code> 可以将日志记录请求传递给父 <code>Logger</code>，直到找到可以处理该请求的 <code>Logger</code>。</p>
<figure class="highlight reasonml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">javaCopy codeLogger logger = <span class="module-access"><span class="module"><span class="identifier">Logger</span>.</span></span>get<span class="constructor">Logger(<span class="string">&quot;com.example&quot;</span>)</span>;</span><br><span class="line">logger.set<span class="constructor">Level(Level.INFO)</span>;</span><br><span class="line">Logger parentLogger = <span class="module-access"><span class="module"><span class="identifier">Logger</span>.</span></span>get<span class="constructor">Logger(<span class="string">&quot;com&quot;</span>)</span>;</span><br><span class="line">parentLogger.set<span class="constructor">Level(Level.WARNING)</span>;</span><br></pre></td></tr></table></figure>

<p>**<code>javax.servlet.Filter</code>**：<code>Filter</code> 是 Servlet 规范中的一个接口，用于对 HTTP 请求进行预处理或后处理。<code>Filter</code> 形成一个责任链，依次处理请求，处理完一个 <code>Filter</code> 后请求会被传递给下一个 <code>Filter</code>。</p>
</li>
<li><p>Spring有哪些地方使用了该模式？</p>
<p>**<code>HandlerInterceptor</code>**：Spring MVC 中的 <code>HandlerInterceptor</code> 也是一个责任链模式的实现。多个拦截器可以依次对请求进行处理，类似于 Servlet 的过滤器链。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyInterceptor</span> <span class="keyword">implements</span> <span class="title">HandlerInterceptor</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">preHandle</span><span class="params">(HttpServletRequest request, HttpServletResponse response, Object handler)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 在处理请求之前进行拦截</span></span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>; <span class="comment">// 返回 true 表示继续往下传递请求</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>**<code>Filter</code>**：Spring 的 Web 层基于 Servlet 规范，也使用了过滤器链来处理 HTTP 请求。例如，Spring Security 的过滤器链就应用了责任链模式，处理认证、授权、访问控制等。</p>
<p>**<code>TransactionManager</code>**：Spring 的事务管理机制也采用了责任链模式。Spring 支持多种事务管理方式（如 <code>DataSourceTransactionManager</code>、<code>JpaTransactionManager</code> 等），每种事务管理器都可以处理不同的事务，并且可以动态地选择最合适的事务管理器。</p>
</li>
</ol>
<h4 id="问：装饰者模式？"><a href="#问：装饰者模式？" class="headerlink" title="问：装饰者模式？"></a>问：装饰者模式？</h4><ol>
<li><p>什么是装饰者模式？</p>
<ul>
<li><strong>装饰者模式</strong>（Decorator Pattern）允许动态地给对象添加新的功能，而不会影响其他同类对象的功能。装饰者模式通过将功能分层次地添加给对象，比继承更灵活，也更符合开闭原则（对扩展开放，对修改封闭）。</li>
</ul>
</li>
<li><p>模式中有哪些角色？</p>
<ul>
<li><p><strong>Component（抽象组件）</strong>：定义对象的接口，可以被动态添加职责。</p>
<p><strong>ConcreteComponent（具体组件）</strong>：被装饰的原始对象，装饰者通过此类进行功能扩展。</p>
<p><strong>Decorator（抽象装饰者）</strong>：持有组件对象的引用，并且实现与 <code>Component</code> 相同的接口，目的是对组件对象进行装饰。</p>
<p><strong>ConcreteDecorator（具体装饰者）</strong>：通过继承装饰者类，向组件添加职责（即扩展功能）。</p>
</li>
</ul>
</li>
<li><p>优缺点？</p>
<ul>
<li>优点：<ul>
<li><p><strong>扩展性强</strong>：可以动态地给对象增加新的功能，不需要修改原始类的代码。</p>
<p><strong>灵活组合</strong>：通过使用不同的装饰者，能自由组合对象的功能。</p>
<p><strong>遵循开闭原则</strong>：不修改已有的代码，通过装饰者类来扩展对象的功能。</p>
</li>
</ul>
</li>
<li>缺点：<ul>
<li><p><strong>增加复杂性</strong>：使用装饰者模式会导致系统中类的数量增加，且增加层次结构，调试困难。</p>
<p><strong>比继承开销大</strong>：由于使用组合和多次包装，可能在性能上比继承略差。</p>
</li>
</ul>
</li>
</ul>
</li>
<li><p>使用场景？</p>
<ul>
<li><p><strong>需要在不修改现有代码的情况下扩展类的功能</strong>。</p>
<p><strong>需要动态地为对象添加功能，且可以随时撤销这些功能</strong>。</p>
<p><strong>需要通过不同的组合方式，实现功能的叠加</strong>，例如输入输出流的处理。</p>
</li>
</ul>
</li>
<li><p>代码实现？</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 1. 抽象组件</span></span><br><span class="line"><span class="class"><span class="keyword">interface</span> <span class="title">Component</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">operation</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 2. 具体组件</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ConcreteComponent</span> <span class="keyword">implements</span> <span class="title">Component</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">operation</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;ConcreteComponent: 基本操作&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 3. 抽象装饰者</span></span><br><span class="line"><span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">Decorator</span> <span class="keyword">implements</span> <span class="title">Component</span> </span>&#123;</span><br><span class="line">    <span class="keyword">protected</span> Component component;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Decorator</span><span class="params">(Component component)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.component = component;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">operation</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        component.operation();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 4. 具体装饰者 A</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ConcreteDecoratorA</span> <span class="keyword">extends</span> <span class="title">Decorator</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">ConcreteDecoratorA</span><span class="params">(Component component)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>(component);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">operation</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>.operation();</span><br><span class="line">        System.out.println(<span class="string">&quot;ConcreteDecoratorA: 添加额外功能 A&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 5. 具体装饰者 B</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ConcreteDecoratorB</span> <span class="keyword">extends</span> <span class="title">Decorator</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">ConcreteDecoratorB</span><span class="params">(Component component)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>(component);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">operation</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>.operation();</span><br><span class="line">        System.out.println(<span class="string">&quot;ConcreteDecoratorB: 添加额外功能 B&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 6. 客户端代码</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Client</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 原始对象</span></span><br><span class="line">        Component component = <span class="keyword">new</span> ConcreteComponent();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 装饰对象 A</span></span><br><span class="line">        Component decoratedA = <span class="keyword">new</span> ConcreteDecoratorA(component);</span><br><span class="line">        decoratedA.operation();</span><br><span class="line">        <span class="comment">// Output: ConcreteComponent: 基本操作</span></span><br><span class="line">        <span class="comment">//         ConcreteDecoratorA: 添加额外功能 A</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// 装饰对象 A 和 B</span></span><br><span class="line">        Component decoratedB = <span class="keyword">new</span> ConcreteDecoratorB(decoratedA);</span><br><span class="line">        decoratedB.operation();</span><br><span class="line">        <span class="comment">// Output: ConcreteComponent: 基本操作</span></span><br><span class="line">        <span class="comment">//         ConcreteDecoratorA: 添加额外功能 A</span></span><br><span class="line">        <span class="comment">//         ConcreteDecoratorB: 添加额外功能 B</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li><p>JDK中有哪些地方使用了该模式？</p>
<p>**<code>java.io.InputStream</code>、<code>OutputStream</code>、<code>Reader</code>、<code>Writer</code>**：Java IO 库中大量使用了装饰者模式。以 <code>BufferedInputStream</code> 为例，它扩展了 <code>InputStream</code> 的功能，通过缓冲机制提高了读写效率，但它依然是 <code>InputStream</code> 的一个子类，保持原有的接口。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">InputStream inputStream = <span class="keyword">new</span> FileInputStream(<span class="string">&quot;file.txt&quot;</span>);</span><br><span class="line">InputStream buffered = <span class="keyword">new</span> BufferedInputStream(inputStream);</span><br></pre></td></tr></table></figure>

<p>**<code>Collections.unmodifiableList</code>、<code>Collections.synchronizedList</code>**：这些方法通过装饰者模式为原始 <code>List</code> 添加了线程安全或不可修改的功能。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">List&lt;String&gt; list = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">List&lt;String&gt; synchronizedList = Collections.synchronizedList(list);</span><br></pre></td></tr></table></figure></li>
<li><p>Spring有哪些地方使用了该模式？</p>
<p>**<code>Transaction Management</code>**：Spring 的事务管理机制在方法级别上实现了装饰者模式。Spring 的 <code>TransactionProxy</code> 为方法添加了事务功能，而不需要改变原有方法的实现。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Transactional</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">doSomething</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 方法被装饰为带事务支持</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>**<code>BeanPostProcessor</code>**：Spring 中的 <code>BeanPostProcessor</code> 可以在初始化之前或之后对 Bean 进行装饰。<code>BeanPostProcessor</code> 是对 Bean 的装饰器，可以在 Spring 容器初始化 Bean 时，动态地为其添加行为。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">CustomBeanPostProcessor</span> <span class="keyword">implements</span> <span class="title">BeanPostProcessor</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Object <span class="title">postProcessBeforeInitialization</span><span class="params">(Object bean, String beanName)</span> <span class="keyword">throws</span> BeansException </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;Before Initialization: &quot;</span> + beanName);</span><br><span class="line">        <span class="keyword">return</span> bean; <span class="comment">// 可以在这里修改 bean</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Object <span class="title">postProcessAfterInitialization</span><span class="params">(Object bean, String beanName)</span> <span class="keyword">throws</span> BeansException </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;After Initialization: &quot;</span> + beanName);</span><br><span class="line">        <span class="keyword">return</span> bean; <span class="comment">// 可以在这里修改 bean</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong><code>HttpServletRequestWrapper</code></strong> 和 **<code>HttpServletResponseWrapper</code>**：Spring Web 中对 HTTP 请求和响应对象进行了装饰。通过这些装饰类，开发者可以在不修改原有 <code>HttpServletRequest</code> 和 <code>HttpServletResponse</code> 对象的基础上添加自定义功能。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">HttpServletRequest requestWrapper = <span class="keyword">new</span> HttpServletRequestWrapper(request) &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getParameter</span><span class="params">(String name)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">super</span>.getParameter(name).toUpperCase();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></li>
</ol>
<h4 id="问：设计模式中常见原则知道一些吗？面向对象设计的五大基本原则？"><a href="#问：设计模式中常见原则知道一些吗？面向对象设计的五大基本原则？" class="headerlink" title="问：设计模式中常见原则知道一些吗？面向对象设计的五大基本原则？"></a>问：设计模式中常见原则知道一些吗？面向对象设计的五大基本原则？</h4><ul>
<li><p>什么是面向对象设计的五大基本原则？简称<strong>SOLID</strong>原则</p>
<ol>
<li><p><strong>单一职责原则</strong>（Single Responsibility Principle，SRP）</p>
<p><strong>定义</strong>：一个类应该只有一个引起它变化的原因，换句话说，<strong>一个类只应该有一个职责</strong>。</p>
<p><strong>目的</strong>：将不同的职责分离到不同的类中，避免一个类承担过多的责任，从而提高类的可维护性和可读性。<strong>如果一个类有多个职责，那么其中一个职责的变更可能会影响到其他职责的功能</strong>。</p>
<p><strong>示例</strong>：可以将验证用户的功能拆分到另一个类中，从而遵循单一职责原则。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">UserService</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">addUser</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 负责添加用户</span></span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">validateUser</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 负责验证用户</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li><p><strong>开闭原则</strong>（Open/Closed Principle，OCP）</p>
<p><strong>定义</strong>：软件实体（类、模块、函数等）<strong>应该对扩展开放，对修改关闭</strong>，Open for extension，Closed for modification。</p>
<p><strong>目的</strong>：提高系统的可扩展性，降低由于代码修改而引入的风险。通过扩展（比如继承、实现接口等）来增加新功能，而不是通过修改已有代码。从而保证可维护、可扩展、可复用和高灵活性。开发人员应该对程序中呈现出频繁变化的部分做出抽象。在实际开发中，将抽象层和实现层分离，不修改抽象，只处理实现。</p>
<p><strong>示例</strong>：通过新增<code>Shape</code>的实现类可以扩展功能，而不需要修改已有的<code>Shape</code>接口和实现类。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">interface</span> <span class="title">Shape</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">draw</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Circle</span> <span class="keyword">implements</span> <span class="title">Shape</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">draw</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 绘制圆形</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Rectangle</span> <span class="keyword">implements</span> <span class="title">Shape</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">draw</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 绘制矩形</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li><p><strong>里氏替换原则</strong>（Liskov Substitution Principle，LSP）</p>
<p><strong>定义</strong>：<strong>子类必须能够替换其基类</strong>，且子类替换基类后，程序的行为不会改变。</p>
<p><strong>目的</strong>：保证继承的正确性，避免继承关系中子类对基类的修改导致系统功能的异常或崩溃。</p>
<p><strong>示例</strong>：这里鸵鸟（<code>Ostrich</code>）类违背了里氏替换原则，因为它不能替代鸟（<code>Bird</code>）类。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Bird</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">fly</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 鸟会飞</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Ostrich</span> <span class="keyword">extends</span> <span class="title">Bird</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">fly</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> UnsupportedOperationException(<span class="string">&quot;鸵鸟不会飞&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li><p><strong>接口隔离原则</strong>（Interface Segregation Principle，ISP）</p>
<p><strong>定义</strong>：客户端<strong>不应该被迫依赖它不使用的方法</strong>，接口应该尽量细化，并为不同的类提供特定的接口。</p>
<p><strong>目的</strong>：避免接口臃肿，客户端只需要关心它需要的方法，减少不必要的依赖。</p>
<p><strong>示例</strong>：这里接口<code>Printer</code>不符合接口隔离原则，可以将其拆分为更小的接口。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">interface</span> <span class="title">Printer</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">print</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">scan</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">fax</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">SimplePrinter</span> <span class="keyword">implements</span> <span class="title">Printer</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">print</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 打印功能</span></span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">scan</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 没有扫描功能，但必须实现这个方法</span></span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">fax</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 没有传真功能，但必须实现这个方法</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li><p><strong>依赖倒置原则</strong>（Dependency Inversion Principle，DIP）</p>
<p><strong>定义</strong>：<strong>高层模块不应该依赖于低层模块，二者都应该依赖于抽象</strong>；抽象不应该依赖于细节，细节应该依赖于抽象。</p>
<p><strong>目的</strong>：减少类之间的耦合，使得系统更容易维护和扩展。通过依赖于抽象（接口或抽象类）而非具体实现，可以提高系统的灵活性。</p>
<p><strong>示例</strong>：<code>Switch</code>类依赖于具体的<code>Light</code>类，可以通过引入<code>Light</code>接口来遵循依赖倒置原则。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Light</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">turnOn</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 打开灯</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Switch</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> Light light;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Switch</span><span class="params">(Light light)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.light = light;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">operate</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        light.turnOn();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ol>
</li>
<li><p><strong>迪米特法则</strong>：<strong>也叫最少知识原则（Principle of Least Knowledge），一个类应当对其它类尽可能少去了解</strong>。其实就是类尽量不把与别的类的交互放在内部函数中，尽量放在第三方类处理；类尽量将成员变量和方法设为私有。从而降低类之间耦合，提高复用。</p>
<ul>
<li><p>迪米特法则规定：</p>
<ul>
<li>一个对象应该只与直接相关的对象通信，不要与陌生对象发生直接联系。</li>
<li>尽量避免通过一个对象去访问另一个对象的内部细节（通过链式调用等）。</li>
</ul>
</li>
<li><p>在迪米特法则中，朋友对象是指：</p>
<ol>
<li>当前对象本身。</li>
<li>当前对象的成员变量。</li>
<li>当前对象创建的对象。</li>
<li>当前对象的方法参数。</li>
</ol>
</li>
<li><p>为什么使用迪米特法则？</p>
<ul>
<li>迪米特法则的主要目的是<strong>降低系统的耦合性</strong>，提高系统的<strong>可维护性</strong>和<strong>可扩展性</strong>。通过减少对象之间的直接依赖，可以减少由于对象的内部变化而导致的系统变更的范围。</li>
</ul>
</li>
<li><p>示例：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Engine</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">start</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;Engine started&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Car</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> Engine engine;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Car</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.engine = <span class="keyword">new</span> Engine();</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> Engine <span class="title">getEngine</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> engine;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Driver</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">drive</span><span class="params">(Car car)</span> </span>&#123;</span><br><span class="line">        car.getEngine().start();  <span class="comment">// 违反迪米特法则，Driver直接访问了Car的Engine</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>  在这个例子中，<code>Driver</code>类直接访问了<code>Car</code>的<code>Engine</code>对象，这违反了迪米特法则。如果将来<code>Car</code>类的内部实现发生了变化，比如<code>Engine</code>的结构发生改变，那么<code>Driver</code>类也可能需要相应修改。</p>
<p>  可以通过调整代码来遵循迪米特法则：</p>
  <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Car</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> Engine engine;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Car</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.engine = <span class="keyword">new</span> Engine();</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">startEngine</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        engine.start();  <span class="comment">// 提供一个方法来启动引擎</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Driver</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">drive</span><span class="params">(Car car)</span> </span>&#123;</span><br><span class="line">        car.startEngine();  <span class="comment">// 遵循迪米特法则，Driver只与Car通信</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>  在这个改进后的例子中，<code>Driver</code>类只与<code>Car</code>类通信，而不直接访问<code>Car</code>的内部细节（如<code>Engine</code>对象），从而遵循了迪米特法则。</p>
</li>
<li><p>迪米特法则有助于减少类之间的耦合，使得系统的维护和扩展变得更加容易。它提醒开发者要尽量避免对象之间复杂的依赖关系，通过降低对象之间的直接关联来提高代码的健壮性和可维护性。</p>
</li>
</ul>
</li>
</ul>
<h2 id="九-Java-8-新特性"><a href="#九-Java-8-新特性" class="headerlink" title="九. Java 8 新特性"></a>九. Java 8 新特性</h2><h4 id="问：java8有了解吗？"><a href="#问：java8有了解吗？" class="headerlink" title="问：java8有了解吗？"></a>问：java8有了解吗？</h4><ol>
<li><p><strong>Lambda表达式</strong>：提供了一种清晰简洁的方式来表示单方法接口（函数式接口）的实现。该特性使得 Java 更加适合函数式编程。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">List&lt;String&gt; names = Arrays.asList(<span class="string">&quot;John&quot;</span>, <span class="string">&quot;Jane&quot;</span>, <span class="string">&quot;Max&quot;</span>);</span><br><span class="line">names.forEach(name -&gt; System.out.println(name));</span><br></pre></td></tr></table></figure></li>
<li><p><strong>流 - Streams API</strong>：Streams 允许你以声明式的方式处理数据集合，使代码更具可读性和可维护性。它支持诸如 filter（过滤）、map（映射）、reduce（归约）等操作。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">List&lt;Integer&gt; numbers = Arrays.asList(<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>);</span><br><span class="line">List&lt;Integer&gt; evenNumbers = numbers.stream()</span><br><span class="line">                                   .filter(n -&gt; n % <span class="number">2</span> == <span class="number">0</span>)</span><br><span class="line">                                   .collect(Collectors.toList());</span><br></pre></td></tr></table></figure></li>
<li><p><strong>接口中的默认方法</strong>：Java 8 引入了默认方法，允许接口具有方法的实现。这样可以在不破坏现有代码的情况下更新 API。</p>
<p>示例：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">interface</span> <span class="title">Vehicle</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">default</span> <span class="keyword">void</span> <span class="title">honk</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;Honking&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li><p><strong>Optional 类</strong>：<code>Optional</code> 类用于避免 <code>null</code> 检查，防止 <code>NullPointerException</code>。它提供了一些方法来处理可能为空的值。</p>
<p>示例：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Optional&lt;String&gt; name = Optional.ofNullable(<span class="keyword">null</span>);</span><br><span class="line">System.out.println(name.orElse(<span class="string">&quot;Default Name&quot;</span>));</span><br></pre></td></tr></table></figure></li>
<li><p><strong>新的日期和时间 API（java.time 包）</strong>：Java 8 引入了一个更加直观且强大的日期和时间处理 API，解决了 <code>java.util.Date</code> 和 <code>java.util.Calendar</code> 的不足。</p>
<p>示例：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">LocalDate date = LocalDate.now();</span><br><span class="line">LocalTime time = LocalTime.now();</span><br></pre></td></tr></table></figure></li>
<li><p><strong>函数式接口</strong>：Java 8 引入了若干内置的函数式接口，如 <code>Predicate</code>、<code>Function</code>、<code>Supplier</code> 和 <code>Consumer</code>。</p>
<p>示例：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Predicate&lt;Integer&gt; isPositive = x -&gt; x &gt; <span class="number">0</span>;</span><br><span class="line">System.out.println(isPositive.test(<span class="number">5</span>));  <span class="comment">// 输出: true</span></span><br></pre></td></tr></table></figure></li>
</ol>
<p><a href="../2019091901.html" title="Title">Java8的新特性</a></p>
<h4 id="问：讲讲Lambda表达式？使用场景？优点？"><a href="#问：讲讲Lambda表达式？使用场景？优点？" class="headerlink" title="问：讲讲Lambda表达式？使用场景？优点？"></a>问：讲讲Lambda表达式？使用场景？优点？</h4><ol>
<li><p>Lambda 表达式是 Java 8 引入的一种简洁的函数式编程方式，允许你将行为（函数或方法）作为参数传递。Lambda 表达式通常用于替代匿名类，解决了Java无法传递代码段的问题，并使代码更加简洁、可读。它的语法如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">(parameters) -&gt; expression</span><br><span class="line">或者</span><br><span class="line">(parameters) -&gt; &#123; statements; &#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 示例：无参数</span></span><br><span class="line">() -&gt; System.out.println(<span class="string">&quot;Hello, Lambda!&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 示例：有参数</span></span><br><span class="line">(<span class="keyword">int</span> x, <span class="keyword">int</span> y) -&gt; x + y;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 示例：带代码块</span></span><br><span class="line">(<span class="keyword">int</span> x, <span class="keyword">int</span> y) -&gt; &#123;</span><br><span class="line">    <span class="keyword">int</span> sum = x + y;</span><br><span class="line">    <span class="keyword">return</span> sum;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></li>
<li><p>使用场景：</p>
<ol>
<li><p><strong>替代匿名类</strong>： Lambda 表达式可以用于简化实现单方法接口的匿名类，尤其是函数式接口的实现。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 传统方式：匿名类</span></span><br><span class="line">Runnable runnable = <span class="keyword">new</span> Runnable() &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;Running&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Lambda 表达式</span></span><br><span class="line">Runnable runnableLambda = () -&gt; System.out.println(<span class="string">&quot;Running&quot;</span>);</span><br></pre></td></tr></table></figure></li>
<li><p><strong>集合操作</strong>： 在使用集合类时，Lambda 表达式通常结合 <code>Stream</code> API 来进行过滤、排序和转换操作。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">List&lt;String&gt; names = Arrays.asList(<span class="string">&quot;John&quot;</span>, <span class="string">&quot;Jane&quot;</span>, <span class="string">&quot;Mike&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 使用 Lambda 表达式筛选名字长度大于 3 的元素</span></span><br><span class="line">List&lt;String&gt; filteredNames = names.stream()</span><br><span class="line">                                  .filter(name -&gt; name.length() &gt; <span class="number">3</span>)</span><br><span class="line">                                  .collect(Collectors.toList());</span><br></pre></td></tr></table></figure></li>
<li><p><strong>事件处理</strong>： 在 GUI 编程或其他基于事件的编程中，Lambda 表达式可以简化事件处理代码。例如，在 JavaFX 中设置按钮的点击事件：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Button button = <span class="keyword">new</span> Button(<span class="string">&quot;Click me&quot;</span>);</span><br><span class="line">button.setOnAction(e -&gt; System.out.println(<span class="string">&quot;Button clicked!&quot;</span>));</span><br></pre></td></tr></table></figure></li>
<li><p><strong>多线程编程</strong>： Lambda 表达式可以用于简化多线程编程中的 <code>Runnable</code> 和 <code>Callable</code> 的实现：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">new</span> Thread(() -&gt; System.out.println(<span class="string">&quot;Running in a thread&quot;</span>)).start();</span><br></pre></td></tr></table></figure></li>
</ol>
</li>
<li><p>优点：</p>
<ol>
<li><strong>简洁易读</strong>： Lambda 表达式消除了创建匿名类时的冗长代码，使代码更加简洁，减少了样板代码（如方法签名、类声明等）。</li>
<li><strong>更好的抽象能力</strong>： Lambda 表达式可以作为参数传递，允许程序更加灵活地定义和传递行为，促进代码重用和模块化设计。</li>
<li><strong>高效并行流处理</strong>： 结合 <code>Stream</code> API，Lambda 表达式能够简洁地表达集合操作，并可以轻松并行化数据处理任务。</li>
<li><strong>提高生产力</strong>： 简化了开发过程中的重复性工作，开发者可以专注于业务逻辑而不是编写样板代码。</li>
</ol>
</li>
<li><p>代码示例：</p>
<p>使用 Lambda 表达式处理集合</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">List&lt;String&gt; names = Arrays.asList(<span class="string">&quot;Alice&quot;</span>, <span class="string">&quot;Bob&quot;</span>, <span class="string">&quot;Charlie&quot;</span>, <span class="string">&quot;David&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 过滤名字长度大于3的元素</span></span><br><span class="line">names.stream()</span><br><span class="line">     .filter(name -&gt; name.length() &gt; <span class="number">3</span>)</span><br><span class="line">     .forEach(System.out::println);</span><br></pre></td></tr></table></figure>

<p>使用 Lambda 表达式创建线程</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">new</span> Thread(() -&gt; System.out.println(<span class="string">&quot;Thread running&quot;</span>)).start();</span><br></pre></td></tr></table></figure></li>
</ol>
<h4 id="问：谈谈流？和集合对比？"><a href="#问：谈谈流？和集合对比？" class="headerlink" title="问：谈谈流？和集合对比？"></a>问：谈谈流？和集合对比？</h4><p><code>Stream</code> 是 Java 8 中引入的一种用于处理集合数据的 API，允许对集合中的元素进行链式的操作，如过滤、排序、转换、聚合等。<code>Stream</code> 提供了一种声明式编程的方式来处理数据，简化了对集合的操作，同时支持并行处理，提高了性能。</p>
<p>核心特性：</p>
<ul>
<li><strong>不存储数据</strong>：<code>Stream</code> 本身不存储数据，而是从源（如集合、数组等）获取数据。</li>
<li><strong>惰性求值</strong>：<code>Stream</code> 的中间操作是惰性的，只有在终端操作时才会实际执行。</li>
<li><strong>函数式编程</strong>：<code>Stream</code> 提供了多个用于操作元素的函数式方法，如 <code>filter</code>、<code>map</code>、<code>reduce</code> 等。</li>
<li><strong>可并行处理</strong>：通过 <code>parallelStream()</code> 可以轻松实现并行处理。</li>
</ul>
<p>使用场景对比：</p>
<ul>
<li><strong>集合</strong>：适合需要频繁增删改查的数据操作场景，尤其是需要多次访问或操作集合中的元素时。</li>
<li><strong>流</strong>：适合对数据进行过滤、转换、聚合等操作，特别是数据处理链较复杂，且需要高性能并行处理时。</li>
</ul>
<p>流是为了在一些如需要进行复杂计算以及多核的场景下代替集合而设计的。集合的主要目的是为了存储和访问数据，而流则是主要用于描述对数据的计算。相较于集合，流采用了更高级的语言表达，流水线的结构可以减少遍历，自动的并行化流操作可以有效利用多核性能。</p>
<p>流的优点：</p>
<ol>
<li><strong>简洁性</strong>：流允许使用链式操作来处理集合中的元素，减少了样板代码，提升了可读性。</li>
<li><strong>函数式编程</strong>：流提供了对集合进行过滤、转换、聚合的函数式编程接口，支持声明式编程。</li>
<li><strong>并行处理</strong>：流的并行处理能力使得在多核环境下更容易提高性能。</li>
</ol>
<p>集合的优点</p>
<ol>
<li><strong>存储功能</strong>：集合类提供了持久的元素存储功能，可以随时添加或删除元素。</li>
<li><strong>可重复操作</strong>：集合可以多次遍历和修改，支持复杂的数据结构和操作。</li>
</ol>
<h4 id="问：default关键字-？"><a href="#问：default关键字-？" class="headerlink" title="问：default关键字 ？"></a>问：default关键字 ？</h4><p><code>default</code> 关键字在 Java 8 中被引入，用于为<strong>接口</strong>中的方法提供默认实现。它主要用于解决接口演变问题，使得在现有接口中添加新方法时，不必修改所有实现该接口的类。打破接口里面是只能有抽象方法，不能有任何方法的实现，接口里面也可以有方法的实现了。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">interface</span> <span class="title">MyInterface</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 默认方法</span></span><br><span class="line">    <span class="function"><span class="keyword">default</span> <span class="keyword">void</span> <span class="title">sayHello</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;Hello from MyInterface&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 抽象方法</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">abstractMethod</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyClass</span> <span class="keyword">implements</span> <span class="title">MyInterface</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">abstractMethod</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;Implementing abstract method&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 可以选择重写默认方法</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">sayHello</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;Hello from MyClass&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Main</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        MyClass myClass = <span class="keyword">new</span> MyClass();</span><br><span class="line">        myClass.sayHello();  <span class="comment">// 输出：Hello from MyClass</span></span><br><span class="line">        myClass.abstractMethod();  <span class="comment">// 输出：Implementing abstract method</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h4 id="问：新时间日期-APILocalDate-LocalTime-LocalDateTime-？对比旧时间日期"><a href="#问：新时间日期-APILocalDate-LocalTime-LocalDateTime-？对比旧时间日期" class="headerlink" title="问：新时间日期 APILocalDate | LocalTime | LocalDateTime ？对比旧时间日期"></a>问：新时间日期 APILocalDate | LocalTime | LocalDateTime ？对比旧时间日期</h4><p>相比旧的时间日期：</p>
<ul>
<li><strong>更清晰的 API 设计</strong>：之前使用的java.util.Date月份从0开始，我们一般会+1使用，很不方便。java.time.LocalDate提供了自然、简洁的方式来操作日期和时间。</li>
<li><strong>线程安全/不可变</strong>：java.util.Date和SimpleDateFormat都不是线程安全的，而LocalDate和LocalTime和最基本的String一样，是<strong>不变类型</strong>，<strong>不但线程安全，而且不能修改</strong>。</li>
<li><strong>支持日期和时间计算</strong>：新接口更好用的原因是考虑到了日期时间的操作，经常发生往前推或往后推几天的情况。用java.util.Date配合Calendar要写好多代码，而且一般的开发人员还不一定能写对。</li>
</ul>
<h4 id="问：JDK1-7与JDK1-8-ConcurrentHashMap对比-？"><a href="#问：JDK1-7与JDK1-8-ConcurrentHashMap对比-？" class="headerlink" title="问：JDK1.7与JDK1.8 ConcurrentHashMap对比 ？"></a>问：JDK1.7与JDK1.8 ConcurrentHashMap对比 ？</h4><ul>
<li>1.7采用segment的分段锁机制实现线程安全；1.8则摒弃了分段锁，采用CAS+Synchronized保证线程安全。</li>
<li>1.7使用了结构为<strong>ReentrantLock+Segment+HashEntry</strong>（数组），分段哈希表，每个段内部是一个链表；1.8则摒弃了分段锁，结构为<strong>synchronized+CAS+HashEntry</strong>（数组）+红黑树。内部结构使用了桶（Bucket）和树（Tree）结构，链表长度超过阈值后转化为红黑树。</li>
<li>查询时间复杂度从原来的遍历链表O（n），变成遍历红黑树O（logN），改进了性能。</li>
<li>1.8 HashMap数组+链表+红黑树来实现hashmap，当碰撞的元素个数大于8时 &amp; 总容量大于64，会有红黑树的引入。除了添加之后，效率都比链表高，1.8之后链表新进元素加到末尾。</li>
</ul>
<h4 id="问：JDK1-8使用synchronized来代替重入锁ReentrantLock-？"><a href="#问：JDK1-8使用synchronized来代替重入锁ReentrantLock-？" class="headerlink" title="问：JDK1.8使用synchronized来代替重入锁ReentrantLock ？"></a>问：JDK1.8使用synchronized来代替重入锁ReentrantLock ？</h4><p>红黑树的节点操作（插入、删除）使用 <code>synchronized</code> 来确保线程安全。在 JDK 1.8 中，<code>ConcurrentHashMap</code> 内部的桶（Bucket）是用 <code>synchronized</code> 进行同步的。每个桶是一个链表或红黑树，链表中的节点在插入或删除时使用 <code>synchronized</code> 来保证线程安全。当桶中的链表长度超过一定阈值（默认为 8），链表会被转换成红黑树。</p>
<p>为什么使用 <code>synchronized</code> 而不是 <code>ReentrantLock</code>？</p>
<ul>
<li><strong>锁粒度降低</strong>：synchronized是JVM内置的锁，相比ReentrantLock 更轻量，性能更高效，基于JVM的synchronized优化空间更大。</li>
<li>ReentrantLock有更多功能，如尝试锁、定时锁等，但对于ConcurrentHashMap并不需要。</li>
<li>在大数据量下，基于API的ReentrantLock会比基于JVM的内存压力开销更多的内存</li>
</ul>
<h2 id="十-Java-9-新特性"><a href="#十-Java-9-新特性" class="headerlink" title="十. Java 9 新特性"></a>十. Java 9 新特性</h2><h4 id="问：Java-9引入了哪些新特性？"><a href="#问：Java-9引入了哪些新特性？" class="headerlink" title="问：Java 9引入了哪些新特性？"></a>问：Java 9引入了哪些新特性？</h4><ul>
<li><p><strong>模块化系统（Project Jigsaw）</strong></p>
<ul>
<li><p><strong>模块系统</strong>：使得 Java 平台可以被拆分成多个模块。每个模块都可以定义自己的依赖关系，导出和隐藏自己的包。使得 Java 应用更加模块化和可维护。</p>
</li>
<li><p><strong>关键组件</strong>：<code>module-info.java</code> 文件是模块的描述文件，定义了模块的名称、导出的包以及需要的模块等。</p>
<p>示例：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">module</span> com.example.myapp &#123;</span><br><span class="line">    <span class="keyword">requires</span> java.sql;</span><br><span class="line">    <span class="keyword">exports</span> com.example.myapp.services;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
</li>
<li><p><strong>JShell：Java REPL</strong></p>
<ul>
<li><p><strong>JShell</strong>：Java 9 引入了一个新的命令行工具 JShell，作为 Java 的 REPL（Read-Eval-Print Loop）工具。它允许开发者快速测试 Java 代码片段，无需编写完整的程序。</p>
<p>示例：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> jshell</span></span><br><span class="line"><span class="meta">jshell&gt;</span><span class="bash"> int x = 5;</span></span><br><span class="line">x ==&gt; 5</span><br><span class="line"><span class="meta">jshell&gt;</span><span class="bash"> x + 10</span></span><br><span class="line"><span class="meta">$</span><span class="bash">1 ==&gt; 15</span></span><br></pre></td></tr></table></figure></li>
</ul>
</li>
<li><p><strong>增强的 Stream API</strong></p>
<ul>
<li><p><strong>新方法</strong>：对 <code>Stream</code> API 进行了增强，新增了一些方法，如 <code>takeWhile</code>, <code>dropWhile</code>, 和 <code>ofNullable</code>。</p>
<p>示例：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">List&lt;String&gt; list = Arrays.asList(<span class="string">&quot;apple&quot;</span>, <span class="string">&quot;banana&quot;</span>, <span class="string">&quot;cherry&quot;</span>, <span class="string">&quot;date&quot;</span>);</span><br><span class="line">list.stream()</span><br><span class="line">    .dropWhile(s -&gt; s.startsWith(<span class="string">&quot;a&quot;</span>))</span><br><span class="line">    .forEach(System.out::println); <span class="comment">// Outputs: banana, cherry, date</span></span><br></pre></td></tr></table></figure></li>
</ul>
</li>
<li><p><strong>改进的 Optional API</strong></p>
<ul>
<li><p><strong>新方法</strong>：<code>Optional</code> 类新增了 <code>ifPresentOrElse</code> 和 <code>or</code> 方法，用于更灵活地处理缺失值的情况。</p>
<p>示例：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Optional&lt;String&gt; optional = Optional.of(<span class="string">&quot;Hello&quot;</span>);</span><br><span class="line">optional.ifPresentOrElse(</span><br><span class="line">    value -&gt; System.out.println(<span class="string">&quot;Value: &quot;</span> + value),</span><br><span class="line">    () -&gt; System.out.println(<span class="string">&quot;No value present&quot;</span>)</span><br><span class="line">);</span><br></pre></td></tr></table></figure></li>
</ul>
</li>
<li><p><strong>私有方法的接口</strong></p>
<ul>
<li><p><strong>私有方法</strong>：Java 9 允许在接口中定义私有方法，以便于接口的默认方法和静态方法可以共享代码。</p>
</li>
<li><p>示例：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">interface</span> <span class="title">MyInterface</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">privateMethod</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="comment">// Implementation</span></span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">default</span> <span class="keyword">void</span> <span class="title">defaultMethod</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        privateMethod();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
</li>
<li><p><strong>改进的 @SuppressWarnings 注解</strong></p>
<ul>
<li><p><strong>参数化</strong>：可以在 <code>@SuppressWarnings</code> 注解中使用新的参数，以便更细粒度地控制警告的抑制。</p>
</li>
<li><p>示例：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@SuppressWarnings(&#123;&quot;unchecked&quot;, &quot;deprecation&quot;&#125;)</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">myMethod</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">// Code</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
</li>
<li><p><strong>堆外内存的改进</strong></p>
<ul>
<li><strong>改进的 <code>Unsafe</code> API</strong>：引入了新的 API 来更安全地操作堆外内存（Direct Memory），提供了对 <code>Unsafe</code> 的更加受限的访问方式。</li>
</ul>
</li>
<li><p><strong>改进的 java.util 包，集合的工厂方法</strong></p>
<ul>
<li><p><strong><code>List.of</code> 和 <code>Map.of</code> 方法</strong>：新增了简便的方法来创建不可变的集合，如 <code>List.of</code>, <code>Map.of</code>, 和 <code>Set.of</code>。</p>
<p>示例：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">List&lt;String&gt; list = List.of(<span class="string">&quot;a&quot;</span>, <span class="string">&quot;b&quot;</span>, <span class="string">&quot;c&quot;</span>);</span><br><span class="line">Map&lt;String, Integer&gt; map = Map.of(<span class="string">&quot;key1&quot;</span>, <span class="number">1</span>, <span class="string">&quot;key2&quot;</span>, <span class="number">2</span>);</span><br></pre></td></tr></table></figure></li>
</ul>
</li>
<li><p><strong>性能改进和 JDK 内部改进</strong></p>
<ul>
<li><strong>性能优化</strong>：包括对 JIT 编译器、垃圾回收和其他运行时性能的改进。</li>
<li><strong>内部 API 的访问控制</strong>：Java 9 引入了更严格的访问控制，限制了对 JDK 内部 API 的访问。</li>
</ul>
</li>
</ul>
<h4 id="问：模块化系统-？"><a href="#问：模块化系统-？" class="headerlink" title="问：模块化系统 ？"></a>问：模块化系统 ？</h4><p>模块是一个包的容器，Java 9 最大的变化之一是引入了模块系统（Jigsaw 项目），旨在改进代码的结构化和可维护性，主要通过 <code>module-info.java</code> 文件来实现模块化开发。</p>
<ul>
<li><p>每个模块都包含一个名为 <code>module-info.java</code> 的描述文件，定义了模块的名称、导出的包、需要的模块等。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">module</span> com.example.myapp &#123;</span><br><span class="line">    <span class="keyword">requires</span> java.sql; <span class="comment">// 依赖于 java.sql 模块</span></span><br><span class="line">    <span class="keyword">exports</span> com.example.myapp.services; <span class="comment">// 导出 com.example.myapp.services 包</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li><p>指令：</p>
<ul>
<li>导出（Exports）：指定哪些包对其他模块可见。</li>
<li>开放（Opens）：允许其他模块通过反射访问模块中的包。</li>
<li>需要（Requires）：指定当前模块所依赖的其他模块。</li>
<li>使用（Uses）：指定当前模块使用的服务类型。服务提供者通过 <code>ServiceLoader</code> 机制来实现。</li>
<li>提供（Provides）：指定当前模块提供的服务实现。</li>
</ul>
</li>
<li></li>
</ul>
<h4 id="问：集合工厂方法-？"><a href="#问：集合工厂方法-？" class="headerlink" title="问：集合工厂方法 ？"></a>问：集合工厂方法 ？</h4><p>通常，您希望在代码中创建一个集合（例如，List 或 Set ），并直接用一些元素填充它。 实例化集合，几个  <code>“add” </code> 调用，使得代码重复。 Java 9，添加了几种集合工厂方法：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Set&lt;Integer&gt; ints = Set.of（<span class="number">1</span>， <span class="number">2</span>， <span class="number">3</span>）；</span><br><span class="line">List&lt;String&gt; strings = List.of（<span class="string">&quot;first&quot;</span>， <span class="string">&quot;second&quot;</span>）；</span><br></pre></td></tr></table></figure>



<h4 id="问：改进的-Stream-API-？"><a href="#问：改进的-Stream-API-？" class="headerlink" title="问：改进的 Stream API ？"></a>问：改进的 Stream API ？</h4><p>Stream 接口中添加了 4 个新的方法：dropWhile， takeWhile， ofNullable。还有个 iterate 方法的新重载方法</p>
<h4 id="问：改进的-Javadoc-？"><a href="#问：改进的-Javadoc-？" class="headerlink" title="问：改进的 Javadoc ？"></a>问：改进的 Javadoc ？</h4><p>Javadoc 现在支持在 API 文档中的进行搜索。另外，Javadoc 的输出现在符合兼容 HTML5 标准。</p>
<ul>
<li><strong>HTML5 支持</strong>：Javadoc 默认生成 HTML5 格式的文档，取代了过去使用的 HTML4。这使得生成的文档更加现代化，兼容性更好，同时支持更丰富的 HTML 特性。</li>
<li><strong>内置搜索功能</strong>：Java 9 为 Javadoc 文档新增了一个内置的搜索框，使开发者能够在文档中搜索类、接口、方法和字段。这极大提升了查找特定信息的效率，避免了手动浏览所有页面。</li>
<li><strong>模块化支持</strong>：Java 9 引入了 Java 平台模块系统（Jigsaw 项目），Javadoc 工具增加了对模块的支持。开发者可以为模块生成文档，文档中清晰展示了模块及其依赖关系。这对于大型项目或使用模块化结构的应用程序特别有用。<ul>
<li>使用 <code>javadoc --module</code> 参数可以为指定模块生成文档。</li>
<li>生成的文档中展示了模块依赖和导出的 API 信息。</li>
</ul>
</li>
<li>等等。</li>
</ul>
<h2 id="十一-Java-11-特性"><a href="#十一-Java-11-特性" class="headerlink" title="十一. Java 11 特性"></a>十一. Java 11 特性</h2><p>redis代理集群模式，三次握手，valitile重排序底层代码， cas 事务的4个特性，filter和interceptor的区别 @autowired原理， dispatcherservlet，分布式事务解决方案spring都有哪些模块，fork join队列，排序算法，</p>

    </div>

    
    
    
      
  <div class="popular-posts-header">相关文章</div>
  <ul class="popular-posts">
    <li class="popular-posts-item">
      <div class="popular-posts-title"><a href="\2020050501.html" rel="bookmark">面试整理——Redis</a></div>
    </li>
    <li class="popular-posts-item">
      <div class="popular-posts-title"><a href="\2020050401.html" rel="bookmark">面试整理——Dubbo</a></div>
    </li>
    <li class="popular-posts-item">
      <div class="popular-posts-title"><a href="\2020050301.html" rel="bookmark">面试整理——Mybatis</a></div>
    </li>
    <li class="popular-posts-item">
      <div class="popular-posts-title"><a href="\2020050201.html" rel="bookmark">面试整理——MQ</a></div>
    </li>
    <li class="popular-posts-item">
      <div class="popular-posts-title"><a href="\2020050101.html" rel="bookmark">面试整理——Spring Cloud</a></div>
    </li>
  </ul>


    <footer class="post-footer">
          

<div class="post-copyright">
<ul>
  <li class="post-copyright-author">
      <strong>本文作者： </strong>Lys
  </li>
  <li class="post-copyright-link">
      <strong>本文链接：</strong>
      <a href="http://linyishui.top/2019102002.html" title="面试整理——Java基础">http://linyishui.top/2019102002.html</a>
  </li>
  <li class="post-copyright-license">
    <strong>版权声明： </strong>本博客所有文章除特别声明外，均采用 <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/deed.zh" rel="noopener" target="_blank"><i class="fab fa-fw fa-creative-commons"></i>BY-NC-SA</a> 许可协议。转载请注明出处！
  </li>
</ul>
</div>

          <div class="post-tags">
              <a href="/tags/Q-A/" rel="tag"><i class="fa fa-tag"></i> Q&A</a>
              <a href="/tags/updating/" rel="tag"><i class="fa fa-tag"></i> updating</a>
          </div>

        

          <div class="post-nav">
            <div class="post-nav-item">
                <a href="/2019102001.html" rel="prev" title="面经整理——导航页">
                  <i class="fa fa-chevron-left"></i> 面经整理——导航页
                </a>
            </div>
            <div class="post-nav-item">
                <a href="/2019102101.html" rel="next" title="面试整理——Java集合">
                  面试整理——Java集合 <i class="fa fa-chevron-right"></i>
                </a>
            </div>
          </div>
    </footer>
  </article>
</div>






    <div class="comments utterances-container"></div>
</div>
  </main>

  <footer class="footer">
    <div class="footer-inner">


<div class="copyright">
  &copy; 2018 – 
  <span itemprop="copyrightYear">2025</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">Lys</span>
</div>
<div class="wordcount">
  <span class="post-meta-item">
    <span class="post-meta-item-icon">
      <i class="fa fa-chart-line"></i>
    </span>
      <span>站点总字数：</span>
    <span title="站点总字数">5.4m</span>
  </span>
  <span class="post-meta-item">
    <span class="post-meta-item-icon">
      <i class="fa fa-coffee"></i>
    </span>
      <span>站点阅读时长 &asymp;</span>
    <span title="站点阅读时长">82:05</span>
  </span>
</div>
  <div class="powered-by">由 <a href="https://hexo.io/" rel="noopener" target="_blank">Hexo</a> & <a href="https://theme-next.js.org/pisces/" rel="noopener" target="_blank">NexT.Pisces</a> 强力驱动
  </div>

    </div>
  </footer>

  
  <script src="https://cdn.jsdelivr.net/npm/animejs@3.2.1/lib/anime.min.js" integrity="sha256-XL2inqUJaslATFnHdJOi9GfQ60on8Wx1C2H8DYiN1xY=" crossorigin="anonymous"></script>
  <script src="https://cdn.jsdelivr.net/npm/jquery@3.6.0/dist/jquery.min.js" integrity="sha256-/xUj+3OJU5yExlq6GSYGSHk7tPXikynS7ogEvDej/m4=" crossorigin="anonymous"></script>
  <script src="https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@3.5.7/dist/jquery.fancybox.min.js" integrity="sha256-yt2kYMy0w8AbtF89WXb2P1rfjcP/HTHLT7097U8Y5b8=" crossorigin="anonymous"></script>
<script src="/js/comments.js"></script><script src="/js/utils.js"></script><script src="/js/motion.js"></script><script src="/js/next-boot.js"></script><script src="/js/bookmark.js"></script>

  
<script src="/js/third-party/search/local-search.js"></script>



  <script class="next-config" data-name="nprogress" type="application/json">{"enable":true,"spinner":true}</script>
  <script src="/js/third-party/nprogress.js"></script>

  




<script src="https://cdn.jsdelivr.net/npm/darkmode-js@1.5.7/lib/darkmode-js.min.js"></script>

<script>
var options = {
  bottom: '64px',
  right: '32px',
  left: 'unset',
  time: '0.5s',
  mixColor: 'transparent',
  backgroundColor: 'transparent',
  buttonColorDark: '#100f2c',
  buttonColorLight: '#fff',
  saveInCookies: true,
  label: '🌓',
  autoMatchOsTheme: true
}
const darkmode = new Darkmode(options);
window.darkmode = darkmode;
darkmode.showWidget();
</script>
<script class="next-config" data-name="utterances" type="application/json">{"enable":true,"repo":"LAILAIWA/LAILAIWA.github.io","issue_term":"pathname","theme":"github-light"}</script>
<script src="/js/third-party/comments/utterances.js"></script>



</body>
</html>
