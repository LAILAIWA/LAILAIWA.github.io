<!DOCTYPE html>



  


<html class="theme-next pisces use-motion" lang="zh-Hans">
<head><meta name="generator" content="Hexo 3.9.0">
  <meta charset="UTF-8">
<meta http-equiv="X-UA-Compatible" content="IE=edge">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
<meta name="theme-color" content="#222">



  
  
    
    
  <script src="/lib/pace/pace.min.js?v=1.0.2"></script>
  <link href="/lib/pace/pace-theme-minimal.min.css?v=1.0.2" rel="stylesheet">







<meta http-equiv="Cache-Control" content="no-transform">
<meta http-equiv="Cache-Control" content="no-siteapp">
















  
  
  <link href="/lib/fancybox/source/jquery.fancybox.css?v=2.1.5" rel="stylesheet" type="text/css">







<link href="/lib/font-awesome/css/font-awesome.min.css?v=4.6.2" rel="stylesheet" type="text/css">

<link href="/css/main.css?v=5.1.4" rel="stylesheet" type="text/css">


  <link rel="apple-touch-icon" sizes="180x180" href="/images/gamepad playstation.png?v=5.1.4">


  <link rel="icon" type="image/png" sizes="32x32" href="/images/Dig Dug.ico?v=5.1.4">


  <link rel="icon" type="image/png" sizes="16x16" href="/images/gamepad playstation.png?v=5.1.4">


  <link rel="mask-icon" href="/images/gamepad playstation.svg?v=5.1.4" color="#222">





  <meta name="keywords" content="algorithm,sort,">





  <link rel="alternate" href="/atom.xml" title="俺的部落格" type="application/atom+xml">






<meta name="description" content="排序算法包括：选择排序，插入排序，希尔排序，归并排序，快速排序，堆排序等常用排序算法内容">
<meta name="keywords" content="algorithm,sort">
<meta property="og:type" content="article">
<meta property="og:title" content="算法复习 (一) 排序">
<meta property="og:url" content="http://linyishui.top/2018073001.html">
<meta property="og:site_name" content="俺的部落格">
<meta property="og:description" content="排序算法包括：选择排序，插入排序，希尔排序，归并排序，快速排序，堆排序等常用排序算法内容">
<meta property="og:locale" content="zh-Hans">
<meta property="og:image" content="https://pic-1258215793.cos.ap-shanghai.myqcloud.com/cover/tinapouty_1___BfVFfHaHi54___.jpg">
<meta property="og:updated_time" content="2020-06-22T13:59:35.430Z">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="算法复习 (一) 排序">
<meta name="twitter:description" content="排序算法包括：选择排序，插入排序，希尔排序，归并排序，快速排序，堆排序等常用排序算法内容">
<meta name="twitter:image" content="https://pic-1258215793.cos.ap-shanghai.myqcloud.com/cover/tinapouty_1___BfVFfHaHi54___.jpg">



<script type="text/javascript" id="hexo.configurations">
  var NexT = window.NexT || {};
  var CONFIG = {
    root: '/',
    scheme: 'Pisces',
    version: '5.1.4',
    sidebar: {"position":"left","display":"always","offset":12,"b2t":false,"scrollpercent":false,"onmobile":false},
    fancybox: true,
    tabs: true,
    motion: {"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}},
    duoshuo: {
      userId: '0',
      author: '博主'
    },
    algolia: {
      applicationID: '',
      apiKey: '',
      indexName: '',
      hits: {"per_page":10},
      labels: {"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}
    }
  };
</script>



  <link rel="canonical" href="http://linyishui.top/2018073001.html">





  <title>算法复习 (一) 排序 | 俺的部落格</title>
  








<link rel="stylesheet" href="\assets\css\APlayer.min.css" class="aplayer-style-marker">
<script src="\assets\js\APlayer.min.js" class="aplayer-script-marker"></script>
</head>

<body itemscope itemtype="http://schema.org/WebPage" lang="zh-Hans">

  
  
    
  

  <div class="container sidebar-position-left page-post-detail">
    <div class="headband"></div>

    <header id="header" class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-wrapper">
  <div class="site-meta ">
    

    <div class="custom-logo-site-title">
      <a href="/" class="brand" rel="start">
        <span class="logo-line-before"><i></i></span>
        <span class="site-title">俺的部落格</span>
        <span class="logo-line-after"><i></i></span>
      </a>
    </div>
      
        <p class="site-subtitle">俺寻思俺需要记点东西</p>
      
  </div>

  <div class="site-nav-toggle">
    <button>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
    </button>
  </div>
</div>

<nav class="site-nav">
  

  
    <ul id="menu" class="menu">
      
        
        <li class="menu-item menu-item-home">
          <a href="/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-home"></i> <br>
            
            首页
          </a>
        </li>
      
        
        <li class="menu-item menu-item-about">
          <a href="/about/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-user"></i> <br>
            
            关于
          </a>
        </li>
      
        
        <li class="menu-item menu-item-tags">
          <a href="/tags/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-tags"></i> <br>
            
            标签
          </a>
        </li>
      
        
        <li class="menu-item menu-item-categories">
          <a href="/categories/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-th"></i> <br>
            
            分类
          </a>
        </li>
      
        
        <li class="menu-item menu-item-archives">
          <a href="/archives/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-archive"></i> <br>
            
            归档
          </a>
        </li>
      
        
        <li class="menu-item menu-item-sitemap">
          <a href="/sitemap.xml" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-sitemap"></i> <br>
            
            站点地图
          </a>
        </li>
      
        
        <li class="menu-item menu-item-commonweal">
          <a href="/404/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-heartbeat"></i> <br>
            
            公益404
          </a>
        </li>
      

      
        <li class="menu-item menu-item-search">
          
            <a href="javascript:;" class="popup-trigger">
          
            
              <i class="menu-item-icon fa fa-search fa-fw"></i> <br>
            
            搜索
          </a>
        </li>
      
    </ul>
  

  
    <div class="site-search">
      
  <div class="popup search-popup local-search-popup">
  <div class="local-search-header clearfix">
    <span class="search-icon">
      <i class="fa fa-search"></i>
    </span>
    <span class="popup-btn-close">
      <i class="fa fa-times-circle"></i>
    </span>
    <div class="local-search-input-wrapper">
      <input autocomplete="off" placeholder="搜索..." spellcheck="false" type="text" id="local-search-input">
    </div>
  </div>
  <div id="local-search-result"></div>
</div>



    </div>
  
</nav>



 </div>
    </header>

    <main id="main" class="main">
      <div class="main-inner">
        <div class="content-wrap">
          <div id="content" class="content">
            

  <div id="posts" class="posts-expand">
    

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://linyishui.top/2018073001.html">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Speciosity">
      <meta itemprop="description" content>
      <meta itemprop="image" content="https://pic-1258215793.cos.ap-shanghai.myqcloud.com/cover/riho_yoshioka1.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="俺的部落格">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">算法复习 (一) 排序</h1>
        

        <div class="post-meta">
          
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2018-07-30T14:48:00+08:00">
                2018-07-30
              </time>
            

            

            
          </span>

          
            <span class="post-category">
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/技术文档/" itemprop="url" rel="index">
                    <span itemprop="name">技术文档</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          
            <div class="post-wordcount">
              
                
                <span class="post-meta-item-icon">
                  <i class="fa fa-file-word-o"></i>
                </span>
                
                  <span class="post-meta-item-text">字数统计&#58;</span>
                
                <span title="字数统计">
                  14,481
                </span>
              

              
                <span class="post-meta-divider">|</span>
              

              
                <span class="post-meta-item-icon">
                  <i class="fa fa-clock-o"></i>
                </span>
                
                  <span class="post-meta-item-text">阅读时长 &asymp;</span>
                
                <span title="阅读时长">
                  56
                </span>
              
            </div>
          

          
              <div class="post-description">
                  排序算法包括：选择排序，插入排序，希尔排序，归并排序，快速排序，堆排序等常用排序算法内容
              </div>
          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      
        <div class="post-gallery" itemscope itemtype="http://schema.org/ImageGallery">
          
          
            <div class="post-gallery-row">
              <a class="post-gallery-img fancybox" href="https://pic-1258215793.cos.ap-shanghai.myqcloud.com/cover/tinapouty_1___BfVFfHaHi54___.jpg" rel="gallery_ckd7392el012z5wt7cek7ubf2" itemscope itemtype="http://schema.org/ImageObject" itemprop="url">
                <img src="https://pic-1258215793.cos.ap-shanghai.myqcloud.com/cover/tinapouty_1___BfVFfHaHi54___.jpg" itemprop="contentUrl">
              </a>
            
          

          
          </div>
        </div>
      

      
        
        <div id="aplayer-NYflfrTd" class="aplayer aplayer-tag-marker" style="margin-bottom: 20px;">
            <pre class="aplayer-lrc-content"></pre>
        </div>
        <script>
          var ap = new APlayer({
            element: document.getElementById("aplayer-NYflfrTd"),
            narrow: false,
            autoplay: false,
            showlrc: false,
            music: {
              title: "ラスト・シンデレラ",
              author: "FreeTEMPO",
              url: "http://pcvwwmd5n.bkt.clouddn.com/FreeTEMPO%20-%20%E3%83%A9%E3%82%B9%E3%83%88%E3%83%BB%E3%82%B7%E3%83%B3%E3%83%87%E3%83%AC%E3%83%A9.mp3",
              pic: "http://p1.music.126.net/qdCz_G7r4dtlpKIE76laJw==/2405731441630133.jpg",
              lrc: ""
            }
          });
          window.aplayers || (window.aplayers = []);
          window.aplayers.push(ap);
        </script>
<h1 id="排序"><a href="#排序" class="headerlink" title="排序"></a><strong>排序</strong></h1><h2 id="第一节-前文"><a href="#第一节-前文" class="headerlink" title="第一节 前文"></a><strong>第一节 前文</strong></h2><h3 id="1-1-什么是排序？"><a href="#1-1-什么是排序？" class="headerlink" title="1.1 什么是排序？"></a><strong>1.1 什么是排序？</strong></h3><p>排序就是<strong>将一组对象按照某种逻辑顺序重新排列的过程</strong>。</p>
<p>排序往往是我们解决现实问题的第一步，接下来我们学习几种经典、优雅和高效的排序算法。</p>
<h3 id="1-2-如何比较两种排序算法？"><a href="#1-2-如何比较两种排序算法？" class="headerlink" title="1.2 如何比较两种排序算法？"></a><strong>1.2 如何比较两种排序算法？</strong></h3><ol>
<li>实现并调试他们</li>
<li>分析它们的基本性质</li>
<li>对它们的相对性能做出猜想</li>
<li>用实验证明猜想</li>
</ol>
<hr>
<h2 id="第二节-排序算法"><a href="#第二节-排序算法" class="headerlink" title="第二节 排序算法"></a><strong>第二节 排序算法</strong></h2><p>回顾一下常用的几种排序算法，实现代码可在GitHub中获取: </p>
<blockquote>
<p>URL: <a href="https://github.com/LAILAIWA/AlgorithmTraining" target="_blank" rel="noopener">https://github.com/LAILAIWA/AlgorithmTraining</a></p>
</blockquote>
<blockquote>
<p>SSH: <a href="mailto:git@github.com" target="_blank" rel="noopener">git@github.com</a>:LAILAIWA/AlgorithmTraining.git</p>
</blockquote>
<blockquote>
<p>代码位置：<a href="https://github.com/LAILAIWA/AlgorithmTraining/tree/master/src/sort" target="_blank" rel="noopener">https://github.com/LAILAIWA/AlgorithmTraining/tree/master/src/sort</a></p>
</blockquote>
<p>简单定义一个排序基类，实现几个常用的排序所需方法。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 实现了排序常用的几个方法，如比较大小、交换元素位置、打印数组、是否已排序等</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SortExample</span> </span>&#123;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//是否小于</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">boolean</span> <span class="title">less</span><span class="params">(Comparable v, Comparable w)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> v.compareTo(w) &lt; <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//交换</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">exch</span><span class="params">(Comparable[] a, <span class="keyword">int</span> i, <span class="keyword">int</span> j)</span> </span>&#123;</span><br><span class="line">        Comparable t = a[i];</span><br><span class="line">        a[i] = a[j];</span><br><span class="line">        a[j] = t;</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    <span class="comment">//单行打印数组</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">show</span><span class="params">(Comparable[] a)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; a.length; i++)</span><br><span class="line">            System.out.print(a[i] + <span class="string">" "</span>);</span><br><span class="line">        System.out.println();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//测试数组元素是否有序</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">boolean</span> <span class="title">isSorted</span><span class="params">(Comparable[] a)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; a.length; i++)</span><br><span class="line">            <span class="keyword">if</span> (less(a[i], a[i - <span class="number">1</span>])) <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>每种排序算法都需要分析以下内容：</p>
<ol>
<li><strong>验证正确性</strong>：通过如 <code>assert isSorted(a);</code> 判断是否每个元素都是有序的，当然这<strong>只能判断最终结果数组是否有序</strong>，不能检测出如<strong>将所有元素替换为相同元素</strong>等漏洞。</li>
<li><strong>评估运行时间</strong>：评估算法的性能，首先要<strong>计算</strong>各种排序算法在随机输入下的<strong>基本操作的次数</strong>（包括<strong>比较</strong>和<strong>交换</strong>，或<strong>读写数组</strong>的次数，前者用来评估排序算法，后者用于评估不交换元素的算法）。</li>
<li><strong>额外内存开销</strong>：排序算法有两种，<strong>除了函数调用所需栈和固定数目的实例变量外无需额外内存的原地排序算法</strong>，以及<strong>需要额外内存空间来存储一份数组副本的其他排序算法</strong>。</li>
<li><strong>数据类型</strong>：排序算法适用于实现 <code>Comparable</code> 接口的数据类型，实现此接口需要实现一个 <code>compareTo()</code> 方法来定义目标对象的自然次序。该方法要求要实现一个全序关系：<ul>
<li><strong>自反性</strong>：对于所有的v，v=v；</li>
<li><strong>反对称性</strong>：对于所有的v&lt;w都有v&gt;w，且v=w时w=v；</li>
<li><strong>传递性</strong>：对于所有的v、w和x，如果v&lt;=w且w&lt;=x，则v&lt;=x。</li>
</ul>
</li>
</ol>
<hr>
<h3 id="2-1-选择排序"><a href="#2-1-选择排序" class="headerlink" title="2.1 选择排序"></a><strong>2.1 选择排序</strong></h3><p><em>最简单的排序算法—选择排序，不断地选择当前最小元素。</em></p>
<p><strong>选择排序</strong>：找到数组中最小的元素，将其与数组第一个元素交换，再在剩余的元素中找到最小的元素，并将其与第二个元素交换，继续在余下数组中循环此过程直到所有元素排序。</p>
<h4 id="2-1-1-代码"><a href="#2-1-1-代码" class="headerlink" title="2.1.1 代码"></a><strong>2.1.1 代码</strong></h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">sort</span><span class="params">(Comparable[] a)</span></span>&#123;<span class="comment">//将数组a按升序排序</span></span><br><span class="line">    <span class="keyword">int</span> N = a.length;<span class="comment">//记录数组长度</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>;i &lt; N;i++)&#123;<span class="comment">//将a[i]与a[i+1...N]最小元素交换</span></span><br><span class="line">        <span class="keyword">int</span> min = i;</span><br><span class="line">        <span class="comment">//循环遍历找到当前最小元素</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j = i+<span class="number">1</span>;j &lt; N;j++)</span><br><span class="line">            <span class="keyword">if</span>(less(a[j],a[min])) min = j;</span><br><span class="line">        <span class="comment">//将第i小元素交换至位置i</span></span><br><span class="line">        exch(a,i,min);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="2-1-2-排序轨迹"><a href="#2-1-2-排序轨迹" class="headerlink" title="2.1.2 排序轨迹"></a><strong>2.1.2 排序轨迹</strong></h4><p><img src="https://pic-1258215793.cos.ap-shanghai.myqcloud.com/content/20200601/202006010101.jpg" alt></p>
<p><img src="https://pic-1258215793.cos.ap-shanghai.myqcloud.com/content/20200601/202006010102.jpg" alt></p>
<h4 id="2-1-3-运行时间"><a href="#2-1-3-运行时间" class="headerlink" title="2.1.3 运行时间"></a><strong>2.1.3 运行时间</strong></h4><p>对于长度为N数组，选择排序需要 <code>N^2/2</code> 次<strong>比较</strong>和 <code>N</code> 次<strong>交换</strong>。</p>
<blockquote>
<p>交换次数为N很明显，每个元素需要且仅需要一次交换；比较次数则需要根据排序轨迹来总结计算，通过一张 N * N 的表格来表示排序轨迹，对角线表示元素进行一次交换，结合代码可以得知，0到N-1的任意i都会进行一次交换和N-1-i次比较，所以比较总次数等于 (N-1) + (N - 2) + …… + 2 + 1 = N (N - 1) / 2 = N^2 / 2。</p>
</blockquote>
<h4 id="2-1-4-额外内存空间"><a href="#2-1-4-额外内存空间" class="headerlink" title="2.1.4 额外内存空间"></a><strong>2.1.4 额外内存空间</strong></h4><p>不需要</p>
<h4 id="2-1-5-特点"><a href="#2-1-5-特点" class="headerlink" title="2.1.5 特点"></a><strong>2.1.5 特点</strong></h4><ol>
<li>运行时间和输入无关，即使是已排序过的数组再排序亦无不同 </li>
<li>数据移动是最少的</li>
</ol>
<hr>
<h3 id="2-2-插入排序"><a href="#2-2-插入排序" class="headerlink" title="2.2 插入排序"></a><strong>2.2 插入排序</strong></h3><p><strong>插入排序</strong>：每次将新来元素插入已经有序的数组中，右侧数据需要右移，当索引到达数组右端排序结束。</p>
<h4 id="2-2-1-代码"><a href="#2-2-1-代码" class="headerlink" title="2.2.1 代码"></a><strong>2.2.1 代码</strong></h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">sort</span><span class="params">(Comparable[] a)</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> N = a.length;</span><br><span class="line">    <span class="comment">// 从第二个元素开始遍历数组</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>;i &lt; N;i++)&#123;</span><br><span class="line">    	<span class="comment">// 第二层游标j从游标i开始，逆向遍历，不断和比其小的元素交换位置，直到移动到0位置</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j = i;j &gt; <span class="number">0</span> &amp;&amp; less(a[j],a[j-<span class="number">1</span>]);j--)</span><br><span class="line">            exch(a,j,j-<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="2-2-2-排序轨迹"><a href="#2-2-2-排序轨迹" class="headerlink" title="2.2.2 排序轨迹"></a><strong>2.2.2 排序轨迹</strong></h4><p><img src="https://pic-1258215793.cos.ap-shanghai.myqcloud.com/content/20200601/202006010103.jpg" alt></p>
<h4 id="2-2-3-运行时间"><a href="#2-2-3-运行时间" class="headerlink" title="2.2.3 运行时间"></a><strong>2.2.3 运行时间</strong></h4><ul>
<li>对于长度为N的数组，插入排序平均需要<code>N^2/4</code> 次<strong>比较</strong>和 <code>N^2/4</code> 次<strong>交换</strong>；</li>
<li>最坏需要 <code>N^2/2</code> 次<strong>比较</strong>以及 <code>N^2/2</code> 次<strong>交换</strong>；</li>
<li>最好情况下需要 <code>N-1</code> 次<strong>比较</strong>和 <code>0</code> 次<strong>交换</strong>。</li>
</ul>
<blockquote>
<p>最坏情况即对角线以下所有元素都需要移动位置（逆序数组），最好情况则是都不需要（顺序数组）。随机排列的数组，平均情况下每个元素都可能向后移动半个数组的长度，因此交换总数是对角线以下元素总数的一半。</p>
<p>比较的次数是交换次数加上一个额外的项，N减去被插入的元素正好是已知的最小元素的次数，最坏情况下可忽略（几乎每次比较都要交换位置），最好情况下等于 <code>N-1</code> 。</p>
</blockquote>
<h4 id="2-2-4-额外内存空间"><a href="#2-2-4-额外内存空间" class="headerlink" title="2.2.4 额外内存空间"></a><strong>2.2.4 额外内存空间</strong></h4><p>不需要</p>
<h4 id="2-2-5-特点"><a href="#2-2-5-特点" class="headerlink" title="2.2.5 特点"></a><strong>2.2.5 特点</strong></h4><ul>
<li>运行时间取决于数组元素的初始顺序。</li>
<li>类似于选择排序，索引左侧元素都是有序的，<strong>选择排序固定次序依次找出</strong>，<strong>插入排序则是固定元素依次排序</strong>。</li>
<li>适用于对<strong>有序数组</strong>（部分有序）进行排序。</li>
<li>当数组乱序时就会导致<strong>交换次数过多</strong>，使性能大幅度下降。</li>
</ul>
<hr>
<h3 id="2-3-希尔排序"><a href="#2-3-希尔排序" class="headerlink" title="2.3 希尔排序"></a><strong>2.3 希尔排序</strong></h3><p><strong>希尔排序</strong>：希尔排序是基于插入排序的改进版本，主要针对乱序的数组。<strong>插入排序只交换相邻元素，所以导致交换次数过多从而影响性能</strong>（如最小元素在数组尽头，将其挪至正确位置就需要 <code>N-1</code> 次交换），而希尔排序则<strong>交换不相邻的元素</strong>对局部进行排序，<strong>最终用插入排序将局部有序的数组排序</strong>，<strong>加速了元素移动的速度</strong>。</p>
<p><strong>排序思想</strong>：使数组中固定间隔H内的元素是有序的，即<strong>H有序数组</strong>：一个由H个有序子数组组成的数组。</p>
<p>最简单的实现希尔排序的方式：对于子数组用插入排序进行排序，将子数组中大的元素右移，移动元素的距离由1改为H，<strong>希尔排序即增量为H的插入排序</strong>。H亦是一组以1为起点的<strong>递增序列</strong>。</p>
<p><img src="https://pic-1258215793.cos.ap-shanghai.myqcloud.com/content/20200601/202006010104.jpg" alt></p>
<p>希尔排序之所以高效是因为其权衡了子数组的规模和有序性，初始时子数组较短，且都部分有序，这很适合插入排序。</p>
<h4 id="2-3-1-代码"><a href="#2-3-1-代码" class="headerlink" title="2.3.1 代码"></a><strong>2.3.1 代码</strong></h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">sort</span><span class="params">(Comparable[] a)</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> N = a.length;</span><br><span class="line">    <span class="keyword">int</span> H = <span class="number">1</span>;</span><br><span class="line">    <span class="comment">// 根据元素数目初始化H</span></span><br><span class="line">    <span class="keyword">while</span> (H &lt; N/<span class="number">3</span>)</span><br><span class="line">        H = <span class="number">3</span>*H + <span class="number">1</span>;</span><br><span class="line">    <span class="comment">//同插入排序，但游标不是相邻移动，而是间隔H，将a[i]插入到a[i-H],a[i-2H]...之中</span></span><br><span class="line">    <span class="keyword">while</span> (H &gt;= <span class="number">1</span>) &#123;</span><br><span class="line">    	<span class="comment">// 游标i从H开始遍历数组</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = H;i &lt; N;i++)&#123;</span><br><span class="line">        	<span class="comment">// 游标j仍从游标i开始，逆向隔H遍历，</span></span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j = i; j &gt;=H &amp;&amp; less(a[j],a[j-H]);j-=H)<span class="comment">//</span></span><br><span class="line">                exch(a,j,j-H);</span><br><span class="line">        &#125;</span><br><span class="line">        H = H/<span class="number">3</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="2-3-2-排序轨迹"><a href="#2-3-2-排序轨迹" class="headerlink" title="2.3.2 排序轨迹"></a><strong>2.3.2 排序轨迹</strong></h4><p><img src="https://pic-1258215793.cos.ap-shanghai.myqcloud.com/content/20200601/202006010105.jpg" alt></p>
<p>H=13 P与S交换</p>
<p>H=4  LP，ES，EH，AR，AL，MT，MP，LX，LO，ER，EL</p>
<p>H=1 EL，EL，AL，AE，AE，HM，HL，LM，EM，EL，EL，EH，OS，OP，LS，LP，LO，LM，ST，RX，RT，RS，RS</p>
<p>H=1时希尔排序等价于插入排序，但因为前述步骤此时子数组已都有序，所以插入排序不会有比较长的持续交换情况。</p>
<p><img src="https://pic-1258215793.cos.ap-shanghai.myqcloud.com/content/20200601/202006010106.jpg" alt></p>
<h4 id="2-3-3-递增序列"><a href="#2-3-3-递增序列" class="headerlink" title="2.3.3 递增序列"></a><strong>2.3.3 递增序列</strong></h4><p>递增序列如何选择？有很多论文研究了各种不同的递增序列，但都没法证明哪个序列是“最好的”。优秀的递增序列有待我们去实验和发现。</p>
<h4 id="2-3-4-运行时间"><a href="#2-3-4-运行时间" class="headerlink" title="2.3.4 运行时间"></a><strong>2.3.4 运行时间</strong></h4><p>希尔排序的性能论证十分复杂，目前的结论是其运行时间达不到平方级别，<strong>最坏情况大概与 <code>N^(3/2)</code> 成正比</strong>，相比插入排序一点微小的改变就突破了平方的屏障，这正是算法设计的目标。</p>
<h4 id="2-3-5-额外内存空间"><a href="#2-3-5-额外内存空间" class="headerlink" title="2.3.5 额外内存空间"></a><strong>2.3.5 额外内存空间</strong></h4><p>不需要</p>
<h4 id="2-3-6-特点"><a href="#2-3-6-特点" class="headerlink" title="2.3.6 特点"></a><strong>2.3.6 特点</strong></h4><ul>
<li>希尔排序通常会被有经验的程序员使用，一些更高效的算法除非对于N特别大的情景，一般只会比希尔排序快不到两倍，且设计复杂度会更大，希尔排序的代码量很小，也不需要额外的内存空间，所以可以首先考虑希尔排序再根据情况选择更复杂的排序算法。</li>
<li>希尔排序的速度要远远快于选择排序和插入排序，且数组越大时优势越明显。</li>
<li>相比选择排序，希尔排序可以应用于一些大型数组，且对于乱序的数组表现也很好。</li>
</ul>
<hr>
<h3 id="2-4-归并排序"><a href="#2-4-归并排序" class="headerlink" title="2.4 归并排序"></a><strong>2.4 归并排序</strong></h3><p><strong>归并</strong>：即将两个有序数组归并成一个更大的有序数组。</p>
<p><strong>归并排序</strong>：根据归并思路设计了简单的递归排序算法—归并排序。即对数组排序时，先将其<strong>分为两半分别排序</strong>，然后再将<strong>结果归并</strong>。归并排序可以保证任意长度N数组排序<strong>所需时间与NlogN成正比</strong>，缺点是<strong>所需额外空间与N成正比</strong>，<strong>用空间换时间</strong>。</p>
<p><img src="https://pic-1258215793.cos.ap-shanghai.myqcloud.com/content/20200601/202006010107.jpg" alt></p>
<h4 id="2-4-1-原地归并"><a href="#2-4-1-原地归并" class="headerlink" title="2.4.1 原地归并"></a><strong>2.4.1 原地归并</strong></h4><p><strong>归并并不高效</strong>：每次归并都创建新数组来存储排序结果是非常耗能的设计，所以需要有一种在原数组中归并的方法，我们可以想象一下有哪些办法可以实现这一需求？</p>
<p><strong>没有既简单又高效的归并方案</strong>：但实际上所有的原地归并方法都会造成复杂度大幅上升，特别是和使用额外内存空间的实现相比，原地归并一般会采用共用一个公共数组来暂存数组数据。</p>
<p>下文中 <code>merge(Comparable[] a, int lo, int mid, int hi)</code> 方法即原地归并的实现方法，通过一个辅助数组放置复制的元素，再合并回原数组。</p>
<h4 id="2-4-2-自顶向下的归并排序"><a href="#2-4-2-自顶向下的归并排序" class="headerlink" title="2.4.2 自顶向下的归并排序"></a><strong>2.4.2 自顶向下的归并排序</strong></h4><p><strong>自顶向下的归并排序</strong>：是基于原地归并的抽象，并采用<strong>分治思想</strong>设计的另外一种递归归并。这段递归代码 <code>sort()</code> 是可以通过归纳证明算法能够正确将数组排序：如果它能将两个子数组排序，它就能通过归并两个子数组将整个数组排序。</p>
<h4 id="2-4-3-自底向上的归并排序"><a href="#2-4-3-自底向上的归并排序" class="headerlink" title="2.4.3 自底向上的归并排序"></a><strong>2.4.3 自底向上的归并排序</strong></h4><p><strong>自底向上的归并排序</strong>：递归实现的归并排序都是<strong>分治思想</strong>的经典应用，自底向上的思路是先归并微小数组，再成对的归并得到的子数组，直到将所有数组归并到一起。从最小单元开始两两归并，相比标准递归方法所需的代码量会少一些。</p>
<h4 id="2-4-4-代码"><a href="#2-4-4-代码" class="headerlink" title="2.4.4 代码"></a><strong>2.4.4 代码</strong></h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Merge</span> <span class="keyword">extends</span> <span class="title">SortExample</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span>&#123;</span><br><span class="line">        Integer[] a = RandomUtil.getRandomIndex(<span class="number">10000</span>);</span><br><span class="line">        Stopwatch stopwatch = <span class="keyword">new</span> Stopwatch();</span><br><span class="line">        sort(a);</span><br><span class="line">        System.out.println(stopwatch.elapseTime());</span><br><span class="line">        show(a);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 原地归并的抽象方法</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">merge</span><span class="params">(Comparable[] a, <span class="keyword">int</span> lo, <span class="keyword">int</span> mid, <span class="keyword">int</span> hi)</span></span>&#123;</span><br><span class="line">        <span class="comment">//将a[lo,mid]与a[mid+1,hi]归并，两个数组是有序的</span></span><br><span class="line">        <span class="keyword">int</span> i = lo,j = mid+<span class="number">1</span>;</span><br><span class="line">        <span class="comment">//先将所有元素复制到aux[]中，再归并到a[]中</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> k = lo;k &lt;= hi;k++)</span><br><span class="line">            aux[k] = a[k];</span><br><span class="line">        <span class="comment">//用i,j指针分别游离于两数组</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> k = lo;k &lt;= hi;k++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(i &gt; mid) a[k] = aux[j++]; <span class="comment">//左边下标已结束</span></span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span>(j &gt; hi) a[k] = aux[i++];<span class="comment">//右边下标已结束</span></span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span>(less(aux[j],aux[i])) a[k] = aux[j++];<span class="comment">//两数组的指针比较当前大小，前者较小</span></span><br><span class="line">            <span class="keyword">else</span> a[k] = aux[i++];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 自顶向下的归并排序</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> Comparable[] aux; <span class="comment">//归并所需的辅助数组</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">sort</span><span class="params">(Comparable[] a)</span></span>&#123;</span><br><span class="line">        aux = <span class="keyword">new</span> Comparable[a.length];<span class="comment">//一次性分配空间</span></span><br><span class="line">        sort(a,<span class="number">0</span>,a.length-<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//将数组a排序，递归排序，sort的作用为以正确的顺序调用merge方法</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">sort</span><span class="params">(Comparable[] a,<span class="keyword">int</span> lo,<span class="keyword">int</span> hi)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(hi &lt;= lo) <span class="keyword">return</span>;</span><br><span class="line">        <span class="keyword">int</span> mid = lo + (hi - lo)/<span class="number">2</span>;</span><br><span class="line">        sort(a,lo,mid);      <span class="comment">// 将左半边排序</span></span><br><span class="line">        sort(a,mid+<span class="number">1</span>,hi);    <span class="comment">// 将右半边排序</span></span><br><span class="line">        merge(a,lo,mid,hi);  <span class="comment">// 归并结果</span></span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 自底向上的归并排序</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">sortBottomUp</span><span class="params">(Comparable[] a)</span></span>&#123;</span><br><span class="line">        <span class="comment">// 进行lgN次两两归并</span></span><br><span class="line">        <span class="keyword">int</span> N = a.length;</span><br><span class="line">        aux = <span class="keyword">new</span> Comparable[N];</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> sz = <span class="number">1</span>; sz &lt; N ;sz = sz + sz) <span class="comment">//sz-子数组大小</span></span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> lo = <span class="number">0</span>; lo &lt; N-sz;lo+=sz+sz) <span class="comment">//子数组索引</span></span><br><span class="line">                merge(a,lo,lo+sz-<span class="number">1</span>,Math.min(lo+sz+sz-<span class="number">1</span>,N-<span class="number">1</span>));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="2-4-5-运行轨迹"><a href="#2-4-5-运行轨迹" class="headerlink" title="2.4.5 运行轨迹"></a><strong>2.4.5 运行轨迹</strong></h4><h5 id="（1）原地归并的抽象方法"><a href="#（1）原地归并的抽象方法" class="headerlink" title="（1）原地归并的抽象方法"></a><strong>（1）原地归并的抽象方法</strong></h5><p>原地归并，先将所有元素复制到 <code>aux[]</code> ，然后再归并到 <code>a[]</code> 。方法在归并时进行了4个条件判断：<strong>左半边用尽</strong>（取右半边的元素）、<strong>右半边用尽</strong>（取左半边的元素）、<strong>右半边的当前元素小于左半边的当前元素</strong>（取右半边的元素）以及<strong>右半边的当前元素大于等于左半边的当前元素</strong>（取左半边的元素）。如下图，将两个有序子数组合并为最终有序数组。</p>
<p><img src="https://pic-1258215793.cos.ap-shanghai.myqcloud.com/content/20200601/202006010108.jpg" alt></p>
<h5 id="（2）自顶向下的归并排序"><a href="#（2）自顶向下的归并排序" class="headerlink" title="（2）自顶向下的归并排序"></a><strong>（2）自顶向下的归并排序</strong></h5><p>自顶向下归并排序，对数组 <code>a[lo...hi]</code> 进行排序，先分为 <code>a[lo...mid]</code> 和 <code>a[mid+1...hi]</code> 两部分，分别通过<strong>递归调用</strong>将它们分别排序（如图递归到最小数组-两个元素），最后将有序的子数组归并为最终结果。</p>
<p><img src="https://pic-1258215793.cos.ap-shanghai.myqcloud.com/content/20200601/202006010109.jpg" alt></p>
<p>自顶向下归并排序的递归调用轨迹如下图，要排序 <code>a[0...15]</code> ，递归调用 <code>a[0...7]</code> ，进一步递归调用 <code>a[0...3]</code> 以及到 <code>a[0...1]</code> ，将 <code>a[0]</code> 和 <code>a[1]</code> 排序后归并，再之后是 <code>a[2]</code> 和 <code>a[3]</code> ，之后是 <code>a[0...1]</code> 和 <code>a[2...3]</code>。<code>sort()</code> 方法其实就是按顺序调用 <code>merge()</code> 方法。</p>
<p><img src="https://pic-1258215793.cos.ap-shanghai.myqcloud.com/content/20200601/202006010110.jpg" alt></p>
<h5 id="（3）自底向上的归并排序"><a href="#（3）自底向上的归并排序" class="headerlink" title="（3）自底向上的归并排序"></a><strong>（3）自底向上的归并排序</strong></h5><p>自底向上的归并排序会多次遍历整个数组，根据子数组大小进行两两归并。子数组的大小sz的初始值为1，每次加倍。最后一个子数组的大小只有在数组大小是sz的偶数倍的时候才会等于sz（否则会小于sz）。</p>
<p><img src="https://pic-1258215793.cos.ap-shanghai.myqcloud.com/content/20200601/202006010112.jpg" alt></p>
<h4 id="2-4-6-运行时间"><a href="#2-4-6-运行时间" class="headerlink" title="2.4.6 运行时间"></a><strong>2.4.6 运行时间</strong></h4><h5 id="（1）自顶向下的归并排序"><a href="#（1）自顶向下的归并排序" class="headerlink" title="（1）自顶向下的归并排序"></a><strong>（1）自顶向下的归并排序</strong></h5><p><strong>对于长度为N的任意数组，自顶向下的归并排序需要 <code>1/2NlgN</code> 至 <code>NlgN</code> 次比较，并且最多需要访问数组 <code>6NlgN</code> 次</strong>。</p>
<p><strong>归并排序所需时间与 <code>NlgN</code> 成正比</strong>，这相比前几个排序要快很多（指数级），只需要比遍历整个数组多个对数因子的时间就可以将一个庞大的数组排序。</p>
<p>如下列树状图所示，每个节点表示一个 <code>sort()</code> 方法通过 <code>merge()</code> 方法归并而成的子数组。这棵树有n层，对于0到n-1之间的任意k，自顶向下的第k层有 <code>2^K</code> 个子数组，每个数组的长度为 <code>2^(n-k)</code> ，归并最多需要 <code>2^(n-k)</code> 次比较。因此每层的比较次数为 <code>2^K</code> x <code>2^(n-k)</code> = <code>2^n</code> ，n层总共为 <code>n2^n</code> = <code>NlgN</code> 。</p>
<p><img src="https://pic-1258215793.cos.ap-shanghai.myqcloud.com/content/20200601/202006010111.jpg" alt></p>
<h5 id="（2）自底向上的归并排序"><a href="#（2）自底向上的归并排序" class="headerlink" title="（2）自底向上的归并排序"></a><strong>（2）自底向上的归并排序</strong></h5><p><strong>对于长度为N的任意数组，自底向上的归并排序需要 <code>1/2NlgN</code> 至 <code>NlgN</code> 次比较，最多访问数组 <code>6NlgN</code> 次</strong>。</p>
<p>当数组长度为2的幂时，自顶向下和自底向上的归并排序的比较和数组访问次数刚好相等，只是顺序不同。其他时候则不同。</p>
<p>自底向上的归并排序比较适合<strong>链表</strong>组织的数据，从底层开始重新组织链接即可将链表原地排序（不需要创建新的链表结点）。</p>
<h4 id="2-4-7-额外内存空间"><a href="#2-4-7-额外内存空间" class="headerlink" title="2.4.7 额外内存空间"></a><strong>2.4.7 额外内存空间</strong></h4><p>需要额外的内存空间，辅助数组所使用的额外空间和N的大小成正比。</p>
<h4 id="2-4-8-优化"><a href="#2-4-8-优化" class="headerlink" title="2.4.8 优化"></a><strong>2.4.8 优化</strong></h4><h5 id="（1）小规模数组采用插入排序"><a href="#（1）小规模数组采用插入排序" class="headerlink" title="（1）小规模数组采用插入排序"></a><strong>（1）小规模数组采用插入排序</strong></h5><p>递归会使小规模问题中方法的调用过于频繁，插入或选择排序比较简单，很可能在小数组上比归并排序更快，如长度小于15时采用插入排序，一般可以将运行时间缩短10%~15%。</p>
<h5 id="（2）判断数组是否已有序"><a href="#（2）判断数组是否已有序" class="headerlink" title="（2）判断数组是否已有序"></a><strong>（2）判断数组是否已有序</strong></h5><p>可以添加一个判断，如果 <code>a[mid]</code> 小于等于 <code>a[mid+1]</code> ，可以认为数组已经是有序的并跳过 <code>merge()</code> 方法。此改动不影响排序的递归调用，但可以使任意有序的子数组的算法运行时间变为线性的。</p>
<h5 id="（3）不将元素复制到辅助数组"><a href="#（3）不将元素复制到辅助数组" class="headerlink" title="（3）不将元素复制到辅助数组"></a><strong>（3）不将元素复制到辅助数组</strong></h5><p>节省将数组元素复制到用于归并的辅助数组所用的时间，为了实现这一目标，需要调用两种排序方法：一种是将数据从输入数组排序到辅助数组，一种将数据从辅助数组排序到输入数组。这一方法需要在递归调用的每个层次交换输入数组和辅助数组的角色。</p>
<h4 id="2-4-9-特点"><a href="#2-4-9-特点" class="headerlink" title="2.4.9 特点"></a><strong>2.4.9 特点</strong></h4><ul>
<li>归并排序所需时间与 <code>NlgN</code> 成正比，远远比前几种排序方法要快。</li>
<li>数组规模较小时使用插入排序可能会比归并排序更快。</li>
<li>自底向上的归并排序比较适合<strong>链表</strong>组织的数据。</li>
<li>需要额外的内存空间，辅助数组所使用的额外空间和N的大小成正比。</li>
<li>归并排序是一种渐进最优的基于比较排序的算法。</li>
<li>归并排序的空间复杂度不是最优的，实践中不一定会遇到最坏情况，除了比较一些如访问数据的操作可能也会很重要，不进行比较也可以将数据排序。</li>
</ul>
<h4 id="2-4-10-计算排序算法的复杂度"><a href="#2-4-10-计算排序算法的复杂度" class="headerlink" title="2.4.10 计算排序算法的复杂度"></a><strong>2.4.10 计算排序算法的复杂度</strong></h4><p>第一步，建立一个计算模型。排序是基于比较的算法，此类算法在两次比较之间可能会进行任意规模的计算，但只能通过主键之间的比较得到关于某个主键的信息。</p>
<p>设计排序算法时有其复杂度的上限，最优算法的定义也并非只有一种标准。</p>
<blockquote>
<p>命题：<strong>没有任何基于比较的算法能够保证使用少于 <code>lg(N!)</code> ~ <code>NlgN</code> 次比较将长度为N的数组排序</strong>。</p>
<p>证明：二叉树来表示比较，叶子结点的数量介于[N!,2^H]，H为最坏情况比较次数，根据斯特灵公式对阶乘函数的近似可得lgN!~NlgN，过程暂略。</p>
</blockquote>
<blockquote>
<p>命题：<strong>归并排序是一种渐进最优的基于比较排序的算法</strong>。</p>
<p>证明：这句话的意思是：归并排序在最坏情况下的比较次数和任意基于比较的排序算法所需的最少比较次数都是 ~ <code>NlgN</code> 。</p>
</blockquote>
<p>准确的上界为软件工程师保证性能提供了空间，平方级别的排序性能低于线性排序；准确的下界帮助我们节省时间，避免因为不可能的性能改进而投入资源。</p>
<hr>
<h3 id="2-5-快速排序"><a href="#2-5-快速排序" class="headerlink" title="2.5 快速排序"></a><strong>2.5 快速排序</strong></h3><p>快速排序，可能是被应用最广泛的排序算法，因为其实现简单、适用各种输入数据且效率比其他排序算法都快的多，甚至还是原地排序。</p>
<p><strong>快速排序是根据切分元素切分为两个子数组，一个子数组内元素都大于切分元素，一个子数组内元素都小于切分元素，递归直到整个数组排序</strong>。如下图所示。</p>
<p><img src="https://pic-1258215793.cos.ap-shanghai.myqcloud.com/content/20200601/202006010113.jpg" alt></p>
<h4 id="2-5-1-优缺点"><a href="#2-5-1-优缺点" class="headerlink" title="2.5.1 优缺点"></a><strong>2.5.1 优缺点</strong></h4><ul>
<li>原地排序，只要一个很小的辅助栈。</li>
<li>快速排序内循环比大部分排序要短小，因此速度较快。</li>
<li>将长度为N的数组排序时间所需和 <code>NlgN</code> 成正比。</li>
<li>需要小心避免性能低劣，比较容易被错误使用。</li>
</ul>
<h4 id="2-5-2-快速排序和归并排序的区别"><a href="#2-5-2-快速排序和归并排序的区别" class="headerlink" title="2.5.2 快速排序和归并排序的区别"></a><strong>2.5.2 快速排序和归并排序的区别</strong></h4><ul>
<li>快速排序是一种<strong>分治</strong>的排序算法（归并也是），将数组分为两个子数组，子数组独立的排序。</li>
<li>快排和归并排序是<strong>互补</strong>的：归并排序是<strong>将数组分为两个子数组分别排序</strong>，<strong>将有序的子数组归并从而将整个数组排序</strong>；快速排序是<strong>将两个子数组顺序有序</strong>，<strong>当子数组内元素有序则数组自然有序</strong>。</li>
<li>快速排序是将两个子数组顺序有序，当子数组内元素有序则数组自然有序。</li>
<li><strong>归并排序递归调用发生在处理整个数组之前</strong>，<strong>快速排序递归调用发生在处理整个数组之后</strong>。</li>
<li>归并排序的切分位置为<strong>中间</strong>，快速排序切分位置<strong>取决于数组的内容</strong>。</li>
<li>快排切分位置取决于输入数据，因为取数组a[lo]作为切分元素，根据归纳法来判断，快速排序递归过程能正确的将整个数组排序，有序的左数组右数组内元素都是有序的则整个数组一定有序。</li>
</ul>
<h4 id="2-5-3-代码"><a href="#2-5-3-代码" class="headerlink" title="2.5.3 代码"></a><strong>2.5.3 代码</strong></h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Quick</span> </span>&#123;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">sort</span><span class="params">(Comparable[] a)</span></span>&#123;</span><br><span class="line">        <span class="comment">//消除对输入的依赖，需要在这里把元素随机分布一下</span></span><br><span class="line">        StdRandom.shuffle(a);</span><br><span class="line">        sort(a,<span class="number">0</span>,a.length-<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 递归排序</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">sort</span><span class="params">(Comparable[] a,<span class="keyword">int</span> lo,<span class="keyword">int</span> hi)</span></span>&#123;</span><br><span class="line">        <span class="comment">//当左右游标相等，表示已对最小数组排序，结束递归</span></span><br><span class="line">        <span class="keyword">if</span>(hi &lt;= lo) <span class="keyword">return</span>;</span><br><span class="line">        <span class="comment">//切分</span></span><br><span class="line">        <span class="keyword">int</span> j = partition(a,lo,hi);</span><br><span class="line">        <span class="comment">//将左半部分排序</span></span><br><span class="line">        sort(a,lo,j-<span class="number">1</span>);</span><br><span class="line">        <span class="comment">//将右半部分排序</span></span><br><span class="line">        sort(a,j+<span class="number">1</span>,hi);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 切分数组</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">partition</span><span class="params">(Comparable[] a,<span class="keyword">int</span> lo,<span class="keyword">int</span> hi)</span></span>&#123;</span><br><span class="line">        <span class="comment">//左右扫描指针</span></span><br><span class="line">        <span class="keyword">int</span> i = lo,j = hi + <span class="number">1</span>; </span><br><span class="line">        <span class="comment">//切分元素</span></span><br><span class="line">        Comparable v = a[lo];  </span><br><span class="line">        <span class="comment">//扫描左右，检查扫描是否结束并交换元素，遍历结束后数组被切分为两部分，一边小于切分元素，一边大于切分元素</span></span><br><span class="line">        <span class="keyword">while</span>(<span class="keyword">true</span>)&#123;</span><br><span class="line">            <span class="comment">//循环遍历直到找到大于v元素或游标到底</span></span><br><span class="line">            <span class="keyword">while</span>(less(a[++i],v))</span><br><span class="line">                <span class="keyword">if</span>(i == hi) <span class="keyword">break</span>;</span><br><span class="line">            <span class="comment">//循环遍历直到找到小于v元素或游标到头</span></span><br><span class="line">            <span class="keyword">while</span>(less(v,a[--j]))</span><br><span class="line">                <span class="keyword">if</span>(j == lo) <span class="keyword">break</span>;</span><br><span class="line">            <span class="comment">//若游标交叉则表示以遍历所有元素，结束</span></span><br><span class="line">            <span class="keyword">if</span>(i &gt;= j) <span class="keyword">break</span>;</span><br><span class="line">            <span class="comment">//交换两边元素</span></span><br><span class="line">            exch(a,i,j);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//将v=a[j]放入正确位置</span></span><br><span class="line">        exch(a,lo,j); </span><br><span class="line">        <span class="comment">//a[lo...j-1] &lt;= a[j] &lt;= a[j+1...hi] 达成</span></span><br><span class="line">        <span class="keyword">return</span> j;    </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="2-5-4-排序轨迹"><a href="#2-5-4-排序轨迹" class="headerlink" title="2.5.4 排序轨迹"></a><strong>2.5.4 排序轨迹</strong></h4><p>递归调用排序子数组 <code>a[lo...hi]</code> ，先用 <code>partition()</code> 方法将 <code>a[j]</code> 放到一个合适位置，然后再用递归调用将其他位置的元素排序。</p>
<p><img src="https://pic-1258215793.cos.ap-shanghai.myqcloud.com/content/20200601/202006010114.jpg" alt></p>
<p>归纳法证明快排正确性：若左子数组和右子数组都是有序的，那么左子数组、切分元素和右子数组组成的结果数组也一定有序。</p>
<p>快速排序的重点是<strong>切分方法</strong>，一般策略是先随意的选取 <code>a[lo]</code> 作为<strong>切分元素</strong>，然后从数组的左端开始向右端扫描知道找到一个大于等于它的元素，再从数组的右端开始向左扫描直到找到一个小于等于它的元素。然后交换两者的位置，如此遍历一轮可以保证左侧元素都小于切分元素、右侧元素都大于切分元素。当两个指针相遇时，只须将切分元素 <code>a[lo]</code> 和左子数组最右侧的元素 <code>a[j]</code> 交换并返回 <code>j</code> 即可，过程如下图所示。</p>
<p><img src="https://pic-1258215793.cos.ap-shanghai.myqcloud.com/content/20200601/202006010115.jpg" alt></p>
<p>切分方法轨迹如下图所示。</p>
<p><img src="https://pic-1258215793.cos.ap-shanghai.myqcloud.com/content/20200601/202006010116.jpg" alt></p>
<h4 id="2-5-5-可能导致实现错误和性能下降的细节"><a href="#2-5-5-可能导致实现错误和性能下降的细节" class="headerlink" title="2.5.5 可能导致实现错误和性能下降的细节"></a><strong>2.5.5 可能导致实现错误和性能下降的细节</strong></h4><ol>
<li><strong>原地切分</strong>：我们用数组来辅助切分的话这当然是容易实现的，但这会增加复制过程的开销，有些经验较差的新手甚至可能会把空数组创建在递归过程，这会大大降低排序速度。</li>
<li><strong>不要越界</strong>：如果切分元素可能是最小或最大元素，就要小心不要将扫描指针跑出数组边界，在切分方法中可以检测来避免。</li>
<li><strong>终止循环</strong>：循环结束需要额外小心，常见的错误是没有考虑到数组中可能包含和切分元素值相同的其他元素。</li>
<li><strong>切分元素有重复如何处理</strong>：左侧扫描在遇到大于等于即停下，右侧小于等于时停下，虽然会进行等值交换，但会避免一些情况下运行时间变为平方级别。</li>
<li><strong>终止递归</strong>：快排常见的错误是忘记把切分元素放回正确的位置，导致切分元素一直是子数组的最大或最小元素，导致无限的递归循环。</li>
</ol>
<h4 id="2-5-6-运行时间"><a href="#2-5-6-运行时间" class="headerlink" title="2.5.6 运行时间"></a><strong>2.5.6 运行时间</strong></h4><p>快速排序切分方法的内循环<strong>通过一个递增的索引</strong>将数组元素和一个固定值来进行比较，这是最短的内循环了，如归并排序和希尔排序它们的内循环会移动数据。</p>
<p>快速排序比较次数很少，其<strong>排序效率依赖于切分数组的效果</strong>，最好就是每次都对半切分数组，这种情况下比较次数满足分支递归的 <code>CN</code> = <code>2C(N/2)</code> + <code>N</code> 公式，其中 <code>2C(N/2)</code> 表示将两个子数组排序的成本，<code>N</code> 表示用切分元素和所有数组元素进行比较的成本，这个公式的解为 <code>CN</code> ~ <code>NlgN</code> 。</p>
<blockquote>
<p>命题：<strong>将长度为N的无重复元素数组排序，快速排序平均需要 ~ <code>2NlnN</code> 次比较，以及 <code>1/6</code> 的交换</strong>。</p>
<p>证明：<code>CN</code> 为将N个不同元素排序平均所需的比较次数。很明显 <code>C0</code> = <code>C1</code> = 0，对于 <code>N &gt; 1</code> ，由递归程序可以得到以下归纳关系：</p>
<p>​                     CN = N + 1 + (C0 + C1 + … + C(N-2) + C(N-1)) / N + (C(N-1) + C(N-2) + … + C0) / N</p>
<p>第一项是切分的成本（总是N+1），第二项是将左子数组排序的平均成本，第三项是将右子数组（长度和左子数组相同）排序的平均成本。将等式左右两边乘以N并整理各项得到：</p>
<p>​                                 NCN = N (N + 1) + 2(C0 + C1 + … + C(N-2) + C(N-1))</p>
<p>将该等式减去 <code>N - 1</code> 时的相同等式可得：</p>
<p>​                                              NCN - (N - 1)C(N - 1) = 2N + 2C(N - 1)</p>
<p>整理等式并将两边除以 <code>N(N + 1)</code> 可得：</p>
<p>​                                              CN / (N + 1) = C(N - 1) / N + 2 / (N + 1)</p>
<p>归纳法推导可得：</p>
<p>​                                              CN ~ 2(N + 1)(1/3 + 1/4 + … + 1 / (N + 1))</p>
<p>括号内的量是曲线 <code>2 / x</code> 下从3到N的离散近似面积加一，积分得到 <code>CN ~ 2NlnN</code> 。注意 <code>2NlnN</code> ≈ <code>1.39NlgN</code> ，也就是说平均比较次数只比最好情况多39%。</p>
</blockquote>
<blockquote>
<p>命题：<strong>快速排序最多需要 <code>N^2/2</code> 次比较，但随机打乱数组能够预防这种情况。</strong></p>
<p>证明：在每次切分后两个子数组之一总是空的情况下，比较次数为：</p>
<p>​                                         N + (N - 1) + … + (N - 2) + 2 + 1 = (N + 1) N / 2</p>
<p>这说明了算法所需时间为平方级别，所需空间是线性的，而这对于大数组来说是不可接受的。比较次数的标准差为0.65N，因此随着N的增大，运行时间会趋于平均数，且不可能与平均数偏差太大。</p>
</blockquote>
<h4 id="2-5-7-改进快速排序算法"><a href="#2-5-7-改进快速排序算法" class="headerlink" title="2.5.7 改进快速排序算法"></a><strong>2.5.7 改进快速排序算法</strong></h4><p>基于以下两点原因，可以发现快速排序在使用时的一些改进空间：</p>
<ol>
<li>小数组，快速排序比插入排序慢。</li>
<li>因为递归，快速排序的 <code>sort()</code> 方法在小数组中也会调用自己。</li>
</ol>
<h5 id="（1）根据数组大小切换到插入排序"><a href="#（1）根据数组大小切换到插入排序" class="headerlink" title="（1）根据数组大小切换到插入排序"></a><strong>（1）根据数组大小切换到插入排序</strong></h5><p>简单的写法是把 <code>sort()</code> 中的</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span>(hi &lt;= lo) <span class="keyword">return</span>;</span><br></pre></td></tr></table></figure>
<p>修改为</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span>(hi &lt;= lo + M) &#123;</span><br><span class="line">  		Insertion.sort(a,lo,hi);</span><br><span class="line">  		<span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>非常机智的改法，指定参数M，只要排序数组大小符合就转换为插入排序，一般认为M在 <code>5</code> 到 <code>15</code> 很合适。</p>
<h5 id="（2）三取样切分"><a href="#（2）三取样切分" class="headerlink" title="（2）三取样切分"></a><strong>（2）三取样切分</strong></h5><p>该方法是使用子数组的一小部分元素的<strong>中位数</strong>来切分数组，这样得到的切分会更好。虽然多了计算中位数的开销，根据统计取样大小为 <code>3</code> 时并用大小居中的元素切分效果是最好的。我们可以将取样元素放在数组末尾作为<strong>哨兵</strong>代替切分方法的数组边界测试。</p>
<h5 id="（3）熵最优排序"><a href="#（3）熵最优排序" class="headerlink" title="（3）熵最优排序"></a><strong>（3）熵最优排序</strong></h5><p>当数组内有大量的重复元素时，快速排序有很大的改进空间，简单的想法就是将数组切分为<strong>三部分</strong>，分别对应小于等于大于切分元素的数组元素。但这种切分实现起来会相比二分法更复杂。</p>
<p>E. W. Dijkstra的<strong>荷兰国旗问题</strong>，就是同样的问题：现有红白蓝三种不同颜色的小球，乱序排列在一起，请重新排列这些小球，使得红白蓝三色的同颜色的球在一起。</p>
<h4 id="2-5-8-三向切分法的快速排序"><a href="#2-5-8-三向切分法的快速排序" class="headerlink" title="2.5.8 三向切分法的快速排序"></a><strong>2.5.8 三向切分法的快速排序</strong></h4><p>Dijkstra的解法如<strong>三向切分的快速排序</strong>算法代码，从左到右遍历数组一次，维护一个指针 <code>lt</code> 使得 <code>a[lo...lt-1]</code> 中的元素都<strong>小于v</strong>，一个指针 <code>gt</code> 使得 <code>a[gt+1...hi]</code> 中的元素都<strong>大于v</strong>，一个指针 <code>i</code> 使得 <code>a[lt..i-1]</code> 元素都<strong>等于v</strong>，<code>a[i...gt]</code> 中的元素还未确定，如下图所示。</p>
<p><img src="https://pic-1258215793.cos.ap-shanghai.myqcloud.com/content/20200601/202006010117.jpg" alt></p>
<p>一开始i和lo相等，通过 <code>Comparable</code> 接口（而非 <code>less()</code> ）对 <code>a[i]</code> 进行三向比较来直接处理以下情况：</p>
<ul>
<li><p><code>a[i]</code> 小于v，将 <code>a[lt]</code> 和 <code>a[i]</code> 交换，将lt和i加一；</p>
</li>
<li><p><code>a[i]</code> 大于v，将 <code>a[gt]</code> 和 <code>a[i]</code> 交换，将gt减一；</p>
</li>
<li><p><code>a[i]</code> 等于v，将i加一。</p>
</li>
</ul>
<p>这些操作都会保证数组元素不变且缩小 <code>gt-i</code> 的值（这样循环才会结束）。另外，除非和切分元素相等，其他元素都会被交换。</p>
<p>20世纪70年代，快排刚发布不久这段代码就出现了，可它并没有流行开，因为<strong>在数组重复元素不多的普遍情况下，它比标准的二分法多使用了很多次交换</strong>。90年代时，J. Bently和D. Mcilory找到了一个聪明的方法解决了此问题，使得三向切分的快速排序比归并排序和其他排序方法在包括重复元素很多的实际应用中更快。</p>
<p>但我们证明过归并排序是最优的，所以快排是如何突破了归并排序的下界？对于含有以任意概率分布的重复元素的输入，归并排序无法保证最佳性能。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">sort</span><span class="params">(Comparable[] a)</span></span>&#123;</span><br><span class="line">    sort(a,<span class="number">0</span>,a.length-<span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">sort</span><span class="params">(Comparable[] a,<span class="keyword">int</span> lo,<span class="keyword">int</span> hi)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(hi &lt;= lo) <span class="keyword">return</span>;</span><br><span class="line">    <span class="keyword">int</span> lt = lo,i = lo + <span class="number">1</span>,gt = hi;</span><br><span class="line">    Comparable v = a[lo];</span><br><span class="line">    <span class="keyword">while</span>(i &lt;= gt)&#123;</span><br><span class="line">        <span class="comment">//通过与切分元素比较</span></span><br><span class="line">        <span class="keyword">int</span> cmp = a[i].compareTo(v);</span><br><span class="line">        <span class="keyword">if</span>(cmp &lt; <span class="number">0</span>) exch(a,lt++,i++);</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(cmp &gt; <span class="number">0</span>) exch(a,i,gt--);</span><br><span class="line">        <span class="keyword">else</span> i++;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//a[lo..lt-1] &lt; v = a[lt..gt] &lt; a[gt+1..hi]</span></span><br><span class="line">    sort(a,lo,lt-<span class="number">1</span>);</span><br><span class="line">    sort(a,gt+<span class="number">1</span>,hi);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这段排序代码的切分能够将和切分元素相等的元素归位，这样它们就不会被包含在递归调用处理的子数组之中了。对于存在大量重复元素的数组，这种方法比标准的快速排序的效率高得多，三向分切的快速排序的可视轨迹如下图所示。</p>
<p><img src="https://pic-1258215793.cos.ap-shanghai.myqcloud.com/content/20200601/202006010118.jpg" alt></p>
<p>对于随机数组，归并排序的时间复杂度是线性对数的，而三向切分的快速排序则是线性的。如上图，可推测主键值数量的N倍是运行时间的一个保守上界。对于标准的快速排序，随着数组规模的增大，其运行时间会趋于平均运行时间，大幅偏离的情况非常罕见，因此可以肯定三向切分的快速排序的运行时间和输入的信息量的N倍成正比的。<strong>对于包含大量重复元素的数组，它将排序时间从线性对数级降低到线性级别</strong>。</p>
<h4 id="2-5-9-特点"><a href="#2-5-9-特点" class="headerlink" title="2.5.9 特点"></a><strong>2.5.9 特点</strong></h4><ul>
<li>使用广泛，排序性能非常高效。</li>
<li>快速排序比归并排序比较次数会多一些，但移动数据次数要少，最终也会比归并排序快。</li>
<li>容易因一些错误导致性能大幅下降。</li>
<li>潜在缺点是<strong>切分不平衡时排序性能可能会极为低效</strong>。</li>
<li>三向切分的快速排序是包含大量重复元素的数组排序情况的最佳选择。</li>
</ul>
<hr>
<h3 id="2-6-优先队列"><a href="#2-6-优先队列" class="headerlink" title="2.6 优先队列"></a><strong>2.6 优先队列</strong></h3><h4 id="2-6-1-概述"><a href="#2-6-1-概述" class="headerlink" title="2.6.1 概述"></a><strong>2.6.1 概述</strong></h4><p>许多情况下都需要处理有序的元素，但不一定要求所有元素都有序，或是一次就要全部排序。比如一些需求要收集一堆元素后处理当前最大元素，然后再收集一部分元素，再处理此时最大元素（如OS为应用分配优先级）。</p>
<p>在这种情况下，需要一种数据结构能够支持两种操作：<strong>删除最大元素</strong>和<strong>插入元素</strong>。这样的数据结构叫<strong>优先队列</strong>，优先队列类似于队列（删除最老的元素）以及栈（删除最新的元素）。<strong>二叉堆</strong>是一种实现优先队列的经典方法，优先队列可以用来实现排序算法：插入一列元素，一个一个的删掉最小元素。<strong>堆排序</strong>就是基于堆的优先队列的一种实现，当然优先队列也会用来构造图搜索算法等。</p>
<p><strong>优先队列</strong>：支持两种操作（删除最大元素和插入元素）的一种<strong>抽象数据类型</strong>。</p>
<h4 id="2-6-2-API"><a href="#2-6-2-API" class="headerlink" title="2.6.2 API"></a><strong>2.6.2 API</strong></h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MaxPQ</span>&lt;<span class="title">Key</span> <span class="keyword">extends</span> <span class="title">Comparable</span>&lt;<span class="title">Key</span>&gt;&gt;</span></span><br></pre></td></tr></table></figure>
<table>
<thead>
<tr>
<th>方法</th>
<th>描述</th>
</tr>
</thead>
<tbody>
<tr>
<td>MaxPQ()</td>
<td>创建一个优先队列</td>
</tr>
<tr>
<td>MaxPQ(int max)</td>
<td>创建一个初始容量为max的优先队列</td>
</tr>
<tr>
<td>MaxPQ(Key[] a)</td>
<td>用a[]中的元素创建一个优先队列</td>
</tr>
<tr>
<td>void Insert(Key v)</td>
<td>向优先队列中插入一个元素</td>
</tr>
<tr>
<td>Key max()</td>
<td>返回最大元素</td>
</tr>
<tr>
<td>Key delMax()</td>
<td>删除并返回最大元素</td>
</tr>
<tr>
<td>boolean isEmpty()</td>
<td>返回队列是否为空</td>
</tr>
<tr>
<td>int size()</td>
<td>返回优先队列中的元素个数</td>
</tr>
</tbody>
</table>
<h4 id="2-6-3-调用示例"><a href="#2-6-3-调用示例" class="headerlink" title="2.6.3 调用示例"></a><strong>2.6.3 调用示例</strong></h4><p>考虑一个问题：<strong>输入N个字符串，每个字符串都对映着一个整数，从中超出最大（或最小）的M个整数（及其关联的字符串）</strong>。</p>
<p>解决这一问题，我们首先会想到使用排序算法，但如果加上一个前提：输入很大甚至可能是无限的，那么普通的排序算法就派不上用场了。另外一种方法是将每个新的输入和已知的M个最大元素比较，但除非M值较小，否则这种比较的代价很大。此处我们可以利用优先队列，只有实现了高效的 <code>insert()</code> 和 <code>delMin()</code> 就可以解决这个问题。</p>
<p>从N个输入中找到最大的M个元素所需成本：</p>
<table>
<thead>
<tr>
<th style="text-align:center">算法</th>
<th>时间</th>
<th>空间</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">排序算法</td>
<td>NlogN</td>
<td>N</td>
</tr>
<tr>
<td style="text-align:center">初级实现的优先队列</td>
<td>NM</td>
<td>M</td>
</tr>
<tr>
<td style="text-align:center">基于堆实现的优先队列</td>
<td>NlogM</td>
<td>M</td>
</tr>
</tbody>
</table>
<p>实现代码如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TopM</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span>&#123;</span><br><span class="line">        <span class="comment">// 打印输入流中最大的M行</span></span><br><span class="line">        <span class="keyword">int</span> M = Integer.parseInt(args[<span class="number">0</span>]);</span><br><span class="line">        MinPQ&lt;Transaction&gt; pq = <span class="keyword">new</span> MinPQ&lt;Transaction&gt;(M+<span class="number">1</span>);</span><br><span class="line">        <span class="keyword">while</span>(StdIn.hasNextLine())&#123;</span><br><span class="line">            <span class="comment">// 为下一行输入创建一个元素并放入优先队列中</span></span><br><span class="line">            pq.insert(<span class="keyword">new</span> Transaction(StdIn.readLine()));</span><br><span class="line">            <span class="keyword">if</span>(pq.size() &gt; M)&#123;</span><br><span class="line">                pq.delMin(); <span class="comment">// 如果优先队列中存在M+1个元素则删除其中最小的元素</span></span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 最大的M个元素都在优先队列中</span></span><br><span class="line">            Stack&lt;Transaction&gt; stack = <span class="keyword">new</span> Stack&lt;Transaction&gt;();</span><br><span class="line">            <span class="keyword">while</span>(!pq.isEmpty()) stack.push(pq.delMin());</span><br><span class="line">            <span class="keyword">for</span>(Transaction t : stack) StdOut.println(t);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="2-6-4-初级实现"><a href="#2-6-4-初级实现" class="headerlink" title="2.6.4 初级实现"></a><strong>2.6.4 初级实现</strong></h4><p>实现优先队列的几种方式：</p>
<ol>
<li><strong>数组实现</strong>（无序）：利用栈（先进后出）来实现，插入元素就是入栈，内部需要类似选择排序的内循环的代码，将最大元素和边界元素交换并删除它，删除就是出栈，<strong>等同于插入排序</strong>。</li>
<li><strong>数组实现</strong>（有序）：在入栈时添加操作，让较大元素向右移动，保证数组总是有序的，最大的元素总是在边界，删除就完全和出栈一样了。</li>
<li><strong>链表表示法</strong>：基于链表的下压栈，使用有序或无序序列就是积极和惰性方法之分，无序即只在必要的时候再选择行动，有序则是尽量未雨绸缪以保证后续操作更加高效。基于栈和队列这些初级实现来说，两个操作总会在最坏情况下需要线性时间来完成，但<strong>基于堆可以把时间从 <code>N</code> 改善到 <code>logN</code> </strong>。</li>
<li><strong>数组（堆）实现</strong>：数组实现的完全二叉树可以高效的实现优先队列，能够实现指数级的插入元素和删除最大元素的操作，<strong>基于堆的优先队列即堆排序</strong>。</li>
</ol>
<table>
<thead>
<tr>
<th style="text-align:left">数据结构</th>
<th>插入元素</th>
<th>删除最大元素</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left">有序数组</td>
<td>N</td>
<td>1</td>
</tr>
<tr>
<td style="text-align:left">无序数组</td>
<td>1</td>
<td>N</td>
</tr>
<tr>
<td style="text-align:left">堆</td>
<td>logN</td>
<td>logN</td>
</tr>
<tr>
<td style="text-align:left">理想情况</td>
<td>1</td>
<td>1</td>
</tr>
</tbody>
</table>
<p><img src="https://pic-1258215793.cos.ap-shanghai.myqcloud.com/content/20200601/202006010119.jpg" alt></p>
<h4 id="2-6-5-堆的定义"><a href="#2-6-5-堆的定义" class="headerlink" title="2.6.5 堆的定义"></a><strong>2.6.5 堆的定义</strong></h4><p><strong>二叉堆</strong>能够很好的实现优先队列的基本操作。在二叉堆数组中，每个元素都要保证大于等于另两个特定位置的元素。</p>
<blockquote>
<p>当一棵二叉树的每个结点都大于等于它的两个子结点时，它被称为<strong>堆有序</strong>。</p>
</blockquote>
<blockquote>
<p>根结点是堆有序的二叉树中的<strong>最大结点</strong>。</p>
</blockquote>
<h5 id="二叉堆表示法"><a href="#二叉堆表示法" class="headerlink" title="二叉堆表示法"></a><strong>二叉堆表示法</strong></h5><p>如果用指针来表示堆有序的二叉树，那么每个元素都需要三个指针来找到其上下结点。但如图所示，使用<strong>完全二叉树</strong>表达会变得简单，只须定义一个根结点，一层一层由上至下由左至右，从每个结点下方连接两个更小的结点，直至N个结点连接完毕。完全二叉树只须用数组而不用指针就可以表示，方法就是将结点按层级顺序放入数组（不使用数组第一个位置），根结点在1，第二层在2和3，第三层在4、5、6和7，以此类推。</p>
<p><img src="https://pic-1258215793.cos.ap-shanghai.myqcloud.com/content/20200601/202006010120.jpg" alt></p>
<p>在一个堆中，位置 <code>K</code> 结点的父结点位置为 <code>k/2</code> ，子结点位置分别为 <code>2k</code> 、<code>2k+1</code> ，所以在不使用指针时可以通过计算索引的方法在树上移动。   </p>
<blockquote>
<p>一棵大小为N的完全二叉树的高度为 <code>lgN</code> 。</p>
</blockquote>
<p><img src="https://pic-1258215793.cos.ap-shanghai.myqcloud.com/content/20200601/202006010121.jpg" alt></p>
<h4 id="2-6-6-堆的算法"><a href="#2-6-6-堆的算法" class="headerlink" title="2.6.6 堆的算法"></a><strong>2.6.6 堆的算法</strong></h4><p>用长度为 <code>N+1</code> 的私有数组 <code>pq[]</code> 来表示一个大小为N的堆，弃用 <code>pq[0]</code> ，堆元素放于1到N中。堆的操作首先需要打破堆的状态，然后再遍历堆按要求将堆的状态恢复，这个过程叫做<strong>堆的有序化</strong>。</p>
<p><strong>有序化过程的问题</strong>：<strong>某个结点优先级上升，需要由下至上的恢复堆的顺序</strong>。<strong>某个结点优先级下降，需要由上至下恢复堆的顺序</strong>。</p>
<h5 id="上浮和下沉"><a href="#上浮和下沉" class="headerlink" title="上浮和下沉"></a><strong>上浮和下沉</strong></h5><ul>
<li><strong>由下至上的堆有序化</strong>（上浮）：将比父结点更大的结点和父结点互换，持续这一过程直到遇到比自己大的父结点，只要知道位置 <code>k</code> 的父结点为 <code>k/2</code> 这个过程实现十分容易。</li>
<li><strong>由上至下的堆有序化</strong>（下浮）：将父结点和子结点中较大者交换位置来恢复堆有序，交换后可能仍需要继续往下交换，直到其子结点都更小或到了底部。</li>
</ul>
<blockquote>
<p>可以将这两种过程看作严密的黑社会组织，每个子结点表示一个下属，<code>swim()</code> 过程即一位强力新人加入组织，逐级提升，直到有一个比他强力的领导，而 <code>sink()</code> 过程为某级领导退休被外来者替代，该外来者需要被强力的下属替换，直到没有能力比其强的下属为止。</p>
</blockquote>
<p>上浮和下沉操作过程如下图：</p>
<p><img src="https://pic-1258215793.cos.ap-shanghai.myqcloud.com/content/20200601/202006010122.jpg" alt></p>
<p>上浮和下沉操作的应用：</p>
<ul>
<li><strong>插入元素</strong>：将新元素加到数组末尾，增加堆的大小，并让新元素<strong>上浮</strong>到合适位置。</li>
<li><strong>删除最大元素</strong>：从数组顶端删去最大的元素并将数组的最后一个元素放到顶端，减小堆的大小，并让此元素<strong>下沉</strong>到合适位置。</li>
</ul>
<p><img src="https://pic-1258215793.cos.ap-shanghai.myqcloud.com/content/20200601/202006010123.jpg" alt></p>
<h5 id="基于堆的优先队列实现代码"><a href="#基于堆的优先队列实现代码" class="headerlink" title="基于堆的优先队列实现代码"></a><strong>基于堆的优先队列实现代码</strong></h5><p>基于堆的二叉树实现优先队列的代码如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MaxPQ</span>&lt;<span class="title">T</span> <span class="keyword">extends</span> <span class="title">Comparable</span>&lt;<span class="title">T</span>&gt;&gt; </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> T[] pq;    <span class="comment">// 基于堆的完全二叉树</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> N = <span class="number">0</span>; <span class="comment">// 存储于pq[1..N]中，pq[0]没有使用</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">MaxPQ</span><span class="params">(<span class="keyword">int</span> maxN)</span></span>&#123;</span><br><span class="line">        pq = (T[]) <span class="keyword">new</span> Comparable[maxN+<span class="number">1</span>];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isEmpty</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> N == <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">size</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> N;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">insert</span><span class="params">(T t)</span></span>&#123;</span><br><span class="line">        pq[++N] = t;     <span class="comment">// 新增结点</span></span><br><span class="line">        swim(N);         <span class="comment">// 由下至上恢复堆的有序性</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> T <span class="title">delMax</span><span class="params">()</span></span>&#123;</span><br><span class="line">        T max = pq[<span class="number">1</span>];   <span class="comment">// 从根节点得到最大元素</span></span><br><span class="line">        exch(<span class="number">1</span>, N--);    <span class="comment">// 将其和最后一个结点交换</span></span><br><span class="line">        pq[N+<span class="number">1</span>] = <span class="keyword">null</span>;  <span class="comment">// 防止对象游离</span></span><br><span class="line">        sink(<span class="number">1</span>);         <span class="comment">// 由上至下恢复堆的有序性</span></span><br><span class="line">        <span class="keyword">return</span> max;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 堆的比较方法</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">boolean</span> <span class="title">less</span><span class="params">(<span class="keyword">int</span> i, <span class="keyword">int</span> j)</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> pq[i].compareTo(pq[j]) &lt; <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 堆的交换方法</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">exch</span><span class="params">(<span class="keyword">int</span> i, <span class="keyword">int</span> j)</span></span>&#123;</span><br><span class="line">        T t = pq[i];</span><br><span class="line">        pq[i] = pq[j];</span><br><span class="line">        pq[j] = t;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 上浮</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">swim</span><span class="params">(<span class="keyword">int</span> k)</span></span>&#123;</span><br><span class="line">        <span class="comment">// 循环判断条件，k&gt;1，父结点的值比当前小</span></span><br><span class="line">        <span class="keyword">while</span> (k &gt; <span class="number">1</span> &amp;&amp; less(k/<span class="number">2</span>,k))&#123;</span><br><span class="line">        	<span class="comment">// 交换当前结点和父结点的值，以及当前游标所指下标</span></span><br><span class="line">            exch(k/<span class="number">2</span>,k);</span><br><span class="line">            k = k/<span class="number">2</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 下沉</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">sink</span><span class="params">(<span class="keyword">int</span> k)</span></span>&#123;</span><br><span class="line">        <span class="comment">// 循环判断条件，当前游标所指有子结点存在</span></span><br><span class="line">        <span class="keyword">while</span> (<span class="number">2</span>*k &lt;= N)&#123;</span><br><span class="line">            <span class="keyword">int</span> j = <span class="number">2</span>*k;</span><br><span class="line">            <span class="comment">// 当子结点不是最后结点，且子结点小于右子结点，指较大的那个子结点</span></span><br><span class="line">            <span class="keyword">if</span>(j &lt; N &amp;&amp; less(j,j+<span class="number">1</span>))</span><br><span class="line">                j++;</span><br><span class="line">            <span class="comment">// 如果当前结点比子结点大就跳出循环</span></span><br><span class="line">            <span class="keyword">if</span>(!less(k,j))</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="comment">// 交换，更新游标</span></span><br><span class="line">            exch(k,j);</span><br><span class="line">            k = j;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>命题：<strong>对于一个含 <code>N</code> 个元素的基于堆的优先队列，插入元素操作只需不超过 <code>lgN+1</code> 次比较，删除最大元素只需不超过 <code>2lgN</code> 次比较</strong>。</p>
<p>证明：两种操作都需要在根结点和堆底之间移动元素，路径长度不超过 <code>lgN</code> 。对于路径上的每个结点，删除最大元素操作需要两次比较（除了堆底元素），一次用来找出较大的子结点，一次用来确定该子结点是否需要上浮。</p>
</blockquote>
<p>此性能突破了使用有序或无序数组实现的优先队列总需线性时间来完成其中一种操作，基于堆的实现保证了对数时间内完成。</p>
<h5 id="多叉堆"><a href="#多叉堆" class="headerlink" title="多叉堆"></a><strong>多叉堆</strong></h5><p>基于用数组表示的完全三叉树构造堆并修改相应代码并不困难，对于数组1至N个元素，位置 <code>k</code> 的结点大于等于位于 <code>3K-1</code> 、<code>3k</code> 和 <code>3k+1</code> 的结点，小于等于位于 <code>(k+1)/3</code> 的结点。甚至对于任意D叉树改动都不困难。</p>
<p><img src="https://pic-1258215793.cos.ap-shanghai.myqcloud.com/content/20200601/202006010124.jpg" alt></p>
<h4 id="2-6-7-基于堆的索引优先队列"><a href="#2-6-7-基于堆的索引优先队列" class="headerlink" title="2.6.7 基于堆的索引优先队列"></a><strong>2.6.7 基于堆的索引优先队列</strong></h4><p>很多应用中，已进入优先队列的元素也需要被外部引用，一个简单的实现方法是<strong>为元素增加索引</strong>。</p>
<p>基于堆的索引优先队列(IndexMinPQ)</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">IndexMinPQ</span>&lt;<span class="title">Item</span> <span class="keyword">extends</span> <span class="title">Comparable</span>&lt;<span class="title">Item</span>&gt;&gt;</span></span><br></pre></td></tr></table></figure>
<table>
<thead>
<tr>
<th style="text-align:center">方法</th>
<th>描述</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">IndexMinPQ(int maxN)</td>
<td>创建一个最大容量为maxN的优先队列，索引的取值范围为0至maxN-1</td>
</tr>
<tr>
<td style="text-align:center">void insert(int k, Item item)</td>
<td>插入一个元素，将它和索引k相关联</td>
</tr>
<tr>
<td style="text-align:center">void change(int k, Item item)</td>
<td>将索引为k的元素设为item</td>
</tr>
<tr>
<td style="text-align:center">boolean contains(int k)</td>
<td>是否存在索引为k的元素</td>
</tr>
<tr>
<td style="text-align:center">void delete(int k)</td>
<td>删去索引k及其相关联的元素</td>
</tr>
<tr>
<td style="text-align:center">Item min()</td>
<td>返回最小元素</td>
</tr>
<tr>
<td style="text-align:center">int minIndex()</td>
<td>返回最小元素的索引</td>
</tr>
<tr>
<td style="text-align:center">int delMin()</td>
<td>删除最小元素并返回它的索引</td>
</tr>
<tr>
<td style="text-align:center">boolean isEmpty()</td>
<td>优先队列是否为空</td>
</tr>
<tr>
<td style="text-align:center">int size()</td>
<td>优先队列中的元素数量</td>
</tr>
</tbody>
</table>
<p>IndexMinPQ可以快速访问数组的一个特定子集中的最小元素（指所有被插入的元素），在一个大小为N的索引优先队列中，插入元素，改变优先级，删除，删除最小元素操作所需的比较次数和logN成正比</p>
<p>1</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">IndexMinPQ</span>&lt;<span class="title">T</span> <span class="keyword">extends</span> <span class="title">Comparable</span>&lt;<span class="title">T</span>&gt;&gt; </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> N;       <span class="comment">//PQ中的元素数量</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span>[] pq;    <span class="comment">//索引二叉堆，由1开始</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span>[] qp;    <span class="comment">//逆序，qp[pq[i]] = pq[qp[i]] = i</span></span><br><span class="line">    <span class="keyword">private</span> T[] keys;    <span class="comment">//有优先级之分的元素</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">IndexMinPQ</span><span class="params">(<span class="keyword">int</span> maxN)</span></span>&#123;</span><br><span class="line">        keys = (T[]) <span class="keyword">new</span> Comparable[maxN + <span class="number">1</span>];</span><br><span class="line">        pq = <span class="keyword">new</span> <span class="keyword">int</span>[maxN + <span class="number">1</span>];</span><br><span class="line">        qp = <span class="keyword">new</span> <span class="keyword">int</span>[maxN + <span class="number">1</span>];</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>;i &lt;= maxN; i++)</span><br><span class="line">            qp[i] = -<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isEmpty</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> N == <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">comtains</span><span class="params">(<span class="keyword">int</span> k)</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> qp[k] != -<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">size</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> N;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">insert</span><span class="params">(<span class="keyword">int</span> k,T t)</span></span>&#123;</span><br><span class="line">        N++;</span><br><span class="line">        qp[k] = N;</span><br><span class="line">        pq[N] = k;</span><br><span class="line">        keys[k] = t;</span><br><span class="line">        swim(N);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> T <span class="title">min</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> keys[pq[<span class="number">1</span>]];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">delMin</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">int</span> indexOfMin = pq[<span class="number">1</span>];</span><br><span class="line">        exch(<span class="number">1</span>,N--);</span><br><span class="line">        sink(<span class="number">1</span>);</span><br><span class="line">        keys[pq[N+<span class="number">1</span>]] = <span class="keyword">null</span>;</span><br><span class="line">        qp[pq[N+<span class="number">1</span>]] = -<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">return</span> indexOfMin;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">minIndex</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> pq[<span class="number">1</span>];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">change</span><span class="params">(<span class="keyword">int</span> k,T t)</span></span>&#123;</span><br><span class="line">        keys[k] = t;</span><br><span class="line">        swim(qp[k]);</span><br><span class="line">        sink(qp[k]);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">delete</span><span class="params">(<span class="keyword">int</span> k)</span></span>&#123;</span><br><span class="line">        <span class="keyword">int</span> index = qp[k];</span><br><span class="line">        exch(index,N--);</span><br><span class="line">        swim(index);</span><br><span class="line">        sink(index);</span><br><span class="line">        keys[k] = <span class="keyword">null</span>;</span><br><span class="line">        qp[k] = -<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">boolean</span> <span class="title">less</span><span class="params">(<span class="keyword">int</span> i, <span class="keyword">int</span> j)</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> keys[i].compareTo(keys[j]) &lt; <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">exch</span><span class="params">(<span class="keyword">int</span> i, <span class="keyword">int</span> j)</span></span>&#123;</span><br><span class="line">        T t = keys[i];</span><br><span class="line">        keys[i] = keys[j];</span><br><span class="line">        keys[j] = t;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">swim</span><span class="params">(<span class="keyword">int</span> k)</span></span>&#123;</span><br><span class="line">        <span class="keyword">while</span> (k &gt; <span class="number">1</span> &amp;&amp; less(k/<span class="number">2</span>,k))&#123;<span class="comment">//循环判断条件，k&gt;1,父结点的值比当前小</span></span><br><span class="line">            <span class="comment">//交换当前结点和父结点的值，以及当前游标所指下标</span></span><br><span class="line">            exch(k/<span class="number">2</span>,k);</span><br><span class="line">            k = k/<span class="number">2</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">sink</span><span class="params">(<span class="keyword">int</span> k)</span></span>&#123;</span><br><span class="line">        <span class="keyword">while</span> (<span class="number">2</span>*k &lt;= N)&#123;<span class="comment">//循环判断条件，当前游标所指有子结点存在</span></span><br><span class="line">            <span class="keyword">int</span> j = <span class="number">2</span>*k;</span><br><span class="line">            <span class="comment">//当子结点不是最后结点，且子结点小于右子结点，指较大的那个子结点</span></span><br><span class="line">            <span class="keyword">if</span>(j &lt; N &amp;&amp; less(j,j+<span class="number">1</span>))</span><br><span class="line">                j++;</span><br><span class="line">            <span class="comment">//如果当前结点比子结点大就跳出循环</span></span><br><span class="line">            <span class="keyword">if</span>(!less(k,j))</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="comment">//交换，更新游标</span></span><br><span class="line">            exch(k,j);</span><br><span class="line">            k = j;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>在一个大小为N的索引优先队列中，插入元素、改变优先级、删除和删除最小元素操作所需的比较次数和 <code>logN</code> 成正比</strong>。</p>
<p>含有N个元素的基于堆的索引优先队列所有操作在最坏情况下的成本：</p>
<table>
<thead>
<tr>
<th style="text-align:center">操作</th>
<th style="text-align:center">比较次数的增长数量级</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">insert()</td>
<td style="text-align:center">logN</td>
</tr>
<tr>
<td style="text-align:center">change()</td>
<td style="text-align:center">logN</td>
</tr>
<tr>
<td style="text-align:center">contains()</td>
<td style="text-align:center">1</td>
</tr>
<tr>
<td style="text-align:center">delete()</td>
<td style="text-align:center">logN</td>
</tr>
<tr>
<td style="text-align:center">min()</td>
<td style="text-align:center">1</td>
</tr>
<tr>
<td style="text-align:center">minIndex()</td>
<td style="text-align:center">1</td>
</tr>
<tr>
<td style="text-align:center">delMin()</td>
<td style="text-align:center">logN</td>
</tr>
</tbody>
</table>
<h5 id="使用案例"><a href="#使用案例" class="headerlink" title="使用案例"></a><strong>使用案例</strong></h5><p><strong>多向归并问题</strong>：将多个有序的输入流归并成一个有序的输出流，输入可能是各种科学仪器的输出值（按时间排序）、可能是来自音乐或电影网站的信息列表（按艺术家名字排序）、可能是商业交易（按账号或时间排序）等。</p>
<p>使用优先队列排序，无论输入有多长都可以全部读入并排序：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Multiway</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">merge</span><span class="params">(In[] streams)</span></span>&#123;</span><br><span class="line">        <span class="comment">// 输入流数目</span></span><br><span class="line">        <span class="keyword">int</span> N = streams.length;</span><br><span class="line">        <span class="comment">// pq为优先队列</span></span><br><span class="line">        IndexMinPQ&lt;String&gt; pq = <span class="keyword">new</span> IndexMinPQ&lt;String&gt;(N);</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 遍历所有输入流</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; N; i++)&#123;</span><br><span class="line">            <span class="comment">// 当此输入流不为空，将输入流插入优先队列</span></span><br><span class="line">            <span class="keyword">if</span>(!streams[i].isEmpty())</span><br><span class="line">                pq.insert(i, streams[i].readString());</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">while</span>(!pq..isEmpty())&#123;</span><br><span class="line">            <span class="comment">// 输出最小值</span></span><br><span class="line">            StdOut.println(pq.min());</span><br><span class="line">            <span class="comment">// 删除并返回最小值的索引</span></span><br><span class="line">            <span class="keyword">int</span> i = pq.delMin();</span><br><span class="line">            </span><br><span class="line">            <span class="comment">// 循环内确保所有输入流都已处理</span></span><br><span class="line">            <span class="keyword">if</span>(!streams[i].isEmpty())</span><br><span class="line">                pq.insert(i, streams[i].readString());</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span>&#123;</span><br><span class="line">        <span class="keyword">int</span> N = args.length;</span><br><span class="line">        In[] streams = <span class="keyword">new</span> In[N];</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; N; i++)&#123;</span><br><span class="line">            streams[i] = <span class="keyword">new</span> In[args[i]];</span><br><span class="line">        &#125;</span><br><span class="line">        merge(streams);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<hr>
<h3 id="2-7-堆排序"><a href="#2-7-堆排序" class="headerlink" title="2.7 堆排序"></a><strong>2.7 堆排序</strong></h3><p>可通过 <code>IndexMinPQ</code> 将多行输入的字符串归并为一行有序的输出，所以优先队列可以变为一种排序方法，其中基于堆的优先队列等同于：<strong>堆排序</strong>。</p>
<p>堆排序：<strong>将所有元素插入一个查找最小元素的优先队列，然后重复调用删除最小元素的操作将元素按顺序删除</strong>。</p>
<p><strong>对于无序数组实现的优先队列就等同于插入排序，而堆排序则是一种全新的排序方法</strong>。</p>
<p>堆排序分为两个阶段：</p>
<ul>
<li><strong>堆的构造阶段</strong>，将原始数组重新安排进一个堆中。</li>
<li><strong>下沉排序阶段</strong>，从堆中按递减顺序取出所有元素并得到排序结果。</li>
</ul>
<h4 id="2-7-1-堆的构造"><a href="#2-7-1-堆的构造" class="headerlink" title="2.7.1 堆的构造"></a><strong>2.7.1 堆的构造</strong></h4><p><strong>如何使给定的N个元素构成一个堆？</strong></p>
<p>一个简单的方法：从左至右遍历数组，用 <strong>上浮</strong> <code>swim()</code> 保证指针左侧的所有元素已经是一棵堆有序的完全树即可，可以在与 <code>NlogN</code> 成正比的时间内完成。</p>
<p>一个高效的方法：从右至左通过<strong>下沉</strong> <code>sink()</code> 函数构造子堆。数组的每个位置都已经是一个子堆的根结点，若一个结点的两个子结点都已经成堆，那么在此结点上调用<code>sink()</code> 函数可以将它们成堆，递归此过程直到最后在位置1调用sink。这一过程可以跳过大小为1的子堆。在堆的构造阶段，最大元素是位于数组的开头，而不是结尾。</p>
<blockquote>
<p>命题：<strong>用下沉操作由N个元素构造堆只须少于2N次比较以及少于N次交换</strong>。</p>
</blockquote>
<h4 id="2-7-2-实现代码"><a href="#2-7-2-实现代码" class="headerlink" title="2.7.2 实现代码"></a><strong>2.7.2 实现代码</strong></h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 堆排序</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Set</span> <span class="keyword">extends</span> <span class="title">SortExample</span> </span>&#123;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> Comparable[] sort(Comparable[] c)&#123;</span><br><span class="line">        Comparable[] a = <span class="keyword">new</span> Comparable[c.length+<span class="number">1</span>];</span><br><span class="line">        <span class="keyword">int</span> N = c.length;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>;i &lt; N;i++)</span><br><span class="line">            a[i+<span class="number">1</span>] = c[i];</span><br><span class="line">        <span class="comment">// for循环构造堆，sink方法将a从1到N排序</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> k = N/<span class="number">2</span>; k &gt;= <span class="number">1</span>; k--)</span><br><span class="line">            sink(a,k,N);</span><br><span class="line">        show(a);</span><br><span class="line">        <span class="comment">// while循环将最大元素a[1]和a[N]交换，并修复堆</span></span><br><span class="line">        <span class="keyword">while</span> (N &gt; <span class="number">1</span>)&#123;</span><br><span class="line">            exch(a,<span class="number">1</span>,N--);</span><br><span class="line">            sink(a,<span class="number">1</span>,N);</span><br><span class="line">            show(a);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> a;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">swim</span><span class="params">(Comparable[] a,<span class="keyword">int</span> k)</span></span>&#123;</span><br><span class="line">        <span class="keyword">while</span> (k &gt; <span class="number">1</span> &amp;&amp; less(k/<span class="number">2</span>,k))&#123;<span class="comment">//循环判断条件，k&gt;1,父结点的值比当前小</span></span><br><span class="line">            <span class="comment">//交换当前结点和父结点的值，以及当前游标所指下标</span></span><br><span class="line">            exch(a,k/<span class="number">2</span>,k);</span><br><span class="line">            k = k/<span class="number">2</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">sink</span><span class="params">(Comparable[] a,<span class="keyword">int</span> k,<span class="keyword">int</span> N)</span></span>&#123;</span><br><span class="line">        <span class="keyword">while</span> (<span class="number">2</span>*k &lt;= N)&#123;<span class="comment">//循环判断条件，当前游标所指有子结点存在</span></span><br><span class="line">            <span class="keyword">int</span> j = <span class="number">2</span>*k;</span><br><span class="line">            <span class="comment">//当子结点不是最后结点，且子结点小于右子结点，指较大的那个子结点</span></span><br><span class="line">            <span class="keyword">if</span>(j &lt; N &amp;&amp; less(a[j],a[j+<span class="number">1</span>]))</span><br><span class="line">                j++;</span><br><span class="line">            <span class="comment">//如果当前结点比子结点大就跳出循环</span></span><br><span class="line">            <span class="keyword">if</span>(!less(a[k],a[j]))</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="comment">//交换，更新游标</span></span><br><span class="line">            exch(a,k,j);</span><br><span class="line">            k = j;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">exch</span><span class="params">(Comparable[] a,<span class="keyword">int</span> i, <span class="keyword">int</span> j)</span></span>&#123;</span><br><span class="line">        Comparable t = a[i];</span><br><span class="line">        a[i] = a[j];</span><br><span class="line">        a[j] = t;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span>&#123;</span><br><span class="line">        <span class="comment">// Integer[] a = RandomUtil.getRandomIndex(10000);</span></span><br><span class="line">        Comparable[] a = &#123;<span class="string">'S'</span>,<span class="string">'O'</span>,<span class="string">'R'</span>,<span class="string">'T'</span>,<span class="string">'E'</span>,<span class="string">'X'</span>,<span class="string">'A'</span>,<span class="string">'M'</span>,<span class="string">'P'</span>,<span class="string">'L'</span>,<span class="string">'E'</span>&#125;;</span><br><span class="line">        Stopwatch stopwatch = <span class="keyword">new</span> Stopwatch();</span><br><span class="line">        a = sort(a);</span><br><span class="line">        System.out.println(stopwatch.elapseTime());</span><br><span class="line">        show(a);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="2-7-3-排序轨迹"><a href="#2-7-3-排序轨迹" class="headerlink" title="2.7.3 排序轨迹"></a><strong>2.7.3 排序轨迹</strong></h4><p>堆排序的轨迹如下图所示，分为两个阶段。</p>
<p><img src="https://pic-1258215793.cos.ap-shanghai.myqcloud.com/content/20200601/202006010127.jpg" alt></p>
<p>堆排序的主要工作都在第二阶段完成，构造阶段通过下沉操作完成堆有序，下沉排序阶段再依次将根结点与当前数组末尾元素交换，并忽略末尾元素即堆缩小（已经处于最终位置），这<strong>很像选择排序但比较次数会少的多</strong>，将此时根结点（较小元素）下沉恢复堆有序，持续此过程直到得到最终排序数组。</p>
<p><img src="https://pic-1258215793.cos.ap-shanghai.myqcloud.com/content/20200601/202006010128.jpg" alt></p>
<p>大多数在下沉排序期间重新插入堆的元素会被直接加入堆底，因为下沉总是会直接提升较大的子结点直至到达堆底，然后再使元素上浮到正确位置，这种改法可以使比较次数减少一半（接近于归并排序的比较次数）。但这种做法需要额外内存空间，所以只会在比较操作比较费时时采用。</p>
<h4 id="2-7-4-运行时间"><a href="#2-7-4-运行时间" class="headerlink" title="2.7.4 运行时间"></a><strong>2.7.4 运行时间</strong></h4><p><strong>将N个元素排序，堆排序只需要少于 <code>2NlgN + 2N</code> 次比较，以及一半次数的交换</strong>。</p>
<h4 id="2-7-5-额外内存空间"><a href="#2-7-5-额外内存空间" class="headerlink" title="2.7.5 额外内存空间"></a><strong>2.7.5 额外内存空间</strong></h4><p><strong>堆排序使用空间是恒定的</strong>，所以在一些嵌入式系统中很流行，但其无法利用缓存导致很多应用很少使用它。数组元素很少和相邻元素比较，因此缓存未命中的次数要远远高于其他算法。但另一方面，用堆实现的优先队列在如今越来越重要，因为其能在<strong>插入元素</strong>和<strong>删除最大元素</strong>这两个基本操作混合的动态场景中保证对数级别的运行时间。</p>
<h4 id="2-7-6-特点"><a href="#2-7-6-特点" class="headerlink" title="2.7.6 特点"></a><strong>2.7.6 特点</strong></h4><ul>
<li>唯一能够同时最优地利用空间和时间的方法，最坏情况下也能保证 ~ <code>2NlgN</code> 次比较和恒定的额外空间。</li>
<li>排序过程分两个阶段。</li>
<li>无法有效利用缓存。</li>
<li>能在<strong>插入元素</strong>和<strong>删除最大元素</strong>这两个基本操作混合的动态场景中保证对数级别的运行时间。</li>
</ul>
<hr>
<h2 id="第三节-归纳总结"><a href="#第三节-归纳总结" class="headerlink" title="第三节 归纳总结"></a><strong>第三节 归纳总结</strong></h2><h3 id="3-1-注意事项"><a href="#3-1-注意事项" class="headerlink" title="3.1 注意事项"></a><strong>3.1 注意事项</strong></h3><ol>
<li><strong>不可变的键</strong>：尽量使用不可变数据类型来作键，如String、Integer、Double、File。</li>
<li><strong>廉价交换</strong>：若元素大而键小，可以使用引用排序，避免元素的交换操作。</li>
<li><strong>多键数组</strong>：应用场景中，可能元素多种属性都可以当作排序的键，<code>Comparator</code> 接口可以定义多种比较器，甚至定义多种排序方法。</li>
</ol>
<h3 id="3-2-排序算法的比较"><a href="#3-2-排序算法的比较" class="headerlink" title="3.2 排序算法的比较"></a><strong>3.2 排序算法的比较</strong></h3><blockquote>
<p>测试用例：1万个随机整数[0,9999]。</p>
</blockquote>
<table>
<thead>
<tr>
<th style="text-align:center">算法</th>
<th style="text-align:center">100次运行平均所用时间</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">选择排序</td>
<td style="text-align:center">0.0718</td>
</tr>
<tr>
<td style="text-align:center">插入排序</td>
<td style="text-align:center">0.1156</td>
</tr>
<tr>
<td style="text-align:center">希尔排序</td>
<td style="text-align:center">0.0025</td>
</tr>
<tr>
<td style="text-align:center">快速排序</td>
<td style="text-align:center">0.0014</td>
</tr>
<tr>
<td style="text-align:center">三向切分的快速排序</td>
<td style="text-align:center">0.0021</td>
</tr>
<tr>
<td style="text-align:center">归并排序</td>
<td style="text-align:center">0.0031</td>
</tr>
<tr>
<td style="text-align:center">堆排序</td>
<td style="text-align:center">0.0020</td>
</tr>
</tbody>
</table>
<p>取随机数耗时比较大，测试的时候注意把取随机数的时间过滤。</p>
<p><strong>稳定性</strong>指排序算法能够保留数组中重复元素的相对位置，这种性质对于按不同维度依次排序的需求很重要（如先按时间排序，再按某一属性排序，相同属性的元素仍能按时间排序），当然也有办法使所有算法都强制稳定，取决于是否有必要花费这样的开销。</p>
<table>
<thead>
<tr>
<th style="text-align:center">算法</th>
<th style="text-align:center">是否稳定</th>
<th style="text-align:center">原地排序</th>
<th style="text-align:center">时间复杂度</th>
<th style="text-align:center">空间复杂度</th>
<th style="text-align:left">备注</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">选择排序</td>
<td style="text-align:center">否</td>
<td style="text-align:center">是</td>
<td style="text-align:center">N^2</td>
<td style="text-align:center">1</td>
<td style="text-align:left"></td>
</tr>
<tr>
<td style="text-align:center">插入排序</td>
<td style="text-align:center">是</td>
<td style="text-align:center">是</td>
<td style="text-align:center">N~N^2</td>
<td style="text-align:center">1</td>
<td style="text-align:left">取决于输入元素的排列情况</td>
</tr>
<tr>
<td style="text-align:center">希尔排序</td>
<td style="text-align:center">否</td>
<td style="text-align:center">是</td>
<td style="text-align:center">NlogN? N^(6/5)?</td>
<td style="text-align:center">1</td>
<td style="text-align:left"></td>
</tr>
<tr>
<td style="text-align:center">快速排序</td>
<td style="text-align:center">否</td>
<td style="text-align:center">是</td>
<td style="text-align:center">NlogN</td>
<td style="text-align:center">lgN</td>
<td style="text-align:left">运行效率由概率提供保证</td>
</tr>
<tr>
<td style="text-align:center">三向快速排序</td>
<td style="text-align:center">否</td>
<td style="text-align:center">是</td>
<td style="text-align:center">N~NlogN</td>
<td style="text-align:center">lgN</td>
<td style="text-align:left">运行效率由概率保证，同时也取决于输入元素的分布情况</td>
</tr>
<tr>
<td style="text-align:center">归并排序</td>
<td style="text-align:center">是</td>
<td style="text-align:center">否</td>
<td style="text-align:center">NlogN</td>
<td style="text-align:center">N</td>
<td style="text-align:left"></td>
</tr>
<tr>
<td style="text-align:center">堆排序</td>
<td style="text-align:center">否</td>
<td style="text-align:center">是</td>
<td style="text-align:center">NlogN</td>
<td style="text-align:center">1</td>
</tr>
</tbody>
</table>
<blockquote>
<p><strong>快速排序是最快的通用排序算法，大多数实际情况快排是最佳选择，但如看重稳定性又不在意空间的场景，归并排序是更好的选择</strong>。</p>
</blockquote>
<blockquote>
<p>Java 的 <code>Arrays.sort()</code> 是<strong>对原始数据类型进行三向快速排序</strong>，<strong>对引用类型使用归并排序</strong>，也<strong>暗示了用空间来换取稳定性</strong>。</p>
</blockquote>
<hr>
<p><em>参考博客和文章书籍等：</em></p>
<blockquote>
<p>《算法 第4版》</p>
</blockquote>
<p><em>因博客主等未标明不可引用，若部分内容涉及侵权请及时告知，我会尽快修改和删除相关内容</em></p>

      
    </div>
    
    
    

    

    

    

    
      <div>
         ﻿<div>
    
        <div style="text-align:center;color: #ccc;font-size:14px;">-------------本文结束<i class="fa fa-paw"></i>感谢您的阅读-------------</div>
    
</div>

      </div>
    
    
    <footer class="post-footer">
      
        <div class="post-tags">
          
            <a href="/tags/algorithm/" rel="tag"># algorithm</a>
          
            <a href="/tags/sort/" rel="tag"># sort</a>
          
        </div>
      

      
      
      

      
        <div class="post-nav">
          <div class="post-nav-next post-nav-item">
            
              <a href="/2018072802.html" rel="next" title="Hexo+GitHub搭建个人博客 (三) 配置nexT主题">
                <i class="fa fa-chevron-left"></i> Hexo+GitHub搭建个人博客 (三) 配置nexT主题
              </a>
            
          </div>

          <span class="post-nav-divider"></span>

          <div class="post-nav-prev post-nav-item">
            
              <a href="/2018080201.html" rel="prev" title="Java知识点总结 (一)">
                Java知识点总结 (一) <i class="fa fa-chevron-right"></i>
              </a>
            
          </div>
        </div>
      

      
      
    </footer>
  </div>
  
  
  
  </article>



    <div class="post-spread">
      
    </div>
  </div>


          </div>
          


          

  
     <div class="comments" id="comments">
       

<script src="https://utteranc.es/client.js" repo="LAILAIWA/LAILAIWA.github.io" issue-term="pathname" label="💬Comments" theme="github-light" crossorigin="anonymous" async>
</script>



     </div>
  



        </div>
        
          
  
  <div class="sidebar-toggle">
    <div class="sidebar-toggle-line-wrap">
      <span class="sidebar-toggle-line sidebar-toggle-line-first"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-middle"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-last"></span>
    </div>
  </div>

  <aside id="sidebar" class="sidebar">
    
    <div class="sidebar-inner">

      

      
        <ul class="sidebar-nav motion-element">
          <li class="sidebar-nav-toc sidebar-nav-active" data-target="post-toc-wrap">
            文章目录
          </li>
          <li class="sidebar-nav-overview" data-target="site-overview-wrap">
            站点概览
          </li>
        </ul>
      

      <section class="site-overview-wrap sidebar-panel">
        <div class="site-overview">
          <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
            
              <img class="site-author-image" itemprop="image" src="https://pic-1258215793.cos.ap-shanghai.myqcloud.com/cover/riho_yoshioka1.jpg" alt="Speciosity">
            
              <p class="site-author-name" itemprop="name">Speciosity</p>
              <p class="site-description motion-element" itemprop="description">记录编程点滴，写点生活中的酸甜</p>
          </div>

          <nav class="site-state motion-element">

            
              <div class="site-state-item site-state-posts">
              
                <a href="/archives/">
              
                  <span class="site-state-item-count">272</span>
                  <span class="site-state-item-name">日志</span>
                </a>
              </div>
            

            
              
              
              <div class="site-state-item site-state-categories">
                <a href="/categories/index.html">
                  <span class="site-state-item-count">8</span>
                  <span class="site-state-item-name">分类</span>
                </a>
              </div>
            

            
              
              
              <div class="site-state-item site-state-tags">
                <a href="/tags/index.html">
                  <span class="site-state-item-count">92</span>
                  <span class="site-state-item-name">标签</span>
                </a>
              </div>
            

          </nav>

          
            <div class="feed-link motion-element">
              <a href="/atom.xml" rel="alternate">
                <i class="fa fa-rss"></i>
                RSS
              </a>
            </div>
          

          
            <div class="links-of-author motion-element">
                
                  <span class="links-of-author-item">
                    <a href="https://github.com/LAILAIWA" target="_blank" title="GitHub">
                      
                        <i class="fa fa-fw fa-github"></i>GitHub</a>
                  </span>
                
                  <span class="links-of-author-item">
                    <a href="mailto:linyishui168@outlook.com" target="_blank" title="E-Mail">
                      
                        <i class="fa fa-fw fa-envelope"></i>E-Mail</a>
                  </span>
                
                  <span class="links-of-author-item">
                    <a href="https://twitter.com/linyishui618" target="_blank" title="Twitter">
                      
                        <i class="fa fa-fw fa-twitter"></i>Twitter</a>
                  </span>
                
                  <span class="links-of-author-item">
                    <a href="https://instagram.com/linyishui618" target="_blank" title="Instagram">
                      
                        <i class="fa fa-fw fa-instagram"></i>Instagram</a>
                  </span>
                
                  <span class="links-of-author-item">
                    <a href="https://weibo.com/u/5340162234" target="_blank" title="Weibo">
                      
                        <i class="fa fa-fw fa-weibo.com"></i>Weibo</a>
                  </span>
                
            </div>
          

          
          

          
          

          <div id="days"></div>
<script>
function show_date_time(){
    window.setTimeout("show_date_time()", 1000);
    BirthDay=new Date("07/26/2018 00:00:00");
    today=new Date();
    timeold=(today.getTime()-BirthDay.getTime());
    sectimeold=timeold/1000
    secondsold=Math.floor(sectimeold);
    msPerDay=24*60*60*1000
    e_daysold=timeold/msPerDay
    daysold=Math.floor(e_daysold);
    e_hrsold=(e_daysold-daysold)*24;
    hrsold=setzero(Math.floor(e_hrsold));
    e_minsold=(e_hrsold-hrsold)*60;
    minsold=setzero(Math.floor((e_hrsold-hrsold)*60));
    seconds=setzero(Math.floor((e_minsold-minsold)*60));
    document.getElementById('days').innerHTML="已运行 "+daysold+" 天 "+hrsold+" 小时 "+minsold+" 分 "+seconds+" 秒";
}
function setzero(i) {
    if (i<10) {
        i="0" + i
    };
    return i;
}
show_date_time();
</script>  
        </div>
      </section>

      
      <!--noindex-->
        <section class="post-toc-wrap motion-element sidebar-panel sidebar-panel-active">
          <div class="post-toc">

            
              
            

            
              <div class="post-toc-content"><ol class="nav"><li class="nav-item nav-level-1"><a class="nav-link" href="#排序"><span class="nav-number">1.</span> <span class="nav-text">排序</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#第一节-前文"><span class="nav-number">1.1.</span> <span class="nav-text">第一节 前文</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#1-1-什么是排序？"><span class="nav-number">1.1.1.</span> <span class="nav-text">1.1 什么是排序？</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#1-2-如何比较两种排序算法？"><span class="nav-number">1.1.2.</span> <span class="nav-text">1.2 如何比较两种排序算法？</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#第二节-排序算法"><span class="nav-number">1.2.</span> <span class="nav-text">第二节 排序算法</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#2-1-选择排序"><span class="nav-number">1.2.1.</span> <span class="nav-text">2.1 选择排序</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#2-1-1-代码"><span class="nav-number">1.2.1.1.</span> <span class="nav-text">2.1.1 代码</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#2-1-2-排序轨迹"><span class="nav-number">1.2.1.2.</span> <span class="nav-text">2.1.2 排序轨迹</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#2-1-3-运行时间"><span class="nav-number">1.2.1.3.</span> <span class="nav-text">2.1.3 运行时间</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#2-1-4-额外内存空间"><span class="nav-number">1.2.1.4.</span> <span class="nav-text">2.1.4 额外内存空间</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#2-1-5-特点"><span class="nav-number">1.2.1.5.</span> <span class="nav-text">2.1.5 特点</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#2-2-插入排序"><span class="nav-number">1.2.2.</span> <span class="nav-text">2.2 插入排序</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#2-2-1-代码"><span class="nav-number">1.2.2.1.</span> <span class="nav-text">2.2.1 代码</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#2-2-2-排序轨迹"><span class="nav-number">1.2.2.2.</span> <span class="nav-text">2.2.2 排序轨迹</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#2-2-3-运行时间"><span class="nav-number">1.2.2.3.</span> <span class="nav-text">2.2.3 运行时间</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#2-2-4-额外内存空间"><span class="nav-number">1.2.2.4.</span> <span class="nav-text">2.2.4 额外内存空间</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#2-2-5-特点"><span class="nav-number">1.2.2.5.</span> <span class="nav-text">2.2.5 特点</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#2-3-希尔排序"><span class="nav-number">1.2.3.</span> <span class="nav-text">2.3 希尔排序</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#2-3-1-代码"><span class="nav-number">1.2.3.1.</span> <span class="nav-text">2.3.1 代码</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#2-3-2-排序轨迹"><span class="nav-number">1.2.3.2.</span> <span class="nav-text">2.3.2 排序轨迹</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#2-3-3-递增序列"><span class="nav-number">1.2.3.3.</span> <span class="nav-text">2.3.3 递增序列</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#2-3-4-运行时间"><span class="nav-number">1.2.3.4.</span> <span class="nav-text">2.3.4 运行时间</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#2-3-5-额外内存空间"><span class="nav-number">1.2.3.5.</span> <span class="nav-text">2.3.5 额外内存空间</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#2-3-6-特点"><span class="nav-number">1.2.3.6.</span> <span class="nav-text">2.3.6 特点</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#2-4-归并排序"><span class="nav-number">1.2.4.</span> <span class="nav-text">2.4 归并排序</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#2-4-1-原地归并"><span class="nav-number">1.2.4.1.</span> <span class="nav-text">2.4.1 原地归并</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#2-4-2-自顶向下的归并排序"><span class="nav-number">1.2.4.2.</span> <span class="nav-text">2.4.2 自顶向下的归并排序</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#2-4-3-自底向上的归并排序"><span class="nav-number">1.2.4.3.</span> <span class="nav-text">2.4.3 自底向上的归并排序</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#2-4-4-代码"><span class="nav-number">1.2.4.4.</span> <span class="nav-text">2.4.4 代码</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#2-4-5-运行轨迹"><span class="nav-number">1.2.4.5.</span> <span class="nav-text">2.4.5 运行轨迹</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#（1）原地归并的抽象方法"><span class="nav-number">1.2.4.5.1.</span> <span class="nav-text">（1）原地归并的抽象方法</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#（2）自顶向下的归并排序"><span class="nav-number">1.2.4.5.2.</span> <span class="nav-text">（2）自顶向下的归并排序</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#（3）自底向上的归并排序"><span class="nav-number">1.2.4.5.3.</span> <span class="nav-text">（3）自底向上的归并排序</span></a></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#2-4-6-运行时间"><span class="nav-number">1.2.4.6.</span> <span class="nav-text">2.4.6 运行时间</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#（1）自顶向下的归并排序"><span class="nav-number">1.2.4.6.1.</span> <span class="nav-text">（1）自顶向下的归并排序</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#（2）自底向上的归并排序"><span class="nav-number">1.2.4.6.2.</span> <span class="nav-text">（2）自底向上的归并排序</span></a></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#2-4-7-额外内存空间"><span class="nav-number">1.2.4.7.</span> <span class="nav-text">2.4.7 额外内存空间</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#2-4-8-优化"><span class="nav-number">1.2.4.8.</span> <span class="nav-text">2.4.8 优化</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#（1）小规模数组采用插入排序"><span class="nav-number">1.2.4.8.1.</span> <span class="nav-text">（1）小规模数组采用插入排序</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#（2）判断数组是否已有序"><span class="nav-number">1.2.4.8.2.</span> <span class="nav-text">（2）判断数组是否已有序</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#（3）不将元素复制到辅助数组"><span class="nav-number">1.2.4.8.3.</span> <span class="nav-text">（3）不将元素复制到辅助数组</span></a></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#2-4-9-特点"><span class="nav-number">1.2.4.9.</span> <span class="nav-text">2.4.9 特点</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#2-4-10-计算排序算法的复杂度"><span class="nav-number">1.2.4.10.</span> <span class="nav-text">2.4.10 计算排序算法的复杂度</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#2-5-快速排序"><span class="nav-number">1.2.5.</span> <span class="nav-text">2.5 快速排序</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#2-5-1-优缺点"><span class="nav-number">1.2.5.1.</span> <span class="nav-text">2.5.1 优缺点</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#2-5-2-快速排序和归并排序的区别"><span class="nav-number">1.2.5.2.</span> <span class="nav-text">2.5.2 快速排序和归并排序的区别</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#2-5-3-代码"><span class="nav-number">1.2.5.3.</span> <span class="nav-text">2.5.3 代码</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#2-5-4-排序轨迹"><span class="nav-number">1.2.5.4.</span> <span class="nav-text">2.5.4 排序轨迹</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#2-5-5-可能导致实现错误和性能下降的细节"><span class="nav-number">1.2.5.5.</span> <span class="nav-text">2.5.5 可能导致实现错误和性能下降的细节</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#2-5-6-运行时间"><span class="nav-number">1.2.5.6.</span> <span class="nav-text">2.5.6 运行时间</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#2-5-7-改进快速排序算法"><span class="nav-number">1.2.5.7.</span> <span class="nav-text">2.5.7 改进快速排序算法</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#（1）根据数组大小切换到插入排序"><span class="nav-number">1.2.5.7.1.</span> <span class="nav-text">（1）根据数组大小切换到插入排序</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#（2）三取样切分"><span class="nav-number">1.2.5.7.2.</span> <span class="nav-text">（2）三取样切分</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#（3）熵最优排序"><span class="nav-number">1.2.5.7.3.</span> <span class="nav-text">（3）熵最优排序</span></a></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#2-5-8-三向切分法的快速排序"><span class="nav-number">1.2.5.8.</span> <span class="nav-text">2.5.8 三向切分法的快速排序</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#2-5-9-特点"><span class="nav-number">1.2.5.9.</span> <span class="nav-text">2.5.9 特点</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#2-6-优先队列"><span class="nav-number">1.2.6.</span> <span class="nav-text">2.6 优先队列</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#2-6-1-概述"><span class="nav-number">1.2.6.1.</span> <span class="nav-text">2.6.1 概述</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#2-6-2-API"><span class="nav-number">1.2.6.2.</span> <span class="nav-text">2.6.2 API</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#2-6-3-调用示例"><span class="nav-number">1.2.6.3.</span> <span class="nav-text">2.6.3 调用示例</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#2-6-4-初级实现"><span class="nav-number">1.2.6.4.</span> <span class="nav-text">2.6.4 初级实现</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#2-6-5-堆的定义"><span class="nav-number">1.2.6.5.</span> <span class="nav-text">2.6.5 堆的定义</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#二叉堆表示法"><span class="nav-number">1.2.6.5.1.</span> <span class="nav-text">二叉堆表示法</span></a></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#2-6-6-堆的算法"><span class="nav-number">1.2.6.6.</span> <span class="nav-text">2.6.6 堆的算法</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#上浮和下沉"><span class="nav-number">1.2.6.6.1.</span> <span class="nav-text">上浮和下沉</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#基于堆的优先队列实现代码"><span class="nav-number">1.2.6.6.2.</span> <span class="nav-text">基于堆的优先队列实现代码</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#多叉堆"><span class="nav-number">1.2.6.6.3.</span> <span class="nav-text">多叉堆</span></a></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#2-6-7-基于堆的索引优先队列"><span class="nav-number">1.2.6.7.</span> <span class="nav-text">2.6.7 基于堆的索引优先队列</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#使用案例"><span class="nav-number">1.2.6.7.1.</span> <span class="nav-text">使用案例</span></a></li></ol></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#2-7-堆排序"><span class="nav-number">1.2.7.</span> <span class="nav-text">2.7 堆排序</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#2-7-1-堆的构造"><span class="nav-number">1.2.7.1.</span> <span class="nav-text">2.7.1 堆的构造</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#2-7-2-实现代码"><span class="nav-number">1.2.7.2.</span> <span class="nav-text">2.7.2 实现代码</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#2-7-3-排序轨迹"><span class="nav-number">1.2.7.3.</span> <span class="nav-text">2.7.3 排序轨迹</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#2-7-4-运行时间"><span class="nav-number">1.2.7.4.</span> <span class="nav-text">2.7.4 运行时间</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#2-7-5-额外内存空间"><span class="nav-number">1.2.7.5.</span> <span class="nav-text">2.7.5 额外内存空间</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#2-7-6-特点"><span class="nav-number">1.2.7.6.</span> <span class="nav-text">2.7.6 特点</span></a></li></ol></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#第三节-归纳总结"><span class="nav-number">1.3.</span> <span class="nav-text">第三节 归纳总结</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#3-1-注意事项"><span class="nav-number">1.3.1.</span> <span class="nav-text">3.1 注意事项</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#3-2-排序算法的比较"><span class="nav-number">1.3.2.</span> <span class="nav-text">3.2 排序算法的比较</span></a></li></ol></li></ol></li></ol></div>
            

          </div>
        </section>
      <!--/noindex-->
      

      

    </div>
  </aside>


        
      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="footer-inner">
        ﻿<div class="copyright">&copy; 2018 &mdash; <span itemprop="copyrightYear">2020</span>
  <span class="with-love" id="heart">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">Speciosity</span>

  
</div>


  <div class="powered-by">由 <a class="theme-link" target="_blank" href="https://hexo.io">Hexo</a> 强力驱动</div>



  <span class="post-meta-divider">|</span>



  <div class="theme-info">主题 &mdash; <a class="theme-link" target="_blank" href="https://github.com/iissnan/hexo-theme-next">NexT.Pisces</a> v5.1.4</div>




        







        
      </div>
    </footer>

    
      <div class="back-to-top">
        <i class="fa fa-arrow-up"></i>
        
      </div>
    

    
   

  </div>

  

<script type="text/javascript">
  if (Object.prototype.toString.call(window.Promise) !== '[object Function]') {
    window.Promise = null;
  }
</script>









  












  
  
    <script type="text/javascript" src="/lib/jquery/index.js?v=2.1.3"></script>
  

  
  
    <script type="text/javascript" src="/lib/fastclick/lib/fastclick.min.js?v=1.0.6"></script>
  

  
  
    <script type="text/javascript" src="/lib/jquery_lazyload/jquery.lazyload.js?v=1.9.7"></script>
  

  
  
    <script type="text/javascript" src="/lib/velocity/velocity.min.js?v=1.2.1"></script>
  

  
  
    <script type="text/javascript" src="/lib/velocity/velocity.ui.min.js?v=1.2.1"></script>
  

  
  
    <script type="text/javascript" src="/lib/fancybox/source/jquery.fancybox.pack.js?v=2.1.5"></script>
  


  


  <script type="text/javascript" src="/js/src/utils.js?v=5.1.4"></script>

  <script type="text/javascript" src="/js/src/motion.js?v=5.1.4"></script>



  
  


  <script type="text/javascript" src="/js/src/affix.js?v=5.1.4"></script>

  <script type="text/javascript" src="/js/src/schemes/pisces.js?v=5.1.4"></script>



  
  <script type="text/javascript" src="/js/src/scrollspy.js?v=5.1.4"></script>
<script type="text/javascript" src="/js/src/post-details.js?v=5.1.4"></script>



  


  <script type="text/javascript" src="/js/src/bootstrap.js?v=5.1.4"></script>



  


  




	





  





  












  

  <script type="text/javascript">
    // Popup Window;
    var isfetched = false;
    var isXml = true;
    // Search DB path;
    var search_path = "search.xml";
    if (search_path.length === 0) {
      search_path = "search.xml";
    } else if (/json$/i.test(search_path)) {
      isXml = false;
    }
    var path = "/" + search_path;
    // monitor main search box;

    var onPopupClose = function (e) {
      $('.popup').hide();
      $('#local-search-input').val('');
      $('.search-result-list').remove();
      $('#no-result').remove();
      $(".local-search-pop-overlay").remove();
      $('body').css('overflow', '');
    }

    function proceedsearch() {
      $("body")
        .append('<div class="search-popup-overlay local-search-pop-overlay"></div>')
        .css('overflow', 'hidden');
      $('.search-popup-overlay').click(onPopupClose);
      $('.popup').toggle();
      var $localSearchInput = $('#local-search-input');
      $localSearchInput.attr("autocapitalize", "none");
      $localSearchInput.attr("autocorrect", "off");
      $localSearchInput.focus();
    }

    // search function;
    var searchFunc = function(path, search_id, content_id) {
      'use strict';

      // start loading animation
      $("body")
        .append('<div class="search-popup-overlay local-search-pop-overlay">' +
          '<div id="search-loading-icon">' +
          '<i class="fa fa-spinner fa-pulse fa-5x fa-fw"></i>' +
          '</div>' +
          '</div>')
        .css('overflow', 'hidden');
      $("#search-loading-icon").css('margin', '20% auto 0 auto').css('text-align', 'center');

      $.ajax({
        url: path,
        dataType: isXml ? "xml" : "json",
        async: true,
        success: function(res) {
          // get the contents from search data
          isfetched = true;
          $('.popup').detach().appendTo('.header-inner');
          var datas = isXml ? $("entry", res).map(function() {
            return {
              title: $("title", this).text(),
              content: $("content",this).text(),
              url: $("url" , this).text()
            };
          }).get() : res;
          var input = document.getElementById(search_id);
          var resultContent = document.getElementById(content_id);
          var inputEventFunction = function() {
            var searchText = input.value.trim().toLowerCase();
            var keywords = searchText.split(/[\s\-]+/);
            if (keywords.length > 1) {
              keywords.push(searchText);
            }
            var resultItems = [];
            if (searchText.length > 0) {
              // perform local searching
              datas.forEach(function(data) {
                var isMatch = false;
                var hitCount = 0;
                var searchTextCount = 0;
                var title = data.title.trim();
                var titleInLowerCase = title.toLowerCase();
                var content = data.content.trim().replace(/<[^>]+>/g,"");
                var contentInLowerCase = content.toLowerCase();
                var articleUrl = decodeURIComponent(data.url);
                var indexOfTitle = [];
                var indexOfContent = [];
                // only match articles with not empty titles
                if(title != '') {
                  keywords.forEach(function(keyword) {
                    function getIndexByWord(word, text, caseSensitive) {
                      var wordLen = word.length;
                      if (wordLen === 0) {
                        return [];
                      }
                      var startPosition = 0, position = [], index = [];
                      if (!caseSensitive) {
                        text = text.toLowerCase();
                        word = word.toLowerCase();
                      }
                      while ((position = text.indexOf(word, startPosition)) > -1) {
                        index.push({position: position, word: word});
                        startPosition = position + wordLen;
                      }
                      return index;
                    }

                    indexOfTitle = indexOfTitle.concat(getIndexByWord(keyword, titleInLowerCase, false));
                    indexOfContent = indexOfContent.concat(getIndexByWord(keyword, contentInLowerCase, false));
                  });
                  if (indexOfTitle.length > 0 || indexOfContent.length > 0) {
                    isMatch = true;
                    hitCount = indexOfTitle.length + indexOfContent.length;
                  }
                }

                // show search results

                if (isMatch) {
                  // sort index by position of keyword

                  [indexOfTitle, indexOfContent].forEach(function (index) {
                    index.sort(function (itemLeft, itemRight) {
                      if (itemRight.position !== itemLeft.position) {
                        return itemRight.position - itemLeft.position;
                      } else {
                        return itemLeft.word.length - itemRight.word.length;
                      }
                    });
                  });

                  // merge hits into slices

                  function mergeIntoSlice(text, start, end, index) {
                    var item = index[index.length - 1];
                    var position = item.position;
                    var word = item.word;
                    var hits = [];
                    var searchTextCountInSlice = 0;
                    while (position + word.length <= end && index.length != 0) {
                      if (word === searchText) {
                        searchTextCountInSlice++;
                      }
                      hits.push({position: position, length: word.length});
                      var wordEnd = position + word.length;

                      // move to next position of hit

                      index.pop();
                      while (index.length != 0) {
                        item = index[index.length - 1];
                        position = item.position;
                        word = item.word;
                        if (wordEnd > position) {
                          index.pop();
                        } else {
                          break;
                        }
                      }
                    }
                    searchTextCount += searchTextCountInSlice;
                    return {
                      hits: hits,
                      start: start,
                      end: end,
                      searchTextCount: searchTextCountInSlice
                    };
                  }

                  var slicesOfTitle = [];
                  if (indexOfTitle.length != 0) {
                    slicesOfTitle.push(mergeIntoSlice(title, 0, title.length, indexOfTitle));
                  }

                  var slicesOfContent = [];
                  while (indexOfContent.length != 0) {
                    var item = indexOfContent[indexOfContent.length - 1];
                    var position = item.position;
                    var word = item.word;
                    // cut out 100 characters
                    var start = position - 20;
                    var end = position + 80;
                    if(start < 0){
                      start = 0;
                    }
                    if (end < position + word.length) {
                      end = position + word.length;
                    }
                    if(end > content.length){
                      end = content.length;
                    }
                    slicesOfContent.push(mergeIntoSlice(content, start, end, indexOfContent));
                  }

                  // sort slices in content by search text's count and hits' count

                  slicesOfContent.sort(function (sliceLeft, sliceRight) {
                    if (sliceLeft.searchTextCount !== sliceRight.searchTextCount) {
                      return sliceRight.searchTextCount - sliceLeft.searchTextCount;
                    } else if (sliceLeft.hits.length !== sliceRight.hits.length) {
                      return sliceRight.hits.length - sliceLeft.hits.length;
                    } else {
                      return sliceLeft.start - sliceRight.start;
                    }
                  });

                  // select top N slices in content

                  var upperBound = parseInt('1');
                  if (upperBound >= 0) {
                    slicesOfContent = slicesOfContent.slice(0, upperBound);
                  }

                  // highlight title and content

                  function highlightKeyword(text, slice) {
                    var result = '';
                    var prevEnd = slice.start;
                    slice.hits.forEach(function (hit) {
                      result += text.substring(prevEnd, hit.position);
                      var end = hit.position + hit.length;
                      result += '<b class="search-keyword">' + text.substring(hit.position, end) + '</b>';
                      prevEnd = end;
                    });
                    result += text.substring(prevEnd, slice.end);
                    return result;
                  }

                  var resultItem = '';

                  if (slicesOfTitle.length != 0) {
                    resultItem += "<li><a href='" + articleUrl + "' class='search-result-title'>" + highlightKeyword(title, slicesOfTitle[0]) + "</a>";
                  } else {
                    resultItem += "<li><a href='" + articleUrl + "' class='search-result-title'>" + title + "</a>";
                  }

                  slicesOfContent.forEach(function (slice) {
                    resultItem += "<a href='" + articleUrl + "'>" +
                      "<p class=\"search-result\">" + highlightKeyword(content, slice) +
                      "...</p>" + "</a>";
                  });

                  resultItem += "</li>";
                  resultItems.push({
                    item: resultItem,
                    searchTextCount: searchTextCount,
                    hitCount: hitCount,
                    id: resultItems.length
                  });
                }
              })
            };
            if (keywords.length === 1 && keywords[0] === "") {
              resultContent.innerHTML = '<div id="no-result"><i class="fa fa-search fa-5x" /></div>'
            } else if (resultItems.length === 0) {
              resultContent.innerHTML = '<div id="no-result"><i class="fa fa-frown-o fa-5x" /></div>'
            } else {
              resultItems.sort(function (resultLeft, resultRight) {
                if (resultLeft.searchTextCount !== resultRight.searchTextCount) {
                  return resultRight.searchTextCount - resultLeft.searchTextCount;
                } else if (resultLeft.hitCount !== resultRight.hitCount) {
                  return resultRight.hitCount - resultLeft.hitCount;
                } else {
                  return resultRight.id - resultLeft.id;
                }
              });
              var searchResultList = '<ul class=\"search-result-list\">';
              resultItems.forEach(function (result) {
                searchResultList += result.item;
              })
              searchResultList += "</ul>";
              resultContent.innerHTML = searchResultList;
            }
          }

          if ('auto' === 'auto') {
            input.addEventListener('input', inputEventFunction);
          } else {
            $('.search-icon').click(inputEventFunction);
            input.addEventListener('keypress', function (event) {
              if (event.keyCode === 13) {
                inputEventFunction();
              }
            });
          }

          // remove loading animation
          $(".local-search-pop-overlay").remove();
          $('body').css('overflow', '');

          proceedsearch();
        }
      });
    }

    // handle and trigger popup window;
    $('.popup-trigger').click(function(e) {
      e.stopPropagation();
      if (isfetched === false) {
        searchFunc(path, 'local-search-input', 'local-search-result');
      } else {
        proceedsearch();
      };
    });

    $('.popup-btn-close').click(onPopupClose);
    $('.popup').click(function(e){
      e.stopPropagation();
    });
    $(document).on('keyup', function (event) {
      var shouldDismissSearchPopup = event.which === 27 &&
        $('.search-popup').is(':visible');
      if (shouldDismissSearchPopup) {
        onPopupClose();
      }
    });
  </script>





  

  

  

  
  

  

  

  

</body>
</html>
