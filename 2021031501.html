<!DOCTYPE html>



  


<html class="theme-next pisces use-motion" lang="zh-Hans">
<head><meta name="generator" content="Hexo 3.9.0">
  <meta charset="UTF-8">
<meta http-equiv="X-UA-Compatible" content="IE=edge">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
<meta name="theme-color" content="#222">



  
  
    
    
  <script src="/lib/pace/pace.min.js?v=1.0.2"></script>
  <link href="/lib/pace/pace-theme-minimal.min.css?v=1.0.2" rel="stylesheet">







<meta http-equiv="Cache-Control" content="no-transform">
<meta http-equiv="Cache-Control" content="no-siteapp">
















  
  
  <link href="/lib/fancybox/source/jquery.fancybox.css?v=2.1.5" rel="stylesheet" type="text/css">







<link href="/lib/font-awesome/css/font-awesome.min.css?v=4.6.2" rel="stylesheet" type="text/css">

<link href="/css/main.css?v=5.1.4" rel="stylesheet" type="text/css">


  <link rel="apple-touch-icon" sizes="180x180" href="/images/gamepad playstation.png?v=5.1.4">


  <link rel="icon" type="image/png" sizes="32x32" href="/images/Dig Dug.ico?v=5.1.4">


  <link rel="icon" type="image/png" sizes="16x16" href="/images/gamepad playstation.png?v=5.1.4">


  <link rel="mask-icon" href="/images/gamepad playstation.svg?v=5.1.4" color="#222">





  <meta name="keywords" content="algorithm,unfinished,">





  <link rel="alternate" href="/atom.xml" title="俺的部落格" type="application/atom+xml">






<meta name="description" content="内容包括：概述，实现，算法题等。">
<meta name="keywords" content="algorithm,unfinished">
<meta property="og:type" content="article">
<meta property="og:title" content="动态规划（未完成）">
<meta property="og:url" content="http://linyishui.top/2021031501.html">
<meta property="og:site_name" content="俺的部落格">
<meta property="og:description" content="内容包括：概述，实现，算法题等。">
<meta property="og:locale" content="zh-Hans">
<meta property="og:image" content="https://wikimedia.org/api/rest_v1/media/math/render/svg/dd9c97f255a11758a2f19098205661f90cf2fa81">
<meta property="og:image" content="https://wikimedia.org/api/rest_v1/media/math/render/svg/dd9c97f255a11758a2f19098205661f90cf2fa81">
<meta property="og:image" content="https://images2018.cnblogs.com/blog/1336655/201806/1336655-20180626142332007-952080845.png">
<meta property="og:image" content="https://images2018.cnblogs.com/blog/1336655/201806/1336655-20180626144646962-1290294296.png">
<meta property="og:image" content="https://images2018.cnblogs.com/blog/1336655/201806/1336655-20180626143827583-1699093130.png">
<meta property="og:image" content="https://images2018.cnblogs.com/blog/1336655/201806/1336655-20180626144206832-946860971.png">
<meta property="og:image" content="https://common.cnblogs.com/images/copycode.gif">
<meta property="og:image" content="https://common.cnblogs.com/images/copycode.gif">
<meta property="og:image" content="https://common.cnblogs.com/images/copycode.gif">
<meta property="og:image" content="https://common.cnblogs.com/images/copycode.gif">
<meta property="og:image" content="https://images2018.cnblogs.com/blog/1336655/201806/1336655-20180626150321546-748343160.png">
<meta property="og:image" content="https://images2018.cnblogs.com/blog/1336655/201806/1336655-20180626150546681-278989483.png">
<meta property="og:image" content="https://images2018.cnblogs.com/blog/1336655/201806/1336655-20180626151529727-1771169615.png">
<meta property="og:image" content="https://images2018.cnblogs.com/blog/1336655/201806/1336655-20180626151725491-1249436922.png">
<meta property="og:image" content="https://images2018.cnblogs.com/blog/1336655/201806/1336655-20180626154205161-1543350290.png">
<meta property="og:image" content="https://images2018.cnblogs.com/blog/1336655/201806/1336655-20180626154222124-1568769512.png">
<meta property="og:image" content="https://common.cnblogs.com/images/copycode.gif">
<meta property="og:image" content="https://common.cnblogs.com/images/copycode.gif">
<meta property="og:image" content="https://common.cnblogs.com/images/copycode.gif">
<meta property="og:image" content="https://common.cnblogs.com/images/copycode.gif">
<meta property="og:image" content="https://images2018.cnblogs.com/blog/1336655/201806/1336655-20180626161250797-846687005.png">
<meta property="og:image" content="https://images2018.cnblogs.com/blog/1336655/201806/1336655-20180626161407046-1649798663.png">
<meta property="og:image" content="https://images2018.cnblogs.com/blog/1336655/201806/1336655-20180626161153121-2116602929.png">
<meta property="og:image" content="https://images2018.cnblogs.com/blog/1336655/201806/1336655-20180626161510812-1390787212.png">
<meta property="og:image" content="https://images2018.cnblogs.com/blog/1336655/201806/1336655-20180626164412918-1817122808.png">
<meta property="og:image" content="https://common.cnblogs.com/images/copycode.gif">
<meta property="og:image" content="https://common.cnblogs.com/images/copycode.gif">
<meta property="og:updated_time" content="2021-04-20T05:33:00.000Z">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="动态规划（未完成）">
<meta name="twitter:description" content="内容包括：概述，实现，算法题等。">
<meta name="twitter:image" content="https://wikimedia.org/api/rest_v1/media/math/render/svg/dd9c97f255a11758a2f19098205661f90cf2fa81">



<script type="text/javascript" id="hexo.configurations">
  var NexT = window.NexT || {};
  var CONFIG = {
    root: '/',
    scheme: 'Pisces',
    version: '5.1.4',
    sidebar: {"position":"left","display":"always","offset":12,"b2t":false,"scrollpercent":false,"onmobile":false},
    fancybox: true,
    tabs: true,
    motion: {"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}},
    duoshuo: {
      userId: '0',
      author: '博主'
    },
    algolia: {
      applicationID: '',
      apiKey: '',
      indexName: '',
      hits: {"per_page":10},
      labels: {"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}
    }
  };
</script>



  <link rel="canonical" href="http://linyishui.top/2021031501.html">





  <title>动态规划（未完成） | 俺的部落格</title>
  




  <script async src="https://www.googletagmanager.com/gtag/js?id=G-Z0L5T0JQG7"></script>
  <script>
    var host = window.location.hostname;
    if (host !== "localhost" || !true) {
      window.dataLayer = window.dataLayer || [];
      function gtag(){dataLayer.push(arguments);}
      gtag('js', new Date());
      gtag('config', 'G-Z0L5T0JQG7');
    }
  </script>


  <script type="text/javascript">
    var _hmt = _hmt || [];
    (function() {
      var hm = document.createElement("script");
      hm.src = "https://hm.baidu.com/hm.js?a73137787baf0001a5bc4063855efe8a";
      var s = document.getElementsByTagName("script")[0];
      s.parentNode.insertBefore(hm, s);
    })();
  </script>




</head>

<body itemscope itemtype="http://schema.org/WebPage" lang="zh-Hans">

  
  
    
  

  <div class="container sidebar-position-left page-post-detail">
    <div class="headband"></div>

    <header id="header" class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-wrapper">
  <div class="site-meta ">
    

    <div class="custom-logo-site-title">
      <a href="/" class="brand" rel="start">
        <span class="logo-line-before"><i></i></span>
        <span class="site-title">俺的部落格</span>
        <span class="logo-line-after"><i></i></span>
      </a>
    </div>
      
        <p class="site-subtitle">俺寻思俺需要记点东西</p>
      
  </div>

  <div class="site-nav-toggle">
    <button>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
    </button>
  </div>
</div>

<nav class="site-nav">
  

  
    <ul id="menu" class="menu">
      
        
        <li class="menu-item menu-item-home">
          <a href="/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-home"></i> <br>
            
            首页
          </a>
        </li>
      
        
        <li class="menu-item menu-item-about">
          <a href="/about/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-user"></i> <br>
            
            关于
          </a>
        </li>
      
        
        <li class="menu-item menu-item-tags">
          <a href="/tags/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-tags"></i> <br>
            
            标签
          </a>
        </li>
      
        
        <li class="menu-item menu-item-categories">
          <a href="/categories/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-th"></i> <br>
            
            分类
          </a>
        </li>
      
        
        <li class="menu-item menu-item-archives">
          <a href="/archives/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-archive"></i> <br>
            
            归档
          </a>
        </li>
      
        
        <li class="menu-item menu-item-sitemap">
          <a href="/sitemap.xml" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-sitemap"></i> <br>
            
            站点地图
          </a>
        </li>
      
        
        <li class="menu-item menu-item-commonweal">
          <a href="/404/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-heartbeat"></i> <br>
            
            公益404
          </a>
        </li>
      

      
        <li class="menu-item menu-item-search">
          
            <a href="javascript:;" class="popup-trigger">
          
            
              <i class="menu-item-icon fa fa-search fa-fw"></i> <br>
            
            搜索
          </a>
        </li>
      
    </ul>
  

  
    <div class="site-search">
      
  <div class="popup search-popup local-search-popup">
  <div class="local-search-header clearfix">
    <span class="search-icon">
      <i class="fa fa-search"></i>
    </span>
    <span class="popup-btn-close">
      <i class="fa fa-times-circle"></i>
    </span>
    <div class="local-search-input-wrapper">
      <input autocomplete="off" placeholder="搜索..." spellcheck="false" type="text" id="local-search-input">
    </div>
  </div>
  <div id="local-search-result"></div>
</div>



    </div>
  
</nav>



 </div>
    </header>

    <main id="main" class="main">
      <div class="main-inner">
        <div class="content-wrap">
          <div id="content" class="content">
            

  <div id="posts" class="posts-expand">
    

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://linyishui.top/2021031501.html">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="林沂水">
      <meta itemprop="description" content>
      <meta itemprop="image" content="https://pic-1258215793.cos.ap-shanghai.myqcloud.com/cover/riho_yoshioka1.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="俺的部落格">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">动态规划（未完成）</h1>
        

        <div class="post-meta">
          
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2021-03-15T21:57:00+08:00">
                2021-03-15
              </time>
            

            

            
          </span>

          
            <span class="post-category">
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/技术文档/" itemprop="url" rel="index">
                    <span itemprop="name">技术文档</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          
            <div class="post-wordcount">
              
                
                <span class="post-meta-item-icon">
                  <i class="fa fa-file-word-o"></i>
                </span>
                
                  <span class="post-meta-item-text">字数统计&#58;</span>
                
                <span title="字数统计">
                  8,286
                </span>
              

              
                <span class="post-meta-divider">|</span>
              

              
                <span class="post-meta-item-icon">
                  <i class="fa fa-clock-o"></i>
                </span>
                
                  <span class="post-meta-item-text">阅读时长 &asymp;</span>
                
                <span title="阅读时长">
                  33
                </span>
              
            </div>
          

          
              <div class="post-description">
                  内容包括：概述，实现，算法题等。
              </div>
          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        <h1 id="动态规划"><a href="#动态规划" class="headerlink" title="动态规划"></a>动态规划</h1><h2 id="一-概述"><a href="#一-概述" class="headerlink" title="一. 概述"></a>一. 概述</h2><h3 id="1-1-什么是动态规划？"><a href="#1-1-什么是动态规划？" class="headerlink" title="1.1 什么是动态规划？"></a>1.1 什么是动态规划？</h3><p><strong>动态规划</strong>（英语：Dynamic Programming，简称DP）是一种<strong>通过把原问题分解为相对简单的子问题的方式求解复杂问题的方法</strong>。常常适用于<strong>有重叠子问题</strong>和<strong>最优子结构</strong>（Optimal substructure）性质的问题，动态规划方法所耗时间往往远少于朴素解法。</p>
<p>在20世纪50年代初，由美国数学家贝尔曼（R.Bellman）等人在研究多阶段决策过程的优化问题时，提出了著名的最优化原理，从而创立了动态规划。</p>
<p>动态规划背后的基本思想非常简单。大致上，若要解一个给定问题，我们需要解其不同部分（即子问题），再根据子问题的解以得出原问题的解。</p>
<p>通常许多子问题非常相似，为此动态规划法试图仅仅解决每个子问题一次，从而减少计算量：<strong>一旦某个给定子问题的解已经算出，则将其记忆化存储，以便下次需要同一个子问题解之时直接查表</strong>。这种做法在重复子问题的数目关于输入的规模呈指数增长时特别有用。</p>
<h3 id="概念引入"><a href="#概念引入" class="headerlink" title="概念引入"></a>概念引入</h3><p>在现实生活中，有一类活动的过程，由于它的特殊性，可将过程分成若干个互相联系的阶段，在它的每一阶段都需要作出决策，从而使整个过程达到最好的活动效果。因此各个阶段决策的选取不能任意确定，它依赖于当前面临的状态，又影响以后的发展。当各个阶段决策确定后，就组成一个决策序列，因而也就确定了整个过程的一条活动路线．这种把一个问题看作是一个前后关联具有链状结构的多阶段过程就称为多阶段决策过程，这种问题称为多阶段决策问题。在多阶段决策问题中，各个阶段采取的决策，一般来说是与时间有关的，决策依赖于当前状态，又随即引起状态的转移，一个决策序列就是在变化的状态中产生出来的，故有“动态”的含义，称这种解决多阶段决策最优化的过程为动态规划方法 [4] 。</p>
<h3 id="基本思想"><a href="#基本思想" class="headerlink" title="基本思想"></a>基本思想</h3><p>动态规划算法通常用于求解具有某种最优性质的问题。在这类问题中，可能会有许多可行解。每一个解都对应于一个值，我们希望找到具有<a href="https://baike.baidu.com/item/最优值" target="_blank" rel="noopener">最优值</a>的解。动态规划算法与<a href="https://baike.baidu.com/item/分治法" target="_blank" rel="noopener">分治法</a>类似，其基本思想也是将待求解问题分解成若干个子问题，先求解子问题，然后从<a href="https://baike.baidu.com/item/这些子" target="_blank" rel="noopener">这些子</a>问题的解得到原问题的解。与分治法不同的是，适合于用动态规划求解的问题，经分解得到子问题往往不是互相独立的。若用分治法来解这类问题，则分解得到的子问题数目太多，有些子问题被重复计算了很多次。如果我们能够保存已解决的子问题的答案，而在需要时再找出已求得的答案，这样就可以避免大量的重复计算，节省时间。我们可以用一个表来记录所有已解的子问题的答案。不管该子问题以后是否被用到，只要它被计算过，就将其结果填入表中。这就是动态规划法的基本思路。具体的动态规划算法多种多样，但它们具有相同的填表格式 [5] 。</p>
<h3 id="基本概念"><a href="#基本概念" class="headerlink" title="基本概念"></a>基本概念</h3><ul>
<li><strong>多阶段决策问题</strong></li>
</ul>
<p>如果一类活动过程可以分为若干个互相联系的阶段，在每一个阶段都需作出决策（采取措施），一个阶段的决策确定以后，常常影响到下一个阶段的决策，从而就完全确定了一个过程的活动路线，则称它为多阶段决策问题 [6] 。</p>
<p>各个阶段的决策构成一个决策序列，称为一个策略。每一个阶段都有若干个决策可供选择，因而就有许多策略供我们选取，对应于一个策略可以确定活动的效果，这个效果可以用数量来确定。策略不同，效果也不同，多阶段决策问题，就是要在可以选择的那些策略中间，选取一个最优策略，使在预定的标准下达到最好的效果 [6] 。</p>
<ul>
<li><strong>动态规划问题中的术语</strong></li>
</ul>
<p><a href="https://baike.baidu.com/item/阶段" target="_blank" rel="noopener">阶段</a>：把所给求解问题的过程恰当地分成若干个相互联系的阶段，以便于求解，过程不同，阶段数就可能不同．描述阶段的变量称为阶段变量。在多数情况下，阶段变量是离散的，用k表示。此外，也有阶段变量是连续的情形。如果过程可以在任何时刻作出决策，且在任意两个不同的时刻之间允许有无穷多个决策时，阶段变量就是连续的 [6] 。</p>
<p><a href="https://baike.baidu.com/item/状态" target="_blank" rel="noopener">状态</a>：状态表示每个阶段开始面临的自然状况或客观条件，它不以人们的主观意志为转移，也称为不可控因素。在上面的例子中状态就是某阶段的出发位置，它既是该阶段某路的起点，同时又是前一阶段某支路的终点 [6] 。</p>
<p><a href="https://baike.baidu.com/item/无后效性" target="_blank" rel="noopener">无后效性</a>：我们要求状态具有下面的性质：如果给定某一阶段的状态，则在这一阶段以后过程的发展不受这阶段以前各段状态的影响，所有各阶段都确定时，整个过程也就确定了。换句话说，过程的每一次实现可以用一个状态序列表示，在前面的例子中每阶段的状态是该线路的始点，确定了这些点的序列，整个线路也就完全确定。从某一阶段以后的线路开始，当这段的始点给定时，不受以前线路（所通过的点）的影响。状态的这个性质意味着过程的历史只能通过当前的状态去影响它的未来的发展，这个性质称为无后效性 [6] 。</p>
<p><a href="https://baike.baidu.com/item/决策" target="_blank" rel="noopener">决策</a>：一个阶段的状态给定以后，从该状态演变到下一阶段某个状态的一种选择（行动）称为决策。在最优控制中，也称为控制。在许多问题中，决策可以自然而然地表示为一个数或一组数。不同的决策对应着不同的数值。描述决策的变量称<a href="https://baike.baidu.com/item/决策变量" target="_blank" rel="noopener">决策变量</a>，因状态满足无后效性，故在每个阶段选择决策时只需考虑当前的状态而无须考虑过程的历史 [6] 。</p>
<p>决策变量的范围称为允许决策集合 [6] 。</p>
<p><a href="https://baike.baidu.com/item/策略" target="_blank" rel="noopener">策略</a>：由每个阶段的决策组成的序列称为策略。对于每一个实际的多阶段决策过程，可供选取的策略有一定的范围限制，这个范围称为允许策略集合 [6] 。</p>
<p>允许策略集合中达到最优效果的策略称为最优策略 [6] 。</p>
<p>给定k阶段状态变量x(k)的值后，如果这一阶段的决策变量一经确定，第k+1阶段的状态变量x(k+1)也就完全确定，即x(k+1)的值随x(k)和第k阶段的决策u(k)的值变化而变化，那么可以把这一关系看成(x(k)，u(k))与x(k+1)确定的对应关系，用x(k+1)=Tk(x(k),u(k))表示。这是从k阶段到k+1阶段的状态转移规律，称为状态转移方程 [6] 。</p>
<p>最优化原理：作为整个过程的最优策略，它满足：相对前面决策所形成的状态而言，余下的子策略必然构成“最优子策略” [6] 。</p>
<p>最优性原理实际上是要求问题的最优策略的子策略也是最优 [6] 。</p>
<h3 id="基本结构"><a href="#基本结构" class="headerlink" title="基本结构"></a>基本结构</h3><p>多阶段决策问题中，各个阶段采取的<a href="https://baike.baidu.com/item/决策" target="_blank" rel="noopener">决策</a>，一般来说是与时间有关的，决策依赖于当前状态，又随即引起状态的转移，一个决策序列就是在变化的状态中产生出来的，故有“动态”的含义，称这种解决多阶段决策最优化问题的方法为动态规划方法 [7] 。</p>
<h3 id="适用条件"><a href="#适用条件" class="headerlink" title="适用条件"></a>适用条件</h3><p>任何思想方法都有一定的局限性，超出了特定条件，它就失去了作用。同样，动态规划也并不是万能的。适用动态规划的问题必须满足最优化原理和无后效性 [8] 。</p>
<ul>
<li><strong><a href="https://baike.baidu.com/item/最优化原理" target="_blank" rel="noopener">最优化原理</a>**</strong>（最优子结构性质）**</li>
</ul>
<p>最优化原理可这样阐述：一个最优化策略具有这样的性质，不论过去状态和决策如何，对前面的决策所形成的状态而言，余下的诸决策必须构成最优策略。简而言之，一个最优化策略的子策略总是最优的。一个问题满足最优化原理又称其具有最优子结构性质 [8] 。</p>
<ul>
<li><strong><a href="https://baike.baidu.com/item/无后效性" target="_blank" rel="noopener">无后效性</a></strong></li>
</ul>
<p>将各阶段按照一定的次序排列好之后，对于某个给定的阶段状态，它以前各阶段的状态无法直接影响它未来的决策，而只能通过当前的这个状态。换句话说，每个状态都是过去历史的一个完整总结。这就是无后向性，又称为无后效性 [8] 。</p>
<ul>
<li><strong>子问题的重叠性</strong></li>
</ul>
<p>动态规划算法的关键在于解决冗余，这是动态规划算法的根本目的。动态规划实质上是一种以空间换时间的技术，它在实现的过程中，不得不存储产生过程中的各种状态，所以它的空间复杂度要大于其他的算法。选择动态规划算法是因为动态规划算法在空间上可以承受，而搜索算法在时间上却无法承受，所以我们舍空间而取时间</p>
<h3 id="1-2-使用场景"><a href="#1-2-使用场景" class="headerlink" title="1.2 使用场景"></a>1.2 使用场景</h3><p>动态规划在查找有很多<strong>重叠子问题</strong>的情况的最优解时有效。它将问题重新组合成子问题。为了避免多次解决这些子问题，它们的结果都逐渐被计算并被保存，从简单的问题直到整个问题都被解决。因此，动态规划保存递归时的结果，因而不会在解决同样的问题时花费时间。</p>
<p>动态规划只能应用于有<strong>最优子结构</strong>的问题。最优子结构的意思是局部最优解能决定全局最优解（对有些问题这个要求并不能完全满足，故有时需要引入一定的近似）。简单地说，问题能够分解成子问题来解决。</p>
<p>适用情况：</p>
<ul>
<li><p><strong>最优子结构性质</strong>：如果问题的最优解所包含的子问题的解也是最优的，我们就称该问题具有最优子结构性质（即满足最优化原理）。最优子结构性质为动态规划算法解决问题提供了重要线索。</p>
</li>
<li><p><strong>无后效性</strong>：即子问题的解一旦确定，就不再改变，不受在这之后、包含它的更大的问题的求解决策影响。</p>
</li>
<li><strong>子问题重叠性质</strong>：子问题重叠性质是指在用递归算法自顶向下对问题进行求解时，每次产生的子问题并不总是新问题，有些子问题会被重复计算多次。动态规划算法正是利用了这种子问题的重叠性质，对每一个子问题只计算一次，然后将其计算结果保存在一个表格中，当再次需要计算已经计算过的子问题时，只是在表格中简单地查看一下结果，从而获得较高的效率，降低了时间复杂度。</li>
</ul>
<h3 id="1-3-动态规划与记忆化搜索"><a href="#1-3-动态规划与记忆化搜索" class="headerlink" title="1.3 动态规划与记忆化搜索"></a>1.3 动态规划与记忆化搜索</h3><p><a href="https://www.luogu.com.cn/blog/interestingLSY/memdfs-and-dp" target="_blank" rel="noopener">https://www.luogu.com.cn/blog/interestingLSY/memdfs-and-dp</a></p>
<h2 id="二-算法"><a href="#二-算法" class="headerlink" title="二. 算法"></a>二. 算法</h2><h3 id="2-1-DP的两种实现方式"><a href="#2-1-DP的两种实现方式" class="headerlink" title="2.1 DP的两种实现方式"></a>2.1 DP的两种实现方式</h3><ul>
<li>递归实现</li>
<li>记忆化搜索</li>
</ul>
<h3 id="2-2-DP常用来解决的问题"><a href="#2-2-DP常用来解决的问题" class="headerlink" title="2.2 DP常用来解决的问题"></a>2.2 DP常用来解决的问题</h3><ul>
<li>切割钢条问题</li>
<li>Floyd最短路问题</li>
<li>最大不下降子序列</li>
<li>矩阵链乘</li>
<li>凸多边形三角剖分</li>
<li>0-1背包</li>
<li>最长公共子序列</li>
<li>最优二分搜索树</li>
</ul>
<h3 id="2-3-使用动态规划的算法"><a href="#2-3-使用动态规划的算法" class="headerlink" title="2.3 使用动态规划的算法"></a>2.3 使用动态规划的算法</h3><ul>
<li>最长公共子序列</li>
<li>Floyd-Warshall算法</li>
<li>Viterbi算法</li>
<li>求解马可夫决策过程下最佳策略</li>
</ul>
<h3 id="2-4-实现原理"><a href="#2-4-实现原理" class="headerlink" title="2.4 实现原理"></a>2.4 实现原理</h3><ul>
<li><strong>基本思想：</strong>问题的最优解如果可以由子问题的最优解推导得到，则可以先求解子问题的最优解，在构造原问题的最优解；若子问题<strong>有较多的重复出现</strong>，则可以<strong>自底向上</strong>从最终子问题向原问题逐步求解。</li>
<li>使用条件：<strong>可分为多个相关子问题，子问题的解被重复使用</strong><ul>
<li>Optimal substructure（优化子结构）：<ul>
<li>一个问题的优化解包含了子问题的优化解</li>
<li>缩小子问题集合，只需那些优化问题中包含的子问题，降低实现复杂性</li>
<li>我们可以自下而上的</li>
</ul>
</li>
<li>Subteties（重叠子问题）：在问题的求解过程中，很多子问题的解将被多次使用。</li>
</ul>
</li>
<li>动态规划算法的设计步骤：<ul>
<li>分析优化解的结构</li>
<li>递归地定义最优解的代价</li>
<li>自底向上地计算优化解的代价保存之，并获取构造最优解的信息</li>
<li>根据构造最优解的信息构造优化解</li>
</ul>
</li>
<li>动态规划特点：<ul>
<li>把原始问题划分成一系列子问题；</li>
<li>求解每个子问题仅一次，并将其结果保存在一个表中，以后用到时直接存取，不重复计算，节省计算时间</li>
<li>自底向上地计算。</li>
<li>整体问题最优解取决于子问题的最优解（状态转移方程）（将子问题称为状态，最终状态的求解归结为其他状态的求解）</li>
</ul>
</li>
</ul>
<h2 id="三-算法题"><a href="#三-算法题" class="headerlink" title="三. 算法题"></a>三. 算法题</h2><p>动态规划等价于记忆化搜索，学习深度优先搜索和记忆化搜索，方便快速理解动态规划</p>
<p>解决DP算法问题，写出记忆化搜索的递归函数，列出方程后，可以用数学方法，魔改优化。</p>
<h3 id="3-1-背包问题"><a href="#3-1-背包问题" class="headerlink" title="3.1 背包问题"></a>3.1 背包问题</h3><p>背包问题作为NP完全问题，暂时不存在多项式时间算法。动态规划属于背包问题求解最优解的可行方法之一。此外，求解背包问题最优解还有搜索法等，近似解还有贪心法等，分数背包问题有最优贪心解等。 背包问题具有最优子结构和重叠子问题。动态规划一般用于求解背包问题中的整数背包问题（即每种物品所选的个数必须是整数）。 </p>
<p>解整数背包问题： 设有n件物品，每件价值记为 P~i~ ，每件体积记为 V~i~ ，用一个最大容积为 V~max~ 的背包，求装入物品的最大价值。 用一个数组 f[i,v] 表示取i件商品填充一个容积为v的背包的最大价值，显然问题的解就是 f[n,V~max~] 。</p>
<p><img src="https://wikimedia.org/api/rest_v1/media/math/render/svg/dd9c97f255a11758a2f19098205661f90cf2fa81" alt="{\displaystyle f[i,v]={\begin{cases}f[i-1,v],v&lt;V_{i}\\\max\{f[i-1,v],f[i-1,v-V_{i}]+P_{i}\},v\geq V_{i}\\0,iv=0\\\end{cases}}}"></p>
<p>对于特例0-1背包问题（即每件物品最多放1件，否则不放入）的问题，状态转移方程：</p>
<p><img src="https://wikimedia.org/api/rest_v1/media/math/render/svg/dd9c97f255a11758a2f19098205661f90cf2fa81" alt="{\displaystyle f[i,v]={\begin{cases}f[i-1,v],v&lt;V_{i}\\\max\{f[i-1,v],f[i-1,v-V_{i}]+P_{i}\},v\geq V_{i}\\0,iv=0\\\end{cases}}}"></p>
<h3 id="3-2-切割钢条问题"><a href="#3-2-切割钢条问题" class="headerlink" title="3.2 切割钢条问题"></a>3.2 切割钢条问题</h3><p>（1）剑指14-剪绳子1</p>
<p>此案例中动态规划效率要低于贪心解法：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 剪绳子1</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * 给你一根长度为 n 的绳子，请把绳子剪成整数长度的 m 段（m、n都是整数，n&gt;1并且m&gt;1），</span></span><br><span class="line"><span class="comment"> * 每段绳子的长度记为 k[0],k[1]...k[m-1] 。</span></span><br><span class="line"><span class="comment"> * 请问 k[0]*k[1]*...*k[m-1] 可能的最大乘积是多少？</span></span><br><span class="line"><span class="comment"> * 例如，当绳子的长度是8时，我们把它剪成长度分别为2、3、3的三段，此时得到的最大乘积是18。</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * 示例 1：</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * 输入: 2</span></span><br><span class="line"><span class="comment"> * 输出: 1</span></span><br><span class="line"><span class="comment"> * 解释: 2 = 1 + 1, 1 × 1 = 1</span></span><br><span class="line"><span class="comment"> * 示例 2:</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * 输入: 10</span></span><br><span class="line"><span class="comment"> * 输出: 36</span></span><br><span class="line"><span class="comment"> * 解释: 10 = 3 + 3 + 4, 3 × 3 × 4 = 36</span></span><br><span class="line"><span class="comment"> * 提示：</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * 2 &lt;= n &lt;= 58</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * Related Topics</span></span><br><span class="line"><span class="comment"> * 数学</span></span><br><span class="line"><span class="comment"> * 动态规划</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Jz14CuttingRope1</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        System.out.println(cuttingRope(<span class="number">2</span>));</span><br><span class="line">        System.out.println(cuttingRope(<span class="number">10</span>));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 求长度为n的绳子剪掉后的最大乘积，可以从前面比n小的绳子转移而来</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * 用一个dp数组记录从0到n长度的绳子剪掉后的最大乘积，也就是dp[i]表示长度为i的绳子剪成m段后的最大乘积，初始化dp[2] = 1</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * 我们先把绳子剪掉第一段（长度为j），如果只剪掉长度为1，对最后的乘积无任何增益，所以从长度为2开始剪</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * 剪了第一段后，剩下(i - j)长度可以剪也可以不剪。</span></span><br><span class="line"><span class="comment">     * 如果不剪的话长度乘积即为j * (i - j)；</span></span><br><span class="line"><span class="comment">     * 如果剪的话长度乘积即为j * dp[i - j]。</span></span><br><span class="line"><span class="comment">     * 取两者最大值max(j * (i - j), j * dp[i - j])</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * 第一段长度j可以取的区间为[2,i)，对所有j不同的情况取最大值，因此最终dp[i]的转移方程为</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * dp[i] = max(dp[i], max(j * (i - j), j * dp[i - j]))</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * 最后返回dp[n]即可</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * 时间复杂度：O(n ^ 2)</span></span><br><span class="line"><span class="comment">     * 空间复杂度：O(n)</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">cuttingRope</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span>[] dp = <span class="keyword">new</span> <span class="keyword">int</span>[n + <span class="number">1</span>];</span><br><span class="line">        dp[<span class="number">2</span>] = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">3</span>; i &lt; n + <span class="number">1</span>; i++)&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">2</span>; j &lt; i; j++)&#123;</span><br><span class="line">                dp[i] = Math.max(dp[i], Math.max(j * (i - j), j * dp[i - j]));</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> dp[n];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 贪心</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * 核心思路是：尽可能把绳子分成长度为3的小段，这样乘积最大</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * 步骤如下：</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * 如果 n == 2，返回1，如果 n == 3，返回2，两个可以合并成n小于4的时候返回n - 1</span></span><br><span class="line"><span class="comment">     * 如果 n == 4，返回4</span></span><br><span class="line"><span class="comment">     * 如果 n &gt; 4，分成尽可能多的长度为3的小段，每次循环长度n减去3，乘积res乘以3；最后返回时乘以小于等于4的最后一小段</span></span><br><span class="line"><span class="comment">     * 以上2和3可以合并</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * 时间复杂度：O(n)</span></span><br><span class="line"><span class="comment">     * 空间复杂度：O(1)</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">cuttingRope1</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(n &lt; <span class="number">4</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> n - <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> res = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span>(n &gt; <span class="number">4</span>)&#123;</span><br><span class="line">            res *= <span class="number">3</span>;</span><br><span class="line">            n -= <span class="number">3</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res * n;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>（2）剑指14-剪绳子2</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 剪绳子2</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * 给你一根长度为 n 的绳子，请把绳子剪成整数长度的 m 段（m、n都是整数，n&gt;1并且m&gt;1），</span></span><br><span class="line"><span class="comment"> * 每段绳子的长度记为 k[0],k[1]...k[m - 1] 。</span></span><br><span class="line"><span class="comment"> * 请问 k[0]*k[1]*...*k[m - 1] 可能的最大乘积是多少？</span></span><br><span class="line"><span class="comment"> * 例如，当绳子的长度是8时，我们把它剪成长度分别为2、3、3的三段，此时得到的最大乘积是18。</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * 答案需要取模 1e9+7（1000000007），如计算初始结果为：1000000008，请返回 1。</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * 示例 1：</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * 输入: 2</span></span><br><span class="line"><span class="comment"> * 输出: 1</span></span><br><span class="line"><span class="comment"> * 解释: 2 = 1 + 1, 1 × 1 = 1</span></span><br><span class="line"><span class="comment"> * 示例 2:</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * 输入: 10</span></span><br><span class="line"><span class="comment"> * 输出: 36</span></span><br><span class="line"><span class="comment"> * 解释: 10 = 3 + 3 + 4, 3 × 3 × 4 = 36</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * 提示：</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * 2 &lt;= n &lt;= 1000</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * Related Topics</span></span><br><span class="line"><span class="comment"> * 数学</span></span><br><span class="line"><span class="comment"> * 动态规划</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * 与剪绳子1唯一不同在于本题目涉及 “大数越界情况下的求余问题”</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Jz14CuttingRope2</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        System.out.println(cuttingRope(<span class="number">2</span>));</span><br><span class="line">        System.out.println(cuttingRope(<span class="number">10</span>));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">cuttingRope</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(n &lt; <span class="number">4</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> n - <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">long</span> res = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span>(n &gt; <span class="number">4</span>)&#123;</span><br><span class="line">            res  = res * <span class="number">3</span> % <span class="number">1000000007</span>;</span><br><span class="line">            n -= <span class="number">3</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> (<span class="keyword">int</span>) (res * n % <span class="number">1000000007</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="3-3-正则表达式匹配"><a href="#3-3-正则表达式匹配" class="headerlink" title="3.3 正则表达式匹配"></a>3.3 正则表达式匹配</h3><p>剑指19-正则表达式匹配</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 正则表达式匹配</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * 请实现一个函数用来匹配包含'. '和'*'的正则表达式。</span></span><br><span class="line"><span class="comment"> * 模式中的字符'.'表示任意一个字符，而'*'表示它前面的字符可以出现任意次（含0次）。</span></span><br><span class="line"><span class="comment"> * 在本题中，匹配是指字符串的所有字符匹配整个模式。</span></span><br><span class="line"><span class="comment"> * 例如，字符串"aaa"与模式"a.a"和"ab*ac*a"匹配，但与"aa.a"和"ab*a"均不匹配。</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * 示例 1:</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * 输入:</span></span><br><span class="line"><span class="comment"> * s = "aa"</span></span><br><span class="line"><span class="comment"> * p = "a"</span></span><br><span class="line"><span class="comment"> * 输出: false</span></span><br><span class="line"><span class="comment"> * 解释: "a" 无法匹配 "aa" 整个字符串。</span></span><br><span class="line"><span class="comment"> * 示例 2:</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * 输入:</span></span><br><span class="line"><span class="comment"> * s = "aa"</span></span><br><span class="line"><span class="comment"> * p = "a*"</span></span><br><span class="line"><span class="comment"> * 输出: true</span></span><br><span class="line"><span class="comment"> * 解释: 因为 '*' 代表可以匹配零个或多个前面的那一个元素, 在这里前面的元素就是 'a'。因此，字符串 "aa" 可被视为 'a' 重复了一次。</span></span><br><span class="line"><span class="comment"> * 示例 3:</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * 输入:</span></span><br><span class="line"><span class="comment"> * s = "ab"</span></span><br><span class="line"><span class="comment"> * p = ".*"</span></span><br><span class="line"><span class="comment"> * 输出: true</span></span><br><span class="line"><span class="comment"> * 解释: ".*" 表示可匹配零个或多个（'*'）任意字符（'.'）。</span></span><br><span class="line"><span class="comment"> * 示例 4:</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * 输入:</span></span><br><span class="line"><span class="comment"> * s = "aab"</span></span><br><span class="line"><span class="comment"> * p = "c*a*b"</span></span><br><span class="line"><span class="comment"> * 输出: true</span></span><br><span class="line"><span class="comment"> * 解释: 因为 '*' 表示零个或多个，这里 'c' 为 0 个, 'a' 被重复一次。因此可以匹配字符串 "aab"。</span></span><br><span class="line"><span class="comment"> * 示例 5:</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * 输入:</span></span><br><span class="line"><span class="comment"> * s = "mississippi"</span></span><br><span class="line"><span class="comment"> * p = "mis*is*p*."</span></span><br><span class="line"><span class="comment"> * 输出: false</span></span><br><span class="line"><span class="comment"> * s 可能为空，且只包含从 a-z 的小写字母。</span></span><br><span class="line"><span class="comment"> * p 可能为空，且只包含从 a-z 的小写字母以及字符 . 和 *，无连续的 '*'。</span></span><br><span class="line"><span class="comment"> * 注意：本题与主站 10 题相同：https://leetcode-cn.com/problems/regular-expression-matching/</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * Related Topics</span></span><br><span class="line"><span class="comment"> * 动态规划</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Jz19IsMatch</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        String s = <span class="string">"aa"</span>;</span><br><span class="line">        String p = <span class="string">"a"</span>;</span><br><span class="line">        System.out.println(isMatch(s, p));</span><br><span class="line"></span><br><span class="line">        s = <span class="string">"aa"</span>;</span><br><span class="line">        p = <span class="string">"a*"</span>;</span><br><span class="line">        System.out.println(isMatch(s, p));</span><br><span class="line"></span><br><span class="line">        s = <span class="string">"ab"</span>;</span><br><span class="line">        p = <span class="string">".*"</span>;</span><br><span class="line">        System.out.println(isMatch(s, p));</span><br><span class="line"></span><br><span class="line">        s = <span class="string">"aab"</span>;</span><br><span class="line">        p = <span class="string">"c*a*b"</span>;</span><br><span class="line">        System.out.println(isMatch(s, p));</span><br><span class="line"></span><br><span class="line">        s = <span class="string">"mississippi"</span>;</span><br><span class="line">        p = <span class="string">"mis*is*p*."</span>;</span><br><span class="line">        System.out.println(isMatch(s, p));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 字符非.或*，则直接比较。</span></span><br><span class="line"><span class="comment">     * 字符为.，则直接匹配，跳到下一个字符。</span></span><br><span class="line"><span class="comment">     * 字符为*，则找到下一个与其匹配的字符。</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">boolean</span> <span class="title">isMatch</span><span class="params">(String s, String p)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> n = s.length();</span><br><span class="line">        <span class="keyword">int</span> m = p.length();</span><br><span class="line">        <span class="comment">// 存放已处理结果</span></span><br><span class="line">        <span class="keyword">boolean</span>[][] f = <span class="keyword">new</span> <span class="keyword">boolean</span>[n + <span class="number">1</span>][m + <span class="number">1</span>];</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt;= n; i++) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt;= m; j++) &#123;</span><br><span class="line">                <span class="comment">//分成空正则和非空正则两种</span></span><br><span class="line">                <span class="keyword">if</span> (j == <span class="number">0</span>) &#123;</span><br><span class="line">                    f[i][j] = i == <span class="number">0</span>;</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    <span class="comment">//非空正则分为两种情况 * 和 非*</span></span><br><span class="line">                    <span class="keyword">if</span> (p.charAt(j - <span class="number">1</span>) != <span class="string">'*'</span>) &#123;</span><br><span class="line">                        <span class="keyword">if</span> (i &gt; <span class="number">0</span> &amp;&amp; (s.charAt(i - <span class="number">1</span>) == p.charAt(j - <span class="number">1</span>) || p.charAt(j - <span class="number">1</span>) == <span class="string">'.'</span>)) &#123;</span><br><span class="line">                            f[i][j] = f[i - <span class="number">1</span>][j - <span class="number">1</span>];</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                        <span class="comment">//碰到 * 了，分为看和不看两种情况</span></span><br><span class="line">                        <span class="comment">//不看</span></span><br><span class="line">                        <span class="keyword">if</span> (j &gt;= <span class="number">2</span>) &#123;</span><br><span class="line">                            f[i][j] |= f[i][j - <span class="number">2</span>];</span><br><span class="line">                        &#125;</span><br><span class="line">                        <span class="comment">//看</span></span><br><span class="line">                        <span class="keyword">if</span> (i &gt;= <span class="number">1</span> &amp;&amp; j &gt;= <span class="number">2</span> &amp;&amp; (s.charAt(i - <span class="number">1</span>) == p.charAt(j - <span class="number">2</span>) || p.charAt(j - <span class="number">2</span>) == <span class="string">'.'</span>)) &#123;</span><br><span class="line">                            f[i][j] |= f[i - <span class="number">1</span>][j];</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> f[n][m];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>解题思路：</p>
<p>假设主串为 A，模式串为 B 从最后一步出发，需要关注最后进来的字符。假设 A 的长度为 n ，B 的长度为 m ，关注正则表达式 B 的最后一个字符是谁，它有三种可能，正常字符、<code>*</code> 和 <code>.</code>（点），那针对这三种情况讨论即可，如下：</p>
<ol>
<li>如果 B 的最后一个字符是正常字符，那就是看 <code>A[n-1]</code> 是否等于 <code>B[m-1]</code> ，相等则看 A~0..n-2~ 与 B~0..m−2~ ，不等则是不能匹配，这就是子问题。</li>
<li>如果 B 的最后一个字符是 <code>.</code> ，它能匹配任意字符，直接看 A~0..n-2~ 与 B~0..m−2~ </li>
<li>如果 BB 的最后一个字符是 <code>*</code> 它代表 <code>B[m-2]=c</code> 可以重复0次或多次，它们是一个整体 c*<ul>
<li>情况一：<code>A[n-1]</code> 是 0 个 c，B 最后两个字符废了，能否匹配取决于  A~0..n-1~ 与 B~0..m−3~ 是否匹配</li>
<li>情况二：<code>A[n-1]</code> 是多个 c 中的最后一个（这种情况必须 A[n-1]=c 或者 c=’.’），所以 A 匹配完往前挪一个，B 继续匹配，因为可以匹配多个，继续看 A~0..n-2~ 与 B~0..m−1~ 是否匹配。</li>
</ul>
</li>
</ol>
<p>转移方程:</p>
<p><code>f[i][j]</code> 代表 A 的前 i 个和 B 的前 j 个能否匹配:</p>
<ul>
<li>对于前面两个情况，可以合并成一种情况 <code>f[i][j]</code> = <code>f[i-1][j-1]</code> </li>
<li>对于第三种情况，对于 c* 分为看和不看两种情况<ul>
<li>不看：直接砍掉正则串的后面两个， <code>f[i][j]</code> = <code>f[i][j-2]</code></li>
<li>看：正则串不动，主串前移一个，<code>f[i][j]</code> = <code>f[i-1][j]</code></li>
</ul>
</li>
</ul>
<p>初始条件</p>
<p>特判：需要考虑空串空正则</p>
<ul>
<li>空串和空正则是匹配的，<code>f[0][0]</code> = true</li>
<li>空串和非空正则，不能直接定义 true 和 false，必须要计算出来。（比如A=’’ ,B=a∗b∗c∗）</li>
<li>非空串和空正则必不匹配，<code>f[1][0]</code> =…= <code>f[n][0]</code> =false</li>
<li>非空串和非空正则，那肯定是需要计算的了。</li>
</ul>
<p>大体上可以分为空正则和非空正则两种，空正则也是比较好处理的，对非空正则我们肯定需要计算，非空正则的三种情况，前面两种可以合并到一起讨论，第三种情况是单独一种，那么也就是分为当前位置是 <em> 和不是 </em> 两种情况了。</p>
<p>复杂度分析</p>
<p>时间复杂度：O(mn)，其中 m 和 n 分别是字符串 s 和 p 的长度。我们需要计算出所有的状态，并且每个状态在进行转移时的时间复杂度为 O(1)。</p>
<p>空间复杂度：O(mn)，即为存储所有状态使用的空间。</p>
<h3 id="3-4-编号动态规划：最大不下降子序列"><a href="#3-4-编号动态规划：最大不下降子序列" class="headerlink" title="3.4 编号动态规划：最大不下降子序列"></a>3.4 编号动态规划：最大不下降子序列</h3><p>　　本类的状态是基础的基础，大部分的动态规划都要用到它，成为一个维。</p>
<ul>
<li><strong>最长不下降子序列定义：</strong>从序列中选出若干个数组成一个新的序列，不改变他们的队伍的顺序，要求新的序列里xi≤xi+1≤xi+1…..举个例子{4,6,5,7,3}，最长不下降子序列就是{4,6,7}。</li>
<li><strong>子问题的表示：</strong>令dp[i]表示以第i个元素结尾的前i个元素构成的最长不下降子序列的长度</li>
<li><strong>优化子结构</strong>：若最长不下降子序列包括ak，则必有一个解包含a1,a2…ak-1的最长不下降子序列，dp[i]表示为前i个元素的序列的最长不下降子序列</li>
<li><strong>方程</strong>： <em>dp[i] = max{dp[j] | 0&lt;j&lt;i , aj≥ai} + 1</em></li>
<li><strong>伪代码</strong>：</li>
</ul>
<p>　　　　输入a[1,…,n]　　输出：最长子序列</p>
<p> 　　　　<img src="https://images2018.cnblogs.com/blog/1336655/201806/1336655-20180626142332007-952080845.png" alt="img"></p>
<p><strong>时间复杂度：O(n^2)</strong></p>
<h3 id="3-5-划分动态规划：矩阵链乘、凸多边形三角剖分"><a href="#3-5-划分动态规划：矩阵链乘、凸多边形三角剖分" class="headerlink" title="3.5 划分动态规划：矩阵链乘、凸多边形三角剖分"></a>3.5 划分动态规划：矩阵链乘、凸多边形三角剖分</h3><p><strong>【矩阵链乘】</strong></p>
<ul>
<li><strong>优化子结构</strong>：若计算A1~n的优化顺序在k处断开矩阵链, 即A1~n=A1~k × Ak+1~n，则在A1~n的优化顺序中，对应于子问题A1~k的解必须是A1-k的优化解，对应于子问题Ak+1~n的解必须是Ak+1~n的优化解</li>
<li><strong>子问题重叠性：</strong></li>
</ul>
<p>　　　　<img src="https://images2018.cnblogs.com/blog/1336655/201806/1336655-20180626144646962-1290294296.png" alt="img"></p>
<ul>
<li><strong>方程：</strong></li>
</ul>
<p>假设：m[i, j] = 计算Ai~j的最小乘法数；  A1 … AkAk+1 …. An 是优化解(k实际上是不可预知)</p>
<p> 　<img src="https://images2018.cnblogs.com/blog/1336655/201806/1336655-20180626143827583-1699093130.png" alt="img"></p>
<p>　  <img src="https://images2018.cnblogs.com/blog/1336655/201806/1336655-20180626144206832-946860971.png" alt="img"></p>
<ul>
<li><strong>伪代码：</strong></li>
</ul>
<p><a href="javascript:void(0" target="_blank" rel="noopener"><img src="https://common.cnblogs.com/images/copycode.gif" alt="复制代码"></a>;)</p>
<figure class="highlight sqf"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">输入：&lt;A1, A2, ..., An&gt;, Ai是矩阵</span><br><span class="line">输出：计算A1 x A2 x ... x An的最小代价方法</span><br><span class="line"></span><br><span class="line">Matrix-Chain-Order(p)</span><br><span class="line">n=length(p)-<span class="number">1</span>；</span><br><span class="line"><span class="keyword">FOR</span> i=<span class="number">1</span> <span class="keyword">TO</span> n <span class="keyword">DO</span></span><br><span class="line">    m[i, i]=<span class="number">0</span>;</span><br><span class="line"><span class="keyword">FOR</span> l=<span class="number">2</span> <span class="keyword">TO</span> n <span class="keyword">DO</span> <span class="comment">/* 计算地l对角线*/</span></span><br><span class="line">    <span class="keyword">FOR</span> i=<span class="number">1</span> <span class="keyword">TO</span> n-l+<span class="number">1</span> <span class="keyword">DO</span></span><br><span class="line">        j=i+l-<span class="number">1</span>;</span><br><span class="line">        m[i, j]= ∞;</span><br><span class="line">        <span class="keyword">FOR</span> k←i <span class="keyword">To</span> j←<span class="number">1</span> <span class="keyword">DO</span> <span class="comment">/* 计算m[i,j] */</span></span><br><span class="line">             q=m[i, k]+m[k+<span class="number">1</span>, j]+ <span class="built_in">pi</span>-<span class="number">1</span>pkpj</span><br><span class="line">             <span class="keyword">IF</span> q&lt;m[i, j] <span class="keyword">THEN</span>                  m[i,j]=q; s[i,j]=k;</span><br><span class="line">Return m <span class="built_in">and</span> s.</span><br></pre></td></tr></table></figure>
<p><a href="javascript:void(0" target="_blank" rel="noopener"><img src="https://common.cnblogs.com/images/copycode.gif" alt="复制代码"></a>;)</p>
<p><a href="javascript:void(0" target="_blank" rel="noopener"><img src="https://common.cnblogs.com/images/copycode.gif" alt="复制代码"></a>;)</p>
<figure class="highlight stata"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">Print</span>-Optimal-Parens(s, i, j) <span class="comment">//构建最优解，输出A1-n的优化计算顺序</span></span><br><span class="line"> <span class="keyword">IF</span> j=<span class="built_in">i</span></span><br><span class="line"> THEN <span class="keyword">Print</span> “A”i;</span><br><span class="line"> <span class="keyword">ELSE</span> <span class="keyword">Print</span> “(”</span><br><span class="line">     <span class="keyword">Print</span>-Optimal-Parens(s, i, s[i, j])</span><br><span class="line">     <span class="keyword">Print</span>-Optimal-Parens(s, s[i, j]+1, j)</span><br><span class="line">     <span class="keyword">Print</span> “)”</span><br></pre></td></tr></table></figure>
<p><a href="javascript:void(0" target="_blank" rel="noopener"><img src="https://common.cnblogs.com/images/copycode.gif" alt="复制代码"></a>;)</p>
<ul>
<li>算法复杂度<ul>
<li>计算代价的时间：三层循环 O(n3)</li>
<li>构建最优解的时间： O(n)</li>
<li><strong>总时间复杂度：O(n3)</strong></li>
</ul>
</li>
<li><p>空间复杂度</p>
<ul>
<li>使用数组m和s</li>
<li>需要<strong>空间O(n3)</strong></li>
</ul>
<p><strong>【三角剖分】</strong></p>
</li>
<li><p><strong>优化子结构</strong>：将多边形P划分为不相交三角形的弦的集合</p>
</li>
<li><strong>优化问题</strong>:</li>
</ul>
<p><img src="https://images2018.cnblogs.com/blog/1336655/201806/1336655-20180626150321546-748343160.png" alt="img"></p>
<ul>
<li><p><strong>方程</strong>：设t[i,j] = &lt;vi-1,vi,…..,vj&gt;的优化三角剖分代价</p>
<p>　<img src="https://images2018.cnblogs.com/blog/1336655/201806/1336655-20180626150546681-278989483.png" alt="img"></p>
</li>
</ul>
<h3 id="3-6-数轴动态规划：0-1背包"><a href="#3-6-数轴动态规划：0-1背包" class="headerlink" title="3.6 数轴动态规划：0-1背包"></a>3.6 数轴动态规划：0-1背包</h3><p>### </p>
<ul>
<li><strong>问题描述</strong>：给定n种物品和一个背包，物品i的重量是wi，价值vi，背包容量为C，问如何选择装入背包的物品，使装入背包中的物品的总价值最大？对于每种物品总能选择完全装入或不装入，一个物品最多装入一次。</li>
<li><strong>等价整数规划问题：</strong></li>
</ul>
<p>　　　　<img src="https://images2018.cnblogs.com/blog/1336655/201806/1336655-20180626151529727-1771169615.png" alt="img"></p>
<ul>
<li><strong>Naive的方法</strong>：每个物品只有两种选择：不装或装，n个物品共2n个装取方案，每个装取方案的计算代价为n，总计算代价为O(n2n)</li>
<li><p><strong>问题的划分：</strong></p>
<p>　<img src="https://images2018.cnblogs.com/blog/1336655/201806/1336655-20180626151725491-1249436922.png" alt="img"></p>
</li>
<li><p><strong>定义代价矩阵m与方程</strong>：  </p>
</li>
<li><ul>
<li><strong><em>定义m(i, j)\</em> :</strong>背包容量为j，可选物品为xi,xi+1…xn时，问题的最优解代价时m[i,j]</li>
<li><em>m(n, j) = 0,  0</em> ≤ <em>j &lt;wn</em></li>
<li><em>m(n, j) = vn,  j ≥**wn</em></li>
<li><em>m(i, j) = m(i+1, j), 　　   0≤</em> <em>j&lt; wi</em></li>
<li><em>m(i, j) = max{m(i+1, j), m(i+1, j-wi)+vi},   j ≥</em> <em>wi</em></li>
</ul>
</li>
<li><p><strong>优化子结构和自底向上的代价</strong></p>
</li>
</ul>
<p>　　<img src="https://images2018.cnblogs.com/blog/1336655/201806/1336655-20180626154205161-1543350290.png" alt="img"><img src="https://images2018.cnblogs.com/blog/1336655/201806/1336655-20180626154222124-1568769512.png" alt="img"></p>
<ul>
<li><strong>伪代码</strong></li>
</ul>
<p><a href="javascript:void(0" target="_blank" rel="noopener"><img src="https://common.cnblogs.com/images/copycode.gif" alt="复制代码"></a>;)</p>
<p>输入：C&gt;0, wi&gt;0, vi&gt;0, 1≤ i≤n<br>输出：(x1, x2, …, xn), xi∈{0, 1}, 满足 ∑1≤i≤nwi xi ≤C, ∑1≤i≤nvi xi 最大</p>
<figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">For</span> <span class="attribute">j</span>=0 <span class="keyword">To</span> min(wn-1, C) <span class="keyword">Do</span></span><br><span class="line">      m[n, j] = 0;</span><br><span class="line"><span class="keyword">For</span> <span class="attribute">j</span>=wn <span class="keyword">To</span> C <span class="keyword">Do</span></span><br><span class="line">      m[n, j] = vn;</span><br><span class="line"><span class="keyword">For</span> <span class="attribute">i</span>=n-1 <span class="keyword">To</span> 2 <span class="keyword">Do</span></span><br><span class="line">    <span class="keyword">For</span> <span class="attribute">j</span>=0 <span class="keyword">To</span> min(wi -1, C)  <span class="keyword">Do</span></span><br><span class="line">      m[i, j] = m[i+1, j];</span><br><span class="line">    <span class="keyword">For</span> <span class="attribute">j</span>=wi  <span class="keyword">To</span> C   <span class="keyword">Do</span></span><br><span class="line">      m[i, j]=max&#123;m[i+1, j], m[i+1, j-wi]+vi&#125;;</span><br><span class="line"><span class="keyword">If</span>  C&lt;w1  Then  m[1, C]=m[2, C];</span><br><span class="line">      <span class="keyword">Else</span>  m[1, C]=max&#123;m[2, C], m[2, C-w1]+v1&#125;;</span><br></pre></td></tr></table></figure>
<p><a href="javascript:void(0" target="_blank" rel="noopener"><img src="https://common.cnblogs.com/images/copycode.gif" alt="复制代码"></a>;)</p>
<p><a href="javascript:void(0" target="_blank" rel="noopener"><img src="https://common.cnblogs.com/images/copycode.gif" alt="复制代码"></a>;)</p>
<figure class="highlight stata"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">m</span>(1, C)是最优解代价值，相应解计算如下: <span class="comment">//构造优化解</span></span><br><span class="line">    <span class="keyword">If</span> <span class="built_in">m</span>(1, C) = <span class="built_in">m</span>(2, C)</span><br><span class="line">    Then x1 = 0;</span><br><span class="line">    <span class="keyword">Else</span> x1 = 1;</span><br><span class="line">如果x1=0, 由<span class="built_in">m</span>(2, C)继续构造最优解;</span><br><span class="line">如果x1=1, 由<span class="built_in">m</span>(2, C-w1)继续构造最优解.</span><br></pre></td></tr></table></figure>
<p><a href="javascript:void(0" target="_blank" rel="noopener"><img src="https://common.cnblogs.com/images/copycode.gif" alt="复制代码"></a>;)</p>
<ul>
<li>时间复杂度：<ul>
<li>计算代价的时间为O(Cn)</li>
<li>构造最优解的时间:O(Cn)</li>
<li><strong>总时间复杂度为:O(Cn)</strong></li>
</ul>
</li>
<li>空间复杂度：<ul>
<li><strong>使用数组m，需要空间O(Cn)</strong></li>
</ul>
</li>
</ul>
<h3 id="3-7-前缀动态规划：最长公共子序列（LCS）"><a href="#3-7-前缀动态规划：最长公共子序列（LCS）" class="headerlink" title="3.7 前缀动态规划：最长公共子序列（LCS）"></a>3.7 前缀动态规划：最长公共子序列（LCS）</h3><p>### </p>
<ul>
<li><strong>问题描述</strong>：Z是序列X与Y的公共子序列如果Z是X的子序列也是Y的子序列。</li>
<li><p><strong>Naive方法：</strong></p>
<ul>
<li>枚举X的每个子序列Z</li>
<li>检查Z是否为Y的子序列</li>
<li><strong>T(n)=O(n2m)</strong></li>
</ul>
</li>
<li><p><strong>优化子结构：</strong></p>
</li>
<li><ul>
<li><em>设X=(x1, …, xm)、Y=(y1, …, yn)是两个序列， LCSXY=(z1, …, zk)是X与Y的LCS，我们有：</em></li>
<li><em>如果xm=yn, 则zk=xm=yn, LCSXY = LCSXm-1Yn-1 + &lt;xm=yn&gt;,  LCSXm-1Yn-1是Xm-1和Yn-1的LCS.</em></li>
<li><em>如果xm<strong>≠yn，且zk≠</strong>xm，则LCSXY是Xm-1和Y的LCS，即 LCSXY = LCSXm-1Y</em></li>
<li><em>如果xm≠<strong>yn,且zk≠</strong>yn,则LCSXY是X与Yn-1的LCS，即 LCSXY = LCSXYn-1</em></li>
</ul>
</li>
</ul>
<p>　　　　<em><img src="https://images2018.cnblogs.com/blog/1336655/201806/1336655-20180626161250797-846687005.png" alt="img"></em></p>
<ul>
<li><strong>子问题重叠性</strong></li>
</ul>
<p><img src="https://images2018.cnblogs.com/blog/1336655/201806/1336655-20180626161407046-1649798663.png" alt="img"></p>
<ul>
<li><strong>方程：</strong></li>
</ul>
<p>　　　　<strong><img src="https://images2018.cnblogs.com/blog/1336655/201806/1336655-20180626161153121-2116602929.png" alt="img"></strong></p>
<ul>
<li><strong>自底向上计算：</strong></li>
</ul>
<p>　　　　<img src="https://images2018.cnblogs.com/blog/1336655/201806/1336655-20180626161510812-1390787212.png" alt="img"></p>
<ul>
<li><strong>伪代码</strong></li>
</ul>
<p><strong><img src="https://images2018.cnblogs.com/blog/1336655/201806/1336655-20180626164412918-1817122808.png" alt="img"></strong></p>
<p><a href="javascript:void(0" target="_blank" rel="noopener"><img src="https://common.cnblogs.com/images/copycode.gif" alt="复制代码"></a>;)</p>
<figure class="highlight mathematica"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line">输入：X = (x1,x2,...,xm)，Y = (y1,y2,...yn)</span><br><span class="line">输出：Z = X与Y的最长公共子序列</span><br><span class="line"></span><br><span class="line"><span class="keyword">C</span>[<span class="number">0</span>:m,<span class="number">0</span>:n]: <span class="keyword">C</span>[i,j]是Xi与Yj的LCS的长度   B[<span class="number">1</span>:m,<span class="number">1</span>:n]:</span><br><span class="line">B[i,j]是指针，指向计算<span class="keyword">C</span>[i,j]时所选择的子问题的优化解所对应的<span class="keyword">C</span>表的表项</span><br><span class="line"></span><br><span class="line">LCS-length(X, Y)</span><br><span class="line">m←length(X)；n←length(Y)；</span><br><span class="line"><span class="keyword">For</span> i←<span class="number">0</span> To m <span class="keyword">Do</span> <span class="keyword">C</span>[i,<span class="number">0</span>]←<span class="number">0</span>;</span><br><span class="line"><span class="keyword">For</span> j←<span class="number">0</span> To n <span class="keyword">Do</span> <span class="keyword">C</span>[<span class="number">0</span>,j]←<span class="number">0</span>;</span><br><span class="line"><span class="keyword">For</span> i←<span class="number">1</span> To m <span class="keyword">Do</span></span><br><span class="line">  <span class="keyword">For</span> j←<span class="number">1</span> To n <span class="keyword">Do</span></span><br><span class="line">    <span class="keyword">If</span> xi = yj</span><br><span class="line">    Then <span class="keyword">C</span>[i,j]←<span class="keyword">C</span>[i<span class="number">-1</span>,j<span class="number">-1</span>]+<span class="number">1</span>；B[i,j]←“↖”;</span><br><span class="line">      Else <span class="keyword">If</span> <span class="keyword">C</span>[i<span class="number">-1</span>,j]≥<span class="keyword">C</span>[i,j<span class="number">-1</span>] Then</span><br><span class="line">              <span class="keyword">C</span>[i,j]←<span class="keyword">C</span>[i<span class="number">-1</span>,j]; B[i,j]←“↑”;</span><br><span class="line">           Else <span class="keyword">C</span>[i,j]←<span class="keyword">C</span>[i,j<span class="number">-1</span>]; B[i,j]←“←”;</span><br><span class="line"><span class="keyword">Return</span> <span class="keyword">C</span> and B.</span><br><span class="line"></span><br><span class="line"><span class="keyword">Print</span>-LCS(B, X, i, j)</span><br><span class="line">IF i=<span class="number">0</span> or j=<span class="number">0</span> THEN <span class="keyword">Return</span>;</span><br><span class="line">IF B[i, j]=“↖”</span><br><span class="line">THEN <span class="keyword">Print</span>-LCS(B, X, i<span class="number">-1</span>, j<span class="number">-1</span>);</span><br><span class="line">    <span class="keyword">Print</span> xi;</span><br><span class="line">ELSE <span class="keyword">If</span> B[i, j]=“↑”</span><br><span class="line">    THEN <span class="keyword">Print</span>-LCS(B, X, i<span class="number">-1</span>, j);</span><br><span class="line">    ELSE <span class="keyword">Print</span>-LCS(B, X, i, j<span class="number">-1</span>).</span><br><span class="line"></span><br><span class="line"><span class="keyword">Print</span>-LCS(B, X, length(X), length(Y))</span><br><span class="line">      可打印出X与Y的LCS。</span><br></pre></td></tr></table></figure>
<p><a href="javascript:void(0" target="_blank" rel="noopener"><img src="https://common.cnblogs.com/images/copycode.gif" alt="复制代码"></a>;)</p>
<ul>
<li><p>时间复杂度</p>
<p>：</p>
<ul>
<li>计算代价的时间：O(mn)</li>
<li>构造最优解的时间：O(m+n)</li>
<li><strong>总时间复杂度为： O(mn)</strong></li>
</ul>
</li>
<li><p>空间复杂度</p>
<p>：</p>
<ul>
<li>使用数组C和B，需要<strong>空间O(mn)</strong></li>
</ul>
</li>
</ul>
<h3 id="3-8-树形动态规划：最优二分搜索树"><a href="#3-8-树形动态规划：最优二分搜索树" class="headerlink" title="3.8 树形动态规划：最优二分搜索树"></a>3.8 树形动态规划：最优二分搜索树</h3><hr>
<p>参考：</p>
<p>🔗 《<a href="https://zh.wikipedia.org/zh-hans/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92" target="_blank" rel="noopener">维基百科-动态规划</a>》</p>
<p>🔗 《<a href="https://www.cnblogs.com/hithongming/p/9229871.html" target="_blank" rel="noopener">【算法复习】动态规划</a>》</p>
<p>🔗 《<a href="https://www.cnblogs.com/hithongming/p/9229871.html" target="_blank" rel="noopener">如何理解动态规划？</a>》</p>

      
    </div>
    
    
    

    

    

    
      <div>
        <ul class="post-copyright">
  <li class="post-copyright-author">
    <strong>本文作者：</strong>
    林沂水
  </li>
  <li class="post-copyright-link">
    <strong>本文链接：</strong>
    <a href="http://linyishui.top/2021031501.html" title="动态规划（未完成）">http://linyishui.top/2021031501.html</a>
  </li>
  <li class="post-copyright-license">
    <strong>版权声明： </strong>
    本博客所有文章除特别声明外，均采用 <a href="https://creativecommons.org/licenses/by-nc-sa/3.0/" rel="external nofollow" target="_blank">CC BY-NC-SA 3.0</a> 许可协议。转载请注明出处！
  </li>
</ul>

      </div>
    

    
      <div>
         ﻿<div>
    
        <div style="text-align:center;color: #ccc;font-size:14px;">-------------本文结束<i class="fa fa-paw"></i>感谢您的阅读-------------</div>
    
</div>

      </div>
    
    
    <footer class="post-footer">
      
        <div class="post-tags">
          
            <a href="/tags/algorithm/" rel="tag"># algorithm</a>
          
            <a href="/tags/unfinished/" rel="tag"># unfinished</a>
          
        </div>
      

      
      
      

      
        <div class="post-nav">
          <div class="post-nav-next post-nav-item">
            
              <a href="/2021030401.html" rel="next" title="算法复习 (三) 图-无向图（未完成）">
                <i class="fa fa-chevron-left"></i> 算法复习 (三) 图-无向图（未完成）
              </a>
            
          </div>

          <span class="post-nav-divider"></span>

          <div class="post-nav-prev post-nav-item">
            
              <a href="/2021041901.html" rel="prev" title="分布式一致性">
                分布式一致性 <i class="fa fa-chevron-right"></i>
              </a>
            
          </div>
        </div>
      

      
      
    </footer>
  </div>
  
  
  
  </article>



    <div class="post-spread">
      
    </div>
  </div>


          </div>
          


          

  
     <div class="comments" id="comments">
       

<script src="https://utteranc.es/client.js" repo="LAILAIWA/LAILAIWA.github.io" issue-term="pathname" label="💬Comments" theme="github-light" crossorigin="anonymous" async>
</script>



     </div>
  



        </div>
        
          
  
  <div class="sidebar-toggle">
    <div class="sidebar-toggle-line-wrap">
      <span class="sidebar-toggle-line sidebar-toggle-line-first"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-middle"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-last"></span>
    </div>
  </div>

  <aside id="sidebar" class="sidebar">
    
    <div class="sidebar-inner">

      

      
        <ul class="sidebar-nav motion-element">
          <li class="sidebar-nav-toc sidebar-nav-active" data-target="post-toc-wrap">
            文章目录
          </li>
          <li class="sidebar-nav-overview" data-target="site-overview-wrap">
            站点概览
          </li>
        </ul>
      

      <section class="site-overview-wrap sidebar-panel">
        <div class="site-overview">
          <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
            
              <img class="site-author-image" itemprop="image" src="https://pic-1258215793.cos.ap-shanghai.myqcloud.com/cover/riho_yoshioka1.jpg" alt="林沂水">
            
              <p class="site-author-name" itemprop="name">林沂水</p>
              <p class="site-description motion-element" itemprop="description">记录编程点滴，写点生活中的酸甜</p>
          </div>

          <nav class="site-state motion-element">

            
              <div class="site-state-item site-state-posts">
              
                <a href="/archives/">
              
                  <span class="site-state-item-count">311</span>
                  <span class="site-state-item-name">日志</span>
                </a>
              </div>
            

            
              
              
              <div class="site-state-item site-state-categories">
                <a href="/categories/index.html">
                  <span class="site-state-item-count">8</span>
                  <span class="site-state-item-name">分类</span>
                </a>
              </div>
            

            
              
              
              <div class="site-state-item site-state-tags">
                <a href="/tags/index.html">
                  <span class="site-state-item-count">100</span>
                  <span class="site-state-item-name">标签</span>
                </a>
              </div>
            

          </nav>

          
            <div class="feed-link motion-element">
              <a href="/atom.xml" rel="alternate">
                <i class="fa fa-rss"></i>
                RSS
              </a>
            </div>
          

          
            <div class="links-of-author motion-element">
                
                  <span class="links-of-author-item">
                    <a href="https://github.com/LAILAIWA" target="_blank" title="GitHub">
                      
                        <i class="fa fa-fw fa-github"></i>GitHub</a>
                  </span>
                
                  <span class="links-of-author-item">
                    <a href="mailto:linyishui168@outlook.com" target="_blank" title="E-Mail">
                      
                        <i class="fa fa-fw fa-envelope"></i>E-Mail</a>
                  </span>
                
                  <span class="links-of-author-item">
                    <a href="https://twitter.com/linyishui618" target="_blank" title="Twitter">
                      
                        <i class="fa fa-fw fa-twitter"></i>Twitter</a>
                  </span>
                
                  <span class="links-of-author-item">
                    <a href="https://instagram.com/linyishui618" target="_blank" title="Instagram">
                      
                        <i class="fa fa-fw fa-instagram"></i>Instagram</a>
                  </span>
                
                  <span class="links-of-author-item">
                    <a href="https://weibo.com/u/5340162234" target="_blank" title="Weibo">
                      
                        <i class="fa fa-fw fa-weibo.com"></i>Weibo</a>
                  </span>
                
            </div>
          

          
          

          
          

          <div id="days"></div>
<script>
function show_date_time(){
    window.setTimeout("show_date_time()", 1000);
    BirthDay=new Date("07/26/2018 00:00:00");
    today=new Date();
    timeold=(today.getTime()-BirthDay.getTime());
    sectimeold=timeold/1000
    secondsold=Math.floor(sectimeold);
    msPerDay=24*60*60*1000
    e_daysold=timeold/msPerDay
    daysold=Math.floor(e_daysold);
    e_hrsold=(e_daysold-daysold)*24;
    hrsold=setzero(Math.floor(e_hrsold));
    e_minsold=(e_hrsold-hrsold)*60;
    minsold=setzero(Math.floor((e_hrsold-hrsold)*60));
    seconds=setzero(Math.floor((e_minsold-minsold)*60));
    document.getElementById('days').innerHTML="已运行 "+daysold+" 天 "+hrsold+" 小时 "+minsold+" 分 "+seconds+" 秒";
}
function setzero(i) {
    if (i<10) {
        i="0" + i
    };
    return i;
}
show_date_time();
</script>  
        </div>
      </section>

      
      <!--noindex-->
        <section class="post-toc-wrap motion-element sidebar-panel sidebar-panel-active">
          <div class="post-toc">

            
              
            

            
              <div class="post-toc-content"><ol class="nav"><li class="nav-item nav-level-1"><a class="nav-link" href="#动态规划"><span class="nav-text">动态规划</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#一-概述"><span class="nav-text">一. 概述</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#1-1-什么是动态规划？"><span class="nav-text">1.1 什么是动态规划？</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#概念引入"><span class="nav-text">概念引入</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#基本思想"><span class="nav-text">基本思想</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#基本概念"><span class="nav-text">基本概念</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#基本结构"><span class="nav-text">基本结构</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#适用条件"><span class="nav-text">适用条件</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#1-2-使用场景"><span class="nav-text">1.2 使用场景</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#1-3-动态规划与记忆化搜索"><span class="nav-text">1.3 动态规划与记忆化搜索</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#二-算法"><span class="nav-text">二. 算法</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#2-1-DP的两种实现方式"><span class="nav-text">2.1 DP的两种实现方式</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#2-2-DP常用来解决的问题"><span class="nav-text">2.2 DP常用来解决的问题</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#2-3-使用动态规划的算法"><span class="nav-text">2.3 使用动态规划的算法</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#2-4-实现原理"><span class="nav-text">2.4 实现原理</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#三-算法题"><span class="nav-text">三. 算法题</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#3-1-背包问题"><span class="nav-text">3.1 背包问题</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#3-2-切割钢条问题"><span class="nav-text">3.2 切割钢条问题</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#3-3-正则表达式匹配"><span class="nav-text">3.3 正则表达式匹配</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#3-4-编号动态规划：最大不下降子序列"><span class="nav-text">3.4 编号动态规划：最大不下降子序列</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#3-5-划分动态规划：矩阵链乘、凸多边形三角剖分"><span class="nav-text">3.5 划分动态规划：矩阵链乘、凸多边形三角剖分</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#3-6-数轴动态规划：0-1背包"><span class="nav-text">3.6 数轴动态规划：0-1背包</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#3-7-前缀动态规划：最长公共子序列（LCS）"><span class="nav-text">3.7 前缀动态规划：最长公共子序列（LCS）</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#3-8-树形动态规划：最优二分搜索树"><span class="nav-text">3.8 树形动态规划：最优二分搜索树</span></a></li></ol></li></ol></li></ol></div>
            

          </div>
        </section>
      <!--/noindex-->
      

      

    </div>
  </aside>


        
      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="footer-inner">
        ﻿<div class="copyright">&copy; 2018 &mdash; <span itemprop="copyrightYear">2021</span>
  <span class="with-love" id="heart">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">林沂水</span>

  
</div>


  <div class="powered-by">由 <a class="theme-link" target="_blank" href="https://hexo.io">Hexo</a> 强力驱动</div>



  <span class="post-meta-divider">|</span>



  <div class="theme-info">主题 &mdash; <a class="theme-link" target="_blank" href="https://github.com/iissnan/hexo-theme-next">NexT.Pisces</a> v5.1.4</div>




        







        
      </div>
    </footer>

    
      <div class="back-to-top">
        <i class="fa fa-arrow-up"></i>
        
      </div>
    

    
   

  </div>

  

<script type="text/javascript">
  if (Object.prototype.toString.call(window.Promise) !== '[object Function]') {
    window.Promise = null;
  }
</script>









  












  
  
    <script type="text/javascript" src="/lib/jquery/index.js?v=2.1.3"></script>
  

  
  
    <script type="text/javascript" src="/lib/fastclick/lib/fastclick.min.js?v=1.0.6"></script>
  

  
  
    <script type="text/javascript" src="/lib/jquery_lazyload/jquery.lazyload.js?v=1.9.7"></script>
  

  
  
    <script type="text/javascript" src="/lib/velocity/velocity.min.js?v=1.2.1"></script>
  

  
  
    <script type="text/javascript" src="/lib/velocity/velocity.ui.min.js?v=1.2.1"></script>
  

  
  
    <script type="text/javascript" src="/lib/fancybox/source/jquery.fancybox.pack.js?v=2.1.5"></script>
  


  


  <script type="text/javascript" src="/js/src/utils.js?v=5.1.4"></script>

  <script type="text/javascript" src="/js/src/motion.js?v=5.1.4"></script>



  
  


  <script type="text/javascript" src="/js/src/affix.js?v=5.1.4"></script>

  <script type="text/javascript" src="/js/src/schemes/pisces.js?v=5.1.4"></script>



  
  <script type="text/javascript" src="/js/src/scrollspy.js?v=5.1.4"></script>
<script type="text/javascript" src="/js/src/post-details.js?v=5.1.4"></script>



  


  <script type="text/javascript" src="/js/src/bootstrap.js?v=5.1.4"></script>



  


  




	





  





  












  

  <script type="text/javascript">
    // Popup Window;
    var isfetched = false;
    var isXml = true;
    // Search DB path;
    var search_path = "search.xml";
    if (search_path.length === 0) {
      search_path = "search.xml";
    } else if (/json$/i.test(search_path)) {
      isXml = false;
    }
    var path = "/" + search_path;
    // monitor main search box;

    var onPopupClose = function (e) {
      $('.popup').hide();
      $('#local-search-input').val('');
      $('.search-result-list').remove();
      $('#no-result').remove();
      $(".local-search-pop-overlay").remove();
      $('body').css('overflow', '');
    }

    function proceedsearch() {
      $("body")
        .append('<div class="search-popup-overlay local-search-pop-overlay"></div>')
        .css('overflow', 'hidden');
      $('.search-popup-overlay').click(onPopupClose);
      $('.popup').toggle();
      var $localSearchInput = $('#local-search-input');
      $localSearchInput.attr("autocapitalize", "none");
      $localSearchInput.attr("autocorrect", "off");
      $localSearchInput.focus();
    }

    // search function;
    var searchFunc = function(path, search_id, content_id) {
      'use strict';

      // start loading animation
      $("body")
        .append('<div class="search-popup-overlay local-search-pop-overlay">' +
          '<div id="search-loading-icon">' +
          '<i class="fa fa-spinner fa-pulse fa-5x fa-fw"></i>' +
          '</div>' +
          '</div>')
        .css('overflow', 'hidden');
      $("#search-loading-icon").css('margin', '20% auto 0 auto').css('text-align', 'center');

      $.ajax({
        url: path,
        dataType: isXml ? "xml" : "json",
        async: true,
        success: function(res) {
          // get the contents from search data
          isfetched = true;
          $('.popup').detach().appendTo('.header-inner');
          var datas = isXml ? $("entry", res).map(function() {
            return {
              title: $("title", this).text(),
              content: $("content",this).text(),
              url: $("url" , this).text()
            };
          }).get() : res;
          var input = document.getElementById(search_id);
          var resultContent = document.getElementById(content_id);
          var inputEventFunction = function() {
            var searchText = input.value.trim().toLowerCase();
            var keywords = searchText.split(/[\s\-]+/);
            if (keywords.length > 1) {
              keywords.push(searchText);
            }
            var resultItems = [];
            if (searchText.length > 0) {
              // perform local searching
              datas.forEach(function(data) {
                var isMatch = false;
                var hitCount = 0;
                var searchTextCount = 0;
                var title = data.title.trim();
                var titleInLowerCase = title.toLowerCase();
                var content = data.content.trim().replace(/<[^>]+>/g,"");
                var contentInLowerCase = content.toLowerCase();
                var articleUrl = decodeURIComponent(data.url);
                var indexOfTitle = [];
                var indexOfContent = [];
                // only match articles with not empty titles
                if(title != '') {
                  keywords.forEach(function(keyword) {
                    function getIndexByWord(word, text, caseSensitive) {
                      var wordLen = word.length;
                      if (wordLen === 0) {
                        return [];
                      }
                      var startPosition = 0, position = [], index = [];
                      if (!caseSensitive) {
                        text = text.toLowerCase();
                        word = word.toLowerCase();
                      }
                      while ((position = text.indexOf(word, startPosition)) > -1) {
                        index.push({position: position, word: word});
                        startPosition = position + wordLen;
                      }
                      return index;
                    }

                    indexOfTitle = indexOfTitle.concat(getIndexByWord(keyword, titleInLowerCase, false));
                    indexOfContent = indexOfContent.concat(getIndexByWord(keyword, contentInLowerCase, false));
                  });
                  if (indexOfTitle.length > 0 || indexOfContent.length > 0) {
                    isMatch = true;
                    hitCount = indexOfTitle.length + indexOfContent.length;
                  }
                }

                // show search results

                if (isMatch) {
                  // sort index by position of keyword

                  [indexOfTitle, indexOfContent].forEach(function (index) {
                    index.sort(function (itemLeft, itemRight) {
                      if (itemRight.position !== itemLeft.position) {
                        return itemRight.position - itemLeft.position;
                      } else {
                        return itemLeft.word.length - itemRight.word.length;
                      }
                    });
                  });

                  // merge hits into slices

                  function mergeIntoSlice(text, start, end, index) {
                    var item = index[index.length - 1];
                    var position = item.position;
                    var word = item.word;
                    var hits = [];
                    var searchTextCountInSlice = 0;
                    while (position + word.length <= end && index.length != 0) {
                      if (word === searchText) {
                        searchTextCountInSlice++;
                      }
                      hits.push({position: position, length: word.length});
                      var wordEnd = position + word.length;

                      // move to next position of hit

                      index.pop();
                      while (index.length != 0) {
                        item = index[index.length - 1];
                        position = item.position;
                        word = item.word;
                        if (wordEnd > position) {
                          index.pop();
                        } else {
                          break;
                        }
                      }
                    }
                    searchTextCount += searchTextCountInSlice;
                    return {
                      hits: hits,
                      start: start,
                      end: end,
                      searchTextCount: searchTextCountInSlice
                    };
                  }

                  var slicesOfTitle = [];
                  if (indexOfTitle.length != 0) {
                    slicesOfTitle.push(mergeIntoSlice(title, 0, title.length, indexOfTitle));
                  }

                  var slicesOfContent = [];
                  while (indexOfContent.length != 0) {
                    var item = indexOfContent[indexOfContent.length - 1];
                    var position = item.position;
                    var word = item.word;
                    // cut out 100 characters
                    var start = position - 20;
                    var end = position + 80;
                    if(start < 0){
                      start = 0;
                    }
                    if (end < position + word.length) {
                      end = position + word.length;
                    }
                    if(end > content.length){
                      end = content.length;
                    }
                    slicesOfContent.push(mergeIntoSlice(content, start, end, indexOfContent));
                  }

                  // sort slices in content by search text's count and hits' count

                  slicesOfContent.sort(function (sliceLeft, sliceRight) {
                    if (sliceLeft.searchTextCount !== sliceRight.searchTextCount) {
                      return sliceRight.searchTextCount - sliceLeft.searchTextCount;
                    } else if (sliceLeft.hits.length !== sliceRight.hits.length) {
                      return sliceRight.hits.length - sliceLeft.hits.length;
                    } else {
                      return sliceLeft.start - sliceRight.start;
                    }
                  });

                  // select top N slices in content

                  var upperBound = parseInt('1');
                  if (upperBound >= 0) {
                    slicesOfContent = slicesOfContent.slice(0, upperBound);
                  }

                  // highlight title and content

                  function highlightKeyword(text, slice) {
                    var result = '';
                    var prevEnd = slice.start;
                    slice.hits.forEach(function (hit) {
                      result += text.substring(prevEnd, hit.position);
                      var end = hit.position + hit.length;
                      result += '<b class="search-keyword">' + text.substring(hit.position, end) + '</b>';
                      prevEnd = end;
                    });
                    result += text.substring(prevEnd, slice.end);
                    return result;
                  }

                  var resultItem = '';

                  if (slicesOfTitle.length != 0) {
                    resultItem += "<li><a href='" + articleUrl + "' class='search-result-title'>" + highlightKeyword(title, slicesOfTitle[0]) + "</a>";
                  } else {
                    resultItem += "<li><a href='" + articleUrl + "' class='search-result-title'>" + title + "</a>";
                  }

                  slicesOfContent.forEach(function (slice) {
                    resultItem += "<a href='" + articleUrl + "'>" +
                      "<p class=\"search-result\">" + highlightKeyword(content, slice) +
                      "...</p>" + "</a>";
                  });

                  resultItem += "</li>";
                  resultItems.push({
                    item: resultItem,
                    searchTextCount: searchTextCount,
                    hitCount: hitCount,
                    id: resultItems.length
                  });
                }
              })
            };
            if (keywords.length === 1 && keywords[0] === "") {
              resultContent.innerHTML = '<div id="no-result"><i class="fa fa-search fa-5x" /></div>'
            } else if (resultItems.length === 0) {
              resultContent.innerHTML = '<div id="no-result"><i class="fa fa-frown-o fa-5x" /></div>'
            } else {
              resultItems.sort(function (resultLeft, resultRight) {
                if (resultLeft.searchTextCount !== resultRight.searchTextCount) {
                  return resultRight.searchTextCount - resultLeft.searchTextCount;
                } else if (resultLeft.hitCount !== resultRight.hitCount) {
                  return resultRight.hitCount - resultLeft.hitCount;
                } else {
                  return resultRight.id - resultLeft.id;
                }
              });
              var searchResultList = '<ul class=\"search-result-list\">';
              resultItems.forEach(function (result) {
                searchResultList += result.item;
              })
              searchResultList += "</ul>";
              resultContent.innerHTML = searchResultList;
            }
          }

          if ('auto' === 'auto') {
            input.addEventListener('input', inputEventFunction);
          } else {
            $('.search-icon').click(inputEventFunction);
            input.addEventListener('keypress', function (event) {
              if (event.keyCode === 13) {
                inputEventFunction();
              }
            });
          }

          // remove loading animation
          $(".local-search-pop-overlay").remove();
          $('body').css('overflow', '');

          proceedsearch();
        }
      });
    }

    // handle and trigger popup window;
    $('.popup-trigger').click(function(e) {
      e.stopPropagation();
      if (isfetched === false) {
        searchFunc(path, 'local-search-input', 'local-search-result');
      } else {
        proceedsearch();
      };
    });

    $('.popup-btn-close').click(onPopupClose);
    $('.popup').click(function(e){
      e.stopPropagation();
    });
    $(document).on('keyup', function (event) {
      var shouldDismissSearchPopup = event.which === 27 &&
        $('.search-popup').is(':visible');
      if (shouldDismissSearchPopup) {
        onPopupClose();
      }
    });
  </script>





  

  

  

  
  

  

  

  

</body>
</html>
