<!DOCTYPE html>
<html lang="zh-CN">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width">
<meta name="theme-color" content="#222">
<meta name="generator" content="Hexo 5.4.0">


  <link rel="apple-touch-icon" sizes="180x180" href="/images/gamepad%20playstation.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/Dig%20Dug.ico">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/gamepad%20playstation.png">
  <link rel="mask-icon" href="/images/gamepad%20playstation.svg" color="#222">

<link rel="stylesheet" href="/css/main.css">

<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Monda:300,300italic,400,400italic,700,700italic%7CMa+Shan+Zheng:300,300italic,400,400italic,700,700italic%7CNoto+Serif+SC:300,300italic,400,400italic,700,700italic&display=swap&subset=latin,latin-ext">

<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free@5.15.3/css/all.min.css" integrity="sha256-2H3fkXt6FEmrReK448mDVGKb3WW2ZZw35gI7vqHOE4Y=" crossorigin="anonymous">
  <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/animate.css@3.1.1/animate.min.css" integrity="sha256-PR7ttpcvz8qrF57fur/yAx1qXMFJeJFiA6pSzWi0OIE=" crossorigin="anonymous">
  <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@3.5.7/dist/jquery.fancybox.min.css" integrity="sha256-Vzbj7sDDS/woiFS3uNKo8eIuni59rjyNGtXfstRzStA=" crossorigin="anonymous">
  <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/nprogress@0.2.0/nprogress.css" integrity="sha256-no0c5ccDODBwp+9hSmV5VvPpKwHCpbVzXHexIkupM6U=" crossorigin="anonymous">
  <script src="https://cdn.jsdelivr.net/npm/nprogress@0.2.0/nprogress.js" integrity="sha256-a5YRB27CcBwBFcT5EF/f3E4vzIqyHrSR878nseNYw64=" crossorigin="anonymous"></script>

<script class="next-config" data-name="main" type="application/json">{"hostname":"linyishui.top","root":"/","images":"/images","scheme":"Pisces","version":"8.6.0","exturl":false,"sidebar":{"position":"left","display":"always","padding":18,"offset":12},"copycode":true,"bookmark":{"enable":true,"color":"#222","save":"manual"},"fancybox":true,"mediumzoom":false,"lazyload":false,"pangu":false,"comments":{"style":"tabs","active":"utterances","storage":true,"lazyload":false,"nav":null,"activeClass":"utterances"},"motion":{"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"fadeInDown","post_body":"fadeInDown","coll_header":"fadeInLeft","sidebar":"fadeInUp"}},"prism":false,"i18n":{"placeholder":"搜索...","empty":"没有找到任何搜索结果：${query}","hits_time":"找到 ${hits} 个搜索结果（用时 ${time} 毫秒）","hits":"找到 ${hits} 个搜索结果"},"path":"/search.xml","localsearch":{"enable":true,"trigger":"auto","top_n_per_article":1,"unescape":false,"preload":false}}</script><script src="/js/config.js"></script>
<meta name="description" content="简单介绍Docker概览（一）容器，内容包括：容器的发展（过去、虚拟机、容器、Linux容器、Docker、Windows容器、Kubernetes），了解Docker，安装Docker，纵观Docker（运维视角、开发视角）等。">
<meta property="og:type" content="article">
<meta property="og:title" content="Docker（一）概览">
<meta property="og:url" content="http://linyishui.top/2019100701.html">
<meta property="og:site_name" content="俺的部落格">
<meta property="og:description" content="简单介绍Docker概览（一）容器，内容包括：容器的发展（过去、虚拟机、容器、Linux容器、Docker、Windows容器、Kubernetes），了解Docker，安装Docker，纵观Docker（运维视角、开发视角）等。">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="https://pic-1258215793.cos.ap-shanghai.myqcloud.com/content/20191001/201910010111.png">
<meta property="og:image" content="https://pic-1258215793.cos.ap-shanghai.myqcloud.com/content/20191001/201910010112.png">
<meta property="og:image" content="https://pic-1258215793.cos.ap-shanghai.myqcloud.com/content/20191001/201910010112.png">
<meta property="article:published_time" content="2019-10-07T02:34:47.000Z">
<meta property="article:modified_time" content="2021-06-20T14:57:12.000Z">
<meta property="article:author" content="Lys">
<meta property="article:tag" content="docker">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://pic-1258215793.cos.ap-shanghai.myqcloud.com/content/20191001/201910010111.png">


<link rel="canonical" href="http://linyishui.top/2019100701.html">



<script class="next-config" data-name="page" type="application/json">{"sidebar":"","isHome":false,"isPost":true,"lang":"zh-CN","comments":true,"permalink":"http://linyishui.top/2019100701.html","path":"2019100701.html","title":"Docker（一）概览"}</script>

<script class="next-config" data-name="calendar" type="application/json">""</script>
<title>Docker（一）概览 | 俺的部落格</title>
  




  <noscript>
    <link rel="stylesheet" href="/css/noscript.css">
  </noscript>
<link rel="alternate" href="/atom.xml" title="俺的部落格" type="application/atom+xml">
<style>.darkmode--activated{--body-bg-color:#282828;--content-bg-color:#333;--card-bg-color:#555;--text-color:#ccc;--blockquote-color:#bbb;--link-color:#ccc;--link-hover-color:#eee;--brand-color:#ddd;--brand-hover-color:#ddd;--table-row-odd-bg-color:#282828;--table-row-hover-bg-color:#363636;--menu-item-bg-color:#555;--btn-default-bg:#222;--btn-default-color:#ccc;--btn-default-border-color:#555;--btn-default-hover-bg:#666;--btn-default-hover-color:#ccc;--btn-default-hover-border-color:#666;--highlight-background:#282b2e;--highlight-foreground:#a9b7c6;--highlight-gutter-background:#34393d;--highlight-gutter-foreground:#9ca9b6}.darkmode--activated img{opacity:.75}.darkmode--activated img:hover{opacity:.9}.darkmode--activated code{color:#69dbdc;background:0 0}button.darkmode-toggle{z-index:9999}</style></head>

<body itemscope itemtype="http://schema.org/WebPage" class="use-motion">
  <div class="headband"></div>

  <main class="main">
    <header class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="切换导航栏" role="button">
        <span class="toggle-line"></span>
        <span class="toggle-line"></span>
        <span class="toggle-line"></span>
    </div>
  </div>

  <div class="site-meta">

    <a href="/" class="brand" rel="start">
      <i class="logo-line"></i>
      <h1 class="site-title">俺的部落格</h1>
      <i class="logo-line"></i>
    </a>
      <p class="site-subtitle" itemprop="description">俺寻思俺需要记点东西</p>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger">
        <i class="fa fa-search fa-fw fa-lg"></i>
    </div>
  </div>
</div>



<nav class="site-nav">
  <ul class="main-menu menu">
        <li class="menu-item menu-item-home"><a href="/" rel="section"><i class="fa fa-home fa-fw"></i>首页</a></li>
        <li class="menu-item menu-item-about"><a href="/about/" rel="section"><i class="fa fa-user fa-fw"></i>关于</a></li>
        <li class="menu-item menu-item-tags"><a href="/tags/" rel="section"><i class="fa fa-tags fa-fw"></i>标签</a></li>
        <li class="menu-item menu-item-categories"><a href="/categories/" rel="section"><i class="fa fa-th fa-fw"></i>分类</a></li>
        <li class="menu-item menu-item-archives"><a href="/archives/" rel="section"><i class="fa fa-archive fa-fw"></i>归档</a></li>
        <li class="menu-item menu-item-sitemap"><a href="/sitemap.xml" rel="section"><i class="fa fa-sitemap fa-fw"></i>站点地图</a></li>
        <li class="menu-item menu-item-tools"><a href="/links/" rel="section"><i class="fa fa-link fa-fw"></i>工具</a></li>
        <li class="menu-item menu-item-books"><a href="/books/" rel="section"><i class="fa fa-book fa-fw"></i>书架</a></li>
        <li class="menu-item menu-item-movies"><a href="/movies/" rel="section"><i class="fa fa-video fa-fw"></i>剧院</a></li>
        <li class="menu-item menu-item-games"><a href="/games/" rel="section"><i class="fa fa-gamepad fa-fw"></i>游戏</a></li>
        <li class="menu-item menu-item-commonweal"><a href="/404/" rel="section"><i class="fa fa-heartbeat fa-fw"></i>公益</a></li>
      <li class="menu-item menu-item-search">
        <a role="button" class="popup-trigger"><i class="fa fa-search fa-fw"></i>搜索
        </a>
      </li>
  </ul>
</nav>



  <div class="search-pop-overlay">
    <div class="popup search-popup"><div class="search-header">
  <span class="search-icon">
    <i class="fa fa-search"></i>
  </span>
  <div class="search-input-container">
    <input autocomplete="off" autocapitalize="off" maxlength="80"
           placeholder="搜索..." spellcheck="false"
           type="search" class="search-input">
  </div>
  <span class="popup-btn-close" role="button">
    <i class="fa fa-times-circle"></i>
  </span>
</div>
<div class="search-result-container no-result">
  <div class="search-result-icon">
    <i class="fa fa-spinner fa-pulse fa-5x"></i>
  </div>
</div>

    </div>
  </div>

</div>
        
  
  <div class="toggle sidebar-toggle" role="button">
    <span class="toggle-line"></span>
    <span class="toggle-line"></span>
    <span class="toggle-line"></span>
  </div>

  <aside class="sidebar">

    <div class="sidebar-inner sidebar-nav-active sidebar-toc-active">
      <ul class="sidebar-nav">
        <li class="sidebar-nav-toc">
          文章目录
        </li>
        <li class="sidebar-nav-overview">
          站点概览
        </li>
      </ul>

      <div class="sidebar-panel-container">
        <!--noindex-->
        <div class="post-toc-wrap sidebar-panel">
            <div class="post-toc animated"><ol class="nav"><li class="nav-item nav-level-1"><a class="nav-link" href="#Docker%E6%A6%82%E8%A7%88%EF%BC%88%E4%B8%80%EF%BC%89%E6%A6%82%E8%A7%88"><span class="nav-text">Docker概览（一）概览</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#%E7%AC%AC%E4%B8%80%E8%8A%82-%E5%AE%B9%E5%99%A8%E7%9A%84%E5%8F%91%E5%B1%95"><span class="nav-text">第一节 容器的发展</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#1-1-%E8%BF%87%E5%8E%BB"><span class="nav-text">1.1 过去</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#1-2-%E8%99%9A%E6%8B%9F%E6%9C%BA"><span class="nav-text">1.2 虚拟机</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#1-3-%E5%AE%B9%E5%99%A8"><span class="nav-text">1.3 容器</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#1-4-Linux%E5%AE%B9%E5%99%A8"><span class="nav-text">1.4 Linux容器</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#1-5-Docker"><span class="nav-text">1.5 Docker</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#1-6-Windows%E5%AE%B9%E5%99%A8"><span class="nav-text">1.6 Windows容器</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#1-7-Kubernetes"><span class="nav-text">1.7 Kubernetes</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E7%AC%AC%E4%BA%8C%E8%8A%82-%E4%BA%86%E8%A7%A3Docker"><span class="nav-text">第二节 了解Docker</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#2-1-%E7%AE%80%E4%BB%8B"><span class="nav-text">2.1 简介</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#2-2-Docker%E8%BF%90%E8%A1%8C%E6%97%B6%E4%B8%8E%E7%BC%96%E6%8E%92%E5%BC%95%E6%93%8E"><span class="nav-text">2.2 Docker运行时与编排引擎</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#2-3-Docker%E5%BC%80%E6%BA%90%E9%A1%B9%E7%9B%AE%EF%BC%88Moby%EF%BC%89"><span class="nav-text">2.3 Docker开源项目（Moby）</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#2-4-%E5%AE%B9%E5%99%A8%E7%94%9F%E6%80%81"><span class="nav-text">2.4 容器生态</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#2-5-%E5%BC%80%E6%94%BE%E5%AE%B9%E5%99%A8%E8%AE%A1%E5%88%92"><span class="nav-text">2.5 开放容器计划</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E7%AC%AC%E4%B8%89%E8%8A%82-%E5%AE%89%E8%A3%85Docker"><span class="nav-text">第三节 安装Docker</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#3-1-Windows%E7%89%88Docker%EF%BC%88DfW%EF%BC%89"><span class="nav-text">3.1 Windows版Docker（DfW）</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%BC%80%E5%90%AFHyper-V%E5%92%8C%E5%AE%B9%E5%99%A8"><span class="nav-text">开启Hyper-V和容器</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%AE%B6%E5%BA%AD%E7%89%88%E6%89%8B%E5%8A%A8%E4%BC%AA%E8%A3%85%E4%B8%93%E4%B8%9A%E7%89%88"><span class="nav-text">家庭版手动伪装专业版</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E6%AD%A3%E5%BC%8F%E5%AE%89%E8%A3%85"><span class="nav-text">正式安装</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#3-2-Mac%E7%89%88Docker%EF%BC%88DfM%EF%BC%89"><span class="nav-text">3.2　Mac版Docker（DfM）</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#3-3-%E5%9C%A8Linux%E4%B8%8A%E5%AE%89%E8%A3%85Docker"><span class="nav-text">3.3　在Linux上安装Docker</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#3-4-%E5%9C%A8Windows-Server-2016%E4%B8%8A%E5%AE%89%E8%A3%85Docker"><span class="nav-text">3.4 在Windows Server 2016上安装Docker</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#3-5-Docker%E5%BC%95%E6%93%8E%EF%BC%88Engine%EF%BC%89%E5%8D%87%E7%BA%A7"><span class="nav-text">3.5 Docker引擎（Engine）升级</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%9C%A8Ubuntu-16-04%E4%B8%8A%E5%8D%87%E7%BA%A7Docker-CE"><span class="nav-text">在Ubuntu 16.04上升级Docker CE</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%9C%A8Windows-Server-2016%E4%B8%8A%E5%8D%87%E7%BA%A7Docker-EE"><span class="nav-text">在Windows Server 2016上升级Docker EE</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#3-6-Docker%E5%AD%98%E5%82%A8%E9%A9%B1%E5%8A%A8%E7%9A%84%E9%80%89%E6%8B%A9"><span class="nav-text">3.6 Docker存储驱动的选择</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#3-6-1-Device-Mapper%E9%85%8D%E7%BD%AE"><span class="nav-text">3.6.1 Device Mapper配置</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#3-6-2-%E8%AE%A9Docker%E8%87%AA%E5%8A%A8%E8%AE%BE%E7%BD%AEdirect-lvm"><span class="nav-text">3.6.2 让Docker自动设置direct-lvm</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#3-6-3-%E6%89%8B%E5%8A%A8%E9%85%8D%E7%BD%AEDevice-Mapper%E7%9A%84direct-lvm"><span class="nav-text">3.6.3 手动配置Device Mapper的direct-lvm</span></a></li></ol></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E7%AC%AC%E5%9B%9B%E8%8A%82-%E7%BA%B5%E8%A7%82Docker"><span class="nav-text">第四节 纵观Docker</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#4-1-%E8%BF%90%E7%BB%B4%E8%A7%86%E8%A7%92"><span class="nav-text">4.1 运维视角</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#4-1-1-%E9%95%9C%E5%83%8F"><span class="nav-text">4.1.1 镜像</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#4-1-2-%E5%AE%B9%E5%99%A8"><span class="nav-text">4.1.2 容器</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#4-1-3-%E8%BF%9E%E6%8E%A5%E5%88%B0%E8%BF%90%E8%A1%8C%E4%B8%AD%E7%9A%84%E5%AE%B9%E5%99%A8"><span class="nav-text">4.1.3 连接到运行中的容器</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#4-2-%E5%BC%80%E5%8F%91%E8%A7%86%E8%A7%92"><span class="nav-text">4.2 开发视角</span></a></li></ol></li></ol></li></ol></div>
        </div>
        <!--/noindex-->

        <div class="site-overview-wrap sidebar-panel">
          <div class="site-overview">
            <div class="site-author site-overview-item animated" itemprop="author" itemscope itemtype="http://schema.org/Person">
    <img class="site-author-image" itemprop="image" alt="Lys"
      src="https://pic-1258215793.cos.ap-shanghai.myqcloud.com/cover/IMG_0759.JPG">
  <p class="site-author-name" itemprop="name">Lys</p>
  <div class="site-description" itemprop="description">记录编程点滴，写点生活中的酸甜</div>
</div>
<div class="site-state-wrap site-overview-item animated">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
          <a href="/archives/">
        
          <span class="site-state-item-count">324</span>
          <span class="site-state-item-name">日志</span>
        </a>
      </div>
      <div class="site-state-item site-state-categories">
            <a href="/categories/">
          
        <span class="site-state-item-count">11</span>
        <span class="site-state-item-name">分类</span></a>
      </div>
      <div class="site-state-item site-state-tags">
            <a href="/tags/">
          
        <span class="site-state-item-count">109</span>
        <span class="site-state-item-name">标签</span></a>
      </div>
  </nav>
</div>
  <div class="links-of-author site-overview-item animated">
      <span class="links-of-author-item">
        <a href="https://github.com/LAILAIWA" title="GitHub → https:&#x2F;&#x2F;github.com&#x2F;LAILAIWA" rel="noopener" target="_blank"><i class="fab fa-github fa-fw"></i>GitHub</a>
      </span>
      <span class="links-of-author-item">
        <a href="mailto:linyishui168@outlook.com" title="E-Mail → mailto:linyishui168@outlook.com" rel="noopener" target="_blank"><i class="fa fa-envelope fa-fw"></i>E-Mail</a>
      </span>
      <span class="links-of-author-item">
        <a href="https://weibo.com/u/5340162234" title="Weibo → https:&#x2F;&#x2F;weibo.com&#x2F;u&#x2F;5340162234" rel="noopener" target="_blank"><i class="fab fa-weibo fa-fw"></i>Weibo</a>
      </span>
      <span class="links-of-author-item">
        <a href="https://twitter.com/linyishui618" title="Twitter → https:&#x2F;&#x2F;twitter.com&#x2F;linyishui618" rel="noopener" target="_blank"><i class="fab fa-twitter fa-fw"></i>Twitter</a>
      </span>
      <span class="links-of-author-item">
        <a href="https://stackoverflow.com/users/13018339/lin-yishui" title="StackOverflow → https:&#x2F;&#x2F;stackoverflow.com&#x2F;users&#x2F;13018339&#x2F;lin-yishui" rel="noopener" target="_blank"><i class="fab fa-stack-overflow fa-fw"></i>StackOverflow</a>
      </span>
      <span class="links-of-author-item">
        <a href="https://instagram.com/linyishui618" title="Instagram → https:&#x2F;&#x2F;instagram.com&#x2F;linyishui618" rel="noopener" target="_blank"><i class="fab fa-instagram fa-fw"></i>Instagram</a>
      </span>
  </div>
  <div class="cc-license site-overview-item animated" itemprop="license">
    <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/deed.zh" class="cc-opacity" rel="noopener" target="_blank"><img src="https://cdn.jsdelivr.net/npm/@creativecommons/vocabulary@2020.11.3/assets/license_badges/small/by_nc_sa.svg" alt="Creative Commons"></a>
  </div>


  <div class="links-of-blogroll site-overview-item animated">
    <div class="links-of-blogroll-title"><i class="far fa-smile-wink fa-fw"></i>
      个人
    </div>
    <ul class="links-of-blogroll-list">
        <li class="links-of-blogroll-item">
          <a href="https://music.163.com/#/user/home?id=68425607" title="https:&#x2F;&#x2F;music.163.com&#x2F;#&#x2F;user&#x2F;home?id&#x3D;68425607" rel="noopener" target="_blank">网易云音乐</a>
        </li>
    </ul>
  </div>

          </div>
        </div>
    </div>
  </aside>
  <div class="sidebar-dimmer"></div>


    </header>

    
  <div class="back-to-top" role="button" aria-label="返回顶部">
    <i class="fa fa-arrow-up"></i>
    <span>0%</span>
  </div>
  <a role="button" class="book-mark-link book-mark-link-fixed"></a>

  <a href="https://github.com/LAILAIWA" class="github-corner" title="Follow me on GitHub" aria-label="Follow me on GitHub" rel="noopener" target="_blank"><svg width="80" height="80" viewBox="0 0 250 250" aria-hidden="true"><path d="M0,0 L115,115 L130,115 L142,142 L250,250 L250,0 Z"></path><path d="M128.3,109.0 C113.8,99.7 119.0,89.6 119.0,89.6 C122.0,82.7 120.5,78.6 120.5,78.6 C119.2,72.0 123.4,76.3 123.4,76.3 C127.3,80.9 125.5,87.3 125.5,87.3 C122.9,97.6 130.6,101.9 134.4,103.2" fill="currentColor" style="transform-origin: 130px 106px;" class="octo-arm"></path><path d="M115.0,115.0 C114.9,115.1 118.7,116.5 119.8,115.4 L133.7,101.6 C136.9,99.2 139.9,98.4 142.2,98.6 C133.8,88.0 127.5,74.4 143.8,58.0 C148.5,53.4 154.0,51.2 159.7,51.0 C160.3,49.4 163.2,43.6 171.4,40.1 C171.4,40.1 176.1,42.5 178.8,56.2 C183.1,58.6 187.2,61.8 190.9,65.4 C194.5,69.0 197.7,73.2 200.1,77.6 C213.8,80.2 216.3,84.9 216.3,84.9 C212.7,93.1 206.9,96.0 205.4,96.6 C205.1,102.4 203.0,107.8 198.3,112.5 C181.9,128.9 168.3,122.5 157.7,114.1 C157.9,116.9 156.7,120.9 152.7,124.9 L141.0,136.5 C139.8,137.7 141.6,141.9 141.8,141.8 Z" fill="currentColor" class="octo-body"></path></svg></a>

<noscript>
  <div class="noscript-warning">Theme NexT works best with JavaScript enabled</div>
</noscript>


    <div class="main-inner post posts-expand">


  


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://linyishui.top/2019100701.html">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="https://pic-1258215793.cos.ap-shanghai.myqcloud.com/cover/IMG_0759.JPG">
      <meta itemprop="name" content="Lys">
      <meta itemprop="description" content="记录编程点滴，写点生活中的酸甜">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="俺的部落格">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          Docker（一）概览
        </h1>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>

      <time title="创建时间：2019-10-07 10:34:47" itemprop="dateCreated datePublished" datetime="2019-10-07T10:34:47+08:00">2019-10-07</time>
    </span>
      <span class="post-meta-item">
        <span class="post-meta-item-icon">
          <i class="far fa-calendar-check"></i>
        </span>
        <span class="post-meta-item-text">更新于</span>
        <time title="修改时间：2021-06-20 22:57:12" itemprop="dateModified" datetime="2021-06-20T22:57:12+08:00">2021-06-20</time>
      </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">分类于</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/%E6%8A%80%E6%9C%AF%E6%96%87%E6%A1%A3/" itemprop="url" rel="index"><span itemprop="name">技术文档</span></a>
        </span>
    </span>

  
      </div>
      <div class="post-meta">
    <span class="post-meta-item" title="本文字数">
      <span class="post-meta-item-icon">
        <i class="far fa-file-word"></i>
      </span>
      <span class="post-meta-item-text">本文字数：</span>
      <span>21k</span>
    </span>
    <span class="post-meta-item" title="阅读时长">
      <span class="post-meta-item-icon">
        <i class="far fa-clock"></i>
      </span>
      <span class="post-meta-item-text">阅读时长 &asymp;</span>
      <span>19 分钟</span>
    </span>
</div>

            <div class="post-description">简单介绍Docker概览（一）容器，内容包括：容器的发展（过去、虚拟机、容器、Linux容器、Docker、Windows容器、Kubernetes），了解Docker，安装Docker，纵观Docker（运维视角、开发视角）等。</div>
        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
        <h1 id="Docker概览（一）概览"><a href="#Docker概览（一）概览" class="headerlink" title="Docker概览（一）概览"></a>Docker概览（一）概览</h1><h2 id="第一节-容器的发展"><a href="#第一节-容器的发展" class="headerlink" title="第一节 容器的发展"></a>第一节 容器的发展</h2><h3 id="1-1-过去"><a href="#1-1-过去" class="headerlink" title="1.1 过去"></a>1.1 过去</h3><p>过去服务器只能运行单一应用，旧时代的Windows和Linux系统都没有相应的技术手段来保证能够在一台服务器上稳定安全的同时运行多个应用。所以每当业务部门需要新增一个应用就要采购一台新的服务器，而对于应用所需服务器性能只能凭经验来推测，所以不得不买性能要大幅优于所需的硬件，最终必然造成大量的浪费。</p>
<h3 id="1-2-虚拟机"><a href="#1-2-虚拟机" class="headerlink" title="1.2 虚拟机"></a>1.2 虚拟机</h3><p>为了解决上述问题，VMware公司开发了<strong>虚拟机</strong>，终于可以有<strong>一种允许多应用能稳定安全运行在同一台服务器的技术</strong>。虚拟机是一项划时代的技术，让现有的资产可以发挥更多的作用。</p>
<p>但虚拟机需要<strong>依赖于其专用的操作系统</strong>，而OS会占用额外的CPU、RAM和存储，这些资源本可以用来运行更多的应用。每个OS都需要补丁和监控，还有一些情况下OS需要许可证才可以运行。还有一些挑战如虚拟机启动会较慢，可移植性很差等等。</p>
<h3 id="1-3-容器"><a href="#1-3-容器" class="headerlink" title="1.3 容器"></a>1.3 容器</h3><p>后来，像谷歌这样的公司开始采用<strong>容器</strong>（Container）技术来解决虚拟机的这些缺点。容器<strong>不会独占OS</strong>，从而节省了大量的系统资源，也省下了花费在许可证和为OS打补丁的运维成本。容器<strong>还有启动快和便于迁移等优势</strong>，从PC迁移到云上或再迁移到数据中心的虚拟机或物理机上都非常简单。</p>
<h3 id="1-4-Linux容器"><a href="#1-4-Linux容器" class="headerlink" title="1.4 Linux容器"></a>1.4 Linux容器</h3><p>现代的容器技术起源于Linux，是很多力量持续贡献的产物，这些年对容器影响较大的技术包括：内核命名空间、控制组、联合文件系统、当然还有Docker。</p>
<h3 id="1-5-Docker"><a href="#1-5-Docker" class="headerlink" title="1.5 Docker"></a>1.5 Docker</h3><p>容器技术的复杂度一直以来是导致其没有被普遍应用的原因，但Docker技术的诞生改变了这一情况。Docker使容器变得简单。</p>
<h3 id="1-6-Windows容器"><a href="#1-6-Windows容器" class="headerlink" title="1.6 Windows容器"></a>1.6 Windows容器</h3><p>近些年微软致力于在Windows平台发展Docker和容器技术，实现容器所需的核心Windows内核技术被统称为Windows容器。用户空间通过Docker来完成与Windows容器的交互，所以同Linux上使用Docker几乎一直。</p>
<p>运行中的容器共享宿主机的内核，这意味着基于Windows的容器化应用在Linux上是无法运行的，但目前Windows版Docker已可以在Windows模式和Linux模式间切换。Docker发展速度日新月异，请及时了解最新技术进展。</p>
<h3 id="1-7-Kubernetes"><a href="#1-7-Kubernetes" class="headerlink" title="1.7 Kubernetes"></a>1.7 Kubernetes</h3><p>Kubernetes是谷歌的一个开源项目，是<strong>容器编排</strong>领域的领头羊。简单理解就是Docker之上的一个平台，采用Docker作为其底层容器操作。</p>
<p>Kubernetes采用Docker作为其默认容器运行时（container runtime），包括Kubernetes启动和停止容器，以及镜像拉取等。Kubernetes提供了一个可插拔的容器运行时接口CRI，帮助Kubernetes实现将运行时环境从Docker快速替换为其他容器运行时，未来Kubernetes会将默认由Docker转为containerd。</p>
<h2 id="第二节-了解Docker"><a href="#第二节-了解Docker" class="headerlink" title="第二节 了解Docker"></a>第二节 了解Docker</h2><h3 id="2-1-简介"><a href="#2-1-简介" class="headerlink" title="2.1 简介"></a>2.1 简介</h3><p>Docker是一种运行于Linux和Windows上的软件，<strong>用于创建、管理和编排容器</strong>。Docker是在GitHub上开发的Moby开源项目的一部分。Docker公司是整个Moby开源项目的维护者，还提供包含支持服务的商业版本的Docker。</p>
<blockquote>
<p><em>“Docker”一词来自英国口语，意为码头工人（Dock Worker），即从船上装卸货物的人</em></p>
</blockquote>
<h3 id="2-2-Docker运行时与编排引擎"><a href="#2-2-Docker运行时与编排引擎" class="headerlink" title="2.2 Docker运行时与编排引擎"></a>2.2 Docker运行时与编排引擎</h3><p>多数技术人员在谈到Docker时，主要是指Docker引擎。<strong>Docker引擎是用于运行和编排容器的基础设施工具</strong>。有VMware管理经验的读者可以将其类比为ESXi（运行虚拟机的核心管理程序），而Docker引擎是运行容器的核心容器运行时。</p>
<p>其他Docker公司或第三方的产品都是围绕Docker引擎进行开发和集成的。如图2.2所示，Docker引擎位于中心，其他产品基于Docker引擎的核心功能进行集成。</p>
<p><img src="https://pic-1258215793.cos.ap-shanghai.myqcloud.com/content/20191001/201910010111.png" alt="围绕Docker引擎进行开发和集成的产品"></p>
<p>Docker引擎可以从Docker网站下载，也可以基于GitHub上的源码进行构建。无论是开源版本还是商业版本，都有Linux和Windows版本。Docker引擎主要有两个版本：企业版（EE）和社区 版（CE）。每个季度，企业版和社区版都会发布一个稳定版本。社区版本会提供4个月的支持，而企业版本会提供12个月的支持。社区版还会通过Edge方式发布月度版。</p>
<h3 id="2-3-Docker开源项目（Moby）"><a href="#2-3-Docker开源项目（Moby）" class="headerlink" title="2.3 Docker开源项目（Moby）"></a>2.3 Docker开源项目（Moby）</h3><p>“Docker”一词也会用于指代开源Docker项目。其中包含一系列可以从Docker官网下载和安装的工具，比如Docker服务端和Docker客户端。不过，该项目在2017年于Austin举办的DockerCon上正式命名为Moby项目。由于这次改名，GitHub上的docker/docker库也被转移到了moby/moby。</p>
<p>Moby项目的目标是基于开源的方式，发展成为Docker上游，并将Docker拆分为更多的模块化组件。Moby项目托管于GitHub的Moby代码库，包括子项目和工具列表。核心的Docker引擎项目位于GitHub的moby/moby，但是引擎中的代码正持续被拆分和模块化。</p>
<p>多数项目及其工具都是基于Golang编写的，这是谷歌推出的一种新的系统级编程语言，又叫Go语言。使用Go语言的读者，将更容易为该项目贡献代码。</p>
<h3 id="2-4-容器生态"><a href="#2-4-容器生态" class="headerlink" title="2.4 容器生态"></a>2.4 容器生态</h3><p>Docker公司的一个核心哲学通常被称为“含电池，但可拆卸”（Batteries included but removable）。意思是许多Docker内置的组件都可以替换为第三方的组件，网络技术栈就是一个很好的例子。Docker核心产品内置有网络解决方案。但是网络技术栈是可插拔的，这意味着Docker内置的网络方案可以被替换为第三方的方案，许多人都会这样使用。</p>
<p>早期的时候，经常出现第三方插件比 Docker 提供的内置组件更好的情况。然而这会对Docker公司的商业模式造成冲击。毕竟，Docker公司需要依靠盈利来维持基业长青。因此，“内置的电池”变得越来越好用了。这也导致了生态内部的紧张关系和竞争的加剧。简单来说，Docker内置的“电池”仍然是可插拔的，然而越来越不需要将它们移除了。</p>
<h3 id="2-5-开放容器计划"><a href="#2-5-开放容器计划" class="headerlink" title="2.5 开放容器计划"></a>2.5 开放容器计划</h3><p>如果不谈及<strong>开放容器计划</strong>（The Open Container Initiative, OCI）的话，对Docker和容器生态的探讨总是不完整的。</p>
<p><strong>OCI是一个旨在对容器基础架构中的基础组件</strong>（如镜像格式与容器运行时）进行标准化的管理委员会。简短的历史介绍是，一个名为CoreOS的公司不喜欢Docker的某些行事方式。因此它就创建了一个新的开源标准，称作“appc”，该标准涉及诸如镜像格式和容器运行时等方面。此外它还开发了一个名为rkt（发音“rocket”）的实现。</p>
<p>两个处于竞争状态的标准将容器生态置于一种尴尬的境地。这使容器生态陷入了分裂的危险中，同时也令用户和消费者陷入两难。虽然竞争是一件好事，但是标准的竞争通常不是。因为它会导致困扰，降低用户接受度，对谁都无益。</p>
<p>考虑到这一点，所有相关方都尽力用成熟的方式处理此事，共同成立了OCI——一个旨在管理容器标准的轻量级的、敏捷型的委员会。当前OCI已经发布了两份规范（标准）：镜像规范和运行时规范。Docker 1.11版本中，Docker引擎架构已经遵循OCI运行时规范了。到目前为止，OCI已经取得了不错的成效，将容器生态团结起来。OCI在Linux基金会的支持下运作，Docker公司和CoreOS公司都是主要贡献者。</p>
<h2 id="第三节-安装Docker"><a href="#第三节-安装Docker" class="headerlink" title="第三节 安装Docker"></a>第三节 安装Docker</h2><p>Docker可以安装在Windows、Mac、Linux之上。除此之外还可以在云上安装，也可以在个人笔记本电脑上安装等等。本节仅整理比较重要的几种安装方式。</p>
<blockquote>
<p>1.桌面安装:</p>
<ul>
<li>Windows版Docker（Docker for Windows）</li>
<li>Mac版Docker（Docker for Mac）</li>
</ul>
<p>2.服务器安装: </p>
<ul>
<li>Linux</li>
<li>Windows Server 2016</li>
</ul>
<p>3.Docker引擎升级</p>
<p>4.Docker存储驱动的选择</p>
</blockquote>
<h3 id="3-1-Windows版Docker（DfW）"><a href="#3-1-Windows版Docker（DfW）" class="headerlink" title="3.1 Windows版Docker（DfW）"></a>3.1 Windows版Docker（DfW）</h3><p>Windows版Docker需要运行在一个安装了64位Windows 10 操作系统的计算机上，通过启动一个独立的引擎来提供Docker环境。</p>
<p>Windows版Docker是一个社区版本（Community Edition，CE）的应用，并不是为生产环境设计的。Windows版Docker在某些版本特性上可能是延后支持的。这是因为Docker公司对该产品的定位是稳定性第一，新特性其次。</p>
<blockquote>
<p>在安装之前，Windows版Docker的环境有以下要求:</p>
<ul>
<li>Windows 10 Pro / Enterprise / Education（1607 Anniversary Update、 Build 14393或者更新的版本）。 </li>
<li>Windows必须是64位的版本。 </li>
<li>需要启用Windows操作系统中的Hyper-V和容器特性。</li>
</ul>
</blockquote>
<h4 id="开启Hyper-V和容器"><a href="#开启Hyper-V和容器" class="headerlink" title="开启Hyper-V和容器"></a>开启Hyper-V和容器</h4><p>接下来的步骤会假设读者的计算机已经开启了BIOS设置中的硬件虚拟化支持。如果没有开启，则需要在机器上执行下面的步骤。</p>
<blockquote>
<p>首先，读者需要确认在Windows 10操作系统中，Hyper-V和容器特性已安装并且开启。</p>
<ol>
<li>右键单击Windows开始按钮并选择“应用和功能”页面。</li>
<li>单击“程序和功能”链接。</li>
<li>单击“启用或关闭Windows功能”。</li>
<li>确认Hyper-V和容器复选框已经被勾选，并单击确定按钮。</li>
</ol>
</blockquote>
<p>按上述步骤操作完成后，会安装并开启Hyper-V和容器特性，需要重启操作系统。之后就可以安装Windows版Docker。</p>
<blockquote>
<ol>
<li>访问Docker的下载页面，并单击其中的Download for Windows按钮。</li>
<li>单击后会跳转到Docker商店，需要读者使用自己的Docker ID进行登录。</li>
<li>单击任意Get Docker下载链接。Docker for Windows分为稳定版（Stable）和抢鲜版（Edge）。抢鲜版当中包含一些新特性，但是可能不够稳定。单击下载链接后，会将名为Docker for Windows Installer.exe的安装包下载到默认下载目录。</li>
<li>找到上一步下载的安装包并运行即可。</li>
</ol>
</blockquote>
<h4 id="家庭版手动伪装专业版"><a href="#家庭版手动伪装专业版" class="headerlink" title="家庭版手动伪装专业版"></a>家庭版手动伪装专业版</h4><p>windows10家庭版无法安装docker，没有Hyper-V等组件，需要下载docker toolbox安装，当然也可以直接将以下代码保存到.cmd文件并用管理员权限执行来安装Hyper-V。</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">pushd &quot;%~dp0&quot;</span><br><span class="line">dir /b %SystemRoot%\servicing\Packages\*Hyper-V*.mum &gt;hyper-v.txt</span><br><span class="line">for /f %%i in (&#x27;findstr /i . hyper-v.txt 2^&gt;nul&#x27;) do dism /online /norestart /add-package:&quot;%SystemRoot%\servicing\Packages\%%i&quot;</span><br><span class="line">del hyper-v.txt</span><br><span class="line">Dism /online /enable-feature /featurename:Microsoft-Hyper-V-All /LimitAccess /ALL</span><br></pre></td></tr></table></figure>



<p>管理员身份执行以下cmd文件，伪装成win10专业版</p>
<figure class="highlight jboss-cli"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">REG ADD <span class="string">&quot;HKEY_LOCAL_MACHINE\software\Microsoft\Windows NT\CurrentVersion&quot;</span> <span class="string">/v</span> EditionId <span class="string">/T</span> REG_EXPAND_SZ <span class="string">/d</span> </span><br><span class="line">Professional <span class="string">/F</span></span><br></pre></td></tr></table></figure>



<p>但执行失败，所以还是用toolbox来安装了。</p>
<blockquote>
<p><a target="_blank" rel="noopener" href="http://mirrors.aliyun.com/docker-toolbox/windows/docker-toolbox/">http://mirrors.aliyun.com/docker-toolbox/windows/docker-toolbox/</a></p>
</blockquote>
<h4 id="正式安装"><a href="#正式安装" class="headerlink" title="正式安装"></a>正式安装</h4><p>以管理员身份运行安装向导，并按照提示一步一步完成整个安装过程。安装完成后Docker会作为系统服务自动启动，并且在Windows的通知栏看到Docker的大鲸鱼图标。</p>
<p>打开命令行或者PowerShell界面，并尝试执行下面的命令：</p>
<figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">Client:</span> </span><br><span class="line"> <span class="attr">Version:</span>       <span class="number">18.01</span><span class="number">.0</span><span class="string">-ce</span> </span><br><span class="line"> <span class="attr">API version:</span>   <span class="number">1.35</span> </span><br><span class="line"> <span class="attr">Go version:</span>    <span class="string">go1.9.2</span> </span><br><span class="line"> <span class="attr">Git commit:</span>    <span class="string">03596f5</span> </span><br><span class="line"> <span class="attr">Built:</span> <span class="string">Wed</span> <span class="string">Jan</span> <span class="number">10</span> <span class="number">20</span><span class="string">:05:55</span> <span class="number">2018</span> </span><br><span class="line"> <span class="attr">OS/Arch:</span>       <span class="string">windows/amd64</span> </span><br><span class="line"> <span class="attr">Experimental:</span>  <span class="literal">false</span> </span><br><span class="line"> <span class="attr">Orchestrator:</span>  <span class="string">swarm</span></span><br><span class="line"><span class="attr">Server:</span> </span><br><span class="line"> <span class="attr">Engine:</span>  </span><br><span class="line">  <span class="attr">Version:</span>      <span class="number">18.01</span><span class="number">.0</span><span class="string">-ce</span>  </span><br><span class="line">  <span class="attr">API version:</span>  <span class="number">1.35</span> <span class="string">(minimum</span> <span class="string">version</span> <span class="number">1.12</span><span class="string">)</span>  </span><br><span class="line">  <span class="attr">Go version:</span>   <span class="string">go1.9.2</span>  </span><br><span class="line">  <span class="attr">Git commit:</span>   <span class="string">03596f5</span>  </span><br><span class="line">  <span class="attr">Built:</span>        <span class="string">Wed</span> <span class="string">Jan</span> <span class="number">10</span> <span class="number">20</span><span class="string">:13:12</span> <span class="number">2018</span>  </span><br><span class="line">  <span class="attr">OS/Arch:</span>      <span class="string">linux/amd64</span>  </span><br><span class="line">  <span class="attr">Experimental:</span> <span class="literal">false</span></span><br></pre></td></tr></table></figure>



<p>注意观察命令输出内容，其中Server部分中的OS/Arch属性展示了当前的操作系统是linux/amd64。这是因为在默认安装方式中，Docker daemon是运行在Hyper-V虚拟机中的一个轻量级Linux上的。这种情况下只能在Windows版Docker上运行Linux容器。</p>
<p>如果想要运行原生Windows容器（Native Windows Container），可以右击Windows通知栏中的Docker鲸鱼图标，并选择“切换到Windows容器”。使用下面的命令也可以完成切换（进入\Program Files\Docker\Docker目录下执行）。</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">C:\Program Files\Docker\Docker&gt; .\dockercli -SwitchDaemon</span><br></pre></td></tr></table></figure>



<p>如果已经开启了Windows容器特性，则只需要花费数秒就能完成切换。一旦切换完成，在命令行中执行docker version指令的输出内容如下。</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">C:\&gt; docker version </span><br><span class="line">Client: </span><br><span class="line"> &lt;Snip&gt;</span><br><span class="line">Server: </span><br><span class="line"> Engine:  </span><br><span class="line">  Version:      18.01.0-ce  </span><br><span class="line">  API version:  1.35 (minimum version 1.24)  </span><br><span class="line">  Go version:   go1.9.2</span><br><span class="line">  Git commit:   03596f5  </span><br><span class="line">  Built:        Wed Jan 10 20:20:36 2018  </span><br><span class="line">  OS/Arch:      windows/amd64  </span><br><span class="line">  Experimental: true</span><br></pre></td></tr></table></figure>



<p>可以看到，现在Server版本信息变成了windows/amd64，这意味着Docker daemon运行在原生Windows内核上，并且只能运行Windows容器了。同时也可以发现，Experimental这个属性的值为true。这表示当前运行的Docker版本是实验版本。可以通过运行dockercli -Version命令来查看当前的Docker版本。dockercli命令在C:\Program Files\Docker\Docker目录下。</p>
<p>Windows版Docker包括Docker引擎（客户端和daemon）、Docker Compose、Docker Machine以及Docker Notary命令行。通过下列命令确认各个模块已经成功安装。</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">C:\&gt; docker --version </span><br><span class="line">Docker version 18.01.0-ce, build 03596f5</span><br><span class="line"></span><br><span class="line">C:\&gt; docker-compose --version </span><br><span class="line">docker-compose version 1.18.0, build 8dd22a96</span><br><span class="line"></span><br><span class="line">C:\&gt; docker-machine --version </span><br><span class="line">docker-machine.exe version 0.13.0, build 9ba6da9</span><br><span class="line"></span><br><span class="line">C:\&gt; notary version </span><br><span class="line">notary </span><br><span class="line"> Version:    0.4.3 </span><br><span class="line"> Git commit: 9211198</span><br></pre></td></tr></table></figure>



<h3 id="3-2-Mac版Docker（DfM）"><a href="#3-2-Mac版Docker（DfM）" class="headerlink" title="3.2　Mac版Docker（DfM）"></a>3.2　Mac版Docker（DfM）</h3><p>Mac版Docker并不是为生产环境而设计的，Mac版Docker就是一个流畅、简单并且稳定版的boot2docker。对于Mac版Docker来说，提供基于Mac原生操作系统中Darwin内核的Docker引擎没有什么意义。所以在Mac版Docker当中，Docker daemon是运行在一个轻量级的Linux VM之上的。Mac版Docker通过对外提供daemon和API的方式与Mac环境实现无缝集成，这意味着我们可以在Mac上打开终端并直接使用Docker命令。</p>
<p>尽管在Mac上实现了无缝集成，还是要谨记Mac版Docker底层是基于Linux VM运行的，所以说Mac版Docker只能运行基于Linux的Docker容器。不过这样已经很好了，因为大部分容器实际上都是基于Linux的。</p>
<p>安装过程暂略，个人还未有Mac产品。</p>
<h3 id="3-3-在Linux上安装Docker"><a href="#3-3-在Linux上安装Docker" class="headerlink" title="3.3　在Linux上安装Docker"></a>3.3　在Linux上安装Docker</h3><p>在Linux上安装Docker是常见的安装场景，并且安装过程非常简单。通常难点在于Linux不同发行版之间的轻微区别，比如Ubuntu和CentOS之间的差异。接下来的示例基于Ubuntu版本Linux，同样适用于更低或者更高的版本。理论上，下面的示例在CentOS的各种版本上也是可以执行的。至于Linux操作系统是安装在自己的数据中心，还是第三方公有云，或是笔记本的虚拟机上，都没有任何的区别。唯一需求就是这台机器是Linux操作系统，并且能够访问 <a target="_blank" rel="noopener" href="https://get.docker.com./">https://get.docker.com。</a></p>
<p>首先需要选择安装的Docker版本。当前有两个版本可供选择： 社区版（Community Edition，CE）和企业版（Enterprise Edition，EE）。</p>
<p>下面使用wget命令来运行一个Shell脚本，完成Docker CE的安装。更多其他在Linux上安装Docker的方式，可以打开Docker主页面，单击页面中Get Started按钮来获取。</p>
<p>（1）在Linux机器上打开一个新的Shell</p>
<p>（2）使用wget从<a target="_blank" rel="noopener" href="https://get.docker.com获取并运行docker安装脚本,然后采用shell中管道(pipe)的方式来执行这个脚本./">https://get.docker.com获取并运行Docker安装脚本，然后采用Shell中管道（pipe）的方式来执行这个脚本。</a></p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> wget -qO- https://get.docker.com/ | sh</span></span><br><span class="line"></span><br><span class="line">modprobe: FATAL: Module aufs not found /lib/modules/4.4.0-36-generic + sh -c &#x27;sleep 3; yum -y -q install docker-engine&#x27; </span><br><span class="line">&lt;Snip&gt; </span><br><span class="line">If you would like to use Docker as a non-root user, you should now consider adding your user to the &quot;docker&quot; group with something like:</span><br><span class="line"></span><br><span class="line">sudo usermod -aG docker your-user</span><br><span class="line"></span><br><span class="line">Remember that you will have to log out and back in...</span><br></pre></td></tr></table></figure>



<p>（3）最好通过非root用户来使用Docker。这时需要添加非root用户到本地Docker Unix组当中。下面的命令展示了如何把名为npoulton的用户添加到Docker组中，以及如何确认操作是否执行成功。请自行使用系统中的有效用户。</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> sudo usermod -aG docker npoulton</span></span><br><span class="line"><span class="meta"></span></span><br><span class="line"><span class="meta">$</span><span class="bash"> cat /etc/group | grep docker</span> </span><br><span class="line">docker:x:999:npoulton</span><br></pre></td></tr></table></figure>



<p>如果当前登录用户就是要添加到Docker组中的用户的话，则需要重新登录，组权限设置才会生效。这样Docker已经在Linux机器上安装成功。运行下面命令来确认安装结果。</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> docker --version</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> docker system info</span> </span><br><span class="line"></span><br><span class="line">--有问题可以尝试重启docker</span><br><span class="line">service docker restart  </span><br></pre></td></tr></table></figure>



<h3 id="3-4-在Windows-Server-2016上安装Docker"><a href="#3-4-在Windows-Server-2016上安装Docker" class="headerlink" title="3.4 在Windows Server 2016上安装Docker"></a>3.4 在Windows Server 2016上安装Docker</h3><p>暂略</p>
<h3 id="3-5-Docker引擎（Engine）升级"><a href="#3-5-Docker引擎（Engine）升级" class="headerlink" title="3.5 Docker引擎（Engine）升级"></a>3.5 Docker引擎（Engine）升级</h3><p>升级Docker引擎（Engine）是一项重要的任务，尤其是生产环境。 </p>
<p>需要重视升级操作的每个前置条件，包括确保容器配置了正确的重启策略；在Swarm Mode模式下使用服务时，需要确保正确配置了draining node。当完成了上述前置条件的检查之后，可以通过如下步骤完成升级操作。</p>
<blockquote>
<ol>
<li>停止Docker守护程序。</li>
<li>移除旧版本Docker。</li>
<li>安装新版本Docker。</li>
<li>配置新版本的Docker为开机自启动。</li>
<li>确保容器重启成功。</li>
</ol>
</blockquote>
<p>不同版本的Linux在升级Docker的时候，命令可能略有区别。</p>
<h4 id="在Ubuntu-16-04上升级Docker-CE"><a href="#在Ubuntu-16-04上升级Docker-CE" class="headerlink" title="在Ubuntu 16.04上升级Docker CE"></a>在Ubuntu 16.04上升级Docker CE</h4><p>假设已经完成了全部的升级前置步骤并且Docker处于可以 升级的状态，同时还可以用root用户身份运行升级命令。以root用户运行升级命令是不推荐的，但是可以简化示例。需要通过sudo来执行下列指令。</p>
<p>（1）更新APT包列表。</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> apt-get update</span></span><br></pre></td></tr></table></figure>



<p>（2）卸载当前Docker。</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> apt-get remove docker docker-engine docker-ce docker.io -y</span></span><br></pre></td></tr></table></figure>

<p>在之前的版本中，Docker引擎的包名可能有多个。这条命令能够确保已经安装的Docker包全部被删除。</p>
<p>（3）安装新版本Docker。</p>
<p>有不同版本的Docker可供选择，并且有多种方式可以安装Docker。 无论是Docker CE还是Docker EE，都有不止一种安装方式。例如， Docker CE可以通过apt或者deb包管理方式进行安装，也可以使用Docker 官网上的脚本。</p>
<p>接下来的命令会使用get.docker.com的脚本完成最新版本Docker CE 的安装和配置。</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> wget -qO- https://get.docker.com/ | sh</span></span><br></pre></td></tr></table></figure>



<p>（4）将Docker配置为开机自启动。</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> systemctl <span class="built_in">enable</span> docker</span></span><br><span class="line">Synchronizing state of docker.service... </span><br><span class="line">Executing /lib/systemd/systemd-sysv-install enable docker</span><br><span class="line"><span class="meta">$</span><span class="bash"> systemctl is-enabled docker</span> </span><br><span class="line">enabled</span><br></pre></td></tr></table></figure>

<p>此时可能想重启自己的节点。这样可以确保刚安装的Docker不会对系统开机有任何的影响。</p>
<p>（5）检查并确保每一个容器和服务都已经重启成功。</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> docker container ls</span> </span><br><span class="line">CONTAINER ID    IMAGE     COMMAND       CREATED           STATUS</span><br><span class="line"></span><br><span class="line">97e599aca9f5    alpine    &quot;sleep 1d&quot;    14 minutes ago    Up 1 minute</span><br><span class="line"><span class="meta"></span></span><br><span class="line"><span class="meta">$</span><span class="bash"> docker service ls</span> </span><br><span class="line">ID              NAME          MODE         REPLICAS     IMAGE </span><br><span class="line">ibyotlt1ehjy    prod-equus1   replicated   1/1          alpine:latest</span><br></pre></td></tr></table></figure>

<p>请注意，更新Docker还有其他的方法，此处只是介绍了基于Ubuntu Linux 16.04 版本的方式。</p>
<h4 id="在Windows-Server-2016上升级Docker-EE"><a href="#在Windows-Server-2016上升级Docker-EE" class="headerlink" title="在Windows Server 2016上升级Docker EE"></a>在Windows Server 2016上升级Docker EE</h4><p>暂略</p>
<h3 id="3-6-Docker存储驱动的选择"><a href="#3-6-Docker存储驱动的选择" class="headerlink" title="3.6 Docker存储驱动的选择"></a>3.6 Docker存储驱动的选择</h3><p>每个Docker容器都有一个<strong>本地存储空间</strong>，用于保存层叠的<strong>镜像层</strong>（Image Layer）以及挂载的容器<strong>文件系统</strong>。默认情况下，容器的所有读写操作都发生在其镜像层上或挂载的文件系统中，所以存储是每个容器的性能和稳定性不可或缺的一个环节。</p>
<p>以往，本地存储是通过<strong>存储驱动</strong>（Storage Driver）进行管理的，有时候也被称为Graph Driver或者GraphDriver。虽然存储驱动在上层抽象设计中都采用了<strong>栈式镜像层存储</strong>和<strong>写时复制</strong>（Copy-on-Write）的设计思想，但是Docker在Linux底层支持几种不同的存储驱动的具体实现，每一种实现方式都采用不同方法实现了镜像层和写时复制。虽然底层实现的差异不影响用户与Docker之间的交互，但是对Docker的性能和稳定性至关重要。</p>
<p>在Linux上，Docker可选择的一些存储驱动包括AUFS（最原始也是 最老的）、Overlay2（可能是未来的最佳选择）、Device Mapper、Btrfs 和ZFS。</p>
<p>Docker在Windows操作系统上只支持一种存储驱动，即Windows Filter。</p>
<p>存储驱动的选择是节点级别的。这意味着每个Docker主机只能选择一种存储驱动，而不能为每个容器选择不同的存储驱动。在Linux上，读者可以通过修改/etc/docker/daemon.json文件来修改存储引擎配置，修改完成之后需要重启Docker才能够生效。下面的代码片段展示了如何将存储驱动设置为overlay2。</p>
<figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&#123;  <span class="attr">&quot;storage-driver&quot;</span>: <span class="string">&quot;overlay2&quot;</span> &#125;</span><br></pre></td></tr></table></figure>



<p>如果修改了正在运行Docker主机的存储引擎类型，则现有的镜像和容器在重启之后将不可用，这是因为每种存储驱动在主机上存储镜像层的位置是不同的（通常在/var/lib/docker / &lt; storagedriver&gt;/…目录下）。修改了存储驱动的类型，Docker就无法找到原有的镜像和容器了。切换到原来的存储驱动，之前的镜像和容器就可以继续使用了。</p>
<p>如果希望在切换存储引擎之后还能够继续使用之前的镜像和容器，需要将镜像保存为Docker格式，上传到某个镜像仓库，修改本地 Docker存储引擎并重启，之后从镜像仓库将镜像拉取到本地，最后重启容器。</p>
<p>通过下面的命令来检查Docker当前的存储驱动类型。</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> docker system info</span> </span><br><span class="line">&lt;Snip&gt; </span><br><span class="line">Storage Driver: overlay2  </span><br><span class="line">  Backing Filesystem: xfs  </span><br><span class="line">  Supports d_type: true  </span><br><span class="line">  Native Overlay Diff: true </span><br><span class="line">&lt;Snip&gt;</span><br></pre></td></tr></table></figure>



<p>选择存储驱动并正确地配置在Docker环境中是一件重要的事情，特别是在生产环境中，建议参阅Docker官网上由Linux发行商提供的最新文档来做出选择。</p>
<h4 id="3-6-1-Device-Mapper配置"><a href="#3-6-1-Device-Mapper配置" class="headerlink" title="3.6.1 Device Mapper配置"></a>3.6.1 Device Mapper配置</h4><p>大部分Linux存储驱动不需要或需要很少的配置。但是，Device Mapper通常需要合理配置之后才能表现出良好的性能。</p>
<p>默认情况下，Device Mapper采用loopback mounted sparse file作为底层实现来为Docker提供存储支持。如果需要的是开箱即用并且对性能没什么要求，那么这种方式是可行的。但这并不适用于生产环境。实际上，默认方式的性能很差，并不支持生产环境。</p>
<p>为了达到Device Mapper在生产环境中的最佳性能，读者需要将底层实现修改为direct-lvm模式。这种模式下通过使用基于裸块设备（Raw Block Device）的LVM精简池（LVM thin pool）来获取更好的性<br>能。</p>
<p>在Docker 17.06以及更高的版本中可以配置direct-lvm作为存储驱动，但到当前该方式存在某种限制。其中最主要的一点是，这种方式只能配置一个块设备，并且只有在第一次安装后才能设置生效。未来可能会有改进，但就目前情况来看配置单一块设备这种方式在性能和可靠性上都有一定的风险。</p>
<h4 id="3-6-2-让Docker自动设置direct-lvm"><a href="#3-6-2-让Docker自动设置direct-lvm" class="headerlink" title="3.6.2 让Docker自动设置direct-lvm"></a>3.6.2 让Docker自动设置direct-lvm</h4><p>下面的步骤会将Docker配置存储驱动为Device Mapper，并使用direct-lvm模式。</p>
<p>（1）将下面的存储驱动配置添加到/etc/docker/daemon.json当中。</p>
<figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">&#123; </span><br><span class="line">  <span class="attr">&quot;storage-driver&quot;</span>: <span class="string">&quot;devicemapper&quot;</span>, </span><br><span class="line">  <span class="attr">&quot;storage-opts&quot;</span>: [  </span><br><span class="line">    <span class="string">&quot;dm.directlvm_device=/dev/xdf&quot;</span>,  </span><br><span class="line">    <span class="string">&quot;dm.thinp_percent=95&quot;</span>,  </span><br><span class="line">    <span class="string">&quot;dm.thinp_metapercent=1&quot;</span>,  <span class="string">&quot;dm.thinp_autoextend_threshold=80&quot;</span>,  <span class="string">&quot;dm.thinp_autoextend_percent=20&quot;</span>,  <span class="string">&quot;dm.directlvm_device_force=false&quot;</span> </span><br><span class="line">  ] </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p>Device Mapper和LVM是很复杂的知识点，并不在讨论范围之内。下面简单介绍一下各配置项的含义。</p>
<blockquote>
<ul>
<li>dm.directlvm_device：设置了块设备的位置。为了存储的最佳<br>性能以及可用性，块设备应当位于高性能存储设备（如本地SSD） 或者外部RAID存储阵列之上。 </li>
<li>dm.thinp_percent=95：设置了镜像和容器允许使用的最大存储 空间占比，默认是95%。 </li>
<li>dm.thinp_metapercent：设置了元数据存储（MetaData Storage）允许使用的存储空间大小。默认是1%。 </li>
<li>dm.thinp_autoextend_threshold：设置了LVM自动扩展精简池 的阈值，默认是80%。 </li>
<li>dm.thinp_autoextend_percent：表示当触发精简池（thin pool）自动扩容机制的时候，扩容的大小应当占现有空间的比例。 </li>
<li>dm.directlvm_device_force：允许用户决定是否将块设备格式 化为新的文件系统。</li>
</ul>
</blockquote>
<p>（2）重启Docker。</p>
<p>（3）确认Docker已成功运行，并且块设备配置已被成功加载。</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> docker version</span> </span><br><span class="line"><span class="meta">$</span><span class="bash"> docker system info</span> </span><br></pre></td></tr></table></figure>

<p>即使Docker在direct-lvm模式下只能设置单一块设备，其性能也会显著优于loopback模式。</p>
<h4 id="3-6-3-手动配置Device-Mapper的direct-lvm"><a href="#3-6-3-手动配置Device-Mapper的direct-lvm" class="headerlink" title="3.6.3 手动配置Device Mapper的direct-lvm"></a>3.6.3 手动配置Device Mapper的direct-lvm</h4><p>完整介绍如何进行Device Mapper direct-lvm的手动配置有些超出范畴。但是，下面列出的内容是我们需要了解并在配置的时候仔细斟酌的。</p>
<blockquote>
<ul>
<li><strong>块设备</strong>（Block Device）：在使用direct-lvm模式的时候，读者需要有可用的块设备。这些块设备应该位于高性能的存储设备之上，比如本地SSD或者外部高性能LUN存储。如果Docker环境部署在企业私有云（On-Premise）之上，那么外部LUN存储可以使用FC、iSCSI，或者其他支持块设备协议的存储阵列。如果Docker环境部署在公有云之上，那么可以采用公有云厂商提供的任何高性能的块设备（通常基于SSD）。 </li>
<li><strong>LVM</strong>配置：Docker的Device Mapper存储驱动底层利用LVM（Logical Volume Manager）来实现，因此需要配置LVM所需的物理设备、卷组、逻辑卷和精简池。读者应当使用专用的物理卷并将其配置在相同的卷组当中。这个卷组不应当被Docker之外的工作负载所使用。此外还需要配置额外两个逻辑卷，分别用于存储数据和源数据信息。另外，要创建LVM配置文件、指定LVM自动扩容的触发阈值，以及自动扩容的大小，并且为自动扩容配置相应的监控，保证自动扩容会被触发。 </li>
<li>Docker配置：修改Docker配置文件之前要先保存原始文件（etc/docker/daemon.json），然后再进行修改。读者环境中的dm.thinpooldev配置项对应值可能跟下面的示例内容有所不同，需要修改为合适的配置。</li>
</ul>
</blockquote>
<figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&#123;  </span><br><span class="line">  <span class="attr">&quot;storage-driver&quot;</span>: <span class="string">&quot;devicemapper&quot;</span>,  </span><br><span class="line">  <span class="attr">&quot;storage-opts&quot;</span>: [</span><br><span class="line">    <span class="string">&quot;dm.thinpooldev=/dev/mapper/docker-thinpool&quot;</span>,  <span class="string">&quot;dm.use_deferred_removal=true&quot;</span>,  <span class="string">&quot;dm.use_deferred_deletion=true&quot;</span>  </span><br><span class="line">  ] </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p>修改并保存配置后，可以重启Docker daemon。如果想获取更多细节信息，可以参考Docker文档，或者咨询Docker 技术账户管理员。</p>
<h2 id="第四节-纵观Docker"><a href="#第四节-纵观Docker" class="headerlink" title="第四节 纵观Docker"></a>第四节 纵观Docker</h2><p>在继续深入研究Docker之前，需要先对Docker进行一个整体介绍。主要包含两部分内容：运维（Ops）视角。 开发（Dev）视角。</p>
<h3 id="4-1-运维视角"><a href="#4-1-运维视角" class="headerlink" title="4.1 运维视角"></a>4.1 运维视角</h3><p>在安装Docker的时候，会涉及两个主要组件：Docker客户端和 Docker daemon（有时也被称为“服务端”或者“引擎”）。daemon实现了Docker引擎的API。</p>
<p>使用Linux默认安装时，客户端与daemon之间的通信是通过本地IPC/UNIX Socket完成的（/var/run/docker.sock）；在Windows上是通过名为npipe:////./pipe/docker_engine的管道（pipe）完成的。可以使用docker version命令来检测客户端和服务端是否都已经成功运行，并且可以互相通信。</p>
<p>如果能成功获取来自客户端和服务端的响应，那么可以继续后面的操作。如果正在使用Linux，并且服务端返回了异常响应，则可尝试在命令的前面加上sudo——sudo docker version。如果加上sudo之后命令正常运行，那么需要将当前用户加入到docker用户组，或者给后面的命令都加上sudo前缀。</p>
<h4 id="4-1-1-镜像"><a href="#4-1-1-镜像" class="headerlink" title="4.1.1 镜像"></a>4.1.1 镜像</h4><p>将<strong>Docker镜像</strong>理解为一个包含了OS文件系统和应用的对象会很有帮助，与<strong>虚拟机模板</strong>类似。虚拟机模板本质上是处于关机状态的虚拟机。在Docker世界中，镜像实际上等价于未运行的容器，可以将镜像比作类（Class）。</p>
<p>在Docker主机上运行docker image ls命令。</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> docker image ls</span> </span><br><span class="line">REPOSITORY    TAG     IMAGE ID     CREATED     SIZE</span><br></pre></td></tr></table></figure>



<p>如果运行命令环境是刚完成Docker安装的主机，或者是Play With Docker，那么Docker主机中应当没有任何镜像，命令输出内容会如上所示。</p>
<p>在Docker主机上获取镜像的操作被称为<strong>拉取</strong>（pulling）。如果使用Linux，那么会拉取ubuntu:latest镜像；如果使用Windows，则会拉取microsoft/powershell:nanoserver镜像（本人环境是centos，所以直接docker pull centos）。</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">latest: Pulling from library/ubuntu </span><br><span class="line">50aff78429b1: Pull complete </span><br><span class="line">f6d82e297bce: Pull complete </span><br><span class="line">275abb2c8a6f: Pull complete</span><br><span class="line">9f15a39356d6: Pull complete </span><br><span class="line">fc0342a94c89: Pull complete </span><br><span class="line">Digest: sha256:fbaf303...c0ea5d1212 </span><br><span class="line">Status: Downloaded newer image for ubuntu:latest</span><br></pre></td></tr></table></figure>



<p>再次运行docker image ls命令来查看刚刚拉取的镜像。</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> docker images</span> </span><br><span class="line">REPOSITORY       TAG      IMAGE ID       CREATED       SIZE </span><br><span class="line">ubuntu           latest   00fd29ccc6f1   3 weeks ago   111MB</span><br><span class="line">centos           latest   0f3e07c0138f   2 months ago  220MB             </span><br></pre></td></tr></table></figure>



<p>关于镜像的存储位置以及镜像内部构成，会在后续进行整理。现在只需知道镜像包含了基础操作系统，以及应用程序运行所需的代码和依赖包。刚才拉取的ubuntu镜像有一个精简版的Ubuntu Linux文件系统，其中包含部分Ubuntu常用工具。而Windows示例中拉取的microsoft/powershell镜像，则包含了带有PowerShell的 Windows Nano Server操作系统。如果拉取了如nginx或者microsoft/iis这样的应用容器，则会得到一个包含操作系统的镜像，并且在镜像中还包括了运行Nginx或IIS所需的代码。</p>
<p>重要的是，Docker的每个镜像都有自己的唯一ID。用户可以通过引用镜像的ID或名称来使用镜像。如果用户选择使用镜像ID，通常只需要输入ID开头的几个字符即可——因为ID是唯一的，Docker知道用户想引用的具体镜像是哪个。</p>
<h4 id="4-1-2-容器"><a href="#4-1-2-容器" class="headerlink" title="4.1.2 容器"></a>4.1.2 容器</h4><p>到目前为止，我们已经拥有一个拉取到本地的镜像，可以使用docker container run命令从镜像来启动容器。</p>
<p>在Linux中启动容器的命令如下。</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> docker container run -it ubuntu:latest /bin/bash</span> </span><br><span class="line"><span class="meta">$</span><span class="bash"> docker container run -it centos:latest /bin/bash</span> </span><br><span class="line">root@6dc20d508db0:/#</span><br></pre></td></tr></table></figure>



<p>在Windows中启动容器的命令如下。</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;</span><span class="bash"> docker container run -it microsoft/powershell:nanoserver pwsh.exe</span></span><br><span class="line"></span><br><span class="line">Windows PowerShell </span><br><span class="line">Copyright (C) 2016 Microsoft Corporation. All rights reserved. </span><br><span class="line">PS C:\&gt;</span><br></pre></td></tr></table></figure>



<p>每个实例中的提示符都发生了变化，是因为-it参数会将Shell切换到容器终端，现在已经位于容器内部了。</p>
<p>接下来分析一下docker container run命令：docker container run告诉Docker daemon启动新的容器。其中-it参数告诉Docker开启容器的交互模式并将当前的Shell连接到<strong>容器终端</strong>。接下来，命令告诉Docker，用户想基于ubuntu:latest镜像启动容器（如果用户使用Windows，则是基于 microsoft/powershell:nanoserver镜像）。最后，命令告诉Docker，用户想要在容器内部运行哪个进程。对于Linux示例来说是运行Bash Shell，对于Windows示例来说则是运行PowerShell。</p>
<p>在容器内部运行ps命令查看当前正在运行的全部进程。</p>
<p>Linux示例如下。</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">root@6dc20d508db0:/# ps -elf </span><br><span class="line">F S UID    PID  PPID   NI ADDR SZ WCHAN  STIME TTY  TIME CMD </span><br><span class="line">4 S root     1     0    0 -  4560 wait   13:38 ?    00:00:00 /bin/bash </span><br><span class="line">0 R root     9     1    0 -  8606 -      13:38 ?    00:00:00 ps -elf</span><br></pre></td></tr></table></figure>



<p>Windows示例如下。</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">PS C:\&gt; ps</span><br><span class="line"></span><br><span class="line">Handles   NPM(K)   PM(K)   WS(K)   CPU(s)     Id   SI ProcessName </span><br><span class="line">-------   ------   -----   -----   ------     --   -- ----------      </span><br><span class="line">      0        5     964    1292     0.00   4716    4 CExecSvc      </span><br><span class="line">      0        5     592     956     0.00   4524    4 csrss      </span><br><span class="line">      0        0       0       4               0    0 Idle      </span><br><span class="line">      0       18    3984    8624     0.13    700    4 lsass      </span><br><span class="line">      0       52   26624   19400     1.64   2100    4 powershell      </span><br><span class="line">      0       38   28324   49616     1.69   4464    4 powershell      </span><br><span class="line">      0        8    1488    3032     0.06   2488    4 services      </span><br><span class="line">      0        2     288     504     0.00   4508    0 smss      </span><br><span class="line">      0        8    1600    3004     0.03    908    4 svchost      </span><br><span class="line">      0       12    1492    3504     0.06   4572    4 svchost      </span><br><span class="line">      0       15   20284   23428     5.64   4628    4 svchost      </span><br><span class="line">      0       15    3704    7536     0.09   4688    4 svchost      </span><br><span class="line">      0       28    5708    6588     0.45   4712    4 svchost      </span><br><span class="line">      0       10    2028    4736     0.03   4840    4 svchost      </span><br><span class="line">      0       11    5364    4824     0.08   4928    4 svchost      </span><br><span class="line">      0        0     128     136    37.02      4    0 System      </span><br><span class="line">      0        7     920    1832     0.02   3752    4 wininit      </span><br><span class="line">      0        8    5472   11124     0.77   5568    4 WmiPrvSE</span><br></pre></td></tr></table></figure>



<p>Linux容器中仅包含两个进程。</p>
<blockquote>
<ul>
<li>PID 1：代表/bin/bash进程，该进程是通过docker container run命令来通知容器运行的。 </li>
<li>PID 9：代表ps -elf进程，查看当前运行中进程所使用的命令/程序。</li>
</ul>
</blockquote>
<p>命令输出中展示的ps -elf进程存在一定的误导，因为这个程序在ps命令退出后就结束了。这意味着容器内长期运行的进程其实只有/bin/bash。</p>
<p>Windows容器运行中的进程会更多，这是由 Windows 操作系统工作方式决定的。虽然Windows容器中的进程比Linux容器要多，但与常见的Windows服务器相比，其进程数量却是明显偏少的。</p>
<p>按Ctrl-PQ组合键，可以在退出容器的同时还保持容器运行。这样Shell就会返回到Docker主机终端。可以通过查看Shell提示符来确认。</p>
<p>现在已经返回到Docker主机的Shell提示符，再次运行ps命令。</p>
<p>Linux示例如下。</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> ps -elf</span> </span><br><span class="line">F S UID       PID  PPID    NI ADDR SZ WCHAN  TIME CMD </span><br><span class="line">4 S root        1     0     0 -  9407 -      00:00:03 /sbin/init </span><br><span class="line">1 S root        2     0     0 -     0 -      00:00:00 [kthreadd] </span><br><span class="line">1 S root        3     2     0 -     0 -      00:00:00 [ksoftirqd/0] </span><br><span class="line">1 S root        5     2     -20     0 -      00:00:00 [kworker/0:0H] </span><br><span class="line">1 S root        7     2    -0 -     0 -      00:00:00 [rcu_sched] </span><br><span class="line">&lt;Snip&gt; </span><br><span class="line">0 R ubuntu  22783 22475     0 -  9021 -      00:00:00 ps -elf</span><br></pre></td></tr></table></figure>



<p>Windows示例如下。</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;</span><span class="bash"> ps</span> </span><br><span class="line">Handles   NPM(K)    PM(K)    WS(K)    CPU(s)     Id  SI ProcessName </span><br><span class="line">-------   ------    -----    -----    ------     --  -- ----------    </span><br><span class="line">    220       11     7396     7872      0.33   1732   0 amazon-ssm-agen     </span><br><span class="line">     84        5      908     2096      0.00   2428   3 CExecSvc     </span><br><span class="line">     87        5      936     1336      0.00   4716   4 CExecSvc    </span><br><span class="line">    203       13     3600    13132      2.53   3192   2 conhost</span><br><span class="line">    210       13     3768    22948      0.08   5260   2 conhost    </span><br><span class="line">    257       11     1808      992      0.64    524   0 csrss    </span><br><span class="line">    116        8     1348       580     0.08    592   1 csrss     </span><br><span class="line">     85        5      532      1136     0.23   2440   3 csrss    </span><br><span class="line">    242       11     1848       952     0.42   2708   2 csrss     </span><br><span class="line">     95        5      592       980     0.00   4524   4 csrss    </span><br><span class="line">    137        9     7784      6776     0.05   5080   2 docker    </span><br><span class="line">    401       17    22744     14016    28.59   1748   0 dockerd    </span><br><span class="line">    307       18    13344      1628     0.17    936   1 dwm    </span><br><span class="line">    &lt;SNIP&gt;   </span><br><span class="line">   1888        0      128       136    37.17      4   0 System    </span><br><span class="line">    272       15     3372      2452     0.23   3340   2 TabTip     </span><br><span class="line">     72        7     1184         8     0.00   3400   2 TabTip32    </span><br><span class="line">    244       16     2676      3148     0.06   1880   2 taskhostw    </span><br><span class="line">    142        7     6172      6680     0.78   4952   3 WmiPrvSE    </span><br><span class="line">    148        8     5620     11028     0.77   5568   4 WmiPrvSE</span><br></pre></td></tr></table></figure>



<p>可以看到与容器相比，Docker主机中运行的进程数要多很多。 Windows容器中运行的进程要远少于Windows主机，Linux容器中的进程数也远少于Linux主机。</p>
<p>在之前的步骤当中，是使用Ctrl-PQ组合键来退出容器的。在容器内部使用该操作可以退出当前容器，但不会杀死容器进程。可以通过docker container ls命令查看系统内全部处于运行状态的容器。</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> docker container ls</span> </span><br><span class="line">CONTAINER ID   IMAGE          COMMAND      CREATED  STATUS    NAMES </span><br><span class="line">e2b69eeb55cb   ubuntu:latest  &quot;/bin/bash&quot;  7 mins   Up 7 min  vigilant_borg</span><br></pre></td></tr></table></figure>



<p>上述的输出显示只有一个运行中的容器，就是前面示例中创建的那个容器，证明了容器在退出后依然是运行的。</p>
<h4 id="4-1-3-连接到运行中的容器"><a href="#4-1-3-连接到运行中的容器" class="headerlink" title="4.1.3 连接到运行中的容器"></a>4.1.3 连接到运行中的容器</h4><p>执行docker container exec命令，可以将Shell连接到一个运行中的容器终端。因为之前示例中的容器仍在运行，所以下面的示例会创建到该容器的新连接。</p>
<p>Linux示例如下。</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> docker container <span class="built_in">exec</span> -it vigilant_borg bash</span> </span><br><span class="line">root@e2b69eeb55cb:/#</span><br></pre></td></tr></table></figure>



<p>示例中的容器名为“vigilant_brog”。每个人环境中的容器名称会不同（本机是thirsty_hermann），所以请记得将“vigilant_brog”替换为自己Docker主机上运行中的容器名称或者ID。</p>
<p>Windows示例如下。</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;</span><span class="bash"> docker container <span class="built_in">exec</span> -it pensive_hamilton pwsh.exe</span></span><br><span class="line"></span><br><span class="line">Windows PowerShell </span><br><span class="line">Copyright (C) 2016 Microsoft Corporation. All rights reserved. </span><br><span class="line">PS C:\&gt;</span><br></pre></td></tr></table></figure>



<p>注意，Shell提示符又发生了变化。此时已登录到了容器内部。docker container exec命令的格式是docker container exec &lt;options&gt; &lt;container-name or container-id&gt; &lt;command/app&gt;。在示例中，将本地Shell连接到容器是通过-it参数实现的。本例中使用名称引用容器，并且告诉Docker运行Bash Shell（在Windows示例中是 PowerShell）。使用十六进制ID的方式也可以很容易地引用具体容器。</p>
<p>再次使用Ctrl-PQ组合键退出容器。Shell提示符应当退回到Docker主机中。</p>
<p>再次运行docker container ls命令来确认容器仍处于运行状态。</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> docker container ls CONTAINER ID   IMAGE          COMMAND      CREATED  STATUS    NAMES e2b69eeb55cb   ubuntu:latest  <span class="string">&quot;/bin/bash&quot;</span>  9 mins   Up 9 min  vigilant_borg</span></span><br></pre></td></tr></table></figure>



<p>通过docker container stop和docker container rm命令来停止并杀死容器。切记需要将示例中的名称/ID替换为读者自己的容器对应的名称和ID。</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> docker container stop vigilant_borg vigilant_borg</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> docker container rm vigilant_borg vigilant_borg</span></span><br></pre></td></tr></table></figure>



<p>通过运行docker container ls命令，并指定-a参数来确认容器 已经被成功删除。添加-a的作用是让Docker列出所有容器，甚至包括那些处于停止状态的。</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> docker container ls -a</span> </span><br><span class="line">CONTAINER ID    IMAGE    COMMAND    CREATED    STATUS    PORTS    NAMES</span><br></pre></td></tr></table></figure>



<h3 id="4-2-开发视角"><a href="#4-2-开发视角" class="headerlink" title="4.2 开发视角"></a>4.2 开发视角</h3><p><strong>容器即应用！</strong>接下来会分析一份应用代码中的Dockerfile并将其容器化，最终以容器的方式运行。</p>
<p>进入到仓库文件目录之下，查看其内容。</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> <span class="built_in">cd</span> psweb</span> </span><br><span class="line"><span class="meta">$</span><span class="bash"> ls -l</span> </span><br><span class="line">total 28 </span><br><span class="line">-rw-rw-r-- 1 ubuntu ubuntu  341 Sep 29 12:15 app.js </span><br><span class="line">-rw-rw-r-- 1 ubuntu ubuntu  216 Sep 29 12:15 circle.yml </span><br><span class="line">-rw-rw-r-- 1 ubuntu ubuntu  338 Sep 29 12:15 Dockerfile </span><br><span class="line">-rw-rw-r-- 1 ubuntu ubuntu  421 Sep 29 12:15 package.json </span><br><span class="line">-rw-rw-r-- 1 ubuntu ubuntu  370 Sep 29 12:15 README.md </span><br><span class="line">drwxrwxr-x 2 ubuntu ubuntu 4096 Sep 29 12:15 test </span><br><span class="line">drwxrwxr-x 2 ubuntu ubuntu 4096 Sep 29 12:15 views</span><br></pre></td></tr></table></figure>



<p>Linux的示例是一个简单的Node.js Web应用。Windows示例是一个简单的ASP.NET Web应用。每个仓库中都包含一个名为Dockerfile的文件。Dockerfile是一个纯文本文件，其中描述了如何将应用构建到Docker镜像当中。</p>
<p>查看Dockerfile的全部内容。</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> cat Dockerfile</span></span><br><span class="line"></span><br><span class="line">FROM alpine </span><br><span class="line">LABEL maintainer=&quot;nigelpoulton@hotmail.com&quot; </span><br><span class="line">RUN apk add --update nodejs nodejs-npm </span><br><span class="line">COPY . /src </span><br><span class="line">WORKDIR /src </span><br><span class="line">RUN  npm install </span><br><span class="line">EXPOSE  8080 </span><br><span class="line">ENTRYPOINT [&quot;node&quot;, &quot;./app.js&quot;]</span><br></pre></td></tr></table></figure>



<p>现在只需要知道Dockerfile的每一行都代表一个用于构建镜像的指令即可。使用docker image build命令，根据Dockerfile中的指令来创建新的镜像。示例中新建的Docker镜像名为test:latest。一定要在包含应用代码和Dockerfile的目录下执行这些命令。</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> docker image build -t <span class="built_in">test</span>:latest .</span></span><br><span class="line"></span><br><span class="line">Sending build context to Docker daemon 74.75kB </span><br><span class="line">Step 1/8 : FROM alpine </span><br><span class="line">latest: Pulling from library/alpine </span><br><span class="line">88286f41530e: Pull complete </span><br><span class="line">Digest: sha256:f006ecbb824...0c103f4820a417d </span><br><span class="line">Status: Downloaded newer image for alpine:latest </span><br><span class="line"><span class="meta"> ---&gt;</span><span class="bash"> 76da55c8019d</span> </span><br><span class="line">&lt;Snip&gt;</span><br><span class="line">Successfully built f154cb3ddbd4 </span><br><span class="line">Successfully tagged test:latest</span><br></pre></td></tr></table></figure>



<p>一旦构建完成，就可以确认主机上是否存在test:latest镜像。</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> docker image ls</span> </span><br><span class="line">REPO     TAG        IMAGE ID         CREATED         SIZE </span><br><span class="line">Test     latest     f154cb3ddbd4     1 minute ago    55.6MB </span><br><span class="line">...</span><br></pre></td></tr></table></figure>



<p>现在已经拥有一个新的Docker镜像，其中包含了应用程序。从镜像启动容器，并测试应用。Linux代码如下。</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> docker container run -d \ </span> </span><br><span class="line">  --name web1 \  </span><br><span class="line">  --publish 8080:8080 \ </span><br><span class="line">  test:latest</span><br></pre></td></tr></table></figure>



<p>打开Web浏览器，在地址栏中输入容器运行所在的Docker主机的DNS名称或者IP地址，并在后面加上端口号8080。然后就能看到图4.1的Web页面。</p>
<p><img src="https://pic-1258215793.cos.ap-shanghai.myqcloud.com/content/20191001/201910010112.png" alt="Linux系统测试应用Web界面"></p>
<p>Windows代码如下。</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;</span><span class="bash"> docker container run -d \ </span> </span><br><span class="line">  --name web1 \  </span><br><span class="line">  --publish 8080:80 \  </span><br><span class="line">  test:latest</span><br></pre></td></tr></table></figure>



<p>打开Web浏览器，在地址栏中输入容器运行所在的Docker主机的DNS名称或者IP地址，并在后面加上端口号8080，然后就能看到图4.2的Web页面。</p>
<p><img src="https://pic-1258215793.cos.ap-shanghai.myqcloud.com/content/20191001/201910010112.png" alt="Windows系统测试应用Web界面"></p>
<p>已经成功将应用代码构建到了Docker镜像当中，然后以容器的方式启动该镜像，这个过程叫作<strong>应用容器化</strong>。</p>
<hr>
<p>参考：</p>
<p>🔗 《深入浅出Docker》</p>

    </div>

    
    
    

    <footer class="post-footer">
          

<div class="post-copyright">
<ul>
  <li class="post-copyright-author">
      <strong>本文作者： </strong>Lys
  </li>
  <li class="post-copyright-link">
      <strong>本文链接：</strong>
      <a href="http://linyishui.top/2019100701.html" title="Docker（一）概览">http://linyishui.top/2019100701.html</a>
  </li>
  <li class="post-copyright-license">
    <strong>版权声明： </strong>本博客所有文章除特别声明外，均采用 <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/deed.zh" rel="noopener" target="_blank"><i class="fab fa-fw fa-creative-commons"></i>BY-NC-SA</a> 许可协议。转载请注明出处！
  </li>
</ul>
</div>

          <div class="post-tags">
              <a href="/tags/docker/" rel="tag"><i class="fa fa-tag"></i> docker</a>
          </div>

        

          <div class="post-nav">
            <div class="post-nav-item">
                <a href="/2019100401.html" rel="prev" title="函数式编程的技巧">
                  <i class="fa fa-chevron-left"></i> 函数式编程的技巧
                </a>
            </div>
            <div class="post-nav-item">
                <a href="/2019101001.html" rel="next" title="Docker（二）引擎">
                  Docker（二）引擎 <i class="fa fa-chevron-right"></i>
                </a>
            </div>
          </div>
    </footer>
  </article>
</div>






    <div class="comments utterances-container"></div>
</div>
  </main>

  <footer class="footer">
    <div class="footer-inner">


<div class="copyright">
  &copy; 2018 – 
  <span itemprop="copyrightYear">2021</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">Lys</span>
</div>
<div class="wordcount">
  <span class="post-meta-item">
    <span class="post-meta-item-icon">
      <i class="fa fa-chart-line"></i>
    </span>
      <span>站点总字数：</span>
    <span title="站点总字数">3.4m</span>
  </span>
  <span class="post-meta-item">
    <span class="post-meta-item-icon">
      <i class="fa fa-coffee"></i>
    </span>
      <span>站点阅读时长 &asymp;</span>
    <span title="站点阅读时长">51:30</span>
  </span>
</div>
  <div class="powered-by">由 <a href="https://hexo.io/" rel="noopener" target="_blank">Hexo</a> & <a href="https://theme-next.js.org/pisces/" rel="noopener" target="_blank">NexT.Pisces</a> 强力驱动
  </div>

    </div>
  </footer>

  
  <script src="https://cdn.jsdelivr.net/npm/animejs@3.2.1/lib/anime.min.js" integrity="sha256-XL2inqUJaslATFnHdJOi9GfQ60on8Wx1C2H8DYiN1xY=" crossorigin="anonymous"></script>
  <script src="https://cdn.jsdelivr.net/npm/jquery@3.6.0/dist/jquery.min.js" integrity="sha256-/xUj+3OJU5yExlq6GSYGSHk7tPXikynS7ogEvDej/m4=" crossorigin="anonymous"></script>
  <script src="https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@3.5.7/dist/jquery.fancybox.min.js" integrity="sha256-yt2kYMy0w8AbtF89WXb2P1rfjcP/HTHLT7097U8Y5b8=" crossorigin="anonymous"></script>
<script src="/js/comments.js"></script><script src="/js/utils.js"></script><script src="/js/motion.js"></script><script src="/js/next-boot.js"></script><script src="/js/bookmark.js"></script>

  
<script src="/js/third-party/search/local-search.js"></script>



  <script class="next-config" data-name="nprogress" type="application/json">{"enable":true,"spinner":true}</script>
  <script src="/js/third-party/nprogress.js"></script>

  




<script src="https://cdn.jsdelivr.net/npm/darkmode-js@1.5.7/lib/darkmode-js.min.js"></script>

<script>
var options = {
  bottom: '64px',
  right: '32px',
  left: 'unset',
  time: '0.5s',
  mixColor: 'transparent',
  backgroundColor: 'transparent',
  buttonColorDark: '#100f2c',
  buttonColorLight: '#fff',
  saveInCookies: true,
  label: '🌓',
  autoMatchOsTheme: true
}
const darkmode = new Darkmode(options);
window.darkmode = darkmode;
darkmode.showWidget();
</script>
<script class="next-config" data-name="utterances" type="application/json">{"enable":true,"repo":"LAILAIWA/LAILAIWA.github.io","issue_term":"pathname","theme":"github-light"}</script>
<script src="/js/third-party/comments/utterances.js"></script>



</body>
</html>
