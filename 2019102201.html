<!DOCTYPE html>



  


<html class="theme-next pisces use-motion" lang="zh-Hans">
<head><meta name="generator" content="Hexo 3.9.0">
  <meta charset="UTF-8">
<meta http-equiv="X-UA-Compatible" content="IE=edge">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
<meta name="theme-color" content="#222">



  
  
    
    
  <script src="/lib/pace/pace.min.js?v=1.0.2"></script>
  <link href="/lib/pace/pace-theme-minimal.min.css?v=1.0.2" rel="stylesheet">







<meta http-equiv="Cache-Control" content="no-transform">
<meta http-equiv="Cache-Control" content="no-siteapp">
















  
  
  <link href="/lib/fancybox/source/jquery.fancybox.css?v=2.1.5" rel="stylesheet" type="text/css">







<link href="/lib/font-awesome/css/font-awesome.min.css?v=4.6.2" rel="stylesheet" type="text/css">

<link href="/css/main.css?v=5.1.4" rel="stylesheet" type="text/css">


  <link rel="apple-touch-icon" sizes="180x180" href="/images/gamepad playstation.png?v=5.1.4">


  <link rel="icon" type="image/png" sizes="32x32" href="/images/Dig Dug.ico?v=5.1.4">


  <link rel="icon" type="image/png" sizes="16x16" href="/images/gamepad playstation.png?v=5.1.4">


  <link rel="mask-icon" href="/images/gamepad playstation.svg?v=5.1.4" color="#222">





  <meta name="keywords" content="Q&A,updating,">





  <link rel="alternate" href="/atom.xml" title="俺的部落格" type="application/atom+xml">






<meta name="description" content="整理面试中常问的Java并发编程相关问题，持续更新中。">
<meta name="keywords" content="Q&amp;A,updating">
<meta property="og:type" content="article">
<meta property="og:title" content="面试整理——Java并发编程">
<meta property="og:url" content="http://linyishui.top/2019102201.html">
<meta property="og:site_name" content="俺的部落格">
<meta property="og:description" content="整理面试中常问的Java并发编程相关问题，持续更新中。">
<meta property="og:locale" content="zh-Hans">
<meta property="og:image" content="https://pic-1258215793.cos.ap-shanghai.myqcloud.com/content/20190316/201903160104.jpg">
<meta property="og:image" content="https://pic-1258215793.cos.ap-shanghai.myqcloud.com/content/20190601/201906010120.png">
<meta property="og:updated_time" content="2020-08-20T14:33:30.272Z">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="面试整理——Java并发编程">
<meta name="twitter:description" content="整理面试中常问的Java并发编程相关问题，持续更新中。">
<meta name="twitter:image" content="https://pic-1258215793.cos.ap-shanghai.myqcloud.com/content/20190316/201903160104.jpg">



<script type="text/javascript" id="hexo.configurations">
  var NexT = window.NexT || {};
  var CONFIG = {
    root: '/',
    scheme: 'Pisces',
    version: '5.1.4',
    sidebar: {"position":"left","display":"always","offset":12,"b2t":false,"scrollpercent":false,"onmobile":false},
    fancybox: true,
    tabs: true,
    motion: {"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}},
    duoshuo: {
      userId: '0',
      author: '博主'
    },
    algolia: {
      applicationID: '',
      apiKey: '',
      indexName: '',
      hits: {"per_page":10},
      labels: {"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}
    }
  };
</script>



  <link rel="canonical" href="http://linyishui.top/2019102201.html">





  <title>面试整理——Java并发编程 | 俺的部落格</title>
  








</head>

<body itemscope itemtype="http://schema.org/WebPage" lang="zh-Hans">

  
  
    
  

  <div class="container sidebar-position-left page-post-detail">
    <div class="headband"></div>

    <header id="header" class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-wrapper">
  <div class="site-meta ">
    

    <div class="custom-logo-site-title">
      <a href="/" class="brand" rel="start">
        <span class="logo-line-before"><i></i></span>
        <span class="site-title">俺的部落格</span>
        <span class="logo-line-after"><i></i></span>
      </a>
    </div>
      
        <p class="site-subtitle">俺寻思俺需要记点东西</p>
      
  </div>

  <div class="site-nav-toggle">
    <button>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
    </button>
  </div>
</div>

<nav class="site-nav">
  

  
    <ul id="menu" class="menu">
      
        
        <li class="menu-item menu-item-home">
          <a href="/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-home"></i> <br>
            
            首页
          </a>
        </li>
      
        
        <li class="menu-item menu-item-about">
          <a href="/about/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-user"></i> <br>
            
            关于
          </a>
        </li>
      
        
        <li class="menu-item menu-item-tags">
          <a href="/tags/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-tags"></i> <br>
            
            标签
          </a>
        </li>
      
        
        <li class="menu-item menu-item-categories">
          <a href="/categories/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-th"></i> <br>
            
            分类
          </a>
        </li>
      
        
        <li class="menu-item menu-item-archives">
          <a href="/archives/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-archive"></i> <br>
            
            归档
          </a>
        </li>
      
        
        <li class="menu-item menu-item-sitemap">
          <a href="/sitemap.xml" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-sitemap"></i> <br>
            
            站点地图
          </a>
        </li>
      
        
        <li class="menu-item menu-item-commonweal">
          <a href="/404/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-heartbeat"></i> <br>
            
            公益404
          </a>
        </li>
      

      
        <li class="menu-item menu-item-search">
          
            <a href="javascript:;" class="popup-trigger">
          
            
              <i class="menu-item-icon fa fa-search fa-fw"></i> <br>
            
            搜索
          </a>
        </li>
      
    </ul>
  

  
    <div class="site-search">
      
  <div class="popup search-popup local-search-popup">
  <div class="local-search-header clearfix">
    <span class="search-icon">
      <i class="fa fa-search"></i>
    </span>
    <span class="popup-btn-close">
      <i class="fa fa-times-circle"></i>
    </span>
    <div class="local-search-input-wrapper">
      <input autocomplete="off" placeholder="搜索..." spellcheck="false" type="text" id="local-search-input">
    </div>
  </div>
  <div id="local-search-result"></div>
</div>



    </div>
  
</nav>



 </div>
    </header>

    <main id="main" class="main">
      <div class="main-inner">
        <div class="content-wrap">
          <div id="content" class="content">
            

  <div id="posts" class="posts-expand">
    

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://linyishui.top/2019102201.html">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Speciosity">
      <meta itemprop="description" content>
      <meta itemprop="image" content="https://pic-1258215793.cos.ap-shanghai.myqcloud.com/cover/riho_yoshioka1.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="俺的部落格">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">面试整理——Java并发编程</h1>
        

        <div class="post-meta">
          
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2019-10-22T16:06:16+08:00">
                2019-10-22
              </time>
            

            

            
          </span>

          
            <span class="post-category">
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/面试整理/" itemprop="url" rel="index">
                    <span itemprop="name">面试整理</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          
            <div class="post-wordcount">
              
                
                <span class="post-meta-item-icon">
                  <i class="fa fa-file-word-o"></i>
                </span>
                
                  <span class="post-meta-item-text">字数统计&#58;</span>
                
                <span title="字数统计">
                  8,868
                </span>
              

              
                <span class="post-meta-divider">|</span>
              

              
                <span class="post-meta-item-icon">
                  <i class="fa fa-clock-o"></i>
                </span>
                
                  <span class="post-meta-item-text">阅读时长 &asymp;</span>
                
                <span title="阅读时长">
                  31
                </span>
              
            </div>
          

          
              <div class="post-description">
                  整理面试中常问的Java并发编程相关问题，持续更新中。
              </div>
          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        <h1 id="Java并发编程"><a href="#Java并发编程" class="headerlink" title="Java并发编程"></a><strong>Java并发编程</strong></h1><h2 id="第一节-多线程"><a href="#第一节-多线程" class="headerlink" title="第一节 多线程"></a><strong>第一节 多线程</strong></h2><h3 id="1-1-线程"><a href="#1-1-线程" class="headerlink" title="1.1 线程"></a><strong>1.1 线程</strong></h3><h4 id="问：什么时候用线程？"><a href="#问：什么时候用线程？" class="headerlink" title="问：什么时候用线程？"></a><strong>问：什么时候用线程？</strong></h4><details><br><br><em> <strong>需要频繁创建和销毁</strong>。
</em> <strong>需要频繁切换</strong>。<br><em> <strong>多核环境</strong>。
</em> <strong>并行操作</strong>。<br>* <strong>相比稳定安全更需要速度</strong>。<br><br></details>

<h4 id="问：创建多线程的方式，以及线程的状态转换？"><a href="#问：创建多线程的方式，以及线程的状态转换？" class="headerlink" title="问：创建多线程的方式，以及线程的状态转换？"></a><strong>问：创建多线程的方式，以及线程的状态转换？</strong></h4><details><br>Java中有：<br><br><em> 继承Thread类，重写run()，创建线程对象。
</em> 实现Runnable接口，重写run()，创建线程对象。<br><em> 实现Callable接口，重写call()，创建实例对象并作为构造器参数创建FutureTask对象，再使用FutureTask对象作为构造器参数创建线程对象。
</em> 使用Executor框架创建线程池。<br><br><img src="https://pic-1258215793.cos.ap-shanghai.myqcloud.com/content/20190316/201903160104.jpg" alt="线程状态"><br><br>状态|名称|示例|介绍<br>:—:|:—:|:—|:—<br>New|初始状态|new Thread(runnable)|线程还未开始运行，处于创建状态<br>Runnable|运行状态|thread.start()|可运行但未必在运行，取决于OS分配的运行时间，即就绪和运行两状态的合并。<br>Blocked|阻塞状态||请求内部的对象锁，但锁被其他线程持有<br>Waiting|等待状态|Object.wait() / Thread.join() / 等待Lock或Condition|当线程等待另一个线程通知调度器某个条件时，处于此状态<br>Timed waiting|超时等待|Object.wait() / Thread.join() / Thread.sleep() / Lock.tryLock() / Condition.await()|调用有些有超时参数的方法时，可以指定时间自行返回<br>Terminated|终止状态|不要使用stop()|要么因为run方法正常结束而终止，要么因为没有捕获的异常终止了run方法而结束<br><br>一个经历了所有状态的线程可能会经历以下流程：线程创建后调用start()方法开始，状态由NEW-&gt;RUNNABLE。当线程执行wait()后，线程进入WAITING状态。处于WAITING状态的线程需要等待其他线程的通知才可以恢复RUNNABLE状态，而TIME_WAITING则是在WAITING上增加了时间限制，在超时后会自动返回RUNNABLE状态。当线程调用同步方法时，在无法获得锁的情况下，线程进入BLOCKED状态。线程在执行run()方法后将进入终止状态。<br><br></details>

<h4 id="问：终止线程的方法？"><a href="#问：终止线程的方法？" class="headerlink" title="问：终止线程的方法？"></a><strong>问：终止线程的方法？</strong></h4><details><br><em> 使用退出标志（如volatile布尔变量），表示线程正常退出；
</em> 通过interrupt()中断，run()内通过isInterrupted()判断是否中断，若处于阻塞状态就无法检测中断状态，会抛出异常InterruptedException。<br><br></details>

<h4 id="问：谈一下线程切换，并引申到Java阻塞，运行？"><a href="#问：谈一下线程切换，并引申到Java阻塞，运行？" class="headerlink" title="问：谈一下线程切换，并引申到Java阻塞，运行？"></a><strong>问：谈一下线程切换，并引申到Java阻塞，运行？</strong></h4><details><br><br>线程切换就是指<strong>CPU从一个进程/线程切换到另一个进程/线程</strong>（上下文指某个时间节点CPU寄存器和计数器的内容）。大概过程可以简单的理解为：<strong>挂起当前线程</strong>（存储当前上下文），<strong>恢复一个线程</strong>（找到一个合适的上下文并恢复到寄存器），<strong>跳转到程序计数器指向的位置</strong>（即线程被中断时的代码行）。<br><br>阻塞就是指线程执行到某一阶段时，需要获取某些资源才能继续执行，但此时这些资源被其他线程占用，所以当前线程需要处于等待状态。<br><br></details>

<h4 id="问：线程的中断机制？"><a href="#问：线程的中断机制？" class="headerlink" title="问：线程的中断机制？"></a><strong>问：线程的中断机制？</strong></h4><details><br><br>Java的线程中有一个中断标识位，表示是否有中断请求，并在Thread中提供了interrupt()来中断线程，以及interrupted()和isInterrupted()来判断当前中断状态，前者会将中断复位。<br><br>中断并不意味着线程会立即终止，中断线程可以任意处理，通常会把中断请求当作终止请求，由线程根据情况在合适的时机终止。<br><br>处于阻塞状态的线程会抛出异常InterruptedException，且抛出异常的方法大多会先重置中断标识位再抛出异常。<br><br></details>

<h4 id="问：怎么实现所有线程在等待某个事件的发生才会去执行？"><a href="#问：怎么实现所有线程在等待某个事件的发生才会去执行？" class="headerlink" title="问：怎么实现所有线程在等待某个事件的发生才会去执行？"></a><strong>问：怎么实现所有线程在等待某个事件的发生才会去执行？</strong></h4><details><br><em> <strong>读写锁</strong>：主线程先获取写锁，所有子线程获取读锁，等事件发生时主线程释放写锁。
</em> <strong>CountDownLatch</strong>：初始值设置为1，所有子线程调用 <code>await()</code> 等待，等事件发生时调用 <code>countDown()</code> 方法计数减为0。<br><em> <strong>Semaphore</strong>：初始值设为N，主线程先调用 <code>acquire(N)</code> 申请N个信号量，其他线程调用 <code>acquire()</code> 阻塞等待，等事件发生时主线程同时释放N个信号量。
</em> <strong>CyclicBarrier</strong>：<br><br><br></details>

<h4 id="问：如何实现控制线程在某段时间内完成，不完成就撤销？"><a href="#问：如何实现控制线程在某段时间内完成，不完成就撤销？" class="headerlink" title="问：如何实现控制线程在某段时间内完成，不完成就撤销？"></a><strong>问：如何实现控制线程在某段时间内完成，不完成就撤销？</strong></h4><details><br><br><br><br></details>

<h4 id="问：线程回调？"><a href="#问：线程回调？" class="headerlink" title="问：线程回调？"></a><strong>问：线程回调？</strong></h4><details><br><br><br><br></details>

<h4 id="问：RPC-框架？设计一个-RPC，怎么实现"><a href="#问：RPC-框架？设计一个-RPC，怎么实现" class="headerlink" title="问：RPC 框架？设计一个 RPC，怎么实现"></a><strong>问：RPC 框架？设计一个 RPC，怎么实现</strong></h4><details><br><br>用到了回调这块的东西<br><br></details>

<h4 id="问：线程间的通信可以怎么做？线程间相互通知你会怎么做，代码要怎么实现？"><a href="#问：线程间的通信可以怎么做？线程间相互通知你会怎么做，代码要怎么实现？" class="headerlink" title="问：线程间的通信可以怎么做？线程间相互通知你会怎么做，代码要怎么实现？"></a><strong>问：线程间的通信可以怎么做？线程间相互通知你会怎么做，代码要怎么实现？</strong></h4><details><br><br>答了synchronized和Object的wait和notify，强调了notify是随机，All是全部，然后问All怎么个全部法，全部唤醒都开始执行不就不安全了吗？<br><br></details>

<hr>
<h3 id="1-2-ThreadLocal"><a href="#1-2-ThreadLocal" class="headerlink" title="1.2 ThreadLocal"></a><strong>1.2 ThreadLocal</strong></h3><h4 id="问：谈一下ThreadLocal？应用场景？原理？与-Thread-类的关系？"><a href="#问：谈一下ThreadLocal？应用场景？原理？与-Thread-类的关系？" class="headerlink" title="问：谈一下ThreadLocal？应用场景？原理？与 Thread 类的关系？"></a><strong>问：谈一下ThreadLocal？应用场景？原理？与 Thread 类的关系？</strong></h4><details><br><br>&gt;应用：<br>&gt; <em> 用来解决数据库连接，存放connection对象，不同线程存放各自session；<br>&gt; </em> 解决simpleDateFormat线程安全问题；<br>&gt; * 会出现内存泄漏，显式remove..不要与线程池配合，因为worker往往是不会退出的；<br><br>原理：线程中创建副本，访问自己内部的副本变量，内部实现是其内部类名叫ThreadLocalMap的成员变量threadLocals，key为本身，value为实际存值的变量副本<br><br>与 Thread 类的关系：<br><br></details>

<h4 id="问：static-能不能修饰-ThreadLocal？"><a href="#问：static-能不能修饰-ThreadLocal？" class="headerlink" title="问：static 能不能修饰 ThreadLocal？"></a><strong>问：static 能不能修饰 ThreadLocal？</strong></h4><details><br><br>能，且通常将ThreadLocal变量声明为私有静态，这样做有好处也有坏处，主要是为了避免重复的创建TSO（thread specific object，即与线程相关的变量），坏处是可能导致内存泄漏。<br><br>如果声明ThreadLocal为某个类的实例变量，每创建一个类的实例就会创建新的ThreadLocal实例，导致同一个线程可能访问到同一个TSO类的不同实例，也因为重复创建相同的对象导致浪费。<br><br>因为类对ThreadLocal的静态引用，导致最终生成了对ThreadLocal的一条可达引用链路，使ThreadLocal实例不会被垃圾回收，即产生了内存泄漏。<br><br>所以使用ThreadLocal需要手动回收这部分内存，可以remove或使ThreadLocal变量=null。<br><br></details>

<h4 id="问：谈一下ThreadLocal的内存泄漏问题？"><a href="#问：谈一下ThreadLocal的内存泄漏问题？" class="headerlink" title="问：谈一下ThreadLocal的内存泄漏问题？"></a><strong>问：谈一下ThreadLocal的内存泄漏问题？</strong></h4><details><br><br>如果是强引用，设置tl=null，但是key的引用依然指向ThreadLocal对象，所以会有内存泄漏，而使用弱引用则不会； 但是还是会有内存泄漏存在，ThreadLocal被回收，key的值变成null，导致整个value再也无法被访问到； 解决办法：在使用结束时，调用ThreadLocal.remove来释放其value的引用；<br><br></details>

<h4 id="问：如果我们要获取父线程的ThreadLocal值呢？"><a href="#问：如果我们要获取父线程的ThreadLocal值呢？" class="headerlink" title="问：如果我们要获取父线程的ThreadLocal值呢？"></a><strong>问：如果我们要获取父线程的ThreadLocal值呢？</strong></h4><details><br><br>ThreadLocal是不具备继承性的，所以是无法获取到的，但是我们可以用InteritableThreadLocal来实现这个功能。InteritableThreadLocal继承来ThreadLocal，重写了createdMap方法，已经对应的get和set方法，不是在利用了threadLocals，而是interitableThreadLocals变量。<br><br>这个变量会在线程初始化的时候（调用init方法），会判断父线程的interitableThreadLocals变量是否为空，如果不为空，则把放入子线程中，但是其实这玩意没啥鸟用，当父线程创建完子线程后，如果改变父线程内容是同步不到子线程的。。。同样，如果在子线程创建完后，再去赋值，也是没啥鸟用的<br><br></details>

<hr>
<h3 id="1-3-Thread"><a href="#1-3-Thread" class="headerlink" title="1.3 Thread"></a><strong>1.3 Thread</strong></h3><h4 id="问：Thread类里有哪些常用方法？"><a href="#问：Thread类里有哪些常用方法？" class="headerlink" title="问：Thread类里有哪些常用方法？"></a><strong>问：Thread类里有哪些常用方法？</strong></h4><details><br><br><br><br></details>

<h4 id="问：interrupt-isInterrupted-interrupt区别？"><a href="#问：interrupt-isInterrupted-interrupt区别？" class="headerlink" title="问：interrupt/isInterrupted/interrupt区别？"></a><strong>问：interrupt/isInterrupted/interrupt区别？</strong></h4><details><br><br>&gt; <em> interrupt（） 调用该方法的线程的状态为将被置为”中断”状态（set操作）<br>&gt; </em> isinterrupted（） 是作用于调用该方法的线程对象所对应的线程的中断信号是true还是false（get操作）。例如我们可以在A线程中去调用B线程对象的isInterrupted方法，查看的是A<br>&gt; * interrupted（）是静态方法：内部实现是调用的当前线程的isInterrupted（），并且会重置当前线程的中断状态（getandset）<br><br></details>

<h4 id="问：谈一下start和run方法的区别？"><a href="#问：谈一下start和run方法的区别？" class="headerlink" title="问：谈一下start和run方法的区别？"></a><strong>问：谈一下start和run方法的区别？</strong></h4><details><br><br>答：start方法启动多线程，但并不一定直接运行，而是先进入可运行状态，等待调度分配。run方法是线程体，包含了要执行的线程的内容，当run方法执行结束，线程随即终止，调用run方法并不能用来启动线程。<br><br></details>

<h4 id="问：sleep-和-wait-有什么区别？"><a href="#问：sleep-和-wait-有什么区别？" class="headerlink" title="问：sleep 和 wait 有什么区别？"></a><strong>问：sleep 和 wait 有什么区别？</strong></h4><details><br><br>sleep属于线程类，wait属于object类；sleep不释放锁<br><br></details>

<h4 id="问：sleep-和-yeild-方法有什么区别？"><a href="#问：sleep-和-yeild-方法有什么区别？" class="headerlink" title="问：sleep 和 yeild 方法有什么区别？"></a><strong>问：sleep 和 yeild 方法有什么区别？</strong></h4><details><br><br><br><br></details>

<hr>
<h3 id="1-4-线程池"><a href="#1-4-线程池" class="headerlink" title="1.4 线程池"></a><strong>1.4 线程池</strong></h3><h4 id="问：项目的用户量多吗？有用过线程池吗？用到多线程的优势在哪？"><a href="#问：项目的用户量多吗？有用过线程池吗？用到多线程的优势在哪？" class="headerlink" title="问：项目的用户量多吗？有用过线程池吗？用到多线程的优势在哪？"></a><strong>问：项目的用户量多吗？有用过线程池吗？用到多线程的优势在哪？</strong></h4><details><br><br>以前的项目用户量不大，但有学习和练习过线程池。<br><br>多线程意味着能同时执行多个任务，可以更好的利用CPU的空闲时间，让程序运行的更快。<br><br>线程池则是用来管理和限制系统中执行线程的数量，减少创建和销毁线程的次数，重复的利用已创建的线程，防止内存的浪费，也能提高响应速度。<br><br></details>

<h4 id="问：ThreadPoolExecutor-初始化参数？"><a href="#问：ThreadPoolExecutor-初始化参数？" class="headerlink" title="问：ThreadPoolExecutor 初始化参数？"></a><strong>问：ThreadPoolExecutor 初始化参数？</strong></h4><details><br><br><em> <strong>corePoolSize</strong>（线程池基本大小）：控制执行线程的数目，超过此值就不再创建基本线程。
</em> <strong>maximumPoolSize</strong>（线程池最大数量）：若队列满了，会继续创建新的线程，直到达到线程池最大数量，当然若任务队列没有界限此参数就失效了。<br><em> <strong>ThreadFactory</strong>（线程工厂）：用于设置创建线程的工厂，一般用于给线程统一命名。
</em> <strong>runnableTaskQueue</strong>（任务队列）：保存等待执行的任务阻塞队列，有多种选择：数组先进先出队列、链表先进先出队列、不存储元素的阻塞队列、含优先级的无限阻塞队列。<br><em> <strong>RejectedExecutionHandler</strong>（饱和策略）：队列和线程池都满了后，处于饱和状态时的新任务处理策略。默认是AbortPolicy直接抛出异常，还有直接丢弃、丢弃最近任务等等。
</em> <strong>keepAliveTime</strong>（线程活动保持时间）：工作线程空闲后能够存活的时间，当任务很多且执行时间较短时，可以调高此值，提高线程的利用率。<br>* <strong>TimeUnit</strong>（时间单位）：可选的单位有天（DAYS）、小时（HOURS）、分钟 （MINUTES）、毫秒（MILLISECONDS）、微秒（MICROSECONDS，千分之一毫秒）和纳秒（NANOSECONDS，千分之一微秒）。<br><br></details>

<h4 id="问：线程状态？"><a href="#问：线程状态？" class="headerlink" title="问：线程状态？"></a><strong>问：线程状态？</strong></h4><details><br><br>线程池有5种状态：running，showdown，stop，Tidying，TERMINATED。<br><br>&gt; <em> running：线程池处于运行状态，可以接受任务，执行任务，创建线程默认就是这个状态了<br>&gt; </em> showdown：调用showdown（）函数，不会接受新任务，但是会慢慢处理完堆积的任务。<br>&gt; <em> stop：调用showdownnow（）函数，不会接受新任务，不处理已有的任务，会中断现有的任务。<br>&gt; </em> Tidying：当线程池状态为showdown或者stop，任务数量为0，就会变为tidying。这个时候会调用钩子函数terminated（）。<br>&gt; * ERMINATED：terminated（）执行完成。<br><br>在线程池中，用了一个原子类来记录线程池的信息，用了int的高3位表示状态，后面的29位表示线程池中线程的个数。<br><br></details>

<h4 id="问：corepoolSize-怎么设置，maxpoolsize-怎么设置，keep-alive-各种的？"><a href="#问：corepoolSize-怎么设置，maxpoolsize-怎么设置，keep-alive-各种的？" class="headerlink" title="问：corepoolSize 怎么设置，maxpoolsize 怎么设置，keep-alive 各种的？"></a><strong>问：corepoolSize 怎么设置，maxpoolsize 怎么设置，keep-alive 各种的？</strong></h4><details><br><br><br><br></details>

<h4 id="问：阻塞队列在生产中的设置？"><a href="#问：阻塞队列在生产中的设置？" class="headerlink" title="问：阻塞队列在生产中的设置？"></a><strong>问：阻塞队列在生产中的设置？</strong></h4><details><br><br>一般设置为 0，防止用户阻塞<br><br></details>

<h4 id="问：Java中的线程池是如何实现的？讲一下线程池的原理？"><a href="#问：Java中的线程池是如何实现的？讲一下线程池的原理？" class="headerlink" title="问：Java中的线程池是如何实现的？讲一下线程池的原理？"></a><strong>问：Java中的线程池是如何实现的？讲一下线程池的原理？</strong></h4><details><br><br>&gt; <em> 线程中线程被抽象为静态内部类Worker，是基于AQS实现的存放在HashSet中；<br>&gt; </em> 要被执行的线程存放在BlockingQueue中；<br>&gt; * 基本思想就是从workQueue中取出要执行的任务，放在worker中处理；<br><br></details>

<h4 id="问：如果线程池中的一个线程运行时出现了异常，会发生什么？"><a href="#问：如果线程池中的一个线程运行时出现了异常，会发生什么？" class="headerlink" title="问：如果线程池中的一个线程运行时出现了异常，会发生什么？"></a><strong>问：如果线程池中的一个线程运行时出现了异常，会发生什么？</strong></h4><details><br><br>如果提交任务的时候使用了submit，则返回的feature里会存有异常信息，但是如果数execute则会打印出异常栈。但是不会给其他线程造成影响。之后线程池会删除该线程，会新增加一个worker。<br><br></details>

<h4 id="问：讲一下线程池的原理？"><a href="#问：讲一下线程池的原理？" class="headerlink" title="问：讲一下线程池的原理？"></a><strong>问：讲一下线程池的原理？</strong></h4><details><br><br>&gt; <em> 提交一个任务，线程池里存活的核心线程数小于corePoolSize时，线程池会创建一个核心线程去处理提交的任务<br>&gt; </em> 如果线程池核心线程数已满，即线程数已经等于corePoolSize，一个新提交的任务，会被放进任务队列workQueue排队等待执行。<br>&gt; <em> 当线程池里面存活的线程数已经等于corePoolSize了，并且任务队列workQueue也满，判断线程数是否达到maximumPoolSize，即最大线程数是否已满，如果没到达，创建非核心线程执行提交的任务。<br>&gt; </em> 如果当前的线程数达到了maximumPoolSize，还有新的任务过来的话，直接采用拒绝策略处理。<br><br></details>

<h4 id="问：如何实现一个线程池，Java中线程池如何进行配置？线程池的线程数怎么确定？"><a href="#问：如何实现一个线程池，Java中线程池如何进行配置？线程池的线程数怎么确定？" class="headerlink" title="问：如何实现一个线程池，Java中线程池如何进行配置？线程池的线程数怎么确定？"></a><strong>问：如何实现一个线程池，Java中线程池如何进行配置？线程池的线程数怎么确定？</strong></h4><details><br><br>如果是IO操作为主怎么确定？如果计算型操作又怎么确定？跳表的查询过程是怎么样的，查询和插入的时间复杂度?<br><br></details>

<h4 id="问：如何实现一个线程池，Java中线程池如何进行配置？线程池的核心参数记得吗？线程池的工作流程记得吗？"><a href="#问：如何实现一个线程池，Java中线程池如何进行配置？线程池的核心参数记得吗？线程池的工作流程记得吗？" class="headerlink" title="问：如何实现一个线程池，Java中线程池如何进行配置？线程池的核心参数记得吗？线程池的工作流程记得吗？"></a><strong>问：如何实现一个线程池，Java中线程池如何进行配置？线程池的核心参数记得吗？线程池的工作流程记得吗？</strong></h4><details><br><br><br><br></details>

<h4 id="问：线程池里如何知道线程执行完了没有？线程阻塞怎么办？怎么保证所有线程执行完之后继续往下处理？怎么让一个线程等另一个线程执行结束？"><a href="#问：线程池里如何知道线程执行完了没有？线程阻塞怎么办？怎么保证所有线程执行完之后继续往下处理？怎么让一个线程等另一个线程执行结束？" class="headerlink" title="问：线程池里如何知道线程执行完了没有？线程阻塞怎么办？怎么保证所有线程执行完之后继续往下处理？怎么让一个线程等另一个线程执行结束？"></a><strong>问：线程池里如何知道线程执行完了没有？线程阻塞怎么办？怎么保证所有线程执行完之后继续往下处理？怎么让一个线程等另一个线程执行结束？</strong></h4><details><br><br>答了CountdownLatch和CyclicBarrier，之后提示可以利用Thread的join方法<br><br></details>

<h3 id="问：Java-的信号灯？"><a href="#问：Java-的信号灯？" class="headerlink" title="问：Java 的信号灯？"></a><strong>问：Java 的信号灯？</strong></h3><details><br><br><br><br></details>


<h4 id="问：Executors-静态方法？"><a href="#问：Executors-静态方法？" class="headerlink" title="问：Executors 静态方法？"></a><strong>问：Executors 静态方法？</strong></h4><details><br><br><br><br></details>

<h4 id="问：拒绝策略？"><a href="#问：拒绝策略？" class="headerlink" title="问：拒绝策略？"></a><strong>问：拒绝策略？</strong></h4><details><br><br>&gt; <em> AbortPolicy直接抛出异常阻止线程运行；<br>&gt; </em> CallerRunsPolicy如果被丢弃的线程任务未关闭，则执行该线程；<br>&gt; <em> DiscardOldestPolicy移除队列最早线程尝试提交当前任务<br>&gt; </em> DiscardPolicy丢弃当前任务，不做处理<br><br></details>

<h4 id="问：newFixedThreadPool-（固定数目线程的线程池）？"><a href="#问：newFixedThreadPool-（固定数目线程的线程池）？" class="headerlink" title="问：newFixedThreadPool （固定数目线程的线程池）？"></a><strong>问：newFixedThreadPool （固定数目线程的线程池）？</strong></h4><details><br><br>&gt; <em> 阻塞队列为无界队列LinkedBlockingQueue<br>&gt; </em> 适用于处理CPU密集型的任务，适用执行长期的任务<br><br></details>

<h4 id="问：newCachedThreadPool（可缓存线程的线程池）？"><a href="#问：newCachedThreadPool（可缓存线程的线程池）？" class="headerlink" title="问：newCachedThreadPool（可缓存线程的线程池）？"></a><strong>问：newCachedThreadPool（可缓存线程的线程池）？</strong></h4><details><br><br>&gt; <em> 阻塞队列是SynchronousQueue<br>&gt; </em> 适用于并发执行大量短期的小任务<br><br></details>

<h4 id="问：newSingleThreadExecutor（单线程的线程池）？"><a href="#问：newSingleThreadExecutor（单线程的线程池）？" class="headerlink" title="问：newSingleThreadExecutor（单线程的线程池）？"></a><strong>问：newSingleThreadExecutor（单线程的线程池）？</strong></h4><details><br><br><br>&gt; <em> 阻塞队列是LinkedBlockingQueue<br>&gt; </em> 适用于串行执行任务的场景，一个任务一个任务地执行<br><br></details>

<h4 id="问：newScheduledThreadPool（定时及周期执行的线程池）？"><a href="#问：newScheduledThreadPool（定时及周期执行的线程池）？" class="headerlink" title="问：newScheduledThreadPool（定时及周期执行的线程池）？"></a><strong>问：newScheduledThreadPool（定时及周期执行的线程池）？</strong></h4><details><br><br>&gt; <em> 阻塞队列是DelayedWorkQueue<br>&gt; </em> 周期性执行任务的场景，需要限制线程数量的场景<br><br></details>

<hr>
<h3 id="1-5-线程安全"><a href="#1-5-线程安全" class="headerlink" title="1.5 线程安全"></a><strong>1.5 线程安全</strong></h3><h4 id="问：谈一下对线程安全的理解？用什么方法保证线程的安全？"><a href="#问：谈一下对线程安全的理解？用什么方法保证线程的安全？" class="headerlink" title="问：谈一下对线程安全的理解？用什么方法保证线程的安全？"></a><strong>问：谈一下对线程安全的理解？用什么方法保证线程的安全？</strong></h4><details><br><br><br><br></details>

<h4 id="问：如何线程安全的实现一个计数器？"><a href="#问：如何线程安全的实现一个计数器？" class="headerlink" title="问：如何线程安全的实现一个计数器？"></a><strong>问：如何线程安全的实现一个计数器？</strong></h4><details><br><br><br><br></details>

<h4 id="问：请写一个线程安全的单例模式？"><a href="#问：请写一个线程安全的单例模式？" class="headerlink" title="问：请写一个线程安全的单例模式？"></a><strong>问：请写一个线程安全的单例模式？</strong></h4><details><br><br><br><br></details>

<h4 id="问：单例模式，饿汉式，懒汉式，线程安全的做法，两次判断-instance-是否为空，每次判断的作用是什么？"><a href="#问：单例模式，饿汉式，懒汉式，线程安全的做法，两次判断-instance-是否为空，每次判断的作用是什么？" class="headerlink" title="问：单例模式，饿汉式，懒汉式，线程安全的做法，两次判断 instance 是否为空，每次判断的作用是什么？"></a><strong>问：单例模式，饿汉式，懒汉式，线程安全的做法，两次判断 instance 是否为空，每次判断的作用是什么？</strong></h4><details><br><br><br><br></details>

<h4 id="问：ABC-三个线程如何保证顺序执行？"><a href="#问：ABC-三个线程如何保证顺序执行？" class="headerlink" title="问：ABC 三个线程如何保证顺序执行？"></a><strong>问：ABC 三个线程如何保证顺序执行？</strong></h4><details><br><br><br><br></details>

<h4 id="问：生产者消费者模式的实现方式？"><a href="#问：生产者消费者模式的实现方式？" class="headerlink" title="问：生产者消费者模式的实现方式？"></a><strong>问：生产者消费者模式的实现方式？</strong></h4><details><br><br><br><br></details>

<hr>
<h2 id="第二节-锁"><a href="#第二节-锁" class="headerlink" title="第二节 锁"></a><strong>第二节 锁</strong></h2><h3 id="2-1-锁"><a href="#2-1-锁" class="headerlink" title="2.1 锁"></a><strong>2.1 锁</strong></h3><h4 id="问：讲讲你知道的锁？锁的几种特性？"><a href="#问：讲讲你知道的锁？锁的几种特性？" class="headerlink" title="问：讲讲你知道的锁？锁的几种特性？"></a><strong>问：讲讲你知道的锁？锁的几种特性？</strong></h4><details><br><br><em> 独占/排他与共享：独占/排他即同一时刻只能有一个线程获取到锁，而其他获取锁的线程只能处于同步队列中等待，只有获取锁的线程释放了锁，后继的线程才能够获取锁。共享则表示同一时刻多个线程可以同时访问。
</em> 公平与非公平：先对锁进行获取请求的线程一定先被满足，这是公平锁；反之则是非公平锁。<br>* 可重入：支持重进入，表示锁能够支持一个线程对资源重复加锁。<br><br></details>

<h4 id="问：公平锁与非公平锁？"><a href="#问：公平锁与非公平锁？" class="headerlink" title="问：公平锁与非公平锁？"></a><strong>问：公平锁与非公平锁？</strong></h4><details><br><br>1. 公平锁指在分配锁前检查是否有线程在排队等待获取该锁，优先分配排队时间最长的线程，非公平直接尝试获取锁 。<br>2. 公平锁需多维护一个锁线程队列，大量的线程切换，效率低；默认非公平。<br><br></details>

<h4 id="问：独占锁与共享锁？"><a href="#问：独占锁与共享锁？" class="headerlink" title="问：独占锁与共享锁？"></a><strong>问：独占锁与共享锁？</strong></h4><details><br><br>1. ReentrantLock为独占锁（悲观加锁策略） 。<br>2. ReentrantReadWriteLock中读锁为共享锁，写锁为独占锁。<br>3. JDK1.8 邮戳锁（StampedLock）， 不可重入锁读的过程中也允许获取写锁后写入。这样一来，我们读的数据就可能不一致，所以，需要一点额外的代码来判断读的过程中是否有写入，这种读锁是一种乐观锁， 乐观锁的并发效率更高，但一旦有小概率的写入导致读取的数据不一致，需要能检测出来，再读一遍就行。<br><br></details>

<h4 id="问：可重入锁概念？"><a href="#问：可重入锁概念？" class="headerlink" title="问：可重入锁概念？"></a><strong>问：可重入锁概念？</strong></h4><details><br><br><br>1. 可重入锁是指同一个线程可以多次获取同一把锁，不会因为之前已经获取过还没释放而阻塞；<br>2. ReentrantLock、ReentrantReadWriteLock和synchronized都是可重入锁。<br>3. 可重入锁的一个优点是可一定程度避免死锁。<br><br></details>

<h4 id="问：讲讲4种锁状态？"><a href="#问：讲讲4种锁状态？" class="headerlink" title="问：讲讲4种锁状态？"></a><strong>问：讲讲4种锁状态？</strong></h4><details><br><br>即重量级锁的四种状态，为了提高效率，尽量避免使用重量级锁：<br><br><em> <strong>无锁</strong>：是否偏向-0，锁标志-01。
</em> <strong>偏向锁</strong>：是否偏向-1，锁标志-01。会偏向第一个访问锁的线程，当一个线程访问同步代码块获得锁时，会在对象头和栈帧记录里存储锁偏向的线程ID，当这个线程再次进入同步代码块时，就不需要CAS操作来加锁了，只要测试一下对象头里是否存储着指向当前线程的偏向锁，如果偏向锁未启动，new出的对象是普通对象（即无锁，有稍微竞争会成轻量级锁），如果启动，new出的对象是匿名偏向（偏向锁） 对象头主要包括两部分数据：Mark Word（标记字段， 存储对象自身的运行时数据）、class Pointer（类型指针， 是对象指向它的类元数据的指针）。<br><em> <strong>轻量级锁</strong>（自旋锁） ：锁标志-00。<br>  1. 在把线程进行阻塞操作之前先让线程自旋等待一段时间，可能在等待期间其他线程已经解锁，这时就无需再让线程执行阻塞操作，避免了用户态到内核态的切换。（自适应自旋时间为一个线程上下文切换的时间）<br>  2. 在用自旋锁时有可能造成死锁，当递归调用时有可能造成死锁<br>  3. 自旋锁底层是通过指向线程栈中Lock Record的指针来实现的
</em> <strong>重量级锁</strong>：锁标志-10。<br><br></details>

<h4 id="问：轻量级锁与偏向锁的区别？"><a href="#问：轻量级锁与偏向锁的区别？" class="headerlink" title="问：轻量级锁与偏向锁的区别？"></a><strong>问：轻量级锁与偏向锁的区别？</strong></h4><details><br>1. 偏向锁对象头 <code>Mark Word</code> 中存放线程ID，轻量级锁则是栈帧中锁记录的指针。<br>2. 偏向锁是在无竞争场景下完全消除同步，连CAS也不执行；轻量级锁是通过CAS来避免进入开销较大的互斥操作。<br>3. 偏向锁遇到线程竞争会升级为轻量级锁，前者适用于只有一个线程访问同步块，后者则是线程竞争不激烈的场景。<br><br></details>

<h4 id="问：自旋锁升级到重量级锁条件？"><a href="#问：自旋锁升级到重量级锁条件？" class="headerlink" title="问：自旋锁升级到重量级锁条件？"></a><strong>问：自旋锁升级到重量级锁条件？</strong></h4><details><br>1. 某线程自旋次数超过10次；<br>2. 等待的自旋线程超过了系统core数的一半；<br><br></details>

<h4 id="问：讲讲读写锁？优点？实现方式？"><a href="#问：讲讲读写锁？优点？实现方式？" class="headerlink" title="问：讲讲读写锁？优点？实现方式？"></a><strong>问：讲讲读写锁？优点？实现方式？</strong></h4><details><br><br>读写锁即分离了读锁和写锁，同一时刻允许多个线程访问，提高了读操作间的并发性。<br><br>优点有：<br><em> 保证了读操作间的并发。
</em> 保证写操作对读操作的可见性。<br>* 简化读写交互场景的编程方式。<br><br>并发包中提供了读写锁 <code>ReentrantReanWriteLock</code> ，和ReentrantLock相似，同样基于AQS，但是读写锁是基于共享资源的，不是互斥，关键在于state的处理，读写锁把高16为记为读状态，低16位记为写状态，从而分开了读写操作，读读情况其实就是读锁重入，读写/写读/写写都是互斥的，只要判断低16位就好了。读状态是所有线程获取读锁次数的总和，每个线程各自的获取次数则存在ThreadLocal中。<br><br></details>

<h4 id="问：乐观锁和悲观锁的区别？优缺点？使用场景？JDK中涉及到乐观锁和悲观锁的内容？这两种锁在Java和MySQL分别是怎么实现的？MySql的悲观锁怎么防止并发？"><a href="#问：乐观锁和悲观锁的区别？优缺点？使用场景？JDK中涉及到乐观锁和悲观锁的内容？这两种锁在Java和MySQL分别是怎么实现的？MySql的悲观锁怎么防止并发？" class="headerlink" title="问：乐观锁和悲观锁的区别？优缺点？使用场景？JDK中涉及到乐观锁和悲观锁的内容？这两种锁在Java和MySQL分别是怎么实现的？MySql的悲观锁怎么防止并发？"></a><strong>问：乐观锁和悲观锁的区别？优缺点？使用场景？JDK中涉及到乐观锁和悲观锁的内容？这两种锁在Java和MySQL分别是怎么实现的？MySql的悲观锁怎么防止并发？</strong></h4><details><br>乐观锁和悲观锁的区别：如字面意思，乐观锁指总是假设最好的情况，每次操作都不会上锁，而是更新时判断是否在此期间有被其他线程修改；悲观锁则相反，总假设最坏的情况，共享资源每次只给一个线程使用。<br><br>优缺点：两种锁适用于不同的场景，当共享资源竞争激烈时，乐观锁产生大量的更新失败，导致一些操作会浪费CPU资源如自旋；而资源竞争不那么激烈时，悲观锁所要进行的线程阻塞切换、等待唤醒等需要额外浪费CPU资源。<br><br>使用场景：乐观锁常见于多读少写的应用场景；悲观锁被应用于传统关系型数据库，如行锁，表锁，读锁，写锁等，适用于多写少读的场景。<br><br>悲观锁实现方式：<br><br><em> JDK：<code>synchronized</code> ，<code>RetreentLock</code> 等。
</em> MySQL：行锁，表锁，读锁，写锁等<br><br>乐观锁实现方式：（CAS，版本号机制）<br><br><em> JDK：CAS，JVM中的CAS操作通过处理器提供的 <code>CMPXCHG</code> 指令来实现原子操作。
</em> MySQL：MVCC-多版本并发控制。<br><br>MySql的悲观锁怎么防止并发：TODO<br><br></details>

<h4 id="问：死锁产生的原因？如何预防？死锁的条件，怎么解除死锁，怎么观测死锁？"><a href="#问：死锁产生的原因？如何预防？死锁的条件，怎么解除死锁，怎么观测死锁？" class="headerlink" title="问：死锁产生的原因？如何预防？死锁的条件，怎么解除死锁，怎么观测死锁？"></a><strong>问：死锁产生的原因？如何预防？死锁的条件，怎么解除死锁，怎么观测死锁？</strong></h4><details><br>死锁产生的原因是线程之间相互等待，导致程序瘫痪。<br><br>如何预防死锁：一般是允许前三个必要条件，通过合理的分配算法确保不会形成封闭等待链。<br><br>死锁产生有四个必要条件：<br><br>1. 互斥条件：资源同时只能被一个线程占有，线程间互斥等待。<br>2. 不可剥夺条件：线程获得资源后不能被夺走，只能主动释放。<br>3. 请求和保持条件：线程请求的资源被其他线程占据，此线程被阻塞但不会释放已有的资源。<br>4. 循环等待条件：存在线程间的循环等待链路，前一个线程请求资源被下个线程持有。<br><br>处理死锁的方法：<br><br>1. 避免一个线程同时获得多个锁。<br>2. 避免一个线程在锁内同时占用多个资源，尽量保证每个锁只占用一个资源。<br>3. 尝试使用定时锁，使用 <code>lock.tryLock(timeout)</code> 来代替内部锁机制。<br>4. 对于数据库锁，加锁和解锁必须在同一个数据库连接里，避免解锁失败情况。<br><br>检测死锁的方法：<br><br><em> 通过JStack工具生成JVM当前的线程快照，通过线程快照定位线程停顿的原因，死锁一般是因为线程互相等待对方持有的对象。
</em> 通过JConsole监控工具，检测线程死锁。<br><br><br></details>

<h4 id="问：加锁会带来哪些性能问题。如何解决？"><a href="#问：加锁会带来哪些性能问题。如何解决？" class="headerlink" title="问：加锁会带来哪些性能问题。如何解决？"></a><strong>问：加锁会带来哪些性能问题。如何解决？</strong></h4><details><br>锁的开销来自于三部分：<br><br>1. 上下文切换，<strong>挂起当前线程</strong>（存储当前上下文），<strong>恢复一个线程</strong>（找到一个合适的上下文并恢复到寄存器），<strong>跳转到程序计数器指向的位置</strong>（即线程被中断时的代码行）。<br>2. 调度器开销，唤醒或休眠线程。<br>3. 多核环境的跨处理器调度开销。<br><br>如何解决这些性能开销：<br><br>1. 减少线程切换，如通过CAS尝试短时间内请求锁的自旋锁。<br>2. 减少锁的冲突次数，比如读写锁分离，哈希表分段加锁等。<br>3. 在较少竞争的环境下尽量避免使用锁，如 <code>synchronized</code> 对锁分等级，CAS + volatile 等<br><br><br></details>

<h4 id="问：偏向锁、轻量级锁、自旋锁等优化？"><a href="#问：偏向锁、轻量级锁、自旋锁等优化？" class="headerlink" title="问：偏向锁、轻量级锁、自旋锁等优化？"></a><strong>问：偏向锁、轻量级锁、自旋锁等优化？</strong></h4><details><br><br><br><br></details>

<h4 id="问：事务有哪些特性？"><a href="#问：事务有哪些特性？" class="headerlink" title="问：事务有哪些特性？"></a><strong>问：事务有哪些特性？</strong></h4><details><br><br><br><br></details>

<h4 id="问：怎么理解原子性？"><a href="#问：怎么理解原子性？" class="headerlink" title="问：怎么理解原子性？"></a><strong>问：怎么理解原子性？</strong></h4><details><br><br><br><br></details>

<hr>
<h3 id="2-2-volatile"><a href="#2-2-volatile" class="headerlink" title="2.2 volatile"></a><strong>2.2 volatile</strong></h3><h4 id="问：volatile的作用是什么？可见性？volatile-的实现原理？"><a href="#问：volatile的作用是什么？可见性？volatile-的实现原理？" class="headerlink" title="问：volatile的作用是什么？可见性？volatile 的实现原理？"></a><strong>问：volatile的作用是什么？可见性？volatile 的实现原理？</strong></h4><details><br><br>volatile变量<br>（1）：变量可见性<br><br>（2）：防止指令重排序<br><br>（3）：保障变量单次读，写操作的原子性，但不能保证i++这种操作的原子性，因为本质是读，写两次操作<br><br></details>

<h4 id="问：volatile-的实现原理？及内存屏障相关？"><a href="#问：volatile-的实现原理？及内存屏障相关？" class="headerlink" title="问：volatile 的实现原理？及内存屏障相关？"></a><strong>问：volatile 的实现原理？及内存屏障相关？</strong></h4><details><br><br><br><br></details>

<h4 id="问：volatile如何保证线程间可见和避免指令重排？"><a href="#问：volatile如何保证线程间可见和避免指令重排？" class="headerlink" title="问：volatile如何保证线程间可见和避免指令重排？"></a><strong>问：volatile如何保证线程间可见和避免指令重排？</strong></h4><details><br><br>volatile可见性是有指令原子性保证的，在jmm中定义了8类原子性指令，比如write，store，read，load。而volatile就要求write-store，load-read成为一个原子性操作，这样子可以确保在读取的时候都是从主内存读入，写入的时候会同步到主内存中（准确来说也是内存屏障），指令重排则是由内存屏障来保证的，由两个内存屏障:<br><br>&gt; <em> 一个是编译器屏障：阻止编译器重排，保证编译程序时在优化屏障之前的指令不会在优化屏障之后执行。<br>&gt; </em> 第二个是cpu屏障：sfence保证写入，lfence保证读取，lock类似于锁的方式。java多执行了一个“load addl $0x0, (%esp)”操作，这个操作相当于一个lock指令，就是增加一个完全的内存屏障指令。<br><br></details>

<hr>
<h3 id="2-3-synchronized"><a href="#2-3-synchronized" class="headerlink" title="2.3 synchronized"></a><strong>2.3 synchronized</strong></h3><h4 id="问：synchronized-使用方式及实现原理，以及锁优化？"><a href="#问：synchronized-使用方式及实现原理，以及锁优化？" class="headerlink" title="问：synchronized 使用方式及实现原理，以及锁优化？"></a><strong>问：synchronized 使用方式及实现原理，以及锁优化？</strong></h4><details><br><br>synchronized实现原理？<br><br>contentionList（请求锁线程队列） entryList（有资格的候选者队列） waitSet（wait方法后阻塞队列） onDeck（竞争候选者） ower（竞争到锁线程） !ower（执行成功释放锁后状态）； Synchronized 是非公平锁。<br><br>Synchronized 在线程进入 ContentionList 时，等待的线程会先尝试自旋获取锁，如果获取不到就进入 ContentionList，这明显对于已经进入队列的线程是不公平的，还有一个不公平的事情就是自旋获取锁的线程还可能直接抢占 OnDeck 线程的锁资源。<br><br>底层是由一对monitorenter和monitorexit指令实现的（监视器锁）<br><br>每个对象有一个监视器锁（monitor）。当monitor被占用时就会处于锁定状态，线程执行monitorenter指令时尝试获取monitor的所有权，过程：<br><br>&gt; <em> 如果monitor的进入数为0，则该线程进入monitor，然后将进入数设置为1，该线程即为monitor的所有者。<br>&gt; </em> 如果线程已经占有该monitor，只是重新进入，则进入monitor的进入数加1.<br>&gt; * 如果其他线程已经占用了monitor，则该线程进入阻塞状态，直到monitor的进入数为0，再重新尝试获取monitor的所有权。<br><br></details>

<h4 id="问：synchronized-在静态方法和普通方法的区别？"><a href="#问：synchronized-在静态方法和普通方法的区别？" class="headerlink" title="问：synchronized 在静态方法和普通方法的区别？"></a><strong>问：synchronized 在静态方法和普通方法的区别？</strong></h4><details><br><br><br><br></details>

<h4 id="问：synchronized-和-ReentranLock的区别？"><a href="#问：synchronized-和-ReentranLock的区别？" class="headerlink" title="问：synchronized 和 ReentranLock的区别？"></a><strong>问：synchronized 和 ReentranLock的区别？</strong></h4><details><br><br>&gt; <em> 都是可重入锁； R是显示获取和释放锁，s是隐式；<br>&gt; </em> R更灵活可以知道有没有成功获取锁，可以定义读写锁，是api级别，s是JVM级别；<br>&gt; * R可以定义公平锁；Lock是接口，s是java中的关键字<br><br></details>

<h4 id="问：synchronized-和-lock-有什么区别？"><a href="#问：synchronized-和-lock-有什么区别？" class="headerlink" title="问：synchronized 和 lock 有什么区别？"></a><strong>问：synchronized 和 lock 有什么区别？</strong></h4><details><br><br><br></details>

<h4 id="问：HashTable，同步锁，synchronized-关键字-1-6-之后提升了什么，怎么提升的这些？"><a href="#问：HashTable，同步锁，synchronized-关键字-1-6-之后提升了什么，怎么提升的这些？" class="headerlink" title="问：HashTable，同步锁，synchronized 关键字 1.6 之后提升了什么，怎么提升的这些？"></a><strong>问：HashTable，同步锁，synchronized 关键字 1.6 之后提升了什么，怎么提升的这些？</strong></h4><details><br><br><br></details>

<hr>
<h3 id="2-4-Lock"><a href="#2-4-Lock" class="headerlink" title="2.4 Lock"></a><strong>2.4 Lock</strong></h3><h4 id="问：Lock-接口有哪些实现类，使用场景是什么？"><a href="#问：Lock-接口有哪些实现类，使用场景是什么？" class="headerlink" title="问：Lock 接口有哪些实现类，使用场景是什么？"></a><strong>问：Lock 接口有哪些实现类，使用场景是什么？</strong></h4><details><br><br><br><br></details>

<h4 id="问：讲讲ReentrantLock实现原理？"><a href="#问：讲讲ReentrantLock实现原理？" class="headerlink" title="问：讲讲ReentrantLock实现原理？"></a><strong>问：讲讲ReentrantLock实现原理？</strong></h4><details><br><br>ReentrantLock原理（CAS+AQS）<br><br>CAS+AQS队列来实现<br>（1）：先通过CAS尝试获取锁， 如果此时已经有线程占据了锁，那就加入AQS队列并且被挂起；<br><br>（2）： 当锁被释放之后， 排在队首的线程会被唤醒CAS再次尝试获取锁，<br><br>（3）：如果是非公平锁， 同时还有另一个线程进来尝试获取可能会让这个线程抢到锁；<br><br>（4）：如果是公平锁， 会排到队尾，由队首的线程获取到锁。<br><br></details>

<h4 id="问：ReentrantLock-是如何实现可重入性的-？"><a href="#问：ReentrantLock-是如何实现可重入性的-？" class="headerlink" title="问：ReentrantLock 是如何实现可重入性的 ？"></a><strong>问：ReentrantLock 是如何实现可重入性的 ？</strong></h4><details><br><br>内部自定义了同步器 Sync，加锁的时候通过CAS 算法 ，将线程对象放到一个双向链表 中，每次获取锁的时候 ，看下当前维 护的那个线程ID和当前请求的线程ID是否一样，一样就可重入了；<br><br></details>

<h4 id="问：ReentrantLock如何避免死锁"><a href="#问：ReentrantLock如何避免死锁" class="headerlink" title="问：ReentrantLock如何避免死锁?"></a><strong>问：ReentrantLock如何避免死锁?</strong></h4><details><br><br>&gt; <em> 响应中断lockInterruptibly（）<br>&gt; </em> 可轮询锁tryLock（）<br>&gt; * 定时锁tryLock（long time）<br><br></details>

<h4 id="问：tryLock-和-lock-和-lockInterruptibly-的区别"><a href="#问：tryLock-和-lock-和-lockInterruptibly-的区别" class="headerlink" title="问：tryLock 和 lock 和 lockInterruptibly 的区别?"></a><strong>问：tryLock 和 lock 和 lockInterruptibly 的区别?</strong></h4><details><br><br>（1）：tryLock 能获得锁就返回 true，不能就立即返回 false，<br><br>（2）：tryLock（long timeout，TimeUnit unit），可以增加时间限制，如果超过该时间段还没获得锁，返回 false<br><br>（3）：lock 能获得锁就返回 true，不能的话一直等待获得锁<br><br>（4）：lock 和 lockInterruptibly，如果两个线程分别执行这两个方法，但此时中断这两个线程， lock 不会抛出异常，而 lockInterruptibly 会抛出异常。<br><br></details>

<hr>
<h3 id="2-5-Condition"><a href="#2-5-Condition" class="headerlink" title="2.5 Condition"></a><strong>2.5 Condition</strong></h3><h4 id="问：讲一下Condition？"><a href="#问：讲一下Condition？" class="headerlink" title="问：讲一下Condition？"></a><strong>问：讲一下Condition？</strong></h4><details><br><br>Condition接口主要是和Lock配合实现等待通知模式，类似于对象监视器方法和synchronized的组合。其定义了一系列等待和唤醒方法，Condition对象依赖于Lock对象，一个Condition包含一个等待队列，Condition拥有首节点（firstWaiter）和尾节点（lastWaiter）。等待时将节点从同步队列移动到等待队列，需要把当前线程构建成一个新的等待结点。通知时则不需要新建节点，可以看作直接把等待节点移动到同步队列。<br><br></details>

<h4 id="问：对象监视器方法和Condition的异同-？"><a href="#问：对象监视器方法和Condition的异同-？" class="headerlink" title="问：对象监视器方法和Condition的异同 ？"></a><strong>问：对象监视器方法和Condition的异同 ？</strong></h4><details><br><br><strong>任意一个Java对象，都拥有一组监视器方法</strong>（定义在 <code>java.lang.Object</code> 上），主要包括 <code>wait()</code> 、<code>wait(long timeout)</code> 、<code>notify()</code> 以及 <code>notifyAll()</code> 方法，这些方法与 <code>synchronized</code> 同步关键字配合，可以实现<strong>等待/通知模式</strong>。<br><br><code>Condition</code> 接口也提供了类似 <code>Object</code> 的监视器方法，与Lock配合可以实现<strong>等待/通知模式</strong>，但是这两者在使用方式以及功能特性上还是有差别的。<br><br><img src="https://pic-1258215793.cos.ap-shanghai.myqcloud.com/content/20190601/201906010120.png" alt="Object的监视器方法与Condition接口的对比"><br><br></details>

<hr>
<h3 id="2-6-AQS"><a href="#2-6-AQS" class="headerlink" title="2.6 AQS"></a><strong>2.6 AQS</strong></h3><h4 id="问：讲讲AQS？实现原理？讲讲AQS怎么实现的Fair和NoFair？"><a href="#问：讲讲AQS？实现原理？讲讲AQS怎么实现的Fair和NoFair？" class="headerlink" title="问：讲讲AQS？实现原理？讲讲AQS怎么实现的Fair和NoFair？"></a><strong>问：讲讲AQS？实现原理？讲讲AQS怎么实现的Fair和NoFair？</strong></h4><details><br><br>AQS即队列同步器（AbstractQueuedSynchronizer），是构建锁和其他同步组件的基础框架，锁是面向使用者的，同步器则是面向锁的实现者。<br><br>实现原理：AQS底层是一个双向链表实现的FIFO同步队列，通过整型成员变量state来判断锁的同步状态，基于模板方法模式来设计，包含独占式和共享式的获取同步状态，各种锁自定义实现AQS。<br><br>对于非可重入锁状态不是0则去阻塞；对于可重入锁如果是0则执行，非0则判断当前线程是否是获取到这个锁的线程，是的话把state状态＋1，比如重入5次，那么state=5。 而在释放锁的时候，同样需要释放5次直到state=0其他线程才有资格获得锁。<br><br></details>

<h4 id="问：AQS两种资源共享方式？"><a href="#问：AQS两种资源共享方式？" class="headerlink" title="问：AQS两种资源共享方式？"></a><strong>问：AQS两种资源共享方式？</strong></h4><details><br><br><em> Exclusive：独占，只有一个线程能执行，如ReentrantLock。
</em> Share：共享，多个线程可以同时执行，如Semaphore、CountDownLatch、ReadWriteLock，CyclicBarrier。<br><br></details>

<h4 id="问：CAS了解么？-CAS-有什么缺陷，如何解决？还了解其他同步机制么？"><a href="#问：CAS了解么？-CAS-有什么缺陷，如何解决？还了解其他同步机制么？" class="headerlink" title="问：CAS了解么？ CAS 有什么缺陷，如何解决？还了解其他同步机制么？"></a><strong>问：CAS了解么？ CAS 有什么缺陷，如何解决？还了解其他同步机制么？</strong></h4><details><br><br>CAS，Compare and Set，比较并交换，常用来实现乐观锁。<br><br>实现原理：内存值，预期值，修改的新值，当内存值等于预期值时，将内存值修改为新值，否则什么都不做。<br><br>CAS的缺陷有三个：<br><br>1. ABA问题，即A变为B再变为A也能满足判断条件。<br>2. 如果CAS失败，自旋会给CPU带来压力，死循环。<br>3. 只能保证对一个变量的原子性操作。<br><br>解决方案分别是：<br><br>1. 引入版本号或修改次数，1A-&gt;2B-&gt;3A。<br>2. 使用JVM提供的pause指令。<br>3. 用锁将多个共享变量合并为一个来操作，使用 <code>AtomicReference</code> 类来保证引用对象之间的原子性，就可以把多个变量放在一个对象里来进行CAS操作。<br><br>CAS在java中的应用：<br>（1）：Atomic系列<br><br>还有信号量机制，自旋锁等。<br><br></details>

<h4 id="问：CAS和synchronized有什么区别？都用synchronized不行么？"><a href="#问：CAS和synchronized有什么区别？都用synchronized不行么？" class="headerlink" title="问：CAS和synchronized有什么区别？都用synchronized不行么？"></a><strong>问：CAS和synchronized有什么区别？都用synchronized不行么？</strong></h4><details><br><br>synchronized是获取对象锁，属于重量级锁，虽然有进行优化，但还是有一定的性能开销。CAS则并未利用锁，其机制比较适合读多写少的场景。<br><br>如果都采用synchronized，在并发编程时不能获得令人满意的执行效率。<br><br><br></details>

<hr>
<h3 id="2-7-CountDownLatch"><a href="#2-7-CountDownLatch" class="headerlink" title="2.7 CountDownLatch"></a><strong>2.7 CountDownLatch</strong></h3><h4 id="问：用过CountDownLatch么？什么场景下用的？"><a href="#问：用过CountDownLatch么？什么场景下用的？" class="headerlink" title="问：用过CountDownLatch么？什么场景下用的？"></a><strong>问：用过CountDownLatch么？什么场景下用的？</strong></h4><details><br><br><br><br></details>

<h4 id="问：什么是信号量Semaphore？应用场景？"><a href="#问：什么是信号量Semaphore？应用场景？" class="headerlink" title="问：什么是信号量Semaphore？应用场景？"></a><strong>问：什么是信号量Semaphore？应用场景？</strong></h4><details><br><br>信号量是一种固定资源的限制的一种并发工具包，基于AQS实现的，在构造的时候会设置一个值，代表着资源数量。信号量主要是应用于是用于多个共享资源的互斥使用，和用于并发线程数的控制（druid的数据库连接数，就是用这个实现的），信号量也分公平和非公平的情况，基本方式和reentrantLock差不多，在请求资源调用task时，会用自旋的方式减1，如果成功，则获取成功了，如果失败，导致资源数变为了0，就会加入队列里面去等待。调用release的时候会加一，补充资源,并唤醒等待队列。<br><br>&gt;Semaphore 应用<br>&gt; <em> acquire（） release（） 可用于对象池，资源池的构建，比如静态全局对象池，数据库连接池；<br>&gt; </em> 可创建计数为1的S，作为互斥锁（二元信号量）<br><br></details>

<h4 id="问：用过CyclicBarrier吗？-和-countdownlatch-的区别？"><a href="#问：用过CyclicBarrier吗？-和-countdownlatch-的区别？" class="headerlink" title="问：用过CyclicBarrier吗？ 和 countdownlatch 的区别？"></a><strong>问：用过CyclicBarrier吗？ 和 countdownlatch 的区别？</strong></h4><details><br><br>个人理解 赛马和点火箭<br><br>&gt; <em> con用于主线程等待其他子线程任务都执行完毕后再执行，cyc用于一组线程相互等待大家都达到某个状态后，再同时执行；<br>&gt; </em> CountDownLatch是不可重用的，CyclicBarrier可重用<br><br>CountDownLatch是等待其他线程执行到某一个点的时候，在继续执行逻辑（子线程不会被阻塞，会继续执行），只能被使用一次。最常见的就是join形式，主线程等待子线程执行完任务，在用主线程去获取结果的方式（当然不一定），内部是用计数器相减实现的（没错，又特么是AQS），AQS的state承担了计数器的作用，初始化的时候，使用CAS赋值，主线程调用await（）则被加入共享线程等待队列里面，子线程调用countDown的时候，使用自旋的方式，减1，知道为0，就触发唤醒。<br><br>CyclicBarrier回环屏障，主要是等待一组线程到底同一个状态的时候，放闸。CyclicBarrier还可以传递一个Runnable对象，可以到放闸的时候，执行这个任务。CyclicBarrier是可循环的，当调用await的时候如果count变成0了则会重置状态，如何重置呢，CyclicBarrier新增了一个字段parties，用来保存初始值，当count变为0的时候，就重新赋值。还有一个不同点，CyclicBarrier不是基于AQS的，而是基于RentrantLock实现的。存放的等待队列是用了条件变量的方式。<br><br></details>

<hr>
<h3 id="2-8-锁的应用"><a href="#2-8-锁的应用" class="headerlink" title="2.8 锁的应用"></a><strong>2.8 锁的应用</strong></h3><h4 id="问：ConcurrentHashMap的get需要加锁么，为什么？"><a href="#问：ConcurrentHashMap的get需要加锁么，为什么？" class="headerlink" title="问：ConcurrentHashMap的get需要加锁么，为什么？"></a><strong>问：ConcurrentHashMap的get需要加锁么，为什么？</strong></h4><details><br><br><br><br></details>

<h4 id="问：Hashtable-是怎么加锁的-？"><a href="#问：Hashtable-是怎么加锁的-？" class="headerlink" title="问：Hashtable 是怎么加锁的 ？"></a><strong>问：Hashtable 是怎么加锁的 ？</strong></h4><details><br><br><br><br></details>

<hr>
<h2 id="第三节-未整理"><a href="#第三节-未整理" class="headerlink" title="第三节 未整理"></a><strong>第三节 未整理</strong></h2><hr>
<blockquote>
<p><a href="https://zhuanlan.zhihu.com/p/138951555" target="_blank" rel="noopener">后端面试的所有知识点</a></p>
</blockquote>
<p><em>参考内容均来自网络中网友分享，若内容涉及侵权请及时告知，我会尽快修改和删除相关内容</em></p>

      
    </div>
    
    
    

    

    

    

    
      <div>
         ﻿<div>
    
        <div style="text-align:center;color: #ccc;font-size:14px;">-------------本文结束<i class="fa fa-paw"></i>感谢您的阅读-------------</div>
    
</div>

      </div>
    
    
    <footer class="post-footer">
      
        <div class="post-tags">
          
            <a href="/tags/Q-A/" rel="tag"># Q&A</a>
          
            <a href="/tags/updating/" rel="tag"># updating</a>
          
        </div>
      

      
      
      

      
        <div class="post-nav">
          <div class="post-nav-next post-nav-item">
            
              <a href="/2019102101.html" rel="next" title="面试整理——Java集合">
                <i class="fa fa-chevron-left"></i> 面试整理——Java集合
              </a>
            
          </div>

          <span class="post-nav-divider"></span>

          <div class="post-nav-prev post-nav-item">
            
              <a href="/2019102301.html" rel="prev" title="面试整理——Java网络编程">
                面试整理——Java网络编程 <i class="fa fa-chevron-right"></i>
              </a>
            
          </div>
        </div>
      

      
      
    </footer>
  </div>
  
  
  
  </article>



    <div class="post-spread">
      
    </div>
  </div>


          </div>
          


          

  
     <div class="comments" id="comments">
       

<script src="https://utteranc.es/client.js" repo="LAILAIWA/LAILAIWA.github.io" issue-term="pathname" label="💬Comments" theme="github-light" crossorigin="anonymous" async>
</script>



     </div>
  



        </div>
        
          
  
  <div class="sidebar-toggle">
    <div class="sidebar-toggle-line-wrap">
      <span class="sidebar-toggle-line sidebar-toggle-line-first"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-middle"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-last"></span>
    </div>
  </div>

  <aside id="sidebar" class="sidebar">
    
    <div class="sidebar-inner">

      

      
        <ul class="sidebar-nav motion-element">
          <li class="sidebar-nav-toc sidebar-nav-active" data-target="post-toc-wrap">
            文章目录
          </li>
          <li class="sidebar-nav-overview" data-target="site-overview-wrap">
            站点概览
          </li>
        </ul>
      

      <section class="site-overview-wrap sidebar-panel">
        <div class="site-overview">
          <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
            
              <img class="site-author-image" itemprop="image" src="https://pic-1258215793.cos.ap-shanghai.myqcloud.com/cover/riho_yoshioka1.jpg" alt="Speciosity">
            
              <p class="site-author-name" itemprop="name">Speciosity</p>
              <p class="site-description motion-element" itemprop="description">记录编程点滴，写点生活中的酸甜</p>
          </div>

          <nav class="site-state motion-element">

            
              <div class="site-state-item site-state-posts">
              
                <a href="/archives/">
              
                  <span class="site-state-item-count">276</span>
                  <span class="site-state-item-name">日志</span>
                </a>
              </div>
            

            
              
              
              <div class="site-state-item site-state-categories">
                <a href="/categories/index.html">
                  <span class="site-state-item-count">8</span>
                  <span class="site-state-item-name">分类</span>
                </a>
              </div>
            

            
              
              
              <div class="site-state-item site-state-tags">
                <a href="/tags/index.html">
                  <span class="site-state-item-count">92</span>
                  <span class="site-state-item-name">标签</span>
                </a>
              </div>
            

          </nav>

          
            <div class="feed-link motion-element">
              <a href="/atom.xml" rel="alternate">
                <i class="fa fa-rss"></i>
                RSS
              </a>
            </div>
          

          
            <div class="links-of-author motion-element">
                
                  <span class="links-of-author-item">
                    <a href="https://github.com/LAILAIWA" target="_blank" title="GitHub">
                      
                        <i class="fa fa-fw fa-github"></i>GitHub</a>
                  </span>
                
                  <span class="links-of-author-item">
                    <a href="mailto:linyishui168@outlook.com" target="_blank" title="E-Mail">
                      
                        <i class="fa fa-fw fa-envelope"></i>E-Mail</a>
                  </span>
                
                  <span class="links-of-author-item">
                    <a href="https://twitter.com/linyishui618" target="_blank" title="Twitter">
                      
                        <i class="fa fa-fw fa-twitter"></i>Twitter</a>
                  </span>
                
                  <span class="links-of-author-item">
                    <a href="https://instagram.com/linyishui618" target="_blank" title="Instagram">
                      
                        <i class="fa fa-fw fa-instagram"></i>Instagram</a>
                  </span>
                
                  <span class="links-of-author-item">
                    <a href="https://weibo.com/u/5340162234" target="_blank" title="Weibo">
                      
                        <i class="fa fa-fw fa-weibo.com"></i>Weibo</a>
                  </span>
                
            </div>
          

          
          

          
          

          <div id="days"></div>
<script>
function show_date_time(){
    window.setTimeout("show_date_time()", 1000);
    BirthDay=new Date("07/26/2018 00:00:00");
    today=new Date();
    timeold=(today.getTime()-BirthDay.getTime());
    sectimeold=timeold/1000
    secondsold=Math.floor(sectimeold);
    msPerDay=24*60*60*1000
    e_daysold=timeold/msPerDay
    daysold=Math.floor(e_daysold);
    e_hrsold=(e_daysold-daysold)*24;
    hrsold=setzero(Math.floor(e_hrsold));
    e_minsold=(e_hrsold-hrsold)*60;
    minsold=setzero(Math.floor((e_hrsold-hrsold)*60));
    seconds=setzero(Math.floor((e_minsold-minsold)*60));
    document.getElementById('days').innerHTML="已运行 "+daysold+" 天 "+hrsold+" 小时 "+minsold+" 分 "+seconds+" 秒";
}
function setzero(i) {
    if (i<10) {
        i="0" + i
    };
    return i;
}
show_date_time();
</script>  
        </div>
      </section>

      
      <!--noindex-->
        <section class="post-toc-wrap motion-element sidebar-panel sidebar-panel-active">
          <div class="post-toc">

            
              
            

            
              <div class="post-toc-content"><ol class="nav"><li class="nav-item nav-level-1"><a class="nav-link" href="#Java并发编程"><span class="nav-number">1.</span> <span class="nav-text">Java并发编程</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#第一节-多线程"><span class="nav-number">1.1.</span> <span class="nav-text">第一节 多线程</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#1-1-线程"><span class="nav-number">1.1.1.</span> <span class="nav-text">1.1 线程</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#问：什么时候用线程？"><span class="nav-number">1.1.1.1.</span> <span class="nav-text">问：什么时候用线程？</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#问：创建多线程的方式，以及线程的状态转换？"><span class="nav-number">1.1.1.2.</span> <span class="nav-text">问：创建多线程的方式，以及线程的状态转换？</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#问：终止线程的方法？"><span class="nav-number">1.1.1.3.</span> <span class="nav-text">问：终止线程的方法？</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#问：谈一下线程切换，并引申到Java阻塞，运行？"><span class="nav-number">1.1.1.4.</span> <span class="nav-text">问：谈一下线程切换，并引申到Java阻塞，运行？</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#问：线程的中断机制？"><span class="nav-number">1.1.1.5.</span> <span class="nav-text">问：线程的中断机制？</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#问：怎么实现所有线程在等待某个事件的发生才会去执行？"><span class="nav-number">1.1.1.6.</span> <span class="nav-text">问：怎么实现所有线程在等待某个事件的发生才会去执行？</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#问：如何实现控制线程在某段时间内完成，不完成就撤销？"><span class="nav-number">1.1.1.7.</span> <span class="nav-text">问：如何实现控制线程在某段时间内完成，不完成就撤销？</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#问：线程回调？"><span class="nav-number">1.1.1.8.</span> <span class="nav-text">问：线程回调？</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#问：RPC-框架？设计一个-RPC，怎么实现"><span class="nav-number">1.1.1.9.</span> <span class="nav-text">问：RPC 框架？设计一个 RPC，怎么实现</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#问：线程间的通信可以怎么做？线程间相互通知你会怎么做，代码要怎么实现？"><span class="nav-number">1.1.1.10.</span> <span class="nav-text">问：线程间的通信可以怎么做？线程间相互通知你会怎么做，代码要怎么实现？</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#1-2-ThreadLocal"><span class="nav-number">1.1.2.</span> <span class="nav-text">1.2 ThreadLocal</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#问：谈一下ThreadLocal？应用场景？原理？与-Thread-类的关系？"><span class="nav-number">1.1.2.1.</span> <span class="nav-text">问：谈一下ThreadLocal？应用场景？原理？与 Thread 类的关系？</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#问：static-能不能修饰-ThreadLocal？"><span class="nav-number">1.1.2.2.</span> <span class="nav-text">问：static 能不能修饰 ThreadLocal？</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#问：谈一下ThreadLocal的内存泄漏问题？"><span class="nav-number">1.1.2.3.</span> <span class="nav-text">问：谈一下ThreadLocal的内存泄漏问题？</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#问：如果我们要获取父线程的ThreadLocal值呢？"><span class="nav-number">1.1.2.4.</span> <span class="nav-text">问：如果我们要获取父线程的ThreadLocal值呢？</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#1-3-Thread"><span class="nav-number">1.1.3.</span> <span class="nav-text">1.3 Thread</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#问：Thread类里有哪些常用方法？"><span class="nav-number">1.1.3.1.</span> <span class="nav-text">问：Thread类里有哪些常用方法？</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#问：interrupt-isInterrupted-interrupt区别？"><span class="nav-number">1.1.3.2.</span> <span class="nav-text">问：interrupt/isInterrupted/interrupt区别？</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#问：谈一下start和run方法的区别？"><span class="nav-number">1.1.3.3.</span> <span class="nav-text">问：谈一下start和run方法的区别？</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#问：sleep-和-wait-有什么区别？"><span class="nav-number">1.1.3.4.</span> <span class="nav-text">问：sleep 和 wait 有什么区别？</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#问：sleep-和-yeild-方法有什么区别？"><span class="nav-number">1.1.3.5.</span> <span class="nav-text">问：sleep 和 yeild 方法有什么区别？</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#1-4-线程池"><span class="nav-number">1.1.4.</span> <span class="nav-text">1.4 线程池</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#问：项目的用户量多吗？有用过线程池吗？用到多线程的优势在哪？"><span class="nav-number">1.1.4.1.</span> <span class="nav-text">问：项目的用户量多吗？有用过线程池吗？用到多线程的优势在哪？</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#问：ThreadPoolExecutor-初始化参数？"><span class="nav-number">1.1.4.2.</span> <span class="nav-text">问：ThreadPoolExecutor 初始化参数？</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#问：线程状态？"><span class="nav-number">1.1.4.3.</span> <span class="nav-text">问：线程状态？</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#问：corepoolSize-怎么设置，maxpoolsize-怎么设置，keep-alive-各种的？"><span class="nav-number">1.1.4.4.</span> <span class="nav-text">问：corepoolSize 怎么设置，maxpoolsize 怎么设置，keep-alive 各种的？</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#问：阻塞队列在生产中的设置？"><span class="nav-number">1.1.4.5.</span> <span class="nav-text">问：阻塞队列在生产中的设置？</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#问：Java中的线程池是如何实现的？讲一下线程池的原理？"><span class="nav-number">1.1.4.6.</span> <span class="nav-text">问：Java中的线程池是如何实现的？讲一下线程池的原理？</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#问：如果线程池中的一个线程运行时出现了异常，会发生什么？"><span class="nav-number">1.1.4.7.</span> <span class="nav-text">问：如果线程池中的一个线程运行时出现了异常，会发生什么？</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#问：讲一下线程池的原理？"><span class="nav-number">1.1.4.8.</span> <span class="nav-text">问：讲一下线程池的原理？</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#问：如何实现一个线程池，Java中线程池如何进行配置？线程池的线程数怎么确定？"><span class="nav-number">1.1.4.9.</span> <span class="nav-text">问：如何实现一个线程池，Java中线程池如何进行配置？线程池的线程数怎么确定？</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#问：如何实现一个线程池，Java中线程池如何进行配置？线程池的核心参数记得吗？线程池的工作流程记得吗？"><span class="nav-number">1.1.4.10.</span> <span class="nav-text">问：如何实现一个线程池，Java中线程池如何进行配置？线程池的核心参数记得吗？线程池的工作流程记得吗？</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#问：线程池里如何知道线程执行完了没有？线程阻塞怎么办？怎么保证所有线程执行完之后继续往下处理？怎么让一个线程等另一个线程执行结束？"><span class="nav-number">1.1.4.11.</span> <span class="nav-text">问：线程池里如何知道线程执行完了没有？线程阻塞怎么办？怎么保证所有线程执行完之后继续往下处理？怎么让一个线程等另一个线程执行结束？</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#问：Java-的信号灯？"><span class="nav-number">1.1.5.</span> <span class="nav-text">问：Java 的信号灯？</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#问：Executors-静态方法？"><span class="nav-number">1.1.5.1.</span> <span class="nav-text">问：Executors 静态方法？</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#问：拒绝策略？"><span class="nav-number">1.1.5.2.</span> <span class="nav-text">问：拒绝策略？</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#问：newFixedThreadPool-（固定数目线程的线程池）？"><span class="nav-number">1.1.5.3.</span> <span class="nav-text">问：newFixedThreadPool （固定数目线程的线程池）？</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#问：newCachedThreadPool（可缓存线程的线程池）？"><span class="nav-number">1.1.5.4.</span> <span class="nav-text">问：newCachedThreadPool（可缓存线程的线程池）？</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#问：newSingleThreadExecutor（单线程的线程池）？"><span class="nav-number">1.1.5.5.</span> <span class="nav-text">问：newSingleThreadExecutor（单线程的线程池）？</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#问：newScheduledThreadPool（定时及周期执行的线程池）？"><span class="nav-number">1.1.5.6.</span> <span class="nav-text">问：newScheduledThreadPool（定时及周期执行的线程池）？</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#1-5-线程安全"><span class="nav-number">1.1.6.</span> <span class="nav-text">1.5 线程安全</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#问：谈一下对线程安全的理解？用什么方法保证线程的安全？"><span class="nav-number">1.1.6.1.</span> <span class="nav-text">问：谈一下对线程安全的理解？用什么方法保证线程的安全？</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#问：如何线程安全的实现一个计数器？"><span class="nav-number">1.1.6.2.</span> <span class="nav-text">问：如何线程安全的实现一个计数器？</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#问：请写一个线程安全的单例模式？"><span class="nav-number">1.1.6.3.</span> <span class="nav-text">问：请写一个线程安全的单例模式？</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#问：单例模式，饿汉式，懒汉式，线程安全的做法，两次判断-instance-是否为空，每次判断的作用是什么？"><span class="nav-number">1.1.6.4.</span> <span class="nav-text">问：单例模式，饿汉式，懒汉式，线程安全的做法，两次判断 instance 是否为空，每次判断的作用是什么？</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#问：ABC-三个线程如何保证顺序执行？"><span class="nav-number">1.1.6.5.</span> <span class="nav-text">问：ABC 三个线程如何保证顺序执行？</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#问：生产者消费者模式的实现方式？"><span class="nav-number">1.1.6.6.</span> <span class="nav-text">问：生产者消费者模式的实现方式？</span></a></li></ol></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#第二节-锁"><span class="nav-number">1.2.</span> <span class="nav-text">第二节 锁</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#2-1-锁"><span class="nav-number">1.2.1.</span> <span class="nav-text">2.1 锁</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#问：讲讲你知道的锁？锁的几种特性？"><span class="nav-number">1.2.1.1.</span> <span class="nav-text">问：讲讲你知道的锁？锁的几种特性？</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#问：公平锁与非公平锁？"><span class="nav-number">1.2.1.2.</span> <span class="nav-text">问：公平锁与非公平锁？</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#问：独占锁与共享锁？"><span class="nav-number">1.2.1.3.</span> <span class="nav-text">问：独占锁与共享锁？</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#问：可重入锁概念？"><span class="nav-number">1.2.1.4.</span> <span class="nav-text">问：可重入锁概念？</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#问：讲讲4种锁状态？"><span class="nav-number">1.2.1.5.</span> <span class="nav-text">问：讲讲4种锁状态？</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#问：轻量级锁与偏向锁的区别？"><span class="nav-number">1.2.1.6.</span> <span class="nav-text">问：轻量级锁与偏向锁的区别？</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#问：自旋锁升级到重量级锁条件？"><span class="nav-number">1.2.1.7.</span> <span class="nav-text">问：自旋锁升级到重量级锁条件？</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#问：讲讲读写锁？优点？实现方式？"><span class="nav-number">1.2.1.8.</span> <span class="nav-text">问：讲讲读写锁？优点？实现方式？</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#问：乐观锁和悲观锁的区别？优缺点？使用场景？JDK中涉及到乐观锁和悲观锁的内容？这两种锁在Java和MySQL分别是怎么实现的？MySql的悲观锁怎么防止并发？"><span class="nav-number">1.2.1.9.</span> <span class="nav-text">问：乐观锁和悲观锁的区别？优缺点？使用场景？JDK中涉及到乐观锁和悲观锁的内容？这两种锁在Java和MySQL分别是怎么实现的？MySql的悲观锁怎么防止并发？</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#问：死锁产生的原因？如何预防？死锁的条件，怎么解除死锁，怎么观测死锁？"><span class="nav-number">1.2.1.10.</span> <span class="nav-text">问：死锁产生的原因？如何预防？死锁的条件，怎么解除死锁，怎么观测死锁？</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#问：加锁会带来哪些性能问题。如何解决？"><span class="nav-number">1.2.1.11.</span> <span class="nav-text">问：加锁会带来哪些性能问题。如何解决？</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#问：偏向锁、轻量级锁、自旋锁等优化？"><span class="nav-number">1.2.1.12.</span> <span class="nav-text">问：偏向锁、轻量级锁、自旋锁等优化？</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#问：事务有哪些特性？"><span class="nav-number">1.2.1.13.</span> <span class="nav-text">问：事务有哪些特性？</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#问：怎么理解原子性？"><span class="nav-number">1.2.1.14.</span> <span class="nav-text">问：怎么理解原子性？</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#2-2-volatile"><span class="nav-number">1.2.2.</span> <span class="nav-text">2.2 volatile</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#问：volatile的作用是什么？可见性？volatile-的实现原理？"><span class="nav-number">1.2.2.1.</span> <span class="nav-text">问：volatile的作用是什么？可见性？volatile 的实现原理？</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#问：volatile-的实现原理？及内存屏障相关？"><span class="nav-number">1.2.2.2.</span> <span class="nav-text">问：volatile 的实现原理？及内存屏障相关？</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#问：volatile如何保证线程间可见和避免指令重排？"><span class="nav-number">1.2.2.3.</span> <span class="nav-text">问：volatile如何保证线程间可见和避免指令重排？</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#2-3-synchronized"><span class="nav-number">1.2.3.</span> <span class="nav-text">2.3 synchronized</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#问：synchronized-使用方式及实现原理，以及锁优化？"><span class="nav-number">1.2.3.1.</span> <span class="nav-text">问：synchronized 使用方式及实现原理，以及锁优化？</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#问：synchronized-在静态方法和普通方法的区别？"><span class="nav-number">1.2.3.2.</span> <span class="nav-text">问：synchronized 在静态方法和普通方法的区别？</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#问：synchronized-和-ReentranLock的区别？"><span class="nav-number">1.2.3.3.</span> <span class="nav-text">问：synchronized 和 ReentranLock的区别？</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#问：synchronized-和-lock-有什么区别？"><span class="nav-number">1.2.3.4.</span> <span class="nav-text">问：synchronized 和 lock 有什么区别？</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#问：HashTable，同步锁，synchronized-关键字-1-6-之后提升了什么，怎么提升的这些？"><span class="nav-number">1.2.3.5.</span> <span class="nav-text">问：HashTable，同步锁，synchronized 关键字 1.6 之后提升了什么，怎么提升的这些？</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#2-4-Lock"><span class="nav-number">1.2.4.</span> <span class="nav-text">2.4 Lock</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#问：Lock-接口有哪些实现类，使用场景是什么？"><span class="nav-number">1.2.4.1.</span> <span class="nav-text">问：Lock 接口有哪些实现类，使用场景是什么？</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#问：讲讲ReentrantLock实现原理？"><span class="nav-number">1.2.4.2.</span> <span class="nav-text">问：讲讲ReentrantLock实现原理？</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#问：ReentrantLock-是如何实现可重入性的-？"><span class="nav-number">1.2.4.3.</span> <span class="nav-text">问：ReentrantLock 是如何实现可重入性的 ？</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#问：ReentrantLock如何避免死锁"><span class="nav-number">1.2.4.4.</span> <span class="nav-text">问：ReentrantLock如何避免死锁?</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#问：tryLock-和-lock-和-lockInterruptibly-的区别"><span class="nav-number">1.2.4.5.</span> <span class="nav-text">问：tryLock 和 lock 和 lockInterruptibly 的区别?</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#2-5-Condition"><span class="nav-number">1.2.5.</span> <span class="nav-text">2.5 Condition</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#问：讲一下Condition？"><span class="nav-number">1.2.5.1.</span> <span class="nav-text">问：讲一下Condition？</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#问：对象监视器方法和Condition的异同-？"><span class="nav-number">1.2.5.2.</span> <span class="nav-text">问：对象监视器方法和Condition的异同 ？</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#2-6-AQS"><span class="nav-number">1.2.6.</span> <span class="nav-text">2.6 AQS</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#问：讲讲AQS？实现原理？讲讲AQS怎么实现的Fair和NoFair？"><span class="nav-number">1.2.6.1.</span> <span class="nav-text">问：讲讲AQS？实现原理？讲讲AQS怎么实现的Fair和NoFair？</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#问：AQS两种资源共享方式？"><span class="nav-number">1.2.6.2.</span> <span class="nav-text">问：AQS两种资源共享方式？</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#问：CAS了解么？-CAS-有什么缺陷，如何解决？还了解其他同步机制么？"><span class="nav-number">1.2.6.3.</span> <span class="nav-text">问：CAS了解么？ CAS 有什么缺陷，如何解决？还了解其他同步机制么？</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#问：CAS和synchronized有什么区别？都用synchronized不行么？"><span class="nav-number">1.2.6.4.</span> <span class="nav-text">问：CAS和synchronized有什么区别？都用synchronized不行么？</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#2-7-CountDownLatch"><span class="nav-number">1.2.7.</span> <span class="nav-text">2.7 CountDownLatch</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#问：用过CountDownLatch么？什么场景下用的？"><span class="nav-number">1.2.7.1.</span> <span class="nav-text">问：用过CountDownLatch么？什么场景下用的？</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#问：什么是信号量Semaphore？应用场景？"><span class="nav-number">1.2.7.2.</span> <span class="nav-text">问：什么是信号量Semaphore？应用场景？</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#问：用过CyclicBarrier吗？-和-countdownlatch-的区别？"><span class="nav-number">1.2.7.3.</span> <span class="nav-text">问：用过CyclicBarrier吗？ 和 countdownlatch 的区别？</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#2-8-锁的应用"><span class="nav-number">1.2.8.</span> <span class="nav-text">2.8 锁的应用</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#问：ConcurrentHashMap的get需要加锁么，为什么？"><span class="nav-number">1.2.8.1.</span> <span class="nav-text">问：ConcurrentHashMap的get需要加锁么，为什么？</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#问：Hashtable-是怎么加锁的-？"><span class="nav-number">1.2.8.2.</span> <span class="nav-text">问：Hashtable 是怎么加锁的 ？</span></a></li></ol></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#第三节-未整理"><span class="nav-number">1.3.</span> <span class="nav-text">第三节 未整理</span></a></li></ol></li></ol></div>
            

          </div>
        </section>
      <!--/noindex-->
      

      

    </div>
  </aside>


        
      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="footer-inner">
        ﻿<div class="copyright">&copy; 2018 &mdash; <span itemprop="copyrightYear">2020</span>
  <span class="with-love" id="heart">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">Speciosity</span>

  
</div>


  <div class="powered-by">由 <a class="theme-link" target="_blank" href="https://hexo.io">Hexo</a> 强力驱动</div>



  <span class="post-meta-divider">|</span>



  <div class="theme-info">主题 &mdash; <a class="theme-link" target="_blank" href="https://github.com/iissnan/hexo-theme-next">NexT.Pisces</a> v5.1.4</div>




        







        
      </div>
    </footer>

    
      <div class="back-to-top">
        <i class="fa fa-arrow-up"></i>
        
      </div>
    

    
   

  </div>

  

<script type="text/javascript">
  if (Object.prototype.toString.call(window.Promise) !== '[object Function]') {
    window.Promise = null;
  }
</script>









  












  
  
    <script type="text/javascript" src="/lib/jquery/index.js?v=2.1.3"></script>
  

  
  
    <script type="text/javascript" src="/lib/fastclick/lib/fastclick.min.js?v=1.0.6"></script>
  

  
  
    <script type="text/javascript" src="/lib/jquery_lazyload/jquery.lazyload.js?v=1.9.7"></script>
  

  
  
    <script type="text/javascript" src="/lib/velocity/velocity.min.js?v=1.2.1"></script>
  

  
  
    <script type="text/javascript" src="/lib/velocity/velocity.ui.min.js?v=1.2.1"></script>
  

  
  
    <script type="text/javascript" src="/lib/fancybox/source/jquery.fancybox.pack.js?v=2.1.5"></script>
  


  


  <script type="text/javascript" src="/js/src/utils.js?v=5.1.4"></script>

  <script type="text/javascript" src="/js/src/motion.js?v=5.1.4"></script>



  
  


  <script type="text/javascript" src="/js/src/affix.js?v=5.1.4"></script>

  <script type="text/javascript" src="/js/src/schemes/pisces.js?v=5.1.4"></script>



  
  <script type="text/javascript" src="/js/src/scrollspy.js?v=5.1.4"></script>
<script type="text/javascript" src="/js/src/post-details.js?v=5.1.4"></script>



  


  <script type="text/javascript" src="/js/src/bootstrap.js?v=5.1.4"></script>



  


  




	





  





  












  

  <script type="text/javascript">
    // Popup Window;
    var isfetched = false;
    var isXml = true;
    // Search DB path;
    var search_path = "search.xml";
    if (search_path.length === 0) {
      search_path = "search.xml";
    } else if (/json$/i.test(search_path)) {
      isXml = false;
    }
    var path = "/" + search_path;
    // monitor main search box;

    var onPopupClose = function (e) {
      $('.popup').hide();
      $('#local-search-input').val('');
      $('.search-result-list').remove();
      $('#no-result').remove();
      $(".local-search-pop-overlay").remove();
      $('body').css('overflow', '');
    }

    function proceedsearch() {
      $("body")
        .append('<div class="search-popup-overlay local-search-pop-overlay"></div>')
        .css('overflow', 'hidden');
      $('.search-popup-overlay').click(onPopupClose);
      $('.popup').toggle();
      var $localSearchInput = $('#local-search-input');
      $localSearchInput.attr("autocapitalize", "none");
      $localSearchInput.attr("autocorrect", "off");
      $localSearchInput.focus();
    }

    // search function;
    var searchFunc = function(path, search_id, content_id) {
      'use strict';

      // start loading animation
      $("body")
        .append('<div class="search-popup-overlay local-search-pop-overlay">' +
          '<div id="search-loading-icon">' +
          '<i class="fa fa-spinner fa-pulse fa-5x fa-fw"></i>' +
          '</div>' +
          '</div>')
        .css('overflow', 'hidden');
      $("#search-loading-icon").css('margin', '20% auto 0 auto').css('text-align', 'center');

      $.ajax({
        url: path,
        dataType: isXml ? "xml" : "json",
        async: true,
        success: function(res) {
          // get the contents from search data
          isfetched = true;
          $('.popup').detach().appendTo('.header-inner');
          var datas = isXml ? $("entry", res).map(function() {
            return {
              title: $("title", this).text(),
              content: $("content",this).text(),
              url: $("url" , this).text()
            };
          }).get() : res;
          var input = document.getElementById(search_id);
          var resultContent = document.getElementById(content_id);
          var inputEventFunction = function() {
            var searchText = input.value.trim().toLowerCase();
            var keywords = searchText.split(/[\s\-]+/);
            if (keywords.length > 1) {
              keywords.push(searchText);
            }
            var resultItems = [];
            if (searchText.length > 0) {
              // perform local searching
              datas.forEach(function(data) {
                var isMatch = false;
                var hitCount = 0;
                var searchTextCount = 0;
                var title = data.title.trim();
                var titleInLowerCase = title.toLowerCase();
                var content = data.content.trim().replace(/<[^>]+>/g,"");
                var contentInLowerCase = content.toLowerCase();
                var articleUrl = decodeURIComponent(data.url);
                var indexOfTitle = [];
                var indexOfContent = [];
                // only match articles with not empty titles
                if(title != '') {
                  keywords.forEach(function(keyword) {
                    function getIndexByWord(word, text, caseSensitive) {
                      var wordLen = word.length;
                      if (wordLen === 0) {
                        return [];
                      }
                      var startPosition = 0, position = [], index = [];
                      if (!caseSensitive) {
                        text = text.toLowerCase();
                        word = word.toLowerCase();
                      }
                      while ((position = text.indexOf(word, startPosition)) > -1) {
                        index.push({position: position, word: word});
                        startPosition = position + wordLen;
                      }
                      return index;
                    }

                    indexOfTitle = indexOfTitle.concat(getIndexByWord(keyword, titleInLowerCase, false));
                    indexOfContent = indexOfContent.concat(getIndexByWord(keyword, contentInLowerCase, false));
                  });
                  if (indexOfTitle.length > 0 || indexOfContent.length > 0) {
                    isMatch = true;
                    hitCount = indexOfTitle.length + indexOfContent.length;
                  }
                }

                // show search results

                if (isMatch) {
                  // sort index by position of keyword

                  [indexOfTitle, indexOfContent].forEach(function (index) {
                    index.sort(function (itemLeft, itemRight) {
                      if (itemRight.position !== itemLeft.position) {
                        return itemRight.position - itemLeft.position;
                      } else {
                        return itemLeft.word.length - itemRight.word.length;
                      }
                    });
                  });

                  // merge hits into slices

                  function mergeIntoSlice(text, start, end, index) {
                    var item = index[index.length - 1];
                    var position = item.position;
                    var word = item.word;
                    var hits = [];
                    var searchTextCountInSlice = 0;
                    while (position + word.length <= end && index.length != 0) {
                      if (word === searchText) {
                        searchTextCountInSlice++;
                      }
                      hits.push({position: position, length: word.length});
                      var wordEnd = position + word.length;

                      // move to next position of hit

                      index.pop();
                      while (index.length != 0) {
                        item = index[index.length - 1];
                        position = item.position;
                        word = item.word;
                        if (wordEnd > position) {
                          index.pop();
                        } else {
                          break;
                        }
                      }
                    }
                    searchTextCount += searchTextCountInSlice;
                    return {
                      hits: hits,
                      start: start,
                      end: end,
                      searchTextCount: searchTextCountInSlice
                    };
                  }

                  var slicesOfTitle = [];
                  if (indexOfTitle.length != 0) {
                    slicesOfTitle.push(mergeIntoSlice(title, 0, title.length, indexOfTitle));
                  }

                  var slicesOfContent = [];
                  while (indexOfContent.length != 0) {
                    var item = indexOfContent[indexOfContent.length - 1];
                    var position = item.position;
                    var word = item.word;
                    // cut out 100 characters
                    var start = position - 20;
                    var end = position + 80;
                    if(start < 0){
                      start = 0;
                    }
                    if (end < position + word.length) {
                      end = position + word.length;
                    }
                    if(end > content.length){
                      end = content.length;
                    }
                    slicesOfContent.push(mergeIntoSlice(content, start, end, indexOfContent));
                  }

                  // sort slices in content by search text's count and hits' count

                  slicesOfContent.sort(function (sliceLeft, sliceRight) {
                    if (sliceLeft.searchTextCount !== sliceRight.searchTextCount) {
                      return sliceRight.searchTextCount - sliceLeft.searchTextCount;
                    } else if (sliceLeft.hits.length !== sliceRight.hits.length) {
                      return sliceRight.hits.length - sliceLeft.hits.length;
                    } else {
                      return sliceLeft.start - sliceRight.start;
                    }
                  });

                  // select top N slices in content

                  var upperBound = parseInt('1');
                  if (upperBound >= 0) {
                    slicesOfContent = slicesOfContent.slice(0, upperBound);
                  }

                  // highlight title and content

                  function highlightKeyword(text, slice) {
                    var result = '';
                    var prevEnd = slice.start;
                    slice.hits.forEach(function (hit) {
                      result += text.substring(prevEnd, hit.position);
                      var end = hit.position + hit.length;
                      result += '<b class="search-keyword">' + text.substring(hit.position, end) + '</b>';
                      prevEnd = end;
                    });
                    result += text.substring(prevEnd, slice.end);
                    return result;
                  }

                  var resultItem = '';

                  if (slicesOfTitle.length != 0) {
                    resultItem += "<li><a href='" + articleUrl + "' class='search-result-title'>" + highlightKeyword(title, slicesOfTitle[0]) + "</a>";
                  } else {
                    resultItem += "<li><a href='" + articleUrl + "' class='search-result-title'>" + title + "</a>";
                  }

                  slicesOfContent.forEach(function (slice) {
                    resultItem += "<a href='" + articleUrl + "'>" +
                      "<p class=\"search-result\">" + highlightKeyword(content, slice) +
                      "...</p>" + "</a>";
                  });

                  resultItem += "</li>";
                  resultItems.push({
                    item: resultItem,
                    searchTextCount: searchTextCount,
                    hitCount: hitCount,
                    id: resultItems.length
                  });
                }
              })
            };
            if (keywords.length === 1 && keywords[0] === "") {
              resultContent.innerHTML = '<div id="no-result"><i class="fa fa-search fa-5x" /></div>'
            } else if (resultItems.length === 0) {
              resultContent.innerHTML = '<div id="no-result"><i class="fa fa-frown-o fa-5x" /></div>'
            } else {
              resultItems.sort(function (resultLeft, resultRight) {
                if (resultLeft.searchTextCount !== resultRight.searchTextCount) {
                  return resultRight.searchTextCount - resultLeft.searchTextCount;
                } else if (resultLeft.hitCount !== resultRight.hitCount) {
                  return resultRight.hitCount - resultLeft.hitCount;
                } else {
                  return resultRight.id - resultLeft.id;
                }
              });
              var searchResultList = '<ul class=\"search-result-list\">';
              resultItems.forEach(function (result) {
                searchResultList += result.item;
              })
              searchResultList += "</ul>";
              resultContent.innerHTML = searchResultList;
            }
          }

          if ('auto' === 'auto') {
            input.addEventListener('input', inputEventFunction);
          } else {
            $('.search-icon').click(inputEventFunction);
            input.addEventListener('keypress', function (event) {
              if (event.keyCode === 13) {
                inputEventFunction();
              }
            });
          }

          // remove loading animation
          $(".local-search-pop-overlay").remove();
          $('body').css('overflow', '');

          proceedsearch();
        }
      });
    }

    // handle and trigger popup window;
    $('.popup-trigger').click(function(e) {
      e.stopPropagation();
      if (isfetched === false) {
        searchFunc(path, 'local-search-input', 'local-search-result');
      } else {
        proceedsearch();
      };
    });

    $('.popup-btn-close').click(onPopupClose);
    $('.popup').click(function(e){
      e.stopPropagation();
    });
    $(document).on('keyup', function (event) {
      var shouldDismissSearchPopup = event.which === 27 &&
        $('.search-popup').is(':visible');
      if (shouldDismissSearchPopup) {
        onPopupClose();
      }
    });
  </script>





  

  

  

  
  

  

  

  

</body>
</html>
