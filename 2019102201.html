<!DOCTYPE html>
<html lang="zh-CN">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width">
<meta name="theme-color" content="#222">
<meta name="generator" content="Hexo 5.4.0">


  <link rel="apple-touch-icon" sizes="180x180" href="/images/gamepad%20playstation.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/Dig%20Dug.ico">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/gamepad%20playstation.png">
  <link rel="mask-icon" href="/images/gamepad%20playstation.svg" color="#222">

<link rel="stylesheet" href="/css/main.css">

<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Monda:300,300italic,400,400italic,700,700italic%7CMa+Shan+Zheng:300,300italic,400,400italic,700,700italic%7CNoto+Serif+SC:300,300italic,400,400italic,700,700italic&display=swap&subset=latin,latin-ext">

<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free@5.15.3/css/all.min.css" integrity="sha256-2H3fkXt6FEmrReK448mDVGKb3WW2ZZw35gI7vqHOE4Y=" crossorigin="anonymous">
  <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/animate.css@3.1.1/animate.min.css" integrity="sha256-PR7ttpcvz8qrF57fur/yAx1qXMFJeJFiA6pSzWi0OIE=" crossorigin="anonymous">
  <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@3.5.7/dist/jquery.fancybox.min.css" integrity="sha256-Vzbj7sDDS/woiFS3uNKo8eIuni59rjyNGtXfstRzStA=" crossorigin="anonymous">
  <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/nprogress@0.2.0/nprogress.css" integrity="sha256-no0c5ccDODBwp+9hSmV5VvPpKwHCpbVzXHexIkupM6U=" crossorigin="anonymous">
  <script src="https://cdn.jsdelivr.net/npm/nprogress@0.2.0/nprogress.js" integrity="sha256-a5YRB27CcBwBFcT5EF/f3E4vzIqyHrSR878nseNYw64=" crossorigin="anonymous"></script>

<script class="next-config" data-name="main" type="application/json">{"hostname":"linyishui.top","root":"/","images":"/images","scheme":"Pisces","version":"8.6.0","exturl":false,"sidebar":{"position":"left","display":"always","padding":18,"offset":12},"copycode":true,"bookmark":{"enable":true,"color":"#222","save":"manual"},"fancybox":true,"mediumzoom":false,"lazyload":false,"pangu":false,"comments":{"style":"tabs","active":"utterances","storage":true,"lazyload":false,"nav":null,"activeClass":"utterances"},"motion":{"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"fadeInDown","post_body":"fadeInDown","coll_header":"fadeInLeft","sidebar":"fadeInUp"}},"prism":false,"i18n":{"placeholder":"搜索...","empty":"没有找到任何搜索结果：${query}","hits_time":"找到 ${hits} 个搜索结果（用时 ${time} 毫秒）","hits":"找到 ${hits} 个搜索结果"},"path":"/search.xml","localsearch":{"enable":true,"trigger":"auto","top_n_per_article":1,"unescape":false,"preload":false}}</script><script src="/js/config.js"></script>
<meta name="description" content="整理面试中常问的Java并发编程相关问题，持续更新中。">
<meta property="og:type" content="article">
<meta property="og:title" content="面试整理——Java并发编程">
<meta property="og:url" content="http://linyishui.top/2019102201.html">
<meta property="og:site_name" content="俺的部落格">
<meta property="og:description" content="整理面试中常问的Java并发编程相关问题，持续更新中。">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="https://pic-1258215793.cos.ap-shanghai.myqcloud.com/content/20190316/201903160104.jpg">
<meta property="og:image" content="https://p0.meituan.net/travelcube/582d1606d57ff99aa0e5f8fc59c7819329028.png">
<meta property="og:image" content="https://p0.meituan.net/travelcube/77441586f6b312a54264e3fcf5eebe2663494.png">
<meta property="og:image" content="https://p0.meituan.net/travelcube/31bad766983e212431077ca8da92762050214.png">
<meta property="og:image" content="https://p0.meituan.net/travelcube/49d8041f8480aba5ef59079fcc7143b996706.png">
<meta property="og:image" content="https://p0.meituan.net/travelcube/03268b9dc49bd30bb63064421bb036bf90315.png">
<meta property="og:image" content="https://p1.meituan.net/travelcube/9d8dc9cebe59122127460f81a98894bb34085.png">
<meta property="og:image" content="https://p0.meituan.net/travelcube/49527b1bb385f0f43529e57b614f59ae145454.png">
<meta property="og:image" content="https://p0.meituan.net/travelcube/90ea093549782945f2c968403fdc39d415386.png">
<meta property="og:image" content="https://p0.meituan.net/travelcube/879edb4f06043d76cea27a3ff358cb1d45243.png">
<meta property="og:image" content="https://pic-1258215793.cos.ap-shanghai.myqcloud.com/content/20190601/201906010120.png">
<meta property="article:published_time" content="2019-10-22T08:06:16.000Z">
<meta property="article:modified_time" content="2025-02-06T06:34:30.151Z">
<meta property="article:author" content="Lys">
<meta property="article:tag" content="Q&amp;A">
<meta property="article:tag" content="updating">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://pic-1258215793.cos.ap-shanghai.myqcloud.com/content/20190316/201903160104.jpg">


<link rel="canonical" href="http://linyishui.top/2019102201.html">



<script class="next-config" data-name="page" type="application/json">{"sidebar":"","isHome":false,"isPost":true,"lang":"zh-CN","comments":true,"permalink":"http://linyishui.top/2019102201.html","path":"2019102201.html","title":"面试整理——Java并发编程"}</script>

<script class="next-config" data-name="calendar" type="application/json">""</script>
<title>面试整理——Java并发编程 | 俺的部落格</title>
  




  <noscript>
    <link rel="stylesheet" href="/css/noscript.css">
  </noscript>
<link rel="alternate" href="/atom.xml" title="俺的部落格" type="application/atom+xml">
<style>.darkmode--activated{--body-bg-color:#282828;--content-bg-color:#333;--card-bg-color:#555;--text-color:#ccc;--blockquote-color:#bbb;--link-color:#ccc;--link-hover-color:#eee;--brand-color:#ddd;--brand-hover-color:#ddd;--table-row-odd-bg-color:#282828;--table-row-hover-bg-color:#363636;--menu-item-bg-color:#555;--btn-default-bg:#222;--btn-default-color:#ccc;--btn-default-border-color:#555;--btn-default-hover-bg:#666;--btn-default-hover-color:#ccc;--btn-default-hover-border-color:#666;--highlight-background:#282b2e;--highlight-foreground:#a9b7c6;--highlight-gutter-background:#34393d;--highlight-gutter-foreground:#9ca9b6}.darkmode--activated img{opacity:.75}.darkmode--activated img:hover{opacity:.9}.darkmode--activated code{color:#69dbdc;background:0 0}button.darkmode-toggle{z-index:9999}</style></head>

<body itemscope itemtype="http://schema.org/WebPage" class="use-motion">
  <div class="headband"></div>

  <main class="main">
    <header class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="切换导航栏" role="button">
        <span class="toggle-line"></span>
        <span class="toggle-line"></span>
        <span class="toggle-line"></span>
    </div>
  </div>

  <div class="site-meta">

    <a href="/" class="brand" rel="start">
      <i class="logo-line"></i>
      <h1 class="site-title">俺的部落格</h1>
      <i class="logo-line"></i>
    </a>
      <p class="site-subtitle" itemprop="description">俺寻思俺需要记点东西</p>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger">
        <i class="fa fa-search fa-fw fa-lg"></i>
    </div>
  </div>
</div>



<nav class="site-nav">
  <ul class="main-menu menu">
        <li class="menu-item menu-item-home"><a href="/" rel="section"><i class="fa fa-home fa-fw"></i>首页</a></li>
        <li class="menu-item menu-item-about"><a href="/about/" rel="section"><i class="fa fa-user fa-fw"></i>关于</a></li>
        <li class="menu-item menu-item-tags"><a href="/tags/" rel="section"><i class="fa fa-tags fa-fw"></i>标签</a></li>
        <li class="menu-item menu-item-categories"><a href="/categories/" rel="section"><i class="fa fa-th fa-fw"></i>分类</a></li>
        <li class="menu-item menu-item-archives"><a href="/archives/" rel="section"><i class="fa fa-archive fa-fw"></i>归档</a></li>
        <li class="menu-item menu-item-sitemap"><a href="/sitemap.xml" rel="section"><i class="fa fa-sitemap fa-fw"></i>站点地图</a></li>
        <li class="menu-item menu-item-tools"><a href="/links/" rel="section"><i class="fa fa-link fa-fw"></i>工具</a></li>
        <li class="menu-item menu-item-books"><a href="/books/" rel="section"><i class="fa fa-book fa-fw"></i>书架</a></li>
        <li class="menu-item menu-item-movies"><a href="/movies/" rel="section"><i class="fa fa-video fa-fw"></i>剧院</a></li>
        <li class="menu-item menu-item-games"><a href="/games/" rel="section"><i class="fa fa-gamepad fa-fw"></i>游戏</a></li>
        <li class="menu-item menu-item-commonweal"><a href="/404/" rel="section"><i class="fa fa-heartbeat fa-fw"></i>公益</a></li>
      <li class="menu-item menu-item-search">
        <a role="button" class="popup-trigger"><i class="fa fa-search fa-fw"></i>搜索
        </a>
      </li>
  </ul>
</nav>



  <div class="search-pop-overlay">
    <div class="popup search-popup"><div class="search-header">
  <span class="search-icon">
    <i class="fa fa-search"></i>
  </span>
  <div class="search-input-container">
    <input autocomplete="off" autocapitalize="off" maxlength="80"
           placeholder="搜索..." spellcheck="false"
           type="search" class="search-input">
  </div>
  <span class="popup-btn-close" role="button">
    <i class="fa fa-times-circle"></i>
  </span>
</div>
<div class="search-result-container no-result">
  <div class="search-result-icon">
    <i class="fa fa-spinner fa-pulse fa-5x"></i>
  </div>
</div>

    </div>
  </div>

</div>
        
  
  <div class="toggle sidebar-toggle" role="button">
    <span class="toggle-line"></span>
    <span class="toggle-line"></span>
    <span class="toggle-line"></span>
  </div>

  <aside class="sidebar">

    <div class="sidebar-inner sidebar-nav-active sidebar-toc-active">
      <ul class="sidebar-nav">
        <li class="sidebar-nav-toc">
          文章目录
        </li>
        <li class="sidebar-nav-overview">
          站点概览
        </li>
      </ul>

      <div class="sidebar-panel-container">
        <!--noindex-->
        <div class="post-toc-wrap sidebar-panel">
            <div class="post-toc animated"><ol class="nav"><li class="nav-item nav-level-1"><a class="nav-link" href="#Java%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B"><span class="nav-text">Java并发编程</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#%E4%B8%80-%E5%A4%9A%E7%BA%BF%E7%A8%8B"><span class="nav-text">一. 多线程</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#1-1-%E7%BA%BF%E7%A8%8B"><span class="nav-text">1.1 线程</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E9%97%AE%EF%BC%9A%E4%BB%80%E4%B9%88%E6%97%B6%E5%80%99%E7%94%A8%E7%BA%BF%E7%A8%8B%EF%BC%9F"><span class="nav-text">问：什么时候用线程？</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E9%97%AE%EF%BC%9A%E5%88%9B%E5%BB%BA%E5%A4%9A%E7%BA%BF%E7%A8%8B%E7%9A%84%E6%96%B9%E5%BC%8F%EF%BC%8C%E4%BB%A5%E5%8F%8A%E7%BA%BF%E7%A8%8B%E7%9A%84%E7%8A%B6%E6%80%81%E8%BD%AC%E6%8D%A2%EF%BC%9F%E2%AD%90%E2%AD%90%E2%AD%90"><span class="nav-text">问：创建多线程的方式，以及线程的状态转换？⭐⭐⭐</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E9%97%AE%EF%BC%9A%E7%BB%88%E6%AD%A2%E7%BA%BF%E7%A8%8B%E7%9A%84%E6%96%B9%E6%B3%95%EF%BC%9F"><span class="nav-text">问：终止线程的方法？</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E9%97%AE%EF%BC%9A%E8%B0%88%E4%B8%80%E4%B8%8B%E7%BA%BF%E7%A8%8B%E5%88%87%E6%8D%A2%EF%BC%8C%E5%B9%B6%E5%BC%95%E7%94%B3%E5%88%B0Java%E9%98%BB%E5%A1%9E%EF%BC%8C%E8%BF%90%E8%A1%8C%EF%BC%9F"><span class="nav-text">问：谈一下线程切换，并引申到Java阻塞，运行？</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E9%97%AE%EF%BC%9A%E7%BA%BF%E7%A8%8B%E7%9A%84%E4%B8%AD%E6%96%AD%E6%9C%BA%E5%88%B6%EF%BC%9F"><span class="nav-text">问：线程的中断机制？</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E9%97%AE%EF%BC%9A%E6%80%8E%E4%B9%88%E5%AE%9E%E7%8E%B0%E6%89%80%E6%9C%89%E7%BA%BF%E7%A8%8B%E5%9C%A8%E7%AD%89%E5%BE%85%E6%9F%90%E4%B8%AA%E4%BA%8B%E4%BB%B6%E7%9A%84%E5%8F%91%E7%94%9F%E6%89%8D%E4%BC%9A%E5%8E%BB%E6%89%A7%E8%A1%8C%EF%BC%9F%E2%AD%90%E2%AD%90"><span class="nav-text">问：怎么实现所有线程在等待某个事件的发生才会去执行？⭐⭐</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E9%97%AE%EF%BC%9A%E5%A6%82%E4%BD%95%E5%AE%9E%E7%8E%B0%E6%8E%A7%E5%88%B6%E7%BA%BF%E7%A8%8B%E5%9C%A8%E6%9F%90%E6%AE%B5%E6%97%B6%E9%97%B4%E5%86%85%E5%AE%8C%E6%88%90%EF%BC%8C%E4%B8%8D%E5%AE%8C%E6%88%90%E5%B0%B1%E6%92%A4%E9%94%80%EF%BC%9F%E2%AD%90%E2%AD%90"><span class="nav-text">问：如何实现控制线程在某段时间内完成，不完成就撤销？⭐⭐</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E9%97%AE%EF%BC%9A%E7%BA%BF%E7%A8%8B%E5%9B%9E%E8%B0%83%EF%BC%9F"><span class="nav-text">问：线程回调？</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E9%97%AE%EF%BC%9ARPC-%E6%A1%86%E6%9E%B6%EF%BC%9F%E8%AE%BE%E8%AE%A1%E4%B8%80%E4%B8%AA-RPC%EF%BC%8C%E6%80%8E%E4%B9%88%E5%AE%9E%E7%8E%B0%EF%BC%9FTODO"><span class="nav-text">问：RPC 框架？设计一个 RPC，怎么实现？TODO</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E9%97%AE%EF%BC%9A%E7%BA%BF%E7%A8%8B%E9%97%B4%E7%9A%84%E9%80%9A%E4%BF%A1%E5%8F%AF%E4%BB%A5%E6%80%8E%E4%B9%88%E5%81%9A%EF%BC%9F%E7%BA%BF%E7%A8%8B%E9%97%B4%E7%9B%B8%E4%BA%92%E9%80%9A%E7%9F%A5%E4%BD%A0%E4%BC%9A%E6%80%8E%E4%B9%88%E5%81%9A%EF%BC%8C%E4%BB%A3%E7%A0%81%E8%A6%81%E6%80%8E%E4%B9%88%E5%AE%9E%E7%8E%B0%EF%BC%9F%E2%AD%90%E2%AD%90"><span class="nav-text">问：线程间的通信可以怎么做？线程间相互通知你会怎么做，代码要怎么实现？⭐⭐</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E9%97%AE%EF%BC%9Anotify-%E4%B8%8EnotifyAll-%E7%9A%84%E5%8C%BA%E5%88%AB%EF%BC%9F"><span class="nav-text">问：notify()与notifyAll()的区别？</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#1-2-ThreadLocal"><span class="nav-text">1.2 ThreadLocal</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E9%97%AE%EF%BC%9A%E8%B0%88%E4%B8%80%E4%B8%8BThreadLocal%EF%BC%9F%E5%BA%94%E7%94%A8%E5%9C%BA%E6%99%AF%EF%BC%9F%E5%8E%9F%E7%90%86%EF%BC%9F%E4%B8%8E-Thread-%E7%B1%BB%E7%9A%84%E5%85%B3%E7%B3%BB%EF%BC%9F%E2%AD%90"><span class="nav-text">问：谈一下ThreadLocal？应用场景？原理？与 Thread 类的关系？⭐</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E9%97%AE%EF%BC%9Astatic-%E8%83%BD%E4%B8%8D%E8%83%BD%E4%BF%AE%E9%A5%B0-ThreadLocal%EF%BC%9F"><span class="nav-text">问：static 能不能修饰 ThreadLocal？</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E9%97%AE%EF%BC%9A%E8%B0%88%E4%B8%80%E4%B8%8BThreadLocal%E7%9A%84%E5%86%85%E5%AD%98%E6%B3%84%E6%BC%8F%E9%97%AE%E9%A2%98%EF%BC%9FThreadLocal%E4%B8%BA%E4%BB%80%E4%B9%88%E4%BC%9A%E5%87%BA%E7%8E%B0%E5%86%85%E5%AD%98%E6%B3%84%E6%BC%8F%EF%BC%9F%E2%AD%90%E2%AD%90%E2%AD%90"><span class="nav-text">问：谈一下ThreadLocal的内存泄漏问题？ThreadLocal为什么会出现内存泄漏？⭐⭐⭐</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E9%97%AE%EF%BC%9A%E5%A6%82%E6%9E%9C%E6%88%91%E4%BB%AC%E8%A6%81%E8%8E%B7%E5%8F%96%E7%88%B6%E7%BA%BF%E7%A8%8B%E7%9A%84ThreadLocal%E5%80%BC%E5%91%A2%EF%BC%9F"><span class="nav-text">问：如果我们要获取父线程的ThreadLocal值呢？</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#1-3-Thread"><span class="nav-text">1.3 Thread</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E9%97%AE%EF%BC%9AThread%E7%B1%BB%E9%87%8C%E6%9C%89%E5%93%AA%E4%BA%9B%E5%B8%B8%E7%94%A8%E6%96%B9%E6%B3%95%EF%BC%9F"><span class="nav-text">问：Thread类里有哪些常用方法？</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E9%97%AE%EF%BC%9Ainterrupt-isInterrupted-interrupt%E5%8C%BA%E5%88%AB%EF%BC%9F"><span class="nav-text">问：interrupt&#x2F;isInterrupted&#x2F;interrupt区别？</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E9%97%AE%EF%BC%9A%E8%B0%88%E4%B8%80%E4%B8%8Bstart%E5%92%8Crun%E6%96%B9%E6%B3%95%E7%9A%84%E5%8C%BA%E5%88%AB%EF%BC%9F%E2%AD%90"><span class="nav-text">问：谈一下start和run方法的区别？⭐</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E9%97%AE%EF%BC%9Asleep-%E5%92%8C-wait-%E6%9C%89%E4%BB%80%E4%B9%88%E5%8C%BA%E5%88%AB%EF%BC%9F%E2%AD%90%E2%AD%90"><span class="nav-text">问：sleep 和 wait 有什么区别？⭐⭐</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E9%97%AE%EF%BC%9Asleep-%E5%92%8C-yeild-%E6%96%B9%E6%B3%95%E6%9C%89%E4%BB%80%E4%B9%88%E5%8C%BA%E5%88%AB%EF%BC%9F"><span class="nav-text">问：sleep 和 yeild 方法有什么区别？</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#1-4-%E7%BA%BF%E7%A8%8B%E6%B1%A0"><span class="nav-text">1.4 线程池</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E9%97%AE%EF%BC%9A%E9%A1%B9%E7%9B%AE%E7%9A%84%E7%94%A8%E6%88%B7%E9%87%8F%E5%A4%9A%E5%90%97%EF%BC%9F%E6%9C%89%E7%94%A8%E8%BF%87%E7%BA%BF%E7%A8%8B%E6%B1%A0%E5%90%97%EF%BC%9F%E7%94%A8%E5%88%B0%E5%A4%9A%E7%BA%BF%E7%A8%8B%E7%9A%84%E4%BC%98%E5%8A%BF%E5%9C%A8%E5%93%AA%EF%BC%9F%E2%AD%90"><span class="nav-text">问：项目的用户量多吗？有用过线程池吗？用到多线程的优势在哪？⭐</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E9%97%AE%EF%BC%9A%E6%9C%89%E5%93%AA%E5%87%A0%E7%A7%8D%E7%BA%BF%E7%A8%8B%E6%B1%A0%EF%BC%9F%E2%AD%90%E2%AD%90"><span class="nav-text">问：有哪几种线程池？⭐⭐</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E9%97%AE%EF%BC%9A%E7%BA%BF%E7%A8%8B%E6%B1%A0%E7%8A%B6%E6%80%81%EF%BC%9F%E2%AD%90"><span class="nav-text">问：线程池状态？⭐</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E9%97%AE%EF%BC%9AThreadPoolExecutor-%E5%88%9D%E5%A7%8B%E5%8C%96%E5%8F%82%E6%95%B0%EF%BC%9FcorepoolSize-%E6%80%8E%E4%B9%88%E8%AE%BE%E7%BD%AE%EF%BC%8Cmaxpoolsize-%E6%80%8E%E4%B9%88%E8%AE%BE%E7%BD%AE%EF%BC%8Ckeep-alive-%E5%90%84%E7%A7%8D%E7%9A%84%EF%BC%9F%E2%AD%90%E2%AD%90%E2%AD%90"><span class="nav-text">问：ThreadPoolExecutor 初始化参数？corepoolSize 怎么设置，maxpoolsize 怎么设置，keep-alive 各种的？⭐⭐⭐</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E9%97%AE%EF%BC%9A%E9%98%BB%E5%A1%9E%E9%98%9F%E5%88%97%E5%9C%A8%E7%94%9F%E4%BA%A7%E4%B8%AD%E7%9A%84%E8%AE%BE%E7%BD%AE%EF%BC%9F%E6%8B%92%E7%BB%9D%E7%AD%96%E7%95%A5%E7%9A%84%E9%80%89%E6%8B%A9%EF%BC%9F%E2%AD%90%E2%AD%90%E2%AD%90"><span class="nav-text">问：阻塞队列在生产中的设置？拒绝策略的选择？⭐⭐⭐</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E9%97%AE%EF%BC%9AJava%E4%B8%AD%E7%9A%84%E7%BA%BF%E7%A8%8B%E6%B1%A0%E6%98%AF%E5%A6%82%E4%BD%95%E5%AE%9E%E7%8E%B0%E7%9A%84%EF%BC%9F%E8%AE%B2%E4%B8%80%E4%B8%8B%E7%BA%BF%E7%A8%8B%E6%B1%A0%E7%9A%84%E5%8E%9F%E7%90%86%EF%BC%9F%E2%AD%90%E2%AD%90%E2%AD%90"><span class="nav-text">问：Java中的线程池是如何实现的？讲一下线程池的原理？⭐⭐⭐</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E9%97%AE%EF%BC%9A%E5%A6%82%E6%9E%9C%E7%BA%BF%E7%A8%8B%E6%B1%A0%E4%B8%AD%E7%9A%84%E4%B8%80%E4%B8%AA%E7%BA%BF%E7%A8%8B%E8%BF%90%E8%A1%8C%E6%97%B6%E5%87%BA%E7%8E%B0%E4%BA%86%E5%BC%82%E5%B8%B8%EF%BC%8C%E4%BC%9A%E5%8F%91%E7%94%9F%E4%BB%80%E4%B9%88%EF%BC%9F"><span class="nav-text">问：如果线程池中的一个线程运行时出现了异常，会发生什么？</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E9%97%AE%EF%BC%9A%E5%A6%82%E4%BD%95%E5%AE%9E%E7%8E%B0%E4%B8%80%E4%B8%AA%E7%BA%BF%E7%A8%8B%E6%B1%A0%EF%BC%8CJava%E4%B8%AD%E7%BA%BF%E7%A8%8B%E6%B1%A0%E5%A6%82%E4%BD%95%E8%BF%9B%E8%A1%8C%E9%85%8D%E7%BD%AE%EF%BC%9F%E7%BA%BF%E7%A8%8B%E6%B1%A0%E7%9A%84%E7%BA%BF%E7%A8%8B%E6%95%B0%E6%80%8E%E4%B9%88%E7%A1%AE%E5%AE%9A%EF%BC%9F%E7%BA%BF%E7%A8%8B%E6%B1%A0%E7%9A%84%E5%B7%A5%E4%BD%9C%E6%B5%81%E7%A8%8B%E8%AE%B0%E5%BE%97%E5%90%97%EF%BC%9F%E5%A6%82%E6%9E%9C%E6%98%AFIO%E6%93%8D%E4%BD%9C%E4%B8%BA%E4%B8%BB%E6%80%8E%E4%B9%88%E7%A1%AE%E5%AE%9A%EF%BC%9F%E5%A6%82%E6%9E%9C%E8%AE%A1%E7%AE%97%E5%9E%8B%E6%93%8D%E4%BD%9C%E5%8F%88%E6%80%8E%E4%B9%88%E7%A1%AE%E5%AE%9A%EF%BC%9F%E8%B7%B3%E8%A1%A8%E7%9A%84%E6%9F%A5%E8%AF%A2%E8%BF%87%E7%A8%8B%E6%98%AF%E6%80%8E%E4%B9%88%E6%A0%B7%E7%9A%84%EF%BC%8C%E6%9F%A5%E8%AF%A2%E5%92%8C%E6%8F%92%E5%85%A5%E7%9A%84%E6%97%B6%E9%97%B4%E5%A4%8D%E6%9D%82%E5%BA%A6-%E2%AD%90%E2%AD%90"><span class="nav-text">问：如何实现一个线程池，Java中线程池如何进行配置？线程池的线程数怎么确定？线程池的工作流程记得吗？如果是IO操作为主怎么确定？如果计算型操作又怎么确定？跳表的查询过程是怎么样的，查询和插入的时间复杂度?⭐⭐</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E9%97%AE%EF%BC%9A%E7%BA%BF%E7%A8%8B%E6%B1%A0%E9%87%8C%E5%A6%82%E4%BD%95%E7%9F%A5%E9%81%93%E7%BA%BF%E7%A8%8B%E6%89%A7%E8%A1%8C%E5%AE%8C%E4%BA%86%E6%B2%A1%E6%9C%89%EF%BC%9F%E7%BA%BF%E7%A8%8B%E9%98%BB%E5%A1%9E%E6%80%8E%E4%B9%88%E5%8A%9E%EF%BC%9F%E6%80%8E%E4%B9%88%E4%BF%9D%E8%AF%81%E6%89%80%E6%9C%89%E7%BA%BF%E7%A8%8B%E6%89%A7%E8%A1%8C%E5%AE%8C%E4%B9%8B%E5%90%8E%E7%BB%A7%E7%BB%AD%E5%BE%80%E4%B8%8B%E5%A4%84%E7%90%86%EF%BC%9F%E6%80%8E%E4%B9%88%E8%AE%A9%E4%B8%80%E4%B8%AA%E7%BA%BF%E7%A8%8B%E7%AD%89%E5%8F%A6%E4%B8%80%E4%B8%AA%E7%BA%BF%E7%A8%8B%E6%89%A7%E8%A1%8C%E7%BB%93%E6%9D%9F%EF%BC%9F%E2%AD%90%E2%AD%90%E2%AD%90"><span class="nav-text">问：线程池里如何知道线程执行完了没有？线程阻塞怎么办？怎么保证所有线程执行完之后继续往下处理？怎么让一个线程等另一个线程执行结束？⭐⭐⭐</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E9%97%AE%EF%BC%9AJava-%E7%9A%84%E4%BF%A1%E5%8F%B7%E7%81%AF%EF%BC%9F%E2%AD%90"><span class="nav-text">问：Java 的信号灯？⭐</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E9%97%AE%EF%BC%9AExecutors-%E9%9D%99%E6%80%81%E6%96%B9%E6%B3%95%EF%BC%9F"><span class="nav-text">问：Executors 静态方法？</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#1-5-%E7%BA%BF%E7%A8%8B%E5%AE%89%E5%85%A8"><span class="nav-text">1.5 线程安全</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E9%97%AE%EF%BC%9A%E8%B0%88%E4%B8%80%E4%B8%8B%E5%AF%B9%E7%BA%BF%E7%A8%8B%E5%AE%89%E5%85%A8%E7%9A%84%E7%90%86%E8%A7%A3%EF%BC%9F%E7%94%A8%E4%BB%80%E4%B9%88%E6%96%B9%E6%B3%95%E4%BF%9D%E8%AF%81%E7%BA%BF%E7%A8%8B%E7%9A%84%E5%AE%89%E5%85%A8%EF%BC%9F"><span class="nav-text">问：谈一下对线程安全的理解？用什么方法保证线程的安全？</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E9%97%AE%EF%BC%9A%E5%A6%82%E4%BD%95%E5%AE%9E%E7%8E%B0%E4%B8%80%E4%B8%AA%E7%BA%BF%E7%A8%8B%E5%AE%89%E5%85%A8%E7%9A%84%E8%AE%A1%E6%95%B0%E5%99%A8%EF%BC%9F"><span class="nav-text">问：如何实现一个线程安全的计数器？</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E9%97%AE%EF%BC%9A%E8%AF%B7%E5%86%99%E4%B8%80%E4%B8%AA%E7%BA%BF%E7%A8%8B%E5%AE%89%E5%85%A8%E7%9A%84%E5%8D%95%E4%BE%8B%E6%A8%A1%E5%BC%8F%EF%BC%9F%E9%A5%BF%E6%B1%89%E5%BC%8F%EF%BC%8C%E6%87%92%E6%B1%89%E5%BC%8F%E7%AD%89%E3%80%82%E4%B8%A4%E6%AC%A1%E5%88%A4%E6%96%AD-instance-%E6%98%AF%E5%90%A6%E4%B8%BA%E7%A9%BA%EF%BC%8C%E6%AF%8F%E6%AC%A1%E5%88%A4%E6%96%AD%E7%9A%84%E4%BD%9C%E7%94%A8%E6%98%AF%E4%BB%80%E4%B9%88%EF%BC%9F"><span class="nav-text">问：请写一个线程安全的单例模式？饿汉式，懒汉式等。两次判断 instance 是否为空，每次判断的作用是什么？</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E9%97%AE%EF%BC%9AABC-%E4%B8%89%E4%B8%AA%E7%BA%BF%E7%A8%8B%E5%A6%82%E4%BD%95%E4%BF%9D%E8%AF%81%E9%A1%BA%E5%BA%8F%E6%89%A7%E8%A1%8C%EF%BC%9F"><span class="nav-text">问：ABC 三个线程如何保证顺序执行？</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E9%97%AE%EF%BC%9A%E7%94%9F%E4%BA%A7%E8%80%85%E6%B6%88%E8%B4%B9%E8%80%85%E6%A8%A1%E5%BC%8F%E7%9A%84%E5%AE%9E%E7%8E%B0%E6%96%B9%E5%BC%8F%EF%BC%9F"><span class="nav-text">问：生产者消费者模式的实现方式？</span></a></li></ol></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E4%BA%8C-%E9%94%81"><span class="nav-text">二. 锁</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#2-1-%E9%94%81"><span class="nav-text">2.1 锁</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E9%97%AE%EF%BC%9A%E8%AE%B2%E8%AE%B2%E4%BD%A0%E7%9F%A5%E9%81%93%E7%9A%84%E9%94%81%EF%BC%9F%E9%94%81%E7%9A%84%E5%87%A0%E7%A7%8D%E7%89%B9%E6%80%A7%EF%BC%9F%E2%AD%90%E2%AD%90"><span class="nav-text">问：讲讲你知道的锁？锁的几种特性？⭐⭐</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E9%97%AE%EF%BC%9A%E5%85%AC%E5%B9%B3%E9%94%81%E4%B8%8E%E9%9D%9E%E5%85%AC%E5%B9%B3%E9%94%81%EF%BC%9F"><span class="nav-text">问：公平锁与非公平锁？</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E9%97%AE%EF%BC%9A%E7%8B%AC%E5%8D%A0%E9%94%81%E4%B8%8E%E5%85%B1%E4%BA%AB%E9%94%81%EF%BC%9F"><span class="nav-text">问：独占锁与共享锁？</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E9%97%AE%EF%BC%9A%E5%8F%AF%E9%87%8D%E5%85%A5%E9%94%81%E6%A6%82%E5%BF%B5%EF%BC%9F"><span class="nav-text">问：可重入锁概念？</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E9%97%AE%EF%BC%9A%E8%AE%B2%E8%AE%B24%E7%A7%8D%E9%94%81%E7%8A%B6%E6%80%81%EF%BC%9F%E2%AD%90%E2%AD%90%E2%AD%90"><span class="nav-text">问：讲讲4种锁状态？⭐⭐⭐</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E9%97%AE%EF%BC%9A%E8%BD%BB%E9%87%8F%E7%BA%A7%E9%94%81%E4%B8%8E%E5%81%8F%E5%90%91%E9%94%81%E7%9A%84%E5%8C%BA%E5%88%AB%EF%BC%9F%E2%AD%90%E2%AD%90"><span class="nav-text">问：轻量级锁与偏向锁的区别？⭐⭐</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E9%97%AE%EF%BC%9A%E8%87%AA%E6%97%8B%E9%94%81%E5%8D%87%E7%BA%A7%E5%88%B0%E9%87%8D%E9%87%8F%E7%BA%A7%E9%94%81%E6%9D%A1%E4%BB%B6%EF%BC%9F%E2%AD%90%E2%AD%90"><span class="nav-text">问：自旋锁升级到重量级锁条件？⭐⭐</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E9%97%AE%EF%BC%9A%E8%AE%B2%E8%AE%B2%E8%AF%BB%E5%86%99%E9%94%81%EF%BC%9F%E4%BC%98%E7%82%B9%EF%BC%9F%E5%AE%9E%E7%8E%B0%E6%96%B9%E5%BC%8F%EF%BC%9F"><span class="nav-text">问：讲讲读写锁？优点？实现方式？</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E9%97%AE%EF%BC%9A%E4%B9%90%E8%A7%82%E9%94%81%E5%92%8C%E6%82%B2%E8%A7%82%E9%94%81%E7%9A%84%E5%8C%BA%E5%88%AB%EF%BC%9F%E4%BC%98%E7%BC%BA%E7%82%B9%EF%BC%9F%E4%BD%BF%E7%94%A8%E5%9C%BA%E6%99%AF%EF%BC%9FJDK%E4%B8%AD%E6%B6%89%E5%8F%8A%E5%88%B0%E4%B9%90%E8%A7%82%E9%94%81%E5%92%8C%E6%82%B2%E8%A7%82%E9%94%81%E7%9A%84%E5%86%85%E5%AE%B9%EF%BC%9F%E8%BF%99%E4%B8%A4%E7%A7%8D%E9%94%81%E5%9C%A8Java%E5%92%8CMySQL%E5%88%86%E5%88%AB%E6%98%AF%E6%80%8E%E4%B9%88%E5%AE%9E%E7%8E%B0%E7%9A%84%EF%BC%9FMySql%E7%9A%84%E6%82%B2%E8%A7%82%E9%94%81%E6%80%8E%E4%B9%88%E9%98%B2%E6%AD%A2%E5%B9%B6%E5%8F%91%EF%BC%9F%E2%AD%90"><span class="nav-text">问：乐观锁和悲观锁的区别？优缺点？使用场景？JDK中涉及到乐观锁和悲观锁的内容？这两种锁在Java和MySQL分别是怎么实现的？MySql的悲观锁怎么防止并发？⭐</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E9%97%AE%EF%BC%9A%E4%BB%80%E4%B9%88%E6%98%AF%E6%AD%BB%E9%94%81%EF%BC%9F%E7%BA%BF%E4%B8%8A%E6%AD%BB%E9%94%81%E5%A6%82%E4%BD%95%E5%A4%84%E7%90%86%EF%BC%9F%E5%A6%82%E4%BD%95%E5%AE%9A%E4%BD%8D%E6%AD%BB%E9%94%81%EF%BC%9F%E6%AD%BB%E9%94%81%E4%BA%A7%E7%94%9F%E7%9A%84%E5%8E%9F%E5%9B%A0%EF%BC%9F%E5%A6%82%E4%BD%95%E9%A2%84%E9%98%B2%E9%81%BF%E5%85%8D%EF%BC%9F%E2%AD%90%E2%AD%90%E2%AD%90"><span class="nav-text">问：什么是死锁？线上死锁如何处理？如何定位死锁？死锁产生的原因？如何预防避免？⭐⭐⭐</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E9%97%AE%EF%BC%9A%E5%8A%A0%E9%94%81%E4%BC%9A%E5%B8%A6%E6%9D%A5%E5%93%AA%E4%BA%9B%E6%80%A7%E8%83%BD%E9%97%AE%E9%A2%98%E3%80%82%E5%A6%82%E4%BD%95%E8%A7%A3%E5%86%B3%EF%BC%9F"><span class="nav-text">问：加锁会带来哪些性能问题。如何解决？</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E9%97%AE%EF%BC%9A%E5%81%8F%E5%90%91%E9%94%81%E3%80%81%E8%BD%BB%E9%87%8F%E7%BA%A7%E9%94%81%E3%80%81%E8%87%AA%E6%97%8B%E9%94%81%E7%AD%89%E4%BC%98%E5%8C%96%EF%BC%9F"><span class="nav-text">问：偏向锁、轻量级锁、自旋锁等优化？</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E9%97%AE%EF%BC%9A%E4%BA%8B%E5%8A%A1%E6%9C%89%E5%93%AA%E4%BA%9B%E7%89%B9%E6%80%A7%EF%BC%9F%E6%80%8E%E4%B9%88%E7%90%86%E8%A7%A3%E5%8E%9F%E5%AD%90%E6%80%A7%EF%BC%9F"><span class="nav-text">问：事务有哪些特性？怎么理解原子性？</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#2-2-volatile"><span class="nav-text">2.2 volatile</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E9%97%AE%EF%BC%9Avolatile%E7%9A%84%E4%BD%9C%E7%94%A8%E6%98%AF%E4%BB%80%E4%B9%88%EF%BC%9F%E5%8F%AF%E8%A7%81%E6%80%A7%EF%BC%9F%E2%AD%90%E2%AD%90%E2%AD%90"><span class="nav-text">问：volatile的作用是什么？可见性？⭐⭐⭐</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E9%97%AE%EF%BC%9Avolatile-%E7%9A%84%E5%AE%9E%E7%8E%B0%E5%8E%9F%E7%90%86%EF%BC%9F%E5%8F%8A%E5%86%85%E5%AD%98%E5%B1%8F%E9%9A%9C%E7%9B%B8%E5%85%B3%EF%BC%9F%E2%AD%90%E2%AD%90"><span class="nav-text">问：volatile 的实现原理？及内存屏障相关？⭐⭐</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E9%97%AE%EF%BC%9Avolatile%E5%A6%82%E4%BD%95%E4%BF%9D%E8%AF%81%E7%BA%BF%E7%A8%8B%E9%97%B4%E5%8F%AF%E8%A7%81%E5%92%8C%E9%81%BF%E5%85%8D%E6%8C%87%E4%BB%A4%E9%87%8D%E6%8E%92%EF%BC%9F"><span class="nav-text">问：volatile如何保证线程间可见和避免指令重排？</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#2-3-synchronized"><span class="nav-text">2.3 synchronized</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E9%97%AE%EF%BC%9Asynchronized-%E4%BD%BF%E7%94%A8%E6%96%B9%E5%BC%8F%E5%8F%8A%E5%AE%9E%E7%8E%B0%E5%8E%9F%E7%90%86%EF%BC%8C%E4%BB%A5%E5%8F%8A%E9%94%81%E4%BC%98%E5%8C%96%EF%BC%9F%E2%AD%90%E2%AD%90%E2%AD%90"><span class="nav-text">问：synchronized 使用方式及实现原理，以及锁优化？⭐⭐⭐</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E9%97%AE%EF%BC%9Asynchronized-%E5%9C%A8%E9%9D%99%E6%80%81%E6%96%B9%E6%B3%95%E5%92%8C%E6%99%AE%E9%80%9A%E6%96%B9%E6%B3%95%E7%9A%84%E5%8C%BA%E5%88%AB%EF%BC%9F"><span class="nav-text">问：synchronized 在静态方法和普通方法的区别？</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E9%97%AE%EF%BC%9Asynchronized-%E5%92%8C-ReentranLock%E7%9A%84%E5%8C%BA%E5%88%AB%EF%BC%9F%E2%AD%90%E2%AD%90"><span class="nav-text">问：synchronized 和 ReentranLock的区别？⭐⭐</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E9%97%AE%EF%BC%9AHashTable%EF%BC%8C%E5%90%8C%E6%AD%A5%E9%94%81%EF%BC%8Csynchronized-%E5%85%B3%E9%94%AE%E5%AD%97-1-6-%E4%B9%8B%E5%90%8E%E6%8F%90%E5%8D%87%E4%BA%86%E4%BB%80%E4%B9%88%EF%BC%8C%E6%80%8E%E4%B9%88%E6%8F%90%E5%8D%87%E7%9A%84%E8%BF%99%E4%BA%9B%EF%BC%9F"><span class="nav-text">问：HashTable，同步锁，synchronized 关键字 1.6 之后提升了什么，怎么提升的这些？</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#2-4-Lock"><span class="nav-text">2.4 Lock</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E9%97%AE%EF%BC%9ALock-%E6%8E%A5%E5%8F%A3%E6%9C%89%E5%93%AA%E4%BA%9B%E5%AE%9E%E7%8E%B0%E7%B1%BB%EF%BC%8C%E4%BD%BF%E7%94%A8%E5%9C%BA%E6%99%AF%E6%98%AF%E4%BB%80%E4%B9%88%EF%BC%9F"><span class="nav-text">问：Lock 接口有哪些实现类，使用场景是什么？</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E9%97%AE%EF%BC%9A%E8%AE%B2%E8%AE%B2ReentrantLock%E5%AE%9E%E7%8E%B0%E5%8E%9F%E7%90%86%EF%BC%9F%E2%AD%90%E2%AD%90%E2%AD%90"><span class="nav-text">问：讲讲ReentrantLock实现原理？⭐⭐⭐</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E9%97%AE%EF%BC%9AReentrantLock-%E6%98%AF%E5%A6%82%E4%BD%95%E5%AE%9E%E7%8E%B0%E5%8F%AF%E9%87%8D%E5%85%A5%E6%80%A7%E7%9A%84-%EF%BC%9F"><span class="nav-text">问：ReentrantLock 是如何实现可重入性的 ？</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E9%97%AE%EF%BC%9AReentrantLock%E5%A6%82%E4%BD%95%E9%81%BF%E5%85%8D%E6%AD%BB%E9%94%81"><span class="nav-text">问：ReentrantLock如何避免死锁?</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E9%97%AE%EF%BC%9AtryLock-%E5%92%8C-lock-%E5%92%8C-lockInterruptibly-%E7%9A%84%E5%8C%BA%E5%88%AB-%E2%AD%90%E2%AD%90"><span class="nav-text">问：tryLock 和 lock 和 lockInterruptibly 的区别?⭐⭐</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#2-5-Condition"><span class="nav-text">2.5 Condition</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E9%97%AE%EF%BC%9A%E8%AE%B2%E4%B8%80%E4%B8%8BCondition%EF%BC%9F"><span class="nav-text">问：讲一下Condition？</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E9%97%AE%EF%BC%9A%E5%AF%B9%E8%B1%A1%E7%9B%91%E8%A7%86%E5%99%A8%E6%96%B9%E6%B3%95%E5%92%8CCondition%E7%9A%84%E5%BC%82%E5%90%8C-%EF%BC%9F"><span class="nav-text">问：对象监视器方法和Condition的异同 ？</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#2-6-AQS"><span class="nav-text">2.6 AQS</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E9%97%AE%EF%BC%9A%E8%AE%B2%E8%AE%B2AQS%EF%BC%9F%E5%AE%9E%E7%8E%B0%E5%8E%9F%E7%90%86%EF%BC%9F%E8%AE%B2%E8%AE%B2AQS%E6%80%8E%E4%B9%88%E5%AE%9E%E7%8E%B0%E7%9A%84Fair%E5%92%8CNoFair%EF%BC%9F"><span class="nav-text">问：讲讲AQS？实现原理？讲讲AQS怎么实现的Fair和NoFair？</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E9%97%AE%EF%BC%9AAQS%E4%B8%A4%E7%A7%8D%E8%B5%84%E6%BA%90%E5%85%B1%E4%BA%AB%E6%96%B9%E5%BC%8F%EF%BC%9F"><span class="nav-text">问：AQS两种资源共享方式？</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E9%97%AE%EF%BC%9ACAS%E4%BA%86%E8%A7%A3%E4%B9%88%EF%BC%9F-CAS-%E6%9C%89%E4%BB%80%E4%B9%88%E7%BC%BA%E9%99%B7%EF%BC%8C%E5%A6%82%E4%BD%95%E8%A7%A3%E5%86%B3%EF%BC%9F%E8%BF%98%E4%BA%86%E8%A7%A3%E5%85%B6%E4%BB%96%E5%90%8C%E6%AD%A5%E6%9C%BA%E5%88%B6%E4%B9%88%EF%BC%9F"><span class="nav-text">问：CAS了解么？ CAS 有什么缺陷，如何解决？还了解其他同步机制么？</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E9%97%AE%EF%BC%9ACAS%E5%92%8Csynchronized%E6%9C%89%E4%BB%80%E4%B9%88%E5%8C%BA%E5%88%AB%EF%BC%9F%E9%83%BD%E7%94%A8synchronized%E4%B8%8D%E8%A1%8C%E4%B9%88%EF%BC%9F"><span class="nav-text">问：CAS和synchronized有什么区别？都用synchronized不行么？</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#2-7-CountDownLatch"><span class="nav-text">2.7 CountDownLatch</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E9%97%AE%EF%BC%9A%E7%94%A8%E8%BF%87CountDownLatch%E4%B9%88%EF%BC%9F%E4%BB%80%E4%B9%88%E5%9C%BA%E6%99%AF%E4%B8%8B%E7%94%A8%E7%9A%84%EF%BC%9F"><span class="nav-text">问：用过CountDownLatch么？什么场景下用的？</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E9%97%AE%EF%BC%9A%E4%BB%80%E4%B9%88%E6%98%AF%E4%BF%A1%E5%8F%B7%E9%87%8FSemaphore%EF%BC%9F%E5%BA%94%E7%94%A8%E5%9C%BA%E6%99%AF%EF%BC%9F"><span class="nav-text">问：什么是信号量Semaphore？应用场景？</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E9%97%AE%EF%BC%9A%E7%94%A8%E8%BF%87CyclicBarrier%E5%90%97%EF%BC%9F-%E5%92%8C-countdownlatch-%E7%9A%84%E5%8C%BA%E5%88%AB%EF%BC%9F"><span class="nav-text">问：用过CyclicBarrier吗？ 和 countdownlatch 的区别？</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#2-8-%E9%94%81%E7%9A%84%E5%BA%94%E7%94%A8"><span class="nav-text">2.8 锁的应用</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E9%97%AE%EF%BC%9AConcurrentHashMap%E7%9A%84get%E9%9C%80%E8%A6%81%E5%8A%A0%E9%94%81%E4%B9%88%EF%BC%8C%E4%B8%BA%E4%BB%80%E4%B9%88%EF%BC%9F"><span class="nav-text">问：ConcurrentHashMap的get需要加锁么，为什么？</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E9%97%AE%EF%BC%9AHashtable-%E6%98%AF%E6%80%8E%E4%B9%88%E5%8A%A0%E9%94%81%E7%9A%84-%EF%BC%9F"><span class="nav-text">问：Hashtable 是怎么加锁的 ？</span></a></li></ol></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E4%B8%89-%E5%86%85%E5%AD%98%E6%A8%A1%E5%9E%8B"><span class="nav-text">三. 内存模型</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E9%97%AE%EF%BC%9AJava%E5%86%85%E5%AD%98%E6%A8%A1%E5%9E%8B%EF%BC%9F%E4%B8%BA%E4%BB%80%E4%B9%88%E8%A6%81%E6%9C%89%E5%B7%A5%E4%BD%9C%E5%86%85%E5%AD%98%E5%92%8C%E4%B8%BB%E5%86%85%E5%AD%98%EF%BC%9F"><span class="nav-text">问：Java内存模型？为什么要有工作内存和主内存？</span></a></li></ol></li></ol></li></ol></li></ol></div>
        </div>
        <!--/noindex-->

        <div class="site-overview-wrap sidebar-panel">
          <div class="site-overview">
            <div class="site-author site-overview-item animated" itemprop="author" itemscope itemtype="http://schema.org/Person">
    <img class="site-author-image" itemprop="image" alt="Lys"
      src="https://pic-1258215793.cos.ap-shanghai.myqcloud.com/cover/IMG_0759.JPG">
  <p class="site-author-name" itemprop="name">Lys</p>
  <div class="site-description" itemprop="description">记录编程点滴，写点生活中的酸甜</div>
</div>
<div class="site-state-wrap site-overview-item animated">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
          <a href="/archives/">
        
          <span class="site-state-item-count">340</span>
          <span class="site-state-item-name">日志</span>
        </a>
      </div>
      <div class="site-state-item site-state-categories">
            <a href="/categories/">
          
        <span class="site-state-item-count">13</span>
        <span class="site-state-item-name">分类</span></a>
      </div>
      <div class="site-state-item site-state-tags">
            <a href="/tags/">
          
        <span class="site-state-item-count">113</span>
        <span class="site-state-item-name">标签</span></a>
      </div>
  </nav>
</div>
  <div class="links-of-author site-overview-item animated">
      <span class="links-of-author-item">
        <a href="https://github.com/LAILAIWA" title="GitHub → https:&#x2F;&#x2F;github.com&#x2F;LAILAIWA" rel="noopener" target="_blank"><i class="fab fa-github fa-fw"></i>GitHub</a>
      </span>
      <span class="links-of-author-item">
        <a href="mailto:linyishui168@outlook.com" title="E-Mail → mailto:linyishui168@outlook.com" rel="noopener" target="_blank"><i class="fa fa-envelope fa-fw"></i>E-Mail</a>
      </span>
      <span class="links-of-author-item">
        <a href="https://weibo.com/u/5340162234" title="Weibo → https:&#x2F;&#x2F;weibo.com&#x2F;u&#x2F;5340162234" rel="noopener" target="_blank"><i class="fab fa-weibo fa-fw"></i>Weibo</a>
      </span>
      <span class="links-of-author-item">
        <a href="https://twitter.com/linyishui618" title="Twitter → https:&#x2F;&#x2F;twitter.com&#x2F;linyishui618" rel="noopener" target="_blank"><i class="fab fa-twitter fa-fw"></i>Twitter</a>
      </span>
      <span class="links-of-author-item">
        <a href="https://stackoverflow.com/users/13018339/lin-yishui" title="StackOverflow → https:&#x2F;&#x2F;stackoverflow.com&#x2F;users&#x2F;13018339&#x2F;lin-yishui" rel="noopener" target="_blank"><i class="fab fa-stack-overflow fa-fw"></i>StackOverflow</a>
      </span>
      <span class="links-of-author-item">
        <a href="https://instagram.com/linyishui618" title="Instagram → https:&#x2F;&#x2F;instagram.com&#x2F;linyishui618" rel="noopener" target="_blank"><i class="fab fa-instagram fa-fw"></i>Instagram</a>
      </span>
  </div>
  <div class="cc-license site-overview-item animated" itemprop="license">
    <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/deed.zh" class="cc-opacity" rel="noopener" target="_blank"><img src="https://cdn.jsdelivr.net/npm/@creativecommons/vocabulary@2020.11.3/assets/license_badges/small/by_nc_sa.svg" alt="Creative Commons"></a>
  </div>


  <div class="links-of-blogroll site-overview-item animated">
    <div class="links-of-blogroll-title"><i class="far fa-smile-wink fa-fw"></i>
      个人
    </div>
    <ul class="links-of-blogroll-list">
        <li class="links-of-blogroll-item">
          <a href="https://music.163.com/#/user/home?id=68425607" title="https:&#x2F;&#x2F;music.163.com&#x2F;#&#x2F;user&#x2F;home?id&#x3D;68425607" rel="noopener" target="_blank">网易云音乐</a>
        </li>
    </ul>
  </div>

          </div>
        </div>
    </div>
  </aside>
  <div class="sidebar-dimmer"></div>


    </header>

    
  <div class="back-to-top" role="button" aria-label="返回顶部">
    <i class="fa fa-arrow-up"></i>
    <span>0%</span>
  </div>
  <a role="button" class="book-mark-link book-mark-link-fixed"></a>

  <a href="https://github.com/LAILAIWA" class="github-corner" title="Follow me on GitHub" aria-label="Follow me on GitHub" rel="noopener" target="_blank"><svg width="80" height="80" viewBox="0 0 250 250" aria-hidden="true"><path d="M0,0 L115,115 L130,115 L142,142 L250,250 L250,0 Z"></path><path d="M128.3,109.0 C113.8,99.7 119.0,89.6 119.0,89.6 C122.0,82.7 120.5,78.6 120.5,78.6 C119.2,72.0 123.4,76.3 123.4,76.3 C127.3,80.9 125.5,87.3 125.5,87.3 C122.9,97.6 130.6,101.9 134.4,103.2" fill="currentColor" style="transform-origin: 130px 106px;" class="octo-arm"></path><path d="M115.0,115.0 C114.9,115.1 118.7,116.5 119.8,115.4 L133.7,101.6 C136.9,99.2 139.9,98.4 142.2,98.6 C133.8,88.0 127.5,74.4 143.8,58.0 C148.5,53.4 154.0,51.2 159.7,51.0 C160.3,49.4 163.2,43.6 171.4,40.1 C171.4,40.1 176.1,42.5 178.8,56.2 C183.1,58.6 187.2,61.8 190.9,65.4 C194.5,69.0 197.7,73.2 200.1,77.6 C213.8,80.2 216.3,84.9 216.3,84.9 C212.7,93.1 206.9,96.0 205.4,96.6 C205.1,102.4 203.0,107.8 198.3,112.5 C181.9,128.9 168.3,122.5 157.7,114.1 C157.9,116.9 156.7,120.9 152.7,124.9 L141.0,136.5 C139.8,137.7 141.6,141.9 141.8,141.8 Z" fill="currentColor" class="octo-body"></path></svg></a>

<noscript>
  <div class="noscript-warning">Theme NexT works best with JavaScript enabled</div>
</noscript>


    <div class="main-inner post posts-expand">


  


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://linyishui.top/2019102201.html">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="https://pic-1258215793.cos.ap-shanghai.myqcloud.com/cover/IMG_0759.JPG">
      <meta itemprop="name" content="Lys">
      <meta itemprop="description" content="记录编程点滴，写点生活中的酸甜">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="俺的部落格">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          面试整理——Java并发编程
        </h1>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>

      <time title="创建时间：2019-10-22 16:06:16" itemprop="dateCreated datePublished" datetime="2019-10-22T16:06:16+08:00">2019-10-22</time>
    </span>
      <span class="post-meta-item">
        <span class="post-meta-item-icon">
          <i class="far fa-calendar-check"></i>
        </span>
        <span class="post-meta-item-text">更新于</span>
        <time title="修改时间：2025-02-06 14:34:30" itemprop="dateModified" datetime="2025-02-06T14:34:30+08:00">2025-02-06</time>
      </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">分类于</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/%E9%9D%A2%E8%AF%95%E6%95%B4%E7%90%86/" itemprop="url" rel="index"><span itemprop="name">面试整理</span></a>
        </span>
    </span>

  
      </div>
      <div class="post-meta">
    <span class="post-meta-item" title="本文字数">
      <span class="post-meta-item-icon">
        <i class="far fa-file-word"></i>
      </span>
      <span class="post-meta-item-text">本文字数：</span>
      <span>149k</span>
    </span>
    <span class="post-meta-item" title="阅读时长">
      <span class="post-meta-item-icon">
        <i class="far fa-clock"></i>
      </span>
      <span class="post-meta-item-text">阅读时长 &asymp;</span>
      <span>2:15</span>
    </span>
</div>

            <div class="post-description">整理面试中常问的Java并发编程相关问题，持续更新中。</div>
        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
        <h1 id="Java并发编程"><a href="#Java并发编程" class="headerlink" title="Java并发编程"></a>Java并发编程</h1><h2 id="一-多线程"><a href="#一-多线程" class="headerlink" title="一. 多线程"></a>一. 多线程</h2><h3 id="1-1-线程"><a href="#1-1-线程" class="headerlink" title="1.1 线程"></a>1.1 线程</h3><h4 id="问：什么时候用线程？"><a href="#问：什么时候用线程？" class="headerlink" title="问：什么时候用线程？"></a>问：什么时候用线程？</h4><ul>
<li><strong>需要频繁创建和销毁</strong>。</li>
<li><strong>需要频繁切换</strong>。</li>
<li><strong>多核环境</strong>。</li>
<li><strong>并行操作</strong>。</li>
<li><strong>相比稳定安全更需要速度</strong>。</li>
</ul>
<h4 id="问：创建多线程的方式，以及线程的状态转换？⭐⭐⭐"><a href="#问：创建多线程的方式，以及线程的状态转换？⭐⭐⭐" class="headerlink" title="问：创建多线程的方式，以及线程的状态转换？⭐⭐⭐"></a>问：创建多线程的方式，以及线程的状态转换？⭐⭐⭐</h4><p>Java中创建多线程的方式有：</p>
<ul>
<li><p>继承Thread类，重写run()，创建线程对象。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyThread</span> <span class="keyword">extends</span> <span class="title">Thread</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;Thread is running&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Main</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        MyThread thread = <span class="keyword">new</span> MyThread();</span><br><span class="line">        thread.start();  <span class="comment">// 启动线程</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li><p>实现Runnable接口，重写run()，创建线程对象。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyRunnable</span> <span class="keyword">implements</span> <span class="title">Runnable</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;Runnable is running&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Main</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Thread thread = <span class="keyword">new</span> Thread(<span class="keyword">new</span> MyRunnable());</span><br><span class="line">        thread.start();  <span class="comment">// 启动线程</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li><p>实现Callable接口，重写call()，创建实例对象并作为构造器参数创建FutureTask对象，再使用FutureTask对象作为构造器参数创建线程对象。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyCallable</span> <span class="keyword">implements</span> <span class="title">Callable</span>&lt;<span class="title">String</span>&gt; </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">call</span><span class="params">()</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;Callable result&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Main</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> ExecutionException, InterruptedException </span>&#123;</span><br><span class="line">        FutureTask&lt;String&gt; futureTask = <span class="keyword">new</span> FutureTask&lt;&gt;(<span class="keyword">new</span> MyCallable());</span><br><span class="line">        Thread thread = <span class="keyword">new</span> Thread(futureTask);</span><br><span class="line">        thread.start();</span><br><span class="line">        System.out.println(futureTask.get());  <span class="comment">// 获取线程返回值</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li><p>使用Executor框架创建线程池。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Main</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 创建固定大小为 3 的线程池</span></span><br><span class="line">        ExecutorService executor = Executors.newFixedThreadPool(<span class="number">3</span>);</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">5</span>; i++) &#123;</span><br><span class="line">            executor.execute(() -&gt; &#123;</span><br><span class="line">                System.out.println(<span class="string">&quot;Thread: &quot;</span> + Thread.currentThread().getName() + <span class="string">&quot; is running&quot;</span>);</span><br><span class="line">            &#125;);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 关闭线程池</span></span><br><span class="line">        executor.shutdown();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
<p><img src="https://pic-1258215793.cos.ap-shanghai.myqcloud.com/content/20190316/201903160104.jpg" alt="线程状态"></p>
<table>
<thead>
<tr>
<th align="center">状态</th>
<th align="center">名称</th>
<th align="left">示例</th>
<th align="left">介绍</th>
</tr>
</thead>
<tbody><tr>
<td align="center">New</td>
<td align="center">初始状态</td>
<td align="left">new Thread(runnable)</td>
<td align="left">线程还未开始运行，处于创建状态</td>
</tr>
<tr>
<td align="center">Runnable</td>
<td align="center">运行状态</td>
<td align="left">thread.start()</td>
<td align="left">可运行但未必在运行，取决于OS分配的运行时间，即就绪和运行两状态的合并。</td>
</tr>
<tr>
<td align="center">Blocked</td>
<td align="center">阻塞状态</td>
<td align="left"></td>
<td align="left">请求内部的对象锁，但锁被其他线程持有</td>
</tr>
<tr>
<td align="center">Waiting</td>
<td align="center">等待状态</td>
<td align="left">Object.wait() / Thread.join() / 等待Lock或Condition</td>
<td align="left">当线程等待另一个线程通知调度器某个条件时，处于此状态</td>
</tr>
<tr>
<td align="center">Timed waiting</td>
<td align="center">超时等待</td>
<td align="left">Object.wait() / Thread.join() / Thread.sleep() / Lock.tryLock() / Condition.await()</td>
<td align="left">调用有些有超时参数的方法时，可以指定时间自行返回</td>
</tr>
<tr>
<td align="center">Terminated</td>
<td align="center">终止状态</td>
<td align="left">不要使用stop()</td>
<td align="left">要么因为run方法正常结束而终止，要么因为没有捕获的异常终止了run方法而结束</td>
</tr>
</tbody></table>
<p>一个经历了所有状态的线程可能会经历以下流程：</p>
<ol>
<li>线程创建后调用start()方法开始，状态由NEW-&gt;RUNNABLE。</li>
<li>当线程执行wait()、join()或 sleep()后，线程进入WAITING/TIME_WAITING状态。处于WAITING状态的线程需要等待其他线程的通知才可以恢复RUNNABLE状态，而TIME_WAITING则是在WAITING上增加了时间限制，在超时后会自动返回RUNNABLE状态。</li>
<li>当线程调用同步方法时，在无法获得锁的情况下，线程进入BLOCKED状态。线程在执行run()方法后将进入终止状态。</li>
</ol>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ThreadStateDemo</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 创建线程</span></span><br><span class="line">        Thread thread = <span class="keyword">new</span> Thread(<span class="keyword">new</span> Task());</span><br><span class="line">        System.out.println(<span class="string">&quot;1. Thread state after creation: &quot;</span> + thread.getState()); <span class="comment">// NEW</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// 启动线程</span></span><br><span class="line">        thread.start();</span><br><span class="line">        System.out.println(<span class="string">&quot;2. Thread state after calling start(): &quot;</span> + thread.getState()); <span class="comment">// RUNNABLE</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// 主线程睡眠 1 秒，让子线程进入睡眠状态</span></span><br><span class="line">        Thread.sleep(<span class="number">1000</span>);</span><br><span class="line">        System.out.println(<span class="string">&quot;3. Thread state while sleeping (TIMED_WAITING): &quot;</span> + thread.getState());</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 主线程等待子线程唤醒，确保子线程进入 WAITING 状态</span></span><br><span class="line">        Thread.sleep(<span class="number">3000</span>);</span><br><span class="line">        System.out.println(<span class="string">&quot;4. Thread state while waiting for lock (WAITING): &quot;</span> + thread.getState());</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 唤醒子线程</span></span><br><span class="line">        <span class="keyword">synchronized</span> (Task.class) &#123;</span><br><span class="line">            Task.class.notify();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 主线程等待子线程完成</span></span><br><span class="line">        thread.join();</span><br><span class="line">        System.out.println(<span class="string">&quot;5. Thread state after completion: &quot;</span> + thread.getState()); <span class="comment">// TERMINATED</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Task</span> <span class="keyword">implements</span> <span class="title">Runnable</span> </span>&#123;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                <span class="comment">// TIMED_WAITING：线程在这里睡眠</span></span><br><span class="line">                Thread.sleep(<span class="number">2000</span>);</span><br><span class="line"></span><br><span class="line">                <span class="keyword">synchronized</span> (Task.class) &#123;</span><br><span class="line">                    System.out.println(<span class="string">&quot;Acquired lock, entering WAITING state...&quot;</span>);</span><br><span class="line">                    Task.class.wait(); <span class="comment">// WAITING：线程等待锁被唤醒</span></span><br><span class="line">                &#125;</span><br><span class="line">            &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                Thread.currentThread().interrupt();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 打印：</span></span><br><span class="line"><span class="number">1.</span> Thread state after creation: NEW</span><br><span class="line"><span class="number">2.</span> <span class="function">Thread state after calling <span class="title">start</span><span class="params">()</span>: RUNNABLE</span></span><br><span class="line"><span class="function">3. Thread state <span class="keyword">while</span> <span class="title">sleeping</span> <span class="params">(TIMED_WAITING)</span>: TIMED_WAITING</span></span><br><span class="line"><span class="function">4. Thread state <span class="keyword">while</span> waiting <span class="keyword">for</span> <span class="title">lock</span> <span class="params">(WAITING)</span>: WAITING</span></span><br><span class="line"><span class="function">5. Thread state after completion: TERMINATED</span></span><br></pre></td></tr></table></figure>





<h4 id="问：终止线程的方法？"><a href="#问：终止线程的方法？" class="headerlink" title="问：终止线程的方法？"></a>问：终止线程的方法？</h4><ol>
<li>使用退出标志/共享标志位（如<strong>volatile</strong>声明的变量）：线程周期性地检查该标志变量的状态，决定是否退出。</li>
<li>通过interrupt()中断：<ul>
<li>不会直接停止线程，而是通过设置线程的中断标志，通知线程它应该停止工作。线程内run()通过isInterrupted()判断是否中断，若处于阻塞状态就无法检测中断状态，会抛出异常InterruptedException。</li>
<li>future.cancel(true)+future.isCancelled()，本质上仍是FutureTask通过interrupt()中断。</li>
<li>ExecutorService.shutdown()，本质上仍是ThreadPoolExecutor通过interrupt()中断。</li>
</ul>
</li>
<li>Thread.stop()强制终止，但会导致资源释放问题、锁泄露以及数据不一致。</li>
<li>守护线程：将线程设置为守护线程，它会在所有非守护线程结束时自动终止。</li>
</ol>
<h4 id="问：谈一下线程切换，并引申到Java阻塞，运行？"><a href="#问：谈一下线程切换，并引申到Java阻塞，运行？" class="headerlink" title="问：谈一下线程切换，并引申到Java阻塞，运行？"></a>问：谈一下线程切换，并引申到Java阻塞，运行？</h4><ul>
<li>什么是线程切换？<ul>
<li>线程切换就是指<strong>CPU从一个进程/线程切换到另一个进程/线程</strong>。</li>
<li>大概过程可以简单的理解为：（上下文指某个时间节  点CPU寄存器和计数器的内容）。<ul>
<li><strong>挂起当前线程</strong>（存储当前上下文），</li>
<li><strong>恢复一个线程</strong>（找到一个合适的上下文并恢复到寄存器），</li>
<li><strong>跳转到程序计数器指向的位置</strong>（即线程被中断时的代码行）。</li>
</ul>
</li>
</ul>
</li>
<li>线程切换的触发场景？<ul>
<li>时间片耗尽：操作系统的调度策略，如时间片轮转。</li>
<li>IO操作：线程进行IO操作会进入阻塞状态，调度器切换其它线程。</li>
<li>锁竞争：多线程竞争锁资源，未获取锁的线程进入等待状态，引起线程切换。</li>
<li>手动yield或sleep：Thread.yield()或Thread.sleep()。</li>
</ul>
</li>
<li>Java 中的阻塞与运行：<ul>
<li>阻塞就是指线程执行到某一阶段时，需要获取某些资源才能继续执行，但此时这些资源被其他线程占用，所以当前线程需要处于等待状态。常见的阻塞原因：等待锁、IO操作、等待通知等。</li>
<li>运行状态表示线程正在被CPU执行。当阻塞状态消失（如锁被释放或IO完成）时，线程有机会从阻塞状态切换回可执行状态（RUNNABLE），等待被调度器分配CPU资源。</li>
</ul>
</li>
</ul>
<h4 id="问：线程的中断机制？"><a href="#问：线程的中断机制？" class="headerlink" title="问：线程的中断机制？"></a>问：线程的中断机制？</h4><ul>
<li>Java的线程中有一个<strong>中断标识位</strong>，表示是否有中断请求，并在Thread中提供了 <code>interrupt()</code> 来中断线程，以及 <code>interrupted()</code> 和 <code>isInterrupted()</code> 来判断当前中断状态，前者会将中断复位。</li>
<li>中断通常在阻塞操作上触发，比如 <code>Thread.sleep()</code>、<code>wait()</code>、<code>join()</code> 等。如果线程在这些方法上收到中断请求，会抛出 <code>InterruptedException</code>，此时线程可选择是否响应中断，或者继续执行。</li>
<li>中断并不意味着线程会立即终止，中断线程可以任意处理，通常会把中断请求当作终止请求，由线程根据情况在合适的时机终止。</li>
<li>处于阻塞状态的线程会抛出异常InterruptedException，且抛出异常的方法大多会先重置中断标识位再抛出异常。</li>
</ul>
<h4 id="问：怎么实现所有线程在等待某个事件的发生才会去执行？⭐⭐"><a href="#问：怎么实现所有线程在等待某个事件的发生才会去执行？⭐⭐" class="headerlink" title="问：怎么实现所有线程在等待某个事件的发生才会去执行？⭐⭐"></a>问：怎么实现所有线程在等待某个事件的发生才会去执行？⭐⭐</h4><ul>
<li><p><strong>读写锁</strong>：主线程先获取写锁，所有子线程获取读锁，等事件发生时主线程释放写锁。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.concurrent.locks.ReadWriteLock;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.locks.ReentrantReadWriteLock;</span><br><span class="line"><span class="comment">// 写锁 保证数据加载时没有其他线程能访问 data。</span></span><br><span class="line"><span class="comment">// 读锁 让所有读线程在数据加载完成后可以安全读取 data，不影响彼此</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ReadWriteLockExample</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> ReadWriteLock lock = <span class="keyword">new</span> ReentrantReadWriteLock();</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> String data = <span class="string">&quot;Initial Data&quot;</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">        <span class="comment">// 写线程：模拟加载数据</span></span><br><span class="line">        <span class="keyword">new</span> Thread(() -&gt; &#123;</span><br><span class="line">            lock.writeLock().lock();</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                System.out.println(<span class="string">&quot;Writing data...&quot;</span>);</span><br><span class="line">                Thread.sleep(<span class="number">2000</span>); <span class="comment">// 模拟数据加载</span></span><br><span class="line">                data = <span class="string">&quot;Loaded Data&quot;</span>;</span><br><span class="line">                System.out.println(<span class="string">&quot;Data loaded.&quot;</span>);</span><br><span class="line">            &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                Thread.currentThread().interrupt();</span><br><span class="line">            &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">                lock.writeLock().unlock();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;).start();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 读线程：等待数据加载完成后再读取</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">5</span>; i++) &#123;</span><br><span class="line">            <span class="keyword">new</span> Thread(() -&gt; &#123;</span><br><span class="line">                lock.readLock().lock();</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    System.out.println(Thread.currentThread().getName() + <span class="string">&quot; reads: &quot;</span> + data);</span><br><span class="line">                &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">                    lock.readLock().unlock();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;).start();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li><p><strong>信号量-Semaphore</strong>：控制一定数量的线程同时访问某个资源或执行某个任务。初始值设为N，主线程先调用 <code>acquire(N)</code> 申请N个信号量，其他线程调用 <code>acquire()</code> 阻塞等待，等事件发生时主线程同时释放N个信号量。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.concurrent.Semaphore;</span><br><span class="line"><span class="comment">// semaphore.acquire() 让线程等待信号。</span></span><br><span class="line"><span class="comment">// 主线程完成准备后调用 semaphore.release(threadCount)，释放信号量，允许所有线程执行。</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SemaphoreExample</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> Semaphore semaphore = <span class="keyword">new</span> Semaphore(<span class="number">0</span>);  <span class="comment">// 0表示初始所有线程阻塞</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> threadCount = <span class="number">5</span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 启动5个线程等待信号量</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; threadCount; i++) &#123;</span><br><span class="line">            <span class="keyword">new</span> Thread(<span class="keyword">new</span> Task(semaphore)).start();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        System.out.println(<span class="string">&quot;Main thread preparing...&quot;</span>);</span><br><span class="line">        Thread.sleep(<span class="number">2000</span>);  <span class="comment">// 模拟准备时间</span></span><br><span class="line"></span><br><span class="line">        System.out.println(<span class="string">&quot;Main thread releases all threads.&quot;</span>);</span><br><span class="line">        semaphore.release(threadCount);  <span class="comment">// 释放信号量，允许所有线程执行</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Task</span> <span class="keyword">implements</span> <span class="title">Runnable</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> Semaphore semaphore;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Task</span><span class="params">(Semaphore semaphore)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.semaphore = semaphore;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            System.out.println(Thread.currentThread().getName() + <span class="string">&quot; waiting for signal.&quot;</span>);</span><br><span class="line">            semaphore.acquire();  <span class="comment">// 等待信号量</span></span><br><span class="line">            System.out.println(Thread.currentThread().getName() + <span class="string">&quot; is now running.&quot;</span>);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">            Thread.currentThread().interrupt();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li><p><strong>CountDownLatch</strong>：适用于一组线程等待一个事件完成后再同时继续执行。初始值设置为1，所有子线程调用 <code>await()</code> 等待，等事件发生时调用 <code>countDown()</code> 方法计数减为0。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 用 CountDownLatch 初始化一个计数值，并让线程等待直到计数归零。</span></span><br><span class="line"><span class="comment">// 各线程先启动并等待 latch.await()。</span></span><br><span class="line"><span class="comment">// 主线程模拟事件准备，准备完成后 countDown()，所有线程被释放同时执行。</span></span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.CountDownLatch;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">CountDownLatchExample</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> threadCount = <span class="number">5</span>;</span><br><span class="line">        CountDownLatch latch = <span class="keyword">new</span> CountDownLatch(<span class="number">1</span>);  <span class="comment">// 初始化事件完成计数器</span></span><br><span class="line">        </span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; threadCount; i++) &#123;</span><br><span class="line">            <span class="keyword">new</span> Thread(<span class="keyword">new</span> Task(latch)).start();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        System.out.println(<span class="string">&quot;Main thread doing setup work...&quot;</span>);</span><br><span class="line">        Thread.sleep(<span class="number">2000</span>); <span class="comment">// 模拟某个事件准备时间</span></span><br><span class="line"></span><br><span class="line">        System.out.println(<span class="string">&quot;Main thread completed setup, releasing all threads.&quot;</span>);</span><br><span class="line">        latch.countDown();  <span class="comment">// 初始化完成，所有等待线程可继续</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Task</span> <span class="keyword">implements</span> <span class="title">Runnable</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> CountDownLatch latch;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Task</span><span class="params">(CountDownLatch latch)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.latch = latch;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            System.out.println(Thread.currentThread().getName() + <span class="string">&quot; is waiting for setup.&quot;</span>);</span><br><span class="line">            latch.await();  <span class="comment">// 等待事件完成</span></span><br><span class="line">            System.out.println(Thread.currentThread().getName() + <span class="string">&quot; is now running.&quot;</span>);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">            Thread.currentThread().interrupt();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li><p><strong>CyclicBarrier</strong>：可以使一组线程到达屏障后，再一同执行。特别适合周期性任务，在每个循环的关键点上使得所有线程保持同步。适用于一组线程都到达某个“屏障”点时，再一同继续执行。可以多次重用，适合需要反复等待的场景。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.concurrent.BrokenBarrierException;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.CyclicBarrier;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 每个线程到达屏障后调用 await()，等到所有线程都到达时触发屏障，释放所有线程。</span></span><br><span class="line"><span class="comment">// barrier.await() 的重置特性使 CyclicBarrier 可重复使用，适合周期性同步。</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">CyclicBarrierExample</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> threadCount = <span class="number">5</span>;</span><br><span class="line">        CyclicBarrier barrier = <span class="keyword">new</span> CyclicBarrier(threadCount, () -&gt; &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;All threads reached the barrier, releasing them...&quot;</span>);</span><br><span class="line">        &#125;);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; threadCount; i++) &#123;</span><br><span class="line">            <span class="keyword">new</span> Thread(<span class="keyword">new</span> Task(barrier)).start();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Task</span> <span class="keyword">implements</span> <span class="title">Runnable</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> CyclicBarrier barrier;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Task</span><span class="params">(CyclicBarrier barrier)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.barrier = barrier;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            System.out.println(Thread.currentThread().getName() + <span class="string">&quot; is waiting at the barrier.&quot;</span>);</span><br><span class="line">            barrier.await();  <span class="comment">// 等待其他线程</span></span><br><span class="line">            System.out.println(Thread.currentThread().getName() + <span class="string">&quot; is now running after the barrier.&quot;</span>);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException | BrokenBarrierException e) &#123;</span><br><span class="line">            Thread.currentThread().interrupt();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
<h4 id="问：如何实现控制线程在某段时间内完成，不完成就撤销？⭐⭐"><a href="#问：如何实现控制线程在某段时间内完成，不完成就撤销？⭐⭐" class="headerlink" title="问：如何实现控制线程在某段时间内完成，不完成就撤销？⭐⭐"></a>问：如何实现控制线程在某段时间内完成，不完成就撤销？⭐⭐</h4><p>通过 <code>Future</code> 和 <code>ExecutorService</code> 来控制线程在指定时间内完成任务，如果超时未完成则尝试撤销该线程。<code>Future</code> 提供了超时控制功能，允许在一定时间内等待线程完成。如果任务超时，可以调用 <code>Future.cancel(true)</code> 取消任务。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.concurrent.*;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TimeoutTaskExample</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 创建线程池</span></span><br><span class="line">        ExecutorService executorService = Executors.newSingleThreadExecutor();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 提交任务并获取 Future 对象</span></span><br><span class="line">        Future&lt;String&gt; future = executorService.submit(() -&gt; &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                Thread.sleep(<span class="number">3000</span>); <span class="comment">// 模拟长时间运行任务</span></span><br><span class="line">                <span class="keyword">return</span> <span class="string">&quot;Task Completed&quot;</span>;</span><br><span class="line">            &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="string">&quot;Task Interrupted&quot;</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">// 尝试在指定时间内完成任务</span></span><br><span class="line">            String result = future.get(<span class="number">2</span>, TimeUnit.SECONDS); <span class="comment">// 2秒内获取任务结果</span></span><br><span class="line">            System.out.println(result);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (TimeoutException e) &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;Task timed out, attempting to cancel...&quot;</span>);</span><br><span class="line">            future.cancel(<span class="keyword">true</span>); <span class="comment">// 超时未完成，尝试取消任务</span></span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException | ExecutionException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            <span class="comment">// 关闭线程池，避免资源泄漏。</span></span><br><span class="line">            executorService.shutdown();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>





<h4 id="问：线程回调？"><a href="#问：线程回调？" class="headerlink" title="问：线程回调？"></a>问：线程回调？</h4><ul>
<li><p>线程回调用于在一个线程完成任务后通知另一个线程执行相应的操作。回调机制在异步编程中非常常见，通过在主线程中设置一个“回调方法”，异步线程完成任务后即触发此回调，告知主线程任务结果或执行后续操作。</p>
</li>
<li><p>使用 <code>Future</code> 模拟回调机制，在 <code>Future</code> 中可以轮询 <code>isDone()</code>，定期检查任务完成状态，以达到回调的效果。不过这样实现并不算是真正的异步回调。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.concurrent.*;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">FutureCallbackExample</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> ExecutionException, InterruptedException </span>&#123;</span><br><span class="line">        ExecutorService executor = Executors.newSingleThreadExecutor();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 提交任务</span></span><br><span class="line">        Future&lt;String&gt; future = executor.submit(() -&gt; &#123;</span><br><span class="line">            Thread.sleep(<span class="number">2000</span>);</span><br><span class="line">            <span class="keyword">return</span> <span class="string">&quot;Task Completed&quot;</span>;</span><br><span class="line">        &#125;);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 模拟回调</span></span><br><span class="line">        <span class="keyword">while</span> (!future.isDone()) &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;等待任务完成...&quot;</span>);</span><br><span class="line">            Thread.sleep(<span class="number">500</span>); <span class="comment">// 等待任务完成的过程中可以做其他事情</span></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 一旦任务完成，获取结果</span></span><br><span class="line">        System.out.println(<span class="string">&quot;任务完成: &quot;</span> + future.get());</span><br><span class="line"></span><br><span class="line">        executor.shutdown();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li><p>使用 <code>CompletableFuture</code> 实现真正的异步回调：<code>CompletableFuture</code> 提供了更为直观的异步编程和回调支持，不需要手动轮询或阻塞等待。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.concurrent.CompletableFuture;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">CompletableFutureCallbackExample</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 提交异步任务，开启一个异步任务，返回 CompletableFuture。</span></span><br><span class="line">        CompletableFuture.supplyAsync(() -&gt; &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                Thread.sleep(<span class="number">2000</span>); <span class="comment">// 模拟耗时操作</span></span><br><span class="line">            &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> <span class="string">&quot;Task Completed&quot;</span>;</span><br><span class="line">        &#125;).thenAccept(result -&gt; &#123;</span><br><span class="line">            <span class="comment">// 任务完成后自动调用此回调方法并传递任务结果，主线程无需等待异步任务完成即可继续执行。</span></span><br><span class="line">            <span class="comment">// 回调操作，在任务完成后执行</span></span><br><span class="line">            System.out.println(<span class="string">&quot;任务完成: &quot;</span> + result);</span><br><span class="line">        &#125;);</span><br><span class="line"></span><br><span class="line">        System.out.println(<span class="string">&quot;主线程可以继续执行其他任务...&quot;</span>);</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 为了观察效果，主线程需要等子线程任务完成（测试环境下）</span></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            Thread.sleep(<span class="number">3000</span>); <span class="comment">// 等待异步任务执行完</span></span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
<h4 id="问：RPC-框架？设计一个-RPC，怎么实现？TODO"><a href="#问：RPC-框架？设计一个-RPC，怎么实现？TODO" class="headerlink" title="问：RPC 框架？设计一个 RPC，怎么实现？TODO"></a>问：RPC 框架？设计一个 RPC，怎么实现？TODO</h4><ul>
<li><p>什么是RPC框架？</p>
<ul>
<li>RPC（Remote Procedure Call，远程过程调用）框架用于在不同进程、不同机器间调用服务，像是在本地直接调用函数。通过<strong>序列化、传输协议、网络通信等机制</strong>，RPC实现跨进程的透明通信，屏蔽了底层网络的细节，调用端可以像调用本地服务一样调用远程方法。</li>
</ul>
</li>
<li><p>RPC调用流程：</p>
<ul>
<li><p>客户端：如 Dubbo 是基于接口的远程方法调用，Java中接口不能直接调用实例方法，必须通过其实现类对象来完成此操作，意味着<strong>客户端必须为这些接口生成代理对象</strong>，对此 <strong>Java 提供了 <code>Proxy</code>、<code>InvocationHandler</code> 生成动态代理的支持</strong>；代理对象调用指定方法时实际会执行<code>InvocationHandler</code> 中定义的 <code>#invoke</code> 方法，在该方法中完成远程方法调用并获取结果。</p>
</li>
<li><p>注册中心：若集群的节点数量很大的话，管理服务地址也是一件繁琐的事情，常见的做法是各个服务节点将自己的地址和提供的服务列表注册到一个注册中心，由注册中心来统一管理服务列表；这样的做法解决问题的同时为客户端增加了一项新的工作—服务发现，通俗来说就是从注册中心中找到远程方法对应的服务列表并通过某种策略从中选取一个服务地址来完成网络通信。</p>
</li>
<li><p>服务端：负责提供服务接口的真正实现并在某个端口上监听网络请求，监听到请求后从网络请求中获取到对应的参数（比如服务接口、方法、请求参数等），再根据这些参数通过反射的方式调用接口的真正实现获取结果并将其写入对应的响应流中。</p>
</li>
</ul>
<p>流程：</p>
<ol>
<li>Client注册客户端信息，Server注册服务接口。</li>
<li>Client初始化，从注册中心获取服务列表。</li>
<li>注册中心进行服务端上下线通知。</li>
<li>Client负载引擎选择服务节点。</li>
<li>Client封装请求为一个任务丢人线程池。</li>
<li>Client从缓存中获取连接（没有则创建并放入缓存中）</li>
<li>Client序列化编码，发送网络请求；Server反序列化解码。</li>
<li>Server从缓存中获取处理类，接口限流、反射调用获取结果。</li>
<li>Client响应请求结果。</li>
</ol>
<p>2</p>
</li>
<li><p>设计RPC步骤：</p>
<ol>
<li><strong>定义通信协议</strong>：定义调用的请求格式、传输协议等。</li>
<li><strong>接口定义和服务实现</strong>：定义服务接口（客户端和服务端共用），并在服务端实现该接口。</li>
<li><strong>序列化与反序列化</strong>：将请求参数、返回值序列化为可传输的数据格式（如 JSON、ProtoBuf 等）。</li>
<li><strong>网络通信</strong>：客户端通过网络（如 Socket、HTTP）发送请求，服务端接收并处理请求后返回结果。</li>
<li><strong>动态代理生成 Stub</strong>：客户端通过动态代理生成的 Stub，使远程调用透明化。</li>
<li><strong>负载均衡与容错处理</strong>（可选）：处理多个服务实例的选择和故障情况。</li>
</ol>
</li>
<li><p>实现：</p>
<ul>
<li><p><strong>服务端（生产者）</strong></p>
<ul>
<li><p>服务接口：在 RPC 中，生产者和消费者有一个共同的服务接口 API。如下，定义一个 HelloService 接口。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Descrption</span>  服务接口</span></span><br><span class="line"><span class="comment"> ***/</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">HelloService</span> </span>&#123;</span><br><span class="line">    <span class="function">String <span class="title">sayHello</span><span class="params">(String somebody)</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li><p>服务实现：生产者要提供服务接口的实现，创建 HelloServiceImpl 实现类。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Descrption</span> 服务实现</span></span><br><span class="line"><span class="comment"> ***/</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">HelloServiceImpl</span> <span class="keyword">implements</span> <span class="title">HelloService</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">sayHello</span><span class="params">(String somebody)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;hello &quot;</span> + somebody + <span class="string">&quot;!&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li><p>服务注册：本例使用 Spring 来管理 bean，采用自定义 XML 和解析器的方式来将服务实现类载入容器（当然也可以采用自定义注解的方式，此处不过多论述）并将服务接口信息注册到注册中心。</p>
<p>首先自定义 XSD：分别指定 Schema 和 XSD，Schema 和对应 Handler 的映射。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">&lt;xsd:element name=<span class="string">&quot;service&quot;</span>&gt;</span><br><span class="line">    <span class="xml"><span class="tag">&lt;<span class="name">xsd:complexType</span>&gt;</span></span></span><br><span class="line"><span class="xml">        <span class="tag">&lt;<span class="name">xsd:complexContent</span>&gt;</span></span></span><br><span class="line"><span class="xml">            <span class="tag">&lt;<span class="name">xsd:extension</span> <span class="attr">base</span>=<span class="string">&quot;beans:identifiedType&quot;</span>&gt;</span></span></span><br><span class="line"><span class="xml">                <span class="tag">&lt;<span class="name">xsd:attribute</span> <span class="attr">name</span>=<span class="string">&quot;interface&quot;</span> <span class="attr">type</span>=<span class="string">&quot;xsd:string&quot;</span> <span class="attr">use</span>=<span class="string">&quot;required&quot;</span>/&gt;</span></span></span><br><span class="line"><span class="xml">                <span class="tag">&lt;<span class="name">xsd:attribute</span> <span class="attr">name</span>=<span class="string">&quot;timeout&quot;</span> <span class="attr">type</span>=<span class="string">&quot;xsd:int&quot;</span> <span class="attr">use</span>=<span class="string">&quot;required&quot;</span>/&gt;</span></span></span><br><span class="line"><span class="xml">                <span class="tag">&lt;<span class="name">xsd:attribute</span> <span class="attr">name</span>=<span class="string">&quot;serverPort&quot;</span> <span class="attr">type</span>=<span class="string">&quot;xsd:int&quot;</span> <span class="attr">use</span>=<span class="string">&quot;required&quot;</span>/&gt;</span></span></span><br><span class="line"><span class="xml">                <span class="tag">&lt;<span class="name">xsd:attribute</span> <span class="attr">name</span>=<span class="string">&quot;ref&quot;</span> <span class="attr">type</span>=<span class="string">&quot;xsd:string&quot;</span> <span class="attr">use</span>=<span class="string">&quot;required&quot;</span>/&gt;</span></span></span><br><span class="line"><span class="xml">                <span class="tag">&lt;<span class="name">xsd:attribute</span> <span class="attr">name</span>=<span class="string">&quot;weight&quot;</span> <span class="attr">type</span>=<span class="string">&quot;xsd:int&quot;</span> <span class="attr">use</span>=<span class="string">&quot;optional&quot;</span>/&gt;</span></span></span><br><span class="line"><span class="xml">                <span class="tag">&lt;<span class="name">xsd:attribute</span> <span class="attr">name</span>=<span class="string">&quot;workerThreads&quot;</span> <span class="attr">type</span>=<span class="string">&quot;xsd:int&quot;</span> <span class="attr">use</span>=<span class="string">&quot;optional&quot;</span>/&gt;</span></span></span><br><span class="line"><span class="xml">                <span class="tag">&lt;<span class="name">xsd:attribute</span> <span class="attr">name</span>=<span class="string">&quot;appKey&quot;</span> <span class="attr">type</span>=<span class="string">&quot;xsd:string&quot;</span> <span class="attr">use</span>=<span class="string">&quot;required&quot;</span>/&gt;</span></span></span><br><span class="line"><span class="xml">                <span class="tag">&lt;<span class="name">xsd:attribute</span> <span class="attr">name</span>=<span class="string">&quot;groupName&quot;</span> <span class="attr">type</span>=<span class="string">&quot;xsd:string&quot;</span> <span class="attr">use</span>=<span class="string">&quot;optional&quot;</span>/&gt;</span></span></span><br><span class="line"><span class="xml">            <span class="tag">&lt;/<span class="name">xsd:extension</span>&gt;</span></span></span><br><span class="line"><span class="xml">        <span class="tag">&lt;/<span class="name">xsd:complexContent</span>&gt;</span></span></span><br><span class="line"><span class="xml">    <span class="tag">&lt;/<span class="name">xsd:complexType</span>&gt;</span></span></span><br><span class="line">&lt;/xsd:element&gt;</span><br></pre></td></tr></table></figure>

<p>Schema：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">http\:<span class="comment">//www.storm.com/schema/storm-service.xsd=META-INF/storm-service.xsd</span></span><br><span class="line">http\:<span class="comment">//www.storm.com/schema/storm-reference.xsd=META-INF/storm-reference.xsd</span></span><br></pre></td></tr></table></figure>

<p>Handler：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">http\:<span class="comment">//www.storm.com/schema/storm-service=com.hsunfkqm.storm.framework.spring.StormServiceNamespaceHandler</span></span><br><span class="line">http\:<span class="comment">//www.storm.com/schema/storm-reference=com.hsunfkqm.storm.framework.spring.StormRemoteReferenceNamespaceHandler</span></span><br></pre></td></tr></table></figure>

<p>将编写好的文件放入 Classpath 下的 META-INF 目录下：spring.handlers，spring.schemas，storm-service.xsd，storm-reference.xsd。</p>
<p>在 Spring 配置文件中配置服务类：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">&lt;!-- 发布远程服务 --&gt;</span><br><span class="line"> <span class="xml"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;helloService&quot;</span> <span class="attr">class</span>=<span class="string">&quot;com.hsunfkqm.storm.framework.test.HelloServiceImpl&quot;</span>/&gt;</span></span></span><br><span class="line"> <span class="xml"><span class="tag">&lt;<span class="name">storm:service</span> <span class="attr">id</span>=<span class="string">&quot;helloServiceRegister&quot;</span></span></span></span><br><span class="line"><span class="tag"><span class="xml">                     <span class="attr">interface</span>=<span class="string">&quot;com.hsunfkqm.storm.framework.test.HelloService&quot;</span></span></span></span><br><span class="line"><span class="tag"><span class="xml">                     <span class="attr">ref</span>=<span class="string">&quot;helloService&quot;</span></span></span></span><br><span class="line"><span class="tag"><span class="xml">                     <span class="attr">groupName</span>=<span class="string">&quot;default&quot;</span></span></span></span><br><span class="line"><span class="tag"><span class="xml">                     <span class="attr">weight</span>=<span class="string">&quot;2&quot;</span></span></span></span><br><span class="line"><span class="tag"><span class="xml">                     <span class="attr">appKey</span>=<span class="string">&quot;ares&quot;</span></span></span></span><br><span class="line"><span class="tag"><span class="xml">                     <span class="attr">workerThreads</span>=<span class="string">&quot;100&quot;</span></span></span></span><br><span class="line"><span class="tag"><span class="xml">                     <span class="attr">serverPort</span>=<span class="string">&quot;8081&quot;</span></span></span></span><br><span class="line"><span class="tag"><span class="xml">                     <span class="attr">timeout</span>=<span class="string">&quot;600&quot;</span>/&gt;</span></span></span><br></pre></td></tr></table></figure>

<p>编写对应的 Handler 和 Parser：</p>
<p>StormServiceNamespaceHandler：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> org.springframework.beans.factory.xml.NamespaceHandlerSupport;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 服务发布自定义标签</span></span><br><span class="line"><span class="comment"> ***/</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">StormServiceNamespaceHandler</span> <span class="keyword">extends</span> <span class="title">NamespaceHandlerSupport</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">init</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        registerBeanDefinitionParser(<span class="string">&quot;service&quot;</span>, <span class="keyword">new</span> ProviderFactoryBeanDefinitionParser());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>ProviderFactoryBeanDefinitionParser：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> Class <span class="title">getBeanClass</span><span class="params">(Element element)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> ProviderFactoryBean.class;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">doParse</span><span class="params">(Element element, BeanDefinitionBuilder bean)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            String serviceItf = element.getAttribute(<span class="string">&quot;interface&quot;</span>);</span><br><span class="line">            String serverPort = element.getAttribute(<span class="string">&quot;serverPort&quot;</span>);</span><br><span class="line">            String ref = element.getAttribute(<span class="string">&quot;ref&quot;</span>);</span><br><span class="line">            <span class="comment">// ....</span></span><br><span class="line">            bean.addPropertyValue(<span class="string">&quot;serverPort&quot;</span>, Integer.parseInt(serverPort));</span><br><span class="line">            bean.addPropertyValue(<span class="string">&quot;serviceItf&quot;</span>, Class.forName(serviceItf));</span><br><span class="line">            bean.addPropertyReference(<span class="string">&quot;serviceObject&quot;</span>, ref);</span><br><span class="line">            <span class="comment">//...</span></span><br><span class="line">            <span class="keyword">if</span> (NumberUtils.isNumber(weight)) &#123;</span><br><span class="line">                bean.addPropertyValue(<span class="string">&quot;weight&quot;</span>, Integer.parseInt(weight));</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//...</span></span><br><span class="line">       &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            <span class="comment">// ...        </span></span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<p>ProviderFactoryBean：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Descrption</span> 服务发布</span></span><br><span class="line"><span class="comment"> ***/</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ProviderFactoryBean</span> <span class="keyword">implements</span> <span class="title">FactoryBean</span>, <span class="title">InitializingBean</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//服务接口</span></span><br><span class="line">    <span class="keyword">private</span> Class&lt;?&gt; serviceItf;</span><br><span class="line">    <span class="comment">//服务实现</span></span><br><span class="line">    <span class="keyword">private</span> Object serviceObject;</span><br><span class="line">    <span class="comment">//服务端口</span></span><br><span class="line">    <span class="keyword">private</span> String serverPort;</span><br><span class="line">    <span class="comment">//服务超时时间</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">long</span> timeout;</span><br><span class="line">    <span class="comment">//服务代理对象，暂时没有用到</span></span><br><span class="line">    <span class="keyword">private</span> Object serviceProxyObject;</span><br><span class="line">    <span class="comment">//服务提供者唯一标识</span></span><br><span class="line">    <span class="keyword">private</span> String appKey;</span><br><span class="line">    <span class="comment">//服务分组组名</span></span><br><span class="line">    <span class="keyword">private</span> String groupName = <span class="string">&quot;default&quot;</span>;</span><br><span class="line">    <span class="comment">//服务提供者权重，默认为 1 , 范围为 [1-100]</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> weight = <span class="number">1</span>;</span><br><span class="line">    <span class="comment">//服务端线程数，默认 10 个线程</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> workerThreads = <span class="number">10</span>;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Object <span class="title">getObject</span><span class="params">()</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> serviceProxyObject;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> Class&lt;?&gt; getObjectType() &#123;</span><br><span class="line">        <span class="keyword">return</span> serviceItf;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">afterPropertiesSet</span><span class="params">()</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        <span class="comment">//启动 Netty 服务端</span></span><br><span class="line">        NettyServer.singleton().start(Integer.parseInt(serverPort));</span><br><span class="line">        <span class="comment">//注册到 zk, 元数据注册中心</span></span><br><span class="line">        List&lt;ProviderService&gt; providerServiceList = buildProviderServiceInfos();</span><br><span class="line">        IRegisterCenter4Provider registerCenter4Provider = RegisterCenter.singleton();</span><br><span class="line">        registerCenter4Provider.registerProvider(providerServiceList);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//================RegisterCenter#registerProvider======================</span></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">registerProvider</span><span class="params">(<span class="keyword">final</span> List&lt;ProviderService&gt; serviceMetaData)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (CollectionUtils.isEmpty(serviceMetaData)) &#123;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//连接 zk, 注册服务</span></span><br><span class="line">    <span class="keyword">synchronized</span> (RegisterCenter.class) &#123;</span><br><span class="line">        <span class="keyword">for</span> (ProviderService provider : serviceMetaData) &#123;</span><br><span class="line">            String serviceItfKey = provider.getServiceItf().getName();</span><br><span class="line"></span><br><span class="line">            List&lt;ProviderService&gt; providers = providerServiceMap.get(serviceItfKey);</span><br><span class="line">            <span class="keyword">if</span> (providers == <span class="keyword">null</span>) &#123;</span><br><span class="line">                providers = Lists.newArrayList();</span><br><span class="line">            &#125;</span><br><span class="line">            providers.add(provider);</span><br><span class="line">            providerServiceMap.put(serviceItfKey, providers);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (zkClient == <span class="keyword">null</span>) &#123;</span><br><span class="line">            zkClient = <span class="keyword">new</span> ZkClient(ZK_SERVICE, ZK_SESSION_TIME_OUT, ZK_CONNECTION_TIME_OUT, <span class="keyword">new</span> SerializableSerializer());</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//创建 ZK 命名空间/当前部署应用 APP 命名空间/</span></span><br><span class="line">        String APP_KEY = serviceMetaData.get(<span class="number">0</span>).getAppKey();</span><br><span class="line">        String ZK_PATH = ROOT_PATH + <span class="string">&quot;/&quot;</span> + APP_KEY;</span><br><span class="line">        <span class="keyword">boolean</span> exist = zkClient.exists(ZK_PATH);</span><br><span class="line">        <span class="keyword">if</span> (!exist) &#123;</span><br><span class="line">            zkClient.createPersistent(ZK_PATH, <span class="keyword">true</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (Map.Entry&lt;String, List&lt;ProviderService&gt;&gt; entry : providerServiceMap.entrySet()) &#123;</span><br><span class="line">            <span class="comment">//服务分组</span></span><br><span class="line">            String groupName = entry.getValue().get(<span class="number">0</span>).getGroupName();</span><br><span class="line">            <span class="comment">//创建服务提供者</span></span><br><span class="line">            String serviceNode = entry.getKey();</span><br><span class="line">            String servicePath = ZK_PATH + <span class="string">&quot;/&quot;</span> + groupName + <span class="string">&quot;/&quot;</span> + serviceNode + <span class="string">&quot;/&quot;</span> + PROVIDER_TYPE;</span><br><span class="line">            exist = zkClient.exists(servicePath);</span><br><span class="line">            <span class="keyword">if</span> (!exist) &#123;</span><br><span class="line">                zkClient.createPersistent(servicePath, <span class="keyword">true</span>);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="comment">//创建当前服务器节点</span></span><br><span class="line">            <span class="keyword">int</span> serverPort = entry.getValue().get(<span class="number">0</span>).getServerPort();<span class="comment">//服务端口</span></span><br><span class="line">            <span class="keyword">int</span> weight = entry.getValue().get(<span class="number">0</span>).getWeight();<span class="comment">//服务权重</span></span><br><span class="line">            <span class="keyword">int</span> workerThreads = entry.getValue().get(<span class="number">0</span>).getWorkerThreads();<span class="comment">//服务工作线程</span></span><br><span class="line">            String localIp = IPHelper.localIp();</span><br><span class="line">            String currentServiceIpNode = servicePath + <span class="string">&quot;/&quot;</span> + localIp + <span class="string">&quot;|&quot;</span> + serverPort + <span class="string">&quot;|&quot;</span> + weight + <span class="string">&quot;|&quot;</span> + workerThreads + <span class="string">&quot;|&quot;</span> + groupName;</span><br><span class="line">            exist = zkClient.exists(currentServiceIpNode);</span><br><span class="line">            <span class="keyword">if</span> (!exist) &#123;</span><br><span class="line">                <span class="comment">//注意，这里创建的是临时节点</span></span><br><span class="line">                zkClient.createEphemeral(currentServiceIpNode);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//监听注册服务的变化，同时更新数据到本地缓存</span></span><br><span class="line">            zkClient.subscribeChildChanges(servicePath, <span class="keyword">new</span> IZkChildListener() &#123;</span><br><span class="line">                <span class="meta">@Override</span></span><br><span class="line">                <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">handleChildChange</span><span class="params">(String parentPath, List&lt;String&gt; currentChilds)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">                    <span class="keyword">if</span> (currentChilds == <span class="keyword">null</span>) &#123;</span><br><span class="line">                        currentChilds = Lists.newArrayList();</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="comment">//存活的服务 IP 列表</span></span><br><span class="line">                    List&lt;String&gt; activityServiceIpList = Lists.newArrayList(Lists.transform(currentChilds, <span class="keyword">new</span> Function&lt;String, String&gt;() &#123;</span><br><span class="line">                        <span class="meta">@Override</span></span><br><span class="line">                        <span class="function"><span class="keyword">public</span> String <span class="title">apply</span><span class="params">(String input)</span> </span>&#123;</span><br><span class="line">                            <span class="keyword">return</span> StringUtils.split(input, <span class="string">&quot;|&quot;</span>)[<span class="number">0</span>];</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;));</span><br><span class="line">                    refreshActivityService(activityServiceIpList);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;);</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>至此服务实现类已被载入 Spring 容器中，且服务接口信息也注册到了注册中心。</p>
</li>
<li><p>网络通信：作为生产者对外提供 RPC 服务，必须有一个网络程序来来监听请求和做出响应。在 Java 领域 Netty 是一款高性能的 NIO 通信框架，很多的框架的通信都是采用 Netty 来实现的，本例中也采用它当做通信服务器。</p>
<p>构建并启动 Netty 服务监听指定端口：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">start</span><span class="params">(<span class="keyword">final</span> <span class="keyword">int</span> port)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">synchronized</span> (NettyServer.class) &#123;</span><br><span class="line">            <span class="keyword">if</span> (bossGroup != <span class="keyword">null</span> || workerGroup != <span class="keyword">null</span>) &#123;</span><br><span class="line">                <span class="keyword">return</span>;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            bossGroup = <span class="keyword">new</span> NioEventLoopGroup();</span><br><span class="line">            workerGroup = <span class="keyword">new</span> NioEventLoopGroup();</span><br><span class="line">            ServerBootstrap serverBootstrap = <span class="keyword">new</span> ServerBootstrap();</span><br><span class="line">            serverBootstrap</span><br><span class="line">                    .group(bossGroup, workerGroup)</span><br><span class="line">                    .channel(NioServerSocketChannel.class)</span><br><span class="line">                    .option(ChannelOption.SO_BACKLOG, <span class="number">1024</span>)</span><br><span class="line">                    .childOption(ChannelOption.SO_KEEPALIVE, <span class="keyword">true</span>)</span><br><span class="line">                    .childOption(ChannelOption.TCP_NODELAY, <span class="keyword">true</span>)</span><br><span class="line">                    .handler(<span class="keyword">new</span> LoggingHandler(LogLevel.INFO))</span><br><span class="line">                    .childHandler(<span class="keyword">new</span> ChannelInitializer&lt;SocketChannel&gt;() &#123;</span><br><span class="line">                        <span class="meta">@Override</span></span><br><span class="line">                        <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">initChannel</span><span class="params">(SocketChannel ch)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">                            <span class="comment">//注册解码器 NettyDecoderHandler</span></span><br><span class="line">                            ch.pipeline().addLast(<span class="keyword">new</span> NettyDecoderHandler(StormRequest.class, serializeType));</span><br><span class="line">                            <span class="comment">//注册编码器 NettyEncoderHandler</span></span><br><span class="line">                            ch.pipeline().addLast(<span class="keyword">new</span> NettyEncoderHandler(serializeType));</span><br><span class="line">                            <span class="comment">//注册服务端业务逻辑处理器 NettyServerInvokeHandler</span></span><br><span class="line">                            ch.pipeline().addLast(<span class="keyword">new</span> NettyServerInvokeHandler());</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;);</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                channel = serverBootstrap.bind(port).sync().channel();</span><br><span class="line">            &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException(e);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<p>上面的代码中向 Netty 服务的 Pipeline 中添加了编解码和业务处理器，当接收到请求时，经过编解码后，真正处理业务的是业务处理器，即 NettyServerInvokeHandler，该处理器继承自 SimpleChannelInboundHandler，当数据读取完成将触发一个事件，并调用 NettyServerInvokeHandler#channelRead0 方法来处理请求。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">channelRead0</span><span class="params">(ChannelHandlerContext ctx, StormRequest request)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (ctx.channel().isWritable()) &#123;</span><br><span class="line">        <span class="comment">//从服务调用对象里获取服务提供者信息</span></span><br><span class="line">        ProviderService metaDataModel = request.getProviderService();</span><br><span class="line">        <span class="keyword">long</span> consumeTimeOut = request.getInvokeTimeout();</span><br><span class="line">        <span class="keyword">final</span> String methodName = request.getInvokedMethodName();</span><br><span class="line"></span><br><span class="line">        <span class="comment">//根据方法名称定位到具体某一个服务提供者</span></span><br><span class="line">        String serviceKey = metaDataModel.getServiceItf().getName();</span><br><span class="line">        <span class="comment">//获取限流工具类</span></span><br><span class="line">        <span class="keyword">int</span> workerThread = metaDataModel.getWorkerThreads();</span><br><span class="line">        Semaphore semaphore = serviceKeySemaphoreMap.get(serviceKey);</span><br><span class="line">        <span class="keyword">if</span> (semaphore == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">synchronized</span> (serviceKeySemaphoreMap) &#123;</span><br><span class="line">                semaphore = serviceKeySemaphoreMap.get(serviceKey);</span><br><span class="line">                <span class="keyword">if</span> (semaphore == <span class="keyword">null</span>) &#123;</span><br><span class="line">                    semaphore = <span class="keyword">new</span> Semaphore(workerThread);</span><br><span class="line">                    serviceKeySemaphoreMap.put(serviceKey, semaphore);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//获取注册中心服务</span></span><br><span class="line">        IRegisterCenter4Provider registerCenter4Provider = RegisterCenter.singleton();</span><br><span class="line">        List&lt;ProviderService&gt; localProviderCaches = registerCenter4Provider.getProviderServiceMap().get(serviceKey);</span><br><span class="line"></span><br><span class="line">        Object result = <span class="keyword">null</span>;</span><br><span class="line">        <span class="keyword">boolean</span> acquire = <span class="keyword">false</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            ProviderService localProviderCache = Collections2.filter(localProviderCaches, <span class="keyword">new</span> Predicate&lt;ProviderService&gt;() &#123;</span><br><span class="line">                <span class="meta">@Override</span></span><br><span class="line">                <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">apply</span><span class="params">(ProviderService input)</span> </span>&#123;</span><br><span class="line">                    <span class="keyword">return</span> StringUtils.equals(input.getServiceMethod().getName(), methodName);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;).iterator().next();</span><br><span class="line">            Object serviceObject = localProviderCache.getServiceObject();</span><br><span class="line"></span><br><span class="line">            <span class="comment">//利用反射发起服务调用</span></span><br><span class="line">            Method method = localProviderCache.getServiceMethod();</span><br><span class="line">            <span class="comment">//利用 semaphore 实现限流</span></span><br><span class="line">            acquire = semaphore.tryAcquire(consumeTimeOut, TimeUnit.MILLISECONDS);</span><br><span class="line">            <span class="keyword">if</span> (acquire) &#123;</span><br><span class="line">                result = method.invoke(serviceObject, request.getArgs());</span><br><span class="line">                <span class="comment">//System.out.println(&quot;---------------&quot;+result);</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            System.out.println(JSON.toJSONString(localProviderCaches) + <span class="string">&quot;  &quot;</span> + methodName+<span class="string">&quot; &quot;</span>+e.getMessage());</span><br><span class="line">            result = e;</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            <span class="keyword">if</span> (acquire) &#123;</span><br><span class="line">                semaphore.release();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//根据服务调用结果组装调用返回对象</span></span><br><span class="line">        StormResponse response = <span class="keyword">new</span> StormResponse();</span><br><span class="line">        response.setInvokeTimeout(consumeTimeOut);</span><br><span class="line">        response.setUniqueKey(request.getUniqueKey());</span><br><span class="line">        response.setResult(result);</span><br><span class="line">        <span class="comment">//将服务调用返回对象回写到消费端</span></span><br><span class="line">        ctx.writeAndFlush(response);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        logger.error(<span class="string">&quot;------------channel closed!---------------&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>此处还有部分细节如自定义的编解码器等，篇幅所限不在此详述，继承 MessageToByteEncoder 和 ByteToMessageDecoder 覆写对应的 encode 和 decode 方法即可自定义编解码器，使用到的序列化工具如 Hessian/Proto 等可参考对应的官方文档。</p>
<p>请求和响应包装：</p>
<p>为便于封装请求和响应，定义两个 bean 来表示请求和响应。</p>
<p>请求：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> ***/</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">StormRequest</span> <span class="keyword">implements</span> <span class="title">Serializable</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">long</span> serialVersionUID = -<span class="number">5196465012408804755L</span>;</span><br><span class="line">    <span class="comment">//UUID，唯一标识一次返回值</span></span><br><span class="line">    <span class="keyword">private</span> String uniqueKey;</span><br><span class="line">    <span class="comment">//服务提供者信息</span></span><br><span class="line">    <span class="keyword">private</span> ProviderService providerService;</span><br><span class="line">    <span class="comment">//调用的方法名称</span></span><br><span class="line">    <span class="keyword">private</span> String invokedMethodName;</span><br><span class="line">    <span class="comment">//传递参数</span></span><br><span class="line">    <span class="keyword">private</span> Object[] args;</span><br><span class="line">    <span class="comment">//消费端应用名</span></span><br><span class="line">    <span class="keyword">private</span> String appName;</span><br><span class="line">    <span class="comment">//消费请求超时时长</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">long</span> invokeTimeout;</span><br><span class="line">    <span class="comment">// getter/setter</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>响应：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> ***/</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">StormResponse</span> <span class="keyword">implements</span> <span class="title">Serializable</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">long</span> serialVersionUID = <span class="number">5785265307118147202L</span>;</span><br><span class="line">    <span class="comment">//UUID, 唯一标识一次返回值</span></span><br><span class="line">    <span class="keyword">private</span> String uniqueKey;</span><br><span class="line">    <span class="comment">//客户端指定的服务超时时间</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">long</span> invokeTimeout;</span><br><span class="line">    <span class="comment">//接口调用返回的结果对象</span></span><br><span class="line">    <span class="keyword">private</span> Object result;</span><br><span class="line">    <span class="comment">//getter/setter</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
</li>
<li><p><strong>客户端（消费者）</strong>：</p>
<p>客户端（消费者）在 RPC 调用中主要是生成服务接口的代理对象，并从注册中心获取对应的服务列表发起网络请求。</p>
<p>客户端和服务端一样采用 Spring 来管理 bean 解析 XML 配置等不再赘述，重点看下以下几点：</p>
<ol>
<li><p>通过 JDK 动态代理来生成引入服务接口的代理对象：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> Object <span class="title">getProxy</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> Proxy.newProxyInstance(Thread.currentThread().getContextClassLoader(), <span class="keyword">new</span> Class&lt;?&gt;[]&#123;targetInterface&#125;, <span class="keyword">this</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li><p>从注册中心获取服务列表并依据某种策略选取其中一个服务节点</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//服务接口名称</span></span><br><span class="line">String serviceKey = targetInterface.getName();</span><br><span class="line"><span class="comment">//获取某个接口的服务提供者列表</span></span><br><span class="line">IRegisterCenter4Invoker registerCenter4Consumer = RegisterCenter.singleton();</span><br><span class="line">List&lt;ProviderService&gt; providerServices = registerCenter4Consumer.getServiceMetaDataMap4Consume().get(serviceKey);</span><br><span class="line"><span class="comment">//根据软负载策略，从服务提供者列表选取本次调用的服务提供者</span></span><br><span class="line">ClusterStrategy clusterStrategyService = ClusterEngine.queryClusterStrategy(clusterStrategy);</span><br><span class="line">ProviderService providerService = clusterStrategyService.select(providerServices);</span><br></pre></td></tr></table></figure></li>
<li><p>通过 Netty 建立连接，发起网络请求。Netty 的响应是异步的，为了在方法调用返回前获取到响应结果，需要将异步的结果同步化。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 欢迎关注公众号：java后端技术全栈</span></span><br><span class="line"><span class="comment"> ***/</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">RevokerProxyBeanFactory</span> <span class="keyword">implements</span> <span class="title">InvocationHandler</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> ExecutorService fixedThreadPool = <span class="keyword">null</span>;</span><br><span class="line">    <span class="comment">//服务接口</span></span><br><span class="line">    <span class="keyword">private</span> Class&lt;?&gt; targetInterface;</span><br><span class="line">    <span class="comment">//超时时间</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> consumeTimeout;</span><br><span class="line">    <span class="comment">//调用者线程数</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">int</span> threadWorkerNumber = <span class="number">10</span>;</span><br><span class="line">    <span class="comment">//负载均衡策略</span></span><br><span class="line">    <span class="keyword">private</span> String clusterStrategy;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Object <span class="title">invoke</span><span class="params">(Object proxy, Method method, Object[] args)</span> <span class="keyword">throws</span> Throwable </span>&#123;</span><br><span class="line"></span><br><span class="line">        ...</span><br><span class="line"></span><br><span class="line">        <span class="comment">//复制一份服务提供者信息</span></span><br><span class="line">        ProviderService newProvider = providerService.copy();</span><br><span class="line">        <span class="comment">//设置本次调用服务的方法以及接口</span></span><br><span class="line">        newProvider.setServiceMethod(method);</span><br><span class="line">        newProvider.setServiceItf(targetInterface);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//声明调用 AresRequest 对象，AresRequest 表示发起一次调用所包含的信息</span></span><br><span class="line">        <span class="keyword">final</span> StormRequest request = <span class="keyword">new</span> StormRequest();</span><br><span class="line">        <span class="comment">//设置本次调用的唯一标识</span></span><br><span class="line">        request.setUniqueKey(UUID.randomUUID().toString() + <span class="string">&quot;-&quot;</span> + Thread.currentThread().getId());</span><br><span class="line">        <span class="comment">//设置本次调用的服务提供者信息</span></span><br><span class="line">        request.setProviderService(newProvider);</span><br><span class="line">        <span class="comment">//设置本次调用的方法名称</span></span><br><span class="line">        request.setInvokedMethodName(method.getName());</span><br><span class="line">        <span class="comment">//设置本次调用的方法参数信息</span></span><br><span class="line">        request.setArgs(args);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">//构建用来发起调用的线程池</span></span><br><span class="line">            <span class="keyword">if</span> (fixedThreadPool == <span class="keyword">null</span>) &#123;</span><br><span class="line">                <span class="keyword">synchronized</span> (RevokerProxyBeanFactory.class) &#123;</span><br><span class="line">                    <span class="keyword">if</span> (<span class="keyword">null</span> == fixedThreadPool) &#123;</span><br><span class="line">                        fixedThreadPool = Executors.newFixedThreadPool(threadWorkerNumber);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//根据服务提供者的 ip,port, 构建 InetSocketAddress 对象，标识服务提供者地址</span></span><br><span class="line">            String serverIp = request.getProviderService().getServerIp();</span><br><span class="line">            <span class="keyword">int</span> serverPort = request.getProviderService().getServerPort();</span><br><span class="line">            InetSocketAddress inetSocketAddress = <span class="keyword">new</span> InetSocketAddress(serverIp, serverPort);</span><br><span class="line">            <span class="comment">//提交本次调用信息到线程池 fixedThreadPool, 发起调用</span></span><br><span class="line">            Future&lt;StormResponse&gt; responseFuture = fixedThreadPool.submit(RevokerServiceCallable.of(inetSocketAddress, request));</span><br><span class="line">            <span class="comment">//获取调用的返回结果</span></span><br><span class="line">            StormResponse response = responseFuture.get(request.getInvokeTimeout(), TimeUnit.MILLISECONDS);</span><br><span class="line">            <span class="keyword">if</span> (response != <span class="keyword">null</span>) &#123;</span><br><span class="line">                <span class="keyword">return</span> response.getResult();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException(e);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//  ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li><p>Netty 异步返回的结果存入阻塞队列</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">channelRead0</span><span class="params">(ChannelHandlerContext channelHandlerContext, StormResponse response)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">    <span class="comment">//将 Netty 异步返回的结果存入阻塞队列，以便调用端同步获取</span></span><br><span class="line">    RevokerResponseHolder.putResultValue(response);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li><p>请求发出后同步获取结果</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//提交本次调用信息到线程池 fixedThreadPool, 发起调用</span></span><br><span class="line">Future&lt;StormResponse&gt; responseFuture = fixedThreadPool.submit(RevokerServiceCallable.of(inetSocketAddress, request));</span><br><span class="line"><span class="comment">//获取调用的返回结果</span></span><br><span class="line">StormResponse response = responseFuture.get(request.getInvokeTimeout(), TimeUnit.MILLISECONDS);</span><br><span class="line"><span class="keyword">if</span> (response != <span class="keyword">null</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> response.getResult();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//===================================================</span></span><br><span class="line"><span class="comment">//从返回结果容器中获取返回结果，同时设置等待超时时间为 invokeTimeout</span></span><br><span class="line"><span class="keyword">long</span> invokeTimeout = request.getInvokeTimeout();</span><br><span class="line">StormResponse response = RevokerResponseHolder.getValue(request.getUniqueKey(), invokeTimeout);</span><br></pre></td></tr></table></figure></li>
</ol>
</li>
<li><p><strong>测试</strong></p>
<p>Server：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MainServer</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        <span class="comment">//发布服务</span></span><br><span class="line">        <span class="keyword">final</span> ClassPathXmlApplicationContext context = <span class="keyword">new</span> ClassPathXmlApplicationContext(<span class="string">&quot;storm-server.xml&quot;</span>);</span><br><span class="line">        System.out.println(<span class="string">&quot; 服务发布完成&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>Client：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Client</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> Logger logger = LoggerFactory.getLogger(Client.class);</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">final</span> ClassPathXmlApplicationContext context = <span class="keyword">new</span> ClassPathXmlApplicationContext(<span class="string">&quot;storm-client.xml&quot;</span>);</span><br><span class="line">        <span class="keyword">final</span> HelloService helloService = (HelloService) context.getBean(<span class="string">&quot;helloService&quot;</span>);</span><br><span class="line">        String result = helloService.sayHello(<span class="string">&quot;World&quot;</span>);</span><br><span class="line">        System.out.println(result);</span><br><span class="line">        <span class="keyword">for</span> (;;) &#123;</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li></li>
</ul>
</li>
<li></li>
</ul>
<p><a target="_blank" rel="noopener" href="https://itmtx.cn/column/11">https://itmtx.cn/column/11</a></p>
<p><a target="_blank" rel="noopener" href="https://github.com/Veal98/RPC-FromScratch">https://github.com/Veal98/RPC-FromScratch</a></p>
<h4 id="问：线程间的通信可以怎么做？线程间相互通知你会怎么做，代码要怎么实现？⭐⭐"><a href="#问：线程间的通信可以怎么做？线程间相互通知你会怎么做，代码要怎么实现？⭐⭐" class="headerlink" title="问：线程间的通信可以怎么做？线程间相互通知你会怎么做，代码要怎么实现？⭐⭐"></a>问：线程间的通信可以怎么做？线程间相互通知你会怎么做，代码要怎么实现？⭐⭐</h4><p>线程间的通信可以怎么做？</p>
<ol>
<li><p>使用synchronized + <code>wait</code> / <code>notify</code> / <code>notifyAll</code> 实现线程间通信，调用这些方法前线程必须获得对象锁。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">SharedData</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> data;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">boolean</span> available = <span class="keyword">false</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">produce</span><span class="params">(<span class="keyword">int</span> value)</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">        <span class="keyword">while</span> (available) &#123; <span class="comment">// 如果已有数据，等待消费者消费</span></span><br><span class="line">            wait();</span><br><span class="line">        &#125;</span><br><span class="line">        data = value;</span><br><span class="line">        available = <span class="keyword">true</span>;</span><br><span class="line">        System.out.println(<span class="string">&quot;Produced: &quot;</span> + data);</span><br><span class="line">        notifyAll(); <span class="comment">// 通知消费者</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">consume</span><span class="params">()</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">        <span class="keyword">while</span> (!available) &#123; <span class="comment">// 如果无数据，等待生产者生产</span></span><br><span class="line">            wait();</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(<span class="string">&quot;Consumed: &quot;</span> + data);</span><br><span class="line">        available = <span class="keyword">false</span>;</span><br><span class="line">        notifyAll(); <span class="comment">// 通知生产者</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">WaitNotifyExample</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        SharedData sharedData = <span class="keyword">new</span> SharedData();</span><br><span class="line"></span><br><span class="line">        Thread producer = <span class="keyword">new</span> Thread(() -&gt; &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">5</span>; i++) &#123;</span><br><span class="line">                    sharedData.produce(i);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                Thread.currentThread().interrupt();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line"></span><br><span class="line">        Thread consumer = <span class="keyword">new</span> Thread(() -&gt; &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">5</span>; i++) &#123;</span><br><span class="line">                    sharedData.consume();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                Thread.currentThread().interrupt();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line"></span><br><span class="line">        producer.start();</span><br><span class="line">        consumer.start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li><p>使用 <code>Lock</code> 和 <code>Condition</code> 实现线程间通信：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.concurrent.locks.Condition;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.locks.Lock;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.locks.ReentrantLock;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">SharedResource</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> data;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">boolean</span> available = <span class="keyword">false</span>;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> Lock lock = <span class="keyword">new</span> ReentrantLock();</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> Condition produced = lock.newCondition();</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> Condition consumed = lock.newCondition();</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">produce</span><span class="params">(<span class="keyword">int</span> value)</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">        lock.lock();</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">while</span> (available) &#123;</span><br><span class="line">                produced.await(); <span class="comment">// 等待消费者消费数据</span></span><br><span class="line">            &#125;</span><br><span class="line">            data = value;</span><br><span class="line">            available = <span class="keyword">true</span>;</span><br><span class="line">            System.out.println(<span class="string">&quot;Produced: &quot;</span> + data);</span><br><span class="line">            consumed.signal(); <span class="comment">// 通知消费者可以消费了</span></span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            lock.unlock();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">consume</span><span class="params">()</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">        lock.lock();</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">while</span> (!available) &#123;</span><br><span class="line">                consumed.await(); <span class="comment">// 等待生产者生产数据</span></span><br><span class="line">            &#125;</span><br><span class="line">            System.out.println(<span class="string">&quot;Consumed: &quot;</span> + data);</span><br><span class="line">            available = <span class="keyword">false</span>;</span><br><span class="line">            produced.signal(); <span class="comment">// 通知生产者可以生产了</span></span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            lock.unlock();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">LockConditionExample</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        SharedResource sharedResource = <span class="keyword">new</span> SharedResource();</span><br><span class="line"></span><br><span class="line">        Thread producer = <span class="keyword">new</span> Thread(() -&gt; &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">5</span>; i++) &#123;</span><br><span class="line">                    sharedResource.produce(i);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                Thread.currentThread().interrupt();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line"></span><br><span class="line">        Thread consumer = <span class="keyword">new</span> Thread(() -&gt; &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">5</span>; i++) &#123;</span><br><span class="line">                    sharedResource.consume();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                Thread.currentThread().interrupt();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line"></span><br><span class="line">        producer.start();</span><br><span class="line">        consumer.start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li><p>使用 <code>BlockingQueue</code> 实现线程间通信：是线程安全的队列，可以用于生产者-消费者模式。生产者可以往队列中放数据，消费者从队列中取数据，自动阻塞和唤醒，无需显式的同步代码。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">BlockingQueueExample</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        BlockingQueue&lt;Integer&gt; queue = <span class="keyword">new</span> ArrayBlockingQueue&lt;&gt;(<span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">        Thread producer = <span class="keyword">new</span> Thread(() -&gt; &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">5</span>; i++) &#123;</span><br><span class="line">                    queue.put(i);</span><br><span class="line">                    System.out.println(<span class="string">&quot;Produced: &quot;</span> + i);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                Thread.currentThread().interrupt();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line"></span><br><span class="line">        Thread consumer = <span class="keyword">new</span> Thread(() -&gt; &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">5</span>; i++) &#123;</span><br><span class="line">                    <span class="keyword">int</span> data = queue.take();</span><br><span class="line">                    System.out.println(<span class="string">&quot;Consumed: &quot;</span> + data);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                Thread.currentThread().interrupt();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line"></span><br><span class="line">        producer.start();</span><br><span class="line">        consumer.start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ol>
<p><strong>4. <code>Semaphore</code></strong></p>
<p>信号量控制资源访问数量，可以实现限流或同步控制。</p>
<figure class="highlight reasonml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">javaCopyEditimport java.util.concurrent.Semaphore;</span><br><span class="line"></span><br><span class="line">public <span class="keyword">class</span> SemaphoreExample &#123;</span><br><span class="line">    public static void main(String<span class="literal">[]</span> args) &#123;</span><br><span class="line">        Semaphore semaphore = <span class="keyword">new</span> <span class="constructor">Semaphore(1)</span>; <span class="comment">// 允许一个线程访问</span></span><br><span class="line"></span><br><span class="line">        Runnable task = <span class="literal">()</span> -&gt; &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                semaphore.acquire<span class="literal">()</span>; <span class="comment">// 获取许可</span></span><br><span class="line">                <span class="module-access"><span class="module"><span class="identifier">System</span>.</span></span>out.println(<span class="module-access"><span class="module"><span class="identifier">Thread</span>.</span></span>current<span class="constructor">Thread()</span>.get<span class="constructor">Name()</span> + <span class="string">&quot; 执行任务&quot;</span>);</span><br><span class="line">                <span class="module-access"><span class="module"><span class="identifier">Thread</span>.</span></span>sleep(<span class="number">2000</span>); <span class="comment">// 模拟任务耗时</span></span><br><span class="line">            &#125; catch (InterruptedException e) &#123;</span><br><span class="line">                e.print<span class="constructor">StackTrace()</span>;</span><br><span class="line">            &#125; finally &#123;</span><br><span class="line">                semaphore.release<span class="literal">()</span>; <span class="comment">// 释放许可</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">new</span> <span class="constructor">Thread(<span class="params">task</span>)</span>.start<span class="literal">()</span>;</span><br><span class="line">        <span class="keyword">new</span> <span class="constructor">Thread(<span class="params">task</span>)</span>.start<span class="literal">()</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>5. <code>CountDownLatch</code> / <code>CyclicBarrier</code></strong></p>
<ul>
<li><strong>CountDownLatch</strong>：等待多个线程完成某个任务</li>
<li><strong>CyclicBarrier</strong>：让多个线程在某个点上等待</li>
</ul>
<figure class="highlight reasonml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">javaCopyEditimport java.util.concurrent.CountDownLatch;</span><br><span class="line"></span><br><span class="line">public <span class="keyword">class</span> CountDownLatchExample &#123;</span><br><span class="line">    public static void main(String<span class="literal">[]</span> args) throws InterruptedException &#123;</span><br><span class="line">        CountDownLatch latch = <span class="keyword">new</span> <span class="constructor">CountDownLatch(3)</span>;</span><br><span class="line"></span><br><span class="line">        Runnable task = <span class="literal">()</span> -&gt; &#123;</span><br><span class="line">            <span class="module-access"><span class="module"><span class="identifier">System</span>.</span></span>out.println(<span class="module-access"><span class="module"><span class="identifier">Thread</span>.</span></span>current<span class="constructor">Thread()</span>.get<span class="constructor">Name()</span> + <span class="string">&quot; 完成任务&quot;</span>);</span><br><span class="line">            latch.count<span class="constructor">Down()</span>; <span class="comment">// 计数器减一</span></span><br><span class="line">        &#125;;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">new</span> <span class="constructor">Thread(<span class="params">task</span>)</span>.start<span class="literal">()</span>;</span><br><span class="line">        <span class="keyword">new</span> <span class="constructor">Thread(<span class="params">task</span>)</span>.start<span class="literal">()</span>;</span><br><span class="line">        <span class="keyword">new</span> <span class="constructor">Thread(<span class="params">task</span>)</span>.start<span class="literal">()</span>;</span><br><span class="line"></span><br><span class="line">        latch.await<span class="literal">()</span>; <span class="comment">// 等待计数器变为 0</span></span><br><span class="line">        <span class="module-access"><span class="module"><span class="identifier">System</span>.</span></span>out.println(<span class="string">&quot;所有任务完成&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>6. <code>volatile</code> 关键字</strong></p>
<p>保证变量的<strong>可见性</strong>，适用于轻量级通信。</p>
<p><strong>7. <code>Future</code> / <code>CompletableFuture</code></strong></p>
<p>适用于<strong>异步任务</strong>，获取结果或处理异常。</p>
<h4 id="问：notify-与notifyAll-的区别？"><a href="#问：notify-与notifyAll-的区别？" class="headerlink" title="问：notify()与notifyAll()的区别？"></a>问：notify()与notifyAll()的区别？</h4><ul>
<li>**<code>notify()</code>**：该方法随机唤醒在对象监视器上等待的单个线程。如果有多个线程在等待，具体唤醒哪个线程是不可预测的，这通常由 JVM 的线程调度策略决定。</li>
<li>**<code>notifyAll()</code>**：该方法唤醒在对象监视器上等待的所有线程。这些线程会被唤醒并进入可运行状态，但并不意味着它们会立即开始执行。它们会等待重新获得对象的锁。</li>
</ul>
<p>当调用 <code>notifyAll()</code> 时，所有等待该对象监视器的线程会被唤醒，并进入可运行状态。但是，这些线程仍需竞争对象的锁，只有获取到锁的线程才能继续执行。具体步骤如下：</p>
<ol>
<li><strong>唤醒所有线程</strong>：调用 <code>notifyAll()</code> 后，所有等待该对象监视器的线程会被唤醒。</li>
<li><strong>竞争锁</strong>：被唤醒的线程不会立刻执行，而是进入可运行状态。它们必须争夺对象的锁，只有获得锁的线程才能继续执行。</li>
<li><strong>锁的排他性</strong>：由于 <code>synchronized</code> 方法或块的排他性，只有一个线程可以持有该对象的锁。其他线程即使被唤醒，必须等待该线程释放锁才能继续执行。</li>
</ol>
<p>安全性考虑</p>
<ul>
<li><strong>使用 <code>notify()</code> 的场景</strong>：如果你清楚在某一时刻只有一个消费者或者一个生产者可以处理数据，并且你只希望唤醒一个线程，那么 <code>notify()</code> 是合适的。</li>
<li><strong>使用 <code>notifyAll()</code> 的场景</strong>：如果你有多个消费者或生产者并且任何一个都可能适合处理共享资源，使用 <code>notifyAll()</code> 更为安全，尽管它会唤醒所有等待的线程。使用 <code>notifyAll()</code> 可以避免饥饿现象（即某些线程永远得不到执行机会），但可能会增加上下文切换的开销。</li>
</ul>
<hr>
<h3 id="1-2-ThreadLocal"><a href="#1-2-ThreadLocal" class="headerlink" title="1.2 ThreadLocal"></a>1.2 ThreadLocal</h3><h4 id="问：谈一下ThreadLocal？应用场景？原理？与-Thread-类的关系？⭐"><a href="#问：谈一下ThreadLocal？应用场景？原理？与-Thread-类的关系？⭐" class="headerlink" title="问：谈一下ThreadLocal？应用场景？原理？与 Thread 类的关系？⭐"></a>问：谈一下ThreadLocal？应用场景？原理？与 Thread 类的关系？⭐</h4><ul>
<li><p>什么是ThreadLocal？</p>
<ul>
<li><code>ThreadLocal</code> 是 Java 中的一个类，用于<strong>创建线程局部变量</strong>。每个线程都可以通过 <code>ThreadLocal</code> 来创建和使用自己的变量副本，这些<strong>副本是线程隔离的</strong>，互不影响。这样可以方便地在多线程环境中存储线程特定的数据。</li>
</ul>
</li>
<li><p>应用场景：</p>
<ol>
<li><p><strong>用户会话管理</strong>：在 web 应用中，使用 <code>ThreadLocal</code> 存储用户的会话信息，使得每个线程在处理请求时能够访问该信息，而不会互相干扰。</p>
</li>
<li><p><strong>数据库连接</strong>：可以用 <code>ThreadLocal</code> 存储数据库连接对象connection，确保每个线程使用自己的连接，避免竞争条件和连接共享。</p>
</li>
<li><p><strong>事务管理</strong>：在一些框架中，例如 Spring，可以使用 <code>ThreadLocal</code> 来管理事务的上下文，使得事务在每个线程中独立处理。</p>
</li>
<li><p><strong>单例模式</strong>：可以用 <code>ThreadLocal</code> 来实现线程安全的单例对象，在多线程环境下确保每个线程都使用自己的单例实例。</p>
</li>
<li><p><strong>解决simpleDateFormat线程安全问题</strong>：<code>SimpleDateFormat</code> 是非线程安全的，因此在多线程环境中使用时，多个线程同时访问同一个 <code>SimpleDateFormat</code> 实例会导致数据竞争和错误的结果。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ThreadLocalDateFormatExample</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 使用 ThreadLocal 创建一个 SimpleDateFormat 实例</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> ThreadLocal&lt;SimpleDateFormat&gt; dateFormatThreadLocal =</span><br><span class="line">        ThreadLocal.withInitial(() -&gt; <span class="keyword">new</span> SimpleDateFormat(<span class="string">&quot;yyyy-MM-dd&quot;</span>));</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Runnable task = () -&gt; &#123;</span><br><span class="line">            <span class="comment">// 每个线程使用自己的 SimpleDateFormat 实例</span></span><br><span class="line">            SimpleDateFormat sdf = dateFormatThreadLocal.get();</span><br><span class="line">            String dateStr = sdf.format(<span class="keyword">new</span> Date());</span><br><span class="line">            System.out.println(<span class="string">&quot;Thread: &quot;</span> + Thread.currentThread().getName() + <span class="string">&quot; - Date: &quot;</span> + dateStr);</span><br><span class="line">        &#125;;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 创建多个线程</span></span><br><span class="line">        Thread thread1 = <span class="keyword">new</span> Thread(task);</span><br><span class="line">        Thread thread2 = <span class="keyword">new</span> Thread(task);</span><br><span class="line">        thread1.start();</span><br><span class="line">        thread2.start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li><p><strong>可能出现内存泄漏</strong>：</p>
<ul>
<li><code>ThreadLocal</code> 持有对其键的强引用（即 <code>Thread</code> 对象），如果 <code>Thread</code> 对象长时间存活而没有被回收，<code>ThreadLocal</code> 的值（如 <code>SimpleDateFormat</code> 实例）也将无法被回收，造成内存泄漏。</li>
<li>线程池中的线程通常会被复用，而不是在完成任务后就被销毁。因此，即使某个线程不再需要 <code>ThreadLocal</code> 存储的值，该值仍然会存在于 <code>ThreadLocalMap</code> 中，直到线程池中的线程被回收（通常不会发生，因为线程池在应用生命周期内保持存活）。这意味着，若不手动调用 <code>remove()</code> 方法来清除不再需要的 <code>ThreadLocal</code> 值，可能会导致内存泄漏。不要与线程池配合，因为worker往往是不会退出的；</li>
<li>所以建议不再需要 <code>ThreadLocal</code> 变量时，显式调用 <code>remove()</code> 方法，以清理 <code>ThreadLocalMap</code> 中的条目，避免内存泄漏。</li>
</ul>
</li>
</ol>
</li>
<li><p>原理：每个线程都有一个独立的 <code>ThreadLocalMap</code>，对应成员变量threadLocals，key为本身，value为实际存值的变量副本。</p>
<ul>
<li><strong>每个线程都有一个 ThreadLocalMap</strong>：当线程访问 <code>ThreadLocal</code> 的 <code>get()</code> 或 <code>set()</code> 方法时，会通过 <code>Thread</code> 类的 <code>threadLocalMap</code> 属性获取到当前线程的 <code>ThreadLocalMap</code> 实例。</li>
<li><strong>存储与检索</strong>：<code>ThreadLocalMap</code> 以 <code>ThreadLocal</code> 对象作为键，线程的值作为值，这样每个线程都可以存取自己的值。</li>
<li><strong>垃圾回收</strong>：如果一个 <code>ThreadLocal</code> 对象不再被使用（没有强引用），那么它在 <code>ThreadLocalMap</code> 中的值会被保留，直到该线程结束。如果线程不再使用，可以通过 <code>remove()</code> 方法清除相应的值，以避免内存泄漏。</li>
</ul>
</li>
<li><p>与 Thread 类的关系：</p>
<ul>
<li><code>ThreadLocal</code> 不是 <code>Thread</code> 类的子类，但它是与 <code>Thread</code> 类密切相关的。每个 <code>Thread</code> 对象内部都有一个 <code>ThreadLocalMap</code>，这个 <code>ThreadLocalMap</code> 存储了该线程使用的 <code>ThreadLocal</code> 变量及其对应的值。</li>
</ul>
</li>
<li><p>案例：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ThreadLocalExample</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 创建一个 ThreadLocal 变量</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> ThreadLocal&lt;Integer&gt; threadLocalValue = ThreadLocal.withInitial(() -&gt; <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 创建多个线程</span></span><br><span class="line">        Thread thread1 = <span class="keyword">new</span> Thread(() -&gt; &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">5</span>; i++) &#123;</span><br><span class="line">                threadLocalValue.set(threadLocalValue.get() + <span class="number">1</span>);</span><br><span class="line">                System.out.println(<span class="string">&quot;Thread 1: &quot;</span> + threadLocalValue.get());</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line"></span><br><span class="line">        Thread thread2 = <span class="keyword">new</span> Thread(() -&gt; &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">5</span>; i++) &#123;</span><br><span class="line">                threadLocalValue.set(threadLocalValue.get() + <span class="number">1</span>);</span><br><span class="line">                System.out.println(<span class="string">&quot;Thread 2: &quot;</span> + threadLocalValue.get());</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line"></span><br><span class="line">        thread1.start();</span><br><span class="line">        thread2.start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
<h4 id="问：static-能不能修饰-ThreadLocal？"><a href="#问：static-能不能修饰-ThreadLocal？" class="headerlink" title="问：static 能不能修饰 ThreadLocal？"></a>问：static 能不能修饰 ThreadLocal？</h4><ul>
<li>可以，且通常将ThreadLocal变量声明为<strong>私有静态</strong>。这样做有好处也有坏处，主要是为了<strong>避免重复的创建TSO</strong>（thread specific object，即与线程相关的变量），坏处是可能导致<strong>内存泄漏</strong>。</li>
<li>如果声明ThreadLocal为某个类的实例变量，每创建一个类的实例就会创建新的ThreadLocal实例，导致同一个线程可能访问到同一个TSO类的不同实例，也因为重复创建相同的对象导致浪费。</li>
<li>因为类对ThreadLocal的静态引用，导致最终生成了对ThreadLocal的一条可达引用链路，使ThreadLocal实例不会被垃圾回收，即产生了内存泄漏。</li>
<li>所以使用ThreadLocal需要手动回收这部分内存，可以remove或使ThreadLocal变量=null。</li>
</ul>
<h4 id="问：谈一下ThreadLocal的内存泄漏问题？ThreadLocal为什么会出现内存泄漏？⭐⭐⭐"><a href="#问：谈一下ThreadLocal的内存泄漏问题？ThreadLocal为什么会出现内存泄漏？⭐⭐⭐" class="headerlink" title="问：谈一下ThreadLocal的内存泄漏问题？ThreadLocal为什么会出现内存泄漏？⭐⭐⭐"></a>问：谈一下ThreadLocal的内存泄漏问题？ThreadLocal为什么会出现内存泄漏？⭐⭐⭐</h4><ul>
<li>首先每个线程内部都有一个<strong>ThreadLocalMap</strong>实例。用于存储该线程中所有ThreadLocal的变量值。<code>ThreadLocalMap</code> 的<strong>键是 <code>ThreadLocal</code> 实例的弱引用，值是一个强引用</strong>。</li>
<li>如果某个 <code>ThreadLocal</code> 实例没有强引用指向它时，GC 会回收该 <code>ThreadLocal</code>。但是回收掉 <code>ThreadLocal</code> 的键之后，其对应的值（<code>ThreadLocal</code> 保存的数据）仍然存放在 <code>ThreadLocalMap</code> 中，形成 <strong>“键为 null，值仍存在”</strong> 的孤岛结构。</li>
<li>普通线程结束时，其 <code>ThreadLocalMap</code> 会随着线程销毁而被回收。但如果线程是线程池中的线程，由于线程会被复用，<code>ThreadLocalMap</code> 的内容可能长期存在，导致无法回收未清理的值，从而引发内存泄漏。</li>
<li>解决办法：<ol>
<li>在任务执行完毕后，调用 <code>ThreadLocal.remove()</code> 方法显式清理数据。</li>
</ol>
</li>
</ul>
<h4 id="问：如果我们要获取父线程的ThreadLocal值呢？"><a href="#问：如果我们要获取父线程的ThreadLocal值呢？" class="headerlink" title="问：如果我们要获取父线程的ThreadLocal值呢？"></a>问：如果我们要获取父线程的ThreadLocal值呢？</h4><ul>
<li><p>在 Java 的标准 <code>ThreadLocal</code> 实现中，<strong>ThreadLocal 是线程隔离的</strong>，不同线程无法直接访问彼此的 <code>ThreadLocal</code> 值。但是我们可以用<strong>InteritableThreadLocal</strong>来实现这个功能。</p>
</li>
<li><p>InteritableThreadLocal继承自ThreadLocal，允许子线程从父线程继承 <code>ThreadLocal</code> 的值。重写了createdMap方法，已经对应的get和set方法，不是在利用了threadLocals，而是interitableThreadLocals变量。</p>
</li>
<li><p><code>InheritableThreadLocal</code> 的默认行为是简单拷贝父线程的值到子线程。但有时你可能希望在拷贝时进行某些转换或自定义处理，可以通过重写 <code>InheritableThreadLocal#childValue</code> 方法实现。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">InheritableThreadLocalExample</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> InheritableThreadLocal&lt;String&gt; inheritableThreadLocal = </span><br><span class="line">            <span class="keyword">new</span> InheritableThreadLocal&lt;&gt;();</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 设置父线程的 ThreadLocal 值</span></span><br><span class="line">        inheritableThreadLocal.set(<span class="string">&quot;Parent Thread Value&quot;</span>);</span><br><span class="line"></span><br><span class="line">        Thread childThread = <span class="keyword">new</span> Thread(() -&gt; &#123;</span><br><span class="line">            <span class="comment">// 子线程获取继承的值</span></span><br><span class="line">            System.out.println(<span class="string">&quot;Child Thread: &quot;</span> + inheritableThreadLocal.get());</span><br><span class="line">        &#125;);</span><br><span class="line"></span><br><span class="line">        childThread.start();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            childThread.join();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">            Thread.currentThread().interrupt();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 输出Child Thread: Parent Thread Value</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> InheritableThreadLocal&lt;String&gt; inheritableThreadLocal = </span><br><span class="line">            <span class="keyword">new</span> InheritableThreadLocal&lt;&gt;() &#123;</span><br><span class="line">                <span class="meta">@Override</span></span><br><span class="line">                <span class="function"><span class="keyword">protected</span> String <span class="title">childValue</span><span class="params">(String parentValue)</span> </span>&#123;</span><br><span class="line">                    <span class="comment">// 自定义子线程继承值的逻辑</span></span><br><span class="line">                    <span class="keyword">return</span> parentValue + <span class="string">&quot; (Modified for Child)&quot;</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;;</span><br></pre></td></tr></table></figure></li>
<li><p>线程池场景中，因为复用线程，如果线程的 <code>InheritableThreadLocal</code> 值没有被清理，线程可能会继续持有上一个任务的值，导致线程间数据污染。而且因为线程由线程池管理而不是调用者，所以没有明确的父子关系。</p>
</li>
<li><p>在 Spring 框架中，<code>InheritableThreadLocal</code> 的功能可以通过 <code>TransmittableThreadLocal</code>（由阿里巴巴开源的组件 <a target="_blank" rel="noopener" href="https://github.com/alibaba/transmittable-thread-local">TTL</a>）增强。这种方式特别适合线程池场景，解决了 <code>InheritableThreadLocal</code> 在线程池中因线程复用而导致父子线程值错乱的问题。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> com.alibaba.ttl.TransmittableThreadLocal;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TransmittableThreadLocalExample</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> TransmittableThreadLocal&lt;String&gt; threadLocal = </span><br><span class="line">            <span class="keyword">new</span> TransmittableThreadLocal&lt;&gt;();</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        threadLocal.set(<span class="string">&quot;Parent Thread Value&quot;</span>);</span><br><span class="line"></span><br><span class="line">        Thread childThread = <span class="keyword">new</span> Thread(() -&gt; &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;Child Thread: &quot;</span> + threadLocal.get());</span><br><span class="line">        &#125;);</span><br><span class="line"></span><br><span class="line">        childThread.start();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            childThread.join();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">            Thread.currentThread().interrupt();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li></li>
</ul>
<hr>
<h3 id="1-3-Thread"><a href="#1-3-Thread" class="headerlink" title="1.3 Thread"></a>1.3 Thread</h3><h4 id="问：Thread类里有哪些常用方法？"><a href="#问：Thread类里有哪些常用方法？" class="headerlink" title="问：Thread类里有哪些常用方法？"></a>问：Thread类里有哪些常用方法？</h4><ol>
<li>start()：启动线程，调用线程的 <code>run()</code> 方法。不能多次调用同一个线程对象的 <code>start()</code> 方法，否则会抛出 <code>IllegalThreadStateException</code>。</li>
<li>run()：定义线程执行的具体逻辑。通常不直接调用，而是通过 <code>start()</code> 启动线程后由 JVM 调用。</li>
<li>join()：当前线程等待指定线程执行完毕。</li>
<li>join(long millis)：等待指定的毫秒时间。</li>
<li>interrupt()：中断线程，将线程的中断状态设置为 <code>true</code>。线程可以通过 <code>Thread.interrupted()</code> 或 <code>isInterrupted()</code> 检测中断状态。如果线程正在执行阻塞操作（如 <code>sleep()</code>、<code>wait()</code> 等），会抛出 <code>InterruptedException</code>。</li>
<li>isInterrupted()：检测线程是否被中断。不会清除中断状态。</li>
<li>interrupted()：（静态方法）检测当前线程是否被中断，并清除中断状态。</li>
<li>isAlive()：检查线程是否仍处于活动状态（尚未终止）。</li>
<li>setPriority(int priority)：设置线程的优先级，取值范围为 <code>Thread.MIN_PRIORITY</code> (1) 到 <code>Thread.MAX_PRIORITY</code> (10)，默认值是 <code>Thread.NORM_PRIORITY</code> (5)。getPriority() 获取线程的优先级。</li>
<li>getName() 和 setName(String name)：获取或设置线程的名称。</li>
<li>getId()：返回线程的唯一标识符。</li>
<li>currentThread()：（静态方法）获取当前正在执行的线程。</li>
<li>getState()：获取线程的当前状态，如 <code>NEW</code>、<code>RUNNABLE</code>、<code>BLOCKED</code>、<code>WAITING</code> 等。</li>
<li>sleep(long millis)：（静态方法）让当前线程进入休眠状态，暂停执行指定的毫秒时间。</li>
<li>yield()：（静态方法）让出 CPU 使用权，允许其他线程获取执行机会。具体行为依赖于操作系统的线程调度机制。</li>
<li>setDaemon(boolean on)：设置线程是否为守护线程，必须在线程启动之前调用。守护线程在所有用户线程结束时自动终止。</li>
<li>isDaemon()：检查线程是否为守护线程。</li>
</ol>
<h4 id="问：interrupt-isInterrupted-interrupt区别？"><a href="#问：interrupt-isInterrupted-interrupt区别？" class="headerlink" title="问：interrupt/isInterrupted/interrupt区别？"></a>问：interrupt/isInterrupted/interrupt区别？</h4><ul>
<li>interrupt()：调用该方法的线程的状态为将被置为”中断”状态（set操作）。如果目标线程正在执行阻塞方法（如 <code>sleep()</code>、<code>wait()</code> 或 <code>join()</code>），这些方法会抛出 <code>InterruptedException</code>，并清除中断状态。</li>
<li>isinterrupted()：检测目标线程的中断状态（<code>true</code> 或 <code>false</code>）。不会清除线程的中断状态。</li>
<li>interrupted()：是静态方法：内部实现是调用的当前线程的isInterrupted()，并且会重置当前线程的中断状态（getandset）用于判断当前线程是否被中断，同时清除中断状态，避免后续误判。</li>
</ul>
<h4 id="问：谈一下start和run方法的区别？⭐"><a href="#问：谈一下start和run方法的区别？⭐" class="headerlink" title="问：谈一下start和run方法的区别？⭐"></a>问：谈一下start和run方法的区别？⭐</h4><ul>
<li><code>start()</code> 方法：启动一个新线程，并使其进入 <strong>就绪状态</strong>。调用 <code>start()</code> 后，<code>JVM</code> 会为该线程分配资源，并自动调用 <code>run()</code> 方法，执行线程任务。每个线程对象的 <code>start()</code> 方法只能调用一次，重复调用会抛出 <code>IllegalThreadStateException</code>。<code>start()</code> 是一个原生方法，由 JVM 调用底层操作系统接口，启动一个新的线程。<ul>
<li>是否创建新线程：是，创建一个新线程，并执行 <code>run()</code> 方法</li>
<li>场景：在需要真正实现多线程的场景中使用，启动新的线程来并发执行任务。</li>
</ul>
</li>
<li><code>run()</code> 方法：定义线程的具体执行逻辑。当run方法执行结束，线程随即终止，调用run方法并不能用来启动线程。<code>run()</code> 是一个普通的方法，直接调用时，代码会在<strong>当前线程</strong>中执行，而不会创建新的线程。<ul>
<li>是否创建新线程：否，在当前线程中调用 <code>run()</code> 方法。</li>
<li>场景：仅用于定义线程的执行逻辑，通常不会直接调用它，而是通过 <code>start()</code> 间接调用。</li>
</ul>
</li>
</ul>
<h4 id="问：sleep-和-wait-有什么区别？⭐⭐"><a href="#问：sleep-和-wait-有什么区别？⭐⭐" class="headerlink" title="问：sleep 和 wait 有什么区别？⭐⭐"></a>问：sleep 和 wait 有什么区别？⭐⭐</h4><ul>
<li>sleep：属于线程类；<ul>
<li>定义：<code>Thread.sleep(long millis)</code> 是 <code>Thread</code> 类的静态方法，用于让当前线程暂停执行一段时间。</li>
</ul>
</li>
<li>wait：属于object类；<ul>
<li>定义：<code>Object.wait()</code> 是 <code>Object</code> 类的实例方法，线程调用该方法后会进入<strong>等待状态</strong>，并释放当前持有的对象锁。</li>
</ul>
</li>
</ul>
<table>
<thead>
<tr>
<th>特性</th>
<th><code>sleep</code></th>
<th><code>wait</code></th>
</tr>
</thead>
<tbody><tr>
<td><strong>所属类</strong></td>
<td><code>Thread</code></td>
<td><code>Object</code></td>
</tr>
<tr>
<td><strong>是否释放锁</strong></td>
<td>不释放锁</td>
<td>释放锁</td>
</tr>
<tr>
<td><strong>调用位置</strong></td>
<td>可在任何位置调用</td>
<td>必须在同步块或同步方法中调用</td>
</tr>
<tr>
<td><strong>恢复方式</strong></td>
<td>时间到期后自动恢复</td>
<td>需要其他线程调用 <code>notify</code> 或 <code>notifyAll</code></td>
</tr>
<tr>
<td><strong>与锁的关系</strong></td>
<td>与锁机制无关</td>
<td>必须依赖锁机制</td>
</tr>
<tr>
<td><strong>用途</strong></td>
<td>让线程休眠一段时间</td>
<td>线程间通信，协调线程执行</td>
</tr>
</tbody></table>
<h4 id="问：sleep-和-yeild-方法有什么区别？"><a href="#问：sleep-和-yeild-方法有什么区别？" class="headerlink" title="问：sleep 和 yeild 方法有什么区别？"></a>问：sleep 和 yeild 方法有什么区别？</h4><table>
<thead>
<tr>
<th>特性</th>
<th><code>sleep</code></th>
<th><code>yield</code></th>
</tr>
</thead>
<tbody><tr>
<td><strong>作用</strong></td>
<td>让线程暂停执行指定时间</td>
<td>让线程让出 CPU 时间片</td>
</tr>
<tr>
<td><strong>状态转换</strong></td>
<td>进入 <strong>TIMED_WAITING</strong> 状态</td>
<td>进入 <strong>RUNNABLE</strong> 状态</td>
</tr>
<tr>
<td><strong>是否阻塞</strong></td>
<td>阻塞线程，直到时间结束或被中断</td>
<td>不阻塞线程</td>
</tr>
<tr>
<td><strong>是否释放锁</strong></td>
<td>不释放锁</td>
<td>不释放锁</td>
</tr>
<tr>
<td><strong>恢复机制</strong></td>
<td>时间到后自动恢复</td>
<td>由线程调度器重新分配 CPU 时间片</td>
</tr>
<tr>
<td><strong>调度器依赖</strong></td>
<td>不依赖调度器</td>
<td>强依赖调度器，效果不确定</td>
</tr>
<tr>
<td><strong>中断处理</strong></td>
<td>可通过 <code>InterruptedException</code> 捕获</td>
<td>不响应中断</td>
</tr>
</tbody></table>
<hr>
<h3 id="1-4-线程池"><a href="#1-4-线程池" class="headerlink" title="1.4 线程池"></a>1.4 线程池</h3><h4 id="问：项目的用户量多吗？有用过线程池吗？用到多线程的优势在哪？⭐"><a href="#问：项目的用户量多吗？有用过线程池吗？用到多线程的优势在哪？⭐" class="headerlink" title="问：项目的用户量多吗？有用过线程池吗？用到多线程的优势在哪？⭐"></a>问：项目的用户量多吗？有用过线程池吗？用到多线程的优势在哪？⭐</h4><ul>
<li>以前的项目用户量不大，但有学习和练习过线程池。</li>
<li>多线程意味着能同时执行多个任务，利用多核处理器，提高并发性能，加快程序执行速度，提高系统 的吞吐量和响应能力。</li>
<li>线程池则是用来管理和限制系统中执行线程的数量（<strong>统一管理，避免资源耗尽</strong>），重复的利用已创建的线程，防止内存的浪费（<strong>降低资源消耗</strong>），减少创建和销毁线程的次数，（<strong>提高响应速度</strong>）。</li>
</ul>
<p>线程池优先把任务放入队列，而不是创建更多线程，适合CPU密集型任务，线程过多反而导致上下文切换等影响效率。对于IO密集的场景，一些线程池会优先创建线程，让单位时间内执行更多的任务。</p>
<p><strong>池化技术</strong>：用空间换时间，把创建耗时的资源统一管理起来。</p>
<p>典型场景：</p>
<ol>
<li>快速响应用户请求<ul>
<li><strong>背景：</strong> 处理实时用户请求，需尽快返回响应。</li>
<li><strong>方案：</strong> 使用线程池执行多个查询任务并聚合结果，提高响应速度。</li>
</ul>
</li>
<li>批量任务处理<ul>
<li><strong>背景：</strong> 定期处理大量离线任务，如日志分析。</li>
<li><strong>方案：</strong> 使用<code>ScheduledThreadPoolExecutor</code>定时调度批量任务，确保任务按时执行。</li>
</ul>
</li>
<li>动态线程池方案：在复杂业务场景中，静态配置的线程池可能无法满足高负载变化的需求。通过动态调整线程池参数，可以提升系统的弹性与稳定性。方案包括：<ul>
<li><strong>实时监控：</strong> 收集线程池运行数据。</li>
<li><strong>参数调优：</strong> 根据业务需求动态调整线程池大小。</li>
<li><strong>策略优化：</strong> 根据任务类型和优先级灵活调整拒绝策略。</li>
</ul>
</li>
</ol>
<h4 id="问：有哪几种线程池？⭐⭐"><a href="#问：有哪几种线程池？⭐⭐" class="headerlink" title="问：有哪几种线程池？⭐⭐"></a>问：有哪几种线程池？⭐⭐</h4><table>
<thead>
<tr>
<th>线程池</th>
<th>特点</th>
<th>核心线程</th>
<th>最大线程</th>
<th>阻塞队列</th>
<th>拒绝策略</th>
<th>适用场景</th>
</tr>
</thead>
<tbody><tr>
<td>newFixedThreadPool(固定线程池)</td>
<td>固定大小，多余的任务排队等待</td>
<td>nThreads</td>
<td>nThreads</td>
<td>LinkedBlockingQueue</td>
<td>AbortPolicy</td>
<td>需要执行大量短期异步任务，且线程数量应受限的情况。适用于处理CPU密集型的任务，适用执行长期的任务</td>
</tr>
<tr>
<td>newCachedThreadPool(缓存线程池)</td>
<td>根据需要调整线程数量，线程闲置超过 60 秒会自动回收</td>
<td>0</td>
<td>Integer.MAX_VALUE</td>
<td>SynchronousQueue</td>
<td>AbortPolicy</td>
<td>执行大量生命周期短的异步任务，且对资源消耗不敏感。适用于并发执行大量短期的小任务</td>
</tr>
<tr>
<td>newSingleThreadExecutor(单线程线程池)</td>
<td>只有一个线程，所有任务按顺序执行</td>
<td>1</td>
<td>1</td>
<td>LinkedBlockingQueue</td>
<td>AbortPolicy</td>
<td>需要顺序执行任务，确保线程安全时。适用于串行执行任务的场景，一个任务一个任务地执行</td>
</tr>
<tr>
<td>newScheduledThreadPool(调度线程池)</td>
<td>支持任务定时和周期性执行</td>
<td>corePoolSize</td>
<td>Integer.MAX_VALUE</td>
<td>DelayedWorkQueue</td>
<td>AbortPolicy</td>
<td>周期性执行任务，定时调度任务。需要限制线程数量的场景</td>
</tr>
<tr>
<td>newWorkStealingPool(工作窃取线程池, Java 8+)</td>
<td>基于分治模型，使用 <code>ForkJoinPool</code> 来实现工作窃取</td>
<td><code>parallelism</code>（默认等于 CPU 核心数）</td>
<td>无显式配置（由 <code>ForkJoinPool</code> 管理）</td>
<td>多个任务队列（每个线程一个双端队列）</td>
<td>自适应，使用 <code>ForkJoinPool</code> 内置策略</td>
<td>需要提高并行任务执行效率的大规模任务</td>
</tr>
</tbody></table>
<h4 id="问：线程池状态？⭐"><a href="#问：线程池状态？⭐" class="headerlink" title="问：线程池状态？⭐"></a>问：线程池状态？⭐</h4><p>线程池有5种状态：running，showdown，stop，Tidying，TERMINATED。</p>
<table>
<thead>
<tr>
<th>状态名</th>
<th>描述</th>
</tr>
</thead>
<tbody><tr>
<td>RUNNING</td>
<td>运行状态，接受新任务，并处理等待队列中的任务。创建线程默认此状态。</td>
</tr>
<tr>
<td>SHUTDOWN</td>
<td>showdown()触发，不接受新任务，但处理等待队列中堆积的任务。</td>
</tr>
<tr>
<td>STOP</td>
<td>showdownnow()触发，不接受新任务，不处理等待队列，并中断正在执行的任务。</td>
</tr>
<tr>
<td>TIDYING</td>
<td>当线程池状态为showdown或者stop，所有任务都已终止，会变为tidying，线程数为 0，正在运行终止处理，会调用钩子函数terminated()。</td>
</tr>
<tr>
<td>TERMINATED</td>
<td>terminated()执行完成，终止处理完成，线程池完全终止。</td>
</tr>
</tbody></table>
<p>状态转换如图：</p>
<pre><code>    +-----------+    shutdown()      +------------+
    |  RUNNING  |------------------&gt; |  SHUTDOWN  |
    +-----------+                    +------------+
          |                               |
          | shutdownNow()                 |
          v                               v
    +-----------+  -&gt; 中断任务  -&gt;    +------------+
    |    STOP   |------------------&gt; |  TIDYING   |
    +-----------+                    +------------+
          |                               |
          |       任务结束                 |
          v                               v
    +-----------+  -&gt; 终止完成 -&gt;      +-------------+
    | TERMINATED| &lt;------------------ |  TIDYING    |
    +-----------+                     +-------------+
</code></pre>
<ol>
<li><strong>RUNNING -&gt; SHUTDOWN</strong>：调用 <code>shutdown()</code>，停止接受新任务，但会处理阻塞队列中的任务。</li>
<li><strong>RUNNING/SHUTDOWN -&gt; STOP</strong>：调用 <code>shutdownNow()</code>，停止接受任务，清空任务队列，中断正在执行的任务。</li>
<li><strong>SHUTDOWN -&gt; TIDYING</strong>：队列和活动线程都为空，进入终止阶段。</li>
<li><strong>STOP -&gt; TIDYING</strong>：所有任务都完成，线程池被中断。</li>
<li><strong>TIDYING -&gt; TERMINATED</strong>：线程池终止完成，<code>terminated()</code> 钩子方法被执行。</li>
</ol>
<p><img src="https://p0.meituan.net/travelcube/582d1606d57ff99aa0e5f8fc59c7819329028.png" alt="图3 线程池生命周期"></p>
<p>在 <code>ThreadPoolExecutor</code> 源码中，线程池状态通过一个 <code>int</code> 类型的变量 <code>ctl</code> 来管理，其中：</p>
<ul>
<li>高 3 位表示线程池状态。</li>
<li>低 29 位表示线程池中的线程数量。</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> AtomicInteger ctl = <span class="keyword">new</span> AtomicInteger(ctlOf(RUNNING, <span class="number">0</span>));</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> COUNT_BITS = Integer.SIZE - <span class="number">3</span>;</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> CAPACITY   = (<span class="number">1</span> &lt;&lt; COUNT_BITS) - <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 状态值定义</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> RUNNING    = -<span class="number">1</span> &lt;&lt; COUNT_BITS;</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> SHUTDOWN   =  <span class="number">0</span> &lt;&lt; COUNT_BITS;</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> STOP       =  <span class="number">1</span> &lt;&lt; COUNT_BITS;</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> TIDYING    =  <span class="number">2</span> &lt;&lt; COUNT_BITS;</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> TERMINATED =  <span class="number">3</span> &lt;&lt; COUNT_BITS;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 状态检查方法</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">runStateOf</span><span class="params">(<span class="keyword">int</span> c)</span>     </span>&#123; <span class="keyword">return</span> c &amp; ~CAPACITY; &#125;</span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">workerCountOf</span><span class="params">(<span class="keyword">int</span> c)</span>  </span>&#123; <span class="keyword">return</span> c &amp; CAPACITY; &#125;</span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">ctlOf</span><span class="params">(<span class="keyword">int</span> rs, <span class="keyword">int</span> wc)</span> </span>&#123; <span class="keyword">return</span> rs | wc; &#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>



<p>观察状态变化：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.concurrent.*;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ThreadPoolStateExample</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">        ThreadPoolExecutor executor = <span class="keyword">new</span> ThreadPoolExecutor(</span><br><span class="line">                <span class="number">2</span>, <span class="number">4</span>, <span class="number">1</span>, TimeUnit.SECONDS, <span class="keyword">new</span> LinkedBlockingQueue&lt;&gt;(<span class="number">2</span>));</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 提交一些任务</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">6</span>; i++) &#123;</span><br><span class="line">            <span class="keyword">final</span> <span class="keyword">int</span> taskId = i + <span class="number">1</span>;</span><br><span class="line">            executor.submit(() -&gt; &#123;</span><br><span class="line">                System.out.println(<span class="string">&quot;Task &quot;</span> + taskId + <span class="string">&quot; is running by &quot;</span> + Thread.currentThread().getName());</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    Thread.sleep(<span class="number">2000</span>); <span class="comment">// 模拟任务执行</span></span><br><span class="line">                &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                    System.out.println(<span class="string">&quot;Task &quot;</span> + taskId + <span class="string">&quot; was interrupted.&quot;</span>);</span><br><span class="line">                &#125;</span><br><span class="line">                System.out.println(<span class="string">&quot;Task &quot;</span> + taskId + <span class="string">&quot; completed.&quot;</span>);</span><br><span class="line">            &#125;);</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        System.out.println(<span class="string">&quot;Current Pool State: &quot;</span> + getPoolState(executor));</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 调用 shutdown()，查看状态</span></span><br><span class="line">        executor.shutdown();</span><br><span class="line">        System.out.println(<span class="string">&quot;After shutdown() - State: &quot;</span> + getPoolState(executor));</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 等待线程池终止</span></span><br><span class="line">        executor.awaitTermination(<span class="number">10</span>, TimeUnit.SECONDS);</span><br><span class="line">        System.out.println(<span class="string">&quot;After termination - State: &quot;</span> + getPoolState(executor));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> String <span class="title">getPoolState</span><span class="params">(ThreadPoolExecutor executor)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (executor.isShutdown()) <span class="keyword">return</span> <span class="string">&quot;SHUTDOWN&quot;</span>;</span><br><span class="line">        <span class="keyword">if</span> (executor.isTerminating()) <span class="keyword">return</span> <span class="string">&quot;TIDYING&quot;</span>;</span><br><span class="line">        <span class="keyword">if</span> (executor.isTerminated()) <span class="keyword">return</span> <span class="string">&quot;TERMINATED&quot;</span>;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;RUNNING&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h4 id="问：ThreadPoolExecutor-初始化参数？corepoolSize-怎么设置，maxpoolsize-怎么设置，keep-alive-各种的？⭐⭐⭐"><a href="#问：ThreadPoolExecutor-初始化参数？corepoolSize-怎么设置，maxpoolsize-怎么设置，keep-alive-各种的？⭐⭐⭐" class="headerlink" title="问：ThreadPoolExecutor 初始化参数？corepoolSize 怎么设置，maxpoolsize 怎么设置，keep-alive 各种的？⭐⭐⭐"></a>问：ThreadPoolExecutor 初始化参数？corepoolSize 怎么设置，maxpoolsize 怎么设置，keep-alive 各种的？⭐⭐⭐</h4><p>ThreadPoolExecutor 初始化参数？</p>
<ul>
<li><strong>corePoolSize</strong>（线程池基本大小）：核心线程数，线程池中始终保持的最小线程数量，即使没有任务。</li>
<li><strong>maximumPoolSize</strong>（线程池最大数量）：若队列满了，会继续创建新的线程，直到达到线程池最大数量，当然若任务队列没有界限此参数就失效了。</li>
<li><strong>ThreadFactory</strong>（线程工厂）：用于设置创建线程的工厂，一般用于给线程统一命名。</li>
<li><strong>keepAliveTime</strong>（线程活动保持时间）：工作线程空闲后能够存活的时间，当任务很多且执行时间较短时，可以调高此值，提高线程的利用率。</li>
<li><strong>TimeUnit</strong>（时间单位）：可选的单位有天（DAYS）、小时（HOURS）、分钟 （MINUTES）、毫秒（MILLISECONDS）、微秒（MICROSECONDS，千分之一毫秒）和纳秒（NANOSECONDS，千分之一微秒）。</li>
<li><strong>runnableTaskQueue</strong>（任务队列）：保存等待执行的任务阻塞队列，有多种选择：数组先进先出队列、链表先进先出队列、不存储元素的阻塞队列、含优先级的无限阻塞队列。注意：不要使用无界队列，任务堆积会占用内存空间，一旦占满就会频繁GC，导致服务不可用。</li>
<li><strong>RejectedExecutionHandler</strong>（饱和策略）：队列和线程池都满了后，处于饱和状态时的新任务处理策略。默认是AbortPolicy直接抛出异常，还有直接丢弃、丢弃最近任务等等。</li>
</ul>
<p><code>corePoolSize</code> 配置策略？</p>
<ul>
<li><strong>CPU 密集型任务（如计算/图像处理）</strong>：<br>设置为 <code>CPU核数 + 1</code>，如 <code>Runtime.getRuntime().availableProcessors() + 1</code>。</li>
<li><strong>IO 密集型任务（如数据库/网络请求）</strong>：<br>设置为 <code>CPU核数 * 2</code> 或更高，因线程会长时间等待 IO。</li>
<li><strong>混合型任务</strong>：根据工作负载特点调整。</li>
</ul>
<p><code>maximumPoolSize</code> 的配置策略？</p>
<ul>
<li>设置为核心线程数的 2-3 倍，或视任务量峰值调整。</li>
<li>注意：如果 <code>workQueue</code> 为无界队列（如 <code>LinkedBlockingQueue</code>），<code>maximumPoolSize</code> 实际无效。</li>
</ul>
<p><code>keepAliveTime</code> 的配置策略？</p>
<ul>
<li><strong>默认值</strong>：60 秒。</li>
<li>适用场景：<ul>
<li>短期任务：缩短存活时间，及时释放空闲线程。</li>
<li>长期任务：适当延长，避免频繁创建销毁线程。</li>
</ul>
</li>
</ul>
<p>线程池配置示例：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.concurrent.*;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ThreadPoolExample</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> corePoolSize = Runtime.getRuntime().availableProcessors() + <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">int</span> maxPoolSize = corePoolSize * <span class="number">2</span>;</span><br><span class="line">        <span class="keyword">long</span> keepAliveTime = <span class="number">60</span>;</span><br><span class="line"></span><br><span class="line">        ThreadPoolExecutor executor = <span class="keyword">new</span> ThreadPoolExecutor(</span><br><span class="line">                corePoolSize,                    <span class="comment">// 核心线程数</span></span><br><span class="line">                maxPoolSize,                     <span class="comment">// 最大线程数</span></span><br><span class="line">                keepAliveTime,                   <span class="comment">// 非核心线程存活时间</span></span><br><span class="line">                TimeUnit.SECONDS,                <span class="comment">// 时间单位</span></span><br><span class="line">                <span class="keyword">new</span> LinkedBlockingQueue&lt;&gt;(<span class="number">100</span>),  <span class="comment">// 工作队列</span></span><br><span class="line">                Executors.defaultThreadFactory(),<span class="comment">// 线程工厂</span></span><br><span class="line">                <span class="keyword">new</span> ThreadPoolExecutor.CallerRunsPolicy() <span class="comment">// 拒绝策略</span></span><br><span class="line">        );</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 提交任务</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= <span class="number">200</span>; i++) &#123;</span><br><span class="line">            <span class="keyword">final</span> <span class="keyword">int</span> taskId = i;</span><br><span class="line">            executor.submit(() -&gt; &#123;</span><br><span class="line">                System.out.println(<span class="string">&quot;Task &quot;</span> + taskId + <span class="string">&quot; is running by &quot;</span> + Thread.currentThread().getName());</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    Thread.sleep(<span class="number">200</span>); <span class="comment">// 模拟任务执行</span></span><br><span class="line">                &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                    Thread.currentThread().interrupt();</span><br><span class="line">                &#125;</span><br><span class="line">                System.out.println(<span class="string">&quot;Task &quot;</span> + taskId + <span class="string">&quot; completed.&quot;</span>);</span><br><span class="line">            &#125;);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 关闭线程池</span></span><br><span class="line">        executor.shutdown();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p>推荐配置示例 (生产环境参考)：</p>
<ul>
<li><p><strong>CPU 密集型任务配置示例</strong>：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">ThreadPoolExecutor cpuExecutor = <span class="keyword">new</span> ThreadPoolExecutor(</span><br><span class="line">    Runtime.getRuntime().availableProcessors() + <span class="number">1</span>,  <span class="comment">// 核心线程数</span></span><br><span class="line">    Runtime.getRuntime().availableProcessors() + <span class="number">1</span>,  <span class="comment">// 最大线程数</span></span><br><span class="line">    <span class="number">0L</span>, TimeUnit.MILLISECONDS,                      <span class="comment">// 非核心线程存活时间</span></span><br><span class="line">    <span class="keyword">new</span> LinkedBlockingQueue&lt;&gt;(<span class="number">100</span>),                 <span class="comment">// 队列大小</span></span><br><span class="line">    Executors.defaultThreadFactory(),</span><br><span class="line">    <span class="keyword">new</span> ThreadPoolExecutor.AbortPolicy()            <span class="comment">// 拒绝策略</span></span><br><span class="line">);</span><br></pre></td></tr></table></figure></li>
<li><p><strong>IO 密集型任务配置示例</strong>：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">ThreadPoolExecutor ioExecutor = <span class="keyword">new</span> ThreadPoolExecutor(</span><br><span class="line">    <span class="number">10</span>,                    <span class="comment">// 核心线程数</span></span><br><span class="line">    <span class="number">100</span>,                   <span class="comment">// 最大线程数</span></span><br><span class="line">    <span class="number">60</span>, TimeUnit.SECONDS,  <span class="comment">// 非核心线程存活时间</span></span><br><span class="line">    <span class="keyword">new</span> SynchronousQueue&lt;&gt;(),   <span class="comment">// 无缓冲队列</span></span><br><span class="line">    Executors.defaultThreadFactory(),</span><br><span class="line">    <span class="keyword">new</span> ThreadPoolExecutor.CallerRunsPolicy()  <span class="comment">// 拒绝策略</span></span><br><span class="line">);</span><br></pre></td></tr></table></figure></li>
</ul>
<p>常见注意事项与最佳实践：</p>
<ol>
<li><strong>选择合适的队列与拒绝策略</strong>：根据任务数量与执行时间配置队列与策略，避免资源枯竭。</li>
<li><strong>监控线程池状态</strong>：通过 <code>ThreadPoolExecutor</code> 提供的方法监控任务执行与队列长度。</li>
<li><strong>合理配置最大线程数</strong>：避免设置过高，导致过度竞争与资源耗尽。</li>
<li>拒绝策略选择：<ul>
<li><code>AbortPolicy</code>（默认）: 抛出异常。</li>
<li><code>CallerRunsPolicy</code>：由调用线程执行任务。</li>
<li><code>DiscardPolicy</code>：直接丢弃任务。</li>
<li><code>DiscardOldestPolicy</code>：丢弃队列中最旧的任务。</li>
</ul>
</li>
</ol>
<h4 id="问：阻塞队列在生产中的设置？拒绝策略的选择？⭐⭐⭐"><a href="#问：阻塞队列在生产中的设置？拒绝策略的选择？⭐⭐⭐" class="headerlink" title="问：阻塞队列在生产中的设置？拒绝策略的选择？⭐⭐⭐"></a>问：阻塞队列在生产中的设置？拒绝策略的选择？⭐⭐⭐</h4><p>阻塞队列(BlockingQueue)是一个支持两个附加操作的队列。这两个附加的操作是：在队列为空时，获取元素的线程会等待队列变为非空。当队列满时，存储元素的线程会等待队列可用。阻塞队列常用于生产者和消费者的场景，生产者是往队列里添加元素的线程，消费者是从队列里拿元素的线程。阻塞队列就是生产者存放元素的容器，而消费者也只从容器里拿元素。</p>
<p><code>workQueue</code> 队列类型选择？一般设置为 0，防止用户阻塞。选择的核心因素有：</p>
<ul>
<li><strong>任务数量</strong>：预计任务请求数量和峰值负载。</li>
<li><strong>任务处理时间</strong>：短任务或长时间任务。</li>
<li><strong>内存占用</strong>：内存是否足够，避免OOM。</li>
<li><strong>任务执行顺序</strong>：是否需要按提交顺序处理。</li>
</ul>
<table>
<thead>
<tr>
<th><strong>队列类型</strong></th>
<th><strong>描述</strong></th>
<th><strong>适用场景</strong></th>
<th><strong>选择策略</strong></th>
</tr>
</thead>
<tbody><tr>
<td><code>ArrayBlockingQueue</code></td>
<td>有界、FIFO 队列，数组结构，需指定容量。</td>
<td>任务数量已知，需内存控制。</td>
<td><strong>容量设置</strong>：适中，防止OOM。</td>
</tr>
<tr>
<td><code>LinkedBlockingQueue</code></td>
<td>链表结构，默认无界，FIFO，任务多时自动扩展。</td>
<td>高并发任务，队列长度难预测。IO 密集任务</td>
<td>设置最大容量，避免内存泄漏。</td>
</tr>
<tr>
<td><code>SynchronousQueue</code></td>
<td>无缓冲区，直接将任务交给工作线程。</td>
<td>实时高频任务，短时间执行。短期异步任务，低延迟</td>
<td><strong>无缓冲队列</strong>：高吞吐。适用于高负载请求处理</td>
</tr>
<tr>
<td><code>PriorityBlockingQueue</code></td>
<td>支持优先级排序的无界队列。</td>
<td>优先级调度，如延迟任务调度。</td>
<td>自定义优先级规则。</td>
</tr>
<tr>
<td><code>DelayQueue</code></td>
<td>定时任务队列，按到期时间执行。</td>
<td>定时任务执行，如任务调度器。</td>
<td>适用于延迟任务场</td>
</tr>
</tbody></table>
<table>
<thead>
<tr>
<th><strong>策略名称</strong></th>
<th><strong>描述</strong></th>
<th><strong>适用场景</strong></th>
<th><strong>注意事项</strong></th>
</tr>
</thead>
<tbody><tr>
<td><code>AbortPolicy</code>（默认策略）</td>
<td>丢弃任务并抛出 <code>RejectedExecutionException</code> 异常</td>
<td>重要任务需确保不丢失任务。</td>
<td>需捕获异常，避免程序崩溃。</td>
</tr>
<tr>
<td><code>CallerRunsPolicy</code></td>
<td>由提交任务的线程执行该任务，所有任务都能被执行</td>
<td>允许当前任务回退，任务重要但可延迟。</td>
<td>阻塞提交线程，可能影响响应时间。</td>
</tr>
<tr>
<td><code>DiscardPolicy</code></td>
<td>直接丢弃任务，无任何通知或异常</td>
<td>不重要的任务或允许任务丢失的场景</td>
<td>任务丢失风险，适用于日志记录。</td>
</tr>
<tr>
<td><code>DiscardOldestPolicy</code></td>
<td>丢弃队列中最旧任务，然后重试提交被拒绝的新任务</td>
<td>不重要任务的前提下，优先保留最新任务</td>
<td>可能导致旧任务被丢弃。</td>
</tr>
</tbody></table>
<h4 id="问：Java中的线程池是如何实现的？讲一下线程池的原理？⭐⭐⭐"><a href="#问：Java中的线程池是如何实现的？讲一下线程池的原理？⭐⭐⭐" class="headerlink" title="问：Java中的线程池是如何实现的？讲一下线程池的原理？⭐⭐⭐"></a>问：Java中的线程池是如何实现的？讲一下线程池的原理？⭐⭐⭐</h4><ul>
<li><p>线程池是什么？</p>
<ul>
<li>线程池（Thread Pool）是一种管理线程的工具，通过复用已创建的线程来执行任务，将资源统一在一起管理。</li>
</ul>
</li>
<li><p>线程池解决的问题是？</p>
<ol>
<li><strong>资源消耗高</strong>：频繁创建和销毁线程造成的资源损耗巨大。</li>
<li><strong>资源枯竭风险：</strong> 对申请无限制措施，有导致资源耗尽的风险。</li>
<li><strong>管理复杂度高</strong>：系统无法合理的管理资源分布，降低系统稳定性。</li>
</ol>
</li>
<li><p>在JDK中主要是核心类ThreadPoolExecutor。其设计基于生产者-消费者模型，将任务与线程解耦，实现任务的缓冲与执行。</p>
<ul>
<li><p>顶层接口Executor：将任务提交和任务执行进行解耦。用户无需关注如何创建线程，如何调度线程来执行任务，用户只需提供Runnable对象，将任务的运行逻辑提交到执行器(Executor)中，由Executor框架完成线程的调配和任务的执行部分。</p>
</li>
<li><p>ExecutorService接口：（1）扩充执行任务的能力，补充可以为一个或一批异步任务生成Future的方法；（2）提供了管控线程池的方法，比如停止线程池的运行。AbstractExecutorService则是上层的抽象类，将执行任务的流程串联了起来，保证下层的实现只需关注一个执行任务的方法即可。</p>
</li>
<li><p>最下层的实现类ThreadPoolExecutor实现最复杂的运行部分。</p>
<p>关键就是<strong>任务和线程</strong>的管理。二者解耦，任务管理部分充当生产者的角色，当任务提交后，线程池会判断该任务后续的流转：（1）直接申请线程执行该任务；（2）缓冲到队列中等待线程执行；（3）拒绝该任务。线程管理部分是消费者，它们被统一维护在线程池内，根据任务请求进行线程的分配，当线程执行完任务后则会继续获取新的任务去执行，最终当线程获取不到任务的时候，线程就会被回收。</p>
<p><img src="https://p0.meituan.net/travelcube/77441586f6b312a54264e3fcf5eebe2663494.png" alt="图2 ThreadPoolExecutor运行流程"></p>
<ul>
<li><p>生命周期管理：线程池内部使用一个变量维护两个值：**运行状态(runState)和线程数量 (workerCount)**。<code>ThreadPoolExecutor</code>使用一个<code>AtomicInteger</code>变量<code>ctl</code>同时记录线程池运行状态和线程数量，避免同步冲突。高3位保存runState，低29位保存workerCount，两个变量之间互不干扰。运行状态包括：<code>RUNNING</code>、<code>SHUTDOWN</code>、<code>STOP</code>、<code>TIDYING</code>、<code>TERMINATED</code>。</p>
</li>
<li><p>任务执行机制：包括调度、缓冲、申请、拒绝</p>
<ol>
<li><p>调度：所有任务的调度都是由execute方法完成，内容主要为：检查现在线程池的运行状态、运行线程数、运行策略，决定接下来执行的流程，是直接申请线程执行，或是缓冲到队列中执行，亦或是直接拒绝该任务。</p>
<p>任务执行流程：</p>
<ol>
<li>首先检测线程池运行状态，如果不是RUNNING，则直接拒绝，线程池要保证在RUNNING的状态下执行任务。</li>
<li>如果workerCount &lt; corePoolSize，则创建并启动一个线程来执行新提交的任务。</li>
<li>如果workerCount &gt;= corePoolSize，且线程池内的阻塞队列未满，则将任务添加到该阻塞队列中。</li>
<li>如果workerCount &gt;= corePoolSize &amp;&amp; workerCount &lt; maximumPoolSize，且线程池内的阻塞队列已满，则创建并启动一个线程来执行新提交的任务。</li>
<li>如果workerCount &gt;= maximumPoolSize，并且线程池内的阻塞队列已满, 则根据拒绝策略来处理该任务, 默认的处理方式是直接抛异常。</li>
</ol>
<p><img src="https://p0.meituan.net/travelcube/31bad766983e212431077ca8da92762050214.png" alt="图4 任务调度流程"></p>
</li>
<li><p>缓冲：线程池通过<strong>阻塞队列</strong>缓存任务，工作线程从阻塞队列中获取任务，从而实现解耦。</p>
</li>
<li><p>申请：</p>
<ul>
<li><p>任务的执行有两种可能：一种是任务直接由新创建的线程执行。另一种是线程从任务队列中获取任务然后执行，执行完任务的空闲线程会再次去从队列中申请任务再去执行。第一种情况仅出现在线程初始创建的时候，第二种是线程获取任务绝大多数的情况。</p>
</li>
<li><p>线程需要从任务缓存模块中不断地取任务执行，帮助线程从阻塞队列中获取任务，实现线程管理模块和任务管理模块之间的通信。这部分策略由getTask方法实现，其执行流程如下图所示：getTask这部分进行了多次判断，为的是控制线程的数量，使其符合线程池的状态。如果线程池现在不应该持有那么多线程，则会返回null值。工作线程Worker会不断接收新任务去执行，而当工作线程Worker接收不到任务的时候，就会开始被回收。</p>
<p><img src="https://p0.meituan.net/travelcube/49d8041f8480aba5ef59079fcc7143b996706.png" alt="图6 获取任务流程图"></p>
</li>
</ul>
</li>
<li><p>拒绝：线程池有一个最大的容量，当线程池的任务缓存队列已满，并且线程池中的线程数目达到maximumPoolSize时，就需要拒绝掉该任务，采取任务拒绝策略，保护线程池。</p>
</li>
</ol>
</li>
<li><p>Worker线程管理：线程池为了掌握线程的状态并维护线程的生命周期，设计了线程池内的工作线程Worker。</p>
<ul>
<li><p><strong>Worker线程模型：</strong> 每个<code>Worker</code>表示一个工作线程，包含任务执行逻辑。线程从队列中获取任务，执行完成后继续获取新任务。如果获取任务失败，则终止线程。</p>
<p><img src="https://p0.meituan.net/travelcube/03268b9dc49bd30bb63064421bb036bf90315.png" alt="图7 Worker执行任务"></p>
</li>
<li><p><strong>线程管理策略：</strong></p>
<ul>
<li>增加线程：<code>addWorker()</code>方法根据核心/非核心线程池容量添加线程。</li>
<li>线程回收：通过<code>processWorkerExit()</code>方法检测空闲线程，自动回收。</li>
<li>任务拒绝：实现<code>RejectedExecutionHandler</code>接口，自定义拒绝策略。</li>
</ul>
</li>
<li><p>线程池使用一张Hash表去持有线程的引用，这样可以通过添加引用、移除引用这样的操作来控制线程的生命周期。</p>
</li>
<li><p>判断线程是否正在运行：Worker是通过继承AQS，使用AQS来实现独占锁这个功能。没有使用可重入锁ReentrantLock，而是使用AQS，为的就是实现不可重入的特性去反应线程现在的执行状态。</p>
</li>
<li><p>1.lock方法一旦获取了独占锁，表示当前线程正在执行任务中。 2.如果正在执行任务，则不应该中断线程。 3.如果该线程现在不是独占锁的状态，也就是空闲的状态，说明它没有在处理任务，这时可以对该线程进行中断。 4.线程池在执行shutdown方法或tryTerminate方法时会调用</p>
</li>
<li><p>interruptIdleWorkers方法来中断空闲的线程，interruptIdleWorkers方法会使用tryLock方法来判断线程池中的线程是否是空闲状态；如果线程是空闲状态则可以安全回收。在线程回收过程中就使用到了这种特性，回收过程如下图所示：</p>
<p><img src="https://p1.meituan.net/travelcube/9d8dc9cebe59122127460f81a98894bb34085.png" alt="图8 线程池回收过程"></p>
</li>
<li><p>增加线程：增加线程是通过线程池中的addWorker方法，该方法的功能就是增加一个线程，该方法不考虑线程池是在哪个阶段增加的该线程，这个分配线程的策略是在上个步骤完成的，该步骤仅仅完成增加线程，并使它运行，最后返回是否成功这个结果。addWorker方法有两个参数：firstTask、core。firstTask参数用于指定新增的线程执行的第一个任务，该参数可以为空；core参数为true表示在新增线程时会判断当前活动线程数是否少于corePoolSize，false表示新增线程前需要判断当前活动线程数是否少于maximumPoolSize，其执行流程如下图所示：</p>
<p><img src="https://p0.meituan.net/travelcube/49527b1bb385f0f43529e57b614f59ae145454.png" alt="图9 申请线程执行流程图"></p>
<p>图9 申请线程执行流程图</p>
</li>
<li><p><strong>线程回收</strong>：</p>
</li>
<li><p>线程池中线程的销毁依赖JVM自动的回收，线程池做的工作是根据当前线程池的状态维护一定数量的线程引用，防止这部分线程被JVM回收，当线程池决定哪些线程需要回收时，只需要将其引用消除即可。Worker被创建出来后，就会不断地进行轮询，然后获取任务去执行，核心线程可以无限等待获取任务，非核心线程要限时获取任务。当Worker无法获取到任务，也就是获取的任务为空时，循环会结束，Worker会主动消除自身在线程池内的引用。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">  <span class="keyword">while</span> (task != <span class="keyword">null</span> || (task = getTask()) != <span class="keyword">null</span>) &#123;</span><br><span class="line">    <span class="comment">//执行任务</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">  processWorkerExit(w, completedAbruptly);<span class="comment">//获取不到任务时，主动回收自己</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>线程回收的工作是在processWorkerExit方法完成的。</p>
<p><img src="https://p0.meituan.net/travelcube/90ea093549782945f2c968403fdc39d415386.png" alt="图10 线程销毁流程"></p>
<p>事实上，在这个方法中，将线程引用移出线程池就已经结束了线程销毁的部分。但由于引起线程销毁的可能性有很多，线程池还要判断是什么引发了这次销毁，是否要改变线程池的现阶段状态，是否要根据新状态，重新分配线程。</p>
</li>
<li><p><strong>执行任务</strong>：在Worker类中的run方法调用了runWorker方法来执行任务，runWorker方法的执行过程如下：</p>
<p>1.while循环不断地通过getTask()方法获取任务。 2.getTask()方法从阻塞队列中取任务。 3.如果线程池正在停止，那么要保证当前线程是中断状态，否则要保证当前线程不是中断状态。 4.执行任务。 5.如果getTask结果为null则跳出循环，执行processWorkerExit()方法，销毁线程。</p>
<p>执行流程如下图所示：</p>
<p><img src="https://p0.meituan.net/travelcube/879edb4f06043d76cea27a3ff358cb1d45243.png" alt="图11 执行任务流程"></p>
</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li><p>线程中线程被抽象为静态内部类Worker，是基于AQS实现的存放在HashSet中；</p>
</li>
<li><p>要被执行的线程存放在BlockingQueue中；</p>
</li>
<li><p>基本思想就是从workQueue中取出要执行的任务，放在worker中处理；</p>
</li>
</ul>
<ul>
<li>提交一个任务，线程池里存活的核心线程数小于corePoolSize时，线程池会创建一个核心线程去处理提交的任务</li>
<li>如果线程池核心线程数已满，即线程数已经等于corePoolSize，一个新提交的任务，会被放进任务队列workQueue排队等待执行。</li>
<li>当线程池里面存活的线程数已经等于corePoolSize了，并且任务队列workQueue也满，判断线程数是否达到maximumPoolSize，即最大线程数是否已满，如果没到达，创建非核心线程执行提交的任务。</li>
<li>如果当前的线程数达到了maximumPoolSize，还有新的任务过来的话，直接采用拒绝策略处理。</li>
</ul>
<h4 id="问：如果线程池中的一个线程运行时出现了异常，会发生什么？"><a href="#问：如果线程池中的一个线程运行时出现了异常，会发生什么？" class="headerlink" title="问：如果线程池中的一个线程运行时出现了异常，会发生什么？"></a>问：如果线程池中的一个线程运行时出现了异常，会发生什么？</h4><p>如果提交任务的时候使用了submit，则返回的feature里会存有异常信息，但是如果数execute则会打印出异常栈。但是不会给其他线程造成影响。之后线程池会删除该线程，会新增加一个worker。</p>
<p>当一个线程池里面的线程异常后:</p>
<ol>
<li>当执行方式是execute时，可以看到堆栈异常的输出。<ul>
<li>执行在ThreadPoolExecutor.runWorker()方法中#task.run()，如果异常的话会直接throw所以可以看到异常堆栈输出。</li>
</ul>
</li>
<li>当执行方式是submit时，异常堆栈没有输出。但是调用Future.get()方法时，可以捕获到异常。<ul>
<li>原因：submit会先把任务封装为FutureTask，在调用ThreadPoolExecutor.runWorker()方法#task.run()后，还会继续执行FutureTask.run()方法，报错后会setException(ex)将异常存入，并没有抛出异常。直到调用Future.get()时才会将异常抛出。</li>
</ul>
</li>
<li>不会影响线程池里面其他线程的正常执行。</li>
<li>线程池会把这个线程移除掉，并创建一个新的线程放到线程池中。当线程异常，会调用ThreadPoolExecutor.runWorker()方法最后面的finally中的processWorkerExit()，会将此线程remove，并重新addworker()一个线程。</li>
</ol>
<h4 id="问：如何实现一个线程池，Java中线程池如何进行配置？线程池的线程数怎么确定？线程池的工作流程记得吗？如果是IO操作为主怎么确定？如果计算型操作又怎么确定？跳表的查询过程是怎么样的，查询和插入的时间复杂度-⭐⭐"><a href="#问：如何实现一个线程池，Java中线程池如何进行配置？线程池的线程数怎么确定？线程池的工作流程记得吗？如果是IO操作为主怎么确定？如果计算型操作又怎么确定？跳表的查询过程是怎么样的，查询和插入的时间复杂度-⭐⭐" class="headerlink" title="问：如何实现一个线程池，Java中线程池如何进行配置？线程池的线程数怎么确定？线程池的工作流程记得吗？如果是IO操作为主怎么确定？如果计算型操作又怎么确定？跳表的查询过程是怎么样的，查询和插入的时间复杂度?⭐⭐"></a>问：如何实现一个线程池，Java中线程池如何进行配置？线程池的线程数怎么确定？线程池的工作流程记得吗？如果是IO操作为主怎么确定？如果计算型操作又怎么确定？跳表的查询过程是怎么样的，查询和插入的时间复杂度?⭐⭐</h4><p>线程池的线程数怎么确定？</p>
<ol>
<li><strong>I/O 密集型任务:</strong><ul>
<li>I/O 操作等待时间较长，CPU 大部分时间在等待 I/O 操作完成。</li>
<li><strong>线程数公式:</strong> 线程数=CPU 核心数×2\text{线程数} = \text{CPU 核心数} \times 2线程数=CPU 核心数×2</li>
</ul>
</li>
<li><strong>计算密集型任务:</strong><ul>
<li>计算密集型任务几乎完全占用 CPU。</li>
<li><strong>线程数公式:</strong> 线程数=CPU 核心数+1\text{线程数} = \text{CPU 核心数} + 1线程数=CPU 核心数+1</li>
</ul>
</li>
<li><strong>混合型任务:</strong><ul>
<li>根据任务性质自定义线程池，适当增加线程数。</li>
</ul>
</li>
</ol>
<p>线程池的工作流程记得吗？</p>
<ol>
<li><strong>提交任务:</strong> 调用 <code>execute()</code> 或 <code>submit()</code> 方法提交任务。</li>
<li><strong>判断线程数:</strong><ul>
<li>如果运行线程数 &lt; <code>corePoolSize</code>，创建新线程。</li>
<li>如果运行线程数 ≥ <code>corePoolSize</code>，将任务加入 <code>workQueue</code>。</li>
<li>如果 <code>workQueue</code> 满了，且线程数 &lt; <code>maximumPoolSize</code>，则创建新线程。</li>
<li>如果线程数达到 <code>maximumPoolSize</code>，执行拒绝策略。</li>
</ul>
</li>
<li><strong>执行任务:</strong> 使用工作线程从队列中取任务并执行。</li>
<li><strong>线程回收:</strong> 空闲线程超过 <code>keepAliveTime</code> 时销毁。</li>
<li><strong>线程池终止:</strong> 调用 <code>shutdown()</code> 或 <code>shutdownNow()</code>。</li>
</ol>
<p>跳表的查询过程是怎么样的，查询和插入的时间复杂度?</p>
<ol>
<li>概述：跳表是一种多层链表结构，支持快速查找、插入和删除操作，是 <code>Redis</code> 和 <code>ConcurrentSkipListMap</code> 的基础结构。</li>
<li>查询过程：假设要查询目标值 <code>target</code>:<ol>
<li>从最高层链表头节点开始。</li>
<li>比较当前节点值：<ul>
<li>如果当前节点值 &lt; <code>target</code>，向右移动。</li>
<li>如果当前节点值 ≥ <code>target</code> 或到达层末尾，向下移动一层。</li>
</ul>
</li>
<li>继续上述过程，直到找到目标节点或遍历结束。</li>
</ol>
</li>
<li>插入过程：假设插入值为 <code>value</code>:<ol>
<li>从最高层开始，找到小于 <code>value</code> 的最后一个节点。</li>
<li>逐层插入节点，并根据随机概率决定是否增加节点高度。</li>
<li>如果节点高度超过当前最大高度，增加跳表高度。</li>
</ol>
</li>
<li>时间复杂度：</li>
</ol>
<table>
<thead>
<tr>
<th>操作</th>
<th>平均时间复杂度</th>
<th>最坏时间复杂度</th>
</tr>
</thead>
<tbody><tr>
<td>查询</td>
<td>O(log n)</td>
<td>O(n)</td>
</tr>
<tr>
<td>插入</td>
<td>O(log n)</td>
<td>O(n)</td>
</tr>
<tr>
<td>删除</td>
<td>O(log n)</td>
<td>O(n)</td>
</tr>
</tbody></table>
<h4 id="问：线程池里如何知道线程执行完了没有？线程阻塞怎么办？怎么保证所有线程执行完之后继续往下处理？怎么让一个线程等另一个线程执行结束？⭐⭐⭐"><a href="#问：线程池里如何知道线程执行完了没有？线程阻塞怎么办？怎么保证所有线程执行完之后继续往下处理？怎么让一个线程等另一个线程执行结束？⭐⭐⭐" class="headerlink" title="问：线程池里如何知道线程执行完了没有？线程阻塞怎么办？怎么保证所有线程执行完之后继续往下处理？怎么让一个线程等另一个线程执行结束？⭐⭐⭐"></a>问：线程池里如何知道线程执行完了没有？线程阻塞怎么办？怎么保证所有线程执行完之后继续往下处理？怎么让一个线程等另一个线程执行结束？⭐⭐⭐</h4><ul>
<li><p>线程池里如何知道线程执行完了没有？</p>
<ul>
<li><p>isTerminated 方法：利用线程池的终止状态（TERMINATED）来判断线程池的任务是否已经全部执行完。需要调用线程池的 shutdown 方法，不然线程池一直会处于 RUNNING 运行状态。问题是需要关闭线程池。</p>
</li>
<li><p>getCompletedTaskCount 方法：判断线程池中的计划执行任务数和已完成任务数 threadPool.getTaskCount() != threadPool.getCompletedTaskCount()。但问题是两个方法返回的值是动态变化的不是一个准确的数值。</p>
</li>
<li><p>Future接口：该接口可以判断单个任务是否执行完成。</p>
<ul>
<li><code>ExecutorService.submit(Callable/Void)</code> 方法会返回 <code>Future</code> 对象。</li>
<li><strong><code>future.isDone()</code></strong> 轮询任务状态，直到完成。</li>
<li><strong><code>future.get()</code></strong> 获取任务结果，如果未完成会阻塞。</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line">    </span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">    ExecutorService executor = Executors.newFixedThreadPool(<span class="number">3</span>);</span><br><span class="line">    List&lt;Future&lt;String&gt;&gt; futures = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 提交任务</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">5</span>; i++) &#123;</span><br><span class="line">        <span class="keyword">final</span> <span class="keyword">int</span> taskId = i;</span><br><span class="line">        futures.add(executor.submit(() -&gt; &#123;</span><br><span class="line">            Thread.sleep(<span class="number">1000</span>);  <span class="comment">// 模拟任务</span></span><br><span class="line">            <span class="keyword">return</span> <span class="string">&quot;任务 &quot;</span> + taskId + <span class="string">&quot; 完成&quot;</span>;</span><br><span class="line">        &#125;));</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 检查是否所有任务完成</span></span><br><span class="line">    <span class="keyword">boolean</span> allDone = <span class="keyword">false</span>;</span><br><span class="line">    <span class="keyword">while</span> (!allDone) &#123;</span><br><span class="line">        allDone = futures.stream().allMatch(Future::isDone);</span><br><span class="line">        System.out.println(<span class="string">&quot;是否全部完成: &quot;</span> + allDone);</span><br><span class="line">        Thread.sleep(<span class="number">500</span>);  <span class="comment">// 轮询间隔</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 或者通过executor.invokeAll一次性全部提交所有任务</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 获取任务结果</span></span><br><span class="line">    <span class="keyword">for</span> (Future&lt;String&gt; future : futures) &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            System.out.println(future.get());</span><br><span class="line">        &#125; <span class="keyword">catch</span> (ExecutionException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    executor.shutdown();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li><p>CountDownLatch：使用其作为计数器，初始为任务数N，每完成一个任务就-1，为0表示全部执行完。缺点是CountDownLatch只能被使用一次。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> taskCount = <span class="number">5</span>;</span><br><span class="line">    CountDownLatch latch = <span class="keyword">new</span> CountDownLatch(taskCount);</span><br><span class="line">    ExecutorService executor = Executors.newFixedThreadPool(<span class="number">3</span>);</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; taskCount; i++) &#123;</span><br><span class="line">        <span class="keyword">final</span> <span class="keyword">int</span> taskId = i;</span><br><span class="line">        executor.execute(() -&gt; &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;执行任务：&quot;</span> + taskId);</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                Thread.sleep(<span class="number">1000</span>);  <span class="comment">// 模拟任务执行</span></span><br><span class="line">            &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">            latch.countDown();  <span class="comment">// 任务完成，计数减一</span></span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    System.out.println(<span class="string">&quot;等待所有任务完成...&quot;</span>);</span><br><span class="line">    latch.await();  <span class="comment">// 等待计数器归零</span></span><br><span class="line">    System.out.println(<span class="string">&quot;所有任务完成！&quot;</span>);</span><br><span class="line">    executor.shutdown();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li><p>CyclicBarrier：则可以循环重复使用，通过reset方法重置。适用于多个线程到达同步点时相互等待，支持重用。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> threadCount = <span class="number">3</span>;</span><br><span class="line">        CyclicBarrier barrier = <span class="keyword">new</span> CyclicBarrier(threadCount, () -&gt; </span><br><span class="line">            System.out.println(<span class="string">&quot;所有线程到达屏障点，继续执行...&quot;</span>)</span><br><span class="line">        );</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; threadCount; i++) &#123;</span><br><span class="line">            <span class="keyword">final</span> <span class="keyword">int</span> threadId = i;</span><br><span class="line">            <span class="keyword">new</span> Thread(() -&gt; &#123;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    System.out.println(<span class="string">&quot;线程 &quot;</span> + threadId + <span class="string">&quot; 正在执行任务...&quot;</span>);</span><br><span class="line">                    Thread.sleep((<span class="keyword">long</span>) (Math.random() * <span class="number">3000</span>));</span><br><span class="line">                    System.out.println(<span class="string">&quot;线程 &quot;</span> + threadId + <span class="string">&quot; 到达屏障点&quot;</span>);</span><br><span class="line">                    barrier.await();  <span class="comment">// 等待其他线程</span></span><br><span class="line">                    System.out.println(<span class="string">&quot;线程 &quot;</span> + threadId + <span class="string">&quot; 开始执行下一阶段任务&quot;</span>);</span><br><span class="line">                &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;).start();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="comment">// 主线程不参与等待，barrier.await() 会阻塞线程，直到所有线程都到达屏障点。</span></span><br><span class="line"><span class="comment">// Runnable 动作在所有线程到达屏障时触发。</span></span><br></pre></td></tr></table></figure></li>
</ul>
</li>
<li><p>线程阻塞怎么办？</p>
<ol>
<li><p>调整线程池配置，置合理的 <code>corePoolSize</code>、<code>maximumPoolSize</code>、<code>queueCapacity</code>。<strong>避免核心线程被长时间占用</strong>，使用 <code>CachedThreadPool</code> 适合短时任务。<strong>使用 <code>ThreadPoolExecutor</code> 配置</strong> <code>keepAliveTime</code> 控制闲置线程销毁。</p>
</li>
<li><p>使用超时控制机制。<strong>设置超时时间</strong>（<code>Future.get(timeout)</code>）。**<code>future.cancel(true)</code>** 取消任务。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">    ExecutorService executor = Executors.newFixedThreadPool(<span class="number">2</span>);</span><br><span class="line">    </span><br><span class="line">    Callable&lt;String&gt; task = () -&gt; &#123;</span><br><span class="line">        Thread.sleep(<span class="number">5000</span>);  <span class="comment">// 模拟长时间任务</span></span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;任务完成&quot;</span>;</span><br><span class="line">    &#125;;</span><br><span class="line">     </span><br><span class="line">    Future&lt;String&gt; future = executor.submit(task);</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        System.out.println(future.get(<span class="number">3</span>, TimeUnit.SECONDS));  <span class="comment">// 超时设置为3秒</span></span><br><span class="line">    &#125; <span class="keyword">catch</span> (TimeoutException e) &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;任务超时，取消任务&quot;</span>);</span><br><span class="line">        future.cancel(<span class="keyword">true</span>);  <span class="comment">// 超时后取消任务</span></span><br><span class="line">    &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">        e.printStackTrace();</span><br><span class="line">    &#125;</span><br><span class="line">    executor.shutdown();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li><p>优化锁管理与同步机制：尽量使用无锁设计（如 <code>ConcurrentHashMap</code>、<code>Atomic</code> 类）。使用 <code>ReentrantLock</code> 并启用公平锁避免饥饿。</p>
</li>
<li><p>使用异步框架，如 <code>CompletableFuture</code> 或 Reactor，减少阻塞等待：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">AsyncExample</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        CompletableFuture.supplyAsync(() -&gt; &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                Thread.sleep(<span class="number">2000</span>);</span><br><span class="line">            &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> <span class="string">&quot;异步任务完成&quot;</span>;</span><br><span class="line">        &#125;).thenAccept(result -&gt; System.out.println(result));</span><br><span class="line">        System.out.println(<span class="string">&quot;主线程继续执行...&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ol>
</li>
<li><p>怎么保证所有线程执行完之后继续往下处理？</p>
<ul>
<li><p>使用 <code>awaitTermination()</code> 方法：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">ExecutorService executor = Executors.newFixedThreadPool(<span class="number">3</span>);</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">5</span>; i++) &#123;</span><br><span class="line">    <span class="keyword">final</span> <span class="keyword">int</span> taskId = i;</span><br><span class="line">    executor.execute(() -&gt; &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;执行任务：&quot;</span> + taskId);</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;</span><br><span class="line">executor.shutdown();</span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (!executor.awaitTermination(<span class="number">60</span>, TimeUnit.SECONDS)) &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;超时未完成&quot;</span>);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;所有任务完成&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">    e.printStackTrace();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li><p>使用 <code>CountDownLatch</code> ：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> taskCount = <span class="number">5</span>;</span><br><span class="line">CountDownLatch latch = <span class="keyword">new</span> CountDownLatch(taskCount);</span><br><span class="line">ExecutorService executor = Executors.newFixedThreadPool(<span class="number">3</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; taskCount; i++) &#123;</span><br><span class="line">    <span class="keyword">final</span> <span class="keyword">int</span> taskId = i;</span><br><span class="line">    executor.execute(() -&gt; &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;执行任务：&quot;</span> + taskId);</span><br><span class="line">        latch.countDown();  <span class="comment">// 减少计数</span></span><br><span class="line">    &#125;);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">    latch.await();  <span class="comment">// 等待任务完成</span></span><br><span class="line">    System.out.println(<span class="string">&quot;所有任务完成&quot;</span>);</span><br><span class="line">&#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">    e.printStackTrace();</span><br><span class="line">&#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">    executor.shutdown();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li></li>
</ul>
</li>
<li><p>怎么让一个线程等另一个线程执行结束？</p>
<ul>
<li><p>使用 <code>join()</code> 方法：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">Thread t1 = <span class="keyword">new</span> Thread(() -&gt; &#123;</span><br><span class="line">    System.out.println(<span class="string">&quot;线程1开始&quot;</span>);</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        Thread.sleep(<span class="number">2000</span>);</span><br><span class="line">    &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">        e.printStackTrace();</span><br><span class="line">    &#125;</span><br><span class="line">    System.out.println(<span class="string">&quot;线程1结束&quot;</span>);</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">Thread t2 = <span class="keyword">new</span> Thread(() -&gt; &#123;</span><br><span class="line">    System.out.println(<span class="string">&quot;线程2等待线程1执行完成&quot;</span>);</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        t1.join();  <span class="comment">// 等待线程1完成</span></span><br><span class="line">    &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">        e.printStackTrace();</span><br><span class="line">    &#125;</span><br><span class="line">    System.out.println(<span class="string">&quot;线程2开始执行&quot;</span>);</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">t1.start();</span><br><span class="line">t2.start();</span><br></pre></td></tr></table></figure></li>
<li><p>使用 <code>Future.get()</code> ：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">ExecutorService executor = Executors.newSingleThreadExecutor();</span><br><span class="line">Future&lt;String&gt; future = executor.submit(() -&gt; &#123;</span><br><span class="line">    Thread.sleep(<span class="number">3000</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="string">&quot;任务完成&quot;</span>;</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">    System.out.println(<span class="string">&quot;等待任务结果...&quot;</span>);</span><br><span class="line">    String result = future.get();  <span class="comment">// 阻塞等待结果</span></span><br><span class="line">    System.out.println(<span class="string">&quot;任务结果：&quot;</span> + result);</span><br><span class="line">&#125; <span class="keyword">catch</span> (InterruptedException | ExecutionException e) &#123;</span><br><span class="line">    e.printStackTrace();</span><br><span class="line">&#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">    executor.shutdown();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li><p>CountDownLatch、CyclicBarrier</p>
</li>
</ul>
</li>
<li></li>
</ul>
<h4 id="问：Java-的信号灯？⭐"><a href="#问：Java-的信号灯？⭐" class="headerlink" title="问：Java 的信号灯？⭐"></a>问：Java 的信号灯？⭐</h4><ul>
<li><strong>信号灯 (Semaphore)</strong> 是一种同步机制，属于 <code>java.util.concurrent</code> 包。它用于控制对共享资源的访问，常用于实现<strong>限流</strong>、<strong>连接池管理</strong>、<strong>资源分配</strong>等场景。</li>
</ul>
<ul>
<li><strong>构造方法:</strong><ul>
<li><code>Semaphore(int permits)</code>：创建一个具有指定许可数的信号灯，默认非公平。</li>
<li><code>Semaphore(int permits, boolean fair)</code>：指定许可数和公平性。</li>
</ul>
</li>
<li><strong>重要方法:</strong><ul>
<li><code>acquire()</code>：获取许可，若无可用许可则阻塞。</li>
<li><code>acquire(int permits)</code>：获取多个许可。</li>
<li><code>release()</code>：释放许可，增加可用许可数。</li>
<li><code>release(int permits)</code>：释放多个许可。</li>
<li><code>availablePermits()</code>：查询剩余许可数量。</li>
<li><code>tryAcquire()</code>：尝试获取许可，立即返回 <code>true</code> 或 <code>false</code>。</li>
</ul>
</li>
</ul>
<ul>
<li>信号灯的工作机制：<ul>
<li><strong>许可数:</strong> 表示资源数量。</li>
<li>公平性:<ul>
<li><strong>公平信号灯:</strong> 按请求的先后顺序分配许可，类似于队列管理。</li>
<li><strong>非公平信号灯:</strong> 可能会优先分配给新请求，吞吐量较高。</li>
</ul>
</li>
</ul>
</li>
<li>使用示例: 限制并发访问，场景: 模拟停车场管理，最多允许三个车辆进入。</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.concurrent.Semaphore;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ParkingLot</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 最多容纳 3 辆车</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> Semaphore parkingSlots = <span class="keyword">new</span> Semaphore(<span class="number">3</span>);</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= <span class="number">6</span>; i++) &#123;</span><br><span class="line">            <span class="keyword">final</span> <span class="keyword">int</span> car = i;</span><br><span class="line">            <span class="keyword">new</span> Thread(() -&gt; &#123;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    System.out.println(<span class="string">&quot;Car &quot;</span> + car + <span class="string">&quot; is trying to enter.&quot;</span>);</span><br><span class="line">                    parkingSlots.acquire();  <span class="comment">// 获取许可</span></span><br><span class="line">                    System.out.println(<span class="string">&quot;Car &quot;</span> + car + <span class="string">&quot; has parked.&quot;</span>);</span><br><span class="line">                    Thread.sleep(<span class="number">2000</span>);  <span class="comment">// 模拟停车时间</span></span><br><span class="line">                &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">                    parkingSlots.release();  <span class="comment">// 释放许可</span></span><br><span class="line">                    System.out.println(<span class="string">&quot;Car &quot;</span> + car + <span class="string">&quot; has left.&quot;</span>);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;).start();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>适用场景与应用：<ol>
<li><strong>限流控制:</strong> 控制访问共享资源的最大并发数（如 API 调用限流）。</li>
<li><strong>资源池管理:</strong> 数据库连接池或对象池管理。</li>
<li><strong>多线程任务管理:</strong> 控制线程运行数量，防止资源耗尽。</li>
</ol>
</li>
<li>注意事项:<ul>
<li><strong>公平性权衡:</strong> 公平性降低了性能，但保证了任务公平执行。</li>
<li><strong>资源正确释放:</strong> 必须在 <code>finally</code> 块中释放许可，防止死锁。</li>
<li><strong>许可数量动态调整:</strong> 可根据负载情况调整许可数量，支持灵活扩展。</li>
</ul>
</li>
</ul>
<h4 id="问：Executors-静态方法？"><a href="#问：Executors-静态方法？" class="headerlink" title="问：Executors 静态方法？"></a>问：Executors 静态方法？</h4><p><code>Executors</code> 是 Java 中的一个工具类，提供了创建线程池的静态方法。以下是常用的 <code>Executors</code> 静态方法：</p>
<ol>
<li>创建线程池方法：</li>
</ol>
<table>
<thead>
<tr>
<th>方法</th>
<th>描述</th>
</tr>
</thead>
<tbody><tr>
<td><code>newFixedThreadPool(int nThreads)</code></td>
<td>创建一个固定大小的线程池，最多可同时运行 <code>nThreads</code> 个线程。</td>
</tr>
<tr>
<td><code>newCachedThreadPool()</code></td>
<td>创建一个可根据需要创建新线程的线程池（无限制），适用于执行大量短期异步任务。</td>
</tr>
<tr>
<td><code>newSingleThreadExecutor()</code></td>
<td>创建一个单线程的线程池，所有任务将被顺序执行。</td>
</tr>
<tr>
<td><code>newScheduledThreadPool(int nThreads)</code></td>
<td>创建一个线程池，可用于定时或周期性任务。</td>
</tr>
<tr>
<td><code>newWorkStealingPool(int parallelism)</code></td>
<td>创建一个基于工作窃取的线程池，适用于并行任务（Java 8+）。</td>
</tr>
</tbody></table>
<p><strong>2. 定时任务方法</strong></p>
<p>这些方法返回 <code>ScheduledExecutorService</code>，用于延时和周期性执行任务。</p>
<table>
<thead>
<tr>
<th>方法</th>
<th>描述</th>
</tr>
</thead>
<tbody><tr>
<td><code>schedule(Runnable command, long delay, TimeUnit unit)</code></td>
<td>在指定延时后执行一次任务。</td>
</tr>
<tr>
<td><code>schedule(Callable&lt;V&gt; callable, long delay, TimeUnit unit)</code></td>
<td>在延时后执行任务并返回结果。</td>
</tr>
<tr>
<td><code>scheduleAtFixedRate(Runnable command, long initialDelay, long period, TimeUnit unit)</code></td>
<td>按固定周期执行任务，从任务开始时间算起。</td>
</tr>
<tr>
<td><code>scheduleWithFixedDelay(Runnable command, long initialDelay, long delay, TimeUnit unit)</code></td>
<td>按固定延时执行任务，从上次任务完成时间算起。</td>
</tr>
</tbody></table>
<p><strong>3. 关闭线程池方法</strong></p>
<table>
<thead>
<tr>
<th>方法</th>
<th>描述</th>
</tr>
</thead>
<tbody><tr>
<td><code>shutdown()</code></td>
<td>优雅关闭线程池，等待已提交的任务完成。</td>
</tr>
<tr>
<td><code>shutdownNow()</code></td>
<td>立即停止所有正在执行的任务，返回未执行的任务列表。</td>
</tr>
<tr>
<td><code>awaitTermination(long timeout, TimeUnit unit)</code></td>
<td>阻塞直到所有任务完成或超时。</td>
</tr>
</tbody></table>
<hr>
<h3 id="1-5-线程安全"><a href="#1-5-线程安全" class="headerlink" title="1.5 线程安全"></a>1.5 线程安全</h3><h4 id="问：谈一下对线程安全的理解？用什么方法保证线程的安全？"><a href="#问：谈一下对线程安全的理解？用什么方法保证线程的安全？" class="headerlink" title="问：谈一下对线程安全的理解？用什么方法保证线程的安全？"></a>问：谈一下对线程安全的理解？用什么方法保证线程的安全？</h4><ul>
<li><p>谈一下对线程安全的理解？</p>
<ul>
<li><p>线程安全是指在多线程环境中，多个线程访问共享资源时，程序能够正确运行，不会产生数据不一致或其他不可预期的行为。</p>
<p>在多线程环境中，线程的交替执行可能导致 <strong>竞态条件（Race Condition）</strong>、<strong>数据竞争（Data Race）</strong> 和 <strong>死锁（Deadlock）</strong> 等问题。因此，需要采取适当的机制来确保线程安全。</p>
</li>
</ul>
</li>
<li><p>用什么方法保证线程的安全？</p>
<ol>
<li>使用不可变对象，如<code>String</code>, <code>Integer</code>, <code>BigDecimal</code>, <code>LocalDateTime</code>。</li>
<li>使用锁机制：同步代码块（synchronized）、ReentrantLock等。</li>
<li>使用原子变量：<code>java.util.concurrent.atomic</code> 包中的类，如 <code>AtomicInteger</code>、<code>AtomicLong</code>，实现无锁线程安全操作。</li>
<li>使用 <code>java.util.concurrent</code> 中的线程安全集合，如：ConcurrentHashMap、CopyOnWriteArrayList、ConcurrentLinkedQueue等。</li>
<li>使用 Java 提供的并发工具类，如 <code>CountDownLatch</code>, <code>CyclicBarrier</code>, <code>Semaphore</code>, <code>ReadWriteLock</code>, <code>ExecutorService</code> 等，确保线程协调和同步。</li>
</ol>
</li>
<li><p>选择线程安全方案的原则：</p>
<ol>
<li><strong>数据不可变时，优先考虑不可变类</strong>。</li>
<li><strong>数据量小、操作简单时，考虑同步方法或代码块</strong>。</li>
<li><strong>多线程频繁访问时，使用并发集合或原子变量</strong>。</li>
<li><strong>有复杂同步需求时，使用高级并发工具类</strong>。</li>
<li><strong>无共享数据时，考虑 ThreadLocal</strong>。</li>
</ol>
</li>
</ul>
<h4 id="问：如何实现一个线程安全的计数器？"><a href="#问：如何实现一个线程安全的计数器？" class="headerlink" title="问：如何实现一个线程安全的计数器？"></a>问：如何实现一个线程安全的计数器？</h4><table>
<thead>
<tr>
<th>实现方式</th>
<th>适用场景</th>
<th>优点</th>
<th>缺点</th>
</tr>
</thead>
<tbody><tr>
<td><code>synchronized</code></td>
<td>简单计数，低并发</td>
<td>简单易用</td>
<td>性能受限于锁机制</td>
</tr>
<tr>
<td><code>ReentrantLock</code></td>
<td>复杂同步场景</td>
<td>灵活，功能强大</td>
<td>锁管理复杂</td>
</tr>
<tr>
<td><code>AtomicInteger</code></td>
<td>中低并发环境，简单计数</td>
<td>高性能，无锁实现</td>
<td>功能有限</td>
</tr>
<tr>
<td><code>LongAdder</code></td>
<td>高并发环境，频繁更新</td>
<td>高性能，分段计数</td>
<td>读取值略复杂</td>
</tr>
<tr>
<td><code>ConcurrentHashMap</code></td>
<td>多键计数，实时统计</td>
<td>自动线程安全</td>
<td>内存占用较大</td>
</tr>
</tbody></table>
<p><strong>1. 使用 <code>synchronized</code> 关键字</strong>：将关键方法或代码块同步，确保同一时刻只有一个线程执行。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">SynchronizedCounter</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> count = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">increment</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        count++;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">int</span> <span class="title">getCount</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> count;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>特点</strong>:</p>
<ul>
<li>简单直接。</li>
<li>性能受限于锁的粒度。</li>
</ul>
<p>**2. 使用 <code>ReentrantLock</code>**：通过显式锁，灵活控制锁的获取和释放。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.concurrent.locks.ReentrantLock;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ReentrantLockCounter</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> count = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> ReentrantLock lock = <span class="keyword">new</span> ReentrantLock();</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">increment</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        lock.lock();</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            count++;</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            lock.unlock();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getCount</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        lock.lock();</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> count;</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            lock.unlock();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>特点</strong>:</p>
<ul>
<li>更灵活，可实现公平锁或非公平锁。</li>
<li>手动控制锁，代码复杂度增加。</li>
</ul>
<p><strong>3. 使用 <code>AtomicInteger</code>（推荐）</strong>：<code>AtomicInteger</code> 是无锁的线程安全实现，基于 CAS（Compare-And-Swap）机制。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.concurrent.atomic.AtomicInteger;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">AtomicCounter</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> AtomicInteger count = <span class="keyword">new</span> AtomicInteger(<span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">increment</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        count.incrementAndGet();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getCount</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> count.get();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>特点</strong>:</p>
<ul>
<li>无锁实现，性能高。</li>
<li>适用于计数操作较为简单的场景。</li>
</ul>
<p><strong>4. 使用 <code>LongAdder</code>（高并发推荐）</strong>：<code>LongAdder</code> 是 <code>AtomicLong</code> 的改进版本，适合高并发环境。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.concurrent.atomic.LongAdder;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">LongAdderCounter</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> LongAdder count = <span class="keyword">new</span> LongAdder();</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">increment</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        count.increment();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">long</span> <span class="title">getCount</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> count.sum();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>特点</strong>:</p>
<ul>
<li>在高并发场景中性能优于 <code>AtomicInteger</code>。</li>
<li>适合频繁更新但读取不多的场景。</li>
</ul>
<p><strong>5. 使用 <code>ConcurrentHashMap</code>（计数表）</strong>：适用于统计多个计数值，如网站访问量或实时统计。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.concurrent.ConcurrentHashMap;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ConcurrentMapCounter</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> ConcurrentHashMap&lt;String, Integer&gt; counter = <span class="keyword">new</span> ConcurrentHashMap&lt;&gt;();</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">increment</span><span class="params">(String key)</span> </span>&#123;</span><br><span class="line">        counter.merge(key, <span class="number">1</span>, Integer::sum);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getCount</span><span class="params">(String key)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> counter.getOrDefault(key, <span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>特点</strong>:</p>
<ul>
<li>适合多键值计数。</li>
<li>无需显式同步。</li>
</ul>
<h4 id="问：请写一个线程安全的单例模式？饿汉式，懒汉式等。两次判断-instance-是否为空，每次判断的作用是什么？"><a href="#问：请写一个线程安全的单例模式？饿汉式，懒汉式等。两次判断-instance-是否为空，每次判断的作用是什么？" class="headerlink" title="问：请写一个线程安全的单例模式？饿汉式，懒汉式等。两次判断 instance 是否为空，每次判断的作用是什么？"></a>问：请写一个线程安全的单例模式？饿汉式，懒汉式等。两次判断 instance 是否为空，每次判断的作用是什么？</h4><table>
<thead>
<tr>
<th>实现方式</th>
<th>线程安全</th>
<th>延迟加载</th>
<th>简洁性</th>
<th>性能</th>
</tr>
</thead>
<tbody><tr>
<td>饿汉式</td>
<td>是</td>
<td>否</td>
<td>简单</td>
<td>高</td>
</tr>
<tr>
<td>懒汉式（双重检查）</td>
<td>是</td>
<td>是</td>
<td>一般</td>
<td>高</td>
</tr>
<tr>
<td>静态内部类</td>
<td>是</td>
<td>是</td>
<td>简单</td>
<td>高</td>
</tr>
<tr>
<td>枚举实现</td>
<td>是</td>
<td>否（但不浪费）</td>
<td>简单</td>
<td>高</td>
</tr>
</tbody></table>
<p><strong>1. 饿汉式（静态初始化）</strong>：线程安全，类加载时创建实例。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SingletonEager</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> SingletonEager INSTANCE = <span class="keyword">new</span> SingletonEager();</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="title">SingletonEager</span><span class="params">()</span> </span>&#123;&#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> SingletonEager <span class="title">getInstance</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> INSTANCE;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>特点:</strong></p>
<ul>
<li>优点: 实现简单，线程安全。</li>
<li>缺点: 类加载时就初始化，可能造成资源浪费。</li>
</ul>
<p><strong>2. 懒汉式（双重检查锁定）</strong>：延迟加载，确保实例只在第一次访问时创建。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SingletonLazy</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">volatile</span> SingletonLazy instance;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="title">SingletonLazy</span><span class="params">()</span> </span>&#123;&#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> SingletonLazy <span class="title">getInstance</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (instance == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">synchronized</span> (SingletonLazy.class) &#123;</span><br><span class="line">                <span class="keyword">if</span> (instance == <span class="keyword">null</span>) &#123;</span><br><span class="line">                    instance = <span class="keyword">new</span> SingletonLazy();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> instance;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>特点:</strong></p>
<ul>
<li>优点: 延迟加载，线程安全，性能较好。</li>
<li>缺点: 实现稍复杂，需使用 <code>volatile</code> 防止指令重排序。</li>
</ul>
<p><strong>3. 静态内部类（推荐）</strong>：利用类加载机制，延迟加载，线程安全。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SingletonHolder</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="title">SingletonHolder</span><span class="params">()</span> </span>&#123;&#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Holder</span> </span>&#123;</span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> SingletonHolder INSTANCE = <span class="keyword">new</span> SingletonHolder();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> SingletonHolder <span class="title">getInstance</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> Holder.INSTANCE;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>特点:</strong></p>
<ul>
<li>优点: 延迟加载，线程安全，实现简单。</li>
<li>缺点: 依赖于类加载机制，适用于大多数情况。</li>
</ul>
<p><strong>4. 枚举实现（最推荐）</strong>：天生线程安全，防止反序列化和反射攻击。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">enum</span> <span class="title">SingletonEnum</span> </span>&#123;</span><br><span class="line">    INSTANCE;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">doSomething</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;Singleton using Enum&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>特点:</strong></p>
<ul>
<li>优点: 简洁，线程安全，防止序列化和反射攻击。</li>
<li>缺点: 适用于单例对象场景，扩展性稍差。</li>
</ul>
<p>在双重检查锁定的懒汉式单例实现中，<code>instance</code> 被检查了两次。每次检查的作用如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Singleton</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 使用 volatile 确保可见性和防止指令重排序</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">volatile</span> Singleton instance;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="title">Singleton</span><span class="params">()</span> </span>&#123;&#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Singleton <span class="title">getInstance</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (instance == <span class="keyword">null</span>) &#123; <span class="comment">// 第一次检查</span></span><br><span class="line">            <span class="keyword">synchronized</span> (Singleton.class) &#123;</span><br><span class="line">                <span class="keyword">if</span> (instance == <span class="keyword">null</span>) &#123; <span class="comment">// 第二次检查</span></span><br><span class="line">                    instance = <span class="keyword">new</span> Singleton();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> instance;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p><strong>为什么需要两次检查？</strong></p>
<ol>
<li><p>第一次检查 (不加锁)：<code>if (instance == null)</code> </p>
<ul>
<li><strong>作用:</strong> 避免不必要的加锁。</li>
<li><strong>原因:</strong> 单例对象通常只需要创建一次。在大多数情况下，<code>instance</code> 已经被初始化，这样可以跳过锁定过程，提高性能。</li>
</ul>
</li>
<li><p>第二次检查 (加锁内)：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">synchronized</span> (Singleton.class) &#123;</span><br><span class="line">    <span class="keyword">if</span> (instance == <span class="keyword">null</span>) &#123;</span><br><span class="line">        instance = <span class="keyword">new</span> Singleton();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li><strong>作用:</strong> 确保对象的唯一性，防止多线程竞争时重复创建实例。</li>
<li><strong>原因:</strong> 多个线程可能在第一次检查时都看到 <code>instance == null</code>，因此进入同步块。在同步块中再次检查，确保只有第一个到达的线程初始化实例，其余线程不会重复创建。</li>
</ul>
</li>
<li><p>总结：双重检查锁定确保了 <strong>线程安全</strong> 与 <strong>性能优化</strong> 的平衡，是一种推荐的懒汉式单例实现方式。</p>
<ul>
<li><strong>没有第一次检查:</strong> 每次获取实例时都会加锁，性能较低。</li>
<li><strong>没有第二次检查:</strong> 多个线程可能同时通过第一次检查，导致重复创建实例，破坏单例模式的唯一性。</li>
</ul>
</li>
</ol>
<h4 id="问：ABC-三个线程如何保证顺序执行？"><a href="#问：ABC-三个线程如何保证顺序执行？" class="headerlink" title="问：ABC 三个线程如何保证顺序执行？"></a>问：ABC 三个线程如何保证顺序执行？</h4><p>选择适合的方案：</p>
<ul>
<li><strong>简单控制:</strong> 使用 <code>join()</code></li>
<li><strong>多线程同步:</strong> 使用 <code>CountDownLatch</code> 或 <code>Semaphore</code></li>
<li><strong>精确控制:</strong> 使用 <code>ReentrantLock</code> 和 <code>Condition</code></li>
</ul>
<ol>
<li><p>使用 <code>join()</code>：主线程启动 A，等待 A 结束，再启动 B，等待 B 结束，最后启动 C。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">JoinExample</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">        Thread threadA = <span class="keyword">new</span> Thread(() -&gt; System.out.println(<span class="string">&quot;A&quot;</span>));</span><br><span class="line">        Thread threadB = <span class="keyword">new</span> Thread(() -&gt; System.out.println(<span class="string">&quot;B&quot;</span>));</span><br><span class="line">        Thread threadC = <span class="keyword">new</span> Thread(() -&gt; System.out.println(<span class="string">&quot;C&quot;</span>));</span><br><span class="line"></span><br><span class="line">        threadA.start();</span><br><span class="line">        threadA.join();  <span class="comment">// 等待 A 执行完</span></span><br><span class="line"></span><br><span class="line">        threadB.start();</span><br><span class="line">        threadB.join();  <span class="comment">// 等待 B 执行完</span></span><br><span class="line"></span><br><span class="line">        threadC.start();</span><br><span class="line">        threadC.join();  <span class="comment">// 等待 C 执行完</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li><p>**使用 <code>CountDownLatch</code>**：使用 <code>CountDownLatch</code> 控制线程的启动顺序。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.concurrent.CountDownLatch;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">CountDownLatchExample</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        CountDownLatch latchA = <span class="keyword">new</span> CountDownLatch(<span class="number">0</span>);  <span class="comment">// A 无需等待</span></span><br><span class="line">        CountDownLatch latchB = <span class="keyword">new</span> CountDownLatch(<span class="number">1</span>);  <span class="comment">// B 等待 A</span></span><br><span class="line">        CountDownLatch latchC = <span class="keyword">new</span> CountDownLatch(<span class="number">1</span>);  <span class="comment">// C 等待 B</span></span><br><span class="line"></span><br><span class="line">        Thread threadA = <span class="keyword">new</span> Thread(() -&gt; &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;A&quot;</span>);</span><br><span class="line">            latchB.countDown();  <span class="comment">// 通知 B 开始</span></span><br><span class="line">        &#125;);</span><br><span class="line"></span><br><span class="line">        Thread threadB = <span class="keyword">new</span> Thread(() -&gt; &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                latchB.await();  <span class="comment">// 等待 A 完成</span></span><br><span class="line">                System.out.println(<span class="string">&quot;B&quot;</span>);</span><br><span class="line">                latchC.countDown();  <span class="comment">// 通知 C 开始</span></span><br><span class="line">            &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                Thread.currentThread().interrupt();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line"></span><br><span class="line">        Thread threadC = <span class="keyword">new</span> Thread(() -&gt; &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                latchC.await();  <span class="comment">// 等待 B 完成</span></span><br><span class="line">                System.out.println(<span class="string">&quot;C&quot;</span>);</span><br><span class="line">            &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                Thread.currentThread().interrupt();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line"></span><br><span class="line">        threadA.start();</span><br><span class="line">        threadB.start();</span><br><span class="line">        threadC.start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li><p>使用 <code>Semaphore</code>：<code>Semaphore</code> 控制线程的执行时机。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.concurrent.Semaphore;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SemaphoreExample</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Semaphore semA = <span class="keyword">new</span> Semaphore(<span class="number">1</span>);  <span class="comment">// A 可直接执行</span></span><br><span class="line">        Semaphore semB = <span class="keyword">new</span> Semaphore(<span class="number">0</span>);  <span class="comment">// B 等待 A</span></span><br><span class="line">        Semaphore semC = <span class="keyword">new</span> Semaphore(<span class="number">0</span>);  <span class="comment">// C 等待 B</span></span><br><span class="line"></span><br><span class="line">        Thread threadA = <span class="keyword">new</span> Thread(() -&gt; &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                semA.acquire();</span><br><span class="line">                System.out.println(<span class="string">&quot;A&quot;</span>);</span><br><span class="line">                semB.release();  <span class="comment">// 通知 B</span></span><br><span class="line">            &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                Thread.currentThread().interrupt();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line"></span><br><span class="line">        Thread threadB = <span class="keyword">new</span> Thread(() -&gt; &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                semB.acquire();</span><br><span class="line">                System.out.println(<span class="string">&quot;B&quot;</span>);</span><br><span class="line">                semC.release();  <span class="comment">// 通知 C</span></span><br><span class="line">            &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                Thread.currentThread().interrupt();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line"></span><br><span class="line">        Thread threadC = <span class="keyword">new</span> Thread(() -&gt; &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                semC.acquire();</span><br><span class="line">                System.out.println(<span class="string">&quot;C&quot;</span>);</span><br><span class="line">            &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                Thread.currentThread().interrupt();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line"></span><br><span class="line">        threadA.start();</span><br><span class="line">        threadB.start();</span><br><span class="line">        threadC.start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li><p>使用 <code>ReentrantLock</code> + <code>Condition</code> ：使用 <code>ReentrantLock</code> 和 <code>Condition</code> 精确控制线程执行时机。</p>
</li>
</ol>
<h4 id="问：生产者消费者模式的实现方式？"><a href="#问：生产者消费者模式的实现方式？" class="headerlink" title="问：生产者消费者模式的实现方式？"></a>问：生产者消费者模式的实现方式？</h4><p>生产者消费者模式通过共享缓冲区在生产者和消费者之间传递数据，常用的实现方式包括以下几种：</p>
<ol>
<li><p><code>wait</code> / <code>notify</code> 实现 (经典方法)：使用 <code>synchronized</code> 锁，<code>wait()</code> 等待，<code>notify()</code> 唤醒。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.LinkedList;</span><br><span class="line"><span class="keyword">import</span> java.util.Queue;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Buffer</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> Queue&lt;Integer&gt; queue = <span class="keyword">new</span> LinkedList&lt;&gt;();</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">int</span> CAPACITY = <span class="number">5</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">produce</span><span class="params">(<span class="keyword">int</span> value)</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">        <span class="keyword">while</span> (queue.size() == CAPACITY) &#123;</span><br><span class="line">            wait();  <span class="comment">// 缓冲区满，等待</span></span><br><span class="line">        &#125;</span><br><span class="line">        queue.offer(value);</span><br><span class="line">        System.out.println(<span class="string">&quot;Produced: &quot;</span> + value);</span><br><span class="line">        notifyAll();  <span class="comment">// 通知消费者</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">int</span> <span class="title">consume</span><span class="params">()</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">        <span class="keyword">while</span> (queue.isEmpty()) &#123;</span><br><span class="line">            wait();  <span class="comment">// 缓冲区空，等待</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> value = queue.poll();</span><br><span class="line">        System.out.println(<span class="string">&quot;Consumed: &quot;</span> + value);</span><br><span class="line">        notifyAll();  <span class="comment">// 通知生产者</span></span><br><span class="line">        <span class="keyword">return</span> value;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ProducerConsumerWaitNotify</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Buffer buffer = <span class="keyword">new</span> Buffer();</span><br><span class="line"></span><br><span class="line">        Runnable producer = () -&gt; &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++) &#123;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    buffer.produce(i);</span><br><span class="line">                &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                    Thread.currentThread().interrupt();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;;</span><br><span class="line"></span><br><span class="line">        Runnable consumer = () -&gt; &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++) &#123;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    buffer.consume();</span><br><span class="line">                &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                    Thread.currentThread().interrupt();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">new</span> Thread(producer).start();</span><br><span class="line">        <span class="keyword">new</span> Thread(consumer).start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li><p><code>BlockingQueue</code> 实现 (推荐方法)：使用 <code>BlockingQueue</code>，生产者直接放入，消费者直接取出，自动阻塞管理。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.concurrent.ArrayBlockingQueue;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.BlockingQueue;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ProducerConsumerBlockingQueue</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        BlockingQueue&lt;Integer&gt; queue = <span class="keyword">new</span> ArrayBlockingQueue&lt;&gt;(<span class="number">5</span>);</span><br><span class="line"></span><br><span class="line">        Runnable producer = () -&gt; &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++) &#123;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    queue.put(i);  <span class="comment">// 自动阻塞</span></span><br><span class="line">                    System.out.println(<span class="string">&quot;Produced: &quot;</span> + i);</span><br><span class="line">                &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                    Thread.currentThread().interrupt();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;;</span><br><span class="line"></span><br><span class="line">        Runnable consumer = () -&gt; &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++) &#123;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    <span class="keyword">int</span> value = queue.take();  <span class="comment">// 自动阻塞</span></span><br><span class="line">                    System.out.println(<span class="string">&quot;Consumed: &quot;</span> + value);</span><br><span class="line">                &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                    Thread.currentThread().interrupt();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">new</span> Thread(producer).start();</span><br><span class="line">        <span class="keyword">new</span> Thread(consumer).start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li><p><code>Lock</code> + <code>Condition</code> 实现 (手动控制)：使用 <code>ReentrantLock</code> 和 <code>Condition</code> 对生产与消费条件进行手动控制。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.LinkedList;</span><br><span class="line"><span class="keyword">import</span> java.util.Queue;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.locks.Condition;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.locks.Lock;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.locks.ReentrantLock;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">BufferWithLock</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> Queue&lt;Integer&gt; queue = <span class="keyword">new</span> LinkedList&lt;&gt;();</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">int</span> CAPACITY = <span class="number">5</span>;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> Lock lock = <span class="keyword">new</span> ReentrantLock();</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> Condition notFull = lock.newCondition();</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> Condition notEmpty = lock.newCondition();</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">produce</span><span class="params">(<span class="keyword">int</span> value)</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">        lock.lock();</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">while</span> (queue.size() == CAPACITY) &#123;</span><br><span class="line">                notFull.await();  <span class="comment">// 缓冲区满，等待</span></span><br><span class="line">            &#125;</span><br><span class="line">            queue.offer(value);</span><br><span class="line">            System.out.println(<span class="string">&quot;Produced: &quot;</span> + value);</span><br><span class="line">            notEmpty.signalAll();  <span class="comment">// 通知消费者</span></span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            lock.unlock();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">consume</span><span class="params">()</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">        lock.lock();</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">while</span> (queue.isEmpty()) &#123;</span><br><span class="line">                notEmpty.await();  <span class="comment">// 缓冲区空，等待</span></span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">int</span> value = queue.poll();</span><br><span class="line">            System.out.println(<span class="string">&quot;Consumed: &quot;</span> + value);</span><br><span class="line">            notFull.signalAll();  <span class="comment">// 通知生产者</span></span><br><span class="line">            <span class="keyword">return</span> value;</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            lock.unlock();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ProducerConsumerLock</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        BufferWithLock buffer = <span class="keyword">new</span> BufferWithLock();</span><br><span class="line"></span><br><span class="line">        Runnable producer = () -&gt; &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++) &#123;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    buffer.produce(i);</span><br><span class="line">                &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                    Thread.currentThread().interrupt();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;;</span><br><span class="line"></span><br><span class="line">        Runnable consumer = () -&gt; &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++) &#123;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    buffer.consume();</span><br><span class="line">                &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                    Thread.currentThread().interrupt();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">new</span> Thread(producer).start();</span><br><span class="line">        <span class="keyword">new</span> Thread(consumer).start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ol>
<p><strong>选择合适实现的场景:</strong></p>
<ol>
<li><strong>简单实现:</strong> 使用 <code>BlockingQueue</code>，推荐日常开发。</li>
<li><strong>手动控制:</strong> 使用 <code>wait</code> / <code>notify</code> 或 <code>Lock</code> + <code>Condition</code>，适合需要精确控制的情况。</li>
</ol>
<p><strong>关键点总结:</strong></p>
<ul>
<li>缓冲区满时，生产者需等待；缓冲区空时，消费者需等待。</li>
<li><code>BlockingQueue</code> 内置阻塞机制，简化了开发。</li>
<li><code>Lock</code> + <code>Condition</code> 提供更灵活的控制，适合复杂场景。</li>
</ul>
<hr>
<h2 id="二-锁"><a href="#二-锁" class="headerlink" title="二. 锁"></a>二. 锁</h2><h3 id="2-1-锁"><a href="#2-1-锁" class="headerlink" title="2.1 锁"></a>2.1 锁</h3><h4 id="问：讲讲你知道的锁？锁的几种特性？⭐⭐"><a href="#问：讲讲你知道的锁？锁的几种特性？⭐⭐" class="headerlink" title="问：讲讲你知道的锁？锁的几种特性？⭐⭐"></a>问：讲讲你知道的锁？锁的几种特性？⭐⭐</h4><ul>
<li>独占/排他与共享：独占/排他即同一时刻只能有一个线程获取到锁，而其他获取锁的线程只能处于同步队列中等待，只有获取锁的线程释放了锁，后继的线程才能够获取锁。共享则表示同一时刻多个线程可以同时访问。</li>
<li>公平与非公平：先对锁进行获取请求的线程一定先被满足，这是公平锁；反之则是非公平锁。</li>
<li>可重入：支持重进入，表示锁能够支持一个线程对资源重复加锁。</li>
</ul>
<p>在 Java 中，锁（Lock）是一种用于控制多个线程对共享资源访问的机制。锁的主要作用是防止数据竞争和线程安全问题。</p>
<p><strong>一、常见的锁类型</strong></p>
<ol>
<li><strong>内置锁 (<code>synchronized</code>)</strong></li>
</ol>
<ul>
<li>Java 提供的内置锁，通过 <code>synchronized</code> 关键字实现。</li>
<li>特点:<ul>
<li>自动获取和释放锁。</li>
<li>可重入。</li>
<li>无法中断。</li>
</ul>
</li>
</ul>
<ol start="2">
<li><strong>显式锁 (<code>Lock</code> 接口)</strong></li>
</ol>
<ul>
<li>在 <code>java.util.concurrent.locks</code> 包中，主要实现类为 <code>ReentrantLock</code>。</li>
<li>特点:<ul>
<li>手动加锁和解锁。</li>
<li>可中断。</li>
<li>支持公平锁和非公平锁。</li>
<li>支持尝试加锁（<code>tryLock()</code>）。</li>
</ul>
</li>
</ul>
<p><strong>二、常用锁实现</strong></p>
<ol>
<li><p><strong>ReentrantLock（可重入锁）</strong></p>
<ul>
<li><p>支持公平和非公平模式。</p>
</li>
<li><p>可重入，锁持有者可以再次获取锁。</p>
</li>
<li><p>提供 <code>lockInterruptibly()</code> 支持线程中断。</p>
</li>
<li><p>示例：</p>
<figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">javaCopy codeLock <span class="keyword">lock</span> = <span class="keyword">new</span> ReentrantLock();</span><br><span class="line"></span><br><span class="line"><span class="keyword">lock</span>.<span class="keyword">lock</span>();</span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">    System.<span class="keyword">out</span>.println(<span class="string">&quot;Critical Section&quot;</span>);</span><br><span class="line">&#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">    <span class="keyword">lock</span>.unlock();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
</li>
<li><p><strong>ReadWriteLock（读写锁）</strong></p>
<ul>
<li><p>提供 <code>ReentrantReadWriteLock</code> 实现。</p>
</li>
<li><p>支持读写分离：多个线程可同时读，写操作独占。</p>
</li>
<li><p>示例：</p>
<figure class="highlight pgsql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">javaCopy codeReadWriteLock <span class="keyword">lock</span> = <span class="built_in">new</span> ReentrantReadWriteLock();</span><br><span class="line"><span class="keyword">Lock</span> readLock = <span class="keyword">lock</span>.readLock();</span><br><span class="line"><span class="keyword">Lock</span> writeLock = <span class="keyword">lock</span>.writeLock();</span><br><span class="line"></span><br><span class="line">readLock.<span class="keyword">lock</span>();</span><br><span class="line">try &#123;</span><br><span class="line">    <span class="keyword">System</span>.<span class="keyword">out</span>.println(&quot;Reading...&quot;);</span><br><span class="line">&#125; finally &#123;</span><br><span class="line">    readLock.unlock();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
</li>
<li><p><strong>StampedLock（乐观锁）</strong></p>
<ul>
<li><p>主要用于高并发场景，支持乐观读和悲观写。</p>
</li>
<li><p>乐观锁通过时间戳版本检查数据是否被修改。</p>
</li>
<li><p>示例：</p>
<figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">javaCopy codeStampedLock <span class="keyword">lock</span> = <span class="keyword">new</span> StampedLock();</span><br><span class="line"><span class="built_in">long</span> stamp = <span class="keyword">lock</span>.readLock();</span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">    System.<span class="keyword">out</span>.println(<span class="string">&quot;Reading...&quot;</span>);</span><br><span class="line">&#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">    <span class="keyword">lock</span>.unlockRead(stamp);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
</li>
<li><p><strong>Semaphore（信号量）</strong></p>
<ul>
<li><p>用于控制资源访问的许可数量，常用于限流。</p>
</li>
<li><p>示例：</p>
<figure class="highlight reasonml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">javaCopy codeSemaphore semaphore = <span class="keyword">new</span> <span class="constructor">Semaphore(3)</span>;  <span class="comment">// 最多允许3个线程同时访问</span></span><br><span class="line">semaphore.acquire<span class="literal">()</span>;  <span class="comment">// 获取许可</span></span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">    <span class="module-access"><span class="module"><span class="identifier">System</span>.</span></span>out.println(<span class="string">&quot;Accessing Resource&quot;</span>);</span><br><span class="line">&#125; finally &#123;</span><br><span class="line">    semaphore.release<span class="literal">()</span>;  <span class="comment">// 释放许可</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
</li>
<li><p><strong>CountDownLatch（倒计时器）</strong></p>
<ul>
<li><p>用于等待多个线程完成任务后再继续执行。</p>
</li>
<li><p>示例：</p>
<figure class="highlight reasonml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">javaCopy codeCountDownLatch latch = <span class="keyword">new</span> <span class="constructor">CountDownLatch(3)</span>;  <span class="comment">// 等待3个线程</span></span><br><span class="line"></span><br><span class="line">Runnable task = <span class="literal">()</span> -&gt; &#123;</span><br><span class="line">    <span class="module-access"><span class="module"><span class="identifier">System</span>.</span></span>out.println(<span class="string">&quot;Task completed&quot;</span>);</span><br><span class="line">    latch.count<span class="constructor">Down()</span>;  <span class="comment">// 减少计数</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">new</span> <span class="constructor">Thread(<span class="params">task</span>)</span>.start<span class="literal">()</span>;</span><br><span class="line"><span class="keyword">new</span> <span class="constructor">Thread(<span class="params">task</span>)</span>.start<span class="literal">()</span>;</span><br><span class="line"><span class="keyword">new</span> <span class="constructor">Thread(<span class="params">task</span>)</span>.start<span class="literal">()</span>;</span><br><span class="line"></span><br><span class="line">latch.await<span class="literal">()</span>;  <span class="comment">// 等待计数变为0</span></span><br><span class="line"><span class="module-access"><span class="module"><span class="identifier">System</span>.</span></span>out.println(<span class="string">&quot;All tasks finished.&quot;</span>);</span><br></pre></td></tr></table></figure></li>
</ul>
</li>
</ol>
<p><strong>三、锁的主要特性</strong></p>
<table>
<thead>
<tr>
<th><strong>特性</strong></th>
<th><strong>描述</strong></th>
</tr>
</thead>
<tbody><tr>
<td><strong>互斥性 (Exclusive)</strong></td>
<td>同一时刻只能有一个线程持有锁。</td>
</tr>
<tr>
<td><strong>可重入性 (Reentrant)</strong></td>
<td>锁的持有者可以多次获取同一把锁而不被阻塞。</td>
</tr>
<tr>
<td><strong>公平性 (Fairness)</strong></td>
<td>锁的获取顺序按先到先得的原则（如 <code>ReentrantLock(true)</code>）。</td>
</tr>
<tr>
<td><strong>中断响应 (Interruptible)</strong></td>
<td>支持线程在等待锁时被中断。</td>
</tr>
<tr>
<td><strong>超时获取 (Timeout)</strong></td>
<td>尝试在指定时间内获取锁，超时则放弃。</td>
</tr>
<tr>
<td><strong>读写分离 (Read-Write)</strong></td>
<td>支持多个读线程并行，写线程独占。</td>
</tr>
</tbody></table>
<p><strong>四、锁的选择指南</strong></p>
<ol>
<li><strong>简单互斥控制:</strong> 使用 <code>synchronized</code>。</li>
<li><strong>复杂并发控制:</strong> 使用 <code>ReentrantLock</code>。</li>
<li><strong>读写分离:</strong> 使用 <code>ReentrantReadWriteLock</code>。</li>
<li><strong>高并发和乐观读:</strong> 使用 <code>StampedLock</code>。</li>
<li><strong>资源限制控制:</strong> 使用 <code>Semaphore</code>。</li>
<li><strong>任务协调:</strong> 使用 <code>CountDownLatch</code>、<code>CyclicBarrier</code>。</li>
</ol>
<p><strong>五、注意事项</strong></p>
<ul>
<li>尽量缩小锁的作用域，避免死锁和性能瓶颈。</li>
<li>谨慎使用嵌套锁，防止锁顺序不一致导致死锁。</li>
<li>在必要时使用超时和中断机制，避免线程无限等待。</li>
</ul>
<h4 id="问：公平锁与非公平锁？"><a href="#问：公平锁与非公平锁？" class="headerlink" title="问：公平锁与非公平锁？"></a>问：公平锁与非公平锁？</h4><ol>
<li>公平锁指在分配锁前检查是否有线程在排队等待获取该锁，优先分配排队时间最长的线程，非公平直接尝试获取锁 。</li>
<li>公平锁需多维护一个锁线程队列，大量的线程切换，效率低；默认非公平。</li>
</ol>
<p>公平锁和非公平锁是线程锁机制中常用的两种模式，主要用于控制锁的获取顺序，解决多线程环境中的资源竞争问题。</p>
<p><strong>1. 公平锁 (Fair Lock)</strong></p>
<p><strong>定义:</strong></p>
<ul>
<li>公平锁按照请求锁的顺序分配锁，遵循“先来先服务”原则。</li>
<li>类似于排队系统，线程按等待时间顺序获取锁。</li>
</ul>
<p><strong>实现方式:</strong></p>
<ul>
<li><p>在 Java 中，</p>
<figure class="highlight ebnf"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="attribute">ReentrantLock</span></span><br></pre></td></tr></table></figure>

<p> 提供公平锁的实现：</p>
<figure class="highlight pgsql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">java</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">Copy</span> code</span><br><span class="line">ReentrantLock <span class="keyword">lock</span> = <span class="built_in">new</span> ReentrantLock(<span class="keyword">true</span>);  // <span class="keyword">true</span> 表示公平锁</span><br></pre></td></tr></table></figure></li>
</ul>
<p><strong>优点:</strong></p>
<ul>
<li>避免线程饥饿，确保每个线程最终都会获得锁。</li>
</ul>
<p><strong>缺点:</strong></p>
<ul>
<li>性能较低，频繁切换线程带来更多开销。</li>
</ul>
<p><strong>2. 非公平锁 (Non-Fair Lock)</strong></p>
<p><strong>定义:</strong></p>
<ul>
<li>非公平锁不保证按请求顺序分配锁，任何线程在尝试获取锁时都能直接竞争，可能插队成功。</li>
<li>默认情况下，Java 中的 <code>ReentrantLock</code> 是非公平锁。</li>
</ul>
<p><strong>实现方式:</strong></p>
<ul>
<li><p>不传递参数，默认构造即为非公平锁：</p>
<figure class="highlight pgsql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">java</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">Copy</span> code</span><br><span class="line">ReentrantLock <span class="keyword">lock</span> = <span class="built_in">new</span> ReentrantLock();  // <span class="keyword">false</span> 表示非公平锁</span><br></pre></td></tr></table></figure></li>
</ul>
<p><strong>优点:</strong></p>
<ul>
<li>性能更高，CPU 资源利用率更高，适用于高吞吐量场景。</li>
</ul>
<p><strong>缺点:</strong></p>
<ul>
<li>存在线程饥饿的可能，某些线程可能长期无法获取锁。</li>
</ul>
<p><strong>3. 比较总结</strong></p>
<table>
<thead>
<tr>
<th><strong>特性</strong></th>
<th><strong>公平锁</strong></th>
<th><strong>非公平锁</strong></th>
</tr>
</thead>
<tbody><tr>
<td><strong>获取顺序</strong></td>
<td>按请求顺序获取（排队）</td>
<td>随机竞争，可能插队</td>
</tr>
<tr>
<td><strong>实现方式</strong></td>
<td><code>ReentrantLock(true)</code></td>
<td><code>ReentrantLock(false)</code></td>
</tr>
<tr>
<td><strong>优点</strong></td>
<td>无线程饥饿，公平性高</td>
<td>性能更高，吞吐量更大</td>
</tr>
<tr>
<td><strong>缺点</strong></td>
<td>性能开销较大，切换频繁</td>
<td>可能导致线程饥饿</td>
</tr>
<tr>
<td><strong>适用场景</strong></td>
<td>需要严格按顺序执行的场景</td>
<td>高性能、高吞吐量场景</td>
</tr>
</tbody></table>
<figure class="highlight reasonml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">javaCopy codeimport java.util.concurrent.locks.ReentrantLock;</span><br><span class="line"></span><br><span class="line">public <span class="keyword">class</span> FairLockExample &#123;</span><br><span class="line">    <span class="keyword">private</span> static ReentrantLock fairLock = <span class="keyword">new</span> <span class="constructor">ReentrantLock(<span class="params">true</span>)</span>;  <span class="comment">// 公平锁</span></span><br><span class="line"></span><br><span class="line">    public static void main(String<span class="literal">[]</span> args) &#123;</span><br><span class="line">        Runnable task = <span class="literal">()</span> -&gt; &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="built_in">int</span> i = <span class="number">0</span>; i &lt; <span class="number">2</span>; i++) &#123;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    fairLock.lock<span class="literal">()</span>;</span><br><span class="line">                    <span class="module-access"><span class="module"><span class="identifier">System</span>.</span></span>out.println(<span class="module-access"><span class="module"><span class="identifier">Thread</span>.</span></span>current<span class="constructor">Thread()</span>.get<span class="constructor">Name()</span> + <span class="string">&quot; 获取了锁&quot;</span>);</span><br><span class="line">                &#125; finally &#123;</span><br><span class="line">                    fairLock.unlock<span class="literal">()</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;;</span><br><span class="line"></span><br><span class="line">        Thread t1 = <span class="keyword">new</span> <span class="constructor">Thread(<span class="params">task</span>, <span class="string">&quot;线程1&quot;</span>)</span>;</span><br><span class="line">        Thread t2 = <span class="keyword">new</span> <span class="constructor">Thread(<span class="params">task</span>, <span class="string">&quot;线程2&quot;</span>)</span>;</span><br><span class="line">        Thread t3 = <span class="keyword">new</span> <span class="constructor">Thread(<span class="params">task</span>, <span class="string">&quot;线程3&quot;</span>)</span>;</span><br><span class="line"></span><br><span class="line">        t1.start<span class="literal">()</span>;</span><br><span class="line">        t2.start<span class="literal">()</span>;</span><br><span class="line">        t3.start<span class="literal">()</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<hr>
<p><strong>选择指南:</strong></p>
<ul>
<li><strong>需要严格顺序控制时</strong>（如银行排队系统），选用 <strong>公平锁</strong>。</li>
<li><strong>追求高性能时</strong>（如高并发的缓存、任务调度），选用 <strong>非公平锁</strong>。</li>
</ul>
<h4 id="问：独占锁与共享锁？"><a href="#问：独占锁与共享锁？" class="headerlink" title="问：独占锁与共享锁？"></a>问：独占锁与共享锁？</h4><ol>
<li>ReentrantLock为独占锁（悲观加锁策略） 。</li>
<li>ReentrantReadWriteLock中读锁为共享锁，写锁为独占锁。</li>
<li>JDK1.8 邮戳锁（StampedLock）， 不可重入锁读的过程中也允许获取写锁后写入。这样一来，我们读的数据就可能不一致，所以，需要一点额外的代码来判断读的过程中是否有写入，这种读锁是一种乐观锁， 乐观锁的并发效率更高，但一旦有小概率的写入导致读取的数据不一致，需要能检测出来，再读一遍就行。</li>
</ol>
<p>在多线程环境中，锁用于控制对共享资源的访问，避免数据竞争和不一致问题。根据线程对锁的获取模式，锁可以分为 <strong>独占锁 (Exclusive Lock)</strong> 和 **共享锁 (Shared Lock)**。</p>
<p><strong>1. 独占锁 (Exclusive Lock)</strong></p>
<p><strong>定义:</strong></p>
<ul>
<li>独占锁一次只能被一个线程持有，其他线程必须等待锁释放后才能获取。</li>
</ul>
<p><strong>特点:</strong></p>
<ul>
<li>线程独占资源，避免并发访问。</li>
<li>常用于写操作，保证数据的一致性和完整性。</li>
</ul>
<p><strong>示例:</strong></p>
<ul>
<li>在 Java 中，<code>ReentrantLock</code> 是典型的独占锁。</li>
</ul>
<p>示例代码:</p>
<figure class="highlight reasonml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">javaCopy codeimport java.util.concurrent.locks.ReentrantLock;</span><br><span class="line"></span><br><span class="line">public <span class="keyword">class</span> ExclusiveLockExample &#123;</span><br><span class="line">    <span class="keyword">private</span> static ReentrantLock lock = <span class="keyword">new</span> <span class="constructor">ReentrantLock()</span>;</span><br><span class="line"></span><br><span class="line">    public static void main(String<span class="literal">[]</span> args) &#123;</span><br><span class="line">        Runnable task = <span class="literal">()</span> -&gt; &#123;</span><br><span class="line">            lock.lock<span class="literal">()</span>;  <span class="comment">// 获取独占锁</span></span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                <span class="module-access"><span class="module"><span class="identifier">System</span>.</span></span>out.println(<span class="module-access"><span class="module"><span class="identifier">Thread</span>.</span></span>current<span class="constructor">Thread()</span>.get<span class="constructor">Name()</span> + <span class="string">&quot; 获取了独占锁&quot;</span>);</span><br><span class="line">                <span class="module-access"><span class="module"><span class="identifier">Thread</span>.</span></span>sleep(<span class="number">2000</span>);  <span class="comment">// 模拟执行任务</span></span><br><span class="line">            &#125; catch (InterruptedException e) &#123;</span><br><span class="line">                e.print<span class="constructor">StackTrace()</span>;</span><br><span class="line">            &#125; finally &#123;</span><br><span class="line">                lock.unlock<span class="literal">()</span>;  <span class="comment">// 释放锁</span></span><br><span class="line">                <span class="module-access"><span class="module"><span class="identifier">System</span>.</span></span>out.println(<span class="module-access"><span class="module"><span class="identifier">Thread</span>.</span></span>current<span class="constructor">Thread()</span>.get<span class="constructor">Name()</span> + <span class="string">&quot; 释放了独占锁&quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">new</span> <span class="constructor">Thread(<span class="params">task</span>, <span class="string">&quot;线程1&quot;</span>)</span>.start<span class="literal">()</span>;</span><br><span class="line">        <span class="keyword">new</span> <span class="constructor">Thread(<span class="params">task</span>, <span class="string">&quot;线程2&quot;</span>)</span>.start<span class="literal">()</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p><strong>2. 共享锁 (Shared Lock)</strong></p>
<p><strong>定义:</strong></p>
<ul>
<li>共享锁可以被多个线程同时持有，允许多个线程同时读共享资源，但不允许写操作。</li>
</ul>
<p><strong>特点:</strong></p>
<ul>
<li>适用于<strong>读操作</strong>，多个线程可以同时读取。</li>
<li>写操作需要独占锁，避免数据不一致。</li>
</ul>
<p><strong>示例:</strong></p>
<ul>
<li><p>Java 中的 </p>
<figure class="highlight ebnf"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="attribute">ReentrantReadWriteLock</span></span><br></pre></td></tr></table></figure>

<p> 提供了共享锁的实现。</p>
<ul>
<li><code>readLock()</code> 是共享锁。</li>
<li><code>writeLock()</code> 是独占锁。</li>
</ul>
</li>
</ul>
<p>示例代码:</p>
<figure class="highlight reasonml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line">javaCopy codeimport java.util.concurrent.locks.ReentrantReadWriteLock;</span><br><span class="line"></span><br><span class="line">public <span class="keyword">class</span> SharedLockExample &#123;</span><br><span class="line">    <span class="keyword">private</span> static ReentrantReadWriteLock lock = <span class="keyword">new</span> <span class="constructor">ReentrantReadWriteLock()</span>;</span><br><span class="line">    <span class="keyword">private</span> static String data = <span class="string">&quot;共享数据&quot;</span>;</span><br><span class="line"></span><br><span class="line">    public static void main(String<span class="literal">[]</span> args) &#123;</span><br><span class="line">        Runnable readTask = <span class="literal">()</span> -&gt; &#123;</span><br><span class="line">            lock.read<span class="constructor">Lock()</span>.lock<span class="literal">()</span>;  <span class="comment">// 获取共享锁</span></span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                <span class="module-access"><span class="module"><span class="identifier">System</span>.</span></span>out.println(<span class="module-access"><span class="module"><span class="identifier">Thread</span>.</span></span>current<span class="constructor">Thread()</span>.get<span class="constructor">Name()</span> + <span class="string">&quot; 读取数据: &quot;</span> + data);</span><br><span class="line">                <span class="module-access"><span class="module"><span class="identifier">Thread</span>.</span></span>sleep(<span class="number">1000</span>);  <span class="comment">// 模拟读取</span></span><br><span class="line">            &#125; catch (InterruptedException e) &#123;</span><br><span class="line">                e.print<span class="constructor">StackTrace()</span>;</span><br><span class="line">            &#125; finally &#123;</span><br><span class="line">                lock.read<span class="constructor">Lock()</span>.unlock<span class="literal">()</span>;  <span class="comment">// 释放锁</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;;</span><br><span class="line"></span><br><span class="line">        Runnable writeTask = <span class="literal">()</span> -&gt; &#123;</span><br><span class="line">            lock.write<span class="constructor">Lock()</span>.lock<span class="literal">()</span>;  <span class="comment">// 获取独占锁</span></span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                data = <span class="module-access"><span class="module"><span class="identifier">Thread</span>.</span></span>current<span class="constructor">Thread()</span>.get<span class="constructor">Name()</span> + <span class="string">&quot; 写入的数据&quot;</span>;</span><br><span class="line">                <span class="module-access"><span class="module"><span class="identifier">System</span>.</span></span>out.println(<span class="module-access"><span class="module"><span class="identifier">Thread</span>.</span></span>current<span class="constructor">Thread()</span>.get<span class="constructor">Name()</span> + <span class="string">&quot; 写入数据&quot;</span>);</span><br><span class="line">                <span class="module-access"><span class="module"><span class="identifier">Thread</span>.</span></span>sleep(<span class="number">1000</span>);  <span class="comment">// 模拟写入</span></span><br><span class="line">            &#125; catch (InterruptedException e) &#123;</span><br><span class="line">                e.print<span class="constructor">StackTrace()</span>;</span><br><span class="line">            &#125; finally &#123;</span><br><span class="line">                lock.write<span class="constructor">Lock()</span>.unlock<span class="literal">()</span>;  <span class="comment">// 释放锁</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">new</span> <span class="constructor">Thread(<span class="params">readTask</span>, <span class="string">&quot;线程1&quot;</span>)</span>.start<span class="literal">()</span>;</span><br><span class="line">        <span class="keyword">new</span> <span class="constructor">Thread(<span class="params">readTask</span>, <span class="string">&quot;线程2&quot;</span>)</span>.start<span class="literal">()</span>;</span><br><span class="line">        <span class="keyword">new</span> <span class="constructor">Thread(<span class="params">writeTask</span>, <span class="string">&quot;线程3&quot;</span>)</span>.start<span class="literal">()</span>;</span><br><span class="line">        <span class="keyword">new</span> <span class="constructor">Thread(<span class="params">readTask</span>, <span class="string">&quot;线程4&quot;</span>)</span>.start<span class="literal">()</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p><strong>3. 对比总结</strong></p>
<table>
<thead>
<tr>
<th><strong>特性</strong></th>
<th><strong>独占锁 (Exclusive Lock)</strong></th>
<th><strong>共享锁 (Shared Lock)</strong></th>
</tr>
</thead>
<tbody><tr>
<td><strong>获取方式</strong></td>
<td>仅允许一个线程持有</td>
<td>允许多个线程持有</td>
</tr>
<tr>
<td><strong>适用场景</strong></td>
<td>写操作，数据修改</td>
<td>读操作，数据读取</td>
</tr>
<tr>
<td><strong>实现类</strong></td>
<td><code>ReentrantLock</code></td>
<td><code>ReentrantReadWriteLock.readLock()</code></td>
</tr>
<tr>
<td><strong>线程安全性</strong></td>
<td>高，确保数据完整性</td>
<td>允许并发读取，减少阻塞</td>
</tr>
<tr>
<td><strong>性能表现</strong></td>
<td>较低，因线程互斥阻塞</td>
<td>较高，允许多线程读共享资源</td>
</tr>
</tbody></table>
<hr>
<p><strong>选择指南:</strong></p>
<ul>
<li><strong>读多写少场景:</strong> 使用共享锁，减少锁竞争，提高读性能。</li>
<li><strong>写多读少或频繁更新场景:</strong> 使用独占锁，确保数据完整性。</li>
<li><strong>混合场景:</strong> 使用 <code>ReentrantReadWriteLock</code>，根据操作类型选择合适的锁。</li>
</ul>
<h4 id="问：可重入锁概念？"><a href="#问：可重入锁概念？" class="headerlink" title="问：可重入锁概念？"></a>问：可重入锁概念？</h4><ol>
<li>可重入锁是指同一个线程可以多次获取同一把锁，不会因为之前已经获取过还没释放而阻塞；</li>
<li>ReentrantLock、ReentrantReadWriteLock和synchronized都是可重入锁。</li>
<li>可重入锁的一个优点是可一定程度避免死锁。</li>
</ol>
<p><strong>可重入锁</strong> 是指同一个线程在持有锁的情况下，可以再次获取该锁而不会被阻塞。换句话说，线程可以“重入”到自己已经拥有的锁中，避免死锁问题。</p>
<p><strong>1. 可重入锁的机制</strong></p>
<p><strong>实现原理:</strong></p>
<ul>
<li>锁会记录<strong>持有该锁的线程</strong>和<strong>重入的次数</strong>。</li>
<li>每次同一线程获取锁时，重入次数加一。</li>
<li>每次释放锁时，重入次数减一，直到重入次数为零时，锁才真正释放。</li>
</ul>
<p><strong>2. 可重入锁的实现示例</strong></p>
<p><strong>示例 1: 使用 <code>synchronized</code> (隐式可重入锁)</strong></p>
<p><code>synchronized</code> 本质上是一个可重入锁。</p>
<figure class="highlight reasonml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">javaCopy codepublic <span class="keyword">class</span> ReentrantLockExample &#123;</span><br><span class="line"></span><br><span class="line">    public synchronized void <span class="keyword">method</span><span class="constructor">A()</span> &#123;</span><br><span class="line">        <span class="module-access"><span class="module"><span class="identifier">System</span>.</span></span>out.println(<span class="module-access"><span class="module"><span class="identifier">Thread</span>.</span></span>current<span class="constructor">Thread()</span>.get<span class="constructor">Name()</span> + <span class="string">&quot; 进入方法A&quot;</span>);</span><br><span class="line">        <span class="keyword">method</span><span class="constructor">B()</span>;  <span class="comment">// 同一个线程可以重入方法B</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public synchronized void <span class="keyword">method</span><span class="constructor">B()</span> &#123;</span><br><span class="line">        <span class="module-access"><span class="module"><span class="identifier">System</span>.</span></span>out.println(<span class="module-access"><span class="module"><span class="identifier">Thread</span>.</span></span>current<span class="constructor">Thread()</span>.get<span class="constructor">Name()</span> + <span class="string">&quot; 进入方法B&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public static void main(String<span class="literal">[]</span> args) &#123;</span><br><span class="line">        ReentrantLockExample example = <span class="keyword">new</span> <span class="constructor">ReentrantLockExample()</span>;</span><br><span class="line">        <span class="keyword">new</span> <span class="constructor">Thread(<span class="params">example</span>::<span class="params">methodA</span>, <span class="string">&quot;线程1&quot;</span>)</span>.start<span class="literal">()</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>运行结果:</strong></p>
<figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">cssCopy <span class="selector-tag">code</span>线程<span class="number">1</span> 进入方法<span class="selector-tag">A</span>  </span><br><span class="line">线程<span class="number">1</span> 进入方法<span class="selector-tag">B</span>  </span><br></pre></td></tr></table></figure>

<p><strong>示例 2: 使用 <code>ReentrantLock</code> (显式可重入锁)</strong></p>
<p>Java 提供了 <code>ReentrantLock</code> 类，明确实现了可重入锁机制。</p>
<figure class="highlight reasonml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line">javaCopy codeimport java.util.concurrent.locks.ReentrantLock;</span><br><span class="line"></span><br><span class="line">public <span class="keyword">class</span> ReentrantLockTest &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> final ReentrantLock lock = <span class="keyword">new</span> <span class="constructor">ReentrantLock()</span>;</span><br><span class="line"></span><br><span class="line">    public void <span class="keyword">method</span><span class="constructor">A()</span> &#123;</span><br><span class="line">        lock.lock<span class="literal">()</span>;  <span class="comment">// 获取锁</span></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="module-access"><span class="module"><span class="identifier">System</span>.</span></span>out.println(<span class="module-access"><span class="module"><span class="identifier">Thread</span>.</span></span>current<span class="constructor">Thread()</span>.get<span class="constructor">Name()</span> + <span class="string">&quot; 进入方法A&quot;</span>);</span><br><span class="line">            <span class="keyword">method</span><span class="constructor">B()</span>;  <span class="comment">// 重入锁</span></span><br><span class="line">        &#125; finally &#123;</span><br><span class="line">            lock.unlock<span class="literal">()</span>;  <span class="comment">// 释放锁</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public void <span class="keyword">method</span><span class="constructor">B()</span> &#123;</span><br><span class="line">        lock.lock<span class="literal">()</span>;  <span class="comment">// 获取锁</span></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="module-access"><span class="module"><span class="identifier">System</span>.</span></span>out.println(<span class="module-access"><span class="module"><span class="identifier">Thread</span>.</span></span>current<span class="constructor">Thread()</span>.get<span class="constructor">Name()</span> + <span class="string">&quot; 进入方法B&quot;</span>);</span><br><span class="line">        &#125; finally &#123;</span><br><span class="line">            lock.unlock<span class="literal">()</span>;  <span class="comment">// 释放锁</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public static void main(String<span class="literal">[]</span> args) &#123;</span><br><span class="line">        ReentrantLockTest example = <span class="keyword">new</span> <span class="constructor">ReentrantLockTest()</span>;</span><br><span class="line">        <span class="keyword">new</span> <span class="constructor">Thread(<span class="params">example</span>::<span class="params">methodA</span>, <span class="string">&quot;线程1&quot;</span>)</span>.start<span class="literal">()</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>运行结果:</strong></p>
<figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">cssCopy <span class="selector-tag">code</span>线程<span class="number">1</span> 进入方法<span class="selector-tag">A</span>  </span><br><span class="line">线程<span class="number">1</span> 进入方法<span class="selector-tag">B</span>  </span><br></pre></td></tr></table></figure>

<p><strong>3. 可重入锁的特点</strong></p>
<table>
<thead>
<tr>
<th><strong>特性</strong></th>
<th><strong>解释</strong></th>
</tr>
</thead>
<tbody><tr>
<td><strong>线程重入性</strong></td>
<td>同一线程可以多次获取锁，不会死锁</td>
</tr>
<tr>
<td><strong>计数维护</strong></td>
<td>每次获取锁计数加一，释放锁计数减一</td>
</tr>
<tr>
<td><strong>实现方式</strong></td>
<td><code>synchronized</code> 或 <code>ReentrantLock</code></td>
</tr>
<tr>
<td><strong>锁粒度</strong></td>
<td>方法级、代码块级</td>
</tr>
<tr>
<td><strong>性能与灵活性</strong></td>
<td><code>ReentrantLock</code> 提供更灵活的锁操作，如尝试锁和定时锁</td>
</tr>
</tbody></table>
<p><strong>4. 可重入锁的应用场景</strong></p>
<ul>
<li><strong>递归调用:</strong> 在递归方法中，锁需要在同一线程内多次获取和释放。</li>
<li><strong>嵌套调用:</strong> 一个方法内部调用另一个加锁的方法时，避免死锁。</li>
<li><strong>复杂任务调度:</strong> 在并发框架中实现灵活的任务管理。</li>
</ul>
<p><strong>5. 可重入锁与非可重入锁的区别</strong></p>
<table>
<thead>
<tr>
<th><strong>特性</strong></th>
<th><strong>可重入锁</strong></th>
<th><strong>非可重入锁</strong></th>
</tr>
</thead>
<tbody><tr>
<td><strong>线程获取锁</strong></td>
<td>同一线程可以多次获取锁</td>
<td>同一线程再次获取会阻塞</td>
</tr>
<tr>
<td><strong>锁实现类</strong></td>
<td><code>ReentrantLock</code>, <code>synchronized</code></td>
<td>自定义实现等</td>
</tr>
<tr>
<td><strong>死锁风险</strong></td>
<td>无</td>
<td>存在潜在死锁风险</td>
</tr>
<tr>
<td><strong>应用场景</strong></td>
<td>常见于大多数 Java 锁机制</td>
<td>特定应用和自定义场景</td>
</tr>
</tbody></table>
<hr>
<p><strong>结论:</strong></p>
<ul>
<li>在 Java 中，<code>synchronized</code> 和 <code>ReentrantLock</code> 都是<strong>可重入锁</strong>，适用于多线程环境。</li>
<li>在实际应用中，优先考虑 <code>synchronized</code>，仅在需要更高灵活性时使用 <code>ReentrantLock</code>。</li>
</ul>
<h4 id="问：讲讲4种锁状态？⭐⭐⭐"><a href="#问：讲讲4种锁状态？⭐⭐⭐" class="headerlink" title="问：讲讲4种锁状态？⭐⭐⭐"></a>问：讲讲4种锁状态？⭐⭐⭐</h4><p>即重量级锁的四种状态，为了提高效率，尽量避免使用重量级锁：</p>
<ul>
<li><p><strong>无锁</strong>：是否偏向-0，锁标志-01。</p>
</li>
<li><p><strong>偏向锁</strong>：是否偏向-1，锁标志-01。会偏向第一个访问锁的线程，当一个线程访问同步代码块获得锁时，会在对象头和栈帧记录里存储锁偏向的线程ID，当这个线程再次进入同步代码块时，就不需要CAS操作来加锁了，只要测试一下对象头里是否存储着指向当前线程的偏向锁，如果偏向锁未启动，new出的对象是普通对象（即无锁，有稍微竞争会成轻量级锁），如果启动，new出的对象是匿名偏向（偏向锁） 对象头主要包括两部分数据：Mark Word（标记字段， 存储对象自身的运行时数据）、class Pointer（类型指针， 是对象指向它的类元数据的指针）。</p>
</li>
<li><p><strong>轻量级锁</strong>（自旋锁） ：锁标志-00。</p>
<ol>
<li><p>在把线程进行阻塞操作之前先让线程自旋等待一段时间，可能在等待期间其他线程已经解锁，这时就无需再让线程执行阻塞操作，避免了用户态到内核态的切换。（自适应自旋时间为一个线程上下文切换的时间）</p>
</li>
<li><p>在用自旋锁时有可能造成死锁，当递归调用时有可能造成死锁</p>
</li>
<li><p>在 JDK 1.6 之后，<strong>JVM 进行了锁优化</strong>，让 <code>synchronized</code> 也能 <strong>利用自旋锁</strong>（轻量级锁），其中涉及 <strong>Lock Record</strong>：</p>
<p><strong><code>synchronized</code> 进入轻量级锁阶段时</strong></p>
<ul>
<li><strong>每个线程的栈帧</strong>（Stack Frame）中维护一个 <strong>Lock Record</strong> 结构。</li>
<li><strong>对象头的 Mark Word 指向 Lock Record</strong>。</li>
<li><strong>自旋时，线程检查 Lock Record 指针是否指向自己</strong>，若不是，则继续自旋。</li>
</ul>
</li>
</ol>
</li>
<li><p><strong>重量级锁</strong>：锁标志-10。</p>
</li>
</ul>
<p><strong>线程进入同步代码块</strong>，先检查对象头的 Mark Word：</p>
<ul>
<li>如果 <strong>指向当前线程的 Lock Record</strong>，说明已获取锁（可重入）。</li>
<li>如果 <strong>指向 null</strong>，则当前线程用 CAS <strong>尝试将 Mark Word 指向自己的 Lock Record</strong>（自旋）。</li>
<li>如果 <strong>CAS 失败</strong>（其他线程持有锁），则自旋一定次数后<strong>膨胀为重量级锁</strong>。</li>
</ul>
<p><strong>释放锁</strong></p>
<ul>
<li><code>Lock Record</code> 的 <code>markOop</code> 还原到对象头 <code>Mark Word</code>。</li>
<li>若有等待线程，则唤醒它们。</li>
</ul>
<p><strong>1. 无锁（Unlocked）</strong></p>
<p><strong>特点:</strong></p>
<ul>
<li>对象在创建时默认是无锁状态。</li>
<li>适用于单线程环境，无需加锁。</li>
</ul>
<p><strong>Mark Word 结构:</strong></p>
<ul>
<li>存储对象的哈希码和分代年龄。</li>
</ul>
<p><strong>应用场景:</strong></p>
<ul>
<li>单线程执行代码时。</li>
</ul>
<p><strong>2. 偏向锁（Biased Locking）</strong></p>
<p><strong>特点:</strong></p>
<ul>
<li>偏向锁优化了无竞争的加锁场景。</li>
<li>锁会“偏向”第一个获取它的线程，直到其他线程尝试获取该锁。</li>
<li>如果没有竞争，持有锁的线程再次进入同步块无需重新加锁。</li>
</ul>
<p><strong>Mark Word 结构:</strong></p>
<ul>
<li>记录持有锁的线程 ID。</li>
</ul>
<p><strong>触发升级:</strong></p>
<ul>
<li>出现其他线程竞争时，锁会升级为轻量级锁。</li>
</ul>
<p><strong>应用场景:</strong></p>
<ul>
<li>单线程执行的代码块，线程间锁竞争很少的场景。</li>
</ul>
<p><strong>3. 轻量级锁（Lightweight Locking）</strong></p>
<p><strong>特点:</strong></p>
<ul>
<li>当多个线程竞争同一锁但没有真正的线程阻塞时，锁膨胀为轻量级锁。</li>
<li>使用自旋锁（CAS）尝试获取锁。</li>
</ul>
<p><strong>Mark Word 结构:</strong></p>
<ul>
<li>存储线程栈中锁记录的地址。</li>
</ul>
<p><strong>触发升级:</strong></p>
<ul>
<li>竞争激烈时，自旋失败，锁升级为重量级锁。</li>
</ul>
<p><strong>应用场景:</strong></p>
<ul>
<li>多线程环境中，锁竞争不激烈，适用于短时间执行的代码块。</li>
</ul>
<p><strong>4. 重量级锁（Heavyweight Locking）</strong></p>
<p><strong>特点:</strong></p>
<ul>
<li>多线程竞争严重，轻量级锁无法满足要求时，锁升级为重量级锁。</li>
<li>线程会被阻塞，等待锁释放，涉及内核调度。</li>
</ul>
<p><strong>Mark Word 结构:</strong></p>
<ul>
<li>存储指向重量级锁的指针。</li>
</ul>
<p><strong>应用场景:</strong></p>
<ul>
<li>锁竞争激烈，长时间执行的代码块。</li>
</ul>
<p><strong>锁状态演化流程图:</strong></p>
<figure class="highlight clean"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">rust</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">Copy <span class="keyword">code</span></span><br><span class="line">无锁 -&gt; 偏向锁 -&gt; 轻量级锁 -&gt; 重量级锁</span><br></pre></td></tr></table></figure>



<p><strong>锁状态切换时的注意点:</strong></p>
<ul>
<li>锁只能从低级状态向高级状态升级，<strong>不能降级</strong>。</li>
<li>JVM 默认开启偏向锁，可以通过 <code>-XX:-UseBiasedLocking</code> 禁用。</li>
</ul>
<p><strong>优化建议:</strong></p>
<ol>
<li>避免长时间持有锁，尽量减少锁的粒度。</li>
<li>使用并发包中的工具类（如 <code>ReentrantLock</code>、<code>ConcurrentHashMap</code>）。</li>
<li>在高竞争场景中，考虑 <code>StampedLock</code> 或 <code>ReadWriteLock</code> 提升并发性能。</li>
</ol>
<h4 id="问：轻量级锁与偏向锁的区别？⭐⭐"><a href="#问：轻量级锁与偏向锁的区别？⭐⭐" class="headerlink" title="问：轻量级锁与偏向锁的区别？⭐⭐"></a>问：轻量级锁与偏向锁的区别？⭐⭐</h4><ol>
<li>偏向锁对象头 <code>Mark Word</code> 中存放线程ID，轻量级锁则是栈帧中锁记录的指针。</li>
<li>偏向锁是在无竞争场景下完全消除同步，连CAS也不执行；轻量级锁是通过CAS来避免进入开销较大的互斥操作。</li>
<li>偏向锁遇到线程竞争会升级为轻量级锁，前者适用于只有一个线程访问同步块，后者则是线程竞争不激烈的场景。</li>
</ol>
<p><strong>1. 偏向锁（Biased Locking）</strong></p>
<p><strong>设计目标:</strong></p>
<ul>
<li>优化 <strong>无竞争</strong> 场景，减少加锁和解锁的开销。</li>
</ul>
<p><strong>特点:</strong></p>
<ul>
<li><strong>偏向线程:</strong> 锁偏向于第一次获取它的线程，避免重复加锁。</li>
<li><strong>无竞争:</strong> 在没有其他线程竞争时，线程可以直接使用该锁。</li>
<li><strong>撤销成本:</strong> 当出现其他线程竞争时，需要撤销偏向锁，升级为轻量级锁。</li>
</ul>
<p><strong>加锁方式:</strong></p>
<ul>
<li>使用 CAS 操作尝试将线程 ID 记录到锁的对象头（Mark Word）。</li>
</ul>
<p><strong>适用场景:</strong></p>
<ul>
<li>单线程访问多次。</li>
</ul>
<p><strong>缺点:</strong></p>
<ul>
<li>多线程场景频繁撤销锁时，性能下降。</li>
</ul>
<p><strong>2. 轻量级锁（Lightweight Locking）</strong></p>
<p><strong>设计目标:</strong></p>
<ul>
<li>在 <strong>短时竞争</strong> 场景中避免线程阻塞，提高并发性能。</li>
</ul>
<p><strong>特点:</strong></p>
<ul>
<li><strong>竞争检测:</strong> 线程尝试通过自旋（CAS 操作）竞争锁。</li>
<li><strong>无阻塞:</strong> 没有线程阻塞，失败的线程自旋等待。</li>
<li><strong>升级路径:</strong> 如果竞争激烈，锁升级为重量级锁。</li>
</ul>
<p><strong>加锁方式:</strong></p>
<ul>
<li>线程尝试通过 CAS 操作将锁记录拷贝到线程的栈帧中，更新对象头。</li>
</ul>
<p><strong>适用场景:</strong></p>
<ul>
<li>多线程访问但锁竞争不激烈。</li>
</ul>
<p><strong>缺点:</strong></p>
<ul>
<li>在高竞争环境中，自旋次数过多会导致性能下降，升级为重量级锁。</li>
</ul>
<p><strong>主要区别总结:</strong></p>
<table>
<thead>
<tr>
<th><strong>对比项</strong></th>
<th><strong>偏向锁</strong></th>
<th><strong>轻量级锁</strong></th>
</tr>
</thead>
<tbody><tr>
<td><strong>设计目标</strong></td>
<td>无竞争优化，减少加锁操作</td>
<td>短时间内少量竞争优化</td>
</tr>
<tr>
<td><strong>适用场景</strong></td>
<td>单线程多次访问</td>
<td>多线程少量竞争</td>
</tr>
<tr>
<td><strong>加锁方式</strong></td>
<td>将线程 ID 写入对象头</td>
<td>CAS 操作尝试锁记录到栈帧</td>
</tr>
<tr>
<td><strong>撤销操作</strong></td>
<td>存在撤销和升级为轻量级锁的开销</td>
<td>升级为重量级锁</td>
</tr>
<tr>
<td><strong>性能表现</strong></td>
<td>无竞争时性能极高</td>
<td>轻量级竞争时性能较好</td>
</tr>
<tr>
<td><strong>失败处理</strong></td>
<td>存在竞争时撤销锁状态</td>
<td>多次失败升级为重量级锁</td>
</tr>
</tbody></table>
<p><strong>选择策略:</strong></p>
<ul>
<li>单线程场景：开启 <strong>偏向锁</strong> 提升性能。</li>
<li>多线程少量竞争场景：<strong>轻量级锁</strong> 提供无阻塞性能。</li>
<li>多线程高竞争场景：直接考虑更高级锁机制（如 <strong>重量级锁</strong>）。</li>
</ul>
<h4 id="问：自旋锁升级到重量级锁条件？⭐⭐"><a href="#问：自旋锁升级到重量级锁条件？⭐⭐" class="headerlink" title="问：自旋锁升级到重量级锁条件？⭐⭐"></a>问：自旋锁升级到重量级锁条件？⭐⭐</h4><ol>
<li>某线程自旋次数超过10次；</li>
<li>等待的自旋线程超过了系统core数的一半；</li>
</ol>
<p>自旋锁在 Java 中是一种锁优化机制，适用于短时间内的锁竞争。自旋锁升级为重量级锁是为了应对竞争激烈的场景，避免 CPU 资源浪费。以下是自旋锁升级为重量级锁的主要条件：</p>
<p><strong>升级条件</strong></p>
<ol>
<li><strong>自旋失败次数超过阈值</strong><ul>
<li>JVM 默认的自旋次数由 <code>-XX:PreBlockSpin</code> 参数控制。</li>
<li>如果一个线程在多次自旋后仍未获取到锁，JVM 判定当前竞争激烈，锁会升级为重量级锁，线程将进入 <strong>阻塞状态</strong>。</li>
</ul>
</li>
<li><strong>多个线程竞争激烈</strong><ul>
<li>当多个线程频繁竞争同一个锁，CAS 操作不断失败，自旋锁升级为重量级锁，竞争线程进入阻塞队列。</li>
</ul>
</li>
<li><strong>线程被挂起或中断</strong><ul>
<li>如果持有锁的线程被挂起或中断，其他线程自旋失败，锁直接升级。</li>
</ul>
</li>
<li><strong>锁膨胀机制触发</strong><ul>
<li>在高并发环境中，JVM 会自动调整锁的状态，锁从轻量级锁升级到重量级锁，使用操作系统的 <strong>内核同步机制（如监视器锁）</strong>。</li>
</ul>
</li>
</ol>
<p><strong>升级过程（锁膨胀过程）</strong></p>
<ol>
<li>初始状态：<strong>无锁（Lock-Free）</strong></li>
<li>线程获取锁时：进入 <strong>偏向锁</strong> 状态，偏向第一个获取锁的线程。</li>
<li>若发生竞争：撤销 <strong>偏向锁</strong>，升级为 <strong>轻量级锁</strong>。</li>
<li>自旋次数过多：轻量级锁失败，升级为 <strong>重量级锁</strong>。</li>
</ol>
<p><strong>注意点</strong></p>
<ul>
<li><strong>自旋锁的优点:</strong> 避免线程阻塞和上下文切换的开销。</li>
<li><strong>重量级锁的优点:</strong> 在高竞争场景下更高效，避免了自旋锁的资源浪费。</li>
<li><strong>配置调整:</strong> 可以通过 JVM 参数调整锁策略，如 <code>-XX:+UseBiasedLocking</code> 控制偏向锁，<code>-XX:PreBlockSpin</code> 控制自旋次数。</li>
</ul>
<p><strong>适用场景对比</strong></p>
<table>
<thead>
<tr>
<th><strong>锁类型</strong></th>
<th><strong>适用场景</strong></th>
<th><strong>性能表现</strong></th>
</tr>
</thead>
<tbody><tr>
<td><strong>自旋锁</strong></td>
<td>短时间锁竞争</td>
<td>高性能，避免阻塞</td>
</tr>
<tr>
<td><strong>重量级锁</strong></td>
<td>高并发、竞争激烈场景</td>
<td>较低性能，支持阻塞</td>
</tr>
</tbody></table>
<p>通过这种升级机制，Java 锁在不同的场景中动态调整，提供更好的性能和线程安全保障。</p>
<h4 id="问：讲讲读写锁？优点？实现方式？"><a href="#问：讲讲读写锁？优点？实现方式？" class="headerlink" title="问：讲讲读写锁？优点？实现方式？"></a>问：讲讲读写锁？优点？实现方式？</h4><p>读写锁即分离了读锁和写锁，同一时刻允许多个线程访问，提高了读操作间的并发性。</p>
<p>优点有：</p>
<ul>
<li>保证了读操作间的并发。</li>
<li>保证写操作对读操作的可见性。</li>
<li>简化读写交互场景的编程方式。</li>
</ul>
<p>并发包中提供了读写锁 <code>ReentrantReanWriteLock</code> ，和ReentrantLock相似，同样基于AQS，但是读写锁是基于共享资源的，不是互斥，关键在于state的处理，读写锁把高16为记为读状态，低16位记为写状态，从而分开了读写操作，读读情况其实就是读锁重入，读写/写读/写写都是互斥的，只要判断低16位就好了。读状态是所有线程获取读锁次数的总和，每个线程各自的获取次数则存在ThreadLocal中。</p>
<p>Java 提供了 <code>ReentrantReadWriteLock</code> 类，支持以下功能：</p>
<ol>
<li><strong>共享锁（读锁）</strong> - 允许多个线程同时持有。</li>
<li><strong>独占锁（写锁）</strong> - 只能被一个线程持有，阻塞其他线程的读写操作。</li>
</ol>
<p><strong>关键方法</strong></p>
<ul>
<li><strong>读锁相关方法：</strong><ul>
<li><code>readLock().lock()</code> - 获取读锁。</li>
<li><code>readLock().unlock()</code> - 释放读锁。</li>
</ul>
</li>
<li><strong>写锁相关方法：</strong><ul>
<li><code>writeLock().lock()</code> - 获取写锁。</li>
<li><code>writeLock().unlock()</code> - 释放写锁。</li>
</ul>
</li>
</ul>
<p><strong>实现示例</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.concurrent.locks.ReentrantReadWriteLock;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ReadWriteLockExample</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> ReentrantReadWriteLock lock = <span class="keyword">new</span> ReentrantReadWriteLock();</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> value = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 读操作</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">readValue</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        lock.readLock().lock();</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            System.out.println(Thread.currentThread().getName() + <span class="string">&quot; 读取值: &quot;</span> + value);</span><br><span class="line">            <span class="keyword">return</span> value;</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            lock.readLock().unlock();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 写操作</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">writeValue</span><span class="params">(<span class="keyword">int</span> newValue)</span> </span>&#123;</span><br><span class="line">        lock.writeLock().lock();</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            System.out.println(Thread.currentThread().getName() + <span class="string">&quot; 写入值: &quot;</span> + newValue);</span><br><span class="line">            value = newValue;</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            lock.writeLock().unlock();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>优点</strong></p>
<ol>
<li><strong>提高并发度</strong> - 多个线程可以同时读，提升读密集型任务的效率。</li>
<li><strong>减少阻塞时间</strong> - 写操作完成后，读取线程可以立即恢复。</li>
<li><strong>线程安全</strong> - 提供了内置的锁机制，避免手动同步。</li>
</ol>
<p><strong>适用场景</strong></p>
<ul>
<li>缓存系统：多线程读取缓存，少数线程更新缓存。</li>
<li>配置管理：频繁读取配置信息，偶尔更新配置。</li>
<li>文件系统：读操作频繁，写操作较少。</li>
</ul>
<p><strong>注意事项</strong></p>
<ol>
<li><strong>写锁优先级问题</strong> - 默认策略是 <strong>写锁优先</strong>，避免读线程长时间占用导致写锁饥饿。</li>
<li><strong>降级操作支持</strong> - 支持从写锁降级为读锁，反之不行。</li>
<li><strong>死锁风险</strong> - 不正确使用可能导致死锁，需注意锁的获取与释放顺序。</li>
</ol>
<hr>
<p>通过读写锁，可以在读多写少的场景中 <strong>有效提高并发性能</strong>，合理配置和使用是保障系统稳定的重要手段。</p>
<h4 id="问：乐观锁和悲观锁的区别？优缺点？使用场景？JDK中涉及到乐观锁和悲观锁的内容？这两种锁在Java和MySQL分别是怎么实现的？MySql的悲观锁怎么防止并发？⭐"><a href="#问：乐观锁和悲观锁的区别？优缺点？使用场景？JDK中涉及到乐观锁和悲观锁的内容？这两种锁在Java和MySQL分别是怎么实现的？MySql的悲观锁怎么防止并发？⭐" class="headerlink" title="问：乐观锁和悲观锁的区别？优缺点？使用场景？JDK中涉及到乐观锁和悲观锁的内容？这两种锁在Java和MySQL分别是怎么实现的？MySql的悲观锁怎么防止并发？⭐"></a>问：乐观锁和悲观锁的区别？优缺点？使用场景？JDK中涉及到乐观锁和悲观锁的内容？这两种锁在Java和MySQL分别是怎么实现的？MySql的悲观锁怎么防止并发？⭐</h4><p>乐观锁和悲观锁的区别：如字面意思，乐观锁指总是假设最好的情况，每次操作都不会上锁，而是更新时判断是否在此期间有被其他线程修改；悲观锁则相反，总假设最坏的情况，共享资源每次只给一个线程使用。</p>
<p>优缺点：两种锁适用于不同的场景，当共享资源竞争激烈时，乐观锁产生大量的更新失败，导致一些操作会浪费CPU资源如自旋；而资源竞争不那么激烈时，悲观锁所要进行的线程阻塞切换、等待唤醒等需要额外浪费CPU资源。</p>
<p>使用场景：乐观锁常见于多读少写的应用场景；悲观锁被应用于传统关系型数据库，如行锁，表锁，读锁，写锁等，适用于多写少读的场景。</p>
<p>悲观锁实现方式：</p>
<ul>
<li>JDK：<code>synchronized</code> ，<code>RetreentLock</code> 等。</li>
<li>MySQL：行锁，表锁，读锁，写锁等</li>
</ul>
<p>乐观锁实现方式：（CAS，版本号机制）</p>
<ul>
<li>JDK：CAS，JVM中的CAS操作通过处理器提供的 <code>CMPXCHG</code> 指令来实现原子操作。</li>
<li>MySQL：MVCC-多版本并发控制。</li>
</ul>
<p>MySql的悲观锁怎么防止并发：TODO</p>
<p><strong>乐观锁与悲观锁的区别</strong></p>
<table>
<thead>
<tr>
<th><strong>特性</strong></th>
<th><strong>乐观锁 (Optimistic Lock)</strong></th>
<th><strong>悲观锁 (Pessimistic Lock)</strong></th>
</tr>
</thead>
<tbody><tr>
<td><strong>基本思想</strong></td>
<td>假设冲突很少，操作前不加锁，仅在提交前验证。</td>
<td>假设冲突频繁，操作前立即加锁，防止并发。</td>
</tr>
<tr>
<td><strong>实现方式</strong></td>
<td>版本号机制、CAS 比较交换操作。</td>
<td>数据库锁机制或同步锁。</td>
</tr>
<tr>
<td><strong>适用场景</strong></td>
<td>读多写少，冲突概率低。</td>
<td>写多读少，冲突概率高。</td>
</tr>
<tr>
<td><strong>性能</strong></td>
<td>开销小，延迟低。</td>
<td>加锁和解锁成本较高，影响吞吐量。</td>
</tr>
<tr>
<td><strong>失败处理</strong></td>
<td>冲突时需要重试，存在自旋消耗。</td>
<td>等待或阻塞，易导致线程饥饿。</td>
</tr>
</tbody></table>
<p><strong>优缺点分析</strong></p>
<p><strong>乐观锁的优点与缺点</strong></p>
<p><strong>优点:</strong></p>
<ul>
<li>高并发环境中性能更高。</li>
<li>避免线程阻塞，节省系统资源。</li>
</ul>
<p><strong>缺点:</strong></p>
<ul>
<li>存在重试机制，消耗 CPU 资源。</li>
<li>不适合高冲突的场景。</li>
</ul>
<p><strong>悲观锁的优点与缺点</strong></p>
<p><strong>优点:</strong></p>
<ul>
<li>提供更强的并发安全保障。</li>
<li>避免了数据冲突带来的不一致问题。</li>
</ul>
<p><strong>缺点:</strong></p>
<ul>
<li>锁的开销大，性能损耗明显。</li>
<li>易导致死锁与线程饥饿。</li>
</ul>
<p><strong>Java 中的实现</strong></p>
<p><strong>1. 乐观锁（CAS机制）</strong></p>
<ul>
<li>使用 <code>java.util.concurrent.atomic</code> 包中的类如 <code>AtomicInteger</code>、<code>AtomicReference</code> 等。</li>
<li><code>Unsafe.compareAndSwapInt()</code> 实现了底层 CAS 操作。</li>
</ul>
<p><strong>示例:</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.concurrent.atomic.AtomicInteger;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">OptimisticLockExample</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> AtomicInteger count = <span class="keyword">new</span> AtomicInteger(<span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">increment</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> current;</span><br><span class="line">        <span class="keyword">do</span> &#123;</span><br><span class="line">            current = count.get();</span><br><span class="line">        &#125; <span class="keyword">while</span> (!count.compareAndSet(current, current + <span class="number">1</span>));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>2. 悲观锁（同步机制）</strong></p>
<ul>
<li>使用 <code>synchronized</code> 关键字或 <code>ReentrantLock</code>。</li>
</ul>
<p><strong>示例:</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.concurrent.locks.ReentrantLock;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">PessimisticLockExample</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> count = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> ReentrantLock lock = <span class="keyword">new</span> ReentrantLock();</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">increment</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        lock.lock();</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            count++;</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            lock.unlock();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>MySQL 中的实现</strong></p>
<p><strong>1. 乐观锁实现</strong></p>
<ul>
<li>使用 <strong>版本号机制</strong> 或 <strong>时间戳</strong>。</li>
</ul>
<p><strong>示例: 基于版本号的更新</strong></p>
<figure class="highlight pgsql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">sqlCopy code<span class="comment">-- 数据表示例</span></span><br><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> inventory (</span><br><span class="line">    id <span class="type">INT</span> <span class="keyword">PRIMARY KEY</span>,</span><br><span class="line">    product_name <span class="type">VARCHAR</span>(<span class="number">50</span>),</span><br><span class="line">    stock <span class="type">INT</span>,</span><br><span class="line">    <span class="keyword">version</span> <span class="type">INT</span></span><br><span class="line">);</span><br><span class="line"></span><br><span class="line"><span class="comment">-- 更新操作</span></span><br><span class="line"><span class="keyword">UPDATE</span> inventory</span><br><span class="line"><span class="keyword">SET</span> stock = stock - <span class="number">1</span>, version = <span class="keyword">version</span> + <span class="number">1</span></span><br><span class="line"><span class="keyword">WHERE</span> id = <span class="number">1</span> <span class="keyword">AND</span> version = <span class="number">5</span>;</span><br></pre></td></tr></table></figure>

<p><strong>2. 悲观锁实现</strong></p>
<ul>
<li>使用 <strong>锁机制</strong>，如 <code>SELECT ... FOR UPDATE</code>。</li>
</ul>
<p><strong>示例: 基于悲观锁的更新</strong></p>
<figure class="highlight pgsql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">sqlCopy code<span class="comment">-- 开启事务</span></span><br><span class="line"><span class="keyword">START</span> <span class="keyword">TRANSACTION</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">-- 加悲观锁</span></span><br><span class="line"><span class="keyword">SELECT</span> stock <span class="keyword">FROM</span> inventory <span class="keyword">WHERE</span> id = <span class="number">1</span> <span class="keyword">FOR</span> <span class="keyword">UPDATE</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">-- 执行库存更新</span></span><br><span class="line"><span class="keyword">UPDATE</span> inventory <span class="keyword">SET</span> stock = stock - <span class="number">1</span> <span class="keyword">WHERE</span> id = <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">-- 提交事务</span></span><br><span class="line"><span class="keyword">COMMIT</span>;</span><br></pre></td></tr></table></figure>

<p><strong>MySQL 中如何防止并发</strong></p>
<ol>
<li><strong>事务隔离级别:</strong> 使用较高的事务隔离级别（如 <code>REPEATABLE READ</code> 或 <code>SERIALIZABLE</code>）。</li>
<li><strong>锁机制:</strong> 使用行级锁（<code>FOR UPDATE</code>），防止数据竞争。</li>
<li><strong>死锁检测:</strong> MySQL 内部死锁检测机制可主动回滚事务，避免死锁。</li>
<li><strong>索引优化:</strong> 使用合适的索引，减少锁范围，提升性能。</li>
</ol>
<hr>
<p>通过灵活选择乐观锁与悲观锁，结合具体的应用场景和数据库特性，可以有效 <strong>提升系统的并发性能</strong></p>
<h4 id="问：什么是死锁？线上死锁如何处理？如何定位死锁？死锁产生的原因？如何预防避免？⭐⭐⭐"><a href="#问：什么是死锁？线上死锁如何处理？如何定位死锁？死锁产生的原因？如何预防避免？⭐⭐⭐" class="headerlink" title="问：什么是死锁？线上死锁如何处理？如何定位死锁？死锁产生的原因？如何预防避免？⭐⭐⭐"></a>问：什么是死锁？线上死锁如何处理？如何定位死锁？死锁产生的原因？如何预防避免？⭐⭐⭐</h4><p>线上程序出现死锁，造成线程堆积，最终OOM。只能快速重启APP，定位到死锁问题后，发布修复补丁。</p>
<ol>
<li>什么是死锁？<ul>
<li>并发场景下，线程因为相互等待对方资源释放，导致永久阻塞。</li>
</ul>
</li>
<li>如何定位死锁？<ul>
<li>jps打印PID，通过jstack PID查看死锁线程，生成JVM当前的线程快照，死锁一般是因为线程互相等待对方持有的对象。</li>
<li>通过JConsole监控工具，检测线程死锁。</li>
</ul>
</li>
<li>死锁产生的原因？会同时满足四个条件<ul>
<li><strong>互斥</strong>条件：资源同时只能被一个线程占有，线程间互斥等待。</li>
<li><strong>请求和保持</strong>条件：线程请求的资源被其他线程占据，此线程被阻塞但不会释放已有的资源。</li>
<li><strong>不可剥夺</strong>条件：线程获得资源后不能被夺走，只能主动释放。</li>
<li><strong>循环等待</strong>条件：存在线程间的循环等待链路，前一个线程请求资源被下个线程持有。</li>
</ul>
</li>
<li>如何处理/避免死锁？针对4个条件，破坏任意一个。一般是允许前三个必要条件，通过合理的分配算法确保不会形成封闭等待链。<ul>
<li>结合代码和业务情况，不使用互斥锁；比如使用原子操作、ThreadLocal、乐观锁等来保证线程安全。</li>
<li>将所有线程共享资源管理起来，同时只给一个线程使用；一个线程一次只占用一个资源；牺牲性能，降低吞吐量。</li>
<li>设置超时时间，让线程不能永久的持有资源。尝试使用定时锁，使用 <code>lock.tryLock(timeout)</code> 来代替内部锁机制。</li>
<li>有序的获取资源，工作最快的线程不会遇到被锁住的资源。</li>
</ul>
</li>
<li>如何预防死锁？<ul>
<li>银行家算法，一种资源分配和进程调度的算法，通过动态地分析系统中进程对资源的请求以及释放来判断是否分配资源，以避免可能导致死锁的资源分配情况。</li>
<li>系统分配资源之前，通过预先检查资源分配是否会导致安全状态。</li>
<li>优点是能够避免死锁，缺点是需要事先知道每个进程的最大需求，并且对系统的资源进行动态分析。</li>
</ul>
</li>
</ol>
<p><strong>什么是死锁？</strong></p>
<p><strong>死锁 (Deadlock)</strong> 是指两个或多个线程（或进程）在执行过程中，由于相互持有并等待对方的资源，导致永远无法继续执行的状态。</p>
<p><strong>死锁产生的四个必要条件</strong></p>
<ol>
<li><strong>互斥条件:</strong> 至少有一个资源只能被一个线程持有。</li>
<li><strong>占有且等待条件:</strong> 线程已持有资源，同时等待其他资源。</li>
<li><strong>不可剥夺条件:</strong> 已获取的资源不能被强制剥夺，必须由线程主动释放。</li>
<li><strong>循环等待条件:</strong> 存在一个线程等待循环链，每个线程都等待下一个线程持有的资源。</li>
</ol>
<p><strong>死锁的产生原因</strong></p>
<ol>
<li><strong>资源竞争:</strong> 多线程争夺有限资源。</li>
<li><strong>锁的嵌套:</strong> 多线程嵌套获取多个锁。</li>
<li><strong>锁的获取顺序不一致:</strong> 不同线程按不同顺序获取锁。</li>
<li><strong>线程优先级反转:</strong> 高优先级线程等待低优先级线程释放资源。</li>
</ol>
<p><strong>如何定位死锁？</strong></p>
<p><strong>1. 线程转储分析（Thread Dump）</strong></p>
<ul>
<li>使用 <code>jstack &lt;PID&gt;</code> 命令获取 Java 应用程序的线程转储。</li>
<li>查看线程状态，检查是否有 <code>BLOCKED</code> 状态和 <code>Found one Java-level deadlock</code> 提示。</li>
</ul>
<p><strong>2. 日志分析</strong></p>
<ul>
<li>打印锁获取和释放的日志。</li>
<li>使用日志分析工具（如 ELK）集中检索和过滤日志。</li>
</ul>
<p><strong>3. APM 工具监控</strong></p>
<ul>
<li>使用应用性能监控 (APM) 工具，如 Prometheus、New Relic、Skywalking 等。</li>
</ul>
<p><strong>4. 数据库监控</strong></p>
<ul>
<li><p>在数据库中使用死锁监控命令：</p>
<figure class="highlight pgsql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">sql</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">Copy</span> code</span><br><span class="line"><span class="keyword">SHOW</span> ENGINE INNODB STATUS;</span><br></pre></td></tr></table></figure></li>
</ul>
<p>**如何处理线上死锁？                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                  **</p>
<p><strong>手动解决方案:</strong></p>
<ol>
<li><strong>重启服务:</strong> 重启可能解除死锁，但应避免频繁重启。</li>
<li><strong>线程中断:</strong> 使用 <code>Thread.interrupt()</code> 中断线程。</li>
<li><strong>数据库回滚:</strong> 数据库死锁通常自动回滚。</li>
</ol>
<p><strong>自动化解决方案:</strong></p>
<ol>
<li><strong>配置超时机制:</strong> 使用锁超时策略，避免无限等待。</li>
<li><strong>负载分流:</strong> 将高并发请求分散到不同实例。</li>
<li><strong>故障切换:</strong> 自动切换到备用服务实例。</li>
</ol>
<p><strong>如何预防和避免死锁？</strong></p>
<p><strong>代码层面</strong></p>
<ol>
<li><strong>锁顺序一致:</strong> 确保所有线程按相同顺序获取锁。</li>
<li><strong>减少锁持有时间:</strong> 尽快释放锁，减少锁的粒度。</li>
<li><strong>尝试锁机制:</strong> 使用 <code>tryLock()</code> 设置锁超时，避免长时间等待。</li>
<li><strong>避免嵌套锁:</strong> 避免嵌套锁，减少多锁依赖。</li>
<li><strong>使用并发工具:</strong> 使用 <code>java.util.concurrent</code> 提供的高效并发工具，如 <code>ReentrantLock</code>、<code>Semaphore</code>、<code>CountDownLatch</code>。</li>
</ol>
<p><strong>数据库层面</strong></p>
<ol>
<li><strong>优化事务:</strong> 尽量缩短事务时间，减少持有锁的时间。</li>
<li><strong>减少锁争用:</strong> 合理设计数据库索引和分区，减少锁冲突。</li>
<li><strong>显式加锁:</strong> 在必要时使用 <code>SELECT ... FOR UPDATE</code>。</li>
</ol>
<p><strong>示例代码：避免死锁</strong></p>
<p>正确使用 <code>ReentrantLock</code> 的示例:</p>
<figure class="highlight reasonml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line">javaCopy codeimport java.util.concurrent.locks.Lock;</span><br><span class="line">import java.util.concurrent.locks.ReentrantLock;</span><br><span class="line"></span><br><span class="line">public <span class="keyword">class</span> DeadlockAvoidance &#123;</span><br><span class="line">    <span class="keyword">private</span> final Lock lock1 = <span class="keyword">new</span> <span class="constructor">ReentrantLock()</span>;</span><br><span class="line">    <span class="keyword">private</span> final Lock lock2 = <span class="keyword">new</span> <span class="constructor">ReentrantLock()</span>;</span><br><span class="line"></span><br><span class="line">    public void operation1<span class="literal">()</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (lock1.<span class="keyword">try</span><span class="constructor">Lock()</span>) &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                <span class="module-access"><span class="module"><span class="identifier">Thread</span>.</span></span>sleep(<span class="number">100</span>);  <span class="comment">// 模拟操作</span></span><br><span class="line">                <span class="keyword">if</span> (lock2.<span class="keyword">try</span><span class="constructor">Lock()</span>) &#123;</span><br><span class="line">                    <span class="keyword">try</span> &#123;</span><br><span class="line">                        <span class="module-access"><span class="module"><span class="identifier">System</span>.</span></span>out.println(<span class="string">&quot;Operation 1 completed&quot;</span>);</span><br><span class="line">                    &#125; finally &#123;</span><br><span class="line">                        lock2.unlock<span class="literal">()</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; catch (InterruptedException e) &#123;</span><br><span class="line">                <span class="module-access"><span class="module"><span class="identifier">Thread</span>.</span></span>current<span class="constructor">Thread()</span>.interrupt<span class="literal">()</span>;</span><br><span class="line">            &#125; finally &#123;</span><br><span class="line">                lock1.unlock<span class="literal">()</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public void operation2<span class="literal">()</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (lock2.<span class="keyword">try</span><span class="constructor">Lock()</span>) &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                <span class="module-access"><span class="module"><span class="identifier">Thread</span>.</span></span>sleep(<span class="number">100</span>);  <span class="comment">// 模拟操作</span></span><br><span class="line">                <span class="keyword">if</span> (lock1.<span class="keyword">try</span><span class="constructor">Lock()</span>) &#123;</span><br><span class="line">                    <span class="keyword">try</span> &#123;</span><br><span class="line">                        <span class="module-access"><span class="module"><span class="identifier">System</span>.</span></span>out.println(<span class="string">&quot;Operation 2 completed&quot;</span>);</span><br><span class="line">                    &#125; finally &#123;</span><br><span class="line">                        lock1.unlock<span class="literal">()</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; catch (InterruptedException e) &#123;</span><br><span class="line">                <span class="module-access"><span class="module"><span class="identifier">Thread</span>.</span></span>current<span class="constructor">Thread()</span>.interrupt<span class="literal">()</span>;</span><br><span class="line">            &#125; finally &#123;</span><br><span class="line">                lock2.unlock<span class="literal">()</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<hr>
<p>通过 <strong>定位死锁</strong>、<strong>分析原因</strong>、<strong>采取预防措施</strong>，可以有效避免死锁，提高系统的稳定性和并发处理能力。</p>
<h4 id="问：加锁会带来哪些性能问题。如何解决？"><a href="#问：加锁会带来哪些性能问题。如何解决？" class="headerlink" title="问：加锁会带来哪些性能问题。如何解决？"></a>问：加锁会带来哪些性能问题。如何解决？</h4><p>锁的开销来自于三部分：</p>
<ol>
<li>上下文切换，<strong>挂起当前线程</strong>（存储当前上下文），<strong>恢复一个线程</strong>（找到一个合适的上下文并恢复到寄存器），<strong>跳转到程序计数器指向的位置</strong>（即线程被中断时的代码行）。</li>
<li>调度器开销，唤醒或休眠线程。</li>
<li>多核环境的跨处理器调度开销。</li>
</ol>
<p>如何解决这些性能开销：</p>
<ol>
<li>减少线程切换，如通过CAS尝试短时间内请求锁的自旋锁。</li>
<li>减少锁的冲突次数，比如读写锁分离，哈希表分段加锁等。</li>
<li>在较少竞争的环境下尽量避免使用锁，如 <code>synchronized</code> 对锁分等级，CAS + volatile 等</li>
</ol>
<p><strong>一、加锁的性能问题</strong></p>
<ol>
<li><strong>线程阻塞与上下文切换成本</strong><ul>
<li><strong>原因:</strong> 线程获取锁失败时会阻塞，导致频繁的线程上下文切换。</li>
<li><strong>影响:</strong> 增加 CPU 使用率，降低应用程序吞吐量。</li>
</ul>
</li>
<li><strong>锁竞争（资源争用）</strong><ul>
<li><strong>原因:</strong> 多线程争夺同一个锁时，出现竞争，导致线程等待。</li>
<li><strong>影响:</strong> 高并发环境下，锁竞争严重，系统性能下降。</li>
</ul>
</li>
<li><strong>死锁风险</strong><ul>
<li><strong>原因:</strong> 多线程在不一致的锁获取顺序下，容易导致死锁。</li>
<li><strong>影响:</strong> 程序无法继续执行，需手动干预或重启服务。</li>
</ul>
</li>
<li><strong>缓存一致性问题</strong><ul>
<li><strong>原因:</strong> 多核 CPU 下的缓存同步机制（MESI 协议）会频繁刷新缓存，导致 CPU 性能下降。</li>
<li><strong>影响:</strong> 系统运行变慢，性能下降。</li>
</ul>
</li>
<li><strong>锁开销（锁的管理成本）</strong><ul>
<li><strong>原因:</strong> 加锁与解锁本身会引入额外的 CPU 开销。</li>
<li><strong>影响:</strong> 在锁持有时间短但频繁使用时，这一开销变得显著。</li>
</ul>
</li>
</ol>
<p><strong>二、解决方案：优化加锁机制</strong></p>
<p><strong>1. 减少锁的粒度</strong></p>
<ul>
<li><p><strong>描述:</strong> 将大范围锁缩小到更精确的代码段或数据。</p>
</li>
<li><p>示例:</p>
<figure class="highlight less"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-tag">javaCopy</span> <span class="selector-tag">code</span><span class="comment">// 锁粒度过大</span></span><br><span class="line"><span class="selector-tag">synchronized</span> (this) &#123;</span><br><span class="line">    <span class="selector-tag">criticalOperation</span>();</span><br><span class="line">    <span class="selector-tag">nonCriticalOperation</span>();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 优化后的代码</span></span><br><span class="line"><span class="selector-tag">criticalOperation</span>();</span><br><span class="line"><span class="selector-tag">synchronized</span> (this) &#123;</span><br><span class="line">    <span class="selector-tag">nonCriticalOperation</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
<p><strong>2. 使用读写锁（ReentrantReadWriteLock）</strong></p>
<ul>
<li><p><strong>描述:</strong> 允许多个线程并发读取，写操作独占，减少锁冲突。</p>
</li>
<li><p>示例:</p>
<figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">javaCopy codeprivate final ReentrantReadWriteLock <span class="keyword">lock</span> = <span class="keyword">new</span> ReentrantReadWriteLock();</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">read</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">    <span class="keyword">lock</span>.readLock().<span class="keyword">lock</span>();</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="comment">// 读操作</span></span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        <span class="keyword">lock</span>.readLock().unlock();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">write</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">    <span class="keyword">lock</span>.writeLock().<span class="keyword">lock</span>();</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="comment">// 写操作</span></span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        <span class="keyword">lock</span>.writeLock().unlock();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
<p><strong>3. 使用无锁算法（CAS）</strong></p>
<ul>
<li><p><strong>描述:</strong> 使用 <code>AtomicInteger</code>、<code>ConcurrentHashMap</code> 等基于 CAS 的无锁数据结构，避免锁开销。</p>
</li>
<li><p>示例:</p>
<figure class="highlight arduino"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">javaCopy codeprivate <span class="keyword">final</span> AtomicInteger counter = <span class="keyword">new</span> <span class="built_in">AtomicInteger</span>(<span class="number">0</span>);</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">increment</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    counter.<span class="built_in">incrementAndGet</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
<p><strong>4. 使用锁分段机制</strong></p>
<ul>
<li><strong>描述:</strong> 将锁划分为多个段，减少锁冲突。例如 <code>ConcurrentHashMap</code>。</li>
</ul>
<p><strong>5. 使用线程局部变量（ThreadLocal）</strong></p>
<ul>
<li><p><strong>描述:</strong> 将数据与线程绑定，避免共享变量带来的锁竞争。</p>
</li>
<li><p>示例:</p>
<figure class="highlight reasonml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">java</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">Copy code</span><br><span class="line"><span class="keyword">private</span> final ThreadLocal&lt;Integer&gt; threadLocalValue = <span class="module-access"><span class="module"><span class="identifier">ThreadLocal</span>.</span></span><span class="keyword">with</span><span class="constructor">Initial(()</span> -&gt; <span class="number">0</span>);</span><br></pre></td></tr></table></figure></li>
</ul>
<p><strong>6. 尝试锁（TryLock）机制</strong></p>
<ul>
<li><p><strong>描述:</strong> 避免线程长时间等待锁，通过 <code>tryLock()</code> 设置超时机制。</p>
</li>
<li><p>示例:</p>
<figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">javaCopy <span class="title">codeif</span> (<span class="params"><span class="keyword">lock</span>.tryLock(<span class="number">100</span>, TimeUnit.MILLISECONDS</span>))</span> &#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="comment">// 执行操作</span></span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        <span class="keyword">lock</span>.unlock();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
<p><strong>7. 锁消除（JIT 优化）</strong></p>
<ul>
<li><strong>描述:</strong> 编译时通过逃逸分析，自动消除不必要的锁。</li>
</ul>
<p><strong>三、其他优化策略</strong></p>
<ol>
<li><strong>减少共享资源</strong>: 尽量减少共享数据，分离不同线程的数据。</li>
<li><strong>优化并发策略</strong>: 选择适合的并发工具，如 <code>ForkJoinPool</code>、<code>CompletableFuture</code> 等。</li>
<li><strong>数据库层优化</strong>: 优化事务范围和锁策略，如减少 <code>SELECT ... FOR UPDATE</code> 使用。</li>
<li><strong>分布式锁优化</strong>: 在分布式系统中使用 Redis、Zookeeper 实现高效的分布式锁。</li>
</ol>
<h4 id="问：偏向锁、轻量级锁、自旋锁等优化？"><a href="#问：偏向锁、轻量级锁、自旋锁等优化？" class="headerlink" title="问：偏向锁、轻量级锁、自旋锁等优化？"></a>问：偏向锁、轻量级锁、自旋锁等优化？</h4><p>Java 虚拟机通过多种锁优化策略来提升并发性能，主要包括 <strong>偏向锁</strong>、<strong>轻量级锁</strong>、<strong>自旋锁</strong>、<strong>锁消除</strong> 和 <strong>锁粗化</strong>。</p>
<p><strong>1. 偏向锁 (Biased Locking)</strong></p>
<p><strong>概念:</strong></p>
<ul>
<li>偏向锁是一个优化，假设锁大多数情况下由同一个线程持有。</li>
<li>第一次获得锁时，锁对象头记录当前线程 ID，以后该线程再进入同步块时，不需要再做锁竞争，直接进入。</li>
</ul>
<p><strong>优点:</strong></p>
<ul>
<li>避免了线程 CAS 操作，提升性能。</li>
</ul>
<p><strong>触发条件:</strong></p>
<ul>
<li>同一线程多次访问同步块时自动启用。</li>
</ul>
<p><strong>撤销条件:</strong></p>
<ul>
<li>另一个线程尝试获取锁时，偏向锁会撤销，升级为轻量级锁。</li>
</ul>
<p><strong>适用场景:</strong></p>
<ul>
<li>适用于锁竞争极少的单线程环境。</li>
</ul>
<p><strong>2. 轻量级锁 (Lightweight Locking)</strong></p>
<p><strong>概念:</strong></p>
<ul>
<li>多线程争用锁时，轻量级锁通过 CAS 操作避免了重量级锁的阻塞。</li>
<li>每个线程会将对象头的锁标记复制到自己创建的锁记录中，使用 CAS 尝试修改对象头的锁标记指向锁记录。</li>
</ul>
<p><strong>优点:</strong></p>
<ul>
<li>避免线程阻塞，提高性能。</li>
</ul>
<p><strong>升级条件:</strong></p>
<ul>
<li>如果 CAS 操作失败，表示有多个线程竞争，锁升级为重量级锁。</li>
</ul>
<p><strong>适用场景:</strong></p>
<ul>
<li>适用于短时间锁竞争的场景。</li>
</ul>
<p><strong>3. 自旋锁 (Spin Lock)</strong></p>
<p><strong>概念:</strong></p>
<ul>
<li>多线程竞争锁时，线程不会立即阻塞，而是循环等待一段时间。</li>
<li>自旋期间线程不进入内核态，减少了线程阻塞与唤醒的开销。</li>
</ul>
<p><strong>优点:</strong></p>
<ul>
<li>避免了线程的阻塞和唤醒，适合短期锁争用。</li>
</ul>
<p><strong>缺点:</strong></p>
<ul>
<li>自旋消耗 CPU，等待时间过长可能导致性能下降。</li>
</ul>
<p><strong>优化策略:</strong></p>
<ul>
<li>JDK 默认开启自适应自旋锁，根据竞争历史动态调整自旋次数。</li>
</ul>
<p><strong>适用场景:</strong></p>
<ul>
<li>适用于多核 CPU 和短期锁竞争环境。</li>
</ul>
<p><strong>4. 锁消除 (Lock Elimination)</strong></p>
<p><strong>概念:</strong></p>
<ul>
<li>通过逃逸分析，在编译期消除不必要的同步操作。</li>
</ul>
<p><strong>示例:</strong></p>
<figure class="highlight processing"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">javaCopy codepublic <span class="keyword">String</span> <span class="built_in">concat</span>(<span class="keyword">String</span> a, <span class="keyword">String</span> b) &#123;</span><br><span class="line">    StringBuffer sb = <span class="keyword">new</span> StringBuffer();</span><br><span class="line">    sb.<span class="built_in">append</span>(a);</span><br><span class="line">    sb.<span class="built_in">append</span>(b);</span><br><span class="line">    <span class="keyword">return</span> sb.toString();  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>编译期检测到 <code>StringBuffer</code> 没有逃逸出方法范围，锁会被消除。</li>
</ul>
<p><strong>适用场景:</strong></p>
<ul>
<li>编译期静态分析时发现无线程竞争。</li>
</ul>
<p><strong>5. 锁粗化 (Lock Coarsening)</strong></p>
<p><strong>概念:</strong></p>
<ul>
<li>编译器将多个连续的锁操作合并，减少锁的频繁获取与释放。</li>
</ul>
<p><strong>示例:</strong></p>
<figure class="highlight aspectj"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">javaCopy <span class="title">codefor</span> <span class="params">(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">1000</span>; i++)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">synchronized</span> (lock) &#123;</span><br><span class="line">        <span class="comment">// 执行代码</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>优化为：</p>
<figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">javaCopy <span class="title">codesynchronized</span> (<span class="params"><span class="keyword">lock</span></span>)</span> &#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="built_in">int</span> i = <span class="number">0</span>; i &lt; <span class="number">1000</span>; i++) &#123;</span><br><span class="line">        <span class="comment">// 执行代码</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>适用场景:</strong></p>
<ul>
<li>频繁获取与释放同一锁的场景。</li>
</ul>
<p><strong>锁状态的转换过程:</strong></p>
<ol>
<li><strong>无锁状态:</strong> 初始状态，无线程竞争。</li>
<li><strong>偏向锁:</strong> 单个线程多次使用时自动启用。</li>
<li><strong>轻量级锁:</strong> 多个线程尝试获取锁时，通过 CAS 进入轻量级锁。</li>
<li><strong>重量级锁:</strong> 多线程锁竞争激烈，升级为重量级锁，线程阻塞。</li>
</ol>
<p><strong>应用场景总结:</strong></p>
<table>
<thead>
<tr>
<th>锁类型</th>
<th>优点</th>
<th>缺点</th>
<th>适用场景</th>
</tr>
</thead>
<tbody><tr>
<td><strong>偏向锁</strong></td>
<td>无竞争时性能最佳</td>
<td>有竞争时撤销成本高</td>
<td>无竞争，单线程环境</td>
</tr>
<tr>
<td><strong>轻量级锁</strong></td>
<td>无阻塞，减少线程切换</td>
<td>多线程时性能下降</td>
<td>短时锁竞争</td>
</tr>
<tr>
<td><strong>自旋锁</strong></td>
<td>避免阻塞，提高吞吐量</td>
<td>消耗 CPU，等待过长损耗</td>
<td>短时间高频竞争</td>
</tr>
<tr>
<td><strong>重量级锁</strong></td>
<td>保证数据一致性</td>
<td>阻塞线程，切换成本高</td>
<td>高强度并发竞争</td>
</tr>
<tr>
<td><strong>锁消除</strong></td>
<td>消除不必要的锁</td>
<td>仅限编译期优化</td>
<td>无跨线程资源访问</td>
</tr>
<tr>
<td><strong>锁粗化</strong></td>
<td>减少锁频繁获取与释放</td>
<td>需编译器自动优化</td>
<td>持续锁操作场景</td>
</tr>
</tbody></table>
<h4 id="问：事务有哪些特性？怎么理解原子性？"><a href="#问：事务有哪些特性？怎么理解原子性？" class="headerlink" title="问：事务有哪些特性？怎么理解原子性？"></a>问：事务有哪些特性？怎么理解原子性？</h4><p>数据库事务具有四个关键特性，称为 <strong>ACID</strong>，分别是：</p>
<ol>
<li><strong>原子性 (Atomicity)</strong></li>
<li><strong>一致性 (Consistency)</strong></li>
<li><strong>隔离性 (Isolation)</strong></li>
<li><strong>持久性 (Durability)</strong></li>
</ol>
<p><strong>1. 原子性 (Atomicity)</strong></p>
<p><strong>定义:</strong></p>
<ul>
<li>原子性指事务中的操作要么全部成功执行，要么全部回滚，事务不可分割。</li>
</ul>
<p><strong>理解:</strong></p>
<ul>
<li>事务内的多个数据库操作被视为一个整体。如果在执行过程中出现任何错误，数据库会回滚到事务开始之前的状态，确保操作不会有部分成功部分失败的情况。</li>
</ul>
<p><strong>示例:</strong></p>
<p>假设有一个银行转账操作：</p>
<figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">text</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">Copy <span class="selector-tag">code</span></span><br><span class="line">账户 <span class="selector-tag">A</span> 转账 <span class="number">100</span> 元到账户 <span class="selector-tag">B</span>。</span><br></pre></td></tr></table></figure>

<p>这包含两个操作：</p>
<ul>
<li>从账户 A 扣除 100 元</li>
<li>向账户 B 增加 100 元</li>
</ul>
<p>如果在执行第一个操作后发生系统崩溃，第二个操作未执行，系统需要回滚，保证账户 A 的余额恢复到转账前的状态，防止资金丢失。</p>
<p><strong>2. 一致性 (Consistency)</strong></p>
<p><strong>定义:</strong></p>
<ul>
<li>事务执行前后，数据库必须保持一致状态，满足数据完整性约束规则。</li>
</ul>
<p><strong>理解:</strong></p>
<ul>
<li>数据库中的约束（如主键、外键、唯一性等）在事务执行后必须仍然有效，确保数据不会出现非法状态。</li>
</ul>
<p><strong>示例:</strong></p>
<ul>
<li>银行系统中，转账过程中，两个账户的总余额必须保持不变。即使在事务中断时，也必须恢复到原始状态或最终正确的状态。</li>
</ul>
<p><strong>3. 隔离性 (Isolation)</strong></p>
<p><strong>定义:</strong></p>
<ul>
<li>多个事务并发执行时，各事务之间相互独立，不能相互影响。</li>
</ul>
<p><strong>理解:</strong></p>
<ul>
<li>一个事务的中间状态对其他事务是不可见的，事务隔离通过锁机制等手段来实现。</li>
</ul>
<p><strong>示例:</strong></p>
<ul>
<li>两个用户同时购买库存为 1 的商品。事务隔离确保只有一个用户能成功下单，另一个用户会被阻塞或看到更新后的库存。</li>
</ul>
<p><strong>隔离级别（从低到高）:</strong></p>
<ul>
<li><strong>READ UNCOMMITTED:</strong> 允许读取未提交的数据（脏读）。</li>
<li><strong>READ COMMITTED:</strong> 只允许读取已提交的数据（避免脏读）。</li>
<li><strong>REPEATABLE READ:</strong> 多次读取数据结果相同（避免不可重复读）。</li>
<li><strong>SERIALIZABLE:</strong> 完全隔离，事务串行执行（避免幻读）。</li>
</ul>
<p><strong>4. 持久性 (Durability)</strong></p>
<p><strong>定义:</strong></p>
<ul>
<li>事务一旦提交，修改结果必须永久保存，即使发生系统故障或崩溃。</li>
</ul>
<p><strong>理解:</strong></p>
<ul>
<li>提交后的数据必须存储在持久性存储设备中，如磁盘或数据库日志文件，确保事务结果不会丢失。</li>
</ul>
<p><strong>示例:</strong></p>
<ul>
<li>在电商系统中，用户下单后收到订单确认，即使系统随后崩溃，用户的订单数据也应保存在数据库中。</li>
</ul>
<table>
<thead>
<tr>
<th><strong>属性</strong></th>
<th><strong>定义</strong></th>
<th><strong>示例</strong></th>
</tr>
</thead>
<tbody><tr>
<td><strong>原子性</strong></td>
<td>全部成功或全部回滚</td>
<td>转账时两账户同时增减金额</td>
</tr>
<tr>
<td><strong>一致性</strong></td>
<td>数据在事务前后必须满足完整性规则</td>
<td>转账后两账户的总余额不变</td>
</tr>
<tr>
<td><strong>隔离性</strong></td>
<td>多事务并发执行时互不干扰</td>
<td>两用户同时购买同一库存商品</td>
</tr>
<tr>
<td><strong>持久性</strong></td>
<td>提交的数据永久保存</td>
<td>下单成功后即使系统崩溃订单仍在</td>
</tr>
</tbody></table>
<hr>
<h3 id="2-2-volatile"><a href="#2-2-volatile" class="headerlink" title="2.2 volatile"></a>2.2 volatile</h3><h4 id="问：volatile的作用是什么？可见性？⭐⭐⭐"><a href="#问：volatile的作用是什么？可见性？⭐⭐⭐" class="headerlink" title="问：volatile的作用是什么？可见性？⭐⭐⭐"></a>问：volatile的作用是什么？可见性？⭐⭐⭐</h4><p>volatile变量<br>（1）：变量可见性</p>
<p>（2）：防止指令重排序</p>
<p>（3）：保障变量单次读，写操作的原子性，但不能保证i++这种操作的原子性，因为本质是读，写两次操作</p>
<p>在 Java 中，<code>volatile</code> 是一种轻量级的同步机制，主要用来解决 <strong>可见性</strong> 和 <strong>禁止指令重排序</strong> 问题，确保变量在多线程环境中的正确性。</p>
<p><strong><code>volatile</code> 的两个核心功能</strong></p>
<ol>
<li><p><strong>保证可见性 (Visibility):</strong></p>
<ul>
<li><p>当一个线程修改了 <code>volatile</code> 修饰的变量，其他线程能够立即看到最新值。</p>
</li>
<li><p>JVM 会强制将变量的新值从线程工作内存刷新到主内存。</p>
</li>
<li><p>示例：</p>
<figure class="highlight arduino"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">javaCopy codeclass VolatileExample &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">volatile</span> <span class="keyword">boolean</span> running = <span class="literal">true</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">stop</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        running = <span class="literal">false</span>;  <span class="comment">// 修改了 running，其他线程可见</span></span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">while</span> (running) &#123;</span><br><span class="line">            <span class="comment">// 如果没有 volatile，可能永远不会退出循环</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
</li>
<li><p><strong>禁止指令重排序 (Orderliness):</strong></p>
<ul>
<li><p><code>volatile</code> 禁止 JVM 对该变量的读写操作进行指令重排序。</p>
</li>
<li><p>这在 <strong>双重检查锁定单例模式</strong> 中非常重要，避免在初始化过程中发生对象未完全初始化的问题。</p>
</li>
<li><p>示例：</p>
<figure class="highlight smali"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">javaCopy codeclass Singleton &#123;</span><br><span class="line">   <span class="keyword"> private</span><span class="keyword"> static</span> volatile Singleton instance;</span><br><span class="line">    </span><br><span class="line">   <span class="keyword"> public</span><span class="keyword"> static</span> Singleton getInstance() &#123;</span><br><span class="line">       <span class="built_in"> if </span>(instance == null) &#123;</span><br><span class="line">            synchronized (Singleton.class) &#123;</span><br><span class="line">               <span class="built_in"> if </span>(instance == null) &#123;</span><br><span class="line">                   <span class="built_in"> instance </span>=<span class="built_in"> new </span>Singleton();  // 禁止重排序，确保初始化安全</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">       <span class="built_in"> return </span>instance;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
</li>
</ol>
<p><strong>为什么需要可见性？</strong></p>
<p>在 Java 内存模型中，每个线程都有自己的 **工作内存 (Working Memory)**，从主内存中拷贝变量的值进行操作。如果没有 <code>volatile</code> 修饰，线程可能只操作工作内存中的值，而不更新主内存，导致数据不同步的问题。</p>
<p><strong>注意事项与局限性</strong></p>
<ol>
<li><strong>不保证原子性：</strong><ul>
<li><code>volatile</code> 不能保证复合操作的原子性，如自增 <code>count++</code>。</li>
<li>解决方法：使用 <code>AtomicInteger</code> 或显式锁 <code>synchronized</code>。</li>
</ul>
</li>
<li><strong>适用场景：</strong><ul>
<li>状态标志变量（如 <code>boolean running</code>）。</li>
<li>不涉及复合操作的变量（如单一赋值）。</li>
</ul>
</li>
</ol>
<p><strong>小结：<code>volatile</code> 的核心作用</strong></p>
<table>
<thead>
<tr>
<th><strong>功能</strong></th>
<th><strong>描述</strong></th>
</tr>
</thead>
<tbody><tr>
<td><strong>可见性 (Visibility)</strong></td>
<td>保证变量的修改对所有线程立即可见</td>
</tr>
<tr>
<td><strong>禁止重排序 (Order)</strong></td>
<td>避免指令重排序，确保内存可见性顺序</td>
</tr>
<tr>
<td><strong>不保证原子性</strong></td>
<td>需配合 <code>synchronized</code> 或 <code>Atomic</code></td>
</tr>
<tr>
<td><strong>适用场景</strong></td>
<td>状态标志、简单变量同步等轻量场景</td>
</tr>
</tbody></table>
<p><code>volatile</code> 是多线程开发中的关键修饰符，在保证变量可见性和内存顺序上非常重要，但需结合实际业务场景，避免误用带来的性能问题。</p>
<h4 id="问：volatile-的实现原理？及内存屏障相关？⭐⭐"><a href="#问：volatile-的实现原理？及内存屏障相关？⭐⭐" class="headerlink" title="问：volatile 的实现原理？及内存屏障相关？⭐⭐"></a>问：volatile 的实现原理？及内存屏障相关？⭐⭐</h4><p><code>volatile</code> 的实现依赖于 <strong>内存屏障 (Memory Barrier)</strong> 和 **缓存一致性协议 (Cache Coherence Protocol)**。这些机制确保 <code>volatile</code> 变量在多线程环境中的可见性与有序性。</p>
<p><strong>1. 内存屏障 (Memory Barrier)</strong></p>
<p><strong>内存屏障</strong> 是一条 CPU 指令，强制处理器在读写特定变量时执行特定操作，从而避免重排序和保证内存可见性。</p>
<p><strong>内存屏障的作用：</strong></p>
<ul>
<li><strong>强制刷新缓存：</strong> 确保当前线程的缓存写入主内存。</li>
<li><strong>禁止指令重排序：</strong> 阻止处理器对内存屏障前后的指令进行重排序。</li>
</ul>
<p><strong>内存屏障类型：</strong></p>
<ol>
<li><strong>LoadLoad 屏障：</strong><ul>
<li>作用：禁止读操作重排序。</li>
<li>示例：<code>Load1; LoadLoad; Load2</code> 确保 <code>Load1</code> 必须在 <code>Load2</code> 之前执行。</li>
</ul>
</li>
<li><strong>StoreStore 屏障：</strong><ul>
<li>作用：禁止写操作重排序。</li>
<li>示例：<code>Store1; StoreStore; Store2</code> 确保 <code>Store1</code> 必须在 <code>Store2</code> 之前执行。</li>
</ul>
</li>
<li><strong>LoadStore 屏障：</strong><ul>
<li>作用：禁止读操作与后续写操作重排序。</li>
<li>示例：<code>Load1; LoadStore; Store2</code> 确保 <code>Load1</code> 在 <code>Store2</code> 之前执行。</li>
</ul>
</li>
<li><strong>StoreLoad 屏障：</strong><ul>
<li>作用：禁止写操作与后续读操作重排序。</li>
<li>示例：<code>Store1; StoreLoad; Load2</code> 确保 <code>Store1</code> 在 <code>Load2</code> 之前完成。</li>
<li><strong>最强屏障</strong>，影响最大，常用于 <code>volatile</code> 实现。</li>
</ul>
</li>
</ol>
<p><strong>2. <code>volatile</code> 的内存屏障实现机制</strong></p>
<p>根据 Java 内存模型（JMM），<code>volatile</code> 变量的读写会插入内存屏障，具体规则如下：</p>
<ul>
<li><strong>写入 <code>volatile</code> 变量时：</strong><ul>
<li>插入 <code>StoreStore</code> 和 <code>StoreLoad</code> 屏障，确保写操作完成，刷新到主内存。</li>
<li>确保后续读写操作不会被重排序到前面。</li>
</ul>
</li>
<li><strong>读取 <code>volatile</code> 变量时：</strong><ul>
<li>插入 <code>LoadLoad</code> 和 <code>LoadStore</code> 屏障，确保变量从主内存读取，避免读取陈旧数据。</li>
<li>确保读取操作之前的写操作不会被重排序。</li>
</ul>
</li>
</ul>
<p><strong>3. 缓存一致性协议（MESI 协议）</strong></p>
<p>为了多核 CPU 环境中数据一致性，Java 使用 CPU 的 <strong>缓存一致性协议</strong> (如 MESI)，确保多个 CPU 核心对共享变量的操作是同步的。</p>
<ul>
<li>原理：<ul>
<li>当一个线程修改 <code>volatile</code> 变量时，CPU 会通过总线通知其他 CPU 该变量失效，强制其他 CPU 从主内存重新加载该变量。</li>
</ul>
</li>
</ul>
<p><strong>示例分析：<code>volatile</code> 实现内存屏障示意图</strong></p>
<figure class="highlight gradle"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">javaCopy codeclass VolatileExample &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">volatile</span> <span class="keyword">int</span> <span class="keyword">count</span> = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> update() &#123;</span><br><span class="line">        <span class="keyword">count</span> = <span class="number">10</span>;  <span class="comment">// 写操作，插入 StoreStore + StoreLoad</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">int</span> <span class="keyword">read</span>() &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">count</span>;  <span class="comment">// 读操作，插入 LoadLoad + LoadStore</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>小结：<code>volatile</code> 实现原理总结</strong></p>
<table>
<thead>
<tr>
<th><strong>机制</strong></th>
<th><strong>功能</strong></th>
</tr>
</thead>
<tbody><tr>
<td><strong>内存屏障 (Memory Barrier)</strong></td>
<td>禁止重排序，确保内存可见性</td>
</tr>
<tr>
<td><strong>缓存一致性协议 (MESI)</strong></td>
<td>保证多核 CPU 间数据一致性</td>
</tr>
<tr>
<td><strong>禁止重排序规则</strong></td>
<td>读操作插入 <code>LoadLoad</code> 和 <code>LoadStore</code></td>
</tr>
<tr>
<td></td>
<td>写操作插入 <code>StoreStore</code> 和 <code>StoreLoad</code></td>
</tr>
</tbody></table>
<p>通过内存屏障与缓存一致性协议，<code>volatile</code> 实现了对变量的 <strong>可见性</strong> 和 <strong>有序性</strong>，确保多线程环境中的数据正确性和一致性。</p>
<h4 id="问：volatile如何保证线程间可见和避免指令重排？"><a href="#问：volatile如何保证线程间可见和避免指令重排？" class="headerlink" title="问：volatile如何保证线程间可见和避免指令重排？"></a>问：volatile如何保证线程间可见和避免指令重排？</h4><p>volatile可见性是有指令原子性保证的，在jmm中定义了8类原子性指令，比如write，store，read，load。而volatile就要求write-store，load-read成为一个原子性操作，这样子可以确保在读取的时候都是从主内存读入，写入的时候会同步到主内存中（准确来说也是内存屏障），指令重排则是由内存屏障来保证的，由两个内存屏障:</p>
<blockquote>
<ul>
<li>一个是编译器屏障：阻止编译器重排，保证编译程序时在优化屏障之前的指令不会在优化屏障之后执行。</li>
<li>第二个是cpu屏障：sfence保证写入，lfence保证读取，lock类似于锁的方式。java多执行了一个“load addl $0x0, (%esp)”操作，这个操作相当于一个lock指令，就是增加一个完全的内存屏障指令。</li>
</ul>
</blockquote>
<p><code>volatile</code> 是 Java 内存模型 (JMM) 中用于多线程环境的轻量级同步机制。它通过 <strong>可见性</strong> 和 <strong>有序性（防止指令重排）</strong> 两个特性来确保数据的正确性。</p>
<p><strong>1. 保证线程间的可见性</strong></p>
<p><strong>机制：内存屏障与缓存一致性协议</strong></p>
<ul>
<li><strong>内存屏障（Memory Barrier）：</strong><ul>
<li><code>volatile</code> 变量的写操作会在写入主内存时插入内存屏障，确保更改立即被其他线程可见。</li>
<li><code>volatile</code> 变量的读操作会从主内存中重新读取，防止读取过期数据。</li>
</ul>
</li>
<li><strong>缓存一致性协议（如 MESI 协议）：</strong><ul>
<li>多核 CPU 使用 MESI 协议，当一个线程修改了 <code>volatile</code> 变量，CPU 会通过总线协议使其他 CPU 的缓存行失效，强制其他线程从主内存重新加载该变量。</li>
</ul>
</li>
</ul>
<p><strong>示例：可见性问题的修复</strong></p>
<figure class="highlight arduino"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">javaCopy codeclass VisibilityExample &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">volatile</span> <span class="keyword">boolean</span> running = <span class="literal">true</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">start</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">new</span> <span class="built_in">Thread</span>(() -&gt; &#123;</span><br><span class="line">            <span class="keyword">while</span> (running) &#123;</span><br><span class="line">                <span class="comment">// busy-waiting</span></span><br><span class="line">            &#125;</span><br><span class="line">            System.out.<span class="built_in">println</span>(<span class="string">&quot;Stopped&quot;</span>);</span><br><span class="line">        &#125;).<span class="built_in">start</span>();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">stop</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        running = <span class="literal">false</span>;  <span class="comment">// 写入操作立即可见</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>解释：</strong></p>
<ul>
<li>当主线程调用 <code>stop()</code>，修改了 <code>running</code> 的值。</li>
<li>因为 <code>running</code> 被声明为 <code>volatile</code>，它的更新会立即刷新到主内存。</li>
<li>子线程每次从主内存读取 <code>running</code>，所以它会看到最新值，正常退出循环。</li>
</ul>
<p><strong>2. 避免指令重排（有序性）</strong></p>
<p><strong>机制：内存屏障规则与指令重排优化限制</strong></p>
<p>Java 内存模型会在 <code>volatile</code> 变量的读写操作前后插入适当的内存屏障，确保代码在执行时保持特定的顺序：</p>
<p><strong>重排序规则：</strong></p>
<ol>
<li><strong>写 <code>volatile</code> 变量时：</strong><br>插入 <code>StoreStore</code> 和 <code>StoreLoad</code> 屏障：<ul>
<li><code>StoreStore</code>: 确保写操作前的普通写操作不会与 <code>volatile</code> 写操作重排。</li>
<li><code>StoreLoad</code>: 禁止写操作与后续的读操作重排。</li>
</ul>
</li>
<li><strong>读 <code>volatile</code> 变量时：</strong><br>插入 <code>LoadLoad</code> 和 <code>LoadStore</code> 屏障：<ul>
<li><code>LoadLoad</code>: 确保前面的读取操作不会与当前 <code>volatile</code> 读操作重排。</li>
<li><code>LoadStore</code>: 确保前面的读取操作不会与后续写操作重排。</li>
</ul>
</li>
</ol>
<p><strong>示例：禁止指令重排（双重检查锁实现单例）</strong></p>
<figure class="highlight smali"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">javaCopy codeclass Singleton &#123;</span><br><span class="line">   <span class="keyword"> private</span><span class="keyword"> static</span> volatile Singleton instance;</span><br><span class="line"></span><br><span class="line">   <span class="keyword"> private</span> Singleton() &#123;&#125;</span><br><span class="line"></span><br><span class="line">   <span class="keyword"> public</span><span class="keyword"> static</span> Singleton getInstance() &#123;</span><br><span class="line">       <span class="built_in"> if </span>(instance == null) &#123;  // 第一次检查</span><br><span class="line">            synchronized (Singleton.class) &#123;</span><br><span class="line">               <span class="built_in"> if </span>(instance == null) &#123;  // 第二次检查</span><br><span class="line">                   <span class="built_in"> instance </span>=<span class="built_in"> new </span>Singleton();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">       <span class="built_in"> return </span>instance;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>解释：</strong></p>
<ul>
<li><code>volatile</code> 关键字确保 <code>instance</code> 的赋值操作不会被重排序。</li>
<li>在没有 <code>volatile</code> 时，可能出现重排序：对象内存分配完成，但构造方法未执行，其他线程却访问了未初始化的对象。</li>
</ul>
<p><strong>小结：<code>volatile</code> 的两大特性与实现机制</strong></p>
<table>
<thead>
<tr>
<th><strong>功能</strong></th>
<th><strong>实现机制</strong></th>
</tr>
</thead>
<tbody><tr>
<td><strong>线程间可见性</strong></td>
<td>主内存同步 + 缓存一致性协议</td>
</tr>
<tr>
<td><strong>防止指令重排</strong></td>
<td>内存屏障规则（读/写屏障插入）</td>
</tr>
</tbody></table>
<p>通过这两个机制，<code>volatile</code> 保证了线程间数据共享的可见性，并防止指令重排，提高了多线程环境下的数据一致性与代码执行的有序性。</p>
<hr>
<h3 id="2-3-synchronized"><a href="#2-3-synchronized" class="headerlink" title="2.3 synchronized"></a>2.3 synchronized</h3><h4 id="问：synchronized-使用方式及实现原理，以及锁优化？⭐⭐⭐"><a href="#问：synchronized-使用方式及实现原理，以及锁优化？⭐⭐⭐" class="headerlink" title="问：synchronized 使用方式及实现原理，以及锁优化？⭐⭐⭐"></a>问：synchronized 使用方式及实现原理，以及锁优化？⭐⭐⭐</h4><p><code>synchronized</code> 是 Java 中用于实现线程同步的关键字，它通过 <strong>监视器锁（Monitor）</strong> 来保证同一时间只有一个线程可以执行被保护的代码块或方法。以下是 <code>synchronized</code> 的实现原理和相关概念的详细解释：</p>
<ol>
<li><p><strong><code>synchronized</code> 的基本原理</strong></p>
<ul>
<li><p><strong>监视器锁（Monitor）</strong>：记录了持有锁的线程和锁的重入次数**。</p>
<ul>
<li>每个 Java 对象都有一个与之关联的监视器锁（Monitor）。</li>
<li>当线程进入 <code>synchronized</code> 代码块时，会尝试获取对象的监视器锁。</li>
<li>如果锁被其他线程持有，当前线程会进入阻塞状态，直到锁被释放。</li>
</ul>
</li>
<li><p><strong><code>monitorenter</code> 和 <code>monitorexit</code> 指令</strong></p>
<ul>
<li><p><code>synchronized</code> 的底层实现依赖于 JVM 的一对字节码指令：</p>
<ul>
<li><code>monitorenter</code>：尝试获取对象的监视器锁。</li>
<li><code>monitorexit</code>：释放对象的监视器锁。</li>
</ul>
</li>
<li><p>这两个指令确保同一时间只有一个线程可以执行 <code>synchronized</code> 代码块。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">synchronizedMethod</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">synchronized</span> (<span class="keyword">this</span>) &#123;</span><br><span class="line">        <span class="comment">// 同步代码块</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">对应的字节码：</span><br><span class="line">monitorenter</span><br><span class="line"><span class="comment">// 同步代码块</span></span><br><span class="line">monitorexit</span><br></pre></td></tr></table></figure></li>
<li><p>获取锁的过程：线程执行 <code>monitorenter</code> 指令，尝试获取对象的监视器锁 <code>Monitor</code>。</p>
<ul>
<li><strong>如果 <code>Monitor</code> 为空（未被持有）</strong>：<ul>
<li>线程 **获取锁，设置 <code>owner</code>**。</li>
<li>**重入计数器 <code>recursion = 1</code>**。</li>
</ul>
</li>
<li><strong>如果 <code>Monitor</code> 被当前线程持有</strong>：允许<strong>重入</strong>，<code>recursion++</code>。</li>
<li><strong>如果 <code>Monitor</code> 被其他线程持有</strong>：<ul>
<li>线程进入 <code>ContentionList</code>，进行<strong>自旋等待</strong>。</li>
<li><strong>如果自旋失败，则进入阻塞</strong>。</li>
</ul>
</li>
</ul>
</li>
<li><p>释放锁的过程：**当前线程调用 <code>monitorexit</code>**指令，释放锁并将进入数减 1。</p>
<ul>
<li><code>recursion--</code>，如果 <code>recursion == 0</code>，锁被释放。</li>
<li><strong>从 <code>entryList</code> 或 <code>ContentionList</code> 选一个线程作为 <code>onDeck</code></strong> 进入竞争。</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li><p><code>synchronized</code> 的四种状态：</p>
<ul>
<li><strong>无锁状态</strong>：对象的监视器锁未被任何线程持有。</li>
<li><strong>偏向锁</strong>：如果只有一个线程访问锁，JVM 会将锁偏向该线程，避免重复的同步操作。</li>
<li><strong>轻量级锁</strong>：当多个线程竞争锁时，JVM 会将锁升级为轻量级锁，使用 CAS 操作来竞争锁。</li>
<li><strong>重量级锁</strong>：当竞争激烈时，JVM 会将锁升级为重量级锁，线程会进入阻塞状态，等待锁的释放。</li>
</ul>
<p><strong>锁升级流程：</strong></p>
<ol>
<li><strong>无锁 → 偏向锁</strong>：第一次访问 <code>synchronized</code> 代码块时，给对象打上偏向标记。通过 CAS 操作将线程 ID 记录在对象头中。</li>
<li><strong>偏向锁 → 轻量级锁</strong>：如果<strong>其他线程尝试获取锁</strong>，撤销偏向锁，升级为轻量级锁。使用 CAS 操作竞争锁。</li>
<li><strong>轻量级锁 → 重量级锁</strong>：如果<strong>多个线程竞争失败</strong>，则<strong>进入阻塞队列</strong>，升级为重量级锁。线程会进入阻塞状态，等待锁的释放。</li>
</ol>
</li>
<li><p>几个关键队列：</p>
<table>
<thead>
<tr>
<th><strong>名称</strong></th>
<th><strong>作用</strong></th>
</tr>
</thead>
<tbody><tr>
<td><strong>ContentionList（竞争队列）</strong></td>
<td><strong>竞争锁的线程队列</strong>（自旋线程会加入）所有请求锁的线程会首先进入 ContentionList。这是一个虚拟队列，线程会通过 CAS 操作自旋竞争锁。</td>
</tr>
<tr>
<td><strong>EntryList（候选队列）</strong></td>
<td><strong>有资格的候选者队列</strong>（轻量级锁竞争失败，进入 EntryList）当锁被释放时，JVM 会从 ContentionList 中选择一些线程进入 EntryList。EntryList 中的线程有资格竞争锁。</td>
</tr>
<tr>
<td><strong>WaitSet（等待队列）</strong></td>
<td><strong>调用 <code>wait()</code> 进入的阻塞队列</strong>（必须 <code>notify()</code> 唤醒）当线程调用 <code>wait()</code> 方法时，会释放锁并进入 WaitSet。当其他线程调用 <code>notify()</code> 或 <code>notifyAll()</code> 时，WaitSet 中的线程会被唤醒并重新进入 EntryList。</td>
</tr>
<tr>
<td><strong>onDeck（竞争候选者）</strong></td>
<td><strong>当前的竞争候选者</strong>；从 EntryList 中选择一个线程作为竞争候选者（OnDeck）。OnDeck 线程会尝试获取锁。</td>
</tr>
<tr>
<td><strong>owner（锁持有者）</strong></td>
<td><strong>当前持有锁的线程</strong>；成功获取锁的线程成为 Owner。Owner 线程执行完同步代码块后，会释放锁并唤醒其他线程。</td>
</tr>
<tr>
<td><strong>!owner</strong></td>
<td><strong>锁已释放，等待 <code>onDeck</code> 线程竞争</strong></td>
</tr>
</tbody></table>
</li>
<li><p>synchronized的非公平性：</p>
<ul>
<li><strong>自旋抢占</strong>：<ul>
<li>新请求锁的线程会先尝试自旋获取锁，如果成功则直接抢占锁。</li>
<li>这会导致已经在 ContentionList 中等待的线程无法公平地获取锁。</li>
</ul>
</li>
<li><strong>直接抢占</strong>：<ul>
<li>自旋获取锁的线程可能会直接抢占 OnDeck 线程的锁资源。</li>
</ul>
</li>
</ul>
</li>
<li></li>
</ol>
<p><a target="_blank" rel="noopener" href="https://callmejiagu.github.io/2019/01/03/%E5%A4%9A%E7%BA%BF%E7%A8%8B%E5%B9%B6%E5%8F%91-%E4%B9%8B-synchronized-%E9%94%81%E7%9A%84%E4%BC%98%E5%8C%96/">多线程并发 之 synchronized 锁的优化</a></p>
<h4 id="问：synchronized-在静态方法和普通方法的区别？"><a href="#问：synchronized-在静态方法和普通方法的区别？" class="headerlink" title="问：synchronized 在静态方法和普通方法的区别？"></a>问：synchronized 在静态方法和普通方法的区别？</h4><p><strong>1. 锁对象的区别</strong></p>
<table>
<thead>
<tr>
<th><strong>修饰方法类型</strong></th>
<th><strong>锁对象</strong></th>
<th><strong>影响范围</strong></th>
</tr>
</thead>
<tbody><tr>
<td>普通方法（实例方法）</td>
<td>当前实例 (<code>this</code>)</td>
<td>同一个实例对象</td>
</tr>
<tr>
<td>静态方法（类方法）</td>
<td>当前类对象 (<code>Class&lt;?&gt;</code>)</td>
<td>整个类（包括所有实例）</td>
</tr>
</tbody></table>
<p>示例代码：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Example</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 锁的是当前实例对象</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">instanceMethod</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;实例方法执行&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 锁的是类对象</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">staticMethod</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;静态方法执行&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>2. 多线程环境下的锁行为</strong></p>
<p><strong>普通方法（实例方法）示例：</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Example obj1 = <span class="keyword">new</span> Example();</span><br><span class="line">Example obj2 = <span class="keyword">new</span> Example();</span><br><span class="line"></span><br><span class="line"><span class="keyword">new</span> Thread(() -&gt; obj1.instanceMethod()).start();  <span class="comment">// 锁 obj1</span></span><br><span class="line"><span class="keyword">new</span> Thread(() -&gt; obj2.instanceMethod()).start();  <span class="comment">// 锁 obj2</span></span><br></pre></td></tr></table></figure>

<p><strong>解释：</strong></p>
<ul>
<li>两个线程锁定不同实例 <code>obj1</code> 和 <code>obj2</code>，因此不会互相阻塞。</li>
</ul>
<p><strong>静态方法（类方法）示例：</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Example obj1 = <span class="keyword">new</span> Example();</span><br><span class="line">Example obj2 = <span class="keyword">new</span> Example();</span><br><span class="line"></span><br><span class="line"><span class="keyword">new</span> Thread(() -&gt; obj1.staticMethod()).start();  <span class="comment">// 锁 Example.class</span></span><br><span class="line"><span class="keyword">new</span> Thread(() -&gt; obj2.staticMethod()).start();  <span class="comment">// 仍锁 Example.class</span></span><br></pre></td></tr></table></figure>

<p><strong>解释：</strong></p>
<ul>
<li>不论通过哪个实例调用静态方法，锁的都是类对象 <code>Example.class</code>，两个线程会互相阻塞。</li>
</ul>
<p><strong>3. 并发控制的应用场景</strong></p>
<p><strong>普通方法的应用场景：</strong></p>
<p>适用于对 <strong>实例级别资源</strong> 的同步，如处理某个对象的属性。</p>
<p><strong>静态方法的应用场景：</strong></p>
<p>适用于对 <strong>类级别资源</strong> 的同步，如全局缓存、配置信息等。</p>
<p><strong>4. 示例对比演示</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Demo</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">instanceMethod</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(Thread.currentThread().getName() + <span class="string">&quot; - 实例方法开始&quot;</span>);</span><br><span class="line">        <span class="keyword">try</span> &#123; Thread.sleep(<span class="number">1000</span>); &#125; <span class="keyword">catch</span> (InterruptedException e) &#123; &#125;</span><br><span class="line">        System.out.println(Thread.currentThread().getName() + <span class="string">&quot; - 实例方法结束&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">staticMethod</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(Thread.currentThread().getName() + <span class="string">&quot; - 静态方法开始&quot;</span>);</span><br><span class="line">        <span class="keyword">try</span> &#123; Thread.sleep(<span class="number">1000</span>); &#125; <span class="keyword">catch</span> (InterruptedException e) &#123; &#125;</span><br><span class="line">        System.out.println(Thread.currentThread().getName() + <span class="string">&quot; - 静态方法结束&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Main</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Demo obj1 = <span class="keyword">new</span> Demo();</span><br><span class="line">        Demo obj2 = <span class="keyword">new</span> Demo();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">new</span> Thread(() -&gt; obj1.instanceMethod(), <span class="string">&quot;线程1&quot;</span>).start();</span><br><span class="line">        <span class="keyword">new</span> Thread(() -&gt; obj2.instanceMethod(), <span class="string">&quot;线程2&quot;</span>).start();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">new</span> Thread(() -&gt; Demo.staticMethod(), <span class="string">&quot;线程3&quot;</span>).start();</span><br><span class="line">        <span class="keyword">new</span> Thread(() -&gt; Demo.staticMethod(), <span class="string">&quot;线程4&quot;</span>).start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>5. 结论</strong></p>
<table>
<thead>
<tr>
<th><strong>比较点</strong></th>
<th><strong>普通方法 (<code>synchronized</code>)</strong></th>
<th><strong>静态方法 (<code>synchronized</code>)</strong></th>
</tr>
</thead>
<tbody><tr>
<td>锁的范围</td>
<td>当前实例对象 <code>this</code></td>
<td>当前类对象 <code>Class&lt;?&gt;</code></td>
</tr>
<tr>
<td>多实例的执行关系</td>
<td>不互相影响</td>
<td>互相阻塞</td>
</tr>
<tr>
<td>同一实例的多线程</td>
<td>互斥</td>
<td>互斥</td>
</tr>
<tr>
<td>使用场景</td>
<td>实例级别资源同步</td>
<td>类级别资源同步</td>
</tr>
</tbody></table>
<hr>
<p>通过选择合适的锁类型，可以有效地控制线程间的同步，避免资源竞争和数据不一致问题。</p>
<h4 id="问：synchronized-和-ReentranLock的区别？⭐⭐"><a href="#问：synchronized-和-ReentranLock的区别？⭐⭐" class="headerlink" title="问：synchronized 和 ReentranLock的区别？⭐⭐"></a>问：synchronized 和 ReentranLock的区别？⭐⭐</h4><blockquote>
<ul>
<li>都是可重入锁； R是显示获取和释放锁，s是隐式；</li>
<li>R更灵活可以知道有没有成功获取锁，可以定义读写锁，是api级别，s是JVM级别；</li>
<li>R可以定义公平锁；Lock是接口，s是java中的关键字</li>
</ul>
</blockquote>
<p><strong><code>synchronized</code></strong> 是 <strong>JVM 层面的关键字</strong>，基于 <code>Monitor</code>。</p>
<p><strong><code>Lock</code></strong> 是 <strong>JDK 提供的类</strong>，基于 <code>AQS</code>，更灵活。</p>
<p><code>synchronized</code> <strong>非公平</strong>，<code>ReentrantLock</code> <strong>支持公平锁</strong>。</p>
<p><code>Lock</code> <strong>支持 <code>tryLock()</code> 超时获取锁</strong>，<strong>可中断</strong>。</p>
<p><strong><code>ReentrantLock</code> 为什么比 <code>synchronized</code> 性能更好？</strong></p>
<p>✅ <strong>回答要点：</strong></p>
<ul>
<li><strong><code>synchronized</code> 依赖 JVM <code>monitor</code>，线程阻塞时依赖 OS 调度</strong>（重量级锁）。</li>
<li><strong><code>ReentrantLock</code> 通过 CAS 和 AQS 进行高效排队</strong>，避免线程频繁挂起 / 唤醒。</li>
</ul>
<table>
<thead>
<tr>
<th><strong>对比项</strong></th>
<th><strong>synchronized</strong></th>
<th><strong>ReentrantLock</strong></th>
</tr>
</thead>
<tbody><tr>
<td><strong>实现原理</strong></td>
<td><strong>基于对象 <code>Monitor</code></strong></td>
<td><strong>基于 <code>AbstractQueuedSynchronizer (AQS)</code></strong></td>
</tr>
<tr>
<td><strong>锁类型</strong></td>
<td><strong>非公平锁</strong></td>
<td><strong>支持公平 &amp; 非公平</strong></td>
</tr>
<tr>
<td><strong>锁状态</strong></td>
<td><strong>支持锁升级</strong></td>
<td><strong>独占锁 / 共享锁</strong></td>
</tr>
<tr>
<td><strong>阻塞方式</strong></td>
<td><strong>依赖 OS 线程调度</strong></td>
<td><strong>CAS + AQS 队列管理</strong></td>
</tr>
<tr>
<td><strong>可中断性</strong></td>
<td><strong>不可中断</strong></td>
<td><strong>支持 <code>lockInterruptibly()</code></strong></td>
</tr>
<tr>
<td><strong><code>tryLock()</code></strong></td>
<td><strong>不支持</strong></td>
<td><strong>支持 <code>tryLock()</code> 超时获取</strong></td>
</tr>
<tr>
<td><strong>条件等待</strong></td>
<td><code>Object.wait()</code>、<code>notify()</code>、<code>notifyAll()</code> 实现条件等待</td>
<td>使用 <code>Condition</code> 对象，可以绑定多个条件</td>
</tr>
<tr>
<td><strong>适用场景</strong></td>
<td><strong>同步代码块，简单场景</strong></td>
<td><strong>高并发 + 灵活锁控制</strong></td>
</tr>
</tbody></table>
<h4 id="问：HashTable，同步锁，synchronized-关键字-1-6-之后提升了什么，怎么提升的这些？"><a href="#问：HashTable，同步锁，synchronized-关键字-1-6-之后提升了什么，怎么提升的这些？" class="headerlink" title="问：HashTable，同步锁，synchronized 关键字 1.6 之后提升了什么，怎么提升的这些？"></a>问：HashTable，同步锁，synchronized 关键字 1.6 之后提升了什么，怎么提升的这些？</h4><p><strong>1. <code>Hashtable</code> 中的同步机制</strong></p>
<ul>
<li><code>Hashtable</code> 是线程安全的，它通过 <code>synchronized</code> 关键字对方法进行加锁，保证多线程环境下的数据一致性。</li>
<li>示例：</li>
</ul>
<figure class="highlight processing"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">javaCopy codepublic <span class="keyword">synchronized</span> V <span class="built_in">get</span>(<span class="keyword">Object</span> <span class="built_in">key</span>) &#123;</span><br><span class="line">    <span class="comment">// 加锁，确保线程安全</span></span><br><span class="line">    Entry&lt;?,?&gt; tab[] = table;</span><br><span class="line">    <span class="built_in">int</span> hash = <span class="built_in">key</span>.hashCode();</span><br><span class="line">    <span class="keyword">for</span> (Entry&lt;?,?&gt; e = tab[(hash &amp; <span class="number">0x7FFFFFFF</span>) % tab.length]; e != <span class="keyword">null</span>; e = e.next) &#123;</span><br><span class="line">        <span class="keyword">if</span> ((e.hash == hash) &amp;&amp; e.<span class="built_in">key</span>.equals(<span class="built_in">key</span>)) &#123;</span><br><span class="line">            <span class="keyword">return</span> (V)e.value;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>问题：<code>Hashtable</code> 的同步性能瓶颈</strong></p>
<ul>
<li>每个方法都使用 <code>synchronized</code>，锁粒度大，竞争激烈时性能下降。</li>
<li>锁的范围涵盖了整个对象，导致线程争用严重。</li>
</ul>
<p><strong>2. <code>synchronized</code> 在 Java 1.6 之后的优化</strong></p>
<p>Java 1.6 对 <code>synchronized</code> 进行了多项优化，提升了其性能，以下是主要的改进：</p>
<p><strong>(1) 偏向锁 (Biased Locking)</strong></p>
<ul>
<li><strong>作用：</strong> 消除不必要的加锁操作，优化无竞争场景。</li>
<li><strong>机制：</strong> 当一个线程第一次获取锁时，JVM 将锁标记为“偏向该线程”。若该线程再次获取锁，无需进行同步操作。</li>
<li><strong>适用场景：</strong> 只有一个线程访问同步块时，性能大幅提升。</li>
</ul>
<p><strong>(2) 轻量级锁 (Lightweight Locking)</strong></p>
<ul>
<li><strong>作用：</strong> 在竞争不激烈时，减少加锁和解锁的开销。</li>
<li><strong>机制：</strong> 在锁对象的对象头中保存锁信息，通过 CAS 操作尝试获取锁，失败时升级为重量级锁。</li>
<li><strong>适用场景：</strong> 少量线程争用时。</li>
</ul>
<p><strong>(3) 自旋锁 (Spin Lock)</strong></p>
<ul>
<li><strong>作用：</strong> 避免线程在锁争用时频繁挂起与恢复。</li>
<li><strong>机制：</strong> 在锁被占用时，线程进行有限次数的忙等待，而不是直接进入阻塞状态。</li>
<li><strong>适用场景：</strong> 锁竞争时间短时，减少线程切换开销。</li>
</ul>
<p><strong>(4) 锁消除 (Lock Elimination)</strong></p>
<ul>
<li><strong>作用：</strong> 在编译期间，JVM 自动消除不必要的锁。</li>
<li><strong>机制：</strong> JVM 使用逃逸分析，判断对象的作用域，如果发现对象不会被其他线程访问，自动移除 <code>synchronized</code> 锁。</li>
<li><strong>适用场景：</strong> 局部对象只在当前线程使用时。</li>
</ul>
<p><strong>(5) 锁粗化 (Lock Coarsening)</strong></p>
<ul>
<li><strong>作用：</strong> 降低频繁加锁与解锁的开销。</li>
<li><strong>机制：</strong> JVM 自动扩大锁的作用范围，将多个连续的同步块合并，减少锁的获取与释放次数。</li>
<li><strong>适用场景：</strong> 多个连续的同步操作对同一对象进行加锁。</li>
</ul>
<p><strong>(6) 重量级锁 (Heavyweight Locking)</strong></p>
<ul>
<li><strong>作用：</strong> 在锁竞争激烈时，升级为重量级锁。</li>
<li><strong>机制：</strong> 使用操作系统的 <code>Monitor</code> 对象，线程直接阻塞，等待唤醒。</li>
</ul>
<p><strong>优化示例：对比前后性能</strong></p>
<p><strong>未优化前：</strong></p>
<figure class="highlight oxygene"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">javaCopy codepublic synchronized void <span class="function"><span class="keyword">method</span><span class="params">()</span> <span class="comment">&#123;</span></span></span><br><span class="line"><span class="comment"><span class="function">    System.out.println(&quot;同步方法执行...&quot;);</span></span></span><br><span class="line"><span class="comment"><span class="function">&#125;</span></span></span><br></pre></td></tr></table></figure>

<p><strong>优化后：</strong></p>
<figure class="highlight oxygene"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">javaCopy codepublic void <span class="function"><span class="keyword">method</span><span class="params">()</span> <span class="comment">&#123;</span></span></span><br><span class="line"><span class="comment"><span class="function">    synchronized(this) &#123;</span></span></span><br><span class="line"><span class="comment"><span class="function">        System.out.println(&quot;同步代码块执行...&quot;);</span></span></span><br><span class="line"><span class="comment"><span class="function">    &#125;</span></span></span><br><span class="line"><span class="function">&#125;</span></span><br></pre></td></tr></table></figure>

<p><strong>3. <code>Hashtable</code> 的替代方案：<code>ConcurrentHashMap</code></strong></p>
<ul>
<li><p>为了提高性能，Java 提供了 </p>
<figure class="highlight ebnf"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="attribute">ConcurrentHashMap</span></span><br></pre></td></tr></table></figure>

<p>，它采用 </p>
<p>分段锁（Segmented Lock）</p>
<p> 技术，提升了并发性能：</p>
<ul>
<li>分为多个段，每个段有独立的锁，减少锁竞争。</li>
<li>采用非阻塞算法，如 CAS，进一步优化。</li>
</ul>
</li>
</ul>
<p><strong>4. 结论：提升的核心要点</strong></p>
<ul>
<li><strong>锁优化概述：</strong> 偏向锁 → 轻量级锁 → 自旋锁 → 重量级锁（逐步升级，减少锁开销）。</li>
<li>性能改进原因：<ul>
<li>锁竞争减少</li>
<li>加锁解锁操作优化</li>
<li>使用更高效的数据结构与算法（如 CAS）。</li>
</ul>
</li>
</ul>
<p>这些改进使 <code>synchronized</code> 的性能在 Java 1.6 及其之后版本得到了显著提升，减少了早期 Java 版本中对 <code>ReentrantLock</code> 的强依赖。</p>
<hr>
<h3 id="2-4-Lock"><a href="#2-4-Lock" class="headerlink" title="2.4 Lock"></a>2.4 Lock</h3><h4 id="问：Lock-接口有哪些实现类，使用场景是什么？"><a href="#问：Lock-接口有哪些实现类，使用场景是什么？" class="headerlink" title="问：Lock 接口有哪些实现类，使用场景是什么？"></a>问：Lock 接口有哪些实现类，使用场景是什么？</h4><p><code>Lock</code> 接口是 Java 并发框架中用于实现线程同步的核心接口，提供了更灵活的锁机制。以下是常见的 <code>Lock</code> 实现类及其适用场景：</p>
<p><strong>1. <code>ReentrantLock</code> (重入锁)</strong></p>
<p><strong>特性：</strong></p>
<ul>
<li>可重入：线程可以多次获取同一个锁。</li>
<li>支持公平锁和非公平锁（默认）。</li>
<li>提供条件变量 (<code>Condition</code>)。</li>
<li>支持中断和尝试获取锁 (<code>tryLock</code>)。</li>
</ul>
<p><strong>适用场景：</strong></p>
<ul>
<li>锁需要显式控制的场景。</li>
<li>高度竞争的资源共享，确保公平性。</li>
<li>需要精确控制锁释放与获取的顺序。</li>
</ul>
<p><strong>示例：</strong></p>
<figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">javaCopy codeimport java.util.concurrent.locks.ReentrantLock;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">ReentrantLockExample</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> final ReentrantLock <span class="keyword">lock</span> = <span class="keyword">new</span> ReentrantLock();</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">safeMethod</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">        <span class="keyword">lock</span>.<span class="keyword">lock</span>();</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            System.<span class="keyword">out</span>.println(Thread.currentThread().getName() + <span class="string">&quot; 正在执行任务&quot;</span>);</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            <span class="keyword">lock</span>.unlock();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>2. <code>ReentrantReadWriteLock</code> (读写锁)</strong></p>
<p><strong>特性：</strong></p>
<ul>
<li>支持多个读线程并发，写线程独占。</li>
<li>提供两种锁：<ul>
<li><code>ReadLock</code>（读锁）：共享锁，多个线程可同时读。</li>
<li><code>WriteLock</code>（写锁）：独占锁，只有一个线程可写。</li>
</ul>
</li>
</ul>
<p><strong>适用场景：</strong></p>
<ul>
<li>读多写少的场景，例如缓存、配置信息读取。</li>
</ul>
<p><strong>示例：</strong></p>
<figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">javaCopy codeimport java.util.concurrent.locks.ReentrantReadWriteLock;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">ReadWriteLockExample</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> final ReentrantReadWriteLock <span class="keyword">lock</span> = <span class="keyword">new</span> ReentrantReadWriteLock();</span><br><span class="line">    <span class="keyword">private</span> <span class="built_in">int</span> data;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">readData</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">        <span class="keyword">lock</span>.readLock().<span class="keyword">lock</span>();</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            System.<span class="keyword">out</span>.println(<span class="string">&quot;读取数据：&quot;</span> + data);</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            <span class="keyword">lock</span>.readLock().unlock();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">writeData</span>(<span class="params"><span class="built_in">int</span> newData</span>)</span> &#123;</span><br><span class="line">        <span class="keyword">lock</span>.writeLock().<span class="keyword">lock</span>();</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            data = newData;</span><br><span class="line">            System.<span class="keyword">out</span>.println(<span class="string">&quot;写入数据：&quot;</span> + data);</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            <span class="keyword">lock</span>.writeLock().unlock();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>3. <code>StampedLock</code> (标记锁)</strong></p>
<p><strong>特性：</strong></p>
<ul>
<li>提供三种锁模式：<ul>
<li>写锁（独占）</li>
<li>悲观读锁（共享）</li>
<li>乐观读锁（无锁）</li>
</ul>
</li>
</ul>
<p><strong>适用场景：</strong></p>
<ul>
<li>高并发下，读操作远多于写操作，且读操作允许一定程度的数据不一致。</li>
</ul>
<p><strong>示例：</strong></p>
<figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">javaCopy codeimport java.util.concurrent.locks.StampedLock;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">StampedLockExample</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> final StampedLock <span class="keyword">lock</span> = <span class="keyword">new</span> StampedLock();</span><br><span class="line">    <span class="keyword">private</span> <span class="built_in">int</span> <span class="keyword">value</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="built_in">int</span> <span class="title">optimisticRead</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">        <span class="built_in">long</span> stamp = <span class="keyword">lock</span>.tryOptimisticRead();</span><br><span class="line">        <span class="built_in">int</span> result = <span class="keyword">value</span>;</span><br><span class="line">        <span class="keyword">if</span> (!<span class="keyword">lock</span>.validate(stamp)) &#123;</span><br><span class="line">            stamp = <span class="keyword">lock</span>.readLock();</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                result = <span class="keyword">value</span>;</span><br><span class="line">            &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">                <span class="keyword">lock</span>.unlockRead(stamp);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">writeValue</span>(<span class="params"><span class="built_in">int</span> newValue</span>)</span> &#123;</span><br><span class="line">        <span class="built_in">long</span> stamp = <span class="keyword">lock</span>.writeLock();</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">value</span> = newValue;</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            <span class="keyword">lock</span>.unlockWrite(stamp);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>4. <code>Condition</code> (条件锁)</strong></p>
<p><strong>特性：</strong></p>
<ul>
<li>与 <code>ReentrantLock</code> 一起使用。</li>
<li>提供类似 <code>Object.wait()</code> 和 <code>Object.notify()</code> 的功能。</li>
<li>支持精确的等待和唤醒机制。</li>
</ul>
<p><strong>适用场景：</strong></p>
<ul>
<li>需要多个条件变量时。</li>
<li>复杂的等待与唤醒逻辑，例如生产者-消费者模型。</li>
</ul>
<p><strong>示例：</strong></p>
<figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line">javaCopy codeimport java.util.concurrent.locks.Condition;</span><br><span class="line">import java.util.concurrent.locks.ReentrantLock;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">ConditionExample</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> final ReentrantLock <span class="keyword">lock</span> = <span class="keyword">new</span> ReentrantLock();</span><br><span class="line">    <span class="keyword">private</span> final Condition condition = <span class="keyword">lock</span>.newCondition();</span><br><span class="line">    <span class="keyword">private</span> boolean ready = <span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">produce</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">        <span class="keyword">lock</span>.<span class="keyword">lock</span>();</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            ready = <span class="literal">true</span>;</span><br><span class="line">            System.<span class="keyword">out</span>.println(<span class="string">&quot;生产完成，通知消费者&quot;</span>);</span><br><span class="line">            condition.signal();</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            <span class="keyword">lock</span>.unlock();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">consume</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">        <span class="keyword">lock</span>.<span class="keyword">lock</span>();</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">while</span> (!ready) &#123;</span><br><span class="line">                System.<span class="keyword">out</span>.println(<span class="string">&quot;等待生产...&quot;</span>);</span><br><span class="line">                condition.<span class="keyword">await</span>();</span><br><span class="line">            &#125;</span><br><span class="line">            System.<span class="keyword">out</span>.println(<span class="string">&quot;消费完成&quot;</span>);</span><br><span class="line">            ready = <span class="literal">false</span>;</span><br><span class="line">        &#125; catch (InterruptedException e) &#123;</span><br><span class="line">            Thread.currentThread().interrupt();</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            <span class="keyword">lock</span>.unlock();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>选择指南：何时使用哪种锁？</strong></p>
<table>
<thead>
<tr>
<th><strong>实现类</strong></th>
<th><strong>适用场景</strong></th>
<th><strong>关键特性</strong></th>
</tr>
</thead>
<tbody><tr>
<td><code>ReentrantLock</code></td>
<td>精确控制锁操作、需要条件变量</td>
<td>可重入、公平/非公平锁</td>
</tr>
<tr>
<td><code>ReentrantReadWriteLock</code></td>
<td>读多写少、缓存、配置管理</td>
<td>独占写锁，共享读锁</td>
</tr>
<tr>
<td><code>StampedLock</code></td>
<td>读操作远多于写操作，数据一致性可放宽</td>
<td>乐观读，悲观读，写锁</td>
</tr>
<tr>
<td><code>Condition</code></td>
<td>复杂的等待与唤醒，精确通知</td>
<td>与 <code>ReentrantLock</code> 配合使用</td>
</tr>
</tbody></table>
<p><strong>总结：选择锁的原则</strong></p>
<ol>
<li><strong>高并发读多写少场景：</strong> 使用 <code>ReentrantReadWriteLock</code> 或 <code>StampedLock</code>。</li>
<li><strong>精确控制锁释放和获取：</strong> 使用 <code>ReentrantLock</code>。</li>
<li><strong>等待与唤醒机制：</strong> 使用 <code>Condition</code>。</li>
<li><strong>性能与灵活性兼顾：</strong> 优先考虑 <code>StampedLock</code>，对乐观读的支持性能更好。</li>
</ol>
<p>根据实际需求选择合适的锁实现，可以在并发编程中有效提高程序的性能和可扩展性。</p>
<h4 id="问：讲讲ReentrantLock实现原理？⭐⭐⭐"><a href="#问：讲讲ReentrantLock实现原理？⭐⭐⭐" class="headerlink" title="问：讲讲ReentrantLock实现原理？⭐⭐⭐"></a>问：讲讲ReentrantLock实现原理？⭐⭐⭐</h4><p>ReentrantLock原理：</p>
<ol>
<li><p>基于 <strong>CAS（Compare-And-Swap）</strong> 和 <strong>AQS（AbstractQueuedSynchronizer）</strong> 来实现锁的获取和释放。</p>
<ul>
<li><p>CAS 是一种原子操作，用于实现无锁的线程安全操作。在 <code>ReentrantLock</code> 中，CAS 用于尝试获取锁的状态（如将锁的状态从 0 改为 1）。</p>
</li>
<li><p><strong>CAS 只能保证单次加锁</strong>，但如果失败，需要<strong>排队等待</strong>，当有多个线程争用同一把锁时，必须有类似<strong>排队的机制</strong>去将那些没能拿到锁的线程串联在一起，避免一直自旋浪费CPU。这就是 <code>AQS</code> 的作用。</p>
</li>
<li><p><strong>AQS 抽象队列同步器</strong> 是一个用于构建锁和同步器的框架。维护了一个 <strong>FIFO 队列</strong>（CLH 队列），用于管理等待锁的线程。通过 <strong><code>state</code> 变量 + CAS 机制</strong> 来管理锁状态。通过 <strong><code>CLH</code>（双向链表）队列</strong> 让线程排队等待锁。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// AQS的关键成员</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">volatile</span> <span class="keyword">int</span> state;      <span class="comment">// 0：未加锁，&gt;0：加锁状态（重入次数）</span></span><br><span class="line"><span class="keyword">private</span> Thread exclusiveOwnerThread;  <span class="comment">// 当前持有锁的线程</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">transient</span> Queue&lt;Node&gt; waitQueue; <span class="comment">// CLH队列</span></span><br></pre></td></tr></table></figure>

<p><strong>锁是面向使用者，其定义了使用者和锁交互的接口，隐藏了实现细节</strong>；<strong>同步器则面向锁的实现者，它简化了锁的实现方式，屏蔽了同步状态管理、线程的排队、等待与唤醒等底层操作</strong>。</p>
</li>
</ul>
</li>
<li><p>基础操作：</p>
<ul>
<li><strong>AQS 的状态</strong>：AQS 使用一个 <code>volatile</code> 的 <code>int</code> 变量（<code>state</code>）来表示锁的状态，通过CAS操作来设置状态：<ul>
<li><code>state = 0</code>：锁未被占用。</li>
<li><code>state &gt; 0</code>：锁被占用，<code>state</code> 的值表示锁的重入次数。</li>
<li><code>compareAndSetState(int expect,int update)</code> </li>
</ul>
</li>
</ul>
<ul>
<li><p><strong>AQS 的队列</strong>：</p>
<ul>
<li><p>AQS 维护了一个<strong>双向链表</strong>（CLH 队列），用于存储等待锁的线程。</p>
</li>
<li><p>每个节点（Node）包含线程的引用和状态信息。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">Node</span> </span>&#123;</span><br><span class="line">    <span class="keyword">volatile</span> <span class="keyword">int</span> waitStatus;  <span class="comment">// -1 表示需要唤醒，0 表示正常</span></span><br><span class="line">    <span class="keyword">volatile</span> Node prev;       <span class="comment">// 前驱节点</span></span><br><span class="line">    <span class="keyword">volatile</span> Node next;       <span class="comment">// 后继节点</span></span><br><span class="line">    <span class="keyword">volatile</span> Thread thread;   <span class="comment">// 当前等待的线程</span></span><br><span class="line">&#125;</span><br><span class="line">HEAD -&gt; 线程 A -&gt; 线程 B -&gt; 线程 C -&gt; ...</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">transient</span> <span class="keyword">volatile</span> Node head;  <span class="comment">// 队头线程将优先获得锁</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">transient</span> <span class="keyword">volatile</span> Node tail;  <span class="comment">// 抢锁失败的线程追加到队尾</span></span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure></li>
<li><p>首节点是获取同步状态成功的节点，首节点的线程在释放同步状态时，将会唤醒后继节点。</p>
</li>
<li><p>设置首节点是通过获取同步状态成功的线程来完成的，<strong>由于只有一个线程能够成功获取到同步状态，因此设置头节点的方法并不需要使用CAS来保证</strong></p>
</li>
<li><p><strong>基于CAS的设置尾节点的方法</strong>：<code>compareAndSetTail(Node expect, Node update)</code></p>
</li>
<li><p><strong>在获取同步状态时，同步器维护一个同步队列，获取状态失败的线程都会被加入到队列中并在队列中进行短暂自旋+阻塞（前驱节点非头节点）；移出队列的条件是前驱节点为头节点且成功获取了同步状态。在释放同步状态时，同步器调用 <code>tryRelease(int arg)</code> 方法释放同步状态，然后唤醒头节点的后继节点。</strong></p>
</li>
</ul>
</li>
<li><p>AQS方法：</p>
<ul>
<li><p>acquire(int arg)：线程<strong>获取独占锁</strong>，获取失败就进入 <code>AQS</code> 队列。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title">acquire</span><span class="params">(<span class="keyword">int</span> arg)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 调用自定义同步器实现的 `tryAcquire(int arg)` 方法，该方法保证线程安全的获取同步状态</span></span><br><span class="line">    <span class="keyword">if</span> (!tryAcquire(arg) &amp;&amp;</span><br><span class="line">        <span class="comment">// 如果同步状态获取失败，则构造同步节点（独占式 `Node.EXCLUSIVE` ，同一时刻只能有一个线程成功获取同步状态）并通过 `addWaiter(Node node)` 方法将该节点加入到同步队列的尾部。</span></span><br><span class="line">        acquireQueued(addWaiter(Node.EXCLUSIVE), arg))</span><br><span class="line">        <span class="comment">// 最后调用 `acquireQueued(Node node,int arg)` 方法，使得该节点以“死循环”的方式获取同步状态。如果获取不到则阻塞节点中的线程，而被阻塞线程的唤醒主要依靠前驱节点的出队或阻塞线程被中断来实现。</span></span><br><span class="line">        selfInterrupt();</span><br><span class="line">&#125;</span><br><span class="line">       </span><br><span class="line"><span class="function"><span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">acquireQueued</span><span class="params">(<span class="keyword">final</span> Node node, <span class="keyword">int</span> arg)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">boolean</span> failed = <span class="keyword">true</span>;<span class="comment">//标识是否失败</span></span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="keyword">boolean</span> interrupted = <span class="keyword">false</span>;</span><br><span class="line">        <span class="keyword">for</span> (;;) &#123;<span class="comment">//循环获取同步状态</span></span><br><span class="line">            <span class="keyword">final</span> Node p = node.predecessor();<span class="comment">//获取前驱节点</span></span><br><span class="line">            <span class="keyword">if</span> (p == head &amp;&amp; tryAcquire(arg)) &#123;<span class="comment">//当前驱节点为头节点时尝试获取同步状态</span></span><br><span class="line">                <span class="comment">//得到同步状态</span></span><br><span class="line">                setHead(node);<span class="comment">//设置此节点为头节点</span></span><br><span class="line">                p.next = <span class="keyword">null</span>; <span class="comment">// help GC</span></span><br><span class="line">                failed = <span class="keyword">false</span>;<span class="comment">//标识操作成功</span></span><br><span class="line">                <span class="keyword">return</span> interrupted;<span class="comment">//未中断返回</span></span><br><span class="line">            &#125;</span><br><span class="line">        <span class="comment">// 🚀 前驱节点不是 head，进入阻塞状态 LockSupport.park(this);</span></span><br><span class="line">            <span class="keyword">if</span> (shouldParkAfterFailedAcquire(p, node) &amp;&amp;</span><br><span class="line">                parkAndCheckInterrupt())</span><br><span class="line">                interrupted = <span class="keyword">true</span>;<span class="comment">//中断</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (failed)</span><br><span class="line">            cancelAcquire(node);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li><p>release(int arg)：<strong>释放锁</strong>，并唤醒下一个等待线程。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">release</span><span class="params">(<span class="keyword">int</span> arg)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (tryRelease(arg)) &#123;</span><br><span class="line">        <span class="comment">// 当前头结点线程</span></span><br><span class="line">        Node h = head;</span><br><span class="line">        <span class="keyword">if</span> (h != <span class="keyword">null</span> &amp;&amp; h.waitStatus != <span class="number">0</span>)</span><br><span class="line">            unparkSuccessor(h);<span class="comment">//唤醒等待状态的头结点线程</span></span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li><p>tryAcquire(int arg)：<strong>独占模式，尝试获取锁</strong>（子类实现）</p>
</li>
<li><p>tryRelease(int arg)：<strong>独占模式，释放锁</strong>（子类实现）</p>
</li>
<li><p>acquireShared(int arg)：共享模式，尝试获取共享锁</p>
</li>
<li><p>releaseShared(int arg)：共享模式，释放共享锁</p>
</li>
</ul>
</li>
<li></li>
</ul>
<p><strong>锁的获取与释放</strong></p>
<ul>
<li><strong>获取锁</strong>：<ul>
<li>线程通过 CAS 操作尝试将 <code>state</code> 从 0 改为 1。</li>
<li>如果失败，则加入 AQS 队列并挂起。</li>
</ul>
</li>
<li><strong>释放锁</strong>：<ul>
<li>线程通过 CAS 操作将 <code>state</code> 减 1。</li>
<li>如果 <code>state</code> 变为 0，则唤醒队首的线程。</li>
</ul>
</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">lock() &#123;</span><br><span class="line">    <span class="keyword">if</span> (CAS(state, <span class="number">0</span>, <span class="number">1</span>)) &#123; <span class="comment">// 🚀 CAS 尝试加锁</span></span><br><span class="line">        setOwner(Thread.currentThread());</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    enterAQSQueue(); <span class="comment">// 🚀 失败就进 AQS 队列</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<table>
<thead>
<tr>
<th><strong>步骤</strong></th>
<th><strong>描述</strong></th>
</tr>
</thead>
<tbody><tr>
<td><strong>① CAS 竞争锁</strong></td>
<td>通过 <code>compareAndSwap</code> 直接尝试修改 <code>state=1</code></td>
</tr>
<tr>
<td><strong>② 竞争失败入队</strong></td>
<td>线程进入 <code>AQS</code> 的 <code>CLH</code> 队列</td>
</tr>
<tr>
<td><strong>③ 线程阻塞</strong></td>
<td>**当前线程进入 <code>park()</code>**（CPU 让出）</td>
</tr>
<tr>
<td><strong>④ 线程被唤醒</strong></td>
<td><strong>排在队首的线程唤醒</strong>，再次尝试 CAS 获取锁</td>
</tr>
<tr>
<td><strong>⑤ 获取成功</strong></td>
<td><strong>线程获得锁，执行代码</strong></td>
</tr>
</tbody></table>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">unlock() &#123;</span><br><span class="line">    <span class="keyword">if</span> (decrementState() == <span class="number">0</span>) &#123; <span class="comment">// 🚀 递减 state</span></span><br><span class="line">        wakeUpNext();  <span class="comment">// 🚀 唤醒下一个排队的线程</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li><code>state--</code> 直到 <code>0</code>，表示锁已释放。</li>
<li><strong>如果 AQS 队列中有线程</strong>，就唤醒队首线程，重新 CAS 竞争。</li>
</ul>
<ul>
<li><p><strong>锁的获取</strong></p>
<ol>
<li><p><strong>尝试获取锁</strong>：</p>
<ul>
<li>线程首先通过 CAS 操作尝试获取锁。</li>
<li>如果锁的状态为 0（未被占用），则 CAS 成功，线程获取锁。</li>
<li>如果锁的状态不为 0（已被占用），则 CAS 失败，进入 AQS 队列并挂起。</li>
</ul>
</li>
<li><p><strong>加入 AQS 队列</strong>：</p>
<ul>
<li>如果 CAS 失败，线程会被封装为一个节点（Node）并加入 AQS 队列的队尾。</li>
<li>线程在队列中等待，直到被唤醒。</li>
</ul>
</li>
<li><p><strong>唤醒并重新尝试获取锁</strong>：</p>
<ul>
<li>当锁被释放时，AQS 会唤醒队首的线程。</li>
<li>被唤醒的线程会再次尝试通过 CAS 获取锁。</li>
</ul>
</li>
</ol>
</li>
<li><p><strong>锁的释放</strong></p>
<ol>
<li><strong>释放锁</strong>：<ul>
<li>线程通过 CAS 操作将锁的状态从 1 改为 0。</li>
<li>如果 AQS 队列中有等待的线程，则唤醒队首的线程。</li>
</ul>
</li>
</ol>
</li>
</ul>
</li>
<li><p><strong>公平锁与非公平锁</strong>：<code>ReentrantLock</code> 支持 <strong>公平锁</strong> 和 <strong>非公平锁</strong> 两种模式，默认是非公平锁。</p>
<ul>
<li><p><strong>非公平锁</strong>：</p>
<ul>
<li><strong>特点</strong>：<ul>
<li>新请求锁的线程会先尝试通过 CAS 获取锁，如果成功则直接抢占锁。</li>
<li>即使 AQS 队列中有等待的线程，新线程也可能抢占锁。</li>
</ul>
</li>
<li><strong>优点</strong>：<ul>
<li>吞吐量高，减少线程切换的开销。</li>
</ul>
</li>
<li><strong>缺点</strong>：<ul>
<li>可能导致线程饥饿，某些线程长期等待。</li>
</ul>
</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">ReentrantLock lock = <span class="keyword">new</span> ReentrantLock(); <span class="comment">// 默认是非公平锁</span></span><br><span class="line">lock.lock();</span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">    <span class="comment">// 同步代码块</span></span><br><span class="line">&#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">    lock.unlock();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li><p><strong>公平锁</strong></p>
<ul>
<li><strong>特点</strong>：<ul>
<li>新请求锁的线程会直接进入 AQS 队列的队尾，按照 FIFO 的顺序获取锁。</li>
<li>只有队首的线程可以尝试获取锁。</li>
</ul>
</li>
<li><strong>优点</strong>：<ul>
<li>公平性高，避免线程饥饿。适合高并发 + 低延迟的场景。</li>
</ul>
</li>
<li><strong>缺点</strong>：<ul>
<li>吞吐量较低，增加了线程切换的开销。</li>
</ul>
</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">ReentrantLock lock = <span class="keyword">new</span> ReentrantLock(<span class="keyword">true</span>); <span class="comment">// 公平锁</span></span><br><span class="line">lock.lock();</span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">    <span class="comment">// 同步代码块</span></span><br><span class="line">&#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">    lock.unlock();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
</li>
<li></li>
<li></li>
</ol>
<p>5.1 <strong>优点</strong></p>
<ul>
<li><strong>可重入性</strong>：同一个线程可以多次获取同一把锁。</li>
<li><strong>灵活性</strong>：支持公平锁和非公平锁。</li>
<li><strong>可中断</strong>：支持 <code>lockInterruptibly()</code> 方法，允许线程在等待锁时响应中断。</li>
<li><strong>超时机制</strong>：支持 <code>tryLock()</code> 方法，允许线程在指定时间内尝试获取锁。</li>
</ul>
<p>5.2 <strong>缺点</strong></p>
<ul>
<li><strong>复杂性</strong>：使用比 <code>synchronized</code> 复杂，需要手动管理锁的获取和释放。</li>
<li><strong>性能开销</strong>：在低竞争场景下，性能可能不如 <code>synchronized</code>。</li>
</ul>
<ol start="6">
<li><strong>总结</strong></li>
</ol>
<table>
<thead>
<tr>
<th>特性</th>
<th><code>ReentrantLock</code></th>
<th><code>synchronized</code></th>
</tr>
</thead>
<tbody><tr>
<td>实现方式</td>
<td>基于 CAS 和 AQS</td>
<td>基于监视器锁（Monitor）</td>
</tr>
<tr>
<td>公平性</td>
<td>支持公平锁和非公平锁</td>
<td>非公平锁</td>
</tr>
<tr>
<td>可中断</td>
<td>支持</td>
<td>不支持</td>
</tr>
<tr>
<td>超时机制</td>
<td>支持</td>
<td>不支持</td>
</tr>
<tr>
<td>复杂性</td>
<td>较高</td>
<td>较低</td>
</tr>
</tbody></table>
<p><code>ReentrantLock</code> 提供了比 <code>synchronized</code> 更灵活的锁控制，适合需要高级功能的并发场景。如果只是简单的同步需求，<code>synchronized</code> 仍然是更好的选择。</p>
<p><code>ReentrantLock</code> 是 <code>java.util.concurrent.locks</code> 包中的一个可重入互斥锁，实现了 <code>Lock</code> 接口，提供了显式锁管理和更多灵活的锁控制。</p>
<p><strong>1. ReentrantLock 的核心特性</strong></p>
<ol>
<li><p>**重入性 (Reentrancy)**：同一线程可多次获取锁，计数器记录锁的获取次数，释放时需多次解锁。</p>
</li>
<li><p><strong>公平与非公平模式</strong>：支持公平和非公平两种模式。</p>
<p><strong>非公平锁（默认）</strong></p>
<ul>
<li>优点：吞吐量更高，适合高并发环境。</li>
<li>原理：不关心等待队列顺序，直接尝试 CAS 获取锁。</li>
</ul>
<p><strong>公平锁（可选）</strong></p>
<ul>
<li>优点：严格遵循 FIFO 顺序，避免线程饥饿。</li>
<li>原理：检查同步队列中是否有等待线程，优先唤醒队首线程。</li>
</ul>
</li>
<li><p><strong>可中断锁获取</strong>：支持 <code>lockInterruptibly()</code> 方法，响应中断。</p>
</li>
<li><p><strong>超时获取锁</strong>：支持 <code>tryLock(time, unit)</code>，设置超时机制。</p>
</li>
<li><p>**条件变量支持 (Condition)**：支持多条件等待/通知机制。</p>
</li>
</ol>
<p><strong>2. 内部实现核心组件</strong></p>
<p><strong>2.1 内部类 <code>Sync</code></strong></p>
<p><code>ReentrantLock</code> 通过内部类 <code>Sync</code> 来实现锁逻辑，继承了 <code>AbstractQueuedSynchronizer (AQS)</code>。</p>
<p><strong>关键方法：</strong></p>
<ul>
<li><code>lock()</code>：获取锁，阻塞式。</li>
<li><code>tryAcquire()</code>：尝试获取锁，成功返回 <code>true</code>，否则 <code>false</code>。</li>
<li><code>release()</code>：释放锁，减少计数器。</li>
<li><code>tryRelease()</code>：尝试释放锁，若计数器归零，表示锁已释放。</li>
</ul>
<p><strong>2.2 锁获取机制 (<code>lock()</code>)</strong></p>
<p><strong>非公平锁流程 (默认模式)</strong></p>
<ol>
<li>尝试通过 <code>compareAndSetState(0, 1)</code> 获取锁。</li>
<li>若获取失败，则调用 <code>acquire(1)</code>，进入 AQS 阻塞队列，等待锁。</li>
<li>获取成功时，将当前线程设置为持有锁的线程。</li>
</ol>
<p><strong>公平锁流程</strong></p>
<ol>
<li><p>调用 </p>
<figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="title">hasQueuedPredecessors</span><span class="params">()</span></span></span><br></pre></td></tr></table></figure>

<p> 判断当前线程是否排在队首：</p>
<ul>
<li>若队列为空或当前线程为第一个节点，尝试获取锁。</li>
<li>否则进入队列排队，等待锁释放。</li>
</ul>
</li>
</ol>
<p><strong>2.3 锁释放机制 (<code>unlock()</code>)</strong></p>
<ol>
<li><p>调用 <code>release(1)</code>。</p>
</li>
<li><p>在 </p>
<figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="title">tryRelease</span><span class="params">()</span></span></span><br></pre></td></tr></table></figure>

<p> 中：</p>
<ul>
<li>锁计数器减 1。</li>
<li>若计数器归零，表示锁已释放，将当前线程置为空。</li>
<li>唤醒队列中的下一个等待线程。</li>
</ul>
</li>
</ol>
<p><strong>3. ReentrantLock 内部机制详解</strong></p>
<p><strong>3.1 AQS 队列管理</strong></p>
<p>AQS 使用 <strong>双向链表</strong> 维护等待线程队列：</p>
<ul>
<li>获取锁失败时，线程进入等待队列，节点类型为 <code>Node.EXCLUSIVE</code>。</li>
<li>锁释放时，队首节点被唤醒，尝试重新获取锁。</li>
</ul>
<p><strong>3.2 公平与非公平模式实现</strong></p>
<ul>
<li><strong>非公平模式：</strong> 忽略队列顺序，当前线程直接竞争锁。</li>
<li><strong>公平模式：</strong> 必须按照队列顺序，先到先得，避免“插队”。</li>
</ul>
<p><strong>3.3 重入锁支持</strong></p>
<ul>
<li><code>Sync</code> 中的 <code>state</code> 记录重入次数。</li>
<li>相同线程多次获取锁时，<code>state</code> 递增。</li>
<li>每次释放锁时，<code>state</code> 递减，归零时完全释放锁。</li>
</ul>
<p><strong>4. 使用示例</strong></p>
<p><strong>基本使用：</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">javaCopy code<span class="keyword">import</span> java.util.concurrent.locks.ReentrantLock;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ReentrantLockExample</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> ReentrantLock lock = <span class="keyword">new</span> ReentrantLock();</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">criticalSection</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        lock.lock();  <span class="comment">// 获取锁</span></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            System.out.println(Thread.currentThread().getName() + <span class="string">&quot; 正在执行...&quot;</span>);</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            lock.unlock();  <span class="comment">// 释放锁</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        ReentrantLockExample example = <span class="keyword">new</span> ReentrantLockExample();</span><br><span class="line">        </span><br><span class="line">        Runnable task = example::criticalSection;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">new</span> Thread(task, <span class="string">&quot;线程1&quot;</span>).start();</span><br><span class="line">        <span class="keyword">new</span> Thread(task, <span class="string">&quot;线程2&quot;</span>).start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>5. 使用场景</strong></p>
<ol>
<li><strong>需要显式锁管理的场景</strong>：如超时锁获取和中断支持。</li>
<li><strong>需要公平锁的场景</strong>：确保无线程插队。</li>
<li><strong>需要多条件变量支持的场景</strong>：通过 <code>Condition</code> 支持多个等待队列。</li>
</ol>
<p><strong>6. 重要对比： <code>synchronized</code> vs <code>ReentrantLock</code></strong></p>
<table>
<thead>
<tr>
<th>特性</th>
<th><code>synchronized</code></th>
<th><code>ReentrantLock</code></th>
</tr>
</thead>
<tbody><tr>
<td>获取锁方式</td>
<td>隐式获取 (JVM 管理)</td>
<td>显式获取和释放</td>
</tr>
<tr>
<td>可中断</td>
<td>不支持</td>
<td>支持</td>
</tr>
<tr>
<td>超时获取锁</td>
<td>不支持</td>
<td>支持</td>
</tr>
<tr>
<td>条件变量支持</td>
<td><code>wait/notify</code> 单一条件</td>
<td>多 <code>Condition</code> 支持</td>
</tr>
<tr>
<td>公平锁支持</td>
<td>不支持 (非公平)</td>
<td>支持公平/非公平</td>
</tr>
<tr>
<td>性能优化</td>
<td>JVM 内置优化 (锁升级等)</td>
<td>用户控制，灵活性高</td>
</tr>
</tbody></table>
<p><strong>优势：</strong></p>
<ul>
<li>支持可重入</li>
<li>支持中断与超时操作</li>
<li>可选公平与非公平锁</li>
<li>支持多个条件变量 (<code>Condition</code>)</li>
</ul>
<p><strong>不足：</strong></p>
<ul>
<li>需要显式加锁和解锁，容易导致死锁</li>
<li>相比 <code>synchronized</code>，编码复杂度更高</li>
</ul>
<p><strong>7. 结论</strong></p>
<p><code>ReentrantLock</code> 提供了强大的锁控制功能，如可中断锁、超时机制和多条件变量等。其内部基于 AQS 实现了高效的线程管理和锁竞争控制，适用于需要更高并发控制的场景。</p>
<h4 id="问：ReentrantLock-是如何实现可重入性的-？"><a href="#问：ReentrantLock-是如何实现可重入性的-？" class="headerlink" title="问：ReentrantLock 是如何实现可重入性的 ？"></a>问：ReentrantLock 是如何实现可重入性的 ？</h4><p>内部自定义了同步器 Sync，加锁的时候通过CAS 算法 ，将线程对象放到一个双向链表 中，每次获取锁的时候 ，看下当前维 护的那个线程ID和当前请求的线程ID是否一样，一样就可重入了；</p>
<p><strong>ReentrantLock 的可重入性实现原理：</strong></p>
<p><strong>1. 可重入性定义：</strong><br> 可重入性指的是同一线程在获取锁后，可以再次获取该锁而不会被阻塞，从而避免死锁。</p>
<p><strong>2. 实现机制：</strong><br> ReentrantLock 的可重入性是通过其内部的 <strong>AQS（AbstractQueuedSynchronizer）</strong> 来实现的。主要依赖于一个整数变量 <strong>state</strong>，以及当前持有锁的线程引用 <strong>exclusiveOwnerThread</strong>。</p>
<p><strong>3. 工作流程：</strong></p>
<ul>
<li><strong>初次获取锁：</strong><ul>
<li>线程尝试获取锁时，如果 state 为 0，说明锁未被占用。成功获取锁后：<ul>
<li>将 state 设置为 1。</li>
<li>将当前线程设置为 exclusiveOwnerThread。</li>
</ul>
</li>
</ul>
</li>
<li><strong>再次获取锁（重入）：</strong><ul>
<li>如果当前线程再次尝试获取锁：<ul>
<li>检查当前线程是否与 exclusiveOwnerThread 相同。</li>
<li>如果相同，说明是同一线程重入。</li>
<li>增加 state 的值，表示锁被多次重入。</li>
</ul>
</li>
</ul>
</li>
<li><strong>释放锁：</strong><ul>
<li>每次 unlock() 调用，state 减 1。</li>
<li>当 state 减到 0 时：<ul>
<li>表示锁完全释放。</li>
<li>将 exclusiveOwnerThread 设置为 null。</li>
<li>其他等待的线程可以竞争该锁。</li>
</ul>
</li>
</ul>
</li>
</ul>
<p><strong>4. 示例代码：</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.concurrent.locks.ReentrantLock;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ReentrantLockExample</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> ReentrantLock lock = <span class="keyword">new</span> ReentrantLock();</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">methodA</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        lock.lock();</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            System.out.println(Thread.currentThread().getName() + <span class="string">&quot; - Enter methodA&quot;</span>);</span><br><span class="line">            methodB();  <span class="comment">// 重入锁示例</span></span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            lock.unlock();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">methodB</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        lock.lock();</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            System.out.println(Thread.currentThread().getName() + <span class="string">&quot; - Enter methodB&quot;</span>);</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            lock.unlock();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        ReentrantLockExample example = <span class="keyword">new</span> ReentrantLockExample();</span><br><span class="line">        <span class="keyword">new</span> Thread(example::methodA, <span class="string">&quot;Thread-1&quot;</span>).start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>5. 关键点总结：</strong></p>
<ul>
<li><strong>state</strong> 用于记录锁的重入次数。</li>
<li><strong>exclusiveOwnerThread</strong> 记录持有锁的线程。</li>
<li>只有持有锁的线程才能重入，避免了死锁和不必要的阻塞。</li>
</ul>
<h4 id="问：ReentrantLock如何避免死锁"><a href="#问：ReentrantLock如何避免死锁" class="headerlink" title="问：ReentrantLock如何避免死锁?"></a>问：ReentrantLock如何避免死锁?</h4><blockquote>
<ul>
<li>响应中断lockInterruptibly（）</li>
<li>可轮询锁tryLock（）</li>
<li>定时锁tryLock（long time）</li>
</ul>
</blockquote>
<p><strong>ReentrantLock避免死锁的方式：</strong></p>
<ol>
<li><p>**尝试锁定 (tryLock)**：<br> 使用 <code>tryLock()</code> 可以尝试在指定时间内获取锁。如果超时未获得锁，线程可以放弃操作，避免长时间阻塞，从而减少死锁的发生。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (lock.tryLock(<span class="number">2</span>, TimeUnit.SECONDS)) &#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="comment">// 执行业务逻辑</span></span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        lock.unlock();</span><br><span class="line">    &#125;</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    System.out.println(<span class="string">&quot;未能获取锁，避免死锁&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li><p><strong>锁的获取顺序</strong>：<br> 在多线程环境中，确保多个线程获取多个锁时，采用相同的顺序来避免循环依赖。例如，按资源ID的顺序加锁，防止交叉持有锁。</p>
</li>
<li><p><strong>使用 <code>lockInterruptibly()</code> 方法</strong>：<br> <code>lockInterruptibly()</code> 允许线程在尝试获取锁时可以响应中断，避免无限期等待锁，进而避免死锁。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">    lock.lockInterruptibly();</span><br><span class="line">    <span class="comment">// 执行业务逻辑</span></span><br><span class="line">&#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">    System.out.println(<span class="string">&quot;线程被中断，避免死锁&quot;</span>);</span><br><span class="line">&#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">    lock.unlock();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li><p><strong>设置超时时间与恢复机制</strong>：<br> 设计良好的恢复机制，如事务回滚、任务重试等，防止锁获取失败导致应用僵死。</p>
</li>
<li><p><strong>减少锁的持有时间</strong>：<br> 将锁的持有时间限制在最小的业务范围内，避免长期持有锁。</p>
</li>
<li><p><strong>检测与诊断工具</strong>：<br> 使用监控工具和死锁检测机制，在出现死锁时能及时发现和处理。</p>
</li>
</ol>
<p>这些机制结合可以有效减少死锁发生，提升系统的稳定性和可靠性。</p>
<p><strong>避免死锁的代码示例与说明</strong></p>
<ol>
<li><strong>响应中断的锁 <code>lockInterruptibly()</code></strong></li>
</ol>
<ul>
<li><strong>说明</strong>: 使用 <code>lockInterruptibly()</code> 可在获取锁时响应中断，避免长时间等待。</li>
</ul>
<p><strong>示例代码</strong>:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.concurrent.locks.ReentrantLock;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">InterruptibleLockDemo</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> ReentrantLock lock = <span class="keyword">new</span> ReentrantLock();</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Thread t1 = <span class="keyword">new</span> Thread(() -&gt; accessResource(), <span class="string">&quot;Thread-1&quot;</span>);</span><br><span class="line">        Thread t2 = <span class="keyword">new</span> Thread(() -&gt; accessResource(), <span class="string">&quot;Thread-2&quot;</span>);</span><br><span class="line"></span><br><span class="line">        t1.start();</span><br><span class="line">        t2.start();</span><br><span class="line">        t1.interrupt();  <span class="comment">// 中断线程1</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">accessResource</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            lock.lockInterruptibly();  <span class="comment">// 支持中断获取锁</span></span><br><span class="line">            System.out.println(Thread.currentThread().getName() + <span class="string">&quot; acquired the lock.&quot;</span>);</span><br><span class="line">            Thread.sleep(<span class="number">2000</span>);  <span class="comment">// 模拟任务</span></span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">            System.out.println(Thread.currentThread().getName() + <span class="string">&quot; was interrupted.&quot;</span>);</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            <span class="keyword">if</span> (lock.isHeldByCurrentThread()) &#123;</span><br><span class="line">                lock.unlock();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ol start="2">
<li><strong>可轮询锁 <code>tryLock()</code></strong></li>
</ol>
<ul>
<li><strong>说明</strong>: 尝试获取锁，获取成功返回 <code>true</code>，失败立即返回 <code>false</code>，避免死锁。</li>
</ul>
<p><strong>示例代码</strong>:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.concurrent.locks.ReentrantLock;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TryLockDemo</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> ReentrantLock lock = <span class="keyword">new</span> ReentrantLock();</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Runnable task = () -&gt; &#123;</span><br><span class="line">            <span class="keyword">if</span> (lock.tryLock()) &#123;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    System.out.println(Thread.currentThread().getName() + <span class="string">&quot; acquired the lock.&quot;</span>);</span><br><span class="line">                    Thread.sleep(<span class="number">1000</span>);  <span class="comment">// 模拟任务</span></span><br><span class="line">                &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">                    lock.unlock();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                System.out.println(Thread.currentThread().getName() + <span class="string">&quot; failed to acquire the lock.&quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">new</span> Thread(task, <span class="string">&quot;Thread-1&quot;</span>).start();</span><br><span class="line">        <span class="keyword">new</span> Thread(task, <span class="string">&quot;Thread-2&quot;</span>).start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ol start="3">
<li><strong>定时锁 <code>tryLock(long time, TimeUnit unit)</code></strong></li>
</ol>
<ul>
<li><strong>说明</strong>: 在指定时间内尝试获取锁，获取成功返回 <code>true</code>，超时返回 <code>false</code>。</li>
</ul>
<p><strong>示例代码</strong>:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.concurrent.TimeUnit;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.locks.ReentrantLock;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TimedLockDemo</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> ReentrantLock lock = <span class="keyword">new</span> ReentrantLock();</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Runnable task = () -&gt; &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                <span class="keyword">if</span> (lock.tryLock(<span class="number">2</span>, TimeUnit.SECONDS)) &#123;</span><br><span class="line">                    <span class="keyword">try</span> &#123;</span><br><span class="line">                        System.out.println(Thread.currentThread().getName() + <span class="string">&quot; acquired the lock.&quot;</span>);</span><br><span class="line">                        Thread.sleep(<span class="number">3000</span>);  <span class="comment">// 模拟任务</span></span><br><span class="line">                    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">                        lock.unlock();</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    System.out.println(Thread.currentThread().getName() + <span class="string">&quot; timed out while waiting for the lock.&quot;</span>);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">new</span> Thread(task, <span class="string">&quot;Thread-1&quot;</span>).start();</span><br><span class="line">        <span class="keyword">new</span> Thread(task, <span class="string">&quot;Thread-2&quot;</span>).start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>总结</strong></p>
<ul>
<li><strong>响应中断 <code>lockInterruptibly()</code></strong>: 在等待锁期间支持线程中断。</li>
<li><strong>可轮询锁 <code>tryLock()</code></strong>: 尝试获取锁，立即返回，避免长时间阻塞。</li>
<li><strong>定时锁 <code>tryLock(long, TimeUnit)</code></strong>: 在特定时间内尝试获取锁，避免无限等待。</li>
</ul>
<h4 id="问：tryLock-和-lock-和-lockInterruptibly-的区别-⭐⭐"><a href="#问：tryLock-和-lock-和-lockInterruptibly-的区别-⭐⭐" class="headerlink" title="问：tryLock 和 lock 和 lockInterruptibly 的区别?⭐⭐"></a>问：tryLock 和 lock 和 lockInterruptibly 的区别?⭐⭐</h4><ol>
<li>tryLock 能获得锁就返回 true，不能就立即返回 false</li>
<li>tryLock(long timeout，TimeUnit unit)，可以增加时间限制，如果超过该时间段还没获得锁，返回 false</li>
<li>lock 能获得锁就返回 true，不能的话一直等待获得锁</li>
<li>lock 和 lockInterruptibly，如果两个线程分别执行这两个方法，但此时中断这两个线程， lock 不会抛出异常，而 lockInterruptibly 会抛出异常。</li>
</ol>
<ol>
<li><strong><code>lock()</code></strong></li>
</ol>
<ul>
<li><strong>作用：</strong> 获取锁，如果锁被占用，当前线程将进入等待状态，直到获得锁。</li>
<li><strong>特点：</strong> 不可中断，必须等待锁释放。</li>
<li><strong>适用场景：</strong> 需要确保获取锁，无论等待时间多长。</li>
</ul>
<p><strong>示例代码：</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">Lock lock = <span class="keyword">new</span> ReentrantLock();</span><br><span class="line">lock.lock();</span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">    <span class="comment">// 临界区代码</span></span><br><span class="line">&#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">    lock.unlock();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ol start="2">
<li><strong><code>tryLock()</code></strong></li>
</ol>
<ul>
<li><strong>作用：</strong> 尝试获取锁，如果锁可用，则立即获取；否则，返回 <code>false</code>。</li>
<li><strong>特点：</strong> 非阻塞，避免线程长时间等待锁。</li>
<li><strong>适用场景：</strong> 非阻塞操作，适合尝试性加锁。</li>
</ul>
<p><strong>示例代码：</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (lock.tryLock()) &#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="comment">// 临界区代码</span></span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        lock.unlock();</span><br><span class="line">    &#125;</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    System.out.println(<span class="string">&quot;未能获取锁&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ol start="3">
<li><strong><code>tryLock(long time, TimeUnit unit)</code></strong></li>
</ol>
<ul>
<li><strong>作用：</strong> 在指定的时间内尝试获取锁，如果成功返回 <code>true</code>，否则返回 <code>false</code>。</li>
<li><strong>特点：</strong> 支持超时机制，适合限时操作。</li>
<li><strong>适用场景：</strong> 限时等待，避免无限期阻塞。</li>
</ul>
<p><strong>示例代码：</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (lock.tryLock(<span class="number">5</span>, TimeUnit.SECONDS)) &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">// 临界区代码</span></span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            lock.unlock();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;获取锁超时&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">    e.printStackTrace();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ol start="4">
<li><strong><code>lockInterruptibly()</code></strong></li>
</ol>
<ul>
<li><strong>作用：</strong> 支持中断的加锁方法。如果锁被占用，当前线程进入等待状态，但可以被其他线程中断。</li>
<li><strong>特点：</strong> 支持中断，避免死锁风险。</li>
<li><strong>适用场景：</strong> 需要对中断信号做出响应，适用于线程池管理等场景。</li>
</ul>
<p><strong>示例代码：</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">    lock.lockInterruptibly();</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="comment">// 临界区代码</span></span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        lock.unlock();</span><br><span class="line">    &#125;</span><br><span class="line">&#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">    System.out.println(<span class="string">&quot;线程被中断&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>区别总结：</strong></p>
<table>
<thead>
<tr>
<th>方法名</th>
<th>是否阻塞</th>
<th>支持中断</th>
<th>超时机制</th>
<th>返回值</th>
</tr>
</thead>
<tbody><tr>
<td><code>lock()</code></td>
<td>阻塞</td>
<td>否</td>
<td>否</td>
<td>无</td>
</tr>
<tr>
<td><code>tryLock()</code></td>
<td>非阻塞</td>
<td>否</td>
<td>否</td>
<td><code>true/false</code></td>
</tr>
<tr>
<td><code>tryLock(time,unit)</code></td>
<td>阻塞</td>
<td>是</td>
<td>是</td>
<td><code>true/false</code></td>
</tr>
<tr>
<td><code>lockInterruptibly()</code></td>
<td>阻塞</td>
<td>是</td>
<td>否</td>
<td>无</td>
</tr>
</tbody></table>
<p>选择时需根据具体需求权衡阻塞性、中断支持和超时管理等功能。</p>
<hr>
<h3 id="2-5-Condition"><a href="#2-5-Condition" class="headerlink" title="2.5 Condition"></a>2.5 Condition</h3><h4 id="问：讲一下Condition？"><a href="#问：讲一下Condition？" class="headerlink" title="问：讲一下Condition？"></a>问：讲一下Condition？</h4><p>Condition接口主要是和Lock配合实现等待通知模式，类似于对象监视器方法和synchronized的组合。其定义了一系列等待和唤醒方法，Condition对象依赖于Lock对象，一个Condition包含一个等待队列，Condition拥有首节点（firstWaiter）和尾节点（lastWaiter）。等待时将节点从同步队列移动到等待队列，需要把当前线程构建成一个新的等待结点。通知时则不需要新建节点，可以看作直接把等待节点移动到同步队列。</p>
<p><strong>Condition 在 Java 中的作用</strong></p>
<p><code>Condition</code> 是 Java 并发包 (<code>java.util.concurrent.locks</code>) 提供的一个接口，用于支持线程之间的协调和通信，类似于 <code>Object</code> 类中的 <code>wait()</code>、<code>notify()</code> 和 <code>notifyAll()</code>，但功能更强大。<code>Condition</code> 是与 <code>ReentrantLock</code> 一起使用的，提供了线程等待和通知的灵活机制。</p>
<p><strong>主要方法：</strong></p>
<ol>
<li><strong><code>await()</code></strong><ul>
<li>当前线程进入等待状态，释放锁，直到被通知或被中断。</li>
</ul>
</li>
<li><strong><code>signal()</code></strong><ul>
<li>唤醒一个等待在此 <code>Condition</code> 上的线程。</li>
</ul>
</li>
<li><strong><code>signalAll()</code></strong><ul>
<li>唤醒所有等待在此 <code>Condition</code> 上的线程。</li>
</ul>
</li>
<li><strong><code>awaitUninterruptibly()</code></strong><ul>
<li>与 <code>await()</code> 类似，但不会响应中断。</li>
</ul>
</li>
<li><strong><code>await(long time, TimeUnit unit)</code></strong><ul>
<li>超时等待，时间到后自动唤醒。</li>
</ul>
</li>
</ol>
<p><strong>使用示例：生产者-消费者模型</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.concurrent.locks.Condition;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.locks.Lock;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.locks.ReentrantLock;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Buffer</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> data;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">boolean</span> isEmpty = <span class="keyword">true</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> Lock lock = <span class="keyword">new</span> ReentrantLock();</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> Condition notFull = lock.newCondition();</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> Condition notEmpty = lock.newCondition();</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">produce</span><span class="params">(<span class="keyword">int</span> value)</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">        lock.lock();</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">while</span> (!isEmpty) &#123;</span><br><span class="line">                notFull.await(); <span class="comment">// 等待缓冲区非满</span></span><br><span class="line">            &#125;</span><br><span class="line">            data = value;</span><br><span class="line">            isEmpty = <span class="keyword">false</span>;</span><br><span class="line">            System.out.println(<span class="string">&quot;Produced: &quot;</span> + data);</span><br><span class="line">            notEmpty.signal(); <span class="comment">// 唤醒消费者</span></span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            lock.unlock();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">consume</span><span class="params">()</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">        lock.lock();</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">while</span> (isEmpty) &#123;</span><br><span class="line">                notEmpty.await(); <span class="comment">// 等待缓冲区非空</span></span><br><span class="line">            &#125;</span><br><span class="line">            isEmpty = <span class="keyword">true</span>;</span><br><span class="line">            System.out.println(<span class="string">&quot;Consumed: &quot;</span> + data);</span><br><span class="line">            notFull.signal(); <span class="comment">// 唤醒生产者</span></span><br><span class="line">            <span class="keyword">return</span> data;</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            lock.unlock();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ConditionExample</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Buffer buffer = <span class="keyword">new</span> Buffer();</span><br><span class="line"></span><br><span class="line">        Thread producer = <span class="keyword">new</span> Thread(() -&gt; &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">5</span>; i++) &#123;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    buffer.produce(i);</span><br><span class="line">                &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line"></span><br><span class="line">        Thread consumer = <span class="keyword">new</span> Thread(() -&gt; &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">5</span>; i++) &#123;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    buffer.consume();</span><br><span class="line">                &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line"></span><br><span class="line">        producer.start();</span><br><span class="line">        consumer.start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>与 <code>Object</code> 的 <code>wait()</code>/<code>notify()</code> 对比：</strong></p>
<table>
<thead>
<tr>
<th>Feature</th>
<th><code>Condition</code></th>
<th><code>Object</code> <code>wait()/notify()</code></th>
</tr>
</thead>
<tbody><tr>
<td>锁机制</td>
<td>必须与 <code>ReentrantLock</code> 一起使用</td>
<td>必须与 <code>synchronized</code> 一起使用</td>
</tr>
<tr>
<td>多个等待队列</td>
<td>支持多个 <code>Condition</code> 实例</td>
<td>只有一个隐式等待队列</td>
</tr>
<tr>
<td>响应中断与超时支持</td>
<td>支持中断与超时</td>
<td>支持中断，但不支持超时</td>
</tr>
<tr>
<td>灵活性和控制力</td>
<td>高</td>
<td>较低</td>
</tr>
</tbody></table>
<p><strong>总结：</strong></p>
<p><code>Condition</code> 提供了灵活的线程间通信机制，可以替代 <code>synchronized</code> 和 <code>wait()/notify()</code>，在复杂并发场景中表现更好。其多等待队列和精准通知的特性非常适合生产者-消费者等模式。</p>
<h4 id="问：对象监视器方法和Condition的异同-？"><a href="#问：对象监视器方法和Condition的异同-？" class="headerlink" title="问：对象监视器方法和Condition的异同 ？"></a>问：对象监视器方法和Condition的异同 ？</h4><p><strong>任意一个Java对象，都拥有一组监视器方法</strong>（定义在 <code>java.lang.Object</code> 上），主要包括 <code>wait()</code> 、<code>wait(long timeout)</code> 、<code>notify()</code> 以及 <code>notifyAll()</code> 方法，这些方法与 <code>synchronized</code> 同步关键字配合，可以实现<strong>等待/通知模式</strong>。</p>
<p><code>Condition</code> 接口也提供了类似 <code>Object</code> 的监视器方法，与Lock配合可以实现<strong>等待/通知模式</strong>，但是这两者在使用方式以及功能特性上还是有差别的。</p>
<p><img src="https://pic-1258215793.cos.ap-shanghai.myqcloud.com/content/20190601/201906010120.png" alt="Object的监视器方法与Condition接口的对比"></p>
<p>对象监视器方法（<code>wait()</code>, <code>notify()</code>, <code>notifyAll()</code>）和 <code>Condition</code> 在 Java 并发编程中都用于线程间通信，但它们的用法和实现机制存在显著差异：</p>
<p><strong>相同点：</strong></p>
<ol>
<li><strong>线程间通信：</strong> 两者都用于在多个线程之间共享信息，协调运行顺序。</li>
<li><strong>等待与通知机制：</strong> 都提供等待和唤醒机制，以实现线程间的同步。</li>
</ol>
<p><strong>不同点：</strong></p>
<table>
<thead>
<tr>
<th><strong>特性</strong></th>
<th><strong>对象监视器方法（Object）</strong></th>
<th><strong>Condition</strong></th>
</tr>
</thead>
<tbody><tr>
<td><strong>所在类</strong></td>
<td><code>Object</code> 类的固有方法</td>
<td><code>java.util.concurrent.locks.Condition</code></td>
</tr>
<tr>
<td><strong>使用范围</strong></td>
<td>必须配合 <code>synchronized</code> 块或方法</td>
<td>必须配合 <code>Lock</code> 实现</td>
</tr>
<tr>
<td><strong>多个等待队列支持</strong></td>
<td>不支持（只能有一个等待队列）</td>
<td>支持多个 <code>Condition</code> 实例</td>
</tr>
<tr>
<td><strong>唤醒机制</strong></td>
<td><code>notify()</code> 唤醒一个，<code>notifyAll()</code> 唤醒全部</td>
<td><code>signal()</code> 唤醒一个，<code>signalAll()</code> 唤醒全部</td>
</tr>
<tr>
<td><strong>响应中断支持</strong></td>
<td>支持，<code>wait()</code> 可响应中断</td>
<td>支持，<code>await()</code> 可响应中断</td>
</tr>
<tr>
<td><strong>等待超时支持</strong></td>
<td>支持 <code>wait(long timeout)</code></td>
<td>支持 <code>await(long time, TimeUnit)</code></td>
</tr>
<tr>
<td><strong>实现复杂度</strong></td>
<td>相对简单，适用于基础同步场景</td>
<td>更灵活，适用于复杂同步需求</td>
</tr>
</tbody></table>
<p><em>选择建议：</em>*</p>
<ul>
<li><strong>对象监视器方法：</strong> 适用于简单的线程同步和少量共享资源。</li>
<li><strong>Condition：</strong> 适用于复杂的线程间协调，需要多个等待条件时尤其有用，如生产者-消费者模型中的多个条件队列。</li>
</ul>
<hr>
<h3 id="2-6-AQS"><a href="#2-6-AQS" class="headerlink" title="2.6 AQS"></a>2.6 AQS</h3><h4 id="问：讲讲AQS？实现原理？讲讲AQS怎么实现的Fair和NoFair？"><a href="#问：讲讲AQS？实现原理？讲讲AQS怎么实现的Fair和NoFair？" class="headerlink" title="问：讲讲AQS？实现原理？讲讲AQS怎么实现的Fair和NoFair？"></a>问：讲讲AQS？实现原理？讲讲AQS怎么实现的Fair和NoFair？</h4><p>AQS即队列同步器（AbstractQueuedSynchronizer），是构建锁和其他同步组件的基础框架，锁是面向使用者的，同步器则是面向锁的实现者。</p>
<p>实现原理：AQS底层是一个双向链表实现的FIFO同步队列，通过整型成员变量state来判断锁的同步状态，基于模板方法模式来设计，包含独占式和共享式的获取同步状态，各种锁自定义实现AQS。</p>
<p>对于非可重入锁状态不是0则去阻塞；对于可重入锁如果是0则执行，非0则判断当前线程是否是获取到这个锁的线程，是的话把state状态＋1，比如重入5次，那么state=5。 而在释放锁的时候，同样需要释放5次直到state=0其他线程才有资格获得锁。</p>
<p><strong>AbstractQueuedSynchronizer (AQS) 概述</strong></p>
<p>AQS（AbstractQueuedSynchronizer）是Java并发包<code>java.util.concurrent</code>中的一个核心框架，用于实现同步工具如<code>ReentrantLock</code>、<code>Semaphore</code>、<code>CountDownLatch</code>等。AQS提供了一个FIFO等待队列和状态管理机制，简化了线程同步逻辑的实现。</p>
<p><strong>AQS 实现原理</strong></p>
<ol>
<li><strong>同步状态管理：</strong><ul>
<li>AQS维护一个<code>state</code>字段（<code>volatile int state</code>），表示共享资源的状态。</li>
<li>通过<code>getState()</code>、<code>setState()</code>、<code>compareAndSetState()</code>操作该状态，保证线程安全。</li>
</ul>
</li>
<li><strong>等待队列：</strong><ul>
<li>AQS维护一个双向链表形式的FIFO等待队列，节点类型为<code>Node</code>。</li>
<li>队列中的节点存储着等待线程及其相关状态信息。</li>
</ul>
</li>
<li><strong>模板方法模式：</strong><ul>
<li>子类通过实现<code>tryAcquire</code>、<code>tryRelease</code>、<code>tryAcquireShared</code>、<code>tryReleaseShared</code>等方法，自定义同步逻辑。</li>
</ul>
</li>
<li><strong>独占模式（Exclusive）：</strong><ul>
<li>线程独占资源，适用于<code>ReentrantLock</code>。</li>
<li>获取锁：<code>acquire(int arg)</code>，释放锁：<code>release(int arg)</code>。</li>
</ul>
</li>
<li><strong>共享模式（Shared）：</strong><ul>
<li>多个线程共享资源，适用于<code>Semaphore</code>、<code>CountDownLatch</code>。</li>
<li>获取资源：<code>acquireShared(int arg)</code>，释放资源：<code>releaseShared(int arg)</code>。</li>
</ul>
</li>
</ol>
<p><strong>公平锁与非公平锁的实现（Fair &amp; NoFair）</strong></p>
<ol>
<li><strong>公平锁（Fair）</strong></li>
</ol>
<ul>
<li>公平锁遵循FIFO顺序，先来先得。</li>
<li>实现方式：在获取锁时，检查等待队列中是否有其他线程。若有，排队等候；若无，尝试获取锁。</li>
</ul>
<p><strong>示例：<code>ReentrantLock</code> 的公平锁实现</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">tryAcquire</span><span class="params">(<span class="keyword">int</span> acquires)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">final</span> Thread current = Thread.currentThread();</span><br><span class="line">    <span class="keyword">int</span> c = getState();</span><br><span class="line">    <span class="keyword">if</span> (c == <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (!hasQueuedPredecessors() &amp;&amp; compareAndSetState(<span class="number">0</span>, acquires)) &#123;</span><br><span class="line">            setExclusiveOwnerThread(current);</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (current == getExclusiveOwnerThread()) &#123;</span><br><span class="line">        setState(c + acquires);</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ol start="2">
<li><strong>非公平锁（NoFair）</strong></li>
</ol>
<ul>
<li>非公平锁不保证线程的获取顺序，允许线程“插队”。</li>
<li>实现方式：尝试直接获取锁，而不检查队列状态。</li>
</ul>
<p><strong>示例：<code>ReentrantLock</code> 的非公平锁实现</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">tryAcquire</span><span class="params">(<span class="keyword">int</span> acquires)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">final</span> Thread current = Thread.currentThread();</span><br><span class="line">    <span class="keyword">int</span> c = getState();</span><br><span class="line">    <span class="keyword">if</span> (c == <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (compareAndSetState(<span class="number">0</span>, acquires)) &#123;</span><br><span class="line">            setExclusiveOwnerThread(current);</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (current == getExclusiveOwnerThread()) &#123;</span><br><span class="line">        setState(c + acquires);</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>小结：AQS 的核心要点</strong></p>
<ul>
<li>状态管理：通过<code>state</code>字段和CAS操作管理资源。</li>
<li>等待队列：维护一个FIFO队列存储等待线程。</li>
<li>可扩展性：通过模板方法模式，支持多种同步器的实现。</li>
<li>公平性实现：通过队列和检查机制支持公平与非公平锁策略。</li>
</ul>
<h4 id="问：AQS两种资源共享方式？"><a href="#问：AQS两种资源共享方式？" class="headerlink" title="问：AQS两种资源共享方式？"></a>问：AQS两种资源共享方式？</h4><ul>
<li>Exclusive：独占，只有一个线程能执行，如ReentrantLock。</li>
<li>Share：共享，多个线程可以同时执行，如Semaphore、CountDownLatch、ReadWriteLock，CyclicBarrier。</li>
</ul>
<p>在Java并发包中，<strong>AQS（AbstractQueuedSynchronizer）</strong> 提供了两种资源共享方式：</p>
<ol>
<li><strong>独占（Exclusive）模式</strong></li>
</ol>
<ul>
<li><strong>定义:</strong> 只有一个线程能获取资源，其它线程必须等待。</li>
<li><strong>实现:</strong><ul>
<li>当一个线程成功获取资源后，其他线程将被阻塞，进入等待队列。</li>
<li>使用场景：<code>ReentrantLock</code>（独占锁）。</li>
</ul>
</li>
<li><strong>主要方法:</strong><ul>
<li><code>tryAcquire(int arg)</code>：尝试获取资源，返回<code>true</code>表示成功。</li>
<li><code>tryRelease(int arg)</code>：释放资源。</li>
</ul>
</li>
</ul>
<ol start="2">
<li><strong>共享（Shared）模式</strong></li>
</ol>
<ul>
<li><strong>定义:</strong> 多个线程可以同时获取资源，直到资源耗尽。</li>
<li><strong>实现:</strong><ul>
<li>多个线程同时获取资源，资源分配完后，剩余线程进入等待队列。</li>
<li>使用场景：<code>CountDownLatch</code>、<code>Semaphore</code>、<code>ReadWriteLock</code>（读锁）。</li>
</ul>
</li>
<li><strong>主要方法:</strong><ul>
<li><code>tryAcquireShared(int arg)</code>：尝试共享式获取资源，返回值 &gt;= 0 表示成功。</li>
<li><code>tryReleaseShared(int arg)</code>：释放共享资源。</li>
</ul>
</li>
</ul>
<p>区别总结</p>
<table>
<thead>
<tr>
<th>特性</th>
<th>独占模式</th>
<th>共享模式</th>
</tr>
</thead>
<tbody><tr>
<td>资源占用</td>
<td>单线程占用</td>
<td>多线程共享</td>
</tr>
<tr>
<td>实现方法</td>
<td><code>tryAcquire</code></td>
<td><code>tryAcquireShared</code></td>
</tr>
<tr>
<td>使用场景</td>
<td><code>ReentrantLock</code></td>
<td><code>CountDownLatch</code>、<code>Semaphore</code></td>
</tr>
</tbody></table>
<p>这两种模式通过自定义AQS的<code>tryAcquire</code>和<code>tryAcquireShared</code>方法，灵活实现各种同步器。</p>
<h4 id="问：CAS了解么？-CAS-有什么缺陷，如何解决？还了解其他同步机制么？"><a href="#问：CAS了解么？-CAS-有什么缺陷，如何解决？还了解其他同步机制么？" class="headerlink" title="问：CAS了解么？ CAS 有什么缺陷，如何解决？还了解其他同步机制么？"></a>问：CAS了解么？ CAS 有什么缺陷，如何解决？还了解其他同步机制么？</h4><p>CAS，Compare and Set，比较并交换，常用来实现乐观锁。</p>
<p>实现原理：内存值，预期值，修改的新值，当内存值等于预期值时，将内存值修改为新值，否则什么都不做。</p>
<p>CAS的缺陷有三个：</p>
<ol>
<li>ABA问题，即A变为B再变为A也能满足判断条件。</li>
<li>如果CAS失败，自旋会给CPU带来压力，死循环。</li>
<li>只能保证对一个变量的原子性操作。</li>
</ol>
<p>解决方案分别是：</p>
<ol>
<li>引入版本号或修改次数，1A-&gt;2B-&gt;3A。</li>
<li>使用JVM提供的pause指令。</li>
<li>用锁将多个共享变量合并为一个来操作，使用 <code>AtomicReference</code> 类来保证引用对象之间的原子性，就可以把多个变量放在一个对象里来进行CAS操作。</li>
</ol>
<p>CAS在java中的应用：<br>（1）：Atomic系列</p>
<p>还有信号量机制，自旋锁等。</p>
<p><strong>CAS (Compare and Swap) 概念</strong></p>
<p><strong>CAS (Compare and Swap/Set)</strong> 是一种无锁的并发编程技术，常用于实现高效的原子操作。它通过硬件支持的指令（如x86的<code>cmpxchg</code>）实现。</p>
<p><strong>工作原理:</strong></p>
<ul>
<li>比较内存中的值（<code>expectedValue</code>）是否等于期望值。</li>
<li>如果相等，将内存值更新为新值（<code>newValue</code>）。</li>
<li>如果不相等，说明其他线程已修改该值，操作失败，需重试。</li>
</ul>
<p><strong>CAS 的缺陷与解决方案</strong></p>
<ol>
<li><strong>ABA问题:</strong><ul>
<li><strong>描述:</strong> 内存中的值从<code>A</code>变为<code>B</code>，然后又变回<code>A</code>。CAS仅检查值是否等于预期值，因此无法察觉中间变化。</li>
<li>解决:<ul>
<li>引入版本号，如<code>AtomicStampedReference</code>，通过版本号检查变化。</li>
</ul>
</li>
</ul>
</li>
<li><strong>自旋等待（Spin-waiting）问题:</strong><ul>
<li><strong>描述:</strong> 若线程长时间CAS失败，将不断重试，浪费CPU资源。</li>
<li>解决:<ul>
<li>增加重试次数上限，必要时让线程休眠。</li>
<li>使用更高级别的锁机制，如<code>ReentrantLock</code>。</li>
</ul>
</li>
</ul>
</li>
<li><strong>只能保证一个变量的原子性:</strong><ul>
<li><strong>描述:</strong> CAS一次只能操作一个变量。</li>
<li>解决:<ul>
<li>使用<code>AtomicReference</code>封装对象。</li>
<li>对多个变量，使用<code>AtomicReferenceFieldUpdater</code>或同步机制。</li>
</ul>
</li>
</ul>
</li>
<li><strong>性能问题:</strong><ul>
<li><strong>描述:</strong> 在高并发场景中，若竞争激烈，CAS失败率高，重试频繁，性能下降。</li>
<li>解决:<ul>
<li>使用高效的并发容器，如<code>ConcurrentHashMap</code>、<code>ConcurrentLinkedQueue</code>，它们在内部优化了CAS重试机制。</li>
</ul>
</li>
</ul>
</li>
</ol>
<p><strong>其他同步机制</strong></p>
<ol>
<li><strong>同步锁:</strong> <code>synchronized</code>、<code>ReentrantLock</code>（独占锁）。</li>
<li><strong>读写锁:</strong> <code>ReentrantReadWriteLock</code>。</li>
<li><strong>倒计时器:</strong> <code>CountDownLatch</code>。</li>
<li><strong>信号量:</strong> <code>Semaphore</code>（控制并发线程数）。</li>
<li><strong>栅栏:</strong> <code>CyclicBarrier</code>（线程集合点）。</li>
<li><strong>原子变量类:</strong> <code>AtomicInteger</code>、<code>AtomicReference</code>。</li>
<li><strong>锁支持工具类:</strong> <code>LockSupport</code>。</li>
</ol>
<p>这些机制在不同场景下实现了线程间的同步与并发控制。需要根据实际情况选择合适的同步工具。</p>
<h4 id="问：CAS和synchronized有什么区别？都用synchronized不行么？"><a href="#问：CAS和synchronized有什么区别？都用synchronized不行么？" class="headerlink" title="问：CAS和synchronized有什么区别？都用synchronized不行么？"></a>问：CAS和synchronized有什么区别？都用synchronized不行么？</h4><p>synchronized是获取对象锁，属于重量级锁，虽然有进行优化，但还是有一定的性能开销。CAS则并未利用锁，其机制比较适合读多写少的场景。</p>
<p>如果都采用synchronized，在并发编程时不能获得令人满意的执行效率。</p>
<p><strong>CAS 与 synchronized 的区别</strong></p>
<table>
<thead>
<tr>
<th><strong>特性</strong></th>
<th><strong>CAS（Compare and Swap）</strong></th>
<th><strong>synchronized</strong></th>
</tr>
</thead>
<tbody><tr>
<td><strong>类型</strong></td>
<td>无锁机制（乐观锁）</td>
<td>阻塞锁（悲观锁）</td>
</tr>
<tr>
<td><strong>实现方式</strong></td>
<td>基于硬件指令，使用自旋重试</td>
<td>JVM 内置锁，使用锁机制</td>
</tr>
<tr>
<td><strong>线程阻塞情况</strong></td>
<td>不会阻塞，失败时自旋重试</td>
<td>失败时阻塞，等待锁释放</td>
</tr>
<tr>
<td><strong>性能</strong></td>
<td>在低竞争环境中性能优越</td>
<td>在高竞争环境中可能更稳定</td>
</tr>
<tr>
<td><strong>适用场景</strong></td>
<td>轻量级并发操作，如计数器、累加器</td>
<td>需要强同步的代码块或方法</td>
</tr>
<tr>
<td><strong>开销</strong></td>
<td>CPU开销高（失败时自旋重试）</td>
<td>线程切换和上下文切换开销</td>
</tr>
<tr>
<td><strong>粒度控制</strong></td>
<td>只能控制变量或内存区域</td>
<td>控制代码块、方法，粒度灵活</td>
</tr>
<tr>
<td><strong>原子性保障</strong></td>
<td>仅能保证单个变量的原子性</td>
<td>保证整个代码块的原子性</td>
</tr>
</tbody></table>
<p><strong>为什么不用 synchronized 替代 CAS？</strong></p>
<ol>
<li><strong>性能差异:</strong><ul>
<li><code>synchronized</code>在JDK早期版本是重量级锁，性能较差。虽然在JDK 1.6后进行了优化（如偏向锁、轻量级锁、锁消除等），但在高并发场景下，仍有线程阻塞和上下文切换成本。</li>
</ul>
</li>
<li><strong>非阻塞性:</strong><ul>
<li>CAS是非阻塞算法，操作失败时会自旋重试，适用于无锁结构，避免了线程阻塞和上下文切换。</li>
</ul>
</li>
<li><strong>扩展性:</strong><ul>
<li>在简单的计数、累加等场景，CAS更高效，常用于 <code>AtomicInteger</code>、<code>ConcurrentHashMap</code> 等类中。</li>
</ul>
</li>
<li><strong>乐观锁模型:</strong><ul>
<li>CAS采用乐观锁模型，假设大多数操作不会冲突，适用于读多写少的环境。</li>
</ul>
</li>
</ol>
<p><strong>何时选择 CAS 与 synchronized？</strong></p>
<ul>
<li><strong>用 CAS:</strong><ul>
<li>轻量级操作，如计数器、标志位更新。</li>
<li>高并发环境，避免锁竞争。</li>
</ul>
</li>
<li><strong>用 synchronized:</strong><ul>
<li>需要控制多个变量的一致性。</li>
<li>操作复杂，业务逻辑多，需要代码块级别的同步控制。</li>
</ul>
</li>
</ul>
<p>两者适用场景不同，不能简单互换。CAS适合轻量级、无锁的高性能操作，而<code>synchronized</code>适合更广泛、严格的同步需求。</p>
<hr>
<h3 id="2-7-CountDownLatch"><a href="#2-7-CountDownLatch" class="headerlink" title="2.7 CountDownLatch"></a>2.7 CountDownLatch</h3><h4 id="问：用过CountDownLatch么？什么场景下用的？"><a href="#问：用过CountDownLatch么？什么场景下用的？" class="headerlink" title="问：用过CountDownLatch么？什么场景下用的？"></a>问：用过CountDownLatch么？什么场景下用的？</h4><p><strong>CountDownLatch 概念</strong></p>
<p><code>CountDownLatch</code> 是 Java 并发包中的同步工具类，用于协调多个线程之间的执行。它允许一个或多个线程等待其他线程完成某些操作后再继续执行。</p>
<p><strong>CountDownLatch 的工作原理</strong></p>
<ul>
<li>它包含一个计数器，初始值由构造函数设定，如 <code>CountDownLatch(int count)</code>。</li>
<li>调用 <code>countDown()</code> 方法时，计数器递减。</li>
<li>调用 <code>await()</code> 方法的线程会阻塞，直到计数器变为零。</li>
</ul>
<p><strong>使用场景</strong></p>
<p><strong>1. 等待多个任务完成后执行操作</strong></p>
<ul>
<li><strong>示例:</strong> 主线程等待多个工作线程完成任务，然后合并结果。</li>
<li><strong>场景:</strong> 并行计算任务、批处理任务等。</li>
</ul>
<p><strong>2. 模拟并发测试</strong></p>
<ul>
<li><strong>示例:</strong> 模拟高并发环境，在所有线程准备好后同时执行操作。</li>
<li><strong>场景:</strong> 压力测试、负载测试。</li>
</ul>
<p><strong>3. 系统服务启动检查</strong></p>
<ul>
<li><strong>示例:</strong> 在启动主应用程序前，确保数据库、缓存服务等组件都已启动。</li>
<li><strong>场景:</strong> 系统初始化、依赖服务检查。</li>
</ul>
<p><strong>4. 任务分解与结果汇总</strong></p>
<ul>
<li><strong>示例:</strong> 将一个大任务分解为多个小任务，等所有小任务完成后汇总结果。</li>
<li><strong>场景:</strong> 文件处理、数据分片处理。</li>
</ul>
<p><strong>示例代码: 等待任务完成后执行</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.concurrent.CountDownLatch;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">CountDownLatchExample</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> taskCount = <span class="number">3</span>;</span><br><span class="line">        CountDownLatch latch = <span class="keyword">new</span> CountDownLatch(taskCount);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= taskCount; i++) &#123;</span><br><span class="line">            <span class="keyword">final</span> <span class="keyword">int</span> taskId = i;</span><br><span class="line">            <span class="keyword">new</span> Thread(() -&gt; &#123;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    System.out.println(<span class="string">&quot;任务 &quot;</span> + taskId + <span class="string">&quot; 正在执行...&quot;</span>);</span><br><span class="line">                    Thread.sleep((<span class="keyword">long</span>)(Math.random() * <span class="number">1000</span>));</span><br><span class="line">                    System.out.println(<span class="string">&quot;任务 &quot;</span> + taskId + <span class="string">&quot; 完成!&quot;</span>);</span><br><span class="line">                &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">                    latch.countDown();  <span class="comment">// 计数器递减</span></span><br><span class="line">                &#125;</span><br><span class="line">            &#125;).start();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        latch.await();  <span class="comment">// 等待所有任务完成</span></span><br><span class="line">        System.out.println(<span class="string">&quot;所有任务已完成，继续主线程执行...&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>CountDownLatch 的注意事项</strong></p>
<ol>
<li><strong>不可重用:</strong> <code>CountDownLatch</code> 一旦计数器变为零，就不能重置。如果需要重用，考虑使用 <code>CyclicBarrier</code>。</li>
<li><strong>线程安全:</strong> 内部使用 <code>AQS</code> 保证线程安全。</li>
<li><strong>适用单向同步:</strong> 如果需要线程之间多次同步，考虑使用 <code>CyclicBarrier</code> 或 <code>Phaser</code>。</li>
</ol>
<p><strong>总结:</strong></p>
<p><code>CountDownLatch</code> 适用于任务等待、启动检查和并发测试等场景，是实现线程同步的重要工具。</p>
<h4 id="问：什么是信号量Semaphore？应用场景？"><a href="#问：什么是信号量Semaphore？应用场景？" class="headerlink" title="问：什么是信号量Semaphore？应用场景？"></a>问：什么是信号量Semaphore？应用场景？</h4><p>信号量是一种固定资源的限制的一种并发工具包，基于AQS实现的，在构造的时候会设置一个值，代表着资源数量。信号量主要是应用于是用于多个共享资源的互斥使用，和用于并发线程数的控制（druid的数据库连接数，就是用这个实现的），信号量也分公平和非公平的情况，基本方式和reentrantLock差不多，在请求资源调用task时，会用自旋的方式减1，如果成功，则获取成功了，如果失败，导致资源数变为了0，就会加入队列里面去等待。调用release的时候会加一，补充资源,并唤醒等待队列。</p>
<blockquote>
<p>Semaphore 应用</p>
<ul>
<li>acquire（） release（） 可用于对象池，资源池的构建，比如静态全局对象池，数据库连接池；</li>
<li>可创建计数为1的S，作为互斥锁（二元信号量）</li>
</ul>
</blockquote>
<p><strong>信号量（Semaphore）概念</strong></p>
<p><code>Semaphore</code> 是 Java 并发包中的同步工具类，用于控制对共享资源的访问数量，维护一个许可计数。线程获取许可时计数减一，释放许可时计数加一。当计数为零时，获取许可的线程将被阻塞。</p>
<p><strong>Semaphore 的工作原理</strong></p>
<ul>
<li><strong>构造方法:</strong><ul>
<li><code>Semaphore(int permits)</code>：指定许可数量。</li>
<li><code>Semaphore(int permits, boolean fair)</code>：指定许可数量和公平性策略。</li>
</ul>
</li>
<li><strong>主要方法:</strong><ul>
<li><code>acquire()</code>：尝试获取一个许可，若没有可用许可，阻塞等待。</li>
<li><code>release()</code>：释放一个许可，增加计数。</li>
<li><code>tryAcquire()</code>：尝试立即获取一个许可，成功返回<code>true</code>，否则返回<code>false</code>。</li>
</ul>
</li>
</ul>
<p><strong>应用场景</strong></p>
<p><strong>1. 限制访问资源的线程数</strong></p>
<ul>
<li><strong>示例:</strong> 限制数据库连接池的最大连接数，避免资源过载。</li>
<li><strong>场景:</strong> 服务器连接池、线程池控制。</li>
</ul>
<p><strong>2. 流量控制与限流</strong></p>
<ul>
<li><strong>示例:</strong> 限制对API的请求数，控制并发请求。</li>
<li><strong>场景:</strong> 限流保护、高并发接口。</li>
</ul>
<p><strong>3. 多资源共享的访问控制</strong></p>
<ul>
<li><strong>示例:</strong> 控制停车场的车位数量，每次允许多个车辆进入停车场。</li>
<li><strong>场景:</strong> 资源池管理、存储容量管理。</li>
</ul>
<p><strong>4. 线程间同步</strong></p>
<ul>
<li><strong>示例:</strong> 线程之间按顺序执行，或在任务完成后释放许可。</li>
<li><strong>场景:</strong> 生产者-消费者模型中的同步控制。</li>
</ul>
<p><strong>示例代码: 停车场控制</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.concurrent.Semaphore;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ParkingLot</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> TOTAL_SPOTS = <span class="number">3</span>;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> Semaphore parkingSpots = <span class="keyword">new</span> Semaphore(TOTAL_SPOTS);</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= <span class="number">6</span>; i++) &#123;</span><br><span class="line">            <span class="keyword">final</span> <span class="keyword">int</span> carId = i;</span><br><span class="line">            <span class="keyword">new</span> Thread(() -&gt; &#123;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    System.out.println(<span class="string">&quot;车辆 &quot;</span> + carId + <span class="string">&quot; 等待进入停车场...&quot;</span>);</span><br><span class="line">                    parkingSpots.acquire();  <span class="comment">// 获取许可</span></span><br><span class="line">                    System.out.println(<span class="string">&quot;车辆 &quot;</span> + carId + <span class="string">&quot; 停入停车场...&quot;</span>);</span><br><span class="line">                    Thread.sleep((<span class="keyword">long</span>)(Math.random() * <span class="number">5000</span>));  <span class="comment">// 模拟停车时间</span></span><br><span class="line">                    System.out.println(<span class="string">&quot;车辆 &quot;</span> + carId + <span class="string">&quot; 离开停车场...&quot;</span>);</span><br><span class="line">                &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">                    parkingSpots.release();  <span class="comment">// 释放许可</span></span><br><span class="line">                &#125;</span><br><span class="line">            &#125;).start();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>Semaphore 的注意事项</strong></p>
<ol>
<li><strong>公平性:</strong> 非公平模式性能更高，适用于无严格先后要求的场景。</li>
<li><strong>许可证可重入:</strong> 信号量许可不是线程绑定的，任何线程都可以释放许可。</li>
<li><strong>使用场景:</strong> 避免资源过载，控制最大并发量，解决生产者-消费者模型中的资源分配问题。</li>
</ol>
<p><strong>总结:</strong></p>
<p><code>Semaphore</code> 在并发编程中是一个强大的工具，适用于资源控制、并发限流等场景，提供了灵活的许可管理机制，确保共享资源的高效利用与安全访问。</p>
<h4 id="问：用过CyclicBarrier吗？-和-countdownlatch-的区别？"><a href="#问：用过CyclicBarrier吗？-和-countdownlatch-的区别？" class="headerlink" title="问：用过CyclicBarrier吗？ 和 countdownlatch 的区别？"></a>问：用过CyclicBarrier吗？ 和 countdownlatch 的区别？</h4><p>个人理解 赛马和点火箭</p>
<blockquote>
<ul>
<li>con用于主线程等待其他子线程任务都执行完毕后再执行，cyc用于一组线程相互等待大家都达到某个状态后，再同时执行；</li>
<li>CountDownLatch是不可重用的，CyclicBarrier可重用</li>
</ul>
</blockquote>
<p>CountDownLatch是等待其他线程执行到某一个点的时候，在继续执行逻辑（子线程不会被阻塞，会继续执行），只能被使用一次。最常见的就是join形式，主线程等待子线程执行完任务，在用主线程去获取结果的方式（当然不一定），内部是用计数器相减实现的（没错，又特么是AQS），AQS的state承担了计数器的作用，初始化的时候，使用CAS赋值，主线程调用await（）则被加入共享线程等待队列里面，子线程调用countDown的时候，使用自旋的方式，减1，知道为0，就触发唤醒。</p>
<p>CyclicBarrier回环屏障，主要是等待一组线程到底同一个状态的时候，放闸。CyclicBarrier还可以传递一个Runnable对象，可以到放闸的时候，执行这个任务。CyclicBarrier是可循环的，当调用await的时候如果count变成0了则会重置状态，如何重置呢，CyclicBarrier新增了一个字段parties，用来保存初始值，当count变为0的时候，就重新赋值。还有一个不同点，CyclicBarrier不是基于AQS的，而是基于RentrantLock实现的。存放的等待队列是用了条件变量的方式。</p>
<p>在 <strong>Java 并发编程</strong> 中，<code>CountDownLatch</code>、<code>Semaphore</code> 和 <code>CyclicBarrier</code> 都是 <code>java.util.concurrent</code> 包提供的 <strong>线程同步工具</strong>，但它们的用途和实现机制有所不同。</p>
<p><strong>🔥 1. 核心区别对比</strong></p>
<table>
<thead>
<tr>
<th><strong>特性</strong></th>
<th><strong>CountDownLatch</strong></th>
<th><strong>Semaphore</strong></th>
<th><strong>CyclicBarrier</strong></th>
</tr>
</thead>
<tbody><tr>
<td><strong>主要用途</strong></td>
<td><strong>等待多个线程完成任务</strong>，然后继续执行</td>
<td><strong>限制并发访问的线程数</strong></td>
<td><strong>让一组线程互相等待，直到所有线程都到达屏障</strong></td>
</tr>
<tr>
<td><strong>计数器变化</strong></td>
<td><strong>只能减小，不能重置</strong></td>
<td><strong>支持增加和减少</strong></td>
<td><strong>达到阈值后可重置</strong>（可复用）</td>
</tr>
<tr>
<td><strong>是否可重用</strong></td>
<td><strong>❌ 不可重用</strong></td>
<td><strong>✅ 可重用</strong></td>
<td><strong>✅ 可重用</strong></td>
</tr>
<tr>
<td><strong>线程等待机制</strong></td>
<td><strong><code>await()</code> 等待计数器归零</strong></td>
<td><strong><code>acquire()</code> / <code>release()</code> 控制线程数</strong></td>
<td><strong>所有线程 <code>await()</code>，全部到达后一起执行</strong></td>
</tr>
<tr>
<td><strong>典型应用场景</strong></td>
<td><strong>主线程等待多个子任务完成</strong>（如 <code>join()</code> 替代）</td>
<td><strong>限流、控制并发量</strong>（如数据库连接池）</td>
<td><strong>多线程任务同步，如多线程计算最终合并结果</strong></td>
</tr>
</tbody></table>
<p><strong>✅ 2. CountDownLatch（倒计时器）</strong></p>
<p><strong>🔹 作用</strong></p>
<ul>
<li><strong>用于多个线程执行任务后，通知主线程继续执行</strong>。</li>
<li><strong>计数器只能递减，不能重置</strong>，用于 <strong>一次性事件</strong>。</li>
</ul>
<p><strong>🔹 使用场景</strong></p>
<ul>
<li><strong>主线程等待多个子线程完成</strong>（类似 <code>join()</code>）。</li>
<li><strong>并行任务，主线程等待所有任务完成后继续</strong>（如批处理任务）。</li>
</ul>
<p><strong>🔹 使用示例</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.concurrent.CountDownLatch;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">CountDownLatchExample</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> THREAD_COUNT = <span class="number">3</span>;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> CountDownLatch latch = <span class="keyword">new</span> CountDownLatch(THREAD_COUNT);</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; THREAD_COUNT; i++) &#123;</span><br><span class="line">            <span class="keyword">new</span> Thread(() -&gt; &#123;</span><br><span class="line">                System.out.println(Thread.currentThread().getName() + <span class="string">&quot; 执行任务&quot;</span>);</span><br><span class="line">                latch.countDown();  <span class="comment">// 计数器减1</span></span><br><span class="line">            &#125;).start();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        latch.await();  <span class="comment">// 等待所有任务完成</span></span><br><span class="line">        System.out.println(<span class="string">&quot;所有任务完成，主线程继续&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>🔹 结果</strong></p>
<figure class="highlight autohotkey"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">Thread</span>-<span class="number">0</span> 执行任务</span><br><span class="line"><span class="keyword">Thread</span>-<span class="number">1</span> 执行任务</span><br><span class="line"><span class="keyword">Thread</span>-<span class="number">2</span> 执行任务</span><br><span class="line">所有任务完成，主线程继续</span><br></pre></td></tr></table></figure>

<p><strong>🔹 关键方法</strong></p>
<table>
<thead>
<tr>
<th>方法</th>
<th>作用</th>
</tr>
</thead>
<tbody><tr>
<td><code>countDown()</code></td>
<td><strong>计数器 -1</strong>，当 <code>count == 0</code> 时，<code>await()</code> 解除阻塞</td>
</tr>
<tr>
<td><code>await()</code></td>
<td><strong>阻塞当前线程</strong>，直到计数器变为 <code>0</code></td>
</tr>
</tbody></table>
<p><strong>🔹 适用场景</strong></p>
<ul>
<li><strong>主线程等待多个任务完成</strong>（如批量任务）。</li>
<li><strong>多个线程同步启动</strong>（倒计时开始）。</li>
</ul>
<p><strong>✅ 3. Semaphore（信号量）</strong></p>
<p><strong>🔹 作用</strong></p>
<ul>
<li><strong>用于控制并发线程数</strong>，防止资源被过多线程占用（如数据库连接池）。</li>
<li>线程 <strong>acquire() 获取许可证</strong>，用完后 <strong>release() 归还许可证</strong>。</li>
</ul>
<p><strong>🔹 使用场景</strong></p>
<ul>
<li><strong>限流</strong>（最多 <code>N</code> 个线程访问某资源）。</li>
<li><strong>数据库连接池</strong>（控制最大连接数）。</li>
<li><strong>停车场</strong>（控制可停车辆数）。</li>
</ul>
<p><strong>🔹 使用示例</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.concurrent.Semaphore;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SemaphoreExample</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> Semaphore semaphore = <span class="keyword">new</span> Semaphore(<span class="number">2</span>); <span class="comment">// 允许 2 个线程同时执行</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">5</span>; i++) &#123;</span><br><span class="line">            <span class="keyword">new</span> Thread(() -&gt; &#123;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    semaphore.acquire();  <span class="comment">// 获取许可证</span></span><br><span class="line">                    System.out.println(Thread.currentThread().getName() + <span class="string">&quot; 获取资源&quot;</span>);</span><br><span class="line">                    Thread.sleep(<span class="number">2000</span>);</span><br><span class="line">                &#125; <span class="keyword">catch</span> (InterruptedException ignored) &#123;</span><br><span class="line">                &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">                    System.out.println(Thread.currentThread().getName() + <span class="string">&quot; 释放资源&quot;</span>);</span><br><span class="line">                    semaphore.release();  <span class="comment">// 释放许可证</span></span><br><span class="line">                &#125;</span><br><span class="line">            &#125;).start();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>🔹 结果</strong></p>
<figure class="highlight lasso"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">Thread</span><span class="number">-0</span> 获取资源</span><br><span class="line"><span class="keyword">Thread</span><span class="number">-1</span> 获取资源</span><br><span class="line"><span class="keyword">Thread</span><span class="number">-0</span> 释放资源</span><br><span class="line"><span class="keyword">Thread</span><span class="number">-2</span> 获取资源</span><br><span class="line"><span class="keyword">Thread</span><span class="number">-1</span> 释放资源</span><br><span class="line"><span class="keyword">Thread</span><span class="number">-3</span> 获取资源</span><br><span class="line"><span class="params">...</span></span><br></pre></td></tr></table></figure>

<p><strong>🔹 关键方法</strong></p>
<table>
<thead>
<tr>
<th>方法</th>
<th>作用</th>
</tr>
</thead>
<tbody><tr>
<td><code>acquire()</code></td>
<td><strong>获取许可证（阻塞等待）</strong></td>
</tr>
<tr>
<td><code>tryAcquire()</code></td>
<td><strong>尝试获取许可证（不阻塞）</strong></td>
</tr>
<tr>
<td><code>release()</code></td>
<td><strong>释放许可证</strong></td>
</tr>
</tbody></table>
<p><strong>🔹 适用场景</strong></p>
<ul>
<li><strong>限流、并发控制</strong>（数据库连接池、限流算法）。</li>
<li><strong>多个线程访问共享资源（如 I/O）</strong>。</li>
</ul>
<p><strong>✅ 4. CyclicBarrier（循环栅栏）</strong></p>
<p><strong>🔹 作用</strong></p>
<ul>
<li><strong>让一组线程相互等待，直到所有线程都到达屏障（Barrier）后再继续执行</strong>。</li>
<li><strong>可以重复使用</strong>，不像 <code>CountDownLatch</code> 只能用一次。</li>
</ul>
<p><strong>🔹 使用场景</strong></p>
<ul>
<li><strong>多线程计算，等待所有线程完成某个阶段后一起执行下一步</strong>。</li>
<li><strong>模拟多人游戏加载，所有玩家加载完毕后开始游戏</strong>。</li>
</ul>
<p><strong>🔹 使用示例</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.concurrent.BrokenBarrierException;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.CyclicBarrier;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">CyclicBarrierExample</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> THREAD_COUNT = <span class="number">3</span>;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> CyclicBarrier barrier = <span class="keyword">new</span> CyclicBarrier(THREAD_COUNT, () -&gt; &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;所有线程已到达，开始执行下一步&quot;</span>);</span><br><span class="line">    &#125;);</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; THREAD_COUNT; i++) &#123;</span><br><span class="line">            <span class="keyword">new</span> Thread(() -&gt; &#123;</span><br><span class="line">                System.out.println(Thread.currentThread().getName() + <span class="string">&quot; 准备就绪&quot;</span>);</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    barrier.await();  <span class="comment">// 等待所有线程到达</span></span><br><span class="line">                &#125; <span class="keyword">catch</span> (InterruptedException | BrokenBarrierException ignored) &#123;</span><br><span class="line">                &#125;</span><br><span class="line">                System.out.println(Thread.currentThread().getName() + <span class="string">&quot; 继续执行&quot;</span>);</span><br><span class="line">            &#125;).start();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>🔹 结果</strong></p>
<figure class="highlight autohotkey"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">Thread</span>-<span class="number">0</span> 准备就绪</span><br><span class="line"><span class="keyword">Thread</span>-<span class="number">1</span> 准备就绪</span><br><span class="line"><span class="keyword">Thread</span>-<span class="number">2</span> 准备就绪</span><br><span class="line">所有线程已到达，开始执行下一步</span><br><span class="line"><span class="keyword">Thread</span>-<span class="number">0</span> 继续执行</span><br><span class="line"><span class="keyword">Thread</span>-<span class="number">1</span> 继续执行</span><br><span class="line"><span class="keyword">Thread</span>-<span class="number">2</span> 继续执行</span><br></pre></td></tr></table></figure>

<p><strong>🔹 关键方法</strong></p>
<table>
<thead>
<tr>
<th>方法</th>
<th>作用</th>
</tr>
</thead>
<tbody><tr>
<td><code>await()</code></td>
<td><strong>等待所有线程到达屏障</strong></td>
</tr>
<tr>
<td><code>reset()</code></td>
<td><strong>重置屏障，允许再次使用</strong></td>
</tr>
</tbody></table>
<p><strong>🔹 适用场景</strong></p>
<ul>
<li><strong>多线程计算任务同步</strong>（如并行 MapReduce）。</li>
<li><strong>游戏多人匹配，等所有人准备好后开始</strong>。</li>
</ul>
<p><strong>✅ 5. 总结</strong></p>
<table>
<thead>
<tr>
<th>特性</th>
<th>CountDownLatch</th>
<th>Semaphore</th>
<th>CyclicBarrier</th>
</tr>
</thead>
<tbody><tr>
<td><strong>作用</strong></td>
<td>等待<strong>多个线程</strong>完成任务</td>
<td>控制<strong>并发线程数</strong></td>
<td>让一组线程<strong>互相等待</strong></td>
</tr>
<tr>
<td><strong>计数器变化</strong></td>
<td>只能递减，不能重置</td>
<td>可增减</td>
<td>可重置</td>
</tr>
<tr>
<td><strong>是否可重用</strong></td>
<td>❌ 否</td>
<td>✅ 是</td>
<td>✅ 是</td>
</tr>
<tr>
<td><strong>线程等待</strong></td>
<td><code>await()</code> 阻塞</td>
<td><code>acquire()</code> 获取，<code>release()</code> 释放</td>
<td><code>await()</code> 等待所有线程到达</td>
</tr>
<tr>
<td><strong>适用场景</strong></td>
<td><strong>主线程等待子任务完成</strong></td>
<td><strong>限流、并发控制</strong></td>
<td><strong>多线程同步等待</strong></td>
</tr>
</tbody></table>
<hr>
<p><strong>🎯 结论</strong></p>
<ul>
<li><strong><code>CountDownLatch</code><strong>：</strong>主线程等待多个任务完成</strong>（不可复用）。</li>
<li><strong><code>Semaphore</code><strong>：</strong>限流，控制并发线程数</strong>（类似令牌桶）。</li>
<li><strong><code>CyclicBarrier</code><strong>：</strong>线程相互等待，所有人准备好一起执行</strong>（可复用）。</li>
</ul>
<p>如果你在 <strong>面试 / 设计系统时</strong> 需要选择合适的并发工具，建议<strong>结合具体业务场景</strong>！🚀</p>
<p><strong>CyclicBarrier 概念</strong></p>
<p><code>CyclicBarrier</code> 是 Java 并发包中的同步工具类，用于让一组线程互相等待，直到所有线程到达屏障点（Barrier），然后继续执行。</p>
<ul>
<li><strong>“Cyclic”</strong> 表示它可以重复使用，适合需要多次同步的场景。</li>
<li>构造方法:<ul>
<li><code>CyclicBarrier(int parties)</code>：指定需要等待的线程数。</li>
<li><code>CyclicBarrier(int parties, Runnable barrierAction)</code>：在所有线程到达屏障点后执行指定任务。</li>
</ul>
</li>
</ul>
<p><strong>主要方法</strong></p>
<ul>
<li><strong><code>await()</code>：</strong><br> 每个线程调用此方法，表示到达屏障点。线程会阻塞，直到所有线程都调用了 <code>await()</code>，然后继续执行。</li>
</ul>
<p><strong>CyclicBarrier 和 CountDownLatch 的区别</strong></p>
<table>
<thead>
<tr>
<th><strong>特性</strong></th>
<th><strong>CyclicBarrier</strong></th>
<th><strong>CountDownLatch</strong></th>
</tr>
</thead>
<tbody><tr>
<td><strong>作用</strong></td>
<td>等待所有线程到达屏障点后再继续执行</td>
<td>一个或多个线程等待其他线程完成任务</td>
</tr>
<tr>
<td><strong>可重用性</strong></td>
<td>可重复使用</td>
<td>不可重复使用</td>
</tr>
<tr>
<td><strong>触发操作</strong></td>
<td>可指定一个屏障操作（<code>Runnable</code>），在屏障点执行</td>
<td>无触发操作</td>
</tr>
<tr>
<td><strong>线程数量控制</strong></td>
<td>必须指定固定数量的线程，所有线程都要到达屏障点</td>
<td>允许动态调整计数值</td>
</tr>
<tr>
<td><strong>适用场景</strong></td>
<td>多线程分阶段任务，需要同步点</td>
<td>等待任务完成后继续，或协调线程启动顺序</td>
</tr>
</tbody></table>
<p><strong>应用场景</strong></p>
<p><strong>1. 多线程分阶段计算</strong></p>
<ul>
<li>各线程完成各自的子任务后等待，所有线程都完成后再进入下一阶段。</li>
<li><strong>示例:</strong> 数据分片处理、分步任务调度。</li>
</ul>
<p><strong>2. 模拟多线程并发</strong></p>
<ul>
<li>所有线程同步启动，保证同时开始执行关键操作。</li>
<li><strong>示例:</strong> 性能测试工具中模拟并发场景。</li>
</ul>
<p><strong>3. 循环执行的任务协调</strong></p>
<ul>
<li>每个阶段结束后，重新开始下一阶段，直到任务完成。</li>
<li><strong>示例:</strong> 多回合比赛或分步算法。</li>
</ul>
<p><strong>示例代码: 数据分片处理</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.concurrent.CyclicBarrier;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">CyclicBarrierExample</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> numThreads = <span class="number">3</span>;</span><br><span class="line">        CyclicBarrier barrier = <span class="keyword">new</span> CyclicBarrier(numThreads, () -&gt; &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;所有线程已完成本阶段任务，继续下一阶段...&quot;</span>);</span><br><span class="line">        &#125;);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; numThreads; i++) &#123;</span><br><span class="line">            <span class="keyword">new</span> Thread(() -&gt; &#123;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    System.out.println(Thread.currentThread().getName() + <span class="string">&quot; 正在执行任务...&quot;</span>);</span><br><span class="line">                    Thread.sleep((<span class="keyword">long</span>) (Math.random() * <span class="number">1000</span>));  <span class="comment">// 模拟任务执行</span></span><br><span class="line">                    System.out.println(Thread.currentThread().getName() + <span class="string">&quot; 到达屏障点...&quot;</span>);</span><br><span class="line">                    barrier.await();  <span class="comment">// 等待其他线程</span></span><br><span class="line">                &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;).start();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>选择 CyclicBarrier 或 CountDownLatch</strong></p>
<ul>
<li><strong>选择 <code>CyclicBarrier</code>:</strong><ul>
<li>任务分阶段完成，线程需要重复同步。</li>
<li>需要在屏障点执行额外操作。</li>
</ul>
</li>
<li><strong>选择 <code>CountDownLatch</code>:</strong><ul>
<li>一次性任务，如主线程等待所有子线程完成后继续执行。</li>
<li>不需要重复使用同步机制。</li>
</ul>
</li>
</ul>
<p><strong>总结:</strong></p>
<ul>
<li><code>CyclicBarrier</code> 适用于循环同步或阶段性任务，线程必须同时到达屏障点才能继续执行。</li>
<li><code>CountDownLatch</code> 更适合一次性任务的线程协调，特别是主线程等待子线程完成时使用。<br> 根据具体需求选择工具，确保线程同步的效率和正确性。</li>
</ul>
<p><strong>CyclicBarrier 概念</strong></p>
<p><code>CyclicBarrier</code> 是 Java 并发包中的同步工具，用于让一组线程在执行到某个共同点时等待彼此，直到所有线程都到达该点后再继续执行。<code>Cyclic</code> 表示它可以被重用，线程到达屏障后，计数器会被重置。</p>
<p><strong>CyclicBarrier 的主要方法</strong></p>
<ul>
<li><strong>构造函数:</strong><ul>
<li><code>CyclicBarrier(int parties)</code>：指定等待的线程数量。</li>
<li><code>CyclicBarrier(int parties, Runnable barrierAction)</code>：在线程达到屏障时执行一个动作。</li>
</ul>
</li>
<li><strong>主要方法:</strong><ul>
<li><code>await()</code>：每个线程调用此方法，表示到达屏障。线程会阻塞，直到所有线程都到达。</li>
</ul>
</li>
</ul>
<p><strong>CyclicBarrier 示例代码</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.concurrent.CyclicBarrier;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">CyclicBarrierExample</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> threadCount = <span class="number">3</span>;</span><br><span class="line">        CyclicBarrier barrier = <span class="keyword">new</span> CyclicBarrier(threadCount, () -&gt; </span><br><span class="line">            System.out.println(<span class="string">&quot;所有线程到达屏障点，开始执行下一阶段任务...&quot;</span>)</span><br><span class="line">        );</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= threadCount; i++) &#123;</span><br><span class="line">            <span class="keyword">final</span> <span class="keyword">int</span> threadId = i;</span><br><span class="line">            <span class="keyword">new</span> Thread(() -&gt; &#123;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    System.out.println(<span class="string">&quot;线程 &quot;</span> + threadId + <span class="string">&quot; 正在执行任务...&quot;</span>);</span><br><span class="line">                    Thread.sleep((<span class="keyword">long</span>)(Math.random() * <span class="number">2000</span>));</span><br><span class="line">                    System.out.println(<span class="string">&quot;线程 &quot;</span> + threadId + <span class="string">&quot; 到达屏障点...&quot;</span>);</span><br><span class="line">                    barrier.await();  <span class="comment">// 等待其他线程</span></span><br><span class="line">                    System.out.println(<span class="string">&quot;线程 &quot;</span> + threadId + <span class="string">&quot; 继续执行...&quot;</span>);</span><br><span class="line">                &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;).start();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>CountDownLatch 与 CyclicBarrier 的区别</strong></p>
<table>
<thead>
<tr>
<th><strong>特性</strong></th>
<th><strong>CountDownLatch</strong></th>
<th><strong>CyclicBarrier</strong></th>
</tr>
</thead>
<tbody><tr>
<td><strong>主要功能</strong></td>
<td>等待其他线程完成任务后继续执行</td>
<td>等待线程之间互相到达屏障点</td>
</tr>
<tr>
<td><strong>线程数量</strong></td>
<td>指定计数，不能重用</td>
<td>可重用，自动重置</td>
</tr>
<tr>
<td><strong>计数递减方式</strong></td>
<td>调用 <code>countDown()</code> 递减计数</td>
<td>每个线程调用 <code>await()</code></td>
</tr>
<tr>
<td><strong>阻塞机制</strong></td>
<td>主线程等待其他线程完成</td>
<td>所有线程相互等待</td>
</tr>
<tr>
<td><strong>执行动作</strong></td>
<td>无附加操作</td>
<td>到达屏障时可执行动作</td>
</tr>
<tr>
<td><strong>适用场景</strong></td>
<td>任务完成等待、主线程汇总结果</td>
<td>多线程阶段性任务协调</td>
</tr>
</tbody></table>
<p><strong>选择使用场景</strong></p>
<p><strong>使用 CountDownLatch:</strong></p>
<ul>
<li>等待一组线程完成，主线程继续执行。</li>
<li>一次性使用，如任务汇总、服务启动检查等。</li>
</ul>
<p><strong>使用 CyclicBarrier:</strong></p>
<ul>
<li>多线程阶段性任务协调，线程之间需要互相等待。</li>
<li>多次使用的场景，如并行计算、循环任务调度等。</li>
</ul>
<p><strong>总结:</strong></p>
<ul>
<li><code>CountDownLatch</code> 适合 <strong>等待其他线程完成任务</strong>。</li>
<li><code>CyclicBarrier</code> 适合 <strong>线程之间的协作与同步</strong>，并且可以重用。选择时应根据应用程序的同步要求和执行模式进行选择。</li>
</ul>
<hr>
<h3 id="2-8-锁的应用"><a href="#2-8-锁的应用" class="headerlink" title="2.8 锁的应用"></a>2.8 锁的应用</h3><h4 id="问：ConcurrentHashMap的get需要加锁么，为什么？"><a href="#问：ConcurrentHashMap的get需要加锁么，为什么？" class="headerlink" title="问：ConcurrentHashMap的get需要加锁么，为什么？"></a>问：ConcurrentHashMap的get需要加锁么，为什么？</h4><p><strong>ConcurrentHashMap 的 <code>get()</code> 是否需要加锁？</strong></p>
<p><strong>结论:</strong><br> <code>ConcurrentHashMap</code> 的 <code>get()</code> 方法 <strong>不需要加锁</strong>，因为它是 <strong>线程安全的</strong>，在大多数实现中是 <strong>无锁的读操作</strong>。</p>
<p><strong>为什么 <code>get()</code> 不需要加锁？</strong></p>
<p><strong>1. 基于分段锁的实现 (JDK 1.7 及以前)</strong></p>
<ul>
<li><code>ConcurrentHashMap</code> 使用了 <strong>分段锁（Segment）</strong> 技术，将整个哈希表分为多个段（默认16段）。</li>
<li>每个段有独立的锁，<code>get()</code> 方法只需要找到对应段，直接读取，无需加锁。</li>
<li>只有 <code>put()</code> 和 <code>remove()</code> 等修改操作才会对段加锁。</li>
</ul>
<p><strong>2. 基于 CAS 和链表/红黑树 (JDK 1.8 及以后)</strong></p>
<ul>
<li>JDK 1.8 改进了 <code>ConcurrentHashMap</code>，摒弃了分段锁，采用了 <strong>CAS（Compare and Swap）</strong> 和 <strong>synchronized</strong> 结合的方式。</li>
<li><code>get()</code> 方法直接通过 <strong>volatile 修饰的 <code>Node</code> 数组</strong> 查找键值对，确保读取操作是可见的，无需加锁。</li>
<li>数据结构变为 <strong>数组 + 链表 + 红黑树</strong>，提高了查询效率。</li>
</ul>
<p><strong>为什么修改操作需要加锁？</strong></p>
<ul>
<li>修改操作（如 <code>put()</code>、<code>remove()</code>）涉及到哈希表的结构变化，如 <strong>扩容</strong>、<strong>节点插入</strong> 或 <strong>链表/树修改</strong>，需要锁或 CAS 来保证线程安全。</li>
<li>主要技术:<ul>
<li><strong>CAS:</strong> 用于节点插入，确保无锁下的原子性。</li>
<li><strong>synchronized:</strong> 用于链表或红黑树节点的修改，避免冲突。</li>
</ul>
</li>
</ul>
<p><strong>示例代码: 无锁 <code>get()</code> 操作</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.concurrent.ConcurrentHashMap;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ConcurrentHashMapExample</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        ConcurrentHashMap&lt;String, String&gt; map = <span class="keyword">new</span> ConcurrentHashMap&lt;&gt;();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 放入键值对</span></span><br><span class="line">        map.put(<span class="string">&quot;key1&quot;</span>, <span class="string">&quot;value1&quot;</span>);</span><br><span class="line">        map.put(<span class="string">&quot;key2&quot;</span>, <span class="string">&quot;value2&quot;</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 无锁获取操作</span></span><br><span class="line">        String value = map.get(<span class="string">&quot;key1&quot;</span>);</span><br><span class="line">        System.out.println(<span class="string">&quot;获取 key1 的值: &quot;</span> + value);  <span class="comment">// 输出: value1</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>总结:</strong></p>
<ul>
<li><code>ConcurrentHashMap.get()</code> 在 JDK 1.8 中是 <strong>无锁的</strong>，因为使用了 <strong>volatile</strong> 和 <strong>CAS</strong> 保证了可见性和一致性。</li>
<li>修改操作如 <code>put()</code>、<code>remove()</code> 则需要部分加锁，确保哈希表结构在高并发环境下的完整性。</li>
<li>因此，<code>get()</code> 方法在 <strong>多线程环境中无需加锁</strong>，高效且线程安全。</li>
</ul>
<h4 id="问：Hashtable-是怎么加锁的-？"><a href="#问：Hashtable-是怎么加锁的-？" class="headerlink" title="问：Hashtable 是怎么加锁的 ？"></a>问：Hashtable 是怎么加锁的 ？</h4><p><code>Hashtable</code> 是 Java 中一种 <strong>线程安全的</strong> <code>Map</code> 实现，通过对 <strong>整个方法加锁</strong> 来保证线程安全。</p>
<p><strong>加锁机制</strong></p>
<ol>
<li>同步方法 (<code>synchronized</code> 修饰)<ul>
<li><code>Hashtable</code> 的几乎所有方法（如 <code>put()</code>、<code>get()</code>、<code>remove()</code> 等）都用 <code>synchronized</code> 修饰，<strong>对方法级别加锁</strong>。</li>
<li>这意味着每次只能有一个线程执行这些方法，其他线程必须等待锁释放。</li>
</ul>
</li>
</ol>
<p><strong>示例代码 (源码片段)</strong></p>
<p><strong>1. <code>put()</code> 方法加锁示例</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> V <span class="title">put</span><span class="params">(K key, V value)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (key == <span class="keyword">null</span> || value == <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> NullPointerException();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span> hash = key.hashCode();</span><br><span class="line">    <span class="keyword">int</span> index = (hash &amp; <span class="number">0x7FFFFFFF</span>) % table.length;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (Entry&lt;K, V&gt; e = table[index]; e != <span class="keyword">null</span>; e = e.next) &#123;</span><br><span class="line">        <span class="keyword">if</span> ((e.hash == hash) &amp;&amp; e.key.equals(key)) &#123;</span><br><span class="line">            V oldValue = e.value;</span><br><span class="line">            e.value = value;</span><br><span class="line">            <span class="keyword">return</span> oldValue;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    addEntry(hash, key, value, index);</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>2. <code>get()</code> 方法加锁示例</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> V <span class="title">get</span><span class="params">(Object key)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> hash = key.hashCode();</span><br><span class="line">    <span class="keyword">int</span> index = (hash &amp; <span class="number">0x7FFFFFFF</span>) % table.length;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (Entry&lt;K, V&gt; e = table[index]; e != <span class="keyword">null</span>; e = e.next) &#123;</span><br><span class="line">        <span class="keyword">if</span> ((e.hash == hash) &amp;&amp; e.key.equals(key)) &#123;</span><br><span class="line">            <span class="keyword">return</span> e.value;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong><code>Hashtable</code> 加锁的缺点</strong></p>
<ol>
<li><strong>粒度过粗:</strong><ul>
<li>锁定整个方法，导致多个线程无法同时访问不同的键，<strong>并发性能较低</strong>。</li>
</ul>
</li>
<li><strong>阻塞操作:</strong><ul>
<li>如果一个线程持有锁，其他线程 <strong>必须阻塞等待</strong>，可能导致长时间等待。</li>
</ul>
</li>
<li><strong>锁竞争激烈:</strong><ul>
<li>在高并发环境下，多个线程频繁操作时，<strong>锁竞争激烈</strong>，性能下降明显。</li>
</ul>
</li>
</ol>
<p><strong>与 <code>ConcurrentHashMap</code> 的比较</strong></p>
<table>
<thead>
<tr>
<th><strong>特性</strong></th>
<th><strong>Hashtable</strong></th>
<th><strong>ConcurrentHashMap</strong></th>
</tr>
</thead>
<tbody><tr>
<td><strong>加锁机制</strong></td>
<td>方法级别加锁 (<code>synchronized</code>)</td>
<td>锁分段 (JDK 1.7) / CAS + 锁 (JDK 1.8)</td>
</tr>
<tr>
<td><strong>线程安全</strong></td>
<td>是</td>
<td>是</td>
</tr>
<tr>
<td><strong>性能</strong></td>
<td>低，在高并发下表现较差</td>
<td>高，在高并发下表现出色</td>
</tr>
<tr>
<td><strong>锁粒度</strong></td>
<td>整个方法</td>
<td>锁分段 / CAS 操作</td>
</tr>
<tr>
<td><strong>扩展性</strong></td>
<td>差，不适用于高并发场景</td>
<td>好，适用于高并发环境</td>
</tr>
</tbody></table>
<p><strong>总结:</strong></p>
<ul>
<li><code>Hashtable</code> 使用 <strong>方法级别的 <code>synchronized</code> 锁</strong> 实现线程安全。</li>
<li>在多线程场景下，<code>Hashtable</code> 的性能较差，锁粒度过粗，锁竞争激烈。</li>
<li>在高并发环境中，推荐使用 **<code>ConcurrentHashMap</code>**，其更细粒度的锁机制能够显著提高性能。</li>
</ul>
<hr>
<h2 id="三-内存模型"><a href="#三-内存模型" class="headerlink" title="三. 内存模型"></a>三. 内存模型</h2><h4 id="问：Java内存模型？为什么要有工作内存和主内存？"><a href="#问：Java内存模型？为什么要有工作内存和主内存？" class="headerlink" title="问：Java内存模型？为什么要有工作内存和主内存？"></a>问：Java内存模型？为什么要有工作内存和主内存？</h4><p>为什么要有工作内存和主内存：计算机随着技术发展CPU与内存速度差距越来越大，于是出现高速缓存技术存放CPU常用数据，其速度与CPU接近，多核多线程每个核都有自己的缓存区，所以面临着缓存一致性问题。Java内存模型主要为了解决这个问题。</p>
<p>所有的实例域、静态域和数组元素都存储在堆内存中，堆内存在线程之间共享。可以将它们看作共享变量。而局部变量，方法定义参数和异常处理器参数这些则不会在线程之间共享，它们不会有内存可见性问题，也不受内存模型的影响。</p>
<p>Java内存模型定义了线程和主内存之间的抽象关系：线程之间的共享变量存储在主内存（Main Memory）中，每个线程都有一个私有的本地内存（Local Memory），本地内存中存储了该线程以读/写共享变量的副本。本地内存是JMM(Java内存模型)的一个抽象概念，并不真实存在。它涵盖了缓存、写缓冲区、寄存器以及其他的硬件和编译器优化。</p>
<p>即三个规则：</p>
<ul>
<li>所有的数据都在主内存中。</li>
<li>每个线程都保留一份共享变量的副本。线程对变量的所有操作都必须在这个副本内存中进行，而不能直接读写主内存。</li>
<li>不同的线程之间也无法直接访问对方工作内存中的变量，线程间变量的传递均需要自己的工作内存和主存之间进行数据同步进行。</li>
</ul>
<p><strong>Java 内存模型 (Java Memory Model, JMM)</strong></p>
<p>Java 内存模型定义了 <strong>多线程环境下变量的可见性和有序性规则</strong>，规范了线程与内存之间的数据交互，确保 <strong>线程安全</strong> 和 <strong>内存一致性</strong>。</p>
<p><strong>为什么要有工作内存和主内存？</strong></p>
<p>在多线程环境下，<strong>工作内存（线程本地内存）</strong> 和 <strong>主内存（共享内存）</strong> 的设计是为了解决以下两个核心问题：</p>
<p><strong>1. 解决 CPU 缓存与内存的不一致性</strong></p>
<ul>
<li>现代计算机中，<strong>CPU 缓存</strong> 和 <strong>主内存</strong> 之间存在较大的访问速度差异。</li>
<li>使用 <strong>工作内存（CPU 缓存）</strong> 提高访问速度，同时通过 <strong>主内存</strong> 保证数据的一致性。</li>
</ul>
<p><strong>2. 保证线程间的数据隔离和共享</strong></p>
<ul>
<li><strong>工作内存:</strong> 每个线程有独立的内存区域，存储从主内存中加载的变量副本，避免线程间干扰。</li>
<li><strong>主内存:</strong> 所有线程共享的内存区域，存储全局变量和对象。</li>
</ul>
<p><strong>Java 内存模型结构</strong></p>
<figure class="highlight gherkin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">    +--------------------+</span><br><span class="line">    |<span class="string">      主内存        </span>|<span class="string">  (共享内存，存储所有对象实例)</span></span><br><span class="line"><span class="string">    +--------------------+</span></span><br><span class="line"><span class="string">          ^        ^</span></span><br><span class="line"><span class="string">          </span>|<span class="string">        </span>|</span><br><span class="line">+----------+    +----------+</span><br><span class="line">|<span class="string"> 工作内存  </span>|<span class="string">    </span>|<span class="string"> 工作内存  </span>|</span><br><span class="line">|<span class="string"> (线程A)  </span>|<span class="string">    </span>|<span class="string"> (线程B)  </span>|</span><br><span class="line">+----------+    +----------+</span><br></pre></td></tr></table></figure>

<p><strong>内存交互操作 (JVM 规范定义的8种操作)</strong></p>
<ol>
<li><strong><code>lock</code>（锁定）:</strong> 变量在主内存中标记为独占状态。</li>
<li><strong><code>unlock</code>（解锁）:</strong> 解除主内存中变量的锁定状态。</li>
<li><strong><code>read</code>（读取）:</strong> 从主内存读取变量值到工作内存。</li>
<li><strong><code>load</code>（加载）:</strong> 把从主内存读取到的值存入工作内存。</li>
<li><strong><code>use</code>（使用）:</strong> 从工作内存读取变量值用于计算。</li>
<li><strong><code>assign</code>（赋值）:</strong> 把值分配给工作内存中的变量。</li>
<li><strong><code>store</code>（存储）:</strong> 把工作内存的变量值传送到主内存。</li>
<li><strong><code>write</code>（写入）:</strong> 把存储的值更新到主内存。</li>
</ol>
<p><strong>关键问题: 为什么要有这两个内存？</strong></p>
<p><strong>1. 提高性能 (缓存机制)</strong></p>
<ul>
<li>主内存访问速度较慢，工作内存提高了 CPU 对内存的访问速度。</li>
</ul>
<p><strong>2. 支持多线程并发</strong></p>
<ul>
<li>工作内存为每个线程提供独立的变量副本，避免了线程间数据冲突。</li>
</ul>
<p><strong>3. 确保数据一致性 (内存可见性)</strong></p>
<ul>
<li>JMM 通过 <strong>内存屏障（Memory Barriers）</strong> 和 <strong>volatile</strong> 关键字，确保线程间数据的最新可见性。</li>
</ul>
<p><strong>内存模型中的核心问题</strong></p>
<p><strong>1. 可见性:</strong></p>
<ul>
<li>一个线程修改的变量，其他线程能否立即看到？</li>
<li>解决方案: <code>volatile</code>、<code>synchronized</code>、<code>final</code> 等。</li>
</ul>
<p><strong>2. 有序性:</strong></p>
<ul>
<li>指令执行的顺序是否与代码顺序一致？</li>
<li>解决方案: 内存屏障、指令重排序规则、<code>synchronized</code>、<code>volatile</code>。</li>
</ul>
<p><strong>3. 原子性:</strong></p>
<ul>
<li>操作是否不可分割，线程间是否能同时执行？</li>
<li>解决方案: <code>synchronized</code>、<code>Lock</code>、<code>Atomic</code> 类等。</li>
</ul>
<p><strong>示例: 可见性问题示例 (未加锁)</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Example</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">boolean</span> stop = <span class="keyword">false</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">        <span class="keyword">new</span> Thread(() -&gt; &#123;</span><br><span class="line">            <span class="keyword">while</span> (!stop) &#123;  <span class="comment">// 缓存读取，可能无法看到最新值</span></span><br><span class="line">            &#125;</span><br><span class="line">            System.out.println(<span class="string">&quot;线程结束&quot;</span>);</span><br><span class="line">        &#125;).start();</span><br><span class="line"></span><br><span class="line">        Thread.sleep(<span class="number">1000</span>);  <span class="comment">// 主线程睡眠</span></span><br><span class="line">        stop = <span class="keyword">true</span>;  <span class="comment">// 修改共享变量</span></span><br><span class="line">        System.out.println(<span class="string">&quot;主线程修改 stop = true&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>解决方案: 使用 <code>volatile</code> 关键字</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Example</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">volatile</span> <span class="keyword">boolean</span> stop = <span class="keyword">false</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">        <span class="keyword">new</span> Thread(() -&gt; &#123;</span><br><span class="line">            <span class="keyword">while</span> (!stop) &#123;</span><br><span class="line">            &#125;</span><br><span class="line">            System.out.println(<span class="string">&quot;线程结束&quot;</span>);</span><br><span class="line">        &#125;).start();</span><br><span class="line"></span><br><span class="line">        Thread.sleep(<span class="number">1000</span>);</span><br><span class="line">        stop = <span class="keyword">true</span>;  <span class="comment">// 保证主线程修改立即可见</span></span><br><span class="line">        System.out.println(<span class="string">&quot;主线程修改 stop = true&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>总结:</strong></p>
<ul>
<li><strong>主内存:</strong> 存储共享变量，所有线程可见。</li>
<li><strong>工作内存:</strong> 存储线程私有变量的副本，提升性能，避免频繁访问主内存。</li>
</ul>
<p>JMM 通过内存屏障、锁机制和 <code>volatile</code> 等关键字，确保多线程环境下的 <strong>可见性</strong>、<strong>有序性</strong> 和 <strong>原子性</strong>，实现高效、安全的并发编程。</p>

    </div>

    
    
    

    <footer class="post-footer">
          

<div class="post-copyright">
<ul>
  <li class="post-copyright-author">
      <strong>本文作者： </strong>Lys
  </li>
  <li class="post-copyright-link">
      <strong>本文链接：</strong>
      <a href="http://linyishui.top/2019102201.html" title="面试整理——Java并发编程">http://linyishui.top/2019102201.html</a>
  </li>
  <li class="post-copyright-license">
    <strong>版权声明： </strong>本博客所有文章除特别声明外，均采用 <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/deed.zh" rel="noopener" target="_blank"><i class="fab fa-fw fa-creative-commons"></i>BY-NC-SA</a> 许可协议。转载请注明出处！
  </li>
</ul>
</div>

          <div class="post-tags">
              <a href="/tags/Q-A/" rel="tag"><i class="fa fa-tag"></i> Q&A</a>
              <a href="/tags/updating/" rel="tag"><i class="fa fa-tag"></i> updating</a>
          </div>

        

          <div class="post-nav">
            <div class="post-nav-item">
                <a href="/2019102101.html" rel="prev" title="面试整理——Java集合">
                  <i class="fa fa-chevron-left"></i> 面试整理——Java集合
                </a>
            </div>
            <div class="post-nav-item">
                <a href="/2019102301.html" rel="next" title="面试整理——Web服务器">
                  面试整理——Web服务器 <i class="fa fa-chevron-right"></i>
                </a>
            </div>
          </div>
    </footer>
  </article>
</div>






    <div class="comments utterances-container"></div>
</div>
  </main>

  <footer class="footer">
    <div class="footer-inner">


<div class="copyright">
  &copy; 2018 – 
  <span itemprop="copyrightYear">2025</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">Lys</span>
</div>
<div class="wordcount">
  <span class="post-meta-item">
    <span class="post-meta-item-icon">
      <i class="fa fa-chart-line"></i>
    </span>
      <span>站点总字数：</span>
    <span title="站点总字数">5.4m</span>
  </span>
  <span class="post-meta-item">
    <span class="post-meta-item-icon">
      <i class="fa fa-coffee"></i>
    </span>
      <span>站点阅读时长 &asymp;</span>
    <span title="站点阅读时长">82:05</span>
  </span>
</div>
  <div class="powered-by">由 <a href="https://hexo.io/" rel="noopener" target="_blank">Hexo</a> & <a href="https://theme-next.js.org/pisces/" rel="noopener" target="_blank">NexT.Pisces</a> 强力驱动
  </div>

    </div>
  </footer>

  
  <script src="https://cdn.jsdelivr.net/npm/animejs@3.2.1/lib/anime.min.js" integrity="sha256-XL2inqUJaslATFnHdJOi9GfQ60on8Wx1C2H8DYiN1xY=" crossorigin="anonymous"></script>
  <script src="https://cdn.jsdelivr.net/npm/jquery@3.6.0/dist/jquery.min.js" integrity="sha256-/xUj+3OJU5yExlq6GSYGSHk7tPXikynS7ogEvDej/m4=" crossorigin="anonymous"></script>
  <script src="https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@3.5.7/dist/jquery.fancybox.min.js" integrity="sha256-yt2kYMy0w8AbtF89WXb2P1rfjcP/HTHLT7097U8Y5b8=" crossorigin="anonymous"></script>
<script src="/js/comments.js"></script><script src="/js/utils.js"></script><script src="/js/motion.js"></script><script src="/js/next-boot.js"></script><script src="/js/bookmark.js"></script>

  
<script src="/js/third-party/search/local-search.js"></script>



  <script class="next-config" data-name="nprogress" type="application/json">{"enable":true,"spinner":true}</script>
  <script src="/js/third-party/nprogress.js"></script>

  




<script src="https://cdn.jsdelivr.net/npm/darkmode-js@1.5.7/lib/darkmode-js.min.js"></script>

<script>
var options = {
  bottom: '64px',
  right: '32px',
  left: 'unset',
  time: '0.5s',
  mixColor: 'transparent',
  backgroundColor: 'transparent',
  buttonColorDark: '#100f2c',
  buttonColorLight: '#fff',
  saveInCookies: true,
  label: '🌓',
  autoMatchOsTheme: true
}
const darkmode = new Darkmode(options);
window.darkmode = darkmode;
darkmode.showWidget();
</script>
<script class="next-config" data-name="utterances" type="application/json">{"enable":true,"repo":"LAILAIWA/LAILAIWA.github.io","issue_term":"pathname","theme":"github-light"}</script>
<script src="/js/third-party/comments/utterances.js"></script>



</body>
</html>
