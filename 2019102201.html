<!DOCTYPE html>
<html lang="zh-CN">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width">
<meta name="theme-color" content="#222">
<meta name="generator" content="Hexo 5.4.0">


  <link rel="apple-touch-icon" sizes="180x180" href="/images/gamepad%20playstation.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/Dig%20Dug.ico">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/gamepad%20playstation.png">
  <link rel="mask-icon" href="/images/gamepad%20playstation.svg" color="#222">

<link rel="stylesheet" href="/css/main.css">

<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Monda:300,300italic,400,400italic,700,700italic%7CMa+Shan+Zheng:300,300italic,400,400italic,700,700italic%7CNoto+Serif+SC:300,300italic,400,400italic,700,700italic&display=swap&subset=latin,latin-ext">

<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free@5.15.3/css/all.min.css" integrity="sha256-2H3fkXt6FEmrReK448mDVGKb3WW2ZZw35gI7vqHOE4Y=" crossorigin="anonymous">
  <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/animate.css@3.1.1/animate.min.css" integrity="sha256-PR7ttpcvz8qrF57fur/yAx1qXMFJeJFiA6pSzWi0OIE=" crossorigin="anonymous">
  <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@3.5.7/dist/jquery.fancybox.min.css" integrity="sha256-Vzbj7sDDS/woiFS3uNKo8eIuni59rjyNGtXfstRzStA=" crossorigin="anonymous">
  <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/nprogress@0.2.0/nprogress.css" integrity="sha256-no0c5ccDODBwp+9hSmV5VvPpKwHCpbVzXHexIkupM6U=" crossorigin="anonymous">
  <script src="https://cdn.jsdelivr.net/npm/nprogress@0.2.0/nprogress.js" integrity="sha256-a5YRB27CcBwBFcT5EF/f3E4vzIqyHrSR878nseNYw64=" crossorigin="anonymous"></script>

<script class="next-config" data-name="main" type="application/json">{"hostname":"linyishui.top","root":"/","images":"/images","scheme":"Pisces","version":"8.6.0","exturl":false,"sidebar":{"position":"left","display":"always","padding":18,"offset":12},"copycode":true,"bookmark":{"enable":true,"color":"#222","save":"manual"},"fancybox":true,"mediumzoom":false,"lazyload":false,"pangu":false,"comments":{"style":"tabs","active":"utterances","storage":true,"lazyload":false,"nav":null,"activeClass":"utterances"},"motion":{"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"fadeInDown","post_body":"fadeInDown","coll_header":"fadeInLeft","sidebar":"fadeInUp"}},"prism":false,"i18n":{"placeholder":"搜索...","empty":"没有找到任何搜索结果：${query}","hits_time":"找到 ${hits} 个搜索结果（用时 ${time} 毫秒）","hits":"找到 ${hits} 个搜索结果"},"path":"/search.xml","localsearch":{"enable":true,"trigger":"auto","top_n_per_article":1,"unescape":false,"preload":false}}</script><script src="/js/config.js"></script>
<meta name="description" content="整理面试中常问的Java并发编程相关问题，持续更新中。">
<meta property="og:type" content="article">
<meta property="og:title" content="面试整理——Java并发编程">
<meta property="og:url" content="http://linyishui.top/2019102201.html">
<meta property="og:site_name" content="俺的部落格">
<meta property="og:description" content="整理面试中常问的Java并发编程相关问题，持续更新中。">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="https://pic-1258215793.cos.ap-shanghai.myqcloud.com/content/20190316/201903160104.jpg">
<meta property="og:image" content="https://pic-1258215793.cos.ap-shanghai.myqcloud.com/content/20190601/201906010120.png">
<meta property="article:published_time" content="2019-10-22T08:06:16.000Z">
<meta property="article:modified_time" content="2021-12-23T08:44:18.000Z">
<meta property="article:author" content="Lys">
<meta property="article:tag" content="Q&amp;A">
<meta property="article:tag" content="updating">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://pic-1258215793.cos.ap-shanghai.myqcloud.com/content/20190316/201903160104.jpg">


<link rel="canonical" href="http://linyishui.top/2019102201.html">



<script class="next-config" data-name="page" type="application/json">{"sidebar":"","isHome":false,"isPost":true,"lang":"zh-CN","comments":true,"permalink":"http://linyishui.top/2019102201.html","path":"2019102201.html","title":"面试整理——Java并发编程"}</script>

<script class="next-config" data-name="calendar" type="application/json">""</script>
<title>面试整理——Java并发编程 | 俺的部落格</title>
  




  <noscript>
    <link rel="stylesheet" href="/css/noscript.css">
  </noscript>
<link rel="alternate" href="/atom.xml" title="俺的部落格" type="application/atom+xml">
<style>.darkmode--activated{--body-bg-color:#282828;--content-bg-color:#333;--card-bg-color:#555;--text-color:#ccc;--blockquote-color:#bbb;--link-color:#ccc;--link-hover-color:#eee;--brand-color:#ddd;--brand-hover-color:#ddd;--table-row-odd-bg-color:#282828;--table-row-hover-bg-color:#363636;--menu-item-bg-color:#555;--btn-default-bg:#222;--btn-default-color:#ccc;--btn-default-border-color:#555;--btn-default-hover-bg:#666;--btn-default-hover-color:#ccc;--btn-default-hover-border-color:#666;--highlight-background:#282b2e;--highlight-foreground:#a9b7c6;--highlight-gutter-background:#34393d;--highlight-gutter-foreground:#9ca9b6}.darkmode--activated img{opacity:.75}.darkmode--activated img:hover{opacity:.9}.darkmode--activated code{color:#69dbdc;background:0 0}button.darkmode-toggle{z-index:9999}</style></head>

<body itemscope itemtype="http://schema.org/WebPage" class="use-motion">
  <div class="headband"></div>

  <main class="main">
    <header class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="切换导航栏" role="button">
        <span class="toggle-line"></span>
        <span class="toggle-line"></span>
        <span class="toggle-line"></span>
    </div>
  </div>

  <div class="site-meta">

    <a href="/" class="brand" rel="start">
      <i class="logo-line"></i>
      <h1 class="site-title">俺的部落格</h1>
      <i class="logo-line"></i>
    </a>
      <p class="site-subtitle" itemprop="description">俺寻思俺需要记点东西</p>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger">
        <i class="fa fa-search fa-fw fa-lg"></i>
    </div>
  </div>
</div>



<nav class="site-nav">
  <ul class="main-menu menu">
        <li class="menu-item menu-item-home"><a href="/" rel="section"><i class="fa fa-home fa-fw"></i>首页</a></li>
        <li class="menu-item menu-item-about"><a href="/about/" rel="section"><i class="fa fa-user fa-fw"></i>关于</a></li>
        <li class="menu-item menu-item-tags"><a href="/tags/" rel="section"><i class="fa fa-tags fa-fw"></i>标签</a></li>
        <li class="menu-item menu-item-categories"><a href="/categories/" rel="section"><i class="fa fa-th fa-fw"></i>分类</a></li>
        <li class="menu-item menu-item-archives"><a href="/archives/" rel="section"><i class="fa fa-archive fa-fw"></i>归档</a></li>
        <li class="menu-item menu-item-sitemap"><a href="/sitemap.xml" rel="section"><i class="fa fa-sitemap fa-fw"></i>站点地图</a></li>
        <li class="menu-item menu-item-tools"><a href="/links/" rel="section"><i class="fa fa-link fa-fw"></i>工具</a></li>
        <li class="menu-item menu-item-books"><a href="/books/" rel="section"><i class="fa fa-book fa-fw"></i>书架</a></li>
        <li class="menu-item menu-item-movies"><a href="/movies/" rel="section"><i class="fa fa-video fa-fw"></i>剧院</a></li>
        <li class="menu-item menu-item-games"><a href="/games/" rel="section"><i class="fa fa-gamepad fa-fw"></i>游戏</a></li>
        <li class="menu-item menu-item-commonweal"><a href="/404/" rel="section"><i class="fa fa-heartbeat fa-fw"></i>公益</a></li>
      <li class="menu-item menu-item-search">
        <a role="button" class="popup-trigger"><i class="fa fa-search fa-fw"></i>搜索
        </a>
      </li>
  </ul>
</nav>



  <div class="search-pop-overlay">
    <div class="popup search-popup"><div class="search-header">
  <span class="search-icon">
    <i class="fa fa-search"></i>
  </span>
  <div class="search-input-container">
    <input autocomplete="off" autocapitalize="off" maxlength="80"
           placeholder="搜索..." spellcheck="false"
           type="search" class="search-input">
  </div>
  <span class="popup-btn-close" role="button">
    <i class="fa fa-times-circle"></i>
  </span>
</div>
<div class="search-result-container no-result">
  <div class="search-result-icon">
    <i class="fa fa-spinner fa-pulse fa-5x"></i>
  </div>
</div>

    </div>
  </div>

</div>
        
  
  <div class="toggle sidebar-toggle" role="button">
    <span class="toggle-line"></span>
    <span class="toggle-line"></span>
    <span class="toggle-line"></span>
  </div>

  <aside class="sidebar">

    <div class="sidebar-inner sidebar-nav-active sidebar-toc-active">
      <ul class="sidebar-nav">
        <li class="sidebar-nav-toc">
          文章目录
        </li>
        <li class="sidebar-nav-overview">
          站点概览
        </li>
      </ul>

      <div class="sidebar-panel-container">
        <!--noindex-->
        <div class="post-toc-wrap sidebar-panel">
            <div class="post-toc animated"><ol class="nav"><li class="nav-item nav-level-1"><a class="nav-link" href="#Java%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B"><span class="nav-text">Java并发编程</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#%E4%B8%80-%E5%A4%9A%E7%BA%BF%E7%A8%8B"><span class="nav-text">一. 多线程</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#1-1-%E7%BA%BF%E7%A8%8B"><span class="nav-text">1.1 线程</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E9%97%AE%EF%BC%9A%E4%BB%80%E4%B9%88%E6%97%B6%E5%80%99%E7%94%A8%E7%BA%BF%E7%A8%8B%EF%BC%9F"><span class="nav-text">问：什么时候用线程？</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E9%97%AE%EF%BC%9A%E5%88%9B%E5%BB%BA%E5%A4%9A%E7%BA%BF%E7%A8%8B%E7%9A%84%E6%96%B9%E5%BC%8F%EF%BC%8C%E4%BB%A5%E5%8F%8A%E7%BA%BF%E7%A8%8B%E7%9A%84%E7%8A%B6%E6%80%81%E8%BD%AC%E6%8D%A2%EF%BC%9F"><span class="nav-text">问：创建多线程的方式，以及线程的状态转换？</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E9%97%AE%EF%BC%9A%E7%BB%88%E6%AD%A2%E7%BA%BF%E7%A8%8B%E7%9A%84%E6%96%B9%E6%B3%95%EF%BC%9F"><span class="nav-text">问：终止线程的方法？</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E9%97%AE%EF%BC%9A%E8%B0%88%E4%B8%80%E4%B8%8B%E7%BA%BF%E7%A8%8B%E5%88%87%E6%8D%A2%EF%BC%8C%E5%B9%B6%E5%BC%95%E7%94%B3%E5%88%B0Java%E9%98%BB%E5%A1%9E%EF%BC%8C%E8%BF%90%E8%A1%8C%EF%BC%9F"><span class="nav-text">问：谈一下线程切换，并引申到Java阻塞，运行？</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E9%97%AE%EF%BC%9A%E7%BA%BF%E7%A8%8B%E7%9A%84%E4%B8%AD%E6%96%AD%E6%9C%BA%E5%88%B6%EF%BC%9F"><span class="nav-text">问：线程的中断机制？</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E9%97%AE%EF%BC%9A%E6%80%8E%E4%B9%88%E5%AE%9E%E7%8E%B0%E6%89%80%E6%9C%89%E7%BA%BF%E7%A8%8B%E5%9C%A8%E7%AD%89%E5%BE%85%E6%9F%90%E4%B8%AA%E4%BA%8B%E4%BB%B6%E7%9A%84%E5%8F%91%E7%94%9F%E6%89%8D%E4%BC%9A%E5%8E%BB%E6%89%A7%E8%A1%8C%EF%BC%9F"><span class="nav-text">问：怎么实现所有线程在等待某个事件的发生才会去执行？</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E9%97%AE%EF%BC%9A%E5%A6%82%E4%BD%95%E5%AE%9E%E7%8E%B0%E6%8E%A7%E5%88%B6%E7%BA%BF%E7%A8%8B%E5%9C%A8%E6%9F%90%E6%AE%B5%E6%97%B6%E9%97%B4%E5%86%85%E5%AE%8C%E6%88%90%EF%BC%8C%E4%B8%8D%E5%AE%8C%E6%88%90%E5%B0%B1%E6%92%A4%E9%94%80%EF%BC%9F"><span class="nav-text">问：如何实现控制线程在某段时间内完成，不完成就撤销？</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E9%97%AE%EF%BC%9A%E7%BA%BF%E7%A8%8B%E5%9B%9E%E8%B0%83%EF%BC%9F"><span class="nav-text">问：线程回调？</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E9%97%AE%EF%BC%9ARPC-%E6%A1%86%E6%9E%B6%EF%BC%9F%E8%AE%BE%E8%AE%A1%E4%B8%80%E4%B8%AA-RPC%EF%BC%8C%E6%80%8E%E4%B9%88%E5%AE%9E%E7%8E%B0"><span class="nav-text">问：RPC 框架？设计一个 RPC，怎么实现</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E9%97%AE%EF%BC%9A%E7%BA%BF%E7%A8%8B%E9%97%B4%E7%9A%84%E9%80%9A%E4%BF%A1%E5%8F%AF%E4%BB%A5%E6%80%8E%E4%B9%88%E5%81%9A%EF%BC%9F%E7%BA%BF%E7%A8%8B%E9%97%B4%E7%9B%B8%E4%BA%92%E9%80%9A%E7%9F%A5%E4%BD%A0%E4%BC%9A%E6%80%8E%E4%B9%88%E5%81%9A%EF%BC%8C%E4%BB%A3%E7%A0%81%E8%A6%81%E6%80%8E%E4%B9%88%E5%AE%9E%E7%8E%B0%EF%BC%9F"><span class="nav-text">问：线程间的通信可以怎么做？线程间相互通知你会怎么做，代码要怎么实现？</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#1-2-ThreadLocal"><span class="nav-text">1.2 ThreadLocal</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E9%97%AE%EF%BC%9A%E8%B0%88%E4%B8%80%E4%B8%8BThreadLocal%EF%BC%9F%E5%BA%94%E7%94%A8%E5%9C%BA%E6%99%AF%EF%BC%9F%E5%8E%9F%E7%90%86%EF%BC%9F%E4%B8%8E-Thread-%E7%B1%BB%E7%9A%84%E5%85%B3%E7%B3%BB%EF%BC%9F"><span class="nav-text">问：谈一下ThreadLocal？应用场景？原理？与 Thread 类的关系？</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E9%97%AE%EF%BC%9Astatic-%E8%83%BD%E4%B8%8D%E8%83%BD%E4%BF%AE%E9%A5%B0-ThreadLocal%EF%BC%9F"><span class="nav-text">问：static 能不能修饰 ThreadLocal？</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E9%97%AE%EF%BC%9A%E8%B0%88%E4%B8%80%E4%B8%8BThreadLocal%E7%9A%84%E5%86%85%E5%AD%98%E6%B3%84%E6%BC%8F%E9%97%AE%E9%A2%98%EF%BC%9F"><span class="nav-text">问：谈一下ThreadLocal的内存泄漏问题？</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E9%97%AE%EF%BC%9A%E5%A6%82%E6%9E%9C%E6%88%91%E4%BB%AC%E8%A6%81%E8%8E%B7%E5%8F%96%E7%88%B6%E7%BA%BF%E7%A8%8B%E7%9A%84ThreadLocal%E5%80%BC%E5%91%A2%EF%BC%9F"><span class="nav-text">问：如果我们要获取父线程的ThreadLocal值呢？</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#1-3-Thread"><span class="nav-text">1.3 Thread</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E9%97%AE%EF%BC%9AThread%E7%B1%BB%E9%87%8C%E6%9C%89%E5%93%AA%E4%BA%9B%E5%B8%B8%E7%94%A8%E6%96%B9%E6%B3%95%EF%BC%9F"><span class="nav-text">问：Thread类里有哪些常用方法？</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E9%97%AE%EF%BC%9Ainterrupt-isInterrupted-interrupt%E5%8C%BA%E5%88%AB%EF%BC%9F"><span class="nav-text">问：interrupt&#x2F;isInterrupted&#x2F;interrupt区别？</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E9%97%AE%EF%BC%9A%E8%B0%88%E4%B8%80%E4%B8%8Bstart%E5%92%8Crun%E6%96%B9%E6%B3%95%E7%9A%84%E5%8C%BA%E5%88%AB%EF%BC%9F"><span class="nav-text">问：谈一下start和run方法的区别？</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E9%97%AE%EF%BC%9Asleep-%E5%92%8C-wait-%E6%9C%89%E4%BB%80%E4%B9%88%E5%8C%BA%E5%88%AB%EF%BC%9F"><span class="nav-text">问：sleep 和 wait 有什么区别？</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E9%97%AE%EF%BC%9Asleep-%E5%92%8C-yeild-%E6%96%B9%E6%B3%95%E6%9C%89%E4%BB%80%E4%B9%88%E5%8C%BA%E5%88%AB%EF%BC%9F"><span class="nav-text">问：sleep 和 yeild 方法有什么区别？</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#1-4-%E7%BA%BF%E7%A8%8B%E6%B1%A0"><span class="nav-text">1.4 线程池</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E9%97%AE%EF%BC%9A%E9%A1%B9%E7%9B%AE%E7%9A%84%E7%94%A8%E6%88%B7%E9%87%8F%E5%A4%9A%E5%90%97%EF%BC%9F%E6%9C%89%E7%94%A8%E8%BF%87%E7%BA%BF%E7%A8%8B%E6%B1%A0%E5%90%97%EF%BC%9F%E7%94%A8%E5%88%B0%E5%A4%9A%E7%BA%BF%E7%A8%8B%E7%9A%84%E4%BC%98%E5%8A%BF%E5%9C%A8%E5%93%AA%EF%BC%9F"><span class="nav-text">问：项目的用户量多吗？有用过线程池吗？用到多线程的优势在哪？</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E9%97%AE%EF%BC%9AThreadPoolExecutor-%E5%88%9D%E5%A7%8B%E5%8C%96%E5%8F%82%E6%95%B0%EF%BC%9F"><span class="nav-text">问：ThreadPoolExecutor 初始化参数？</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E9%97%AE%EF%BC%9A%E7%BA%BF%E7%A8%8B%E7%8A%B6%E6%80%81%EF%BC%9F"><span class="nav-text">问：线程状态？</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E9%97%AE%EF%BC%9AcorepoolSize-%E6%80%8E%E4%B9%88%E8%AE%BE%E7%BD%AE%EF%BC%8Cmaxpoolsize-%E6%80%8E%E4%B9%88%E8%AE%BE%E7%BD%AE%EF%BC%8Ckeep-alive-%E5%90%84%E7%A7%8D%E7%9A%84%EF%BC%9F"><span class="nav-text">问：corepoolSize 怎么设置，maxpoolsize 怎么设置，keep-alive 各种的？</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E9%97%AE%EF%BC%9A%E9%98%BB%E5%A1%9E%E9%98%9F%E5%88%97%E5%9C%A8%E7%94%9F%E4%BA%A7%E4%B8%AD%E7%9A%84%E8%AE%BE%E7%BD%AE%EF%BC%9F"><span class="nav-text">问：阻塞队列在生产中的设置？</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E9%97%AE%EF%BC%9AJava%E4%B8%AD%E7%9A%84%E7%BA%BF%E7%A8%8B%E6%B1%A0%E6%98%AF%E5%A6%82%E4%BD%95%E5%AE%9E%E7%8E%B0%E7%9A%84%EF%BC%9F%E8%AE%B2%E4%B8%80%E4%B8%8B%E7%BA%BF%E7%A8%8B%E6%B1%A0%E7%9A%84%E5%8E%9F%E7%90%86%EF%BC%9F"><span class="nav-text">问：Java中的线程池是如何实现的？讲一下线程池的原理？</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E9%97%AE%EF%BC%9A%E5%A6%82%E6%9E%9C%E7%BA%BF%E7%A8%8B%E6%B1%A0%E4%B8%AD%E7%9A%84%E4%B8%80%E4%B8%AA%E7%BA%BF%E7%A8%8B%E8%BF%90%E8%A1%8C%E6%97%B6%E5%87%BA%E7%8E%B0%E4%BA%86%E5%BC%82%E5%B8%B8%EF%BC%8C%E4%BC%9A%E5%8F%91%E7%94%9F%E4%BB%80%E4%B9%88%EF%BC%9F"><span class="nav-text">问：如果线程池中的一个线程运行时出现了异常，会发生什么？</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E9%97%AE%EF%BC%9A%E8%AE%B2%E4%B8%80%E4%B8%8B%E7%BA%BF%E7%A8%8B%E6%B1%A0%E7%9A%84%E5%8E%9F%E7%90%86%EF%BC%9F"><span class="nav-text">问：讲一下线程池的原理？</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E9%97%AE%EF%BC%9A%E5%A6%82%E4%BD%95%E5%AE%9E%E7%8E%B0%E4%B8%80%E4%B8%AA%E7%BA%BF%E7%A8%8B%E6%B1%A0%EF%BC%8CJava%E4%B8%AD%E7%BA%BF%E7%A8%8B%E6%B1%A0%E5%A6%82%E4%BD%95%E8%BF%9B%E8%A1%8C%E9%85%8D%E7%BD%AE%EF%BC%9F%E7%BA%BF%E7%A8%8B%E6%B1%A0%E7%9A%84%E7%BA%BF%E7%A8%8B%E6%95%B0%E6%80%8E%E4%B9%88%E7%A1%AE%E5%AE%9A%EF%BC%9F"><span class="nav-text">问：如何实现一个线程池，Java中线程池如何进行配置？线程池的线程数怎么确定？</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E9%97%AE%EF%BC%9A%E5%A6%82%E4%BD%95%E5%AE%9E%E7%8E%B0%E4%B8%80%E4%B8%AA%E7%BA%BF%E7%A8%8B%E6%B1%A0%EF%BC%8CJava%E4%B8%AD%E7%BA%BF%E7%A8%8B%E6%B1%A0%E5%A6%82%E4%BD%95%E8%BF%9B%E8%A1%8C%E9%85%8D%E7%BD%AE%EF%BC%9F%E7%BA%BF%E7%A8%8B%E6%B1%A0%E7%9A%84%E6%A0%B8%E5%BF%83%E5%8F%82%E6%95%B0%E8%AE%B0%E5%BE%97%E5%90%97%EF%BC%9F%E7%BA%BF%E7%A8%8B%E6%B1%A0%E7%9A%84%E5%B7%A5%E4%BD%9C%E6%B5%81%E7%A8%8B%E8%AE%B0%E5%BE%97%E5%90%97%EF%BC%9F"><span class="nav-text">问：如何实现一个线程池，Java中线程池如何进行配置？线程池的核心参数记得吗？线程池的工作流程记得吗？</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E9%97%AE%EF%BC%9A%E7%BA%BF%E7%A8%8B%E6%B1%A0%E9%87%8C%E5%A6%82%E4%BD%95%E7%9F%A5%E9%81%93%E7%BA%BF%E7%A8%8B%E6%89%A7%E8%A1%8C%E5%AE%8C%E4%BA%86%E6%B2%A1%E6%9C%89%EF%BC%9F%E7%BA%BF%E7%A8%8B%E9%98%BB%E5%A1%9E%E6%80%8E%E4%B9%88%E5%8A%9E%EF%BC%9F%E6%80%8E%E4%B9%88%E4%BF%9D%E8%AF%81%E6%89%80%E6%9C%89%E7%BA%BF%E7%A8%8B%E6%89%A7%E8%A1%8C%E5%AE%8C%E4%B9%8B%E5%90%8E%E7%BB%A7%E7%BB%AD%E5%BE%80%E4%B8%8B%E5%A4%84%E7%90%86%EF%BC%9F%E6%80%8E%E4%B9%88%E8%AE%A9%E4%B8%80%E4%B8%AA%E7%BA%BF%E7%A8%8B%E7%AD%89%E5%8F%A6%E4%B8%80%E4%B8%AA%E7%BA%BF%E7%A8%8B%E6%89%A7%E8%A1%8C%E7%BB%93%E6%9D%9F%EF%BC%9F"><span class="nav-text">问：线程池里如何知道线程执行完了没有？线程阻塞怎么办？怎么保证所有线程执行完之后继续往下处理？怎么让一个线程等另一个线程执行结束？</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E9%97%AE%EF%BC%9AJava-%E7%9A%84%E4%BF%A1%E5%8F%B7%E7%81%AF%EF%BC%9F"><span class="nav-text">问：Java 的信号灯？</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E9%97%AE%EF%BC%9AExecutors-%E9%9D%99%E6%80%81%E6%96%B9%E6%B3%95%EF%BC%9F"><span class="nav-text">问：Executors 静态方法？</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E9%97%AE%EF%BC%9A%E6%8B%92%E7%BB%9D%E7%AD%96%E7%95%A5%EF%BC%9F"><span class="nav-text">问：拒绝策略？</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E9%97%AE%EF%BC%9AnewFixedThreadPool-%EF%BC%88%E5%9B%BA%E5%AE%9A%E6%95%B0%E7%9B%AE%E7%BA%BF%E7%A8%8B%E7%9A%84%E7%BA%BF%E7%A8%8B%E6%B1%A0%EF%BC%89%EF%BC%9F"><span class="nav-text">问：newFixedThreadPool （固定数目线程的线程池）？</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E9%97%AE%EF%BC%9AnewCachedThreadPool%EF%BC%88%E5%8F%AF%E7%BC%93%E5%AD%98%E7%BA%BF%E7%A8%8B%E7%9A%84%E7%BA%BF%E7%A8%8B%E6%B1%A0%EF%BC%89%EF%BC%9F"><span class="nav-text">问：newCachedThreadPool（可缓存线程的线程池）？</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E9%97%AE%EF%BC%9AnewSingleThreadExecutor%EF%BC%88%E5%8D%95%E7%BA%BF%E7%A8%8B%E7%9A%84%E7%BA%BF%E7%A8%8B%E6%B1%A0%EF%BC%89%EF%BC%9F"><span class="nav-text">问：newSingleThreadExecutor（单线程的线程池）？</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E9%97%AE%EF%BC%9AnewScheduledThreadPool%EF%BC%88%E5%AE%9A%E6%97%B6%E5%8F%8A%E5%91%A8%E6%9C%9F%E6%89%A7%E8%A1%8C%E7%9A%84%E7%BA%BF%E7%A8%8B%E6%B1%A0%EF%BC%89%EF%BC%9F"><span class="nav-text">问：newScheduledThreadPool（定时及周期执行的线程池）？</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#1-5-%E7%BA%BF%E7%A8%8B%E5%AE%89%E5%85%A8"><span class="nav-text">1.5 线程安全</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E9%97%AE%EF%BC%9A%E8%B0%88%E4%B8%80%E4%B8%8B%E5%AF%B9%E7%BA%BF%E7%A8%8B%E5%AE%89%E5%85%A8%E7%9A%84%E7%90%86%E8%A7%A3%EF%BC%9F%E7%94%A8%E4%BB%80%E4%B9%88%E6%96%B9%E6%B3%95%E4%BF%9D%E8%AF%81%E7%BA%BF%E7%A8%8B%E7%9A%84%E5%AE%89%E5%85%A8%EF%BC%9F"><span class="nav-text">问：谈一下对线程安全的理解？用什么方法保证线程的安全？</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E9%97%AE%EF%BC%9A%E5%A6%82%E4%BD%95%E7%BA%BF%E7%A8%8B%E5%AE%89%E5%85%A8%E7%9A%84%E5%AE%9E%E7%8E%B0%E4%B8%80%E4%B8%AA%E8%AE%A1%E6%95%B0%E5%99%A8%EF%BC%9F"><span class="nav-text">问：如何线程安全的实现一个计数器？</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E9%97%AE%EF%BC%9A%E8%AF%B7%E5%86%99%E4%B8%80%E4%B8%AA%E7%BA%BF%E7%A8%8B%E5%AE%89%E5%85%A8%E7%9A%84%E5%8D%95%E4%BE%8B%E6%A8%A1%E5%BC%8F%EF%BC%9F"><span class="nav-text">问：请写一个线程安全的单例模式？</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E9%97%AE%EF%BC%9A%E5%8D%95%E4%BE%8B%E6%A8%A1%E5%BC%8F%EF%BC%8C%E9%A5%BF%E6%B1%89%E5%BC%8F%EF%BC%8C%E6%87%92%E6%B1%89%E5%BC%8F%EF%BC%8C%E7%BA%BF%E7%A8%8B%E5%AE%89%E5%85%A8%E7%9A%84%E5%81%9A%E6%B3%95%EF%BC%8C%E4%B8%A4%E6%AC%A1%E5%88%A4%E6%96%AD-instance-%E6%98%AF%E5%90%A6%E4%B8%BA%E7%A9%BA%EF%BC%8C%E6%AF%8F%E6%AC%A1%E5%88%A4%E6%96%AD%E7%9A%84%E4%BD%9C%E7%94%A8%E6%98%AF%E4%BB%80%E4%B9%88%EF%BC%9F"><span class="nav-text">问：单例模式，饿汉式，懒汉式，线程安全的做法，两次判断 instance 是否为空，每次判断的作用是什么？</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E9%97%AE%EF%BC%9AABC-%E4%B8%89%E4%B8%AA%E7%BA%BF%E7%A8%8B%E5%A6%82%E4%BD%95%E4%BF%9D%E8%AF%81%E9%A1%BA%E5%BA%8F%E6%89%A7%E8%A1%8C%EF%BC%9F"><span class="nav-text">问：ABC 三个线程如何保证顺序执行？</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E9%97%AE%EF%BC%9A%E7%94%9F%E4%BA%A7%E8%80%85%E6%B6%88%E8%B4%B9%E8%80%85%E6%A8%A1%E5%BC%8F%E7%9A%84%E5%AE%9E%E7%8E%B0%E6%96%B9%E5%BC%8F%EF%BC%9F"><span class="nav-text">问：生产者消费者模式的实现方式？</span></a></li></ol></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E4%BA%8C-%E9%94%81"><span class="nav-text">二. 锁</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#2-1-%E9%94%81"><span class="nav-text">2.1 锁</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E9%97%AE%EF%BC%9A%E8%AE%B2%E8%AE%B2%E4%BD%A0%E7%9F%A5%E9%81%93%E7%9A%84%E9%94%81%EF%BC%9F%E9%94%81%E7%9A%84%E5%87%A0%E7%A7%8D%E7%89%B9%E6%80%A7%EF%BC%9F"><span class="nav-text">问：讲讲你知道的锁？锁的几种特性？</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E9%97%AE%EF%BC%9A%E5%85%AC%E5%B9%B3%E9%94%81%E4%B8%8E%E9%9D%9E%E5%85%AC%E5%B9%B3%E9%94%81%EF%BC%9F"><span class="nav-text">问：公平锁与非公平锁？</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E9%97%AE%EF%BC%9A%E7%8B%AC%E5%8D%A0%E9%94%81%E4%B8%8E%E5%85%B1%E4%BA%AB%E9%94%81%EF%BC%9F"><span class="nav-text">问：独占锁与共享锁？</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E9%97%AE%EF%BC%9A%E5%8F%AF%E9%87%8D%E5%85%A5%E9%94%81%E6%A6%82%E5%BF%B5%EF%BC%9F"><span class="nav-text">问：可重入锁概念？</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E9%97%AE%EF%BC%9A%E8%AE%B2%E8%AE%B24%E7%A7%8D%E9%94%81%E7%8A%B6%E6%80%81%EF%BC%9F"><span class="nav-text">问：讲讲4种锁状态？</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E9%97%AE%EF%BC%9A%E8%BD%BB%E9%87%8F%E7%BA%A7%E9%94%81%E4%B8%8E%E5%81%8F%E5%90%91%E9%94%81%E7%9A%84%E5%8C%BA%E5%88%AB%EF%BC%9F"><span class="nav-text">问：轻量级锁与偏向锁的区别？</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E9%97%AE%EF%BC%9A%E8%87%AA%E6%97%8B%E9%94%81%E5%8D%87%E7%BA%A7%E5%88%B0%E9%87%8D%E9%87%8F%E7%BA%A7%E9%94%81%E6%9D%A1%E4%BB%B6%EF%BC%9F"><span class="nav-text">问：自旋锁升级到重量级锁条件？</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E9%97%AE%EF%BC%9A%E8%AE%B2%E8%AE%B2%E8%AF%BB%E5%86%99%E9%94%81%EF%BC%9F%E4%BC%98%E7%82%B9%EF%BC%9F%E5%AE%9E%E7%8E%B0%E6%96%B9%E5%BC%8F%EF%BC%9F"><span class="nav-text">问：讲讲读写锁？优点？实现方式？</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E9%97%AE%EF%BC%9A%E4%B9%90%E8%A7%82%E9%94%81%E5%92%8C%E6%82%B2%E8%A7%82%E9%94%81%E7%9A%84%E5%8C%BA%E5%88%AB%EF%BC%9F%E4%BC%98%E7%BC%BA%E7%82%B9%EF%BC%9F%E4%BD%BF%E7%94%A8%E5%9C%BA%E6%99%AF%EF%BC%9FJDK%E4%B8%AD%E6%B6%89%E5%8F%8A%E5%88%B0%E4%B9%90%E8%A7%82%E9%94%81%E5%92%8C%E6%82%B2%E8%A7%82%E9%94%81%E7%9A%84%E5%86%85%E5%AE%B9%EF%BC%9F%E8%BF%99%E4%B8%A4%E7%A7%8D%E9%94%81%E5%9C%A8Java%E5%92%8CMySQL%E5%88%86%E5%88%AB%E6%98%AF%E6%80%8E%E4%B9%88%E5%AE%9E%E7%8E%B0%E7%9A%84%EF%BC%9FMySql%E7%9A%84%E6%82%B2%E8%A7%82%E9%94%81%E6%80%8E%E4%B9%88%E9%98%B2%E6%AD%A2%E5%B9%B6%E5%8F%91%EF%BC%9F"><span class="nav-text">问：乐观锁和悲观锁的区别？优缺点？使用场景？JDK中涉及到乐观锁和悲观锁的内容？这两种锁在Java和MySQL分别是怎么实现的？MySql的悲观锁怎么防止并发？</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E9%97%AE%EF%BC%9A%E6%AD%BB%E9%94%81%E4%BA%A7%E7%94%9F%E7%9A%84%E5%8E%9F%E5%9B%A0%EF%BC%9F%E5%A6%82%E4%BD%95%E9%A2%84%E9%98%B2%EF%BC%9F%E6%AD%BB%E9%94%81%E7%9A%84%E6%9D%A1%E4%BB%B6%EF%BC%8C%E6%80%8E%E4%B9%88%E8%A7%A3%E9%99%A4%E6%AD%BB%E9%94%81%EF%BC%8C%E6%80%8E%E4%B9%88%E8%A7%82%E6%B5%8B%E6%AD%BB%E9%94%81%EF%BC%9F"><span class="nav-text">问：死锁产生的原因？如何预防？死锁的条件，怎么解除死锁，怎么观测死锁？</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E9%97%AE%EF%BC%9A%E5%8A%A0%E9%94%81%E4%BC%9A%E5%B8%A6%E6%9D%A5%E5%93%AA%E4%BA%9B%E6%80%A7%E8%83%BD%E9%97%AE%E9%A2%98%E3%80%82%E5%A6%82%E4%BD%95%E8%A7%A3%E5%86%B3%EF%BC%9F"><span class="nav-text">问：加锁会带来哪些性能问题。如何解决？</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E9%97%AE%EF%BC%9A%E5%81%8F%E5%90%91%E9%94%81%E3%80%81%E8%BD%BB%E9%87%8F%E7%BA%A7%E9%94%81%E3%80%81%E8%87%AA%E6%97%8B%E9%94%81%E7%AD%89%E4%BC%98%E5%8C%96%EF%BC%9F"><span class="nav-text">问：偏向锁、轻量级锁、自旋锁等优化？</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E9%97%AE%EF%BC%9A%E4%BA%8B%E5%8A%A1%E6%9C%89%E5%93%AA%E4%BA%9B%E7%89%B9%E6%80%A7%EF%BC%9F"><span class="nav-text">问：事务有哪些特性？</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E9%97%AE%EF%BC%9A%E6%80%8E%E4%B9%88%E7%90%86%E8%A7%A3%E5%8E%9F%E5%AD%90%E6%80%A7%EF%BC%9F"><span class="nav-text">问：怎么理解原子性？</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#2-2-volatile"><span class="nav-text">2.2 volatile</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E9%97%AE%EF%BC%9Avolatile%E7%9A%84%E4%BD%9C%E7%94%A8%E6%98%AF%E4%BB%80%E4%B9%88%EF%BC%9F%E5%8F%AF%E8%A7%81%E6%80%A7%EF%BC%9Fvolatile-%E7%9A%84%E5%AE%9E%E7%8E%B0%E5%8E%9F%E7%90%86%EF%BC%9F"><span class="nav-text">问：volatile的作用是什么？可见性？volatile 的实现原理？</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E9%97%AE%EF%BC%9Avolatile-%E7%9A%84%E5%AE%9E%E7%8E%B0%E5%8E%9F%E7%90%86%EF%BC%9F%E5%8F%8A%E5%86%85%E5%AD%98%E5%B1%8F%E9%9A%9C%E7%9B%B8%E5%85%B3%EF%BC%9F"><span class="nav-text">问：volatile 的实现原理？及内存屏障相关？</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E9%97%AE%EF%BC%9Avolatile%E5%A6%82%E4%BD%95%E4%BF%9D%E8%AF%81%E7%BA%BF%E7%A8%8B%E9%97%B4%E5%8F%AF%E8%A7%81%E5%92%8C%E9%81%BF%E5%85%8D%E6%8C%87%E4%BB%A4%E9%87%8D%E6%8E%92%EF%BC%9F"><span class="nav-text">问：volatile如何保证线程间可见和避免指令重排？</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#2-3-synchronized"><span class="nav-text">2.3 synchronized</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E9%97%AE%EF%BC%9Asynchronized-%E4%BD%BF%E7%94%A8%E6%96%B9%E5%BC%8F%E5%8F%8A%E5%AE%9E%E7%8E%B0%E5%8E%9F%E7%90%86%EF%BC%8C%E4%BB%A5%E5%8F%8A%E9%94%81%E4%BC%98%E5%8C%96%EF%BC%9F"><span class="nav-text">问：synchronized 使用方式及实现原理，以及锁优化？</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E9%97%AE%EF%BC%9Asynchronized-%E5%9C%A8%E9%9D%99%E6%80%81%E6%96%B9%E6%B3%95%E5%92%8C%E6%99%AE%E9%80%9A%E6%96%B9%E6%B3%95%E7%9A%84%E5%8C%BA%E5%88%AB%EF%BC%9F"><span class="nav-text">问：synchronized 在静态方法和普通方法的区别？</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E9%97%AE%EF%BC%9Asynchronized-%E5%92%8C-ReentranLock%E7%9A%84%E5%8C%BA%E5%88%AB%EF%BC%9F"><span class="nav-text">问：synchronized 和 ReentranLock的区别？</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E9%97%AE%EF%BC%9Asynchronized-%E5%92%8C-lock-%E6%9C%89%E4%BB%80%E4%B9%88%E5%8C%BA%E5%88%AB%EF%BC%9F"><span class="nav-text">问：synchronized 和 lock 有什么区别？</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E9%97%AE%EF%BC%9AHashTable%EF%BC%8C%E5%90%8C%E6%AD%A5%E9%94%81%EF%BC%8Csynchronized-%E5%85%B3%E9%94%AE%E5%AD%97-1-6-%E4%B9%8B%E5%90%8E%E6%8F%90%E5%8D%87%E4%BA%86%E4%BB%80%E4%B9%88%EF%BC%8C%E6%80%8E%E4%B9%88%E6%8F%90%E5%8D%87%E7%9A%84%E8%BF%99%E4%BA%9B%EF%BC%9F"><span class="nav-text">问：HashTable，同步锁，synchronized 关键字 1.6 之后提升了什么，怎么提升的这些？</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#2-4-Lock"><span class="nav-text">2.4 Lock</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E9%97%AE%EF%BC%9ALock-%E6%8E%A5%E5%8F%A3%E6%9C%89%E5%93%AA%E4%BA%9B%E5%AE%9E%E7%8E%B0%E7%B1%BB%EF%BC%8C%E4%BD%BF%E7%94%A8%E5%9C%BA%E6%99%AF%E6%98%AF%E4%BB%80%E4%B9%88%EF%BC%9F"><span class="nav-text">问：Lock 接口有哪些实现类，使用场景是什么？</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E9%97%AE%EF%BC%9A%E8%AE%B2%E8%AE%B2ReentrantLock%E5%AE%9E%E7%8E%B0%E5%8E%9F%E7%90%86%EF%BC%9F"><span class="nav-text">问：讲讲ReentrantLock实现原理？</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E9%97%AE%EF%BC%9AReentrantLock-%E6%98%AF%E5%A6%82%E4%BD%95%E5%AE%9E%E7%8E%B0%E5%8F%AF%E9%87%8D%E5%85%A5%E6%80%A7%E7%9A%84-%EF%BC%9F"><span class="nav-text">问：ReentrantLock 是如何实现可重入性的 ？</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E9%97%AE%EF%BC%9AReentrantLock%E5%A6%82%E4%BD%95%E9%81%BF%E5%85%8D%E6%AD%BB%E9%94%81"><span class="nav-text">问：ReentrantLock如何避免死锁?</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E9%97%AE%EF%BC%9AtryLock-%E5%92%8C-lock-%E5%92%8C-lockInterruptibly-%E7%9A%84%E5%8C%BA%E5%88%AB"><span class="nav-text">问：tryLock 和 lock 和 lockInterruptibly 的区别?</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#2-5-Condition"><span class="nav-text">2.5 Condition</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E9%97%AE%EF%BC%9A%E8%AE%B2%E4%B8%80%E4%B8%8BCondition%EF%BC%9F"><span class="nav-text">问：讲一下Condition？</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E9%97%AE%EF%BC%9A%E5%AF%B9%E8%B1%A1%E7%9B%91%E8%A7%86%E5%99%A8%E6%96%B9%E6%B3%95%E5%92%8CCondition%E7%9A%84%E5%BC%82%E5%90%8C-%EF%BC%9F"><span class="nav-text">问：对象监视器方法和Condition的异同 ？</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#2-6-AQS"><span class="nav-text">2.6 AQS</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E9%97%AE%EF%BC%9A%E8%AE%B2%E8%AE%B2AQS%EF%BC%9F%E5%AE%9E%E7%8E%B0%E5%8E%9F%E7%90%86%EF%BC%9F%E8%AE%B2%E8%AE%B2AQS%E6%80%8E%E4%B9%88%E5%AE%9E%E7%8E%B0%E7%9A%84Fair%E5%92%8CNoFair%EF%BC%9F"><span class="nav-text">问：讲讲AQS？实现原理？讲讲AQS怎么实现的Fair和NoFair？</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E9%97%AE%EF%BC%9AAQS%E4%B8%A4%E7%A7%8D%E8%B5%84%E6%BA%90%E5%85%B1%E4%BA%AB%E6%96%B9%E5%BC%8F%EF%BC%9F"><span class="nav-text">问：AQS两种资源共享方式？</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E9%97%AE%EF%BC%9ACAS%E4%BA%86%E8%A7%A3%E4%B9%88%EF%BC%9F-CAS-%E6%9C%89%E4%BB%80%E4%B9%88%E7%BC%BA%E9%99%B7%EF%BC%8C%E5%A6%82%E4%BD%95%E8%A7%A3%E5%86%B3%EF%BC%9F%E8%BF%98%E4%BA%86%E8%A7%A3%E5%85%B6%E4%BB%96%E5%90%8C%E6%AD%A5%E6%9C%BA%E5%88%B6%E4%B9%88%EF%BC%9F"><span class="nav-text">问：CAS了解么？ CAS 有什么缺陷，如何解决？还了解其他同步机制么？</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E9%97%AE%EF%BC%9ACAS%E5%92%8Csynchronized%E6%9C%89%E4%BB%80%E4%B9%88%E5%8C%BA%E5%88%AB%EF%BC%9F%E9%83%BD%E7%94%A8synchronized%E4%B8%8D%E8%A1%8C%E4%B9%88%EF%BC%9F"><span class="nav-text">问：CAS和synchronized有什么区别？都用synchronized不行么？</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#2-7-CountDownLatch"><span class="nav-text">2.7 CountDownLatch</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E9%97%AE%EF%BC%9A%E7%94%A8%E8%BF%87CountDownLatch%E4%B9%88%EF%BC%9F%E4%BB%80%E4%B9%88%E5%9C%BA%E6%99%AF%E4%B8%8B%E7%94%A8%E7%9A%84%EF%BC%9F"><span class="nav-text">问：用过CountDownLatch么？什么场景下用的？</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E9%97%AE%EF%BC%9A%E4%BB%80%E4%B9%88%E6%98%AF%E4%BF%A1%E5%8F%B7%E9%87%8FSemaphore%EF%BC%9F%E5%BA%94%E7%94%A8%E5%9C%BA%E6%99%AF%EF%BC%9F"><span class="nav-text">问：什么是信号量Semaphore？应用场景？</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E9%97%AE%EF%BC%9A%E7%94%A8%E8%BF%87CyclicBarrier%E5%90%97%EF%BC%9F-%E5%92%8C-countdownlatch-%E7%9A%84%E5%8C%BA%E5%88%AB%EF%BC%9F"><span class="nav-text">问：用过CyclicBarrier吗？ 和 countdownlatch 的区别？</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#2-8-%E9%94%81%E7%9A%84%E5%BA%94%E7%94%A8"><span class="nav-text">2.8 锁的应用</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E9%97%AE%EF%BC%9AConcurrentHashMap%E7%9A%84get%E9%9C%80%E8%A6%81%E5%8A%A0%E9%94%81%E4%B9%88%EF%BC%8C%E4%B8%BA%E4%BB%80%E4%B9%88%EF%BC%9F"><span class="nav-text">问：ConcurrentHashMap的get需要加锁么，为什么？</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E9%97%AE%EF%BC%9AHashtable-%E6%98%AF%E6%80%8E%E4%B9%88%E5%8A%A0%E9%94%81%E7%9A%84-%EF%BC%9F"><span class="nav-text">问：Hashtable 是怎么加锁的 ？</span></a></li></ol></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E4%B8%89-%E5%86%85%E5%AD%98%E6%A8%A1%E5%9E%8B"><span class="nav-text">三. 内存模型</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E9%97%AE%EF%BC%9AJava%E5%86%85%E5%AD%98%E6%A8%A1%E5%9E%8B%EF%BC%9F%E4%B8%BA%E4%BB%80%E4%B9%88%E8%A6%81%E6%9C%89%E5%B7%A5%E4%BD%9C%E5%86%85%E5%AD%98%E5%92%8C%E4%B8%BB%E5%86%85%E5%AD%98%EF%BC%9F"><span class="nav-text">问：Java内存模型？为什么要有工作内存和主内存？</span></a></li></ol></li></ol></li></ol></li></ol></div>
        </div>
        <!--/noindex-->

        <div class="site-overview-wrap sidebar-panel">
          <div class="site-overview">
            <div class="site-author site-overview-item animated" itemprop="author" itemscope itemtype="http://schema.org/Person">
    <img class="site-author-image" itemprop="image" alt="Lys"
      src="https://pic-1258215793.cos.ap-shanghai.myqcloud.com/cover/IMG_0759.JPG">
  <p class="site-author-name" itemprop="name">Lys</p>
  <div class="site-description" itemprop="description">记录编程点滴，写点生活中的酸甜</div>
</div>
<div class="site-state-wrap site-overview-item animated">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
          <a href="/archives/">
        
          <span class="site-state-item-count">330</span>
          <span class="site-state-item-name">日志</span>
        </a>
      </div>
      <div class="site-state-item site-state-categories">
            <a href="/categories/">
          
        <span class="site-state-item-count">12</span>
        <span class="site-state-item-name">分类</span></a>
      </div>
      <div class="site-state-item site-state-tags">
            <a href="/tags/">
          
        <span class="site-state-item-count">110</span>
        <span class="site-state-item-name">标签</span></a>
      </div>
  </nav>
</div>
  <div class="links-of-author site-overview-item animated">
      <span class="links-of-author-item">
        <a href="https://github.com/LAILAIWA" title="GitHub → https:&#x2F;&#x2F;github.com&#x2F;LAILAIWA" rel="noopener" target="_blank"><i class="fab fa-github fa-fw"></i>GitHub</a>
      </span>
      <span class="links-of-author-item">
        <a href="mailto:linyishui168@outlook.com" title="E-Mail → mailto:linyishui168@outlook.com" rel="noopener" target="_blank"><i class="fa fa-envelope fa-fw"></i>E-Mail</a>
      </span>
      <span class="links-of-author-item">
        <a href="https://weibo.com/u/5340162234" title="Weibo → https:&#x2F;&#x2F;weibo.com&#x2F;u&#x2F;5340162234" rel="noopener" target="_blank"><i class="fab fa-weibo fa-fw"></i>Weibo</a>
      </span>
      <span class="links-of-author-item">
        <a href="https://twitter.com/linyishui618" title="Twitter → https:&#x2F;&#x2F;twitter.com&#x2F;linyishui618" rel="noopener" target="_blank"><i class="fab fa-twitter fa-fw"></i>Twitter</a>
      </span>
      <span class="links-of-author-item">
        <a href="https://stackoverflow.com/users/13018339/lin-yishui" title="StackOverflow → https:&#x2F;&#x2F;stackoverflow.com&#x2F;users&#x2F;13018339&#x2F;lin-yishui" rel="noopener" target="_blank"><i class="fab fa-stack-overflow fa-fw"></i>StackOverflow</a>
      </span>
      <span class="links-of-author-item">
        <a href="https://instagram.com/linyishui618" title="Instagram → https:&#x2F;&#x2F;instagram.com&#x2F;linyishui618" rel="noopener" target="_blank"><i class="fab fa-instagram fa-fw"></i>Instagram</a>
      </span>
  </div>
  <div class="cc-license site-overview-item animated" itemprop="license">
    <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/deed.zh" class="cc-opacity" rel="noopener" target="_blank"><img src="https://cdn.jsdelivr.net/npm/@creativecommons/vocabulary@2020.11.3/assets/license_badges/small/by_nc_sa.svg" alt="Creative Commons"></a>
  </div>


  <div class="links-of-blogroll site-overview-item animated">
    <div class="links-of-blogroll-title"><i class="far fa-smile-wink fa-fw"></i>
      个人
    </div>
    <ul class="links-of-blogroll-list">
        <li class="links-of-blogroll-item">
          <a href="https://music.163.com/#/user/home?id=68425607" title="https:&#x2F;&#x2F;music.163.com&#x2F;#&#x2F;user&#x2F;home?id&#x3D;68425607" rel="noopener" target="_blank">网易云音乐</a>
        </li>
    </ul>
  </div>

          </div>
        </div>
    </div>
  </aside>
  <div class="sidebar-dimmer"></div>


    </header>

    
  <div class="back-to-top" role="button" aria-label="返回顶部">
    <i class="fa fa-arrow-up"></i>
    <span>0%</span>
  </div>
  <a role="button" class="book-mark-link book-mark-link-fixed"></a>

  <a href="https://github.com/LAILAIWA" class="github-corner" title="Follow me on GitHub" aria-label="Follow me on GitHub" rel="noopener" target="_blank"><svg width="80" height="80" viewBox="0 0 250 250" aria-hidden="true"><path d="M0,0 L115,115 L130,115 L142,142 L250,250 L250,0 Z"></path><path d="M128.3,109.0 C113.8,99.7 119.0,89.6 119.0,89.6 C122.0,82.7 120.5,78.6 120.5,78.6 C119.2,72.0 123.4,76.3 123.4,76.3 C127.3,80.9 125.5,87.3 125.5,87.3 C122.9,97.6 130.6,101.9 134.4,103.2" fill="currentColor" style="transform-origin: 130px 106px;" class="octo-arm"></path><path d="M115.0,115.0 C114.9,115.1 118.7,116.5 119.8,115.4 L133.7,101.6 C136.9,99.2 139.9,98.4 142.2,98.6 C133.8,88.0 127.5,74.4 143.8,58.0 C148.5,53.4 154.0,51.2 159.7,51.0 C160.3,49.4 163.2,43.6 171.4,40.1 C171.4,40.1 176.1,42.5 178.8,56.2 C183.1,58.6 187.2,61.8 190.9,65.4 C194.5,69.0 197.7,73.2 200.1,77.6 C213.8,80.2 216.3,84.9 216.3,84.9 C212.7,93.1 206.9,96.0 205.4,96.6 C205.1,102.4 203.0,107.8 198.3,112.5 C181.9,128.9 168.3,122.5 157.7,114.1 C157.9,116.9 156.7,120.9 152.7,124.9 L141.0,136.5 C139.8,137.7 141.6,141.9 141.8,141.8 Z" fill="currentColor" class="octo-body"></path></svg></a>

<noscript>
  <div class="noscript-warning">Theme NexT works best with JavaScript enabled</div>
</noscript>


    <div class="main-inner post posts-expand">


  


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://linyishui.top/2019102201.html">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="https://pic-1258215793.cos.ap-shanghai.myqcloud.com/cover/IMG_0759.JPG">
      <meta itemprop="name" content="Lys">
      <meta itemprop="description" content="记录编程点滴，写点生活中的酸甜">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="俺的部落格">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          面试整理——Java并发编程
        </h1>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>

      <time title="创建时间：2019-10-22 16:06:16" itemprop="dateCreated datePublished" datetime="2019-10-22T16:06:16+08:00">2019-10-22</time>
    </span>
      <span class="post-meta-item">
        <span class="post-meta-item-icon">
          <i class="far fa-calendar-check"></i>
        </span>
        <span class="post-meta-item-text">更新于</span>
        <time title="修改时间：2021-12-23 16:44:18" itemprop="dateModified" datetime="2021-12-23T16:44:18+08:00">2021-12-23</time>
      </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">分类于</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/%E9%9D%A2%E8%AF%95%E6%95%B4%E7%90%86/" itemprop="url" rel="index"><span itemprop="name">面试整理</span></a>
        </span>
    </span>

  
      </div>
      <div class="post-meta">
    <span class="post-meta-item" title="本文字数">
      <span class="post-meta-item-icon">
        <i class="far fa-file-word"></i>
      </span>
      <span class="post-meta-item-text">本文字数：</span>
      <span>14k</span>
    </span>
    <span class="post-meta-item" title="阅读时长">
      <span class="post-meta-item-icon">
        <i class="far fa-clock"></i>
      </span>
      <span class="post-meta-item-text">阅读时长 &asymp;</span>
      <span>13 分钟</span>
    </span>
</div>

            <div class="post-description">整理面试中常问的Java并发编程相关问题，持续更新中。</div>
        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
        <h1 id="Java并发编程"><a href="#Java并发编程" class="headerlink" title="Java并发编程"></a>Java并发编程</h1><h2 id="一-多线程"><a href="#一-多线程" class="headerlink" title="一. 多线程"></a>一. 多线程</h2><h3 id="1-1-线程"><a href="#1-1-线程" class="headerlink" title="1.1 线程"></a>1.1 线程</h3><h4 id="问：什么时候用线程？"><a href="#问：什么时候用线程？" class="headerlink" title="问：什么时候用线程？"></a>问：什么时候用线程？</h4><ul>
<li><strong>需要频繁创建和销毁</strong>。</li>
<li><strong>需要频繁切换</strong>。</li>
<li><strong>多核环境</strong>。</li>
<li><strong>并行操作</strong>。</li>
<li><strong>相比稳定安全更需要速度</strong>。</li>
</ul>
<h4 id="问：创建多线程的方式，以及线程的状态转换？"><a href="#问：创建多线程的方式，以及线程的状态转换？" class="headerlink" title="问：创建多线程的方式，以及线程的状态转换？"></a>问：创建多线程的方式，以及线程的状态转换？</h4><p>Java中有：</p>
<ul>
<li>继承Thread类，重写run()，创建线程对象。</li>
<li>实现Runnable接口，重写run()，创建线程对象。</li>
<li>实现Callable接口，重写call()，创建实例对象并作为构造器参数创建FutureTask对象，再使用FutureTask对象作为构造器参数创建线程对象。</li>
<li>使用Executor框架创建线程池。</li>
</ul>
<p><img src="https://pic-1258215793.cos.ap-shanghai.myqcloud.com/content/20190316/201903160104.jpg" alt="线程状态"></p>
<table>
<thead>
<tr>
<th align="center">状态</th>
<th align="center">名称</th>
<th align="left">示例</th>
<th align="left">介绍</th>
</tr>
</thead>
<tbody><tr>
<td align="center">New</td>
<td align="center">初始状态</td>
<td align="left">new Thread(runnable)</td>
<td align="left">线程还未开始运行，处于创建状态</td>
</tr>
<tr>
<td align="center">Runnable</td>
<td align="center">运行状态</td>
<td align="left">thread.start()</td>
<td align="left">可运行但未必在运行，取决于OS分配的运行时间，即就绪和运行两状态的合并。</td>
</tr>
<tr>
<td align="center">Blocked</td>
<td align="center">阻塞状态</td>
<td align="left"></td>
<td align="left">请求内部的对象锁，但锁被其他线程持有</td>
</tr>
<tr>
<td align="center">Waiting</td>
<td align="center">等待状态</td>
<td align="left">Object.wait() / Thread.join() / 等待Lock或Condition</td>
<td align="left">当线程等待另一个线程通知调度器某个条件时，处于此状态</td>
</tr>
<tr>
<td align="center">Timed waiting</td>
<td align="center">超时等待</td>
<td align="left">Object.wait() / Thread.join() / Thread.sleep() / Lock.tryLock() / Condition.await()</td>
<td align="left">调用有些有超时参数的方法时，可以指定时间自行返回</td>
</tr>
<tr>
<td align="center">Terminated</td>
<td align="center">终止状态</td>
<td align="left">不要使用stop()</td>
<td align="left">要么因为run方法正常结束而终止，要么因为没有捕获的异常终止了run方法而结束</td>
</tr>
</tbody></table>
<p>一个经历了所有状态的线程可能会经历以下流程：线程创建后调用start()方法开始，状态由NEW-&gt;RUNNABLE。当线程执行wait()后，线程进入WAITING状态。处于WAITING状态的线程需要等待其他线程的通知才可以恢复RUNNABLE状态，而TIME_WAITING则是在WAITING上增加了时间限制，在超时后会自动返回RUNNABLE状态。当线程调用同步方法时，在无法获得锁的情况下，线程进入BLOCKED状态。线程在执行run()方法后将进入终止状态。</p>
<h4 id="问：终止线程的方法？"><a href="#问：终止线程的方法？" class="headerlink" title="问：终止线程的方法？"></a>问：终止线程的方法？</h4><ul>
<li>使用退出标志（如volatile布尔变量），表示线程正常退出；</li>
<li>通过interrupt()中断，run()内通过isInterrupted()判断是否中断，若处于阻塞状态就无法检测中断状态，会抛出异常InterruptedException。</li>
</ul>
<h4 id="问：谈一下线程切换，并引申到Java阻塞，运行？"><a href="#问：谈一下线程切换，并引申到Java阻塞，运行？" class="headerlink" title="问：谈一下线程切换，并引申到Java阻塞，运行？"></a>问：谈一下线程切换，并引申到Java阻塞，运行？</h4><p>线程切换就是指<strong>CPU从一个进程/线程切换到另一个进程/线程</strong>（上下文指某个时间节点CPU寄存器和计数器的内容）。大概过程可以简单的理解为：<strong>挂起当前线程</strong>（存储当前上下文），<strong>恢复一个线程</strong>（找到一个合适的上下文并恢复到寄存器），<strong>跳转到程序计数器指向的位置</strong>（即线程被中断时的代码行）。</p>
<p>阻塞就是指线程执行到某一阶段时，需要获取某些资源才能继续执行，但此时这些资源被其他线程占用，所以当前线程需要处于等待状态。</p>
<h4 id="问：线程的中断机制？"><a href="#问：线程的中断机制？" class="headerlink" title="问：线程的中断机制？"></a>问：线程的中断机制？</h4><p>Java的线程中有一个中断标识位，表示是否有中断请求，并在Thread中提供了interrupt()来中断线程，以及interrupted()和isInterrupted()来判断当前中断状态，前者会将中断复位。</p>
<p>中断并不意味着线程会立即终止，中断线程可以任意处理，通常会把中断请求当作终止请求，由线程根据情况在合适的时机终止。</p>
<p>处于阻塞状态的线程会抛出异常InterruptedException，且抛出异常的方法大多会先重置中断标识位再抛出异常。</p>
<h4 id="问：怎么实现所有线程在等待某个事件的发生才会去执行？"><a href="#问：怎么实现所有线程在等待某个事件的发生才会去执行？" class="headerlink" title="问：怎么实现所有线程在等待某个事件的发生才会去执行？"></a>问：怎么实现所有线程在等待某个事件的发生才会去执行？</h4><ul>
<li><strong>读写锁</strong>：主线程先获取写锁，所有子线程获取读锁，等事件发生时主线程释放写锁。</li>
<li><strong>CountDownLatch</strong>：初始值设置为1，所有子线程调用 <code>await()</code> 等待，等事件发生时调用 <code>countDown()</code> 方法计数减为0。</li>
<li><strong>Semaphore</strong>：初始值设为N，主线程先调用 <code>acquire(N)</code> 申请N个信号量，其他线程调用 <code>acquire()</code> 阻塞等待，等事件发生时主线程同时释放N个信号量。</li>
<li><strong>CyclicBarrier</strong>：</li>
</ul>
<h4 id="问：如何实现控制线程在某段时间内完成，不完成就撤销？"><a href="#问：如何实现控制线程在某段时间内完成，不完成就撤销？" class="headerlink" title="问：如何实现控制线程在某段时间内完成，不完成就撤销？"></a>问：如何实现控制线程在某段时间内完成，不完成就撤销？</h4><h4 id="问：线程回调？"><a href="#问：线程回调？" class="headerlink" title="问：线程回调？"></a>问：线程回调？</h4><h4 id="问：RPC-框架？设计一个-RPC，怎么实现"><a href="#问：RPC-框架？设计一个-RPC，怎么实现" class="headerlink" title="问：RPC 框架？设计一个 RPC，怎么实现"></a>问：RPC 框架？设计一个 RPC，怎么实现</h4><p>用到了回调这块的东西</p>
<h4 id="问：线程间的通信可以怎么做？线程间相互通知你会怎么做，代码要怎么实现？"><a href="#问：线程间的通信可以怎么做？线程间相互通知你会怎么做，代码要怎么实现？" class="headerlink" title="问：线程间的通信可以怎么做？线程间相互通知你会怎么做，代码要怎么实现？"></a>问：线程间的通信可以怎么做？线程间相互通知你会怎么做，代码要怎么实现？</h4><p>答了synchronized和Object的wait和notify，强调了notify是随机，All是全部，然后问All怎么个全部法，全部唤醒都开始执行不就不安全了吗？</p>
<hr>
<h3 id="1-2-ThreadLocal"><a href="#1-2-ThreadLocal" class="headerlink" title="1.2 ThreadLocal"></a>1.2 ThreadLocal</h3><h4 id="问：谈一下ThreadLocal？应用场景？原理？与-Thread-类的关系？"><a href="#问：谈一下ThreadLocal？应用场景？原理？与-Thread-类的关系？" class="headerlink" title="问：谈一下ThreadLocal？应用场景？原理？与 Thread 类的关系？"></a>问：谈一下ThreadLocal？应用场景？原理？与 Thread 类的关系？</h4><blockquote>
<p>应用：</p>
<ul>
<li>用来解决数据库连接，存放connection对象，不同线程存放各自session；</li>
<li>解决simpleDateFormat线程安全问题；</li>
<li>会出现内存泄漏，显式remove..不要与线程池配合，因为worker往往是不会退出的；</li>
</ul>
</blockquote>
<p>原理：线程中创建副本，访问自己内部的副本变量，内部实现是其内部类名叫ThreadLocalMap的成员变量threadLocals，key为本身，value为实际存值的变量副本</p>
<p>与 Thread 类的关系：</p>
<h4 id="问：static-能不能修饰-ThreadLocal？"><a href="#问：static-能不能修饰-ThreadLocal？" class="headerlink" title="问：static 能不能修饰 ThreadLocal？"></a>问：static 能不能修饰 ThreadLocal？</h4><p>能，且通常将ThreadLocal变量声明为私有静态，这样做有好处也有坏处，主要是为了避免重复的创建TSO（thread specific object，即与线程相关的变量），坏处是可能导致内存泄漏。</p>
<p>如果声明ThreadLocal为某个类的实例变量，每创建一个类的实例就会创建新的ThreadLocal实例，导致同一个线程可能访问到同一个TSO类的不同实例，也因为重复创建相同的对象导致浪费。</p>
<p>因为类对ThreadLocal的静态引用，导致最终生成了对ThreadLocal的一条可达引用链路，使ThreadLocal实例不会被垃圾回收，即产生了内存泄漏。</p>
<p>所以使用ThreadLocal需要手动回收这部分内存，可以remove或使ThreadLocal变量=null。</p>
<h4 id="问：谈一下ThreadLocal的内存泄漏问题？"><a href="#问：谈一下ThreadLocal的内存泄漏问题？" class="headerlink" title="问：谈一下ThreadLocal的内存泄漏问题？"></a>问：谈一下ThreadLocal的内存泄漏问题？</h4><p>如果是强引用，设置tl=null，但是key的引用依然指向ThreadLocal对象，所以会有内存泄漏，而使用弱引用则不会； 但是还是会有内存泄漏存在，ThreadLocal被回收，key的值变成null，导致整个value再也无法被访问到； 解决办法：在使用结束时，调用ThreadLocal.remove来释放其value的引用；</p>
<h4 id="问：如果我们要获取父线程的ThreadLocal值呢？"><a href="#问：如果我们要获取父线程的ThreadLocal值呢？" class="headerlink" title="问：如果我们要获取父线程的ThreadLocal值呢？"></a>问：如果我们要获取父线程的ThreadLocal值呢？</h4><p>ThreadLocal是不具备继承性的，所以是无法获取到的，但是我们可以用InteritableThreadLocal来实现这个功能。InteritableThreadLocal继承来ThreadLocal，重写了createdMap方法，已经对应的get和set方法，不是在利用了threadLocals，而是interitableThreadLocals变量。</p>
<p>这个变量会在线程初始化的时候（调用init方法），会判断父线程的interitableThreadLocals变量是否为空，如果不为空，则把放入子线程中，但是其实这玩意没啥鸟用，当父线程创建完子线程后，如果改变父线程内容是同步不到子线程的。。。同样，如果在子线程创建完后，再去赋值，也是没啥鸟用的</p>
<hr>
<h3 id="1-3-Thread"><a href="#1-3-Thread" class="headerlink" title="1.3 Thread"></a>1.3 Thread</h3><h4 id="问：Thread类里有哪些常用方法？"><a href="#问：Thread类里有哪些常用方法？" class="headerlink" title="问：Thread类里有哪些常用方法？"></a>问：Thread类里有哪些常用方法？</h4><h4 id="问：interrupt-isInterrupted-interrupt区别？"><a href="#问：interrupt-isInterrupted-interrupt区别？" class="headerlink" title="问：interrupt/isInterrupted/interrupt区别？"></a>问：interrupt/isInterrupted/interrupt区别？</h4><blockquote>
<ul>
<li>interrupt（） 调用该方法的线程的状态为将被置为”中断”状态（set操作）</li>
<li>isinterrupted（） 是作用于调用该方法的线程对象所对应的线程的中断信号是true还是false（get操作）。例如我们可以在A线程中去调用B线程对象的isInterrupted方法，查看的是A</li>
<li>interrupted（）是静态方法：内部实现是调用的当前线程的isInterrupted（），并且会重置当前线程的中断状态（getandset）</li>
</ul>
</blockquote>
<h4 id="问：谈一下start和run方法的区别？"><a href="#问：谈一下start和run方法的区别？" class="headerlink" title="问：谈一下start和run方法的区别？"></a>问：谈一下start和run方法的区别？</h4><p>答：start方法启动多线程，但并不一定直接运行，而是先进入可运行状态，等待调度分配。run方法是线程体，包含了要执行的线程的内容，当run方法执行结束，线程随即终止，调用run方法并不能用来启动线程。</p>
<h4 id="问：sleep-和-wait-有什么区别？"><a href="#问：sleep-和-wait-有什么区别？" class="headerlink" title="问：sleep 和 wait 有什么区别？"></a>问：sleep 和 wait 有什么区别？</h4><p>sleep属于线程类，wait属于object类；sleep不释放锁</p>
<h4 id="问：sleep-和-yeild-方法有什么区别？"><a href="#问：sleep-和-yeild-方法有什么区别？" class="headerlink" title="问：sleep 和 yeild 方法有什么区别？"></a>问：sleep 和 yeild 方法有什么区别？</h4><hr>
<h3 id="1-4-线程池"><a href="#1-4-线程池" class="headerlink" title="1.4 线程池"></a>1.4 线程池</h3><h4 id="问：项目的用户量多吗？有用过线程池吗？用到多线程的优势在哪？"><a href="#问：项目的用户量多吗？有用过线程池吗？用到多线程的优势在哪？" class="headerlink" title="问：项目的用户量多吗？有用过线程池吗？用到多线程的优势在哪？"></a>问：项目的用户量多吗？有用过线程池吗？用到多线程的优势在哪？</h4><p>以前的项目用户量不大，但有学习和练习过线程池。</p>
<p>多线程意味着能同时执行多个任务，可以更好的利用CPU的空闲时间，让程序运行的更快。</p>
<p>线程池则是用来管理和限制系统中执行线程的数量，减少创建和销毁线程的次数，重复的利用已创建的线程，防止内存的浪费，也能提高响应速度。</p>
<h4 id="问：ThreadPoolExecutor-初始化参数？"><a href="#问：ThreadPoolExecutor-初始化参数？" class="headerlink" title="问：ThreadPoolExecutor 初始化参数？"></a>问：ThreadPoolExecutor 初始化参数？</h4><ul>
<li><strong>corePoolSize</strong>（线程池基本大小）：控制执行线程的数目，超过此值就不再创建基本线程。</li>
<li><strong>maximumPoolSize</strong>（线程池最大数量）：若队列满了，会继续创建新的线程，直到达到线程池最大数量，当然若任务队列没有界限此参数就失效了。</li>
<li><strong>ThreadFactory</strong>（线程工厂）：用于设置创建线程的工厂，一般用于给线程统一命名。</li>
<li><strong>runnableTaskQueue</strong>（任务队列）：保存等待执行的任务阻塞队列，有多种选择：数组先进先出队列、链表先进先出队列、不存储元素的阻塞队列、含优先级的无限阻塞队列。</li>
<li><strong>RejectedExecutionHandler</strong>（饱和策略）：队列和线程池都满了后，处于饱和状态时的新任务处理策略。默认是AbortPolicy直接抛出异常，还有直接丢弃、丢弃最近任务等等。</li>
<li><strong>keepAliveTime</strong>（线程活动保持时间）：工作线程空闲后能够存活的时间，当任务很多且执行时间较短时，可以调高此值，提高线程的利用率。</li>
<li><strong>TimeUnit</strong>（时间单位）：可选的单位有天（DAYS）、小时（HOURS）、分钟 （MINUTES）、毫秒（MILLISECONDS）、微秒（MICROSECONDS，千分之一毫秒）和纳秒（NANOSECONDS，千分之一微秒）。</li>
</ul>
<h4 id="问：线程状态？"><a href="#问：线程状态？" class="headerlink" title="问：线程状态？"></a>问：线程状态？</h4><p>线程池有5种状态：running，showdown，stop，Tidying，TERMINATED。</p>
<blockquote>
<ul>
<li>running：线程池处于运行状态，可以接受任务，执行任务，创建线程默认就是这个状态了</li>
<li>showdown：调用showdown（）函数，不会接受新任务，但是会慢慢处理完堆积的任务。</li>
<li>stop：调用showdownnow（）函数，不会接受新任务，不处理已有的任务，会中断现有的任务。</li>
<li>Tidying：当线程池状态为showdown或者stop，任务数量为0，就会变为tidying。这个时候会调用钩子函数terminated（）。</li>
<li>ERMINATED：terminated（）执行完成。</li>
</ul>
</blockquote>
<p>在线程池中，用了一个原子类来记录线程池的信息，用了int的高3位表示状态，后面的29位表示线程池中线程的个数。</p>
<h4 id="问：corepoolSize-怎么设置，maxpoolsize-怎么设置，keep-alive-各种的？"><a href="#问：corepoolSize-怎么设置，maxpoolsize-怎么设置，keep-alive-各种的？" class="headerlink" title="问：corepoolSize 怎么设置，maxpoolsize 怎么设置，keep-alive 各种的？"></a>问：corepoolSize 怎么设置，maxpoolsize 怎么设置，keep-alive 各种的？</h4><h4 id="问：阻塞队列在生产中的设置？"><a href="#问：阻塞队列在生产中的设置？" class="headerlink" title="问：阻塞队列在生产中的设置？"></a>问：阻塞队列在生产中的设置？</h4><p>一般设置为 0，防止用户阻塞</p>
<h4 id="问：Java中的线程池是如何实现的？讲一下线程池的原理？"><a href="#问：Java中的线程池是如何实现的？讲一下线程池的原理？" class="headerlink" title="问：Java中的线程池是如何实现的？讲一下线程池的原理？"></a>问：Java中的线程池是如何实现的？讲一下线程池的原理？</h4><blockquote>
<ul>
<li>线程中线程被抽象为静态内部类Worker，是基于AQS实现的存放在HashSet中；</li>
<li>要被执行的线程存放在BlockingQueue中；</li>
<li>基本思想就是从workQueue中取出要执行的任务，放在worker中处理；</li>
</ul>
</blockquote>
<h4 id="问：如果线程池中的一个线程运行时出现了异常，会发生什么？"><a href="#问：如果线程池中的一个线程运行时出现了异常，会发生什么？" class="headerlink" title="问：如果线程池中的一个线程运行时出现了异常，会发生什么？"></a>问：如果线程池中的一个线程运行时出现了异常，会发生什么？</h4><p>如果提交任务的时候使用了submit，则返回的feature里会存有异常信息，但是如果数execute则会打印出异常栈。但是不会给其他线程造成影响。之后线程池会删除该线程，会新增加一个worker。</p>
<h4 id="问：讲一下线程池的原理？"><a href="#问：讲一下线程池的原理？" class="headerlink" title="问：讲一下线程池的原理？"></a>问：讲一下线程池的原理？</h4><blockquote>
<ul>
<li>提交一个任务，线程池里存活的核心线程数小于corePoolSize时，线程池会创建一个核心线程去处理提交的任务</li>
<li>如果线程池核心线程数已满，即线程数已经等于corePoolSize，一个新提交的任务，会被放进任务队列workQueue排队等待执行。</li>
<li>当线程池里面存活的线程数已经等于corePoolSize了，并且任务队列workQueue也满，判断线程数是否达到maximumPoolSize，即最大线程数是否已满，如果没到达，创建非核心线程执行提交的任务。</li>
<li>如果当前的线程数达到了maximumPoolSize，还有新的任务过来的话，直接采用拒绝策略处理。</li>
</ul>
</blockquote>
<h4 id="问：如何实现一个线程池，Java中线程池如何进行配置？线程池的线程数怎么确定？"><a href="#问：如何实现一个线程池，Java中线程池如何进行配置？线程池的线程数怎么确定？" class="headerlink" title="问：如何实现一个线程池，Java中线程池如何进行配置？线程池的线程数怎么确定？"></a>问：如何实现一个线程池，Java中线程池如何进行配置？线程池的线程数怎么确定？</h4><p>如果是IO操作为主怎么确定？如果计算型操作又怎么确定？跳表的查询过程是怎么样的，查询和插入的时间复杂度?</p>
<h4 id="问：如何实现一个线程池，Java中线程池如何进行配置？线程池的核心参数记得吗？线程池的工作流程记得吗？"><a href="#问：如何实现一个线程池，Java中线程池如何进行配置？线程池的核心参数记得吗？线程池的工作流程记得吗？" class="headerlink" title="问：如何实现一个线程池，Java中线程池如何进行配置？线程池的核心参数记得吗？线程池的工作流程记得吗？"></a>问：如何实现一个线程池，Java中线程池如何进行配置？线程池的核心参数记得吗？线程池的工作流程记得吗？</h4><h4 id="问：线程池里如何知道线程执行完了没有？线程阻塞怎么办？怎么保证所有线程执行完之后继续往下处理？怎么让一个线程等另一个线程执行结束？"><a href="#问：线程池里如何知道线程执行完了没有？线程阻塞怎么办？怎么保证所有线程执行完之后继续往下处理？怎么让一个线程等另一个线程执行结束？" class="headerlink" title="问：线程池里如何知道线程执行完了没有？线程阻塞怎么办？怎么保证所有线程执行完之后继续往下处理？怎么让一个线程等另一个线程执行结束？"></a>问：线程池里如何知道线程执行完了没有？线程阻塞怎么办？怎么保证所有线程执行完之后继续往下处理？怎么让一个线程等另一个线程执行结束？</h4><p>答了CountdownLatch和CyclicBarrier，之后提示可以利用Thread的join方法</p>
<h3 id="问：Java-的信号灯？"><a href="#问：Java-的信号灯？" class="headerlink" title="问：Java 的信号灯？"></a>问：Java 的信号灯？</h3><h4 id="问：Executors-静态方法？"><a href="#问：Executors-静态方法？" class="headerlink" title="问：Executors 静态方法？"></a>问：Executors 静态方法？</h4><h4 id="问：拒绝策略？"><a href="#问：拒绝策略？" class="headerlink" title="问：拒绝策略？"></a>问：拒绝策略？</h4><blockquote>
<ul>
<li>AbortPolicy直接抛出异常阻止线程运行；</li>
<li>CallerRunsPolicy如果被丢弃的线程任务未关闭，则执行该线程；</li>
<li>DiscardOldestPolicy移除队列最早线程尝试提交当前任务</li>
<li>DiscardPolicy丢弃当前任务，不做处理</li>
</ul>
</blockquote>
<h4 id="问：newFixedThreadPool-（固定数目线程的线程池）？"><a href="#问：newFixedThreadPool-（固定数目线程的线程池）？" class="headerlink" title="问：newFixedThreadPool （固定数目线程的线程池）？"></a>问：newFixedThreadPool （固定数目线程的线程池）？</h4><blockquote>
<ul>
<li>阻塞队列为无界队列LinkedBlockingQueue</li>
<li>适用于处理CPU密集型的任务，适用执行长期的任务</li>
</ul>
</blockquote>
<h4 id="问：newCachedThreadPool（可缓存线程的线程池）？"><a href="#问：newCachedThreadPool（可缓存线程的线程池）？" class="headerlink" title="问：newCachedThreadPool（可缓存线程的线程池）？"></a>问：newCachedThreadPool（可缓存线程的线程池）？</h4><blockquote>
<ul>
<li>阻塞队列是SynchronousQueue</li>
<li>适用于并发执行大量短期的小任务</li>
</ul>
</blockquote>
<h4 id="问：newSingleThreadExecutor（单线程的线程池）？"><a href="#问：newSingleThreadExecutor（单线程的线程池）？" class="headerlink" title="问：newSingleThreadExecutor（单线程的线程池）？"></a>问：newSingleThreadExecutor（单线程的线程池）？</h4><blockquote>
<ul>
<li>阻塞队列是LinkedBlockingQueue</li>
<li>适用于串行执行任务的场景，一个任务一个任务地执行</li>
</ul>
</blockquote>
<h4 id="问：newScheduledThreadPool（定时及周期执行的线程池）？"><a href="#问：newScheduledThreadPool（定时及周期执行的线程池）？" class="headerlink" title="问：newScheduledThreadPool（定时及周期执行的线程池）？"></a>问：newScheduledThreadPool（定时及周期执行的线程池）？</h4><blockquote>
<ul>
<li>阻塞队列是DelayedWorkQueue</li>
<li>周期性执行任务的场景，需要限制线程数量的场景</li>
</ul>
</blockquote>
<hr>
<h3 id="1-5-线程安全"><a href="#1-5-线程安全" class="headerlink" title="1.5 线程安全"></a>1.5 线程安全</h3><h4 id="问：谈一下对线程安全的理解？用什么方法保证线程的安全？"><a href="#问：谈一下对线程安全的理解？用什么方法保证线程的安全？" class="headerlink" title="问：谈一下对线程安全的理解？用什么方法保证线程的安全？"></a>问：谈一下对线程安全的理解？用什么方法保证线程的安全？</h4><h4 id="问：如何线程安全的实现一个计数器？"><a href="#问：如何线程安全的实现一个计数器？" class="headerlink" title="问：如何线程安全的实现一个计数器？"></a>问：如何线程安全的实现一个计数器？</h4><h4 id="问：请写一个线程安全的单例模式？"><a href="#问：请写一个线程安全的单例模式？" class="headerlink" title="问：请写一个线程安全的单例模式？"></a>问：请写一个线程安全的单例模式？</h4><h4 id="问：单例模式，饿汉式，懒汉式，线程安全的做法，两次判断-instance-是否为空，每次判断的作用是什么？"><a href="#问：单例模式，饿汉式，懒汉式，线程安全的做法，两次判断-instance-是否为空，每次判断的作用是什么？" class="headerlink" title="问：单例模式，饿汉式，懒汉式，线程安全的做法，两次判断 instance 是否为空，每次判断的作用是什么？"></a>问：单例模式，饿汉式，懒汉式，线程安全的做法，两次判断 instance 是否为空，每次判断的作用是什么？</h4><h4 id="问：ABC-三个线程如何保证顺序执行？"><a href="#问：ABC-三个线程如何保证顺序执行？" class="headerlink" title="问：ABC 三个线程如何保证顺序执行？"></a>问：ABC 三个线程如何保证顺序执行？</h4><h4 id="问：生产者消费者模式的实现方式？"><a href="#问：生产者消费者模式的实现方式？" class="headerlink" title="问：生产者消费者模式的实现方式？"></a>问：生产者消费者模式的实现方式？</h4><hr>
<h2 id="二-锁"><a href="#二-锁" class="headerlink" title="二. 锁"></a>二. 锁</h2><h3 id="2-1-锁"><a href="#2-1-锁" class="headerlink" title="2.1 锁"></a>2.1 锁</h3><h4 id="问：讲讲你知道的锁？锁的几种特性？"><a href="#问：讲讲你知道的锁？锁的几种特性？" class="headerlink" title="问：讲讲你知道的锁？锁的几种特性？"></a>问：讲讲你知道的锁？锁的几种特性？</h4><ul>
<li>独占/排他与共享：独占/排他即同一时刻只能有一个线程获取到锁，而其他获取锁的线程只能处于同步队列中等待，只有获取锁的线程释放了锁，后继的线程才能够获取锁。共享则表示同一时刻多个线程可以同时访问。</li>
<li>公平与非公平：先对锁进行获取请求的线程一定先被满足，这是公平锁；反之则是非公平锁。</li>
<li>可重入：支持重进入，表示锁能够支持一个线程对资源重复加锁。</li>
</ul>
<h4 id="问：公平锁与非公平锁？"><a href="#问：公平锁与非公平锁？" class="headerlink" title="问：公平锁与非公平锁？"></a>问：公平锁与非公平锁？</h4><ol>
<li>公平锁指在分配锁前检查是否有线程在排队等待获取该锁，优先分配排队时间最长的线程，非公平直接尝试获取锁 。</li>
<li>公平锁需多维护一个锁线程队列，大量的线程切换，效率低；默认非公平。</li>
</ol>
<h4 id="问：独占锁与共享锁？"><a href="#问：独占锁与共享锁？" class="headerlink" title="问：独占锁与共享锁？"></a>问：独占锁与共享锁？</h4><ol>
<li>ReentrantLock为独占锁（悲观加锁策略） 。</li>
<li>ReentrantReadWriteLock中读锁为共享锁，写锁为独占锁。</li>
<li>JDK1.8 邮戳锁（StampedLock）， 不可重入锁读的过程中也允许获取写锁后写入。这样一来，我们读的数据就可能不一致，所以，需要一点额外的代码来判断读的过程中是否有写入，这种读锁是一种乐观锁， 乐观锁的并发效率更高，但一旦有小概率的写入导致读取的数据不一致，需要能检测出来，再读一遍就行。</li>
</ol>
<h4 id="问：可重入锁概念？"><a href="#问：可重入锁概念？" class="headerlink" title="问：可重入锁概念？"></a>问：可重入锁概念？</h4><ol>
<li>可重入锁是指同一个线程可以多次获取同一把锁，不会因为之前已经获取过还没释放而阻塞；</li>
<li>ReentrantLock、ReentrantReadWriteLock和synchronized都是可重入锁。</li>
<li>可重入锁的一个优点是可一定程度避免死锁。</li>
</ol>
<h4 id="问：讲讲4种锁状态？"><a href="#问：讲讲4种锁状态？" class="headerlink" title="问：讲讲4种锁状态？"></a>问：讲讲4种锁状态？</h4><p>即重量级锁的四种状态，为了提高效率，尽量避免使用重量级锁：</p>
<ul>
<li><strong>无锁</strong>：是否偏向-0，锁标志-01。</li>
<li><strong>偏向锁</strong>：是否偏向-1，锁标志-01。会偏向第一个访问锁的线程，当一个线程访问同步代码块获得锁时，会在对象头和栈帧记录里存储锁偏向的线程ID，当这个线程再次进入同步代码块时，就不需要CAS操作来加锁了，只要测试一下对象头里是否存储着指向当前线程的偏向锁，如果偏向锁未启动，new出的对象是普通对象（即无锁，有稍微竞争会成轻量级锁），如果启动，new出的对象是匿名偏向（偏向锁） 对象头主要包括两部分数据：Mark Word（标记字段， 存储对象自身的运行时数据）、class Pointer（类型指针， 是对象指向它的类元数据的指针）。</li>
<li><strong>轻量级锁</strong>（自旋锁） ：锁标志-00。<ol>
<li>在把线程进行阻塞操作之前先让线程自旋等待一段时间，可能在等待期间其他线程已经解锁，这时就无需再让线程执行阻塞操作，避免了用户态到内核态的切换。（自适应自旋时间为一个线程上下文切换的时间）</li>
<li>在用自旋锁时有可能造成死锁，当递归调用时有可能造成死锁</li>
<li>自旋锁底层是通过指向线程栈中Lock Record的指针来实现的</li>
</ol>
</li>
<li><strong>重量级锁</strong>：锁标志-10。</li>
</ul>
<h4 id="问：轻量级锁与偏向锁的区别？"><a href="#问：轻量级锁与偏向锁的区别？" class="headerlink" title="问：轻量级锁与偏向锁的区别？"></a>问：轻量级锁与偏向锁的区别？</h4><ol>
<li>偏向锁对象头 <code>Mark Word</code> 中存放线程ID，轻量级锁则是栈帧中锁记录的指针。</li>
<li>偏向锁是在无竞争场景下完全消除同步，连CAS也不执行；轻量级锁是通过CAS来避免进入开销较大的互斥操作。</li>
<li>偏向锁遇到线程竞争会升级为轻量级锁，前者适用于只有一个线程访问同步块，后者则是线程竞争不激烈的场景。</li>
</ol>
<h4 id="问：自旋锁升级到重量级锁条件？"><a href="#问：自旋锁升级到重量级锁条件？" class="headerlink" title="问：自旋锁升级到重量级锁条件？"></a>问：自旋锁升级到重量级锁条件？</h4><ol>
<li>某线程自旋次数超过10次；</li>
<li>等待的自旋线程超过了系统core数的一半；</li>
</ol>
<h4 id="问：讲讲读写锁？优点？实现方式？"><a href="#问：讲讲读写锁？优点？实现方式？" class="headerlink" title="问：讲讲读写锁？优点？实现方式？"></a>问：讲讲读写锁？优点？实现方式？</h4><p>读写锁即分离了读锁和写锁，同一时刻允许多个线程访问，提高了读操作间的并发性。</p>
<p>优点有：</p>
<ul>
<li>保证了读操作间的并发。</li>
<li>保证写操作对读操作的可见性。</li>
<li>简化读写交互场景的编程方式。</li>
</ul>
<p>并发包中提供了读写锁 <code>ReentrantReanWriteLock</code> ，和ReentrantLock相似，同样基于AQS，但是读写锁是基于共享资源的，不是互斥，关键在于state的处理，读写锁把高16为记为读状态，低16位记为写状态，从而分开了读写操作，读读情况其实就是读锁重入，读写/写读/写写都是互斥的，只要判断低16位就好了。读状态是所有线程获取读锁次数的总和，每个线程各自的获取次数则存在ThreadLocal中。</p>
<h4 id="问：乐观锁和悲观锁的区别？优缺点？使用场景？JDK中涉及到乐观锁和悲观锁的内容？这两种锁在Java和MySQL分别是怎么实现的？MySql的悲观锁怎么防止并发？"><a href="#问：乐观锁和悲观锁的区别？优缺点？使用场景？JDK中涉及到乐观锁和悲观锁的内容？这两种锁在Java和MySQL分别是怎么实现的？MySql的悲观锁怎么防止并发？" class="headerlink" title="问：乐观锁和悲观锁的区别？优缺点？使用场景？JDK中涉及到乐观锁和悲观锁的内容？这两种锁在Java和MySQL分别是怎么实现的？MySql的悲观锁怎么防止并发？"></a>问：乐观锁和悲观锁的区别？优缺点？使用场景？JDK中涉及到乐观锁和悲观锁的内容？这两种锁在Java和MySQL分别是怎么实现的？MySql的悲观锁怎么防止并发？</h4><p>乐观锁和悲观锁的区别：如字面意思，乐观锁指总是假设最好的情况，每次操作都不会上锁，而是更新时判断是否在此期间有被其他线程修改；悲观锁则相反，总假设最坏的情况，共享资源每次只给一个线程使用。</p>
<p>优缺点：两种锁适用于不同的场景，当共享资源竞争激烈时，乐观锁产生大量的更新失败，导致一些操作会浪费CPU资源如自旋；而资源竞争不那么激烈时，悲观锁所要进行的线程阻塞切换、等待唤醒等需要额外浪费CPU资源。</p>
<p>使用场景：乐观锁常见于多读少写的应用场景；悲观锁被应用于传统关系型数据库，如行锁，表锁，读锁，写锁等，适用于多写少读的场景。</p>
<p>悲观锁实现方式：</p>
<ul>
<li>JDK：<code>synchronized</code> ，<code>RetreentLock</code> 等。</li>
<li>MySQL：行锁，表锁，读锁，写锁等</li>
</ul>
<p>乐观锁实现方式：（CAS，版本号机制）</p>
<ul>
<li>JDK：CAS，JVM中的CAS操作通过处理器提供的 <code>CMPXCHG</code> 指令来实现原子操作。</li>
<li>MySQL：MVCC-多版本并发控制。</li>
</ul>
<p>MySql的悲观锁怎么防止并发：TODO</p>
<h4 id="问：死锁产生的原因？如何预防？死锁的条件，怎么解除死锁，怎么观测死锁？"><a href="#问：死锁产生的原因？如何预防？死锁的条件，怎么解除死锁，怎么观测死锁？" class="headerlink" title="问：死锁产生的原因？如何预防？死锁的条件，怎么解除死锁，怎么观测死锁？"></a>问：死锁产生的原因？如何预防？死锁的条件，怎么解除死锁，怎么观测死锁？</h4><p>死锁产生的原因是线程之间相互等待，导致程序瘫痪。</p>
<p>如何预防死锁：一般是允许前三个必要条件，通过合理的分配算法确保不会形成封闭等待链。</p>
<p>死锁产生有四个必要条件：</p>
<ol>
<li>互斥条件：资源同时只能被一个线程占有，线程间互斥等待。</li>
<li>不可剥夺条件：线程获得资源后不能被夺走，只能主动释放。</li>
<li>请求和保持条件：线程请求的资源被其他线程占据，此线程被阻塞但不会释放已有的资源。</li>
<li>循环等待条件：存在线程间的循环等待链路，前一个线程请求资源被下个线程持有。</li>
</ol>
<p>处理死锁的方法：</p>
<ol>
<li>避免一个线程同时获得多个锁。</li>
<li>避免一个线程在锁内同时占用多个资源，尽量保证每个锁只占用一个资源。</li>
<li>尝试使用定时锁，使用 <code>lock.tryLock(timeout)</code> 来代替内部锁机制。</li>
<li>对于数据库锁，加锁和解锁必须在同一个数据库连接里，避免解锁失败情况。</li>
</ol>
<p>检测死锁的方法：</p>
<ul>
<li>通过JStack工具生成JVM当前的线程快照，通过线程快照定位线程停顿的原因，死锁一般是因为线程互相等待对方持有的对象。</li>
<li>通过JConsole监控工具，检测线程死锁。</li>
</ul>
<h4 id="问：加锁会带来哪些性能问题。如何解决？"><a href="#问：加锁会带来哪些性能问题。如何解决？" class="headerlink" title="问：加锁会带来哪些性能问题。如何解决？"></a>问：加锁会带来哪些性能问题。如何解决？</h4><p>锁的开销来自于三部分：</p>
<ol>
<li>上下文切换，<strong>挂起当前线程</strong>（存储当前上下文），<strong>恢复一个线程</strong>（找到一个合适的上下文并恢复到寄存器），<strong>跳转到程序计数器指向的位置</strong>（即线程被中断时的代码行）。</li>
<li>调度器开销，唤醒或休眠线程。</li>
<li>多核环境的跨处理器调度开销。</li>
</ol>
<p>如何解决这些性能开销：</p>
<ol>
<li>减少线程切换，如通过CAS尝试短时间内请求锁的自旋锁。</li>
<li>减少锁的冲突次数，比如读写锁分离，哈希表分段加锁等。</li>
<li>在较少竞争的环境下尽量避免使用锁，如 <code>synchronized</code> 对锁分等级，CAS + volatile 等</li>
</ol>
<h4 id="问：偏向锁、轻量级锁、自旋锁等优化？"><a href="#问：偏向锁、轻量级锁、自旋锁等优化？" class="headerlink" title="问：偏向锁、轻量级锁、自旋锁等优化？"></a>问：偏向锁、轻量级锁、自旋锁等优化？</h4><h4 id="问：事务有哪些特性？"><a href="#问：事务有哪些特性？" class="headerlink" title="问：事务有哪些特性？"></a>问：事务有哪些特性？</h4><h4 id="问：怎么理解原子性？"><a href="#问：怎么理解原子性？" class="headerlink" title="问：怎么理解原子性？"></a>问：怎么理解原子性？</h4><hr>
<h3 id="2-2-volatile"><a href="#2-2-volatile" class="headerlink" title="2.2 volatile"></a>2.2 volatile</h3><h4 id="问：volatile的作用是什么？可见性？volatile-的实现原理？"><a href="#问：volatile的作用是什么？可见性？volatile-的实现原理？" class="headerlink" title="问：volatile的作用是什么？可见性？volatile 的实现原理？"></a>问：volatile的作用是什么？可见性？volatile 的实现原理？</h4><p>volatile变量<br>（1）：变量可见性</p>
<p>（2）：防止指令重排序</p>
<p>（3）：保障变量单次读，写操作的原子性，但不能保证i++这种操作的原子性，因为本质是读，写两次操作</p>
<h4 id="问：volatile-的实现原理？及内存屏障相关？"><a href="#问：volatile-的实现原理？及内存屏障相关？" class="headerlink" title="问：volatile 的实现原理？及内存屏障相关？"></a>问：volatile 的实现原理？及内存屏障相关？</h4><h4 id="问：volatile如何保证线程间可见和避免指令重排？"><a href="#问：volatile如何保证线程间可见和避免指令重排？" class="headerlink" title="问：volatile如何保证线程间可见和避免指令重排？"></a>问：volatile如何保证线程间可见和避免指令重排？</h4><p>volatile可见性是有指令原子性保证的，在jmm中定义了8类原子性指令，比如write，store，read，load。而volatile就要求write-store，load-read成为一个原子性操作，这样子可以确保在读取的时候都是从主内存读入，写入的时候会同步到主内存中（准确来说也是内存屏障），指令重排则是由内存屏障来保证的，由两个内存屏障:</p>
<blockquote>
<ul>
<li>一个是编译器屏障：阻止编译器重排，保证编译程序时在优化屏障之前的指令不会在优化屏障之后执行。</li>
<li>第二个是cpu屏障：sfence保证写入，lfence保证读取，lock类似于锁的方式。java多执行了一个“load addl $0x0, (%esp)”操作，这个操作相当于一个lock指令，就是增加一个完全的内存屏障指令。</li>
</ul>
</blockquote>
<hr>
<h3 id="2-3-synchronized"><a href="#2-3-synchronized" class="headerlink" title="2.3 synchronized"></a>2.3 synchronized</h3><h4 id="问：synchronized-使用方式及实现原理，以及锁优化？"><a href="#问：synchronized-使用方式及实现原理，以及锁优化？" class="headerlink" title="问：synchronized 使用方式及实现原理，以及锁优化？"></a>问：synchronized 使用方式及实现原理，以及锁优化？</h4><p>synchronized实现原理？</p>
<p>contentionList（请求锁线程队列） entryList（有资格的候选者队列） waitSet（wait方法后阻塞队列） onDeck（竞争候选者） ower（竞争到锁线程） !ower（执行成功释放锁后状态）； Synchronized 是非公平锁。</p>
<p>Synchronized 在线程进入 ContentionList 时，等待的线程会先尝试自旋获取锁，如果获取不到就进入 ContentionList，这明显对于已经进入队列的线程是不公平的，还有一个不公平的事情就是自旋获取锁的线程还可能直接抢占 OnDeck 线程的锁资源。</p>
<p>底层是由一对monitorenter和monitorexit指令实现的（监视器锁）</p>
<p>每个对象有一个监视器锁（monitor）。当monitor被占用时就会处于锁定状态，线程执行monitorenter指令时尝试获取monitor的所有权，过程：</p>
<blockquote>
<ul>
<li>如果monitor的进入数为0，则该线程进入monitor，然后将进入数设置为1，该线程即为monitor的所有者。</li>
<li>如果线程已经占有该monitor，只是重新进入，则进入monitor的进入数加1.</li>
<li>如果其他线程已经占用了monitor，则该线程进入阻塞状态，直到monitor的进入数为0，再重新尝试获取monitor的所有权。</li>
</ul>
</blockquote>
<h4 id="问：synchronized-在静态方法和普通方法的区别？"><a href="#问：synchronized-在静态方法和普通方法的区别？" class="headerlink" title="问：synchronized 在静态方法和普通方法的区别？"></a>问：synchronized 在静态方法和普通方法的区别？</h4><h4 id="问：synchronized-和-ReentranLock的区别？"><a href="#问：synchronized-和-ReentranLock的区别？" class="headerlink" title="问：synchronized 和 ReentranLock的区别？"></a>问：synchronized 和 ReentranLock的区别？</h4><blockquote>
<ul>
<li>都是可重入锁； R是显示获取和释放锁，s是隐式；</li>
<li>R更灵活可以知道有没有成功获取锁，可以定义读写锁，是api级别，s是JVM级别；</li>
<li>R可以定义公平锁；Lock是接口，s是java中的关键字</li>
</ul>
</blockquote>
<h4 id="问：synchronized-和-lock-有什么区别？"><a href="#问：synchronized-和-lock-有什么区别？" class="headerlink" title="问：synchronized 和 lock 有什么区别？"></a>问：synchronized 和 lock 有什么区别？</h4><h4 id="问：HashTable，同步锁，synchronized-关键字-1-6-之后提升了什么，怎么提升的这些？"><a href="#问：HashTable，同步锁，synchronized-关键字-1-6-之后提升了什么，怎么提升的这些？" class="headerlink" title="问：HashTable，同步锁，synchronized 关键字 1.6 之后提升了什么，怎么提升的这些？"></a>问：HashTable，同步锁，synchronized 关键字 1.6 之后提升了什么，怎么提升的这些？</h4><hr>
<h3 id="2-4-Lock"><a href="#2-4-Lock" class="headerlink" title="2.4 Lock"></a>2.4 Lock</h3><h4 id="问：Lock-接口有哪些实现类，使用场景是什么？"><a href="#问：Lock-接口有哪些实现类，使用场景是什么？" class="headerlink" title="问：Lock 接口有哪些实现类，使用场景是什么？"></a>问：Lock 接口有哪些实现类，使用场景是什么？</h4><h4 id="问：讲讲ReentrantLock实现原理？"><a href="#问：讲讲ReentrantLock实现原理？" class="headerlink" title="问：讲讲ReentrantLock实现原理？"></a>问：讲讲ReentrantLock实现原理？</h4><p>ReentrantLock原理（CAS+AQS）</p>
<p>CAS+AQS队列来实现<br>（1）：先通过CAS尝试获取锁， 如果此时已经有线程占据了锁，那就加入AQS队列并且被挂起；</p>
<p>（2）： 当锁被释放之后， 排在队首的线程会被唤醒CAS再次尝试获取锁，</p>
<p>（3）：如果是非公平锁， 同时还有另一个线程进来尝试获取可能会让这个线程抢到锁；</p>
<p>（4）：如果是公平锁， 会排到队尾，由队首的线程获取到锁。</p>
<h4 id="问：ReentrantLock-是如何实现可重入性的-？"><a href="#问：ReentrantLock-是如何实现可重入性的-？" class="headerlink" title="问：ReentrantLock 是如何实现可重入性的 ？"></a>问：ReentrantLock 是如何实现可重入性的 ？</h4><p>内部自定义了同步器 Sync，加锁的时候通过CAS 算法 ，将线程对象放到一个双向链表 中，每次获取锁的时候 ，看下当前维 护的那个线程ID和当前请求的线程ID是否一样，一样就可重入了；</p>
<h4 id="问：ReentrantLock如何避免死锁"><a href="#问：ReentrantLock如何避免死锁" class="headerlink" title="问：ReentrantLock如何避免死锁?"></a>问：ReentrantLock如何避免死锁?</h4><blockquote>
<ul>
<li>响应中断lockInterruptibly（）</li>
<li>可轮询锁tryLock（）</li>
<li>定时锁tryLock（long time）</li>
</ul>
</blockquote>
<h4 id="问：tryLock-和-lock-和-lockInterruptibly-的区别"><a href="#问：tryLock-和-lock-和-lockInterruptibly-的区别" class="headerlink" title="问：tryLock 和 lock 和 lockInterruptibly 的区别?"></a>问：tryLock 和 lock 和 lockInterruptibly 的区别?</h4><p>（1）：tryLock 能获得锁就返回 true，不能就立即返回 false，</p>
<p>（2）：tryLock（long timeout，TimeUnit unit），可以增加时间限制，如果超过该时间段还没获得锁，返回 false</p>
<p>（3）：lock 能获得锁就返回 true，不能的话一直等待获得锁</p>
<p>（4）：lock 和 lockInterruptibly，如果两个线程分别执行这两个方法，但此时中断这两个线程， lock 不会抛出异常，而 lockInterruptibly 会抛出异常。</p>
<hr>
<h3 id="2-5-Condition"><a href="#2-5-Condition" class="headerlink" title="2.5 Condition"></a>2.5 Condition</h3><h4 id="问：讲一下Condition？"><a href="#问：讲一下Condition？" class="headerlink" title="问：讲一下Condition？"></a>问：讲一下Condition？</h4><p>Condition接口主要是和Lock配合实现等待通知模式，类似于对象监视器方法和synchronized的组合。其定义了一系列等待和唤醒方法，Condition对象依赖于Lock对象，一个Condition包含一个等待队列，Condition拥有首节点（firstWaiter）和尾节点（lastWaiter）。等待时将节点从同步队列移动到等待队列，需要把当前线程构建成一个新的等待结点。通知时则不需要新建节点，可以看作直接把等待节点移动到同步队列。</p>
<h4 id="问：对象监视器方法和Condition的异同-？"><a href="#问：对象监视器方法和Condition的异同-？" class="headerlink" title="问：对象监视器方法和Condition的异同 ？"></a>问：对象监视器方法和Condition的异同 ？</h4><p><strong>任意一个Java对象，都拥有一组监视器方法</strong>（定义在 <code>java.lang.Object</code> 上），主要包括 <code>wait()</code> 、<code>wait(long timeout)</code> 、<code>notify()</code> 以及 <code>notifyAll()</code> 方法，这些方法与 <code>synchronized</code> 同步关键字配合，可以实现<strong>等待/通知模式</strong>。</p>
<p><code>Condition</code> 接口也提供了类似 <code>Object</code> 的监视器方法，与Lock配合可以实现<strong>等待/通知模式</strong>，但是这两者在使用方式以及功能特性上还是有差别的。</p>
<p><img src="https://pic-1258215793.cos.ap-shanghai.myqcloud.com/content/20190601/201906010120.png" alt="Object的监视器方法与Condition接口的对比"></p>
<hr>
<h3 id="2-6-AQS"><a href="#2-6-AQS" class="headerlink" title="2.6 AQS"></a>2.6 AQS</h3><h4 id="问：讲讲AQS？实现原理？讲讲AQS怎么实现的Fair和NoFair？"><a href="#问：讲讲AQS？实现原理？讲讲AQS怎么实现的Fair和NoFair？" class="headerlink" title="问：讲讲AQS？实现原理？讲讲AQS怎么实现的Fair和NoFair？"></a>问：讲讲AQS？实现原理？讲讲AQS怎么实现的Fair和NoFair？</h4><p>AQS即队列同步器（AbstractQueuedSynchronizer），是构建锁和其他同步组件的基础框架，锁是面向使用者的，同步器则是面向锁的实现者。</p>
<p>实现原理：AQS底层是一个双向链表实现的FIFO同步队列，通过整型成员变量state来判断锁的同步状态，基于模板方法模式来设计，包含独占式和共享式的获取同步状态，各种锁自定义实现AQS。</p>
<p>对于非可重入锁状态不是0则去阻塞；对于可重入锁如果是0则执行，非0则判断当前线程是否是获取到这个锁的线程，是的话把state状态＋1，比如重入5次，那么state=5。 而在释放锁的时候，同样需要释放5次直到state=0其他线程才有资格获得锁。</p>
<h4 id="问：AQS两种资源共享方式？"><a href="#问：AQS两种资源共享方式？" class="headerlink" title="问：AQS两种资源共享方式？"></a>问：AQS两种资源共享方式？</h4><ul>
<li>Exclusive：独占，只有一个线程能执行，如ReentrantLock。</li>
<li>Share：共享，多个线程可以同时执行，如Semaphore、CountDownLatch、ReadWriteLock，CyclicBarrier。</li>
</ul>
<h4 id="问：CAS了解么？-CAS-有什么缺陷，如何解决？还了解其他同步机制么？"><a href="#问：CAS了解么？-CAS-有什么缺陷，如何解决？还了解其他同步机制么？" class="headerlink" title="问：CAS了解么？ CAS 有什么缺陷，如何解决？还了解其他同步机制么？"></a>问：CAS了解么？ CAS 有什么缺陷，如何解决？还了解其他同步机制么？</h4><p>CAS，Compare and Set，比较并交换，常用来实现乐观锁。</p>
<p>实现原理：内存值，预期值，修改的新值，当内存值等于预期值时，将内存值修改为新值，否则什么都不做。</p>
<p>CAS的缺陷有三个：</p>
<ol>
<li>ABA问题，即A变为B再变为A也能满足判断条件。</li>
<li>如果CAS失败，自旋会给CPU带来压力，死循环。</li>
<li>只能保证对一个变量的原子性操作。</li>
</ol>
<p>解决方案分别是：</p>
<ol>
<li>引入版本号或修改次数，1A-&gt;2B-&gt;3A。</li>
<li>使用JVM提供的pause指令。</li>
<li>用锁将多个共享变量合并为一个来操作，使用 <code>AtomicReference</code> 类来保证引用对象之间的原子性，就可以把多个变量放在一个对象里来进行CAS操作。</li>
</ol>
<p>CAS在java中的应用：<br>（1）：Atomic系列</p>
<p>还有信号量机制，自旋锁等。</p>
<h4 id="问：CAS和synchronized有什么区别？都用synchronized不行么？"><a href="#问：CAS和synchronized有什么区别？都用synchronized不行么？" class="headerlink" title="问：CAS和synchronized有什么区别？都用synchronized不行么？"></a>问：CAS和synchronized有什么区别？都用synchronized不行么？</h4><p>synchronized是获取对象锁，属于重量级锁，虽然有进行优化，但还是有一定的性能开销。CAS则并未利用锁，其机制比较适合读多写少的场景。</p>
<p>如果都采用synchronized，在并发编程时不能获得令人满意的执行效率。</p>
<hr>
<h3 id="2-7-CountDownLatch"><a href="#2-7-CountDownLatch" class="headerlink" title="2.7 CountDownLatch"></a>2.7 CountDownLatch</h3><h4 id="问：用过CountDownLatch么？什么场景下用的？"><a href="#问：用过CountDownLatch么？什么场景下用的？" class="headerlink" title="问：用过CountDownLatch么？什么场景下用的？"></a>问：用过CountDownLatch么？什么场景下用的？</h4><h4 id="问：什么是信号量Semaphore？应用场景？"><a href="#问：什么是信号量Semaphore？应用场景？" class="headerlink" title="问：什么是信号量Semaphore？应用场景？"></a>问：什么是信号量Semaphore？应用场景？</h4><p>信号量是一种固定资源的限制的一种并发工具包，基于AQS实现的，在构造的时候会设置一个值，代表着资源数量。信号量主要是应用于是用于多个共享资源的互斥使用，和用于并发线程数的控制（druid的数据库连接数，就是用这个实现的），信号量也分公平和非公平的情况，基本方式和reentrantLock差不多，在请求资源调用task时，会用自旋的方式减1，如果成功，则获取成功了，如果失败，导致资源数变为了0，就会加入队列里面去等待。调用release的时候会加一，补充资源,并唤醒等待队列。</p>
<blockquote>
<p>Semaphore 应用</p>
<ul>
<li>acquire（） release（） 可用于对象池，资源池的构建，比如静态全局对象池，数据库连接池；</li>
<li>可创建计数为1的S，作为互斥锁（二元信号量）</li>
</ul>
</blockquote>
<h4 id="问：用过CyclicBarrier吗？-和-countdownlatch-的区别？"><a href="#问：用过CyclicBarrier吗？-和-countdownlatch-的区别？" class="headerlink" title="问：用过CyclicBarrier吗？ 和 countdownlatch 的区别？"></a>问：用过CyclicBarrier吗？ 和 countdownlatch 的区别？</h4><p>个人理解 赛马和点火箭</p>
<blockquote>
<ul>
<li>con用于主线程等待其他子线程任务都执行完毕后再执行，cyc用于一组线程相互等待大家都达到某个状态后，再同时执行；</li>
<li>CountDownLatch是不可重用的，CyclicBarrier可重用</li>
</ul>
</blockquote>
<p>CountDownLatch是等待其他线程执行到某一个点的时候，在继续执行逻辑（子线程不会被阻塞，会继续执行），只能被使用一次。最常见的就是join形式，主线程等待子线程执行完任务，在用主线程去获取结果的方式（当然不一定），内部是用计数器相减实现的（没错，又特么是AQS），AQS的state承担了计数器的作用，初始化的时候，使用CAS赋值，主线程调用await（）则被加入共享线程等待队列里面，子线程调用countDown的时候，使用自旋的方式，减1，知道为0，就触发唤醒。</p>
<p>CyclicBarrier回环屏障，主要是等待一组线程到底同一个状态的时候，放闸。CyclicBarrier还可以传递一个Runnable对象，可以到放闸的时候，执行这个任务。CyclicBarrier是可循环的，当调用await的时候如果count变成0了则会重置状态，如何重置呢，CyclicBarrier新增了一个字段parties，用来保存初始值，当count变为0的时候，就重新赋值。还有一个不同点，CyclicBarrier不是基于AQS的，而是基于RentrantLock实现的。存放的等待队列是用了条件变量的方式。</p>
<hr>
<h3 id="2-8-锁的应用"><a href="#2-8-锁的应用" class="headerlink" title="2.8 锁的应用"></a>2.8 锁的应用</h3><h4 id="问：ConcurrentHashMap的get需要加锁么，为什么？"><a href="#问：ConcurrentHashMap的get需要加锁么，为什么？" class="headerlink" title="问：ConcurrentHashMap的get需要加锁么，为什么？"></a>问：ConcurrentHashMap的get需要加锁么，为什么？</h4><h4 id="问：Hashtable-是怎么加锁的-？"><a href="#问：Hashtable-是怎么加锁的-？" class="headerlink" title="问：Hashtable 是怎么加锁的 ？"></a>问：Hashtable 是怎么加锁的 ？</h4><hr>
<h2 id="三-内存模型"><a href="#三-内存模型" class="headerlink" title="三. 内存模型"></a>三. 内存模型</h2><h4 id="问：Java内存模型？为什么要有工作内存和主内存？"><a href="#问：Java内存模型？为什么要有工作内存和主内存？" class="headerlink" title="问：Java内存模型？为什么要有工作内存和主内存？"></a>问：Java内存模型？为什么要有工作内存和主内存？</h4><p>为什么要有工作内存和主内存：计算机随着技术发展CPU与内存速度差距越来越大，于是出现高速缓存技术存放CPU常用数据，其速度与CPU接近，多核多线程每个核都有自己的缓存区，所以面临着缓存一致性问题。Java内存模型主要为了解决这个问题。</p>
<p>所有的实例域、静态域和数组元素都存储在堆内存中，堆内存在线程之间共享。可以将它们看作共享变量。而局部变量，方法定义参数和异常处理器参数这些则不会在线程之间共享，它们不会有内存可见性问题，也不受内存模型的影响。</p>
<p>Java内存模型定义了线程和主内存之间的抽象关系：线程之间的共享变量存储在主内存（Main Memory）中，每个线程都有一个私有的本地内存（Local Memory），本地内存中存储了该线程以读/写共享变量的副本。本地内存是JMM(Java内存模型)的一个抽象概念，并不真实存在。它涵盖了缓存、写缓冲区、寄存器以及其他的硬件和编译器优化。</p>
<p>即三个规则：</p>
<ul>
<li>所有的数据都在主内存中。</li>
<li>每个线程都保留一份共享变量的副本。线程对变量的所有操作都必须在这个副本内存中进行，而不能直接读写主内存。</li>
<li>不同的线程之间也无法直接访问对方工作内存中的变量，线程间变量的传递均需要自己的工作内存和主存之间进行数据同步进行。</li>
</ul>

    </div>

    
    
    

    <footer class="post-footer">
          

<div class="post-copyright">
<ul>
  <li class="post-copyright-author">
      <strong>本文作者： </strong>Lys
  </li>
  <li class="post-copyright-link">
      <strong>本文链接：</strong>
      <a href="http://linyishui.top/2019102201.html" title="面试整理——Java并发编程">http://linyishui.top/2019102201.html</a>
  </li>
  <li class="post-copyright-license">
    <strong>版权声明： </strong>本博客所有文章除特别声明外，均采用 <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/deed.zh" rel="noopener" target="_blank"><i class="fab fa-fw fa-creative-commons"></i>BY-NC-SA</a> 许可协议。转载请注明出处！
  </li>
</ul>
</div>

          <div class="post-tags">
              <a href="/tags/Q-A/" rel="tag"><i class="fa fa-tag"></i> Q&A</a>
              <a href="/tags/updating/" rel="tag"><i class="fa fa-tag"></i> updating</a>
          </div>

        

          <div class="post-nav">
            <div class="post-nav-item">
                <a href="/2019102101.html" rel="prev" title="面试整理——Java集合">
                  <i class="fa fa-chevron-left"></i> 面试整理——Java集合
                </a>
            </div>
            <div class="post-nav-item">
                <a href="/2019102301.html" rel="next" title="面试整理——Java网络编程">
                  面试整理——Java网络编程 <i class="fa fa-chevron-right"></i>
                </a>
            </div>
          </div>
    </footer>
  </article>
</div>






    <div class="comments utterances-container"></div>
</div>
  </main>

  <footer class="footer">
    <div class="footer-inner">


<div class="copyright">
  &copy; 2018 – 
  <span itemprop="copyrightYear">2022</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">Lys</span>
</div>
<div class="wordcount">
  <span class="post-meta-item">
    <span class="post-meta-item-icon">
      <i class="fa fa-chart-line"></i>
    </span>
      <span>站点总字数：</span>
    <span title="站点总字数">3.6m</span>
  </span>
  <span class="post-meta-item">
    <span class="post-meta-item-icon">
      <i class="fa fa-coffee"></i>
    </span>
      <span>站点阅读时长 &asymp;</span>
    <span title="站点阅读时长">54:03</span>
  </span>
</div>
  <div class="powered-by">由 <a href="https://hexo.io/" rel="noopener" target="_blank">Hexo</a> & <a href="https://theme-next.js.org/pisces/" rel="noopener" target="_blank">NexT.Pisces</a> 强力驱动
  </div>

    </div>
  </footer>

  
  <script src="https://cdn.jsdelivr.net/npm/animejs@3.2.1/lib/anime.min.js" integrity="sha256-XL2inqUJaslATFnHdJOi9GfQ60on8Wx1C2H8DYiN1xY=" crossorigin="anonymous"></script>
  <script src="https://cdn.jsdelivr.net/npm/jquery@3.6.0/dist/jquery.min.js" integrity="sha256-/xUj+3OJU5yExlq6GSYGSHk7tPXikynS7ogEvDej/m4=" crossorigin="anonymous"></script>
  <script src="https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@3.5.7/dist/jquery.fancybox.min.js" integrity="sha256-yt2kYMy0w8AbtF89WXb2P1rfjcP/HTHLT7097U8Y5b8=" crossorigin="anonymous"></script>
<script src="/js/comments.js"></script><script src="/js/utils.js"></script><script src="/js/motion.js"></script><script src="/js/next-boot.js"></script><script src="/js/bookmark.js"></script>

  
<script src="/js/third-party/search/local-search.js"></script>



  <script class="next-config" data-name="nprogress" type="application/json">{"enable":true,"spinner":true}</script>
  <script src="/js/third-party/nprogress.js"></script>

  




<script src="https://cdn.jsdelivr.net/npm/darkmode-js@1.5.7/lib/darkmode-js.min.js"></script>

<script>
var options = {
  bottom: '64px',
  right: '32px',
  left: 'unset',
  time: '0.5s',
  mixColor: 'transparent',
  backgroundColor: 'transparent',
  buttonColorDark: '#100f2c',
  buttonColorLight: '#fff',
  saveInCookies: true,
  label: '🌓',
  autoMatchOsTheme: true
}
const darkmode = new Darkmode(options);
window.darkmode = darkmode;
darkmode.showWidget();
</script>
<script class="next-config" data-name="utterances" type="application/json">{"enable":true,"repo":"LAILAIWA/LAILAIWA.github.io","issue_term":"pathname","theme":"github-light"}</script>
<script src="/js/third-party/comments/utterances.js"></script>



</body>
</html>
