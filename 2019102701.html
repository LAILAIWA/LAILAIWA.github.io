<!DOCTYPE html>
<html lang="zh-CN">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width">
<meta name="theme-color" content="#222">
<meta name="generator" content="Hexo 5.4.0">


  <link rel="apple-touch-icon" sizes="180x180" href="/images/gamepad%20playstation.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/Dig%20Dug.ico">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/gamepad%20playstation.png">
  <link rel="mask-icon" href="/images/gamepad%20playstation.svg" color="#222">

<link rel="stylesheet" href="/css/main.css">

<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Monda:300,300italic,400,400italic,700,700italic%7CMa+Shan+Zheng:300,300italic,400,400italic,700,700italic%7CNoto+Serif+SC:300,300italic,400,400italic,700,700italic&display=swap&subset=latin,latin-ext">

<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free@5.15.3/css/all.min.css" integrity="sha256-2H3fkXt6FEmrReK448mDVGKb3WW2ZZw35gI7vqHOE4Y=" crossorigin="anonymous">
  <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/animate.css@3.1.1/animate.min.css" integrity="sha256-PR7ttpcvz8qrF57fur/yAx1qXMFJeJFiA6pSzWi0OIE=" crossorigin="anonymous">
  <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@3.5.7/dist/jquery.fancybox.min.css" integrity="sha256-Vzbj7sDDS/woiFS3uNKo8eIuni59rjyNGtXfstRzStA=" crossorigin="anonymous">
  <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/nprogress@0.2.0/nprogress.css" integrity="sha256-no0c5ccDODBwp+9hSmV5VvPpKwHCpbVzXHexIkupM6U=" crossorigin="anonymous">
  <script src="https://cdn.jsdelivr.net/npm/nprogress@0.2.0/nprogress.js" integrity="sha256-a5YRB27CcBwBFcT5EF/f3E4vzIqyHrSR878nseNYw64=" crossorigin="anonymous"></script>

<script class="next-config" data-name="main" type="application/json">{"hostname":"linyishui.top","root":"/","images":"/images","scheme":"Pisces","version":"8.6.0","exturl":false,"sidebar":{"position":"left","display":"always","padding":18,"offset":12},"copycode":true,"bookmark":{"enable":true,"color":"#222","save":"manual"},"fancybox":true,"mediumzoom":false,"lazyload":false,"pangu":false,"comments":{"style":"tabs","active":"utterances","storage":true,"lazyload":false,"nav":null,"activeClass":"utterances"},"motion":{"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"fadeInDown","post_body":"fadeInDown","coll_header":"fadeInLeft","sidebar":"fadeInUp"}},"prism":false,"i18n":{"placeholder":"搜索...","empty":"没有找到任何搜索结果：${query}","hits_time":"找到 ${hits} 个搜索结果（用时 ${time} 毫秒）","hits":"找到 ${hits} 个搜索结果"},"path":"/search.xml","localsearch":{"enable":true,"trigger":"auto","top_n_per_article":1,"unescape":false,"preload":false}}</script><script src="/js/config.js"></script>
<meta name="description" content="整理面试中常问的操作系统相关问题，持续更新中。">
<meta property="og:type" content="article">
<meta property="og:title" content="面试整理——操作系统">
<meta property="og:url" content="http://linyishui.top/2019102701.html">
<meta property="og:site_name" content="俺的部落格">
<meta property="og:description" content="整理面试中常问的操作系统相关问题，持续更新中。">
<meta property="og:locale" content="zh_CN">
<meta property="article:published_time" content="2019-10-27T08:24:13.000Z">
<meta property="article:modified_time" content="2025-01-20T03:33:53.119Z">
<meta property="article:author" content="Lys">
<meta property="article:tag" content="Q&amp;A">
<meta property="article:tag" content="updating">
<meta name="twitter:card" content="summary">


<link rel="canonical" href="http://linyishui.top/2019102701.html">



<script class="next-config" data-name="page" type="application/json">{"sidebar":"","isHome":false,"isPost":true,"lang":"zh-CN","comments":true,"permalink":"http://linyishui.top/2019102701.html","path":"2019102701.html","title":"面试整理——操作系统"}</script>

<script class="next-config" data-name="calendar" type="application/json">""</script>
<title>面试整理——操作系统 | 俺的部落格</title>
  




  <noscript>
    <link rel="stylesheet" href="/css/noscript.css">
  </noscript>
<link rel="alternate" href="/atom.xml" title="俺的部落格" type="application/atom+xml">
<style>.darkmode--activated{--body-bg-color:#282828;--content-bg-color:#333;--card-bg-color:#555;--text-color:#ccc;--blockquote-color:#bbb;--link-color:#ccc;--link-hover-color:#eee;--brand-color:#ddd;--brand-hover-color:#ddd;--table-row-odd-bg-color:#282828;--table-row-hover-bg-color:#363636;--menu-item-bg-color:#555;--btn-default-bg:#222;--btn-default-color:#ccc;--btn-default-border-color:#555;--btn-default-hover-bg:#666;--btn-default-hover-color:#ccc;--btn-default-hover-border-color:#666;--highlight-background:#282b2e;--highlight-foreground:#a9b7c6;--highlight-gutter-background:#34393d;--highlight-gutter-foreground:#9ca9b6}.darkmode--activated img{opacity:.75}.darkmode--activated img:hover{opacity:.9}.darkmode--activated code{color:#69dbdc;background:0 0}button.darkmode-toggle{z-index:9999}</style></head>

<body itemscope itemtype="http://schema.org/WebPage" class="use-motion">
  <div class="headband"></div>

  <main class="main">
    <header class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="切换导航栏" role="button">
        <span class="toggle-line"></span>
        <span class="toggle-line"></span>
        <span class="toggle-line"></span>
    </div>
  </div>

  <div class="site-meta">

    <a href="/" class="brand" rel="start">
      <i class="logo-line"></i>
      <h1 class="site-title">俺的部落格</h1>
      <i class="logo-line"></i>
    </a>
      <p class="site-subtitle" itemprop="description">俺寻思俺需要记点东西</p>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger">
        <i class="fa fa-search fa-fw fa-lg"></i>
    </div>
  </div>
</div>



<nav class="site-nav">
  <ul class="main-menu menu">
        <li class="menu-item menu-item-home"><a href="/" rel="section"><i class="fa fa-home fa-fw"></i>首页</a></li>
        <li class="menu-item menu-item-about"><a href="/about/" rel="section"><i class="fa fa-user fa-fw"></i>关于</a></li>
        <li class="menu-item menu-item-tags"><a href="/tags/" rel="section"><i class="fa fa-tags fa-fw"></i>标签</a></li>
        <li class="menu-item menu-item-categories"><a href="/categories/" rel="section"><i class="fa fa-th fa-fw"></i>分类</a></li>
        <li class="menu-item menu-item-archives"><a href="/archives/" rel="section"><i class="fa fa-archive fa-fw"></i>归档</a></li>
        <li class="menu-item menu-item-sitemap"><a href="/sitemap.xml" rel="section"><i class="fa fa-sitemap fa-fw"></i>站点地图</a></li>
        <li class="menu-item menu-item-tools"><a href="/links/" rel="section"><i class="fa fa-link fa-fw"></i>工具</a></li>
        <li class="menu-item menu-item-books"><a href="/books/" rel="section"><i class="fa fa-book fa-fw"></i>书架</a></li>
        <li class="menu-item menu-item-movies"><a href="/movies/" rel="section"><i class="fa fa-video fa-fw"></i>剧院</a></li>
        <li class="menu-item menu-item-games"><a href="/games/" rel="section"><i class="fa fa-gamepad fa-fw"></i>游戏</a></li>
        <li class="menu-item menu-item-commonweal"><a href="/404/" rel="section"><i class="fa fa-heartbeat fa-fw"></i>公益</a></li>
      <li class="menu-item menu-item-search">
        <a role="button" class="popup-trigger"><i class="fa fa-search fa-fw"></i>搜索
        </a>
      </li>
  </ul>
</nav>



  <div class="search-pop-overlay">
    <div class="popup search-popup"><div class="search-header">
  <span class="search-icon">
    <i class="fa fa-search"></i>
  </span>
  <div class="search-input-container">
    <input autocomplete="off" autocapitalize="off" maxlength="80"
           placeholder="搜索..." spellcheck="false"
           type="search" class="search-input">
  </div>
  <span class="popup-btn-close" role="button">
    <i class="fa fa-times-circle"></i>
  </span>
</div>
<div class="search-result-container no-result">
  <div class="search-result-icon">
    <i class="fa fa-spinner fa-pulse fa-5x"></i>
  </div>
</div>

    </div>
  </div>

</div>
        
  
  <div class="toggle sidebar-toggle" role="button">
    <span class="toggle-line"></span>
    <span class="toggle-line"></span>
    <span class="toggle-line"></span>
  </div>

  <aside class="sidebar">

    <div class="sidebar-inner sidebar-nav-active sidebar-toc-active">
      <ul class="sidebar-nav">
        <li class="sidebar-nav-toc">
          文章目录
        </li>
        <li class="sidebar-nav-overview">
          站点概览
        </li>
      </ul>

      <div class="sidebar-panel-container">
        <!--noindex-->
        <div class="post-toc-wrap sidebar-panel">
            <div class="post-toc animated"><ol class="nav"><li class="nav-item nav-level-1"><a class="nav-link" href="#%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F"><span class="nav-text">操作系统</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#%E4%B8%80-%E5%9F%BA%E6%9C%AC%E7%89%B9%E5%BE%81"><span class="nav-text">一. 基本特征</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E9%97%AE%EF%BC%9A%E5%B9%B6%E5%8F%91%E4%B8%8E%E5%B9%B6%E8%A1%8C%EF%BC%9F"><span class="nav-text">问：并发与并行？</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E9%97%AE%EF%BC%9A%E4%BB%80%E4%B9%88%E6%98%AF%E5%90%8C%E6%AD%A5%EF%BC%9F%E4%BB%80%E4%B9%88%E6%98%AF%E5%BC%82%E6%AD%A5%EF%BC%9F"><span class="nav-text">问：什么是同步？什么是异步？</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%90%8C%E6%AD%A5%E5%9C%BA%E6%99%AF"><span class="nav-text">同步场景</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%BC%82%E6%AD%A5%E5%9C%BA%E6%99%AF"><span class="nav-text">异步场景</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E9%97%AE%EF%BC%9A%E8%99%9A%E6%8B%9F%E6%8A%80%E6%9C%AF%EF%BC%9F"><span class="nav-text">问：虚拟技术？</span></a></li></ol></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E4%BA%8C-%E5%9F%BA%E6%9C%AC%E5%8A%9F%E8%83%BD"><span class="nav-text">二. 基本功能</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E9%97%AE%EF%BC%9A%E8%AF%B4%E4%B8%80%E4%B8%8B%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E7%9A%84%E5%9F%BA%E6%9C%AC%E5%8A%9F%E8%83%BD%E5%8C%85%E6%8B%AC%EF%BC%9F"><span class="nav-text">问：说一下操作系统的基本功能包括？</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#1-1-%E8%BF%9B%E7%A8%8B%E7%AE%A1%E7%90%86"><span class="nav-text">1.1 进程管理</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E9%97%AE%EF%BC%9A%E4%BB%80%E4%B9%88%E6%98%AF%E8%BF%9B%E7%A8%8B%EF%BC%9F%E4%BB%80%E4%B9%88%E6%98%AF%E7%BA%BF%E7%A8%8B%EF%BC%9F%E7%BA%BF%E7%A8%8B%E5%92%8C%E8%BF%9B%E7%A8%8B%E7%9A%84%E5%8C%BA%E5%88%AB%EF%BC%9F"><span class="nav-text">问：什么是进程？什么是线程？线程和进程的区别？</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E9%97%AE%EF%BC%9A%E8%BF%9B%E7%A8%8B%E7%9A%84%E6%95%B0%E6%8D%AE%E6%AE%B5%E5%92%8C%E5%86%85%E5%AD%98%EF%BC%9F%E8%BF%9B%E7%A8%8B%E5%92%8C%E7%BA%BF%E7%A8%8B%E7%9A%84%E5%86%85%E5%AD%98%E6%9C%89%E4%BB%80%E4%B9%88%E5%8C%BA%E5%88%AB%EF%BC%9F"><span class="nav-text">问：进程的数据段和内存？进程和线程的内存有什么区别？</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E9%97%AE%EF%BC%9A%E8%BF%9B%E7%A8%8B%E3%80%81%E7%BA%BF%E7%A8%8B%E9%97%B4%E7%9A%84%E9%80%9A%E4%BF%A1%E6%96%B9%E5%BC%8F%EF%BC%9F"><span class="nav-text">问：进程、线程间的通信方式？</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E9%97%AE%EF%BC%9A%E7%94%9F%E4%BA%A7%E8%80%85%E6%B6%88%E8%B4%B9%E8%80%85%E9%97%AE%E9%A2%98%EF%BC%9F"><span class="nav-text">问：生产者消费者问题？</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E9%97%AE%EF%BC%9A%E5%93%B2%E5%AD%A6%E5%AE%B6%E8%BF%9B%E9%A4%90%E9%97%AE%E9%A2%98%EF%BC%9F"><span class="nav-text">问：哲学家进餐问题？</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E9%97%AE%EF%BC%9A%E8%AF%BB%E8%80%85%E5%86%99%E8%80%85%E9%97%AE%E9%A2%98%EF%BC%9F"><span class="nav-text">问：读者写者问题？</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E9%97%AE%EF%BC%9A%E8%BF%9B%E7%A8%8B%E8%B0%83%E5%BA%A6%E7%AE%97%E6%B3%95%EF%BC%9F"><span class="nav-text">问：进程调度算法？</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E9%97%AE%EF%BC%9A%E8%BF%9B%E7%A8%8B%E4%B8%AD%E7%9A%84%E5%93%8D%E5%BA%94%E6%97%B6%E9%97%B4%E6%8C%87%EF%BC%9F"><span class="nav-text">问：进程中的响应时间指？</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E9%97%AE%EF%BC%9Afork%E5%92%8Cexec%E6%9C%89%E6%B7%B1%E5%85%A5%E4%BA%86%E8%A7%A3%E5%90%97%EF%BC%9F%E7%88%B6%E8%BF%9B%E7%A8%8B%E6%9C%89%E5%A4%9A%E4%B8%AA%E7%BA%BF%E7%A8%8B%E5%9C%A8%E8%BF%90%E8%A1%8C%EF%BC%8C%E8%B0%83%E7%94%A8fork%E5%90%8E%EF%BC%8C%E4%BA%A7%E7%94%9F%E7%9A%84%E5%AD%90%E8%BF%9B%E7%A8%8B%E4%B8%AD%E6%9C%89%E5%A4%9A%E5%B0%91%E4%B8%AA%E7%BA%BF%E7%A8%8B%EF%BC%9F"><span class="nav-text">问：fork和exec有深入了解吗？父进程有多个线程在运行，调用fork后，产生的子进程中有多少个线程？</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E9%97%AE%EF%BC%9A%E6%AD%BB%E9%94%81%E7%9A%84%E5%BF%85%E8%A6%81%E6%9D%A1%E4%BB%B6%EF%BC%9F%E6%AD%BB%E9%94%81%E7%9A%84%E5%A4%84%E7%90%86%E6%96%B9%E6%B3%95%EF%BC%9F"><span class="nav-text">问：死锁的必要条件？死锁的处理方法？</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E9%97%AE%EF%BC%9A%E6%AD%BB%E9%94%81%E7%9A%84%E5%A4%84%E7%90%86%E6%96%B9%E6%B3%95%EF%BC%9F%E6%AD%BB%E9%94%81%E7%9A%84%E6%A3%80%E6%B5%8B%E4%B8%8E%E6%81%A2%E5%A4%8D%EF%BC%9F%E6%AD%BB%E9%94%81%E9%A2%84%E9%98%B2%EF%BC%9F%E6%AD%BB%E9%94%81%E9%81%BF%E5%85%8D%EF%BC%9F"><span class="nav-text">问：死锁的处理方法？死锁的检测与恢复？死锁预防？死锁避免？</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#1-2-%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86"><span class="nav-text">1.2 内存管理</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E9%97%AE%EF%BC%9A%E8%AF%B4%E4%B8%80%E4%B8%8B%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E7%9A%84%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86%E6%9C%BA%E5%88%B6%EF%BC%9F"><span class="nav-text">问：说一下操作系统的内存管理机制？</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E9%97%AE%EF%BC%9A%E8%99%9A%E6%8B%9F%E5%86%85%E5%AD%98%EF%BC%9F"><span class="nav-text">问：虚拟内存？</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E9%97%AE%EF%BC%9A%E5%88%86%E9%A1%B5%E7%B3%BB%E7%BB%9F%E5%9C%B0%E5%9D%80%E6%98%A0%E5%B0%84%EF%BC%9F"><span class="nav-text">问：分页系统地址映射？</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E9%97%AE%EF%BC%9A%E5%88%86%E9%A1%B5%E5%92%8C%E5%88%86%E6%AE%B5%E7%9A%84%E5%8C%BA%E5%88%AB%EF%BC%9F"><span class="nav-text">问：分页和分段的区别？</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E9%97%AE%EF%BC%9A%E8%99%9A%E6%8B%9F%E5%86%85%E5%AD%98%E7%9A%84%E7%BC%BA%E9%A1%B5%E4%B8%AD%E6%96%AD%E5%A4%84%E7%90%86%E8%BF%87%E7%A8%8B%EF%BC%9F"><span class="nav-text">问：虚拟内存的缺页中断处理过程？</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E9%97%AE%EF%BC%9A%E9%A1%B5%E9%9D%A2%E7%BD%AE%E6%8D%A2%E7%AE%97%E6%B3%95%E5%A6%82%E4%BD%95%E9%80%89%E6%8B%A9%EF%BC%9F%E9%A1%B5%E9%9D%A2%E7%BD%AE%E6%8D%A2%E7%AE%97%E6%B3%95%E6%9C%89%E5%93%AA%E4%BA%9B%EF%BC%8C%E4%BB%8B%E7%BB%8D%E4%B8%80%E4%B8%8B%EF%BC%9F"><span class="nav-text">问：页面置换算法如何选择？页面置换算法有哪些，介绍一下？</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#1-3-%E6%96%87%E4%BB%B6%E7%AE%A1%E7%90%86"><span class="nav-text">1.3 文件管理</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#1-4-%E8%AE%BE%E5%A4%87%E7%AE%A1%E7%90%86"><span class="nav-text">1.4 设备管理</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E9%97%AE%EF%BC%9A%E7%A3%81%E7%9B%98%E7%BB%93%E6%9E%84%EF%BC%9F"><span class="nav-text">问：磁盘结构？</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E9%97%AE%EF%BC%9A%E7%A3%81%E7%9B%98%E8%B0%83%E5%BA%A6%E7%AE%97%E6%B3%95%EF%BC%9F"><span class="nav-text">问：磁盘调度算法？</span></a></li></ol></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E4%B8%89-%E7%B3%BB%E7%BB%9F%E8%B0%83%E7%94%A8"><span class="nav-text">三. 系统调用</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E9%97%AE%EF%BC%9A%E8%AE%B2%E8%AE%B2Linux%E4%BD%A0%E7%9F%A5%E9%81%93%E7%9A%84%E7%B3%BB%E7%BB%9F%E8%B0%83%E7%94%A8%EF%BC%9F"><span class="nav-text">问：讲讲Linux你知道的系统调用？</span></a></li></ol></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%9B%9B-%E4%B8%AD%E6%96%AD"><span class="nav-text">四. 中断</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E4%BA%94-Linux"><span class="nav-text">五. Linux</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#5-1-%E5%9F%BA%E7%A1%80%E6%93%8D%E4%BD%9C"><span class="nav-text">5.1 基础操作</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E9%97%AE%EF%BC%9Alinux%E4%B8%AD%E6%9C%89%E5%93%AA%E4%BA%9B%E5%B8%B8%E8%A7%81%E7%9A%84%E6%8C%87%E4%BB%A4%EF%BC%9F"><span class="nav-text">问：linux中有哪些常见的指令？</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E9%97%AE%EF%BC%9Aselect%E3%80%81poll%E3%80%81epoll%E6%9C%89%E6%B2%A1%E6%9C%89%E4%BA%86%E8%A7%A3%E8%BF%87%EF%BC%8C%E8%AE%B2%E8%A7%A3%E4%B8%80%E4%B8%8B%EF%BC%9F%E5%8C%BA%E5%88%AB%EF%BC%9F"><span class="nav-text">问：select、poll、epoll有没有了解过，讲解一下？区别？</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E9%97%AE%EF%BC%9A%E5%A6%82%E4%BD%95%E6%9F%A5%E7%9C%8BLinux%E7%B3%BB%E7%BB%9F%E8%BF%90%E8%A1%8C%E7%8A%B6%E6%80%81%EF%BC%9F"><span class="nav-text">问：如何查看Linux系统运行状态？</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E9%97%AE%EF%BC%9A%E8%AF%B4%E4%B8%80%E4%B8%8BLinux%E5%A6%82%E4%BD%95%E6%9F%A5%E6%89%BECPU%E6%95%85%E9%9A%9C%EF%BC%9F"><span class="nav-text">问：说一下Linux如何查找CPU故障？</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#5-2-%E7%A3%81%E7%9B%98"><span class="nav-text">5.2 磁盘</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#5-3-%E5%88%86%E5%8C%BA"><span class="nav-text">5.3 分区</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#5-4-%E6%96%87%E4%BB%B6%E7%B3%BB%E7%BB%9F"><span class="nav-text">5.4 文件系统</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E9%97%AE%EF%BC%9ALinux%E6%96%87%E4%BB%B6%E7%B3%BB%E7%BB%9F%E6%9C%89%E5%93%AA%E4%BA%9B%EF%BC%9F"><span class="nav-text">问：Linux文件系统有哪些？</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E9%97%AE%EF%BC%9A%E6%96%87%E4%BB%B6%E7%B3%BB%E7%BB%9F%E7%9A%84%E7%BB%84%E6%88%90%EF%BC%9Finode-%E5%92%8C-block-%EF%BC%9F"><span class="nav-text">问：文件系统的组成？inode 和 block ？</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E9%97%AE%EF%BC%9A%E5%A6%82%E4%BD%95%E8%BF%9B%E8%A1%8C%E6%95%B0%E6%8D%AE%E6%81%A2%E5%A4%8D%EF%BC%9F"><span class="nav-text">问：如何进行数据恢复？</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#6-RAID-%E6%95%B0%E6%8D%AE%E6%81%A2%E5%A4%8D"><span class="nav-text">6. RAID 数据恢复</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#5-5-%E6%96%87%E4%BB%B6"><span class="nav-text">5.5 文件</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E9%97%AE%EF%BC%9ALinux%E6%96%87%E4%BB%B6%E7%B1%BB%E5%9E%8B%E6%9C%89%E5%93%AA%E4%BA%9B%EF%BC%9F"><span class="nav-text">问：Linux文件类型有哪些？</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E9%97%AE%EF%BC%9A%E8%AF%B4%E4%B8%80%E4%B8%8BLinux%E8%BD%AF%E9%93%BE%E6%8E%A5%E4%BB%A5%E5%8F%8A%E5%92%8C%E7%A1%AC%E9%93%BE%E6%8E%A5%E7%9A%84%E5%8C%BA%E5%88%AB%EF%BC%9F"><span class="nav-text">问：说一下Linux软链接以及和硬链接的区别？</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#5-6-%E5%8E%8B%E7%BC%A9%E4%B8%8E%E6%89%93%E5%8C%85"><span class="nav-text">5.6 压缩与打包</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#5-7-Bash"><span class="nav-text">5.7 Bash</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#5-8-%E7%AE%A1%E9%81%93%E6%8C%87%E4%BB%A4"><span class="nav-text">5.8 管道指令</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E9%97%AE%EF%BC%9A%E8%AF%B4%E4%B8%80%E4%B8%8B%E5%91%BD%E5%90%8D%E7%AE%A1%E9%81%93%E5%92%8C%E5%8C%BF%E5%90%8D%E7%AE%A1%E9%81%93%E7%9A%84%E7%89%B9%E7%82%B9%E5%92%8C%E5%8C%BA%E5%88%AB%EF%BC%9F"><span class="nav-text">问：说一下命名管道和匿名管道的特点和区别？</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#5-9-%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F"><span class="nav-text">5.9 正则表达式</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#5-10-%E8%BF%9B%E7%A8%8B%E7%AE%A1%E7%90%86"><span class="nav-text">5.10 进程管理</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E9%97%AE%EF%BC%9A%E8%AF%B4%E4%B8%80%E4%B8%8BLinux%E8%BF%9B%E7%A8%8B%E9%97%B4%E9%80%9A%E4%BF%A1%E7%9A%84%E6%96%B9%E5%BC%8F%EF%BC%9F"><span class="nav-text">问：说一下Linux进程间通信的方式？</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E9%97%AE%EF%BC%9A%E7%94%A8%E6%88%B7%E6%80%81%E5%92%8C%E5%86%85%E6%A0%B8%E6%80%81%EF%BC%9F%E4%B8%BA%E4%BB%80%E4%B9%88%E8%A6%81%E6%9C%89%E7%94%A8%E6%88%B7%E6%80%81%E5%92%8C%E5%86%85%E6%A0%B8%E6%80%81%EF%BC%9F"><span class="nav-text">问：用户态和内核态？为什么要有用户态和内核态？</span></a></li></ol></li></ol></li></ol></div>
        </div>
        <!--/noindex-->

        <div class="site-overview-wrap sidebar-panel">
          <div class="site-overview">
            <div class="site-author site-overview-item animated" itemprop="author" itemscope itemtype="http://schema.org/Person">
    <img class="site-author-image" itemprop="image" alt="Lys"
      src="https://pic-1258215793.cos.ap-shanghai.myqcloud.com/cover/IMG_0759.JPG">
  <p class="site-author-name" itemprop="name">Lys</p>
  <div class="site-description" itemprop="description">记录编程点滴，写点生活中的酸甜</div>
</div>
<div class="site-state-wrap site-overview-item animated">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
          <a href="/archives/">
        
          <span class="site-state-item-count">340</span>
          <span class="site-state-item-name">日志</span>
        </a>
      </div>
      <div class="site-state-item site-state-categories">
            <a href="/categories/">
          
        <span class="site-state-item-count">13</span>
        <span class="site-state-item-name">分类</span></a>
      </div>
      <div class="site-state-item site-state-tags">
            <a href="/tags/">
          
        <span class="site-state-item-count">113</span>
        <span class="site-state-item-name">标签</span></a>
      </div>
  </nav>
</div>
  <div class="links-of-author site-overview-item animated">
      <span class="links-of-author-item">
        <a href="https://github.com/LAILAIWA" title="GitHub → https:&#x2F;&#x2F;github.com&#x2F;LAILAIWA" rel="noopener" target="_blank"><i class="fab fa-github fa-fw"></i>GitHub</a>
      </span>
      <span class="links-of-author-item">
        <a href="mailto:linyishui168@outlook.com" title="E-Mail → mailto:linyishui168@outlook.com" rel="noopener" target="_blank"><i class="fa fa-envelope fa-fw"></i>E-Mail</a>
      </span>
      <span class="links-of-author-item">
        <a href="https://weibo.com/u/5340162234" title="Weibo → https:&#x2F;&#x2F;weibo.com&#x2F;u&#x2F;5340162234" rel="noopener" target="_blank"><i class="fab fa-weibo fa-fw"></i>Weibo</a>
      </span>
      <span class="links-of-author-item">
        <a href="https://twitter.com/linyishui618" title="Twitter → https:&#x2F;&#x2F;twitter.com&#x2F;linyishui618" rel="noopener" target="_blank"><i class="fab fa-twitter fa-fw"></i>Twitter</a>
      </span>
      <span class="links-of-author-item">
        <a href="https://stackoverflow.com/users/13018339/lin-yishui" title="StackOverflow → https:&#x2F;&#x2F;stackoverflow.com&#x2F;users&#x2F;13018339&#x2F;lin-yishui" rel="noopener" target="_blank"><i class="fab fa-stack-overflow fa-fw"></i>StackOverflow</a>
      </span>
      <span class="links-of-author-item">
        <a href="https://instagram.com/linyishui618" title="Instagram → https:&#x2F;&#x2F;instagram.com&#x2F;linyishui618" rel="noopener" target="_blank"><i class="fab fa-instagram fa-fw"></i>Instagram</a>
      </span>
  </div>
  <div class="cc-license site-overview-item animated" itemprop="license">
    <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/deed.zh" class="cc-opacity" rel="noopener" target="_blank"><img src="https://cdn.jsdelivr.net/npm/@creativecommons/vocabulary@2020.11.3/assets/license_badges/small/by_nc_sa.svg" alt="Creative Commons"></a>
  </div>


  <div class="links-of-blogroll site-overview-item animated">
    <div class="links-of-blogroll-title"><i class="far fa-smile-wink fa-fw"></i>
      个人
    </div>
    <ul class="links-of-blogroll-list">
        <li class="links-of-blogroll-item">
          <a href="https://music.163.com/#/user/home?id=68425607" title="https:&#x2F;&#x2F;music.163.com&#x2F;#&#x2F;user&#x2F;home?id&#x3D;68425607" rel="noopener" target="_blank">网易云音乐</a>
        </li>
    </ul>
  </div>

          </div>
        </div>
    </div>
  </aside>
  <div class="sidebar-dimmer"></div>


    </header>

    
  <div class="back-to-top" role="button" aria-label="返回顶部">
    <i class="fa fa-arrow-up"></i>
    <span>0%</span>
  </div>
  <a role="button" class="book-mark-link book-mark-link-fixed"></a>

  <a href="https://github.com/LAILAIWA" class="github-corner" title="Follow me on GitHub" aria-label="Follow me on GitHub" rel="noopener" target="_blank"><svg width="80" height="80" viewBox="0 0 250 250" aria-hidden="true"><path d="M0,0 L115,115 L130,115 L142,142 L250,250 L250,0 Z"></path><path d="M128.3,109.0 C113.8,99.7 119.0,89.6 119.0,89.6 C122.0,82.7 120.5,78.6 120.5,78.6 C119.2,72.0 123.4,76.3 123.4,76.3 C127.3,80.9 125.5,87.3 125.5,87.3 C122.9,97.6 130.6,101.9 134.4,103.2" fill="currentColor" style="transform-origin: 130px 106px;" class="octo-arm"></path><path d="M115.0,115.0 C114.9,115.1 118.7,116.5 119.8,115.4 L133.7,101.6 C136.9,99.2 139.9,98.4 142.2,98.6 C133.8,88.0 127.5,74.4 143.8,58.0 C148.5,53.4 154.0,51.2 159.7,51.0 C160.3,49.4 163.2,43.6 171.4,40.1 C171.4,40.1 176.1,42.5 178.8,56.2 C183.1,58.6 187.2,61.8 190.9,65.4 C194.5,69.0 197.7,73.2 200.1,77.6 C213.8,80.2 216.3,84.9 216.3,84.9 C212.7,93.1 206.9,96.0 205.4,96.6 C205.1,102.4 203.0,107.8 198.3,112.5 C181.9,128.9 168.3,122.5 157.7,114.1 C157.9,116.9 156.7,120.9 152.7,124.9 L141.0,136.5 C139.8,137.7 141.6,141.9 141.8,141.8 Z" fill="currentColor" class="octo-body"></path></svg></a>

<noscript>
  <div class="noscript-warning">Theme NexT works best with JavaScript enabled</div>
</noscript>


    <div class="main-inner post posts-expand">


  


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://linyishui.top/2019102701.html">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="https://pic-1258215793.cos.ap-shanghai.myqcloud.com/cover/IMG_0759.JPG">
      <meta itemprop="name" content="Lys">
      <meta itemprop="description" content="记录编程点滴，写点生活中的酸甜">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="俺的部落格">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          面试整理——操作系统
        </h1>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>

      <time title="创建时间：2019-10-27 16:24:13" itemprop="dateCreated datePublished" datetime="2019-10-27T16:24:13+08:00">2019-10-27</time>
    </span>
      <span class="post-meta-item">
        <span class="post-meta-item-icon">
          <i class="far fa-calendar-check"></i>
        </span>
        <span class="post-meta-item-text">更新于</span>
        <time title="修改时间：2025-01-20 11:33:53" itemprop="dateModified" datetime="2025-01-20T11:33:53+08:00">2025-01-20</time>
      </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">分类于</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/%E9%9D%A2%E8%AF%95%E6%95%B4%E7%90%86/" itemprop="url" rel="index"><span itemprop="name">面试整理</span></a>
        </span>
    </span>

  
      </div>
      <div class="post-meta">
    <span class="post-meta-item" title="本文字数">
      <span class="post-meta-item-icon">
        <i class="far fa-file-word"></i>
      </span>
      <span class="post-meta-item-text">本文字数：</span>
      <span>68k</span>
    </span>
    <span class="post-meta-item" title="阅读时长">
      <span class="post-meta-item-icon">
        <i class="far fa-clock"></i>
      </span>
      <span class="post-meta-item-text">阅读时长 &asymp;</span>
      <span>1:01</span>
    </span>
</div>

            <div class="post-description">整理面试中常问的操作系统相关问题，持续更新中。</div>
        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
        <h1 id="操作系统"><a href="#操作系统" class="headerlink" title="操作系统"></a>操作系统</h1><h2 id="一-基本特征"><a href="#一-基本特征" class="headerlink" title="一. 基本特征"></a>一. 基本特征</h2><h4 id="问：并发与并行？"><a href="#问：并发与并行？" class="headerlink" title="问：并发与并行？"></a>问：并发与并行？</h4><p><strong>并发</strong>是指宏观上在一段时间内能同时运行多个程序，而<strong>并行</strong>则指同一时刻能运行多个指令。</p>
<ul>
<li>并行需要硬件支持，如多流水线、多核处理器或者分布式计算系统。</li>
<li></li>
</ul>
<ol>
<li><p>并发（Concurrency）</p>
<ul>
<li><p><strong>定义</strong>：并发是指多个任务在<strong>同一时间段内</strong>交替执行。任务可能是独立的，也可能需要共享资源。并发更<strong>强调的是任务之间的逻辑顺序，而不是同时运行</strong>。</p>
</li>
<li><p><strong>特点</strong>：</p>
<ul>
<li><p>多个任务交替进行，给人一种“同时进行”的感觉。</p>
</li>
<li><p>通常在单个CPU核心上，通过任务切换实现。操作系统通过引入进程和线程，使得程序能够并发运行。</p>
</li>
<li><p>强调任务之间的协调与资源管理。</p>
</li>
</ul>
</li>
<li><p><strong>示例</strong>：</p>
<ul>
<li>在单核CPU上运行一个视频播放器：音频解码、视频解码、用户输入处理交替执行。</li>
<li>Java中使用<code>Thread</code>或线程池时，多个线程并发地执行。</li>
</ul>
</li>
</ul>
</li>
<li><p>并行（Parallelism）</p>
<ul>
<li><strong>定义</strong>：并行是指多个任务在<strong>同一时刻</strong>真正地同时运行。并行<strong>需要硬件支持</strong>，例如多核处理器或分布式系统。</li>
<li><strong>特点</strong>：<ul>
<li>任务在物理上同时运行。</li>
<li>通常依赖于多核CPU或多台机器。</li>
<li>强调计算任务的真正并行处理。</li>
</ul>
</li>
<li><strong>示例</strong>：<ul>
<li>在多核CPU上，多个线程分别运行在不同的核心上。</li>
<li>大型分布式计算（如MapReduce）中的数据分片并行处理。</li>
</ul>
</li>
</ul>
</li>
</ol>
<p><strong>并发 vs. 并行：对比总结</strong></p>
<table>
<thead>
<tr>
<th><strong>特性</strong></th>
<th><strong>并发</strong></th>
<th><strong>并行</strong></th>
</tr>
</thead>
<tbody><tr>
<td><strong>定义</strong></td>
<td>任务交替进行</td>
<td>任务同时运行</td>
</tr>
<tr>
<td><strong>硬件依赖</strong></td>
<td>不依赖多核硬件，可单核实现</td>
<td>依赖多核或多机器</td>
</tr>
<tr>
<td><strong>重点</strong></td>
<td>任务之间的逻辑切换和协调</td>
<td>任务真正同时运行</td>
</tr>
<tr>
<td><strong>示例</strong></td>
<td>多线程任务调度</td>
<td>多线程在多核上运行</td>
</tr>
</tbody></table>
<p>Java 中的体现</p>
<ul>
<li><strong>并发</strong>：<code>java.util.concurrent</code>包提供了线程池、锁等并发编程工具。</li>
<li><strong>并行</strong>：<code>Fork/Join</code>框架和<code>Stream API</code>中的并行流（Parallel Stream）利用多核CPU实现并行计算。</li>
</ul>
<h4 id="问：什么是同步？什么是异步？"><a href="#问：什么是同步？什么是异步？" class="headerlink" title="问：什么是同步？什么是异步？"></a>问：什么是同步？什么是异步？</h4><p>面试中回答时可以根据实际项目经验，说明在什么场景选择同步或异步，以及如何权衡两者的优缺点。如果面试官深入提问，可以提到：</p>
<ul>
<li>Java 中的具体实现（如 <code>Future</code>、<code>CompletableFuture</code>）。</li>
<li>异步编程可能引入的问题（如线程安全、死锁等）。</li>
<li>应用异步的设计模式（如生产者-消费者、回调、事件驱动）。</li>
</ul>
<p><strong>同步</strong>和<strong>异步</strong>描述了任务执行过程中线程或进程之间的交互方式。</p>
<ol>
<li><p>同步（Synchronous）</p>
<ul>
<li><strong>定义</strong>：同步是指<strong>任务按照顺序执行</strong>，一个任务必须等前一个任务完成后才能开始。同步分为进程/线程同步和数据同步，进程同步指多个进程在特定点会和使操作序列有序，数据同步则指一份数据集的多份拷贝保持一致以维护完整性。（一般通过进程同步来实现数据同步）</li>
<li><strong>特点</strong>：<ul>
<li><strong>阻塞</strong>：调用方需要等待被调用的任务完成，才能继续执行。</li>
<li><strong>线程占用</strong>：调用方在等待期间一直占用线程或资源。</li>
<li><strong>顺序性</strong>：严格按照任务的启动顺序完成。</li>
</ul>
</li>
</ul>
<ul>
<li><p><strong>优点</strong>：</p>
<ul>
<li>逻辑简单，容易理解和实现。</li>
<li>适用于对任务完成顺序要求严格的场景。</li>
</ul>
</li>
<li><p><strong>缺点</strong>：效率较低，调用方在等待时无法处理其他任务。</p>
</li>
<li><p><strong>示例</strong>：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">synchronousExample</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    System.out.println(<span class="string">&quot;任务1开始&quot;</span>);</span><br><span class="line">    System.out.println(<span class="string">&quot;任务1完成&quot;</span>);</span><br><span class="line">    System.out.println(<span class="string">&quot;任务2开始&quot;</span>);</span><br><span class="line">    System.out.println(<span class="string">&quot;任务2完成&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>执行结果是按顺序输出“任务1开始”、“任务1完成”、“任务2开始”、“任务2完成”。</p>
</li>
</ul>
</li>
<li><p>异步（Asynchronous）</p>
<ul>
<li><strong>定义</strong>：异步是指任务可以独立于前一个任务执行，调用方在发起任务后无需等待，可以继续处理其他任务。异步指进程不是一次性执行完毕，而是走走停停，以不可知的速度向前推进。</li>
<li><strong>特点</strong>：<ul>
<li><strong>非阻塞</strong>：调用方无需等待任务完成。</li>
<li><strong>回调/事件驱动</strong>：任务完成后，通过回调函数、Promise 或 Future 通知调用方。</li>
<li><strong>并发性</strong>：可以并发地执行多个任务。</li>
</ul>
</li>
</ul>
<ul>
<li><p><strong>优点</strong>：</p>
<ul>
<li>提高系统的效率和资源利用率。</li>
<li>适用于需要处理大量 I/O 或长时间等待的场景。</li>
</ul>
</li>
<li><p><strong>缺点</strong>：</p>
<ul>
<li>实现逻辑较复杂，可能引入回调地狱或竞争问题。</li>
<li>调试和错误处理相对困难。</li>
</ul>
</li>
<li><p><strong>示例</strong>：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.concurrent.CompletableFuture;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">asynchronousExample</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    System.out.println(<span class="string">&quot;任务1开始&quot;</span>);</span><br><span class="line">    CompletableFuture.runAsync(() -&gt; &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;任务2完成&quot;</span>);</span><br><span class="line">    &#125;);</span><br><span class="line">    System.out.println(<span class="string">&quot;任务3开始&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>可能的输出：</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">任务1开始</span><br><span class="line">任务3开始</span><br><span class="line">任务2完成</span><br></pre></td></tr></table></figure>

<p>任务2在后台异步执行，不阻塞任务3的执行。</p>
</li>
</ul>
</li>
<li><p>同步与异步的对比</p>
<table>
<thead>
<tr>
<th><strong>特性</strong></th>
<th><strong>同步</strong></th>
<th><strong>异步</strong></th>
</tr>
</thead>
<tbody><tr>
<td><strong>任务依赖</strong></td>
<td>后续任务需等待前一任务完成</td>
<td>任务独立，不依赖完成顺序</td>
</tr>
<tr>
<td><strong>调用行为</strong></td>
<td>阻塞调用方，必须等待结果</td>
<td>非阻塞调用方，可继续处理其他任务</td>
</tr>
<tr>
<td><strong>执行效率</strong></td>
<td>效率较低</td>
<td>更高效，适合并发任务</td>
</tr>
<tr>
<td><strong>实现难度</strong></td>
<td>简单</td>
<td>复杂</td>
</tr>
<tr>
<td><strong>应用场景</strong></td>
<td>对执行顺序有严格要求的场景</td>
<td>网络请求、大量 I/O 操作等场景</td>
</tr>
</tbody></table>
</li>
<li><p>典型应用场景</p>
<h4 id="同步场景"><a href="#同步场景" class="headerlink" title="同步场景"></a><strong>同步场景</strong></h4><ul>
<li>数据库事务：需要保证操作的原子性和一致性。</li>
<li>文件写入：确保顺序性。</li>
</ul>
<h4 id="异步场景"><a href="#异步场景" class="headerlink" title="异步场景"></a><strong>异步场景</strong></h4><ul>
<li>网络请求：例如 REST API 调用。</li>
<li>消息队列：如 RabbitMQ、Kafka，用于异步解耦。</li>
<li>用户界面：避免界面卡顿，异步处理后台任务。</li>
</ul>
</li>
</ol>
<h4 id="问：虚拟技术？"><a href="#问：虚拟技术？" class="headerlink" title="问：虚拟技术？"></a>问：虚拟技术？</h4><p><strong>虚拟技术</strong>（Virtualization Technology）通过软件模拟硬件资源，使得多个操作系统或应用程序能够共享同一套物理硬件资源。</p>
<ul>
<li><p>定义：虚拟技术是指<strong>在一台物理设备上创建多个逻辑设备</strong>（虚拟机、虚拟资源）的技术，<strong>把一个物理实体转换为多个逻辑实体</strong>。它使得硬件资源如CPU、内存、存储和网络能够被抽象化，并分配给不同的用户或系统。</p>
</li>
<li><p>分类：主要有两种虚拟技术：时（时间）分复用技术、空（空间）分复用技术。</p>
<p>多个进程能在同一个处理器上并发执行使用了时分复用技术，让每个进程轮流占用处理器，每次只执行一小个<strong>时间片</strong>并快速切换。</p>
<p><strong>虚拟内存</strong>使用了空分复用技术，它将物理内存抽象为地址空间，每个进程都有各自的地址空间。地址空间的页被映射到物理内存，地址空间的页并不需要全部在物理内存中，当使用到一个没有在物理内存的页时，执行<strong>页面置换算法</strong>，将该页置换到内存中。</p>
<ol>
<li><strong>硬件虚拟化</strong>：<ul>
<li>将物理硬件抽象为多个虚拟硬件实例。</li>
<li>应用：虚拟机（Virtual Machine），如 VMware、KVM、Hyper-V 等。</li>
<li>分类：<ul>
<li><strong>全虚拟化</strong>：完全模拟硬件环境，不需要修改操作系统（如 VMware ESXi）。</li>
<li><strong>半虚拟化</strong>：部分硬件由软件模拟，操作系统需要进行修改（如 Xen）。</li>
<li><strong>硬件辅助虚拟化</strong>：利用CPU指令集支持虚拟化（如 Intel VT-x, AMD-V）。</li>
</ul>
</li>
</ul>
</li>
<li><strong>操作系统虚拟化</strong>：<ul>
<li>在单一操作系统内运行多个隔离的用户空间实例。</li>
<li>应用：容器技术（如 Docker、LXC）。</li>
<li>优势：比硬件虚拟化更轻量级，启动速度快，占用资源少。</li>
</ul>
</li>
<li><strong>存储虚拟化</strong>：<ul>
<li>将物理存储设备抽象为逻辑存储资源，提供更高的存储灵活性。</li>
<li>应用：存储池化、分布式存储（如 VMware vSAN）。</li>
</ul>
</li>
<li><strong>网络虚拟化</strong>：<ul>
<li>把网络硬件和网络功能抽象为逻辑组件（如虚拟交换机、虚拟路由器）。</li>
<li>应用：软件定义网络（SDN），虚拟局域网（VLAN）。</li>
</ul>
</li>
</ol>
</li>
<li><p>核心组件：</p>
<ol>
<li><strong>虚拟机监控器（Hypervisor）</strong>：<ul>
<li>在硬件和虚拟机之间的核心层。</li>
<li>分类：<ul>
<li><strong>Type 1（裸金属型）</strong>：直接运行在硬件上，性能高（如 VMware ESXi）。</li>
<li><strong>Type 2（托管型）</strong>：运行在主机操作系统之上，灵活性高（如 VMware Workstation）。</li>
</ul>
</li>
</ul>
</li>
<li><strong>虚拟机（Virtual Machine）</strong>：<ul>
<li>虚拟硬件环境中的操作系统实例。</li>
</ul>
</li>
<li><strong>容器（Container）</strong>：<ul>
<li>操作系统层的虚拟化技术，提供隔离的运行环境。</li>
</ul>
</li>
</ol>
</li>
<li><p>优点：</p>
<ol>
<li><strong>资源利用率提升</strong>：多个虚拟机或容器共享硬件资源，减少资源闲置。</li>
<li><strong>隔离性强</strong>：不同虚拟机和容器之间相互隔离，安全性高。</li>
<li><strong>灵活性和可扩展性</strong>：快速部署新环境，按需扩展资源。</li>
<li><strong>成本节约</strong>：减少硬件投入，降低能耗。</li>
<li><strong>高可用性</strong>：支持迁移、快照等功能，减少宕机时间。</li>
</ol>
</li>
<li><p>常见应用场景：</p>
<ol>
<li><strong>服务器整合</strong>：<ul>
<li>将多个服务器整合到一个虚拟化平台，减少硬件使用。</li>
</ul>
</li>
<li><strong>云计算</strong>：<ul>
<li>云服务提供商（如 AWS、Azure）利用虚拟化技术提供弹性计算资源。</li>
</ul>
</li>
<li><strong>开发与测试</strong>：<ul>
<li>快速创建隔离的测试环境。</li>
</ul>
</li>
<li><strong>容器化部署</strong>：<ul>
<li>使用 Docker 或 Kubernetes 实现微服务架构的部署和管理。</li>
</ul>
</li>
<li><strong>桌面虚拟化</strong>：<ul>
<li>通过虚拟桌面基础架构（VDI），远程访问桌面环境。</li>
</ul>
</li>
</ol>
</li>
<li><p>相关技术及工具：</p>
<ul>
<li><strong>虚拟机工具</strong>：VMware、KVM、Hyper-V、VirtualBox。</li>
<li><strong>容器工具</strong>：Docker、Podman、LXC。</li>
<li><strong>编排工具</strong>：Kubernetes、Docker Swarm。</li>
<li><strong>存储虚拟化工具</strong>：Ceph、GlusterFS。</li>
<li><strong>网络虚拟化工具</strong>：Open vSwitch、SDN 控制器。</li>
</ul>
</li>
</ul>
<hr>
<h2 id="二-基本功能"><a href="#二-基本功能" class="headerlink" title="二. 基本功能"></a>二. 基本功能</h2><h4 id="问：说一下操作系统的基本功能包括？"><a href="#问：说一下操作系统的基本功能包括？" class="headerlink" title="问：说一下操作系统的基本功能包括？"></a>问：说一下操作系统的基本功能包括？</h4><ol>
<li>进程管理<br>* </li>
<li>内存管理<br>* </li>
<li>文件管理<br>* </li>
<li>设备管理：<br>* </li>
</ol>
<p>操作系统（Operating System, OS）是管理计算机硬件和软件资源的核心软件，其主要功能是为用户和应用程序提供一个方便、有效的运行环境。以下是操作系统的基本功能分类和详细说明：</p>
<ol>
<li><p>进程管理</p>
<p><strong>定义</strong>：操作系统负责<strong>对进程进行创建、调度、终止</strong>，并确保多进程环境下的资源共享和独立性。</p>
<p><strong>关键任务</strong>：进程控制、进程同步、进程通信、死锁处理、处理机调度等</p>
<ul>
<li><strong>进程调度</strong>：决定哪个进程优先执行（如先来先服务、时间片轮转）。</li>
<li><strong>进程同步</strong>：协调多个进程之间的运行顺序，防止资源竞争。</li>
<li><strong>进程通信</strong>：提供进程之间的数据交换机制（如共享内存、消息队列、管道等）。</li>
<li><strong>进程状态管理</strong>：维护进程的创建、就绪、运行、等待、终止等状态转换。</li>
</ul>
</li>
<li><p>内存管理</p>
<p><strong>定义</strong>：操作系统负责为每个进程分配和管理内存，同时确保内存的高效使用和安全性。</p>
<p><strong>关键任务</strong>：内存分配、地址映射、内存保护与共享、虚拟内存等。</p>
<ul>
<li><strong>内存分配和回收</strong>：为进程分配内存空间，释放未使用的空间。</li>
<li><strong>地址空间管理</strong>：实现虚拟内存机制，使进程看到的是逻辑地址，而非物理地址。</li>
<li><strong>分页与分段</strong>：通过分页或分段技术实现内存管理。</li>
<li><strong>内存保护</strong>：确保一个进程的内存不会被其他进程访问。</li>
</ul>
</li>
<li><p>文件管理</p>
<p><strong>定义</strong>：<br> 操作系统提供了对存储设备上文件的创建、读取、写入、删除等操作的支持。</p>
<p><strong>关键任务</strong>：文件存储空间的管理、目录管理、文件读写管理和保护等。</p>
<ul>
<li><strong>文件系统管理</strong>：定义文件的存储结构（如 FAT32、NTFS、EXT4）。</li>
<li><strong>目录管理</strong>：支持文件的组织和分类。</li>
<li><strong>文件访问控制</strong>：确保文件访问的权限（如读、写、执行权限）。</li>
<li><strong>文件共享和保护</strong>：支持多用户对文件的共享，并保证安全性。</li>
</ul>
</li>
<li><p>设备管理</p>
<p><strong>定义</strong>：<br> 操作系统负责管理各种硬件设备（如磁盘、打印机、键盘、网络设备等）并提供统一的接口。</p>
<p><strong>关键任务</strong>：完成用户的 I/O 请求，方便用户使用各种设备，并提高设备的利用率。主要包括缓冲管理、设备分配、设备处理、虛拟设备等。</p>
<ul>
<li><strong>设备驱动程序</strong>：通过驱动程序与硬件交互。</li>
<li><strong>设备分配</strong>：在多个进程请求使用设备时，合理分配资源。</li>
<li><strong>I/O 管理</strong>：提供同步和异步的输入输出操作。</li>
<li><strong>缓冲与缓存</strong>：提高设备操作的效率。</li>
</ul>
</li>
<li><p>存储管理</p>
<p><strong>定义</strong>：<br> 操作系统管理存储设备（如硬盘、SSD）以及存储层次结构（如主存、缓存、外存）。</p>
<p><strong>关键任务</strong>：</p>
<ul>
<li><strong>数据组织与分配</strong>：决定如何将数据存储在存储设备上。</li>
<li><strong>磁盘调度</strong>：如电梯调度算法，用于优化磁盘的读取效率。</li>
<li><strong>空间管理</strong>：分配和回收存储空间。</li>
<li><strong>备份与恢复</strong>：支持数据的备份和故障恢复。</li>
</ul>
</li>
<li><p>网络管理</p>
<p><strong>定义</strong>：<br> 操作系统提供网络通信的支持，实现进程之间的远程通信。</p>
<p><strong>关键任务</strong>：</p>
<ul>
<li><strong>协议支持</strong>：如 TCP/IP 协议栈的实现。</li>
<li><strong>数据传输</strong>：在网络设备间高效传输数据。</li>
<li><strong>资源共享</strong>：通过网络共享文件和设备。</li>
</ul>
</li>
<li><p>用户接口管理</p>
<p><strong>定义</strong>：<br> 为用户和操作系统的交互提供界面，包括图形用户界面（GUI）和命令行界面（CLI）。</p>
<p><strong>关键任务</strong>：</p>
<ul>
<li><strong>图形用户界面</strong>：提供窗口、菜单、按钮等可视化组件。</li>
<li><strong>命令行界面</strong>：支持用户通过命令与系统交互。</li>
<li><strong>多用户支持</strong>：支持不同用户登录并访问资源。</li>
</ul>
</li>
<li><p>安全与保护</p>
<p><strong>定义</strong>：<br> 操作系统提供对系统和用户数据的保护，防止非法访问和恶意破坏。</p>
<p><strong>关键任务</strong>：</p>
<ul>
<li><strong>用户认证</strong>：通过密码、指纹等手段验证用户身份。</li>
<li><strong>访问控制</strong>：限制对资源（文件、进程）的访问权限。</li>
<li><strong>数据加密</strong>：对敏感数据进行加密存储和传输。</li>
<li><strong>防御机制</strong>：防范病毒、木马、网络攻击等威胁。</li>
</ul>
</li>
<li><p>错误检测与恢复</p>
<p><strong>定义</strong>：<br> 操作系统监测和处理运行中的错误，以保证系统稳定性和可靠性。</p>
<p><strong>关键任务</strong>：</p>
<ul>
<li><strong>硬件错误</strong>：如内存故障、磁盘损坏。</li>
<li><strong>软件错误</strong>：如进程死锁、程序异常退出。</li>
<li><strong>容错机制</strong>：通过备份、冗余设计，提高系统可靠性。</li>
</ul>
</li>
</ol>
<p><strong>总结</strong></p>
<p>操作系统的基本功能可以归纳为：</p>
<ol>
<li><strong>资源管理</strong>（进程、内存、设备、存储）。</li>
<li><strong>任务调度</strong>（进程调度、I/O调度）。</li>
<li><strong>安全保障</strong>（权限控制、数据保护）。</li>
<li><strong>用户交互</strong>（提供友好的用户界面）。</li>
</ol>
<p><strong>面试建议</strong>：<br> 在回答操作系统功能时，结合实际项目或经验说明某个功能的使用场景，例如在 Java 项目中如何利用多线程进行进程管理，或如何通过虚拟内存优化内存使用。这样可以体现对理论和实践的理解。</p>
<h3 id="1-1-进程管理"><a href="#1-1-进程管理" class="headerlink" title="1.1 进程管理"></a>1.1 进程管理</h3><h4 id="问：什么是进程？什么是线程？线程和进程的区别？"><a href="#问：什么是进程？什么是线程？线程和进程的区别？" class="headerlink" title="问：什么是进程？什么是线程？线程和进程的区别？"></a>问：什么是进程？什么是线程？线程和进程的区别？</h4><ol>
<li><p>进程（Process）</p>
<ul>
<li><strong>定义</strong>：进程是程序在内存中的一次运行实例，是<strong>资源分配的基本单位</strong>。<strong>每个进程都有独立的地址空间，包含代码、数据、堆和栈</strong>。进程控制块 (Process Control Block, PCB) 描述进程的基本信息和运行状态，所谓的创建进程和撤销进程，都是指对 PCB 的操作。</li>
<li><strong>特点</strong>：<ul>
<li><strong>独立性</strong>：进程之间相互隔离，每个进程有独立的地址空间。</li>
<li><strong>资源独占</strong>：每个进程独立持有资源（如内存、文件句柄）。</li>
<li><strong>开销大</strong>：进程切换需要保存和恢复上下文（CPU寄存器、内存页表等）。</li>
</ul>
</li>
<li><strong>示例</strong>：在操作系统中运行的每个程序（如浏览器、文本编辑器）都是一个进程。</li>
</ul>
</li>
<li><p>线程（Thread）</p>
<ul>
<li><strong>定义</strong>：线程是<strong>进程中的一个执行单元</strong>，是操作系统<strong>调度的基本单位</strong>。一个进程可以包含多个线程，这些线程共享进程的资源（如内存、文件句柄）。</li>
<li><strong>特点</strong>：<ul>
<li><strong>轻量级</strong>：线程的开销比进程小，线程切换效率更高。</li>
<li><strong>资源共享</strong>：同一进程中的线程共享代码段、数据段和打开的文件句柄，但有独立的栈和寄存器。</li>
<li><strong>并发执行</strong>：线程可以通过多核CPU实现并行。</li>
</ul>
</li>
<li><strong>示例</strong>：一个浏览器进程可能包含多个线程：QQ 和浏览器是两个进程，浏览器进程里面有很多线程，例如 HTTP 请求线程、事件响应线程、渲染线程等等，线程的并发执行使得在浏览器中点击一个新链接从而发起 HTTP 请求时，浏览器还可以响应用户的其它事件。<ul>
<li>渲染线程负责页面显示。</li>
<li>网络线程负责数据下载。</li>
<li>主线程处理用户输入。</li>
</ul>
</li>
</ul>
</li>
<li><p>进程与线程的区别</p>
<table>
<thead>
<tr>
<th><strong>特性</strong></th>
<th><strong>进程</strong></th>
<th><strong>线程</strong></th>
</tr>
</thead>
<tbody><tr>
<td><strong>定义</strong></td>
<td>程序的独立运行实例，是资源分配的基本单位，<strong>开销大</strong>、<strong>切换慢</strong></td>
<td>进程中的执行单元，是调度的基本单位，<strong>开销小</strong>，<strong>切换快</strong></td>
</tr>
<tr>
<td><strong>内容</strong></td>
<td>地址空间、全局变量、打开文件、子进程、即将发生的报警、信号与信号处理程序、账户信号、同步互斥信号量</td>
<td>程序计数器、寄存器、堆栈、状态</td>
</tr>
<tr>
<td><strong>地址空间</strong></td>
<td>独立的地址空间，每个进程有自己的代码、数据和堆栈</td>
<td>同一进程内的线程共享地址空间（代码段、数据段、堆）</td>
</tr>
<tr>
<td><strong>资源共享</strong></td>
<td>进程间资源独立，不共享资源</td>
<td>线程本身并不拥有资源但可以访问同一进程内的线程共享资源（内存、文件句柄等）</td>
</tr>
<tr>
<td><strong>执行开销</strong></td>
<td>进程创建、切换和销毁的开销较大（需切换上下文）。创建或撤销进程时，系统都要为之分配或回收资源，如内存空间、I/O 设备等，所付出的开销远大于创建或撤销线程时的开销，进程切换时，涉及当前执行进程 CPU 环境的保存及新调度进程 CPU 环境的设置</td>
<td>线程创建、切换和销毁的开销较小（上下文切换更快）。线程切换时只需保存和设置少量寄存器内容，开销很小</td>
</tr>
<tr>
<td><strong>通信方式</strong></td>
<td>通过进程间通信（IPC），如管道，信号，消息队列，共享内存，套接字等通信机制</td>
<td>通过共享内存或全局变量实现线程间通信</td>
</tr>
<tr>
<td><strong>独立性</strong></td>
<td>进程相互独立，一个进程崩溃不会影响其他进程</td>
<td>同一进程内的线程相互依赖，一个线程崩溃可能导致整个进程崩溃</td>
</tr>
<tr>
<td><strong>并发性</strong></td>
<td>不同进程可以并发执行</td>
<td>同一进程内的多个线程可以并发执行</td>
</tr>
</tbody></table>
</li>
</ol>
<h4 id="问：进程的数据段和内存？进程和线程的内存有什么区别？"><a href="#问：进程的数据段和内存？进程和线程的内存有什么区别？" class="headerlink" title="问：进程的数据段和内存？进程和线程的内存有什么区别？"></a>问：进程的数据段和内存？进程和线程的内存有什么区别？</h4><p><strong>进程的数据段和内存？</strong></p>
<p>一个进程的内存空间通常分为以下几个主要区域（<strong>进程的内存布局</strong>）：</p>
<ol>
<li><strong>代码段（Text Segment）</strong>：<ul>
<li>存储进程的可执行代码，也称为指令区。</li>
<li>代码段是只读的，多个进程可以共享相同的代码段（如共享库）。</li>
</ul>
</li>
<li><strong>数据段（Data Segment）</strong>：<ul>
<li>存储进程的全局变量和静态变量。</li>
<li>数据段分为两部分：<ul>
<li><strong>已初始化数据段</strong>：存储初始化的全局变量和静态变量。</li>
<li><strong>未初始化数据段（BSS Segment）</strong>：存储未初始化的全局变量和静态变量，默认初始化为 0。</li>
</ul>
</li>
</ul>
</li>
<li><strong>堆（Heap）</strong>：<ul>
<li>用于动态分配内存，分配的内存空间可以在程序运行时通过 <code>malloc</code>（C）或 <code>new</code>（Java）等方式获得。</li>
<li>堆的大小可以动态增长或缩减。</li>
</ul>
</li>
<li><strong>栈（Stack）</strong>：<ul>
<li>每个线程都有独立的栈，用于存储局部变量、函数调用信息（如返回地址、参数）等。</li>
<li>栈是后进先出的数据结构，随着函数调用不断增长和缩减。</li>
</ul>
</li>
<li><strong>内核区（Kernel Space）</strong>：<ul>
<li>包含与操作系统交互所需的数据和函数，例如文件描述符、进程控制块（PCB）。</li>
<li>普通进程无法直接访问内核区。</li>
</ul>
</li>
</ol>
<p><strong>进程和线程的内存区别？</strong></p>
<p>进程和线程在内存的使用上有显著的区别，主要体现在<strong>共享与隔离</strong>的层面。</p>
<table>
<thead>
<tr>
<th><strong>特性</strong></th>
<th><strong>进程</strong></th>
<th><strong>线程</strong></th>
</tr>
</thead>
<tbody><tr>
<td><strong>地址空间</strong></td>
<td>每个进程有独立的地址空间，互相隔离。</td>
<td>线程共享进程的地址空间（代码段、数据段、堆等）。</td>
</tr>
<tr>
<td><strong>数据段</strong></td>
<td>数据段独立，每个进程有自己的全局变量和静态变量。</td>
<td>线程共享进程的数据段，全局变量和静态变量对所有线程可见。</td>
</tr>
<tr>
<td><strong>堆</strong></td>
<td>每个进程有独立的堆区域，用于动态内存分配。</td>
<td>线程共享进程的堆区域，但需要通过同步机制避免竞争。</td>
</tr>
<tr>
<td><strong>栈</strong></td>
<td>每个进程有独立的栈，存储其自身的函数调用和局部变量。</td>
<td>每个线程有独立的栈，存储线程的局部变量和调用栈信息。</td>
</tr>
<tr>
<td><strong>内核对象</strong></td>
<td>进程有独立的内核对象，如文件描述符和资源句柄。</td>
<td>线程共享进程的内核对象，但线程可以独立使用这些对象。</td>
</tr>
</tbody></table>
<p><strong>进程与线程内存使用的关键点</strong></p>
<p><strong>1. 数据共享</strong>：</p>
<ul>
<li><strong>进程</strong>：进程之间的数据共享需要通过进程间通信（IPC）机制实现，如共享内存、管道、消息队列、套接字等。</li>
<li><strong>线程</strong>：同一进程内的线程共享内存，数据共享较为直接，但需要处理同步问题，防止数据竞争。</li>
</ul>
<p><strong>2. 独立性与隔离性</strong>：</p>
<ul>
<li><strong>进程</strong>：由于进程的地址空间独立，崩溃的进程不会影响其他进程。</li>
<li><strong>线程</strong>：线程共享地址空间，一个线程崩溃可能会导致整个进程崩溃。</li>
</ul>
<p><strong>3. 并发与同步</strong>：</p>
<ul>
<li><strong>进程</strong>：进程间的同步开销较大，因为需要通过操作系统提供的 IPC。</li>
<li><strong>线程</strong>：线程间的同步更高效，但也更容易出现竞争条件和死锁。</li>
</ul>
<h4 id="问：进程、线程间的通信方式？"><a href="#问：进程、线程间的通信方式？" class="headerlink" title="问：进程、线程间的通信方式？"></a>问：进程、线程间的通信方式？</h4><p><strong>进程间通信（Inter-Process Communication, IPC）</strong>：进程间通信的目的是在独立的进程间传递数据或协调操作，因为每个进程都有自己的独立地址空间。以下是常见的进程间通信方式：</p>
<ol>
<li><p><strong>管道（Pipe）</strong>：</p>
<ul>
<li><p><strong>描述</strong>：管道是一种<strong>半双工</strong>的单向通信机制，数据从一端写入，从另一端读取，且<strong>只能在具有亲缘关系的进程间使用</strong>（通常指父子进程）。</p>
</li>
<li><p>特点：</p>
<ul>
<li>数据流是<strong>单向的</strong>，除非使用命名管道（Named Pipe）。</li>
<li><strong>命名管道</strong>（FIFO）：<strong>有路径名</strong>关联，<strong>允许无亲缘关系进程间进行通信</strong>。</li>
<li>只能在有亲缘关系的进程间通信（如父子进程）。</li>
<li>操作系统提供管道的创建和销毁。</li>
</ul>
</li>
<li><p>示例（Linux Shell）：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">ls | grep <span class="string">&quot;.txt&quot;</span></span><br><span class="line">ls</span><br><span class="line">grep</span><br></pre></td></tr></table></figure>

<p> 通过管道实现通信。</p>
</li>
</ul>
</li>
<li><p><strong>信号（Signal）</strong></p>
<ul>
<li><p><strong>描述</strong>：信号是一种异步通信机制，用于通知进程某些事件的发生。</p>
</li>
<li><p>特点：</p>
<ul>
<li>信号处理机制简单，用于事件通知。</li>
<li>常见信号：<code>SIGKILL</code>（终止进程）、<code>SIGINT</code>（中断进程）。</li>
<li>不适合传递大量数据。</li>
</ul>
</li>
<li><p><strong>示例</strong>： 使用 <code>kill -SIGINT pid</code> 向进程发送信号。</p>
</li>
</ul>
</li>
<li><p><strong>套接字（Socket）</strong></p>
<ul>
<li><p><strong>描述</strong>：套接字是一种通用的通信机制，可用于同一主机或分布式系统中不同机器的进程间通信。</p>
</li>
<li><p>特点：</p>
<ul>
<li>支持<strong>跨网络</strong>通信。</li>
<li>支持多种协议（如 TCP、UDP）。</li>
<li>广泛用于客户端-服务器架构。</li>
</ul>
</li>
<li><p><strong>示例</strong>： HTTP 请求通过套接字在客户端和服务器间传输数据。</p>
</li>
</ul>
</li>
<li><p><strong>消息队列（Message Queue）</strong></p>
<ul>
<li><p><strong>描述</strong>：即消息的链接表，存放在内核中并由消息队列标识符（队列ID）标识，有写权限的进程向队列添加消息，有读权限的进程则可以读走。通过消息队列，进程可以以消息的形式发送和接收数据。</p>
</li>
<li><p><strong>消息队列解决了信号传递信息少、管道只能承载无格式字节流以及缓冲区大小受限等缺点</strong>。相比于管道的优点：</p>
<ul>
<li>消息队列可以独立于读写进程存在，从而避免了 FIFO 中同步管道的打开和关闭时可能产生的困难；</li>
<li>避免了 FIFO 的同步阻塞问题，不需要进程自己提供同步方法；</li>
<li>读进程可以根据消息类型有选择地接收消息，而不像 FIFO 那样只能默认地接收。</li>
</ul>
</li>
<li><p>特点：</p>
<ul>
<li>可以在无亲缘关系的进程之间通信。</li>
<li>消息队列由操作系统维护，有容量限制。</li>
<li>支持同步或异步通信。</li>
</ul>
</li>
<li><p><strong>应用场景</strong>： 用于多进程服务器的任务调度。</p>
</li>
</ul>
</li>
<li><p><strong>共享内存（Shared Memory）</strong></p>
<ul>
<li><p><strong>描述</strong>：即映射一段能被其他进程所访问的内存，由一个进程创建，但多个进程都可访问。共享内存允许多个进程直接访问一段共享的内存区域。因为数据不需要在进程之间复制，这种IPC方式效率最高，往往与其他通信机制配合使用（需要使用信号量用来同步对共享存储的访问）。</p>
</li>
<li><p>特点：</p>
<ul>
<li><strong>最快的通信方式</strong>，因为数据无需在内核和用户空间之间拷贝。</li>
<li>需要同步机制（如信号量）来防止数据竞争。</li>
<li>通信前需要设置共享内存区域。</li>
</ul>
</li>
<li><p><strong>示例</strong>： 在 Linux 中，可以通过 <code>shmget</code> 和 <code>shmat</code> 系统调用创建和访问共享内存。</p>
</li>
</ul>
</li>
<li><p><strong>信号量（Semaphore）</strong>：</p>
<ul>
<li><p><strong>描述</strong>：信号量是一个计数器，可以用来控制多个进程对共享资源的访问。常作为一种锁机制，防止某进程访问共享资源时被其他进程访问。</p>
</li>
<li><p>信号量（Semaphore）是一个整型变量，可以对其执行 down 和 up 操作，也就是常见的 P 和 V 操作：</p>
<ul>
<li><strong>down</strong> : 如果信号量大于 0 ，执行 -1 操作；如果信号量等于 0，进程睡眠，等待信号量大于 0；</li>
<li><strong>up</strong> ：对信号量执行 +1 操作，唤醒睡眠的进程让其完成 down 操作。</li>
<li>如果信号量的取值只能为 0 或者 1，那么就成为了 <strong>互斥量（Mutex）</strong> ，0 表示临界区已经加锁，1 表示临界区解锁。</li>
</ul>
</li>
<li><p>特点：</p>
<ul>
<li>用于解决共享内存中的<strong>数据竞争问题</strong>。</li>
<li>提供计数器机制，允许多个进程共享资源。</li>
</ul>
</li>
<li><p><strong>示例</strong>： POSIX 信号量 API 提供 <code>sem_wait</code> 和 <code>sem_post</code> 操作。</p>
</li>
</ul>
</li>
<li><p>文件（File）</p>
<ul>
<li><p><strong>描述</strong>：通过读写文件，进程可以交换数据。</p>
</li>
<li><p>特点：</p>
<ul>
<li>简单易用，跨平台支持。</li>
<li>性能较低，因为涉及磁盘 I/O。</li>
</ul>
</li>
<li><p><strong>应用场景</strong>： 日志文件、配置文件的共享访问。</p>
</li>
</ul>
</li>
</ol>
<p><strong>线程间通信（Thread Communication）</strong> （线程间通信主要用于同步，所以没有进程那种用于数据交换的通信机制）线程之间共享进程的地址空间，因此通信相对简单。以下是线程间常用的通信和同步机制：</p>
<ol>
<li><p>全局变量</p>
<ul>
<li><strong>描述</strong>：线程共享进程的内存空间，直接通过全局变量或静态变量共享数据。</li>
<li><strong>注意</strong>：需要同步机制防止数据竞争。</li>
</ul>
</li>
<li><p>锁（Lock）</p>
<ul>
<li><p><strong>描述</strong>：通过锁机制，线程可以同步访问共享资源。</p>
</li>
<li><p>常见类型：</p>
<ul>
<li><strong>互斥锁（Mutex）</strong>：确保同一时间只有一个线程访问共享资源。</li>
<li><strong>读写锁（Read-Write Lock）</strong>：写锁获取时阻塞所有尝试获取锁的线程，读锁获取时只阻塞写锁。读模式共享，写模式互斥。</li>
<li><strong>自旋锁</strong>：获取锁失败并不阻塞，而是循环轮询尝试，因为没有线程切换所以没有相关开销，但因为占用CPU所以可能造成资源浪费。适用于并行结构或锁占用时间较短切换频繁的场景。</li>
</ul>
</li>
</ul>
</li>
<li><p><strong>条件变量（Condition Variable）</strong></p>
<ul>
<li><p><strong>描述</strong>：线程通过条件变量实现等待和通知机制。以原子的方式阻塞线程，直到某个特定的条件为真。条件变量一直与互斥锁配套使用。</p>
</li>
<li><p>示例（Java）：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">synchronized</span> (lock) &#123;</span><br><span class="line">    <span class="keyword">while</span> (!condition) &#123;</span><br><span class="line">        lock.wait();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 执行操作</span></span><br><span class="line">    lock.notifyAll();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
</li>
<li><p><strong>信号量（Semaphore）</strong></p>
<ul>
<li><p><strong>描述</strong>：包括无名和命名信号量。类似于进程的信号量，可以高效完成基于线程的资源计数，是一个整数计数器，每当公共资源增加或减少就相应变化，当信号量大于0时可以访问其所代表的资源。</p>
</li>
<li><p>示例（Java）：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">Semaphore semaphore = <span class="keyword">new</span> Semaphore(<span class="number">3</span>); <span class="comment">// 最多允许3个线程访问</span></span><br><span class="line">semaphore.acquire();</span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">    <span class="comment">// 访问共享资源</span></span><br><span class="line">&#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">    semaphore.release();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
</li>
<li><p>volatile共享内存：TODO</p>
</li>
<li><p>阻塞唤醒机制：TODO</p>
</li>
<li><p>阻塞队列（Blocking Queue）</p>
<ul>
<li><p><strong>描述</strong>：线程通过阻塞队列实现生产者-消费者模型。</p>
</li>
<li><p>示例（Java）：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">BlockingQueue&lt;Integer&gt; queue = <span class="keyword">new</span> ArrayBlockingQueue&lt;&gt;(<span class="number">10</span>);</span><br><span class="line">queue.put(<span class="number">1</span>); <span class="comment">// 阻塞直到队列有空间</span></span><br><span class="line">queue.take(); <span class="comment">// 阻塞直到队列有数据</span></span><br></pre></td></tr></table></figure></li>
</ul>
</li>
</ol>
<p><strong>进程与线程通信方式对比</strong></p>
<table>
<thead>
<tr>
<th><strong>特性</strong></th>
<th><strong>进程间通信</strong></th>
<th><strong>线程间通信</strong></th>
</tr>
</thead>
<tbody><tr>
<td><strong>地址空间</strong></td>
<td>各进程独立，需要显式通信机制。</td>
<td>共享进程地址空间，通信更简单。</td>
</tr>
<tr>
<td><strong>效率</strong></td>
<td>较低（如管道、消息队列有内核开销）。</td>
<td>较高，直接操作共享内存。</td>
</tr>
<tr>
<td><strong>数据同步</strong></td>
<td>需要同步机制（如信号量、共享内存）。</td>
<td>需要同步机制（如锁、条件变量）。</td>
</tr>
<tr>
<td><strong>通信复杂性</strong></td>
<td>高，需要显式建立通信渠道。</td>
<td>低，数据共享天然支持。</td>
</tr>
<tr>
<td><strong>适用场景</strong></td>
<td>独立进程间的协作或分布式通信。</td>
<td>同一任务下的并发操作。</td>
</tr>
</tbody></table>
<h4 id="问：生产者消费者问题？"><a href="#问：生产者消费者问题？" class="headerlink" title="问：生产者消费者问题？"></a>问：生产者消费者问题？</h4><ol>
<li><p>问题描述</p>
<ul>
<li>生产者消费者问题，又叫<strong>有限缓冲区问题</strong>，是多进程同步的经典案例。典型的<strong>同步问题</strong>，一个共享固定大小的缓冲区，多个生产者线程或进程负责向缓冲区生产数据，多个消费者进程则消耗缓冲区的数据。生产者需要在缓冲区有空闲空间时才能生产，消费者需要在缓冲区有数据时才能消费。问题的关键就是保证生产者不会在缓冲区满时加入数据，消费者不会在缓冲区空时消耗数据。</li>
</ul>
</li>
<li><p>核心难点</p>
<ul>
<li><strong>数据竞争</strong>：生产者和消费者同时访问共享缓冲区，可能造成数据混乱。</li>
<li><strong>同步与互斥</strong>：需要确保生产者在缓冲区未满时生产，消费者在缓冲区非空时消费。</li>
<li><strong>效率</strong>：避免线程或进程因资源竞争而忙等待，提升系统效率。</li>
</ul>
</li>
<li><p>常见解决方案，解决生产者-消费者问题需要借助<strong>进程间或线程间的同步机制</strong>：</p>
<p>基于线程的解决方案（Java 示例）</p>
<p><strong>1. 使用阻塞队列（推荐方式）</strong></p>
<p>Java 提供的 <code>BlockingQueue</code> 是生产者-消费者问题的理想解决方案。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.concurrent.ArrayBlockingQueue;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.BlockingQueue;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ProducerConsumer</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        BlockingQueue&lt;Integer&gt; queue = <span class="keyword">new</span> ArrayBlockingQueue&lt;&gt;(<span class="number">5</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 生产者线程</span></span><br><span class="line">        Runnable producer = () -&gt; &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++) &#123;</span><br><span class="line">                    queue.put(i); <span class="comment">// 阻塞直到队列有空位</span></span><br><span class="line">                    System.out.println(<span class="string">&quot;Produced: &quot;</span> + i);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                Thread.currentThread().interrupt();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 消费者线程</span></span><br><span class="line">        Runnable consumer = () -&gt; &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                <span class="keyword">while</span> (<span class="keyword">true</span>) &#123;</span><br><span class="line">                    Integer item = queue.take(); <span class="comment">// 阻塞直到队列有数据</span></span><br><span class="line">                    System.out.println(<span class="string">&quot;Consumed: &quot;</span> + item);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                Thread.currentThread().interrupt();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">new</span> Thread(producer).start();</span><br><span class="line">        <span class="keyword">new</span> Thread(consumer).start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>2. 使用 <code>wait()</code> 和 <code>notify()</code></strong></p>
<p>手动实现同步逻辑，适合学习线程间通信。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.LinkedList;</span><br><span class="line"><span class="keyword">import</span> java.util.Queue;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ProducerConsumer</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> CAPACITY = <span class="number">5</span>;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> Queue&lt;Integer&gt; queue = <span class="keyword">new</span> LinkedList&lt;&gt;();</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        ProducerConsumer pc = <span class="keyword">new</span> ProducerConsumer();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 生产者线程</span></span><br><span class="line">        Runnable producer = () -&gt; &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++) &#123;</span><br><span class="line">                    pc.produce(i);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                Thread.currentThread().interrupt();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 消费者线程</span></span><br><span class="line">        Runnable consumer = () -&gt; &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                <span class="keyword">while</span> (<span class="keyword">true</span>) &#123;</span><br><span class="line">                    pc.consume();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                Thread.currentThread().interrupt();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">new</span> Thread(producer).start();</span><br><span class="line">        <span class="keyword">new</span> Thread(consumer).start();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">produce</span><span class="params">(<span class="keyword">int</span> value)</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">        <span class="keyword">while</span> (queue.size() == CAPACITY) &#123;</span><br><span class="line">            wait(); <span class="comment">// 等待队列有空位</span></span><br><span class="line">        &#125;</span><br><span class="line">        queue.add(value);</span><br><span class="line">        System.out.println(<span class="string">&quot;Produced: &quot;</span> + value);</span><br><span class="line">        notifyAll(); <span class="comment">// 通知消费者</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">consume</span><span class="params">()</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">        <span class="keyword">while</span> (queue.isEmpty()) &#123;</span><br><span class="line">            wait(); <span class="comment">// 等待队列有数据</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> value = queue.poll();</span><br><span class="line">        System.out.println(<span class="string">&quot;Consumed: &quot;</span> + value);</span><br><span class="line">        notifyAll(); <span class="comment">// 通知生产者</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p>基于进程的解决方案：<strong>使用共享内存 + 信号量</strong></p>
<ul>
<li>因为缓冲区属于临界资源，因此需要使用一个<strong>互斥量 mutex</strong> 来控制对缓冲区的互斥访问。</li>
<li>为了同步生产者和消费者的行为，需要记录缓冲区中物品的数量。<strong>数量可以使用信号量来进行统计</strong>，这里需要使用两个信号量：<ul>
<li>empty：记录空缓冲区的数量，empty 信号量是在生产者进程中使用，当 empty 不为 0 时，生产者才可以放入物品；</li>
<li>full：记录满缓冲区的数量，full 信号量是在消费者进程中使用，当 full 信号量不为 0 时，消费者才可以取走物品。</li>
</ul>
</li>
<li><strong>生产者</strong>：检查可用空位信号量，写入共享内存后增加数据信号量。</li>
<li><strong>消费者</strong>：检查数据信号量，读取共享内存后增加空位信号量。</li>
<li>注意，不能先对缓冲区进行加锁，再测试信号量。也就是说，不能先执行 down(mutex) 再执行 down(empty)。如果这么做了，那么可能会出现这种情况：生产者对缓冲区加锁后，执行 down(empty) 操作，发现 empty = 0，此时生产者睡眠。消费者不能进入临界区，因为生产者对缓冲区加锁了，消费者就无法执行 up(empty) 操作，empty 永远都为 0，导致生产者永远等待下，不会释放锁，消费者因此也会永远等待下去。</li>
</ul>
</li>
</ol>
<h4 id="问：哲学家进餐问题？"><a href="#问：哲学家进餐问题？" class="headerlink" title="问：哲学家进餐问题？"></a>问：哲学家进餐问题？</h4><ol>
<li><p>问题描述：由计算机科学家 <strong>Edsger Dijkstra</strong> 提出，是典型的同步问题，用于说明如何避免死锁、饥饿等问题。</p>
<ul>
<li><p><strong>场景</strong>：五个哲学家围坐在圆桌旁，每个哲学家面前放着食物。哲学家的生活有两种交替活动：吃饭以及思考。当一个哲学家吃饭时，需要先拿起自己左右两边的两根筷子，并且一次只能拿起一根筷子。生活的循环是“思考”和“吃饭”。</p>
</li>
<li><p>条件：</p>
<ul>
<li>每个哲学家吃饭时<strong>需要两只筷子</strong>（左手和右手）。</li>
<li>筷子放在哲学家之间的两侧，共有五根筷子。</li>
<li>筷子是共享资源，最多只能被一个哲学家使用。</li>
</ul>
</li>
<li><p><strong>问题</strong>：如何设计一种机制，保证哲学家不会出现死锁或饥饿现象，同时能有效地使用资源。</p>
</li>
</ul>
</li>
<li><p>问题的核心挑战</p>
<ul>
<li>死锁（Deadlock）：如果每个哲学家同时拿起左手的筷子，所有人都会等待右手的筷子，从而陷入死锁。</li>
<li>饥饿（Starvation）：如果某个哲学家长期无法获取两只筷子，他将永远无法进餐。</li>
<li>并发性：如何设计高效的机制，使多个哲学家可以尽量同时进餐，避免资源浪费。</li>
</ul>
</li>
<li><p>解决方案：</p>
<p>为了防止死锁的发生，可以设置两个条件：</p>
<ul>
<li>必须同时拿起左右两根筷子；</li>
<li>只有在两个邻居都没有进餐的情况下才允许进餐。</li>
</ul>
<p><strong>方法 1：资源分配顺序</strong></p>
<ul>
<li><strong>规则</strong>：哲学家只有在<strong>同时拿到两只筷子时才可以进餐</strong>，否则必须放下已拿的筷子。</li>
<li><strong>实现</strong>： 每个哲学家尝试同时获取左右两只筷子（互斥锁或信号量），失败时放下筷子并稍后重试。</li>
</ul>
<p><strong>伪代码：</strong></p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">while</span> <span class="literal">True</span>:</span><br><span class="line">    think() <span class="comment"># 思考</span></span><br><span class="line">    wait(left_fork)  <span class="comment"># 拿左边的筷子</span></span><br><span class="line">    <span class="keyword">if</span> try_acquire(right_fork):  <span class="comment"># 尝试拿右边的筷子</span></span><br><span class="line">        eat()  <span class="comment"># 进餐</span></span><br><span class="line">        release(right_fork)</span><br><span class="line">    release(left_fork)</span><br></pre></td></tr></table></figure>

<p><strong>方法 2：限制同时进餐的哲学家</strong></p>
<ul>
<li><strong>规则</strong>：限制最多只能有<strong>4个哲学家同时尝试拿筷子</strong>，保证至少一个哲学家能够成功拿到两只筷子并进餐。</li>
<li><strong>实现</strong>：使用一个计数信号量，限制最多允许4个哲学家同时进入“拿筷子”阶段。</li>
</ul>
<p><strong>伪代码：</strong></p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">semaphore dining = <span class="number">4</span>  <span class="comment"># 限制同时进入拿筷子的哲学家数量</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">while</span> <span class="literal">True</span>:</span><br><span class="line">    think()  <span class="comment"># 思考</span></span><br><span class="line">    wait(dining)  <span class="comment"># 尝试进入拿筷子阶段</span></span><br><span class="line">    wait(left_fork)  <span class="comment"># 拿左边的筷子</span></span><br><span class="line">    wait(right_fork)  <span class="comment"># 拿右边的筷子</span></span><br><span class="line">    eat()  <span class="comment"># 进餐</span></span><br><span class="line">    release(right_fork)  <span class="comment"># 放下右边的筷子</span></span><br><span class="line">    release(left_fork)  <span class="comment"># 放下左边的筷子</span></span><br><span class="line">    signal(dining)  <span class="comment"># 离开拿筷子阶段</span></span><br></pre></td></tr></table></figure>

<p><strong>方法 3：改变资源分配顺序</strong></p>
<ul>
<li><strong>规则</strong>：所有哲学家以相同的顺序拿筷子（如先拿左筷子，再拿右筷子），<strong>除了最后一个哲学家</strong>，他需先拿右筷子再拿左筷子。</li>
<li><strong>优点</strong>：避免形成资源分配的环路，从而预防死锁。</li>
</ul>
<p><strong>伪代码：</strong></p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (philosopher_index == n - <span class="number">1</span>):  <span class="comment"># 最后一个哲学家</span></span><br><span class="line">    wait(right_fork)</span><br><span class="line">    wait(left_fork)</span><br><span class="line"><span class="keyword">else</span>:</span><br><span class="line">    wait(left_fork)</span><br><span class="line">    wait(right_fork)</span><br><span class="line"></span><br><span class="line">eat()</span><br><span class="line"></span><br><span class="line">release(left_fork)</span><br><span class="line">release(right_fork)</span><br></pre></td></tr></table></figure>

<p><strong>方法 4：使用条件变量</strong></p>
<ul>
<li><strong>规则</strong>：哲学家需要检查邻居是否正在用餐，只有邻居都没有用餐时才可以拿筷子。</li>
<li><strong>实现</strong>：通过条件变量管理哲学家的状态（思考、饥饿、用餐），并保证同时最多只有两个相邻的哲学家进餐。</li>
</ul>
<p><strong>伪代码：</strong></p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">enum State &#123;THINKING, HUNGRY, EATING&#125;;</span><br><span class="line">State[] states = new State[<span class="number">5</span>];  <span class="comment"># 每个哲学家的状态</span></span><br><span class="line">Condition[] self = new Condition[<span class="number">5</span>];  <span class="comment"># 条件变量</span></span><br><span class="line"></span><br><span class="line">lock.acquire();</span><br><span class="line"><span class="keyword">while</span> (true) &#123;</span><br><span class="line">    think();</span><br><span class="line">    states[i] = HUNGRY;</span><br><span class="line">    test(i);</span><br><span class="line">    <span class="keyword">if</span> (states[i] != EATING)</span><br><span class="line">        self[i].<span class="keyword">await</span>();  <span class="comment"># 等待</span></span><br><span class="line">    eat();</span><br><span class="line">    states[i] = THINKING;</span><br><span class="line">    test((i - <span class="number">1</span> + <span class="number">5</span>) % <span class="number">5</span>);  <span class="comment"># 通知左邻居</span></span><br><span class="line">    test((i + <span class="number">1</span>) % <span class="number">5</span>);      <span class="comment"># 通知右邻居</span></span><br><span class="line">    lock.release();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">void test(<span class="built_in">int</span> i) &#123;</span><br><span class="line">    <span class="keyword">if</span> (states[i] == HUNGRY &amp;&amp;</span><br><span class="line">        states[(i - <span class="number">1</span> + <span class="number">5</span>) % <span class="number">5</span>] != EATING &amp;&amp;</span><br><span class="line">        states[(i + <span class="number">1</span>) % <span class="number">5</span>] != EATING) &#123;</span><br><span class="line">        states[i] = EATING;</span><br><span class="line">        self[i].signal();  <span class="comment"># 唤醒哲学家</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ol>
<h4 id="问：读者写者问题？"><a href="#问：读者写者问题？" class="headerlink" title="问：读者写者问题？"></a>问：读者写者问题？</h4><p>允许多个进程同时对数据进行读操作，但是不允许读和写以及写和写操作同时发生。</p>
<ol>
<li><p>问题描述</p>
<p><strong>读者-写者问题（Readers-Writers Problem）</strong>是经典的同步问题，主要描述多个读者和写者如何安全地访问共享资源（如文件、数据库等）：</p>
<ul>
<li><strong>读者</strong>：可以同时访问资源（共享读锁）。</li>
<li><strong>写者</strong>：独占资源访问，不能与任何其他读者或写者同时操作（独占写锁）。</li>
</ul>
</li>
<li><p>问题的核心</p>
<ul>
<li><p>数据一致性：确保写操作与读操作、写操作与写操作之间不会引起数据冲突。</p>
</li>
<li><p>公平性：避免某一类（读者或写者）长时间无法获得资源，造成<strong>饥饿</strong>现象。</p>
</li>
<li><p>效率：尽量允许更多的并发（如多个读者同时读），提升系统性能。</p>
</li>
</ul>
</li>
<li><p>常见场景</p>
<ul>
<li>数据库系统中，读操作和写操作的并发控制。</li>
<li>文件系统中的读写访问。</li>
<li>缓存系统中的共享和更新。</li>
</ul>
</li>
<li><p>问题的变体</p>
<ul>
<li><p>第一类读者-写者问题：<strong>优先读者</strong>：当读者想访问时，写者必须等待，可能造成写者饥饿。</p>
</li>
<li><p>第二类读者-写者问题：<strong>优先写者</strong>：当写者想访问时，新的读者必须等待，可能造成读者饥饿。</p>
</li>
<li><p>第三类读者-写者问题（公平性）：读者和写者按照先后顺序访问资源，不优先考虑某一方，避免饥饿。</p>
</li>
</ul>
</li>
<li><p>解决方案</p>
<p>一个整型变量 count 记录在对数据进行读操作的进程数量，一个互斥量 count_mutex 用于对 count 加锁，一个互斥量 data_mutex 用于对读写的数据加锁。</p>
<p><strong>优先读者的实现</strong></p>
<p>读者可以在其他读者访问时加入，写者必须等待。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.concurrent.locks.ReentrantReadWriteLock;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ReaderWriter</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> ReentrantReadWriteLock lock = <span class="keyword">new</span> ReentrantReadWriteLock();</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> ReentrantReadWriteLock.ReadLock readLock = lock.readLock();</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> ReentrantReadWriteLock.WriteLock writeLock = lock.writeLock();</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Runnable reader = () -&gt; &#123;</span><br><span class="line">            readLock.lock();</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                System.out.println(Thread.currentThread().getName() + <span class="string">&quot; is reading&quot;</span>);</span><br><span class="line">                Thread.sleep(<span class="number">1000</span>); <span class="comment">// 模拟读操作</span></span><br><span class="line">                System.out.println(Thread.currentThread().getName() + <span class="string">&quot; finished reading&quot;</span>);</span><br><span class="line">            &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                Thread.currentThread().interrupt();</span><br><span class="line">            &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">                readLock.unlock();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;;</span><br><span class="line"></span><br><span class="line">        Runnable writer = () -&gt; &#123;</span><br><span class="line">            writeLock.lock();</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                System.out.println(Thread.currentThread().getName() + <span class="string">&quot; is writing&quot;</span>);</span><br><span class="line">                Thread.sleep(<span class="number">2000</span>); <span class="comment">// 模拟写操作</span></span><br><span class="line">                System.out.println(Thread.currentThread().getName() + <span class="string">&quot; finished writing&quot;</span>);</span><br><span class="line">            &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                Thread.currentThread().interrupt();</span><br><span class="line">            &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">                writeLock.unlock();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 创建并启动读者和写者线程</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">3</span>; i++) &#123;</span><br><span class="line">            <span class="keyword">new</span> Thread(reader, <span class="string">&quot;Reader-&quot;</span> + i).start();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">2</span>; i++) &#123;</span><br><span class="line">            <span class="keyword">new</span> Thread(writer, <span class="string">&quot;Writer-&quot;</span> + i).start();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>优先写者的实现</strong></p>
<p>写者优先，当有写者想访问时，读者必须等待。</p>
<p><strong>伪代码：</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ReaderWriterPriorityWrite</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> readCount = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">boolean</span> writeFlag = <span class="keyword">false</span>;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> Object lock = <span class="keyword">new</span> Object();</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">read</span><span class="params">()</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">        <span class="keyword">synchronized</span> (lock) &#123;</span><br><span class="line">            <span class="keyword">while</span> (writeFlag) &#123;</span><br><span class="line">                lock.wait(); <span class="comment">// 等待写操作完成</span></span><br><span class="line">            &#125;</span><br><span class="line">            readCount++;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 读操作</span></span><br><span class="line">        System.out.println(Thread.currentThread().getName() + <span class="string">&quot; is reading&quot;</span>);</span><br><span class="line">        Thread.sleep(<span class="number">1000</span>);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">synchronized</span> (lock) &#123;</span><br><span class="line">            readCount--;</span><br><span class="line">            <span class="keyword">if</span> (readCount == <span class="number">0</span>) &#123;</span><br><span class="line">                lock.notifyAll();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">write</span><span class="params">()</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">        <span class="keyword">synchronized</span> (lock) &#123;</span><br><span class="line">            <span class="keyword">while</span> (writeFlag || readCount &gt; <span class="number">0</span>) &#123;</span><br><span class="line">                lock.wait(); <span class="comment">// 等待读者或写者释放资源</span></span><br><span class="line">            &#125;</span><br><span class="line">            writeFlag = <span class="keyword">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 写操作</span></span><br><span class="line">        System.out.println(Thread.currentThread().getName() + <span class="string">&quot; is writing&quot;</span>);</span><br><span class="line">        Thread.sleep(<span class="number">2000</span>);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">synchronized</span> (lock) &#123;</span><br><span class="line">            writeFlag = <span class="keyword">false</span>;</span><br><span class="line">            lock.notifyAll();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>公平性解决方案</strong></p>
<p>通过信号量（Semaphore）或公平锁实现读者与写者的交替访问。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.concurrent.Semaphore;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">FairReaderWriter</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> Semaphore resource = <span class="keyword">new</span> Semaphore(<span class="number">1</span>);</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> Semaphore readLock = <span class="keyword">new</span> Semaphore(<span class="number">1</span>);</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">int</span> readCount = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Runnable reader = () -&gt; &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                readLock.acquire();</span><br><span class="line">                <span class="keyword">if</span> (readCount == <span class="number">0</span>) &#123;</span><br><span class="line">                    resource.acquire();</span><br><span class="line">                &#125;</span><br><span class="line">                readCount++;</span><br><span class="line">                readLock.release();</span><br><span class="line"></span><br><span class="line">                System.out.println(Thread.currentThread().getName() + <span class="string">&quot; is reading&quot;</span>);</span><br><span class="line">                Thread.sleep(<span class="number">1000</span>);</span><br><span class="line"></span><br><span class="line">                readLock.acquire();</span><br><span class="line">                readCount--;</span><br><span class="line">                <span class="keyword">if</span> (readCount == <span class="number">0</span>) &#123;</span><br><span class="line">                    resource.release();</span><br><span class="line">                &#125;</span><br><span class="line">                readLock.release();</span><br><span class="line">            &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                Thread.currentThread().interrupt();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;;</span><br><span class="line"></span><br><span class="line">        Runnable writer = () -&gt; &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                resource.acquire();</span><br><span class="line">                System.out.println(Thread.currentThread().getName() + <span class="string">&quot; is writing&quot;</span>);</span><br><span class="line">                Thread.sleep(<span class="number">2000</span>);</span><br><span class="line">                resource.release();</span><br><span class="line">            &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                Thread.currentThread().interrupt();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">3</span>; i++) &#123;</span><br><span class="line">            <span class="keyword">new</span> Thread(reader, <span class="string">&quot;Reader-&quot;</span> + i).start();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">2</span>; i++) &#123;</span><br><span class="line">            <span class="keyword">new</span> Thread(writer, <span class="string">&quot;Writer-&quot;</span> + i).start();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ol>
<h4 id="问：进程调度算法？"><a href="#问：进程调度算法？" class="headerlink" title="问：进程调度算法？"></a>问：进程调度算法？</h4><ol>
<li><p>什么是进程调度？</p>
<ul>
<li>进程调度是操作系统<strong>为多个进程分配 CPU 资源</strong>的机制，目的是在多任务系统中高效地管理和执行进程。</li>
<li>调度策略的目标：<ul>
<li><strong>最大化 CPU 利用率</strong>。</li>
<li>最小化等待时间、周转时间和响应时间。</li>
<li>确保系统的公平性和效率。</li>
</ul>
</li>
</ul>
</li>
<li><p>常见的进程调度算法</p>
<p>不同环境的调度算法目标不同，因此需要针对不同环境来讨论调度算法：</p>
<ul>
<li><p><strong>批处理系统</strong>：批处理系统没有太多的用户操作，在该系统中，调度算法目标是<strong>保证吞吐量和周转时间</strong>（从提交到终止的时间）。</p>
<ul>
<li><p><strong>先来先服务（FCFS, First-Come, First-Served）</strong>：</p>
<ul>
<li><p><strong>描述</strong>：按照进程到达的顺序分配 CPU，先到先执行。非抢占式的调度算法，<strong>有利于长作业，但不利于短作业</strong>，因为短作业必须一直等待前面的长作业执行完毕才能执行，而长作业又需要执行很长时间，造成了短作业等待时间过长。</p>
</li>
<li><p>特点：</p>
<ul>
<li>实现简单。</li>
<li>不支持抢占。</li>
</ul>
</li>
<li><p>优点：</p>
<ul>
<li>简单易用。</li>
<li>对长进程有利。</li>
</ul>
</li>
<li><p>缺点：</p>
<ul>
<li>平均等待时间可能较长。</li>
<li>容易出现“<strong>长进程阻塞短进程</strong>”的问题（即“<strong>会车现象</strong>”）。</li>
</ul>
</li>
</ul>
<p><strong>例</strong>：假设有以下进程及其到达时间和运行时间：</p>
<table>
<thead>
<tr>
<th>进程</th>
<th>到达时间</th>
<th>执行时间</th>
</tr>
</thead>
<tbody><tr>
<td>P1</td>
<td>0</td>
<td>5</td>
</tr>
<tr>
<td>P2</td>
<td>1</td>
<td>3</td>
</tr>
<tr>
<td>P3</td>
<td>2</td>
<td>8</td>
</tr>
</tbody></table>
<ul>
<li>调度顺序：P1 → P2 → P3</li>
<li>平均等待时间：<code>(0 + 5 + 8) / 3 = 4.33</code> 秒。</li>
</ul>
</li>
<li><p><strong>短作业优先（SJF, Shortest Job First）</strong>：</p>
<ul>
<li><p><strong>描述</strong>：优先调度执行时间最短的进程。按估计运行时间最短的顺序进行调度。<strong>长作业有可能会饿死，处于一直等待短作业执行完毕的状态</strong>。因为如果一直有短作业到来，那么长作业永远得不到调度。</p>
</li>
<li><p>特点：</p>
<ul>
<li>可以是非抢占式，也可以是抢占式（抢占式又称<strong>最短剩余时间优先</strong>，SRTF）。</li>
</ul>
</li>
<li><p>优点：</p>
<ul>
<li>能够最小化平均等待时间。</li>
</ul>
</li>
<li><p>缺点：</p>
<ul>
<li><strong>可能导致饥饿问题</strong>（长进程可能永远得不到调度）。</li>
<li>实现依赖于对执行时间的准确预测。</li>
</ul>
</li>
</ul>
<p><strong>例</strong>：与 FCFS 相同的进程：</p>
<ul>
<li>调度顺序：P2 → P1 → P3</li>
<li>平均等待时间：<code>(0 + 3 + 5) / 3 = 2.67</code> 秒。</li>
</ul>
</li>
<li><p><strong>最短剩余时间优先（SRTN</strong>）：最短作业优先的抢占式版本，按剩余运行时间的顺序进行调度。 当一个新的作业到达时，其整个运行时间与当前进程的剩余时间作比较。如果新的进程需要的时间更少，则挂起当前进程，运行新的进程。否则新的进程等待。</p>
</li>
</ul>
</li>
<li><p><strong>交互式系统</strong>：交互式系统有大量的用户交互操作，在该系统中调度算法的目标是<strong>快速地进行响应</strong>。</p>
<ul>
<li><p><strong>时间片轮转（RR, Round-Robin）</strong>：</p>
<ul>
<li><p><strong>描述</strong>：将 CPU 时间片分为固定长度，每个进程按照循环顺序分配 CPU 时间片。将所有就绪进程按 FCFS 的原则排成一个队列，每次调度时，把 CPU 时间分配给队首进程，该进程可以执行一个时间片。当时间片用完时，由计时器发出时钟中断，调度程序便停止该进程的执行，并将它送往就绪队列的末尾，同时继续把 CPU 时间分配给队首的进程。</p>
</li>
<li><p>特点：</p>
<ul>
<li>是抢占式调度。</li>
<li>时间片的大小对性能影响很大：因为进程切换都要保存进程的信息并且载入新进程的信息。<ul>
<li>时间片太长：退化为 FCFS。实时性就不能得到保证。</li>
<li>时间片太短：上下文切换开销大。会导致进程切换得太频繁，在进程切换上就会花过多时间。</li>
</ul>
</li>
</ul>
</li>
<li><p>优点：公平性好，适合时间共享系统。</p>
</li>
<li><p>缺点：平均等待时间可能较高。</p>
</li>
</ul>
<p><strong>例</strong>：假设时间片为 2 秒：</p>
<ul>
<li>调度顺序：P1(2) → P2(2) → P3(2) → P1(3) → P3(6)</li>
<li>平均等待时间：<code>(0 + 2 + 4 + 6 + 8) / 3 = 5</code> 秒。</li>
</ul>
</li>
<li><p><strong>优先级调度（Priority Scheduling）</strong>：为每个进程分配一个优先级，按优先级进行调度。为了<strong>防止低优先级的进程永远等不到调度，可以随着时间的推移增加等待进程的优先级</strong>。</p>
<ul>
<li><p><strong>描述</strong>：根据进程的优先级调度 CPU，优先级高的进程优先执行。</p>
</li>
<li><p>特点：</p>
<ul>
<li>可以是抢占式，也可以是非抢占式。</li>
<li>优先级可以动态调整（如老化技术）。</li>
</ul>
</li>
<li><p>优点：高优先级任务响应快。</p>
</li>
<li><p>缺点：<strong>可能导致饥饿</strong>问题（低优先级进程可能永远得不到调度）。</p>
</li>
</ul>
<p><strong>例</strong>：假设时间片为 2 秒：</p>
<table>
<thead>
<tr>
<th>进程</th>
<th>优先级</th>
<th>执行时间</th>
</tr>
</thead>
<tbody><tr>
<td>P1</td>
<td>2</td>
<td>5</td>
</tr>
<tr>
<td>P2</td>
<td>1</td>
<td>3</td>
</tr>
<tr>
<td>P3</td>
<td>3</td>
<td>8</td>
</tr>
</tbody></table>
<ul>
<li>调度顺序：P3 → P1 → P2</li>
<li>平均等待时间：<code>(0 + 8 + 13) / 3 = 7</code> 秒。</li>
</ul>
</li>
<li><p><strong>多级队列调度（Multilevel Queue Scheduling）</strong></p>
<ul>
<li><p><strong>描述</strong>：将进程<strong>按照不同类别</strong>（如前台交互进程、后台批处理进程）<strong>分到不同队列</strong>，不同队列有不同的优先级或调度策略。一个进程需要执行 100 个时间片，如果采用时间片轮转调度算法，那么需要交换 100 次。多级队列是为这种需要连续执行多个时间片的进程考虑，它设置了多个队列，每个队列时间片大小都不同，例如 1,2,4,8,..。</p>
</li>
<li><p>特点：</p>
<ul>
<li><strong>每个队列可以有自己的调度算法</strong>。</li>
<li>进程一般不跨队列。</li>
</ul>
</li>
<li><p>优点：实现了不同类型任务的分级调度。</p>
</li>
<li><p>缺点：队列优先级的配置和算法设计较复杂。</p>
</li>
</ul>
</li>
<li><p><strong>多级反馈队列调度（Multilevel Feedback Queue Scheduling）</strong>：</p>
<ul>
<li><p><strong>描述</strong>：在多级队列的基础上，<strong>允许进程根据其表现（如 CPU 时间使用量）在队列间动态调整</strong>。进程在第一个队列没执行完，就会被移到下一个队列。这种方式下，之前的进程只需要交换 7 次。每个队列优先权也不同，最上面的优先权最高。因此只有上一个队列没有进程在排队，才能调度当前队列上的进程。可以将这种调度算法看成是时间片轮转调度算法和优先级调度算法的结合。</p>
</li>
<li><p>特点：</p>
<ul>
<li>动态调整优先级，避免饥饿。</li>
<li>适合多种任务的混合负载。</li>
</ul>
</li>
<li><p>优点：兼顾了效率和公平性。</p>
</li>
<li><p>缺点：实现复杂。</p>
</li>
</ul>
</li>
</ul>
</li>
<li><p><strong>实时系统</strong>：实时系统要求一个请求在一个确定时间内得到响应。分为硬实时和软实时，前者必须满足绝对的截止时间，后者可以容忍一定的超时。</p>
</li>
</ul>
</li>
<li><p>选择调度算法的考量</p>
<ul>
<li><p>任务类型：</p>
<ul>
<li>短任务较多：选择 SJF 或多级反馈队列。</li>
<li>时间共享系统：选择 RR。</li>
</ul>
</li>
<li><p>实时性需求：</p>
<ul>
<li>实时系统中，需要优先级调度或多级队列。</li>
</ul>
</li>
<li><p>系统目标：</p>
<ul>
<li>要求最大化吞吐量：选择 SJF。</li>
<li>要求公平性：选择 RR 或多级反馈队列。</li>
</ul>
</li>
</ul>
</li>
</ol>
<h4 id="问：进程中的响应时间指？"><a href="#问：进程中的响应时间指？" class="headerlink" title="问：进程中的响应时间指？"></a>问：进程中的响应时间指？</h4><p><strong>到达时间和进程首次获取CPU的时间之间的差异</strong>称为响应时间。</p>
<h4 id="问：fork和exec有深入了解吗？父进程有多个线程在运行，调用fork后，产生的子进程中有多少个线程？"><a href="#问：fork和exec有深入了解吗？父进程有多个线程在运行，调用fork后，产生的子进程中有多少个线程？" class="headerlink" title="问：fork和exec有深入了解吗？父进程有多个线程在运行，调用fork后，产生的子进程中有多少个线程？"></a>问：fork和exec有深入了解吗？父进程有多个线程在运行，调用fork后，产生的子进程中有多少个线程？</h4><ol>
<li><p>什么是 fork 和 exec？</p>
<ul>
<li><p>**<code>fork()</code>**：</p>
<ul>
<li><p>用于创建一个新的子进程。</p>
</li>
<li><p>子进程是父进程的副本：拥有父进程的<strong>数据段</strong>、<strong>堆</strong>和<strong>栈</strong>的副本（在现代操作系统中通常通过<strong>写时拷贝</strong>机制实现）。</p>
</li>
<li><p>子进程的PID不同，返回值不同：</p>
<ul>
<li><strong>父进程</strong>中 <code>fork()</code> 返回子进程的 PID。</li>
<li><strong>子进程</strong>中 <code>fork()</code> 返回 <code>0</code>。</li>
</ul>
</li>
<li><p>子进程从父进程的<strong>fork 调用点开始执行</strong>。</p>
</li>
</ul>
</li>
<li><p>**<code>exec()</code>**：</p>
<ul>
<li>用于用一个新程序替换当前进程的代码段。</li>
<li>执行 <code>exec()</code> 后，当前进程的代码段、数据段等被新程序替换，PID 不变。</li>
</ul>
</li>
</ul>
</li>
<li><p>fork 的多线程行为</p>
<p>当一个多线程进程调用 <code>fork()</code> 时，<strong>子进程只有一个线程</strong>，即调用 <code>fork()</code> 的线程会复制到子进程中。其余线程不会复制到子进程中。</p>
<ul>
<li><strong>原因</strong>：<ul>
<li>子进程会从父进程的 <code>fork</code> 调用点开始执行。</li>
<li><strong>如果复制了所有线程，线程的状态可能在复制后变得不一致</strong>，例如线程的锁状态、堆内存状态等。</li>
<li>为了避免这些问题，POSIX 标准要求在多线程进程中调用 <code>fork</code> 后，子进程只保留调用 <code>fork</code> 的线程。</li>
</ul>
</li>
<li><strong>解决方法</strong>：如果需要保留所有线程，通常会立即调用 <code>exec()</code> 替换进程映像，这样子进程就不需要处理线程状态的问题。</li>
</ul>
</li>
<li><p>需要注意的问题</p>
<ul>
<li><strong>fork 与多线程的不兼容性</strong>：<ul>
<li>由于子进程只复制调用 <code>fork()</code> 的线程，其他线程的状态可能会导致不一致问题。</li>
<li>例如，锁的状态在子进程中可能处于锁定状态，但没有线程能解锁。</li>
</ul>
</li>
<li><strong>推荐的最佳实践</strong>：<ul>
<li>多线程环境下，如果需要使用 <code>fork()</code>，建议立即调用 <code>exec()</code>。</li>
<li>在单线程环境下使用 <code>fork()</code> 更安全。</li>
</ul>
</li>
</ul>
</li>
<li><p>结论</p>
<ul>
<li>调用 <code>fork()</code> 后，子进程中<strong>只有一个线程</strong>，即调用 <code>fork()</code> 的线程。</li>
<li>如果需要在子进程中运行多线程程序，应在 <code>fork()</code> 后调用 <code>exec()</code> 加载新的程序。</li>
<li>深入了解线程状态、锁、信号处理等，可以帮助在多线程和 <code>fork</code> 的结合场景下避免陷阱。</li>
</ul>
</li>
</ol>
<h4 id="问：死锁的必要条件？死锁的处理方法？"><a href="#问：死锁的必要条件？死锁的处理方法？" class="headerlink" title="问：死锁的必要条件？死锁的处理方法？"></a>问：死锁的必要条件？死锁的处理方法？</h4><p>根据 <strong>Coffman 条件</strong>，死锁的发生需要满足以下 <strong>4 个必要条件</strong>，若任何一个条件不成立，就不会发生死锁：</p>
<ol>
<li><strong>互斥条件</strong>（Mutual Exclusion）：资源一次只能被一个进程占用。</li>
<li><strong>占有并等待条件</strong>（Hold and Wait）：进程已经持有至少一个资源，同时等待其他资源，而这些资源被其他进程占用。</li>
<li><strong>不可抢占条件</strong>（No Preemption）：资源不能被强制抢占，只能由持有资源的进程主动释放。</li>
<li><strong>环路等待条件</strong>（Circular Wait）：存在一个进程集合 <code>&#123;P1, P2, ..., Pn&#125;</code>，其中每个进程都等待下一个进程所占用的资源，形成环形等待链。</li>
</ol>
<h4 id="问：死锁的处理方法？死锁的检测与恢复？死锁预防？死锁避免？"><a href="#问：死锁的处理方法？死锁的检测与恢复？死锁预防？死锁避免？" class="headerlink" title="问：死锁的处理方法？死锁的检测与恢复？死锁预防？死锁避免？"></a>问：死锁的处理方法？死锁的检测与恢复？死锁预防？死锁避免？</h4><p>主要有以下四种方法：</p>
<ul>
<li><p><strong>鸵鸟策略</strong>：把头埋在沙子里，假装根本没发生问题。因为解决死锁问题的代价很高，因此鸵鸟策略这种不采取任务措施的方案会获得更高的性能。当发生死锁时不会对用户造成多大影响，或发生死锁的概率很低，可以采用鸵鸟策略。大多数操作系统，包括 Unix，Linux 和 Windows，处理死锁问题的办法仅仅是忽略它。</p>
</li>
<li><p>死锁检测与恢复：允许死锁发生，系统周期性检测是否出现死锁，并通过某种策略恢复系统。</p>
<ol>
<li><p><strong>死锁检测</strong>：</p>
<ul>
<li>使用<strong>资源分配图或等待图</strong>（Wait-for Graph）检测环路。从一个节点出发进行深度优先搜索，对访问过的节点进行标记，如果访问了已经标记的节点，就表示有向图存在环，也就是检测到死锁的发生。</li>
<li><strong>若图中存在环路，则表示发生死锁</strong>。</li>
</ul>
</li>
<li><p><strong>死锁恢复</strong>：</p>
<ul>
<li><p><strong>资源抢占</strong>：强制抢占资源并分配给其他进程。</p>
</li>
<li><p>利用回滚恢复</p>
</li>
<li><p>终止进程：</p>
<ul>
<li>按一定顺序终止死锁中的进程（例如优先终止低优先级进程）。</li>
<li>一次终止一个进程，直到解除死锁。</li>
</ul>
</li>
</ul>
</li>
</ol>
<p><strong>优点</strong>：提高资源利用率，只有在发生死锁时才采取措施。</p>
<p><strong>缺点</strong>：</p>
<ul>
<li>死锁检测算法开销较高。</li>
<li>进程终止或资源抢占可能导致计算丢失或不一致。</li>
</ul>
</li>
<li><p>死锁预防：通过破坏死锁的必要条件之一，来防止死锁的发生。</p>
<ul>
<li><p>破坏互斥条件：</p>
<ul>
<li>尽量避免资源的独占使用，例如使用共享锁（但对某些资源，如打印机，无法完全避免互斥）。</li>
</ul>
</li>
<li><p>破坏占有并等待条件：</p>
<ul>
<li>要求进程在开始<strong>执行前一次性申请所需的所有资源</strong>，避免持有部分资源再申请。</li>
</ul>
</li>
<li><p>破坏不可抢占条件：</p>
<ul>
<li>允许操作系统<strong>在必要时强制抢占资源</strong>并分配给其他进程。</li>
</ul>
</li>
<li><p>破坏环路等待条件：</p>
<ul>
<li>对资源进行<strong>全局编号</strong>，要求进程<strong>按照编号递增的顺序</strong>申请资源。</li>
</ul>
</li>
</ul>
<p><strong>缺点</strong>：</p>
<ul>
<li>资源利用率低。</li>
<li>可能导致系统运行效率降低。</li>
</ul>
</li>
<li><p>死锁避免：</p>
<p>动态检测可能的死锁情况，确保系统不会进入死锁状态。</p>
<ol>
<li><p><strong>安全状态（Safe State）</strong></p>
<p><strong>定义</strong></p>
<ul>
<li>系统处于安全状态是指：<strong>存在一种资源分配顺序，使每个进程都能够在有限时间内完成并释放资源</strong>。</li>
</ul>
</li>
</ol>
</li>
<li><p>如果不存在这种顺序，则系统处于<strong>不安全状态</strong>，可能导致死锁。</p>
</li>
</ul>
<p><strong>判定条件</strong></p>
<pre><code> - 系统在进行资源分配时，必须确保分配后仍然处于安全状态。
</code></pre>
<ul>
<li>如果分配资源后，导致系统处于不安全状态，则拒绝分配。</li>
</ul>
<p><strong>安全序列</strong></p>
<pre><code> - 安全序列

    是一种进程执行顺序（如 P1,P2,…,Pn），满足以下条件：

   - 每个进程在运行时，系统有足够资源满足其需求。
</code></pre>
<ul>
<li>进程完成后释放资源，可供后续进程使用。</li>
</ul>
<p><strong>安全状态与死锁</strong></p>
<pre><code> - 安全状态 ≠ 无死锁：

   - 不安全状态并不一定会导致死锁，但可能存在死锁风险。

 - 安全状态 → 一定无死锁：

   - 系统始终保持安全状态，则死锁一定不会发生。
</code></pre>
<ol start="2">
<li><p>单个资源的银行家算法（Banker’s Algorithm）</p>
<p>银行家算法是一个经典的死锁避免算法，模拟银行对贷款的分配，确保系统始终处于安全状态。</p>
<ul>
<li>系统根据当前资源分配情况，动态评估进程申请资源后的系统状态是否安全。</li>
</ul>
</li>
</ol>
<ul>
<li><p>只有在分配资源后系统仍处于安全状态时，才允许分配资源。</p>
<ul>
<li><strong>安全状态</strong>：系统能够按照某种顺序为每个进程分配其最大需求资源并完成执行。</li>
</ul>
<p><strong>优点</strong>：</p>
<ul>
<li>相比死锁预防更灵活，资源利用率较高。</li>
</ul>
<p><strong>缺点</strong>：</p>
<ul>
<li>算法复杂度高。</li>
<li>系统开销大。</li>
</ul>
</li>
</ul>
<p>  <strong>基本概念</strong></p>
<pre><code> 1. Available（可用资源向量）：系统当前可用的每种资源数量。
 2. Maximum（最大需求矩阵）：每个进程对每种资源的最大需求。
 3. Allocation（已分配矩阵）：每个进程当前已经获得的每种资源数量。
 4. Need（需求矩阵）：
  - 每个进程还需要的每种资源数量。
 - 计算公式：Need\[i\]\[j\]=Maximum\[i\]\[j\]−Allocation\[i\]\[j\]。
</code></pre>
<p>  <strong>假设条件</strong></p>
<ul>
<li><p>系统中只有一种资源类型。</p>
<ul>
<li>每个进程的最大需求量已知。</li>
</ul>
<p><strong>算法步骤</strong></p>
<ol>
<li><p>初始状态：记录系统可用资源数量 Available 和每个进程的最大需求 Max。</p>
</li>
<li><p>安全性检查：</p>
<ul>
<li>遍历所有进程，找到一个满足 Need[i]≤Available 的进程。</li>
</ul>
</li>
</ol>
<ul>
<li>如果找到：<ul>
<li>假设该进程完成，释放资源（即 Available+=Allocation[i]）。</li>
<li>标记该进程为已完成。</li>
<li>如果没有找到：<ul>
<li>系统处于不安全状态。</li>
</ul>
</li>
</ul>
</li>
</ul>
<ol start="3">
<li>判断安全状态：<ul>
<li>如果所有进程都能完成，则系统处于安全状态。</li>
</ul>
</li>
</ol>
</li>
<li><p>否则，不安全。</p>
</li>
</ul>
<p>   一个小城镇的银行家，他向一群客户分别承诺了一定的贷款额度，算法要做的是判断对请求的满足是否会进入不安全状态，如果是，就拒绝请求；否则予以分配。</p>
<p>   上图 c 为不安全状态，因此算法会拒绝之前的请求，从而避免进入图 c 中的状态。</p>
<ol start="3">
<li><p>多个资源的银行家算法</p>
<p><strong>假设条件</strong></p>
<ul>
<li>系统中有多种资源类型。</li>
</ul>
</li>
</ol>
<ul>
<li>每个进程的最大需求和已分配资源已知。</li>
</ul>
<p>   <strong>算法步骤</strong></p>
<ol>
<li><strong>初始化数据结构</strong>：<ul>
<li>可用资源向量 Available。</li>
<li>最大需求矩阵 Maximum。</li>
<li>已分配矩阵 Allocation。<ul>
<li>需求矩阵 Need，计算公式： Need[i][j]=Maximum[i][j]−Allocation[i][j]</li>
</ul>
</li>
</ul>
</li>
<li><strong>安全性检查算法</strong>：<ul>
<li>设置工作向量 Work： Work=Available</li>
<li>初始化完成标志向量 Finish： Finish[i]=false(i=1,2,…,n)</li>
<li>遍历所有进程，找到满足以下条件的进程 Pi： Need[i] ≤ Work and Finish[i] = false</li>
<li>如果找到：<ul>
<li>假设该进程完成，将其资源释放给系统： Work=Work+Allocation[i]</li>
<li>标记为完成： Finish[i]=true</li>
</ul>
</li>
<li>如果没有找到：<ul>
<li>停止检查，判断系统是否处于安全状态。</li>
</ul>
<ol start="3">
<li><strong>判断安全状态</strong>：</li>
</ol>
</li>
<li>如果所有 Finish[i]=true，则系统处于安全状态。</li>
<li>如果存在未完成的进程，系统处于不安全状态。</li>
</ul>
</li>
</ol>
<pre><code> 检查一个状态是否安全的算法如下：
  
 - 查找右边的矩阵是否存在一行小于等于向量 A。如果不存在这样的行，那么系统将会发生死锁，状态是不安全的。
 - 假若找到这样一行，将该进程标记为终止，并将其已分配资源加到 A 中。
 - 重复以上两步，直到所有进程都标记为终止，则状态时安全的。
   
 如果一个状态不是安全的，需要拒绝进入这个状态。

 **示例：多个资源的银行家算法**

 **问题描述**
  
 系统有以下资源：

 - 可用资源：[3,3,2]。
</code></pre>
<ul>
<li>进程 P0 到 P4 的资源分配和需求：</li>
</ul>
<p>   | 进程 | Allocation | Maximum                 | Need                    |<br>     | —- | ———- | ———————– | ———————– |<br>   | P0   | [0,1,0]    | [7,5,3] | [7,4,3] |<br>     | P1   | [2,0,0]    | [3,2,2] | [1,2,2] |<br>   | P2   | [3,0,2]    | [9,0,2] | [6,0,0] |<br>     | P3   | [2,1,1]    | [2,2,2] | [0,1,1] |<br>     | P4   | [0,0,2]    | [4,3,3] | [4,3,1] |</p>
<pre><code> **步骤**
  
 1. 初始状态：Work=[3,3,2]。
  
 2. 遍历寻找满足条件的进程：
  
    - P1满足 Need[1]≤Work：

       - 假设完成，释放资源：Work=[3,3,2]+[2,0,0]=[5,3,2]。

    - P3满足 Need[3]≤Work：

       - 假设完成，释放资源：Work=[5,3,2]+[2,1,1]=[7,4,3]。

    - 继续寻找，最终得出安全序列 [P1,P3,…]。

 **结果**：系统处于安全状态。
</code></pre>
<ul>
<li><strong>死锁预防、避免、检测对比</strong></li>
</ul>
<table>
<thead>
<tr>
<th><strong>方法</strong></th>
<th><strong>主要特点</strong></th>
<th><strong>优点</strong></th>
<th><strong>缺点</strong></th>
</tr>
</thead>
<tbody><tr>
<td><strong>死锁预防</strong></td>
<td>破坏死锁必要条件，防止死锁发生</td>
<td>实现简单，避免死锁</td>
<td>资源利用率低，效率可能降低</td>
</tr>
<tr>
<td><strong>死锁避免</strong></td>
<td>动态检测状态，避免进入死锁状态</td>
<td>灵活，资源利用率较高</td>
<td>算法复杂，系统开销大</td>
</tr>
<tr>
<td><strong>死锁检测与恢复</strong></td>
<td>允许死锁发生，周期性检测并恢复</td>
<td>提高资源利用率，适合批处理系统</td>
<td>检测开销大，可能丢失计算或数据</td>
</tr>
</tbody></table>
<h3 id="1-2-内存管理"><a href="#1-2-内存管理" class="headerlink" title="1.2 内存管理"></a>1.2 内存管理</h3><h4 id="问：说一下操作系统的内存管理机制？"><a href="#问：说一下操作系统的内存管理机制？" class="headerlink" title="问：说一下操作系统的内存管理机制？"></a>问：说一下操作系统的内存管理机制？</h4><p>内存管理机制包括：内存分配、地址映射、内存保护与共享、虚拟内存等。</p>
<p>操作系统的内存管理机制负责高效地分配、使用和回收计算机内存，为程序提供稳定的运行环境，同时避免内存冲突和资源浪费。</p>
<ol>
<li><p>内存管理的目标</p>
<ul>
<li><strong>分配内存</strong>：确保每个进程都能获得所需的内存资源。</li>
<li><strong>保护内存</strong>：防止进程互相访问彼此的内存空间。</li>
<li><strong>高效利用</strong>：最大化内存利用率，减少内存碎片。</li>
<li><strong>地址空间管理</strong>：为每个进程提供独立的逻辑地址空间。</li>
</ul>
</li>
<li><p>内存管理的主要功能</p>
<ul>
<li><strong>地址映射</strong>：<ul>
<li>将逻辑地址转换为物理地址。</li>
<li>实现方式：<strong>重定位寄存器</strong> 或 <strong>页表</strong>。</li>
</ul>
</li>
<li><strong>内存分配</strong>：<ul>
<li>静态分配：在程序运行前分配固定大小的内存。</li>
<li>动态分配：在程序运行时根据需求动态分配内存。</li>
</ul>
</li>
<li><strong>内存保护</strong>：使用基址寄存器（Base Register）和界限寄存器（Limit Register）防止越界访问。</li>
<li><strong>内存回收</strong>：回收已终止进程占用的内存，供其他进程使用。</li>
</ul>
</li>
<li><p>内存管理的关键机制</p>
<p><strong>(1) 分段（Segmentation）</strong></p>
<ul>
<li><p>概念：将程序的内存分为逻辑段（如代码段、数据段、栈段）。</p>
</li>
<li><p>优点：</p>
<ul>
<li>更符合程序逻辑结构。</li>
<li>提供更灵活的访问控制。</li>
</ul>
</li>
<li><p>缺点：会产生<strong>外部碎片</strong>。</p>
</li>
</ul>
</li>
</ol>
<p>   <strong>(2) 分页（Paging）</strong></p>
<ul>
<li><p>概念：</p>
<ul>
<li>将内存分为固定大小的块（称为页），逻辑地址分为页号和页内偏移量。</li>
<li>页表（Page Table）负责映射逻辑地址到物理地址。</li>
</ul>
</li>
<li><p>优点：</p>
<ul>
<li>避免外部碎片。</li>
<li>更容易管理内存。</li>
</ul>
</li>
<li><p>缺点：页表可能占用大量内存（可使用多级页表或反向页表优化）。</p>
</li>
</ul>
<p>   <strong>(3) 分段与分页结合</strong></p>
<ul>
<li><p>概念：将分段和分页结合使用，段进一步划分为固定大小的页。</p>
</li>
<li><p>优点：结合两者优点，既支持逻辑结构，又能避免碎片问题。</p>
</li>
</ul>
<ol start="4">
<li><p>内存管理的高级机制</p>
<p><strong>(1) 虚拟内存（Virtual Memory）</strong></p>
<ul>
<li><strong>概念</strong>：<ul>
<li>提供比物理内存更大的逻辑地址空间。</li>
<li>使用磁盘作为扩展内存。</li>
</ul>
</li>
<li><strong>主要技术</strong>：<ol>
<li><strong>请求分页</strong>：仅在需要时将页面加载到内存中。</li>
<li><strong>页面置换算法</strong>：决定哪些页面被换出内存（如 FIFO、LRU、LFU）。</li>
<li><strong>缺页中断</strong>：当访问未加载的页面时触发中断，操作系统加载页面。</li>
</ol>
</li>
<li><strong>优点</strong>：<ul>
<li>提供独立的地址空间，支持更多并发进程。</li>
<li>提高内存利用率。</li>
</ul>
</li>
<li><strong>缺点</strong>：磁盘 I/O 速度远慢于内存，频繁换页会导致性能下降（<strong>抖动现象</strong>）。</li>
</ul>
<p><strong>(2) 缓存机制</strong></p>
<ul>
<li><p>概念：</p>
<ul>
<li>利用缓存（如 CPU 缓存、磁盘缓存）减少内存和外部存储之间的访问时间差。</li>
<li>缓存管理策略：LRU（最近最少使用）、MRU（最近最多使用）。</li>
</ul>
</li>
</ul>
<p><strong>(3) 内存映射文件</strong></p>
<ul>
<li><p>概念：</p>
<ul>
<li>将文件的内容映射到内存地址中，方便访问和修改。</li>
<li>应用：内存数据库、共享内存。</li>
</ul>
</li>
</ul>
</li>
<li><p>内存分配策略</p>
<ul>
<li><strong>连续分配</strong>：<ul>
<li><strong>首次适配（First Fit）</strong>：从头开始寻找第一个能容纳进程的空闲块。</li>
<li><strong>最佳适配（Best Fit）</strong>：选择能刚好容纳进程的最小空闲块。</li>
<li><strong>最差适配（Worst Fit）</strong>：选择最大的空闲块。</li>
</ul>
</li>
<li><strong>非连续分配</strong>：<ul>
<li>使用分页或分段机制，允许进程分散在内存的多个区域中。</li>
</ul>
</li>
</ul>
</li>
<li><p>内存碎片问题</p>
<ol>
<li><strong>外部碎片</strong>：<ul>
<li>内存中存在大量零散的小空闲块，无法容纳大进程。</li>
<li>解决方案：分页、分段与分页结合。</li>
</ul>
</li>
<li><strong>内部碎片</strong>：<ul>
<li>分配的内存块比实际需要的内存大，导致多余的部分浪费。</li>
<li>解决方案：适当调整页面大小。</li>
</ul>
</li>
</ol>
</li>
<li><p>面试重点总结</p>
<ul>
<li><strong>基本概念</strong>：<ul>
<li>分段、分页和虚拟内存的区别和应用场景。</li>
<li>分页避免外部碎片，而分段更符合逻辑结构。</li>
</ul>
</li>
<li><strong>虚拟内存</strong>：<ul>
<li>如何处理缺页中断。</li>
<li>常用的页面置换算法（如 LRU）。</li>
</ul>
</li>
<li><strong>内存保护</strong>：<ul>
<li>如何防止进程间的地址冲突。</li>
</ul>
</li>
<li><strong>实际应用</strong>：<ul>
<li>操作系统如何管理共享内存。</li>
<li>分页机制对性能的影响。</li>
</ul>
</li>
</ul>
</li>
</ol>
<h4 id="问：虚拟内存？"><a href="#问：虚拟内存？" class="headerlink" title="问：虚拟内存？"></a>问：虚拟内存？</h4><p><strong>虚拟内存（Virtual Memory）</strong> 是操作系统的一种内存管理技术，通过将物理内存与磁盘结合，提供给每个进程一个<strong>连续的、逻辑上的内存地址空间</strong>，<strong>使得程序可以运行在比实际物理内存更大的地址空间中</strong>，让程序获得更多的可用内存。为了更好的管理内存，操作系统<strong>将内存抽象成地址空间</strong>。每个程序拥有自己的地址空间，这个地址空间被分割成多个块，<strong>每一块称为一页</strong>。这些页被映射到物理内存，但<strong>不需要映射到连续的物理内存，也不需要所有页都必须在物理内存中</strong>。当程序引用到不在物理内存中的页时，由硬件执行必要的映射，将缺失的部分装入物理内存并重新执行失败的指令。</p>
<p>从上面的描述中可以看出，虚拟内存<strong>允许程序不用将地址空间中的每一页都映射到物理内</strong>存，也就是说一个程序不需要全部调入内存就可以运行，这使得有限的内存运行大程序成为可能。例如有一台计算机可以产生 16 位地址，那么一个程序的地址空间范围是 0~64K。该计算机只有 32KB 的物理内存，虚拟内存技术允许该计算机运行一个 64K 大小的程序。</p>
<ol>
<li><p>虚拟内存的核心概念</p>
<ul>
<li><strong>逻辑地址与物理地址</strong>：<ul>
<li><strong>逻辑地址</strong>：进程看到的地址，是由编译器或程序生成的。</li>
<li><strong>物理地址</strong>：内存硬件中的实际地址。</li>
<li><strong>地址转换</strong>：通过 MMU（内存管理单元）将逻辑地址映射到物理地址。</li>
</ul>
</li>
<li><strong>按需加载</strong>（Demand Paging）：不需要一次性将整个程序加载到内存，只在需要时加载对应的页面。</li>
<li><strong>分页与分段支持</strong>：虚拟内存通常结合分页（Paging）和分段（Segmentation）技术。</li>
</ul>
</li>
<li><p>虚拟内存的优点</p>
<ul>
<li><strong>扩展内存空间</strong>：程序可以运行在比物理内存更大的虚拟地址空间中。</li>
<li><strong>多任务支持</strong>：每个进程都有独立的虚拟地址空间，避免相互干扰。</li>
<li><strong>提高内存利用率</strong>：仅加载实际使用的部分内存页面，未使用的部分保存在磁盘中。</li>
<li><strong>实现进程隔离</strong>：防止一个进程访问另一个进程的内存空间。</li>
</ul>
</li>
<li><p>虚拟内存的主要机制</p>
<p><strong>(1) 页表（Page Table）</strong></p>
<ul>
<li><p><strong>作用</strong>：存储逻辑页与物理页之间的映射关系。</p>
</li>
<li><p>结构：</p>
<ul>
<li>每个进程有自己的页表。</li>
<li>页表条目包含：<ul>
<li>页面号。</li>
<li>页面在物理内存中的帧号。</li>
<li>是否有效（页面是否在内存中）。</li>
<li>访问权限等。</li>
</ul>
</li>
</ul>
</li>
<li><p>优化方式：</p>
<ul>
<li><strong>多级页表</strong>：减少页表占用的内存空间。</li>
<li><strong>反向页表（Inverted Page Table）</strong>：使用全局页表减少内存占用。</li>
</ul>
</li>
</ul>
<p><strong>(2) 缺页中断（Page Fault）</strong></p>
<ul>
<li><p><strong>触发条件</strong>：进程访问的页面不在内存中。</p>
</li>
<li><p>处理过程：</p>
<ol>
<li>暂停进程。</li>
<li>操作系统查找页面对应的磁盘地址。</li>
<li>将页面加载到内存中。</li>
<li>更新页表。</li>
<li>恢复进程执行。</li>
</ol>
</li>
</ul>
<p><strong>(3) 页面置换算法</strong></p>
<ul>
<li><p><strong>目的</strong>：当内存不足时，选择一个页面替换出去，为新的页面腾出空间。</p>
</li>
<li><p>常见算法：</p>
<ul>
<li><strong>FIFO（先进先出）</strong>：优先置换最早加载的页面。</li>
<li><strong>LRU（最近最少使用）</strong>：优先置换最近最少访问的页面。</li>
<li><strong>LFU（最不常用）</strong>：优先置换访问次数最少的页面。</li>
<li><strong>CLOCK（时钟算法）</strong>：FIFO 的改进版，通过使用访问位来减少开销。</li>
</ul>
</li>
</ul>
<p><strong>(4) 虚拟内存分配策略</strong></p>
<ul>
<li><strong>静态分配</strong>：固定为进程分配一定数量的页面。</li>
<li><strong>动态分配</strong>：根据进程的需求动态调整页面分配。</li>
</ul>
</li>
<li><p><strong>虚拟内存的实现技术</strong></p>
<p><strong>(1) 分页（Paging）</strong></p>
<ul>
<li>将虚拟地址分为固定大小的页面（Page），内存分为相同大小的帧（Frame）。</li>
<li>页表记录页面与帧的映射。</li>
</ul>
<p><strong>(2) 分段（Segmentation）</strong></p>
<ul>
<li>将虚拟地址按逻辑划分为多个段（如代码段、数据段、堆栈段）。</li>
<li>每个段可以有不同的大小和权限。</li>
</ul>
<p><strong>(3) 分段与分页结合</strong></p>
<ul>
<li>先将虚拟地址分为段，再对每段进行分页，兼顾逻辑性和避免外部碎片。</li>
</ul>
</li>
<li><p>虚拟内存的性能问题</p>
<ol>
<li><strong>缺页率</strong>：<ul>
<li>频繁的缺页中断会导致性能下降，称为<strong>抖动（Thrashing）</strong>。</li>
<li>解决方法：<ul>
<li>增加物理内存。</li>
<li>调整页面大小。</li>
<li>使用更优的页面置换算法。</li>
</ul>
</li>
</ul>
</li>
<li><strong>磁盘 I/O 开销</strong>：虚拟内存频繁依赖磁盘访问会降低性能。</li>
</ol>
</li>
<li><p><strong>示例问题及回答建议</strong></p>
<p><strong>(1) 问题：虚拟内存是如何工作的？</strong></p>
<p><strong>回答要点</strong>：</p>
<ul>
<li>提到逻辑地址到物理地址的映射。</li>
<li>解释按需加载和缺页中断处理过程。</li>
<li>简要介绍分页或页面置换算法。</li>
</ul>
<p><strong>(2) 问题：虚拟内存和物理内存的区别？</strong></p>
<table>
<thead>
<tr>
<th><strong>虚拟内存</strong></th>
<th><strong>物理内存</strong></th>
</tr>
</thead>
<tbody><tr>
<td>是操作系统提供的抽象概念。</td>
<td>是实际的硬件资源。</td>
</tr>
<tr>
<td>可以比物理内存大，使用磁盘作为扩展。</td>
<td>有固定大小，受硬件限制。</td>
</tr>
<tr>
<td>通过地址映射机制转换到物理地址。</td>
<td>直接存储数据和指令。</td>
</tr>
</tbody></table>
<p><strong>(3) 问题：LRU 页面置换算法的实现原理？</strong></p>
<ul>
<li>通过记录页面最近使用的时间或访问顺序，选择最近最少使用的页面进行替换。</li>
<li>可使用链表、栈或硬件支持的访问位实现。</li>
</ul>
</li>
</ol>
<h4 id="问：分页系统地址映射？"><a href="#问：分页系统地址映射？" class="headerlink" title="问：分页系统地址映射？"></a>问：分页系统地址映射？</h4><p>面试重点：</p>
<ol>
<li><strong>基本概念</strong>：<ul>
<li>页号、页内偏移、页表、页框。</li>
</ul>
</li>
<li><strong>计算过程</strong>：<ul>
<li>如何根据虚拟地址和页表得到物理地址。</li>
</ul>
</li>
<li><strong>优化机制</strong>：<ul>
<li>多级页表的优点。</li>
<li>TLB 的作用和性能提升。</li>
</ul>
</li>
<li><strong>常见问题</strong>：<ul>
<li>缺页中断的处理流程。</li>
<li>页表大小的计算：根据虚拟地址位数、页大小和页表结构。</li>
</ul>
</li>
</ol>
<p><strong>内存管理单元（MMU）</strong>管理着地址空间和物理内存的转换，其中的页表（Page table）存储着页（程序地址空间）和页框（物理内存空间）的映射表。在分页系统中，虚拟地址（逻辑地址）通过页表（Page Table）映射到物理地址。这种机制让操作系统能够高效管理内存并支持虚拟内存。</p>
<ul>
<li><p><strong>分页系统的基本概念</strong></p>
<ol>
<li><strong>页面（Page）</strong>：虚拟地址空间被分为固定大小的块，称为页面（如 4KB 或 8KB）。</li>
<li><strong>页框（Frame）</strong>：物理内存同样被划分为与页面大小相同的块，称为页框。</li>
<li><strong>页表（Page Table）</strong>：每个进程都有一个页表，用来存储虚拟页面到物理页框的映射关系。</li>
</ol>
</li>
<li><p><strong>虚拟地址结构</strong></p>
<p>虚拟地址在分页系统中通常分为两部分：</p>
<ol>
<li><p><strong>页号（Page Number，P）：</strong>决定虚拟地址对应的页。</p>
</li>
<li><p><strong>页内偏移量（Page Offset，d）：</strong>决定页面内的具体地址。</p>
</li>
</ol>
<p>虚拟地址大小 = 页号位数 + 页内偏移量位数</p>
</li>
<li><p><strong>地址映射过程</strong></p>
<ol>
<li><strong>虚拟地址分解</strong>：<ul>
<li>操作系统将虚拟地址分解为：<ul>
<li>页号 PP</li>
<li>页内偏移 dd</li>
</ul>
</li>
</ul>
</li>
<li><strong>查找页表</strong>：<ul>
<li>根据页号 PP，在页表中找到对应的页表项（Page Table Entry，PTE）。</li>
<li>页表项包含页框号 FF 和其他信息（如有效位、权限位等）。</li>
</ul>
</li>
<li><strong>计算物理地址</strong>：<ul>
<li>将页框号 FF 与页内偏移 dd 组合，形成物理地址。</li>
</ul>
</li>
</ol>
<p><strong>公式</strong>：物理地址=(页框号×页大小)+页内偏移</p>
</li>
<li><p><strong>示例</strong></p>
<p>假设：</p>
<ul>
<li>虚拟地址为 16 位，页大小为 4KB（2^12 = 4096 字节）。</li>
<li>页号位数 = 4（16 位 - 12 位）。</li>
<li>页内偏移位数 = 12。</li>
</ul>
<p>虚拟地址：<strong>0x1234</strong></p>
<ul>
<li>页号 P=0x1</li>
<li>页内偏移 d=0x234</li>
</ul>
<p>页表：</p>
<ul>
<li>页号 0 映射到页框号 5。</li>
<li>页号 1 映射到页框号 3。</li>
</ul>
<p>物理地址计算： </p>
<ul>
<li>物理地址=(页框号×4KB)+页内偏移 </li>
<li>物理地址=(3×4096)+0x234 </li>
<li>物理地址=0xC234</li>
</ul>
</li>
<li><p><strong>多级页表</strong></p>
<p>对于大虚拟地址空间，单级页表可能过于庞大，无法高效存储。因此使用<strong>多级页表</strong>。</p>
<p><strong>机制</strong>：</p>
<ol>
<li>将页表进一步划分为多级结构：<ul>
<li>顶级页表（目录）。</li>
<li>中间页表（部分实现可有）。</li>
<li>叶级页表。</li>
</ul>
</li>
<li>虚拟地址分为多个字段：<ul>
<li>页目录索引。</li>
<li>页表索引。</li>
<li>页内偏移。</li>
</ul>
</li>
</ol>
<p><strong>优点</strong>：</p>
<ul>
<li>减少内存占用。</li>
<li>仅为需要的页表分配内存。</li>
</ul>
</li>
<li><p><strong>硬件支持</strong></p>
<p>分页地址映射通常依赖硬件支持的 <strong>MMU（内存管理单元）</strong>，它能快速完成逻辑地址到物理地址的转换。</p>
<p><strong>加速技术</strong>：</p>
<ol>
<li><p>TLB（Translation Lookaside Buffer）：</p>
<ul>
<li>页表缓存，用于存储最近使用的页表项。</li>
<li>避免频繁访问内存中的页表。</li>
</ul>
</li>
<li><p>硬件页表查找：许多现代处理器支持硬件级别的页表遍历。</p>
</li>
</ol>
</li>
</ul>
<h4 id="问：分页和分段的区别？"><a href="#问：分页和分段的区别？" class="headerlink" title="问：分页和分段的区别？"></a>问：分页和分段的区别？</h4><p>分页（Paging）和分段（Segmentation）是操作系统中两种不同的内存管理方式，它们在<strong>实现目的</strong>、<strong>管理单位</strong>和<strong>实现细节</strong>等方面都有显著区别。虚拟内存采用的是分页技术，也就是将地址空间划分成固定大小的页，每一页再与内存进行映射。</p>
<ul>
<li><p><strong>分页（Paging）</strong></p>
<p><strong>1.定义</strong></p>
<ul>
<li>分页是一种将<strong>进程的逻辑地址空间</strong>分割为<strong>固定大小</strong>的块（称为页，Page）的内存管理方式。主存被分割为与页大小相同的块（称为页框，Frame）。<ul>
<li><strong>页面（Page）</strong>：虚拟地址空间的固定大小单位。</li>
<li><strong>页框（Frame）</strong>：物理地址空间的固定大小单位，与页面大小相等。</li>
</ul>
</li>
<li>页和页框通过<strong>页表（Page Table）</strong>实现地址映射。</li>
</ul>
<p><strong>2. 特点</strong></p>
<ul>
<li><strong>固定大小</strong>：页的大小固定（如 4KB、8KB），由硬件或系统决定。</li>
<li><strong>解决外部碎片问题</strong>：由于页是固定大小，内存分配时不会产生外部碎片。</li>
<li><strong>地址连续性要求低</strong>：页可以存储在<strong>非连续的物理内存</strong>位置。</li>
<li><strong>需要页表</strong>：通过页表维护逻辑页号和物理页框的映射关系。</li>
</ul>
<p><strong>3. 地址结构</strong></p>
<ul>
<li>逻辑地址分为两部分：逻辑地址=(P,D)<ol>
<li><strong>页号（Page Number，P）</strong>：标识逻辑地址对应的页。</li>
<li><strong>页内偏移量（Page Offset，D）</strong>：标识逻辑地址在页内的位置。</li>
</ol>
</li>
<li>地址转换：通过页表将页号映射到物理页框。</li>
</ul>
<p><strong>优点</strong></p>
<ul>
<li>有效利用内存，减少<strong>内存碎片</strong>（只需分配所需的页数）。</li>
<li>支持虚拟内存，允许进程使用比物理内存更大的地址空间。</li>
</ul>
<p><strong>缺点</strong></p>
<ul>
<li><strong>内部碎片</strong>：页面可能无法完全填满页框。</li>
<li>需要硬件支持（如 MMU）进行地址转换。</li>
</ul>
</li>
<li><p><strong>分段（Segmentation）</strong></p>
<p><strong>1. 定义</strong></p>
<ul>
<li>分段是一种将<strong>进程的逻辑地址空间</strong>划分为具有逻辑意义的段（Segment）的内存管理方式。</li>
<li>每个段可以表示逻辑上程序的不同部分：<ul>
<li>代码段（Code Segment）。</li>
<li>数据段（Data Segment）。</li>
<li>堆栈段（Stack Segment）。</li>
</ul>
</li>
</ul>
<p><strong>2. 特点</strong></p>
<ul>
<li><strong>可变大小</strong>：段的大小由程序需求决定。</li>
<li><strong>逻辑划分</strong>：段是逻辑单元，具有明确的意义（如一个函数、数组等）。</li>
<li><strong>可能产生外部碎片</strong>：由于段的大小可变，内存分配后可能存在空闲空间无法利用。</li>
<li><strong>需要段表</strong>：通过<strong>段表（Segment Table）</strong>记录段号与段基址、段长度的映射关系。</li>
</ul>
<p><strong>3. 地址结构</strong></p>
<ul>
<li>逻辑地址分为两部分：逻辑地址=(S,D)<ol>
<li><strong>段号（Segment Number，S）</strong>：标识逻辑地址对应的段。</li>
<li><strong>段内偏移量（Segment Offset，D）</strong>：标识逻辑地址在段内的位置。</li>
</ol>
</li>
<li>地址转换：通过段表将段号映射到物理地址，检查偏移量是否超出段长度。</li>
</ul>
<p><strong>优点</strong></p>
<ul>
<li>更符合程序的逻辑结构，便于内存保护和共享。</li>
<li>灵活分配内存，无需固定的分割方式。</li>
</ul>
<p><strong>缺点</strong></p>
<ul>
<li><strong>外部碎片</strong>：由于段大小不固定，可能会出现大量小块未使用的物理内存。</li>
<li>地址计算较复杂。</li>
</ul>
</li>
<li><p><strong>分页与分段的对比</strong></p>
<ul>
<li>对程序员的透明性：分页透明，但是分段需要程序员显式划分每个段。</li>
<li>地址空间的维度：分页是一维地址空间，分段是二维的。</li>
<li>大小是否可以改变：页的大小不可变，段的大小可以动态改变。</li>
<li>出现的原因：分页主要用于实现虚拟内存，从而获得更大的地址空间；分段主要是为了使程序和数据可以被划分为逻辑上独立的地址空间并且有助于共享和保护。</li>
</ul>
</li>
</ul>
<table>
<thead>
<tr>
<th><strong>特性</strong></th>
<th><strong>分页（Paging）</strong></th>
<th><strong>分段（Segmentation）</strong></th>
</tr>
</thead>
<tbody><tr>
<td><strong>管理单位</strong></td>
<td>页（Page），大小固定</td>
<td>段（Segment），大小可变</td>
</tr>
<tr>
<td><strong>划分依据</strong></td>
<td>按<strong>固定大小</strong>划分</td>
<td>按<strong>逻辑功能</strong>划分</td>
</tr>
<tr>
<td><strong>地址空间</strong></td>
<td>一维地址空间；页号 + 页内偏移</td>
<td>多维地址空间，分为多个段；段号 + 段内偏移</td>
</tr>
<tr>
<td><strong>碎片问题</strong></td>
<td>解决内部碎片问题，但存在外部碎片问题</td>
<td>容易产生外部碎片，但无内部碎片问题</td>
</tr>
<tr>
<td><strong>地址映射方式</strong></td>
<td>使用<strong>页表</strong>将逻辑页号映射到物理页框</td>
<td>使用<strong>段表</strong>将段号映射到段基址，并检查段长度</td>
</tr>
<tr>
<td><strong>连续性要求</strong></td>
<td>页框存储在物理内存中可以<strong>不连续</strong></td>
<td>每个段必须<strong>连续分配</strong>物理内存</td>
</tr>
<tr>
<td><strong>效率</strong></td>
<td>地址映射效率高（使用固定大小页表）</td>
<td>地址映射需要额外检查段长度，效率相对较低</td>
</tr>
<tr>
<td><strong>硬件支持</strong></td>
<td>需要<strong>页表硬件</strong>支持</td>
<td>需要<strong>段表硬件</strong>支持</td>
</tr>
<tr>
<td><strong>适用场景</strong></td>
<td>适用于解决内存管理的低碎片需求</td>
<td>适用于程序逻辑划分需求</td>
</tr>
<tr>
<td><strong>保护和共享</strong></td>
<td>保护性差，每页权限一致</td>
<td>段粒度更大，保护和共享更灵活</td>
</tr>
<tr>
<td><strong>实现复杂度</strong></td>
<td>较低</td>
<td>较高</td>
</tr>
<tr>
<td><strong>示例</strong></td>
<td>分配逻辑页号给用户程序的内存空间</td>
<td>将代码段、数据段、堆栈段等独立划分为不同的段</td>
</tr>
</tbody></table>
<p><strong>分页和分段的结合：段页式存储管理</strong></p>
<p>在实际操作系统中，<strong>分页</strong>和<strong>分段</strong>可以结合使用，形成段页式存储管理：程序的地址空间划分成多个拥有独立地址空间的段，每个段上的地址空间划分成大小相同的页。这样既拥有分段系统的共享和保护，又拥有分页系统的虚拟内存功能。</p>
<ol>
<li>首先将进程划分为若干段（Segmentation）。</li>
<li>每个段再划分为若干固定大小的页（Paging）。</li>
<li>地址映射需要段表和页表联合完成：<ul>
<li><strong>段表</strong>：找到段的基址。</li>
<li><strong>页表</strong>：找到段内页的物理地址。</li>
</ul>
</li>
</ol>
<p><strong>优点</strong></p>
<ul>
<li>既支持逻辑划分（通过段表）又支持内存管理效率（通过页表）。</li>
<li>避免了分段中可能产生的外部碎片问题。</li>
</ul>
<p><strong>地址结构</strong></p>
<ul>
<li>虚拟地址 = 段号 + 页号 + 页内偏移</li>
<li>段号用于定位段表，页号用于定位页表，页内偏移定位具体物理内存。</li>
</ul>
<p><strong>问题？</strong></p>
<ol>
<li>分页和分段的核心区别是什么？<ul>
<li>分页是物理上的固定划分，分段是逻辑上的划分。</li>
</ul>
</li>
<li>分页和分段分别如何解决内存碎片问题？<ul>
<li>分页减少了外部碎片，但会产生内部碎片。</li>
<li>分段减少了内部碎片，但可能产生外部碎片。</li>
</ul>
</li>
<li>分页和分段的结合有哪些优点？<ul>
<li>高效内存利用和灵活内存管理的结合。</li>
</ul>
</li>
<li>页表和段表如何管理？<ul>
<li>页表存储页面映射关系，段表存储段的起始地址和长度。</li>
</ul>
</li>
</ol>
<h4 id="问：虚拟内存的缺页中断处理过程？"><a href="#问：虚拟内存的缺页中断处理过程？" class="headerlink" title="问：虚拟内存的缺页中断处理过程？"></a>问：虚拟内存的缺页中断处理过程？</h4><p>虚拟内存的缺页中断（Page Fault）是指<strong>当程序访问的虚拟地址未被映射到物理内存时</strong>，<strong>硬件和操作系统协同处理的一种异常情况</strong>。以下是缺页中断的详细处理过程：</p>
<ul>
<li><p><strong>缺页中断的触发条件</strong></p>
<ul>
<li>当程序执行时，访问某个虚拟地址。如果该虚拟地址的页面没有加载到物理内存中，MMU（内存管理单元）检测到该地址的页表项无效（缺页标志位未设置），会触发缺页中断。</li>
</ul>
</li>
<li><p><strong>缺页中断的处理流程</strong></p>
<p><strong>1. 硬件检测并触发缺页中断</strong></p>
<ul>
<li>硬件（MMU）检测到访问的页面不在物理内存中，产生一个缺页异常（Page Fault Exception）。</li>
<li>当前的CPU将控制权转交给操作系统内核中的缺页中断处理程序。</li>
</ul>
<p><strong>2. 保存CPU的上下文信息</strong></p>
<ul>
<li>操作系统中断处理程序会保存当前进程的上下文（如寄存器状态），以便稍后恢复程序的执行。</li>
<li>确保中断处理过程对程序透明。</li>
</ul>
<p><strong>3. 检查访问合法性</strong></p>
<ul>
<li>操作系统通过页表或其他数据结构，检查引发缺页中断的虚拟地址是否有效：<ul>
<li><strong>地址合法</strong>：进程有权访问该地址，继续后续处理。</li>
<li><strong>地址非法</strong>：进程试图访问未分配的虚拟地址，操作系统会向进程发送异常信号（如 <code>SIGSEGV</code>）或直接终止进程。</li>
</ul>
</li>
</ul>
<p><strong>4.确定页面所在位置</strong></p>
<p>如果虚拟地址合法，操作系统需要确定页面的数据是否在二级存储（如硬盘的交换分区）中：</p>
<ul>
<li>页面已存在于磁盘中：页面在交换分区或程序文件中，准备加载到物理内存。</li>
<li>页面不在磁盘中：页面需要初始化（如为堆栈或数据段分配新页面），分配一个新的空页面。</li>
</ul>
<p><strong>5.分配物理内存页面</strong></p>
<p>操作系统在物理内存中分配一个空闲的页框（Page Frame）用于加载页面：</p>
<ul>
<li><strong>内存不足</strong>：如果没有可用的物理内存页面，需要触发页面置换算法（如 LRU、FIFO）。<ul>
<li>替换掉一个不常用的页面（如未修改的页面直接丢弃，已修改的页面写回磁盘）。</li>
</ul>
</li>
<li><strong>内存充足</strong>：直接分配一个新的页框。</li>
</ul>
<p><strong>6.加载页面到物理内存</strong></p>
<ul>
<li>如果页面在磁盘中：操作系统从磁盘中读取页面数据，加载到刚分配的页框中。</li>
<li>如果页面需要初始化：分配的物理内存页框被清零或初始化为默认值。</li>
</ul>
<p><strong>7.更新页表</strong></p>
<p>页表项被更新，标记：</p>
<ul>
<li>页面已在物理内存中。</li>
<li>设置页面的物理地址（页框号）。</li>
<li>更新访问位、修改位、有效位等。</li>
</ul>
<p><strong>8.恢复进程执行</strong></p>
<ul>
<li>恢复之前保存的CPU上下文。</li>
<li>重新尝试访问引发缺页中断的虚拟地址。</li>
<li>由于页面已加载到物理内存，这次访问不会再引发缺页中断。</li>
</ul>
</li>
<li><p>缺页中断处理的流程图（概述）</p>
<ol>
<li>检测到缺页中断。</li>
<li>保存进程上下文。</li>
<li>检查地址合法性。</li>
<li>找到页面的存储位置。</li>
<li>分配或置换物理内存页框。</li>
<li>加载页面数据到内存。</li>
<li>更新页表。</li>
<li>恢复进程执行。</li>
</ol>
</li>
<li><p><strong>性能优化</strong></p>
<ul>
<li><strong>页面置换算法</strong>：选择合适的页面置换算法（如 LRU）降低缺页率。</li>
<li><strong>预取机制</strong>：根据程序访问的局部性，预先加载可能使用的页面。</li>
<li>减少磁盘IO：<ul>
<li>使用 SSD 提升磁盘读写速度。</li>
<li>利用缓存机制减少实际的磁盘访问次数。</li>
</ul>
</li>
</ul>
</li>
</ul>
<h4 id="问：页面置换算法如何选择？页面置换算法有哪些，介绍一下？"><a href="#问：页面置换算法如何选择？页面置换算法有哪些，介绍一下？" class="headerlink" title="问：页面置换算法如何选择？页面置换算法有哪些，介绍一下？"></a>问：页面置换算法如何选择？页面置换算法有哪些，介绍一下？</h4><p><strong>为什么需要页面置换算法？</strong></p>
<ul>
<li>在程序运行过程中，如果要访问的页面不在内存中，就发生<strong>缺页中断</strong>从而将该页调入内存中。此时如果<strong>内存已无空闲空间</strong>，系统必须从内存中调出一个页面到磁盘对换区中来腾出空间。</li>
<li>页面置换算法和缓存淘汰策略类似，可以将内存看成磁盘的缓存。在缓存系统中，缓存的大小有限，当有新的缓存到达时，需要淘汰一部分已经存在的缓存，这样才有空间存放新的缓存数据。</li>
</ul>
<p><strong>页面置换算法的目标</strong></p>
<ol>
<li><strong>减少缺页率（Page Fault Rate）</strong>：尽量减少内存中页面被替换的频率。使页面置换频率最低。</li>
<li><strong>提高系统性能</strong>：通过高效的算法减少页面置换的开销。</li>
<li><strong>适应系统环境</strong>：根据进程的内存访问模式选择合适的算法。</li>
</ol>
<p><strong>常见页面置换算法</strong></p>
<ol>
<li><p><strong>最优页面置换算法（Optimal Page Replacement, OPT）</strong></p>
<ul>
<li><p><strong>思想</strong>：替换<strong>未来最久不会被访问</strong>的页面，最长时间内不再被访问。</p>
</li>
<li><p>优点：理论上缺页率最低，作为衡量其他算法性能的基准。</p>
</li>
<li><p>缺点：实现困难，需提前知道页面访问序列（仅用于模拟或离线分析）。</p>
</li>
<li><p>举例：一个系统为某进程分配了三个物理块，并有如下页面引用序列：</p>
<figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="attribute">7</span>，<span class="number">0</span>，<span class="number">1</span>，<span class="number">2</span>，<span class="number">0</span>，<span class="number">3</span>，<span class="number">0</span>，<span class="number">4</span>，<span class="number">2</span>，<span class="number">3</span>，<span class="number">0</span>，<span class="number">3</span>，<span class="number">2</span>，<span class="number">1</span>，<span class="number">2</span>，<span class="number">0</span>，<span class="number">1</span>，<span class="number">7</span>，<span class="number">0</span>，<span class="number">1</span></span><br></pre></td></tr></table></figure>

<p>开始运行时，先将 7, 0, 1 三个页面装入内存。当进程要访问页面 2 时，产生缺页中断，会将页面 7 换出，因为页面 7 再次被访问的时间最长。</p>
</li>
</ul>
</li>
<li><p><strong>先进先出（FIFO, First-In-First-Out）</strong></p>
<ul>
<li><strong>思想</strong>：替换最早进入内存的页面。</li>
<li>优点：简单易实现，使用队列即可。</li>
<li>缺点：容易出现<strong>Belady 异常</strong>（增加页面数却导致缺页率增加）。该算法会将那些经常被访问的页面换出，导致缺页率升高。</li>
<li>适用场景：小规模内存，简单场景下的页面置换。</li>
</ul>
</li>
<li><p><strong>最近最久未使用（LRU, Least Recently Used）</strong></p>
<ul>
<li><strong>思想</strong>：替换<strong>最近最久未被使用</strong>的页面。虽然无法知道将来要使用的页面情况，但是可以知道过去使用页面的情况。</li>
<li>优点：缺页率低，性能接近最优算法。</li>
<li>缺点：<strong>实现复杂、硬件支持成本高</strong>，需要维护访问时间记录或使用链表/栈。为了实现 LRU，需要在内存中维护一个所有页面的链表。当一个页面被访问时，将这个页面移到链表表头。这样就能保证链表表尾的页面是最近最久未访问的。因为每次访问都需要更新链表，因此这种方式实现的 LRU 代价很高</li>
<li>适用场景：页面访问局部性强的应用。</li>
</ul>
</li>
<li><p><strong>最近未使用（NRU, Not Recently Used）</strong></p>
<ul>
<li><p><strong>思想</strong>：利用页面的访问位和修改位，优先替换“最近未被使用且未修改”的页面。每个页面都有两个状态位：R 与 M，当页面被访问时设置页面的 R=1，当页面被修改时设置 M=1。</p>
<p>使用硬件提供的位标志：</p>
<ol>
<li>访问位（Referenced Bit）：页面是否被访问。</li>
<li>修改位（Modified Bit）：页面是否被修改。</li>
</ol>
<p>其中 R 位会定时被清零。可以将页面分成以下四类：</p>
<ul>
<li>R=0，M=0</li>
<li>R=0，M=1</li>
<li>R=1，M=0</li>
<li>R=1，M=1</li>
</ul>
<p>当发生缺页中断时，NRU 算法随机地从类编号最小的非空类中挑选一个页面将它换出。</p>
<p>NRU 优先换出已经被修改的脏页面（R=0，M=1），而不是被频繁使用的干净页面（R=1，M=0）。</p>
</li>
<li><p>优点：适中复杂度，能较好地平衡效率和性能。</p>
</li>
<li><p>缺点：需要硬件支持访问位和修改位。</p>
</li>
<li><p>适用场景：硬件支持的虚拟内存环境。</p>
</li>
</ul>
</li>
<li><p><strong>第二次机会算法（Second-Chance）</strong></p>
<ul>
<li><strong>思想</strong>：基于FIFO，同时检查页面的访问位，访问位为1的页面获得第二次机会。FIFO 算法可能会把经常使用的页面置换出去，为了避免这一问题，对该算法做一个简单的修改：当页面被访问 (读或写) 时设置该页面的 R 位为 1。需要替换的时候，检查最老页面的 R 位。如果 R 位是 0，那么这个页面既老又没有被使用，可以立刻置换掉；如果是 1，就将 R 位清 0，并把该页面放到链表的尾端，修改它的装入时间使它就像刚装入的一样，然后继续从链表的头部开始搜索。优点：改进了FIFO，性能更优。</li>
<li>缺点：实现稍复杂，需要维护一个环形队列。</li>
<li>适用场景：缓存管理，硬件支持访问位的场景。</li>
</ul>
</li>
<li><p><strong>时钟算法（Clock Algorithm）</strong></p>
<ul>
<li><strong>思想</strong>：是第二次机会算法的优化版本，使用指针实现循环检查页面的访问位。第二次机会算法需要在链表中移动页面，降低了效率。时钟算法使用环形链表将页面连接起来，再使用一个指针指向最老的页面。使用一个指针指向“时钟”的当前位置。如果页面的访问位为 0，淘汰该页面；如果为 1，清除访问位并移动指针。</li>
<li>优点：高效，适合实际操作系统实现。</li>
<li>缺点：在访问位全为1时效果一般。</li>
<li>适用场景：操作系统中常用的实际算法。</li>
</ul>
</li>
<li><p><strong>最近未使用访问频率（LFU, Least Frequently Used）</strong></p>
<ul>
<li><strong>思想</strong>：替换访问频率最低的页面。记录每个页面的访问次数，选择访问次数最少的页面淘汰。</li>
<li>优点：适合访问模式稳定的场景。可以保留频繁使用的页面。</li>
<li>缺点：不适合访问模式变化快的场景，可能导致热点页面频繁替换。可能导致“历史遗留问题”（某些页面长期占用内存）。</li>
<li>适用场景：数据库缓存等场景。</li>
</ul>
</li>
<li><p><strong>最少修改页面置换（MFU, Most Frequently Used）</strong></p>
<ul>
<li><strong>思想</strong>：替换访问频率最高的页面，假设频繁使用的页面即将被淘汰。</li>
<li>优点：针对某些特殊模式，性能优于LFU。</li>
<li>缺点：一般适用性不强。</li>
</ul>
</li>
</ol>
<p><strong>算法性能对比</strong></p>
<table>
<thead>
<tr>
<th><strong>算法</strong></th>
<th><strong>优点</strong></th>
<th><strong>缺点</strong></th>
<th><strong>适用场景</strong></th>
</tr>
</thead>
<tbody><tr>
<td>FIFO</td>
<td>简单易实现</td>
<td>Belady 异常，性能差</td>
<td>资源受限的简单场景</td>
</tr>
<tr>
<td>LRU</td>
<td>性能接近最优</td>
<td>实现复杂，硬件支持要求高</td>
<td>高性能系统，硬件支持较好</td>
</tr>
<tr>
<td>OPT</td>
<td>理论最优性能</td>
<td>实际不可实现</td>
<td>理论分析和性能比较</td>
</tr>
<tr>
<td>NRU</td>
<td>性能较好，开销小</td>
<td>需硬件支持访问位和修改位</td>
<td>通用系统</td>
</tr>
<tr>
<td>CLOCK</td>
<td>实现简单，性能接近 LRU</td>
<td>不如 LRU 精确</td>
<td>性能需求较高但资源有限的系统</td>
</tr>
<tr>
<td>LFU</td>
<td>频繁使用的页面保留时间长</td>
<td>历史问题，计算复杂</td>
<td>特殊应用，访问频率较稳定时</td>
</tr>
<tr>
<td>RANDOM</td>
<td>实现简单</td>
<td>缺页率高</td>
<td>资源受限的特殊场景</td>
</tr>
</tbody></table>
<p><strong>如何选择页面置换算法？</strong></p>
<ol>
<li>系统支持的硬件功能<ul>
<li>如果硬件支持访问位和修改位：<strong>选择 LRU、NRU 或时钟算法</strong>。</li>
<li>如果硬件功能有限：<strong>选择 FIFO 或其改进版本（如第二次机会算法）</strong>。</li>
</ul>
</li>
<li>应用场景<ul>
<li>工作负载较轻：FIFO 简单高效。</li>
<li>工作负载局部性强：LRU 或其近似算法（如 CLOCK）。</li>
<li>实时系统或性能敏感场景：时钟算法因效率高而常用。</li>
<li>内存访问模式稳定：LFU 性能较好。</li>
<li>内存需求动态变化大：NRU 平衡性能和复杂度。</li>
</ul>
</li>
<li><strong>性能优先还是实现优先</strong><ul>
<li>性能优先：LRU 或最优页面置换算法（OPT，理论分析用）。</li>
<li>实现优先：FIFO 或时钟算法（较简单易实现）。</li>
</ul>
</li>
</ol>
<p><strong>总结与推荐</strong></p>
<ol>
<li><strong>理论参考</strong>：使用 <strong>最优算法（OPT）</strong> 测试并分析缺页率。</li>
<li>实际实现：<ul>
<li>如果硬件资源充足，优先考虑 <strong>LRU 或 CLOCK</strong>。在实际系统中，<strong>LRU</strong> 和 <strong>CLOCK</strong> 是最常用的页面置换算法。</li>
<li>如果硬件受限且需要简单实现，选择 <strong>FIFO 或第二次机会算法</strong>。</li>
</ul>
</li>
<li>应用场景：<ul>
<li>数据库缓存中使用 <strong>LFU</strong> 或其改进版本。</li>
<li>操作系统中的内存管理多采用 <strong>时钟算法</strong>。</li>
</ul>
</li>
</ol>
<p><strong>面试重点问题</strong></p>
<p><strong>(1) FIFO 和 LRU 的区别？</strong></p>
<ul>
<li><strong>FIFO</strong>：优先淘汰最早加载的页面。</li>
<li><strong>LRU</strong>：优先淘汰最近最少使用的页面，性能更优。</li>
</ul>
<p><strong>(2) 如何实现 LRU？</strong></p>
<ul>
<li><strong>计数器法</strong>：维护时间戳记录页面最近访问时间。</li>
<li><strong>栈法</strong>：使用链表或栈实现页面访问的排序。</li>
</ul>
<p><strong>(3) 时钟算法如何改进 FIFO？</strong></p>
<ul>
<li>引入访问位减少不必要的页面淘汰，避免淘汰仍然活跃的页面。</li>
</ul>
<h3 id="1-3-文件管理"><a href="#1-3-文件管理" class="headerlink" title="1.3 文件管理"></a>1.3 文件管理</h3><h3 id="1-4-设备管理"><a href="#1-4-设备管理" class="headerlink" title="1.4 设备管理"></a>1.4 设备管理</h3><h4 id="问：磁盘结构？"><a href="#问：磁盘结构？" class="headerlink" title="问：磁盘结构？"></a>问：磁盘结构？</h4><ul>
<li><p>结构</p>
<ol>
<li><strong>磁盘盘片（Platter）</strong>：每个磁盘包含一个或多个盘片，通常是金属或玻璃制成，并涂有磁性材料，用于存储数据。</li>
<li><strong>磁道（Track）</strong>：每个盘片表面划分为若干同心圆环，称为磁道。</li>
<li><strong>扇区（Sector）</strong>：每个磁道被进一步划分为多个扇形区域，称为扇区，是磁盘的<strong>最小存储单位</strong>（如 512 字节或 4 KB）。</li>
<li><strong>柱面（Cylinder）</strong>：不同盘片上相同半径的磁道集合称为柱面。</li>
<li><strong>磁头（Read/Write Head）</strong>：每个盘片有一个磁头，与盘面非常接近，能够将盘面上的磁场转换为电信号（读），或者将电信号转换为盘面的磁场（写），用于读取或写入数据。</li>
<li><strong>制动手臂（Actuator arm）</strong>：用于在磁道之间移动磁头；负责磁头移动、数据传输以及和操作系统的通信。</li>
<li><strong>旋转轴（Spindle）</strong>：磁盘的盘片通过旋转轴固定，并以一定速度旋转（如 7200 RPM）。</li>
</ol>
</li>
<li><p>磁盘寻址方式</p>
<p>磁盘通过<strong>CHS（Cylinder, Head, Sector）</strong>或<strong>逻辑块地址（LBA, Logical Block Addressing）</strong>进行寻址：</p>
<ul>
<li><strong>CHS</strong>：柱面号 + 磁头号 + 扇区号。</li>
<li><strong>LBA</strong>：将磁盘的扇区逻辑编号，简化寻址。</li>
</ul>
</li>
</ul>
<h4 id="问：磁盘调度算法？"><a href="#问：磁盘调度算法？" class="headerlink" title="问：磁盘调度算法？"></a>问：磁盘调度算法？</h4><p>读写一个磁盘块的时间的影响因素有：</p>
<ul>
<li>旋转时间（主轴转动盘面，使得磁头移动到适当的扇区上）</li>
<li>寻道时间（制动手臂移动，使得磁头移动到适当的磁道上）</li>
<li>实际的数据传输时间</li>
</ul>
<p>其中，<strong>寻道时间最长</strong>，因此磁盘调度的主要<strong>目标是使磁盘的平均寻道时间最短</strong>。</p>
<p>磁盘调度算法用于优化磁头移动的顺序，减少寻道时间，提高磁盘访问效率。</p>
<ol>
<li><p><strong>先来先服务（FCFS, First-Come, First-Served）</strong></p>
<p><strong>思想</strong>：</p>
<ul>
<li>按磁盘请求到达的顺序依次服务。</li>
</ul>
<p><strong>优点</strong>：</p>
<ul>
<li>简单易实现、公平。</li>
</ul>
<p><strong>缺点</strong>：</p>
<ul>
<li>未对寻道做任何优化，使平均寻道时间可能较长。可能导致磁头频繁跳动，增加寻道时间。</li>
</ul>
</li>
<li><p><strong>最短寻道时间优先（SSTF, Shortest Seek Time First）</strong></p>
<p><strong>思想</strong>：</p>
<ul>
<li>优先服务离磁头所在磁道距离最近的请求。</li>
</ul>
<p><strong>优点</strong>：</p>
<ul>
<li>减少总寻道时间。虽然平均寻道时间比较低，但是不够公平。</li>
</ul>
<p><strong>缺点</strong>：</p>
<ul>
<li><strong>饥饿问题</strong>：距离远的请求可能长期得不到服务。如果新到达的磁道请求总是比一个在等待的磁道请求近，那么在等待的磁道请求会一直等待下去，也就是出现饥饿现象。具体来说，两端的磁道请求更容易出现饥饿现象。</li>
</ul>
</li>
<li><p><strong>电梯算法（SCAN）</strong></p>
<p><strong>思想</strong>：</p>
<ul>
<li>电梯总是保持一个方向运行，直到该方向没有请求为止，然后改变运行方向。和电梯的运行过程类似，磁头按一个方向移动，直到到达最远端，再反向移动，服务沿途的请求。</li>
<li>类似于电梯运行。</li>
</ul>
<p><strong>优点</strong>：</p>
<ul>
<li>减少饥饿问题，较均衡。因为考虑了移动方向，因此所有的磁盘请求都会被满足，解决了 SSTF 的饥饿问题。</li>
</ul>
<p><strong>缺点</strong>：</p>
<ul>
<li>每次换向可能导致等待时间增加。</li>
</ul>
</li>
<li><p><strong>循环扫描算法（C-SCAN, Circular SCAN）</strong></p>
<p><strong>思想</strong>：</p>
<ul>
<li>磁头始终向一个方向移动，服务沿途的请求，到达最远端后快速返回起始端（不服务沿途请求）。</li>
</ul>
<p><strong>优点</strong>：</p>
<ul>
<li>为所有请求提供公平的响应时间。</li>
<li>均衡服务，减少饥饿问题。</li>
</ul>
</li>
<li><p>LOOK 和 C-LOOK</p>
<p><strong>LOOK 和 SCAN 的改进</strong>：</p>
<ul>
<li><p>LOOK：</p>
<ul>
<li>磁头只移动到有请求的最远位置，然后反向移动。</li>
</ul>
</li>
<li><p>C-LOOK：</p>
<ul>
<li>磁头只服务有请求的最远位置后快速返回起始端。</li>
</ul>
</li>
</ul>
<p><strong>优点</strong>：</p>
<ul>
<li>减少不必要的磁头移动。</li>
</ul>
</li>
<li><p>EDF（Earliest Deadline First）</p>
<p><strong>思想</strong>：</p>
<ul>
<li>按照请求的截止时间优先级排序，优先处理最紧急的任务。</li>
</ul>
<p><strong>优点</strong>：</p>
<ul>
<li>适用于实时系统。</li>
</ul>
<p><strong>缺点</strong>：</p>
<ul>
<li>需要额外的时间和资源管理。</li>
</ul>
</li>
<li><p><strong>算法性能对比</strong></p>
</li>
</ol>
<table>
<thead>
<tr>
<th><strong>算法</strong></th>
<th><strong>优点</strong></th>
<th><strong>缺点</strong></th>
<th><strong>适用场景</strong></th>
</tr>
</thead>
<tbody><tr>
<td><strong>FCFS</strong></td>
<td>简单易实现</td>
<td>寻道时间可能较长</td>
<td>请求数量少，顺序性强的场景</td>
</tr>
<tr>
<td><strong>SSTF</strong></td>
<td>总寻道时间短</td>
<td>饥饿问题</td>
<td>磁盘负载较轻</td>
</tr>
<tr>
<td><strong>SCAN</strong></td>
<td>减少饥饿问题，较均衡</td>
<td>换向时增加等待时间</td>
<td>请求负载中等，响应时间要求较低</td>
</tr>
<tr>
<td><strong>C-SCAN</strong></td>
<td>公平性更高，响应时间更均匀</td>
<td>不服务回程请求，增加寻道距离</td>
<td>请求较多，需要公平响应的场景</td>
</tr>
<tr>
<td><strong>LOOK</strong></td>
<td>减少磁头的无效移动</td>
<td>换向等待时间增加</td>
<td>改进 SCAN 场景</td>
</tr>
<tr>
<td><strong>C-LOOK</strong></td>
<td>减少无效移动，公平性较好</td>
<td>实现复杂性稍高</td>
<td>改进 C-SCAN 场景</td>
</tr>
<tr>
<td><strong>EDF</strong></td>
<td>优先处理紧急任务</td>
<td>需额外管理任务优先级</td>
<td>实时系统</td>
</tr>
</tbody></table>
<p><strong>面试中的关键点</strong></p>
<ol>
<li><strong>如何选择调度算法？</strong><ul>
<li>根据任务特性：<ul>
<li>实时性：EDF。</li>
<li>公平性：C-SCAN、C-LOOK。</li>
<li>性能：SSTF、LOOK。</li>
</ul>
</li>
</ul>
</li>
<li><strong>SCAN 和 C-SCAN 的区别？</strong><ul>
<li>SCAN：磁头来回移动。</li>
<li>C-SCAN：磁头始终一个方向移动，公平性更高。</li>
</ul>
</li>
<li><strong>LOOK 系列的优势？</strong><ul>
<li>减少无效的磁头移动，性能更优。</li>
</ul>
</li>
<li><strong>实际中如何优化磁盘调度？</strong><ul>
<li>结合多种算法。</li>
<li>考虑缓存（如磁盘缓存）和硬件支持（如 SSD）。</li>
</ul>
</li>
</ol>
<hr>
<h2 id="三-系统调用"><a href="#三-系统调用" class="headerlink" title="三. 系统调用"></a>三. 系统调用</h2><h4 id="问：讲讲Linux你知道的系统调用？"><a href="#问：讲讲Linux你知道的系统调用？" class="headerlink" title="问：讲讲Linux你知道的系统调用？"></a>问：讲讲Linux你知道的系统调用？</h4><p>在 Linux 操作系统中，<strong>系统调用（System Call）</strong>是用户程序与内核进行交互的接口，用于完成底层资源管理和硬件操作。系统调用是 Linux 内核的重要组成部分，用户态程序通过它们向内核请求服务。</p>
<p>以下是一些常见的 Linux 系统调用，根据其功能分类介绍：</p>
<ol>
<li><p>文件操作</p>
<p>这些系统调用用于文件的创建、读取、写入和管理。</p>
<p>设备操作：ioctl(); read(); write();</p>
<table>
<thead>
<tr>
<th><strong>系统调用</strong></th>
<th><strong>功能</strong></th>
<th><strong>示例</strong></th>
</tr>
</thead>
<tbody><tr>
<td><code>open</code></td>
<td>打开文件或创建新文件</td>
<td><code>fd = open(&quot;file.txt&quot;, O_RDONLY);</code></td>
</tr>
<tr>
<td><code>close</code></td>
<td>关闭文件描述符</td>
<td><code>close(fd);</code></td>
</tr>
<tr>
<td><code>read</code></td>
<td>从文件中读取数据</td>
<td><code>read(fd, buf, count);</code></td>
</tr>
<tr>
<td><code>write</code></td>
<td>向文件中写入数据</td>
<td><code>write(fd, buf, count);</code></td>
</tr>
<tr>
<td><code>lseek</code></td>
<td>移动文件指针</td>
<td><code>lseek(fd, offset, SEEK_SET);</code></td>
</tr>
<tr>
<td><code>stat</code></td>
<td>获取文件元数据</td>
<td><code>stat(&quot;file.txt&quot;, &amp;statbuf);</code></td>
</tr>
<tr>
<td><code>mkdir</code></td>
<td>创建目录</td>
<td><code>mkdir(&quot;newdir&quot;, 0755);</code></td>
</tr>
<tr>
<td><code>unlink</code></td>
<td>删除文件</td>
<td><code>unlink(&quot;file.txt&quot;);</code></td>
</tr>
<tr>
<td><code>rename</code></td>
<td>重命名文件</td>
<td><code>rename(&quot;old.txt&quot;, &quot;new.txt&quot;);</code></td>
</tr>
<tr>
<td><code>fsync</code></td>
<td>将文件的缓冲区内容同步到磁盘</td>
<td><code>fsync(fd);</code></td>
</tr>
</tbody></table>
</li>
<li><p>进程控制</p>
<p>这些系统调用用于创建、管理和终止进程。</p>
<p>进程通信：pipe(); shmget(); mmap();</p>
<table>
<thead>
<tr>
<th><strong>系统调用</strong></th>
<th><strong>功能</strong></th>
<th><strong>示例</strong></th>
</tr>
</thead>
<tbody><tr>
<td><code>fork</code></td>
<td>创建子进程</td>
<td><code>pid = fork();</code></td>
</tr>
<tr>
<td><code>exec</code></td>
<td>执行新程序，替换当前进程</td>
<td><code>execl(&quot;/bin/ls&quot;, &quot;ls&quot;, NULL);</code></td>
</tr>
<tr>
<td><code>exit</code></td>
<td>终止当前进程</td>
<td><code>exit(0);</code></td>
</tr>
<tr>
<td><code>wait</code></td>
<td>等待子进程退出</td>
<td><code>wait(&amp;status);</code></td>
</tr>
<tr>
<td><code>getpid</code></td>
<td>获取当前进程 ID</td>
<td><code>pid = getpid();</code></td>
</tr>
<tr>
<td><code>getppid</code></td>
<td>获取父进程 ID</td>
<td><code>ppid = getppid();</code></td>
</tr>
<tr>
<td><code>kill</code></td>
<td>向进程发送信号</td>
<td><code>kill(pid, SIGKILL);</code></td>
</tr>
<tr>
<td><code>nice</code></td>
<td>设置进程优先级</td>
<td><code>nice(-5);</code></td>
</tr>
</tbody></table>
</li>
<li><p>内存管理相关系统调用</p>
<p>这些系统调用用于分配和管理内存。</p>
<table>
<thead>
<tr>
<th><strong>系统调用</strong></th>
<th><strong>功能</strong></th>
<th><strong>示例</strong></th>
</tr>
</thead>
<tbody><tr>
<td><code>brk</code></td>
<td>修改进程的堆边界</td>
<td><code>brk(new_brk);</code></td>
</tr>
<tr>
<td><code>mmap</code></td>
<td>将文件或设备映射到内存</td>
<td><code>mmap(addr, len, prot, flags, fd, 0);</code></td>
</tr>
<tr>
<td><code>munmap</code></td>
<td>解除内存映射</td>
<td><code>munmap(addr, len);</code></td>
</tr>
<tr>
<td><code>mprotect</code></td>
<td>修改内存区域的保护属性</td>
<td><code>mprotect(addr, len, PROT_READ);</code></td>
</tr>
<tr>
<td><code>shmget</code></td>
<td>获取共享内存标识符</td>
<td><code>shmget(key, size, IPC_CREAT);</code></td>
</tr>
<tr>
<td><code>shmat</code></td>
<td>将共享内存段附加到进程的地址空间</td>
<td><code>shmat(shmid, NULL, 0);</code></td>
</tr>
</tbody></table>
</li>
<li><p>网络相关系统调用</p>
<p>这些系统调用用于套接字操作和网络通信。</p>
<table>
<thead>
<tr>
<th><strong>系统调用</strong></th>
<th><strong>功能</strong></th>
<th><strong>示例</strong></th>
</tr>
</thead>
<tbody><tr>
<td><code>socket</code></td>
<td>创建套接字</td>
<td><code>sockfd = socket(AF_INET, SOCK_STREAM, 0);</code></td>
</tr>
<tr>
<td><code>bind</code></td>
<td>绑定套接字到地址</td>
<td><code>bind(sockfd, &amp;addr, sizeof(addr));</code></td>
</tr>
<tr>
<td><code>listen</code></td>
<td>监听连接请求</td>
<td><code>listen(sockfd, backlog);</code></td>
</tr>
<tr>
<td><code>accept</code></td>
<td>接受连接请求</td>
<td><code>connfd = accept(sockfd, &amp;addr, &amp;len);</code></td>
</tr>
<tr>
<td><code>connect</code></td>
<td>发起连接请求</td>
<td><code>connect(sockfd, &amp;addr, sizeof(addr));</code></td>
</tr>
<tr>
<td><code>send</code></td>
<td>发送数据</td>
<td><code>send(sockfd, buf, len, flags);</code></td>
</tr>
<tr>
<td><code>recv</code></td>
<td>接收数据</td>
<td><code>recv(sockfd, buf, len, flags);</code></td>
</tr>
<tr>
<td><code>setsockopt</code></td>
<td>设置套接字选项</td>
<td><code>setsockopt(sockfd, level, optname, &amp;optval, len);</code></td>
</tr>
</tbody></table>
</li>
<li><p>时间管理相关系统调用</p>
<p>这些系统调用用于获取或设置系统时间。</p>
<p>信息维护：getpid(); alarm(); sleep();</p>
<table>
<thead>
<tr>
<th><strong>系统调用</strong></th>
<th><strong>功能</strong></th>
<th><strong>示例</strong></th>
</tr>
</thead>
<tbody><tr>
<td><code>time</code></td>
<td>获取当前时间（秒级）</td>
<td><code>time(&amp;t);</code></td>
</tr>
<tr>
<td><code>gettimeofday</code></td>
<td>获取当前时间（微秒级）</td>
<td><code>gettimeofday(&amp;tv, NULL);</code></td>
</tr>
<tr>
<td><code>clock_gettime</code></td>
<td>获取时钟时间</td>
<td><code>clock_gettime(CLOCK_REALTIME, &amp;ts);</code></td>
</tr>
<tr>
<td><code>alarm</code></td>
<td>设置闹钟，触发信号</td>
<td><code>alarm(seconds);</code></td>
</tr>
<tr>
<td><code>sleep</code></td>
<td>挂起进程一段时间</td>
<td><code>sleep(seconds);</code></td>
</tr>
</tbody></table>
</li>
<li><p>信号相关系统调用</p>
<p>这些系统调用用于处理进程间的异步信号。</p>
<table>
<thead>
<tr>
<th><strong>系统调用</strong></th>
<th><strong>功能</strong></th>
<th><strong>示例</strong></th>
</tr>
</thead>
<tbody><tr>
<td><code>signal</code></td>
<td>注册信号处理程序</td>
<td><code>signal(SIGINT, handler);</code></td>
</tr>
<tr>
<td><code>sigaction</code></td>
<td>更灵活地设置信号处理程序</td>
<td><code>sigaction(SIGTERM, &amp;act, NULL);</code></td>
</tr>
<tr>
<td><code>kill</code></td>
<td>向进程发送信号</td>
<td><code>kill(pid, SIGKILL);</code></td>
</tr>
<tr>
<td><code>pause</code></td>
<td>挂起进程，直到收到信号</td>
<td><code>pause();</code></td>
</tr>
</tbody></table>
</li>
<li><p>安全：chmod(); umask(); chown();</p>
</li>
<li><p>常见的高级系统调用</p>
<ul>
<li>**<code>ioctl</code>**：控制设备的 I/O 操作。</li>
<li>**<code>poll</code>/<code>select</code>**：监听多个文件描述符的事件。</li>
<li>**<code>epoll</code>**：高效处理多路 I/O 事件。</li>
<li>**<code>clone</code>**：创建轻量级进程或线程（常用于实现线程库）。</li>
<li>**<code>sysinfo</code>**：获取系统信息，如总内存、空闲内存等。</li>
</ul>
</li>
<li><p><strong>面试考点</strong></p>
<ul>
<li><p>系统调用和库函数的区别：系统调用直接与内核交互，而库函数是对系统调用的封装。</p>
</li>
<li><p>常用系统调用的调用流程：系统调用通过软中断（如 x86 的 <code>int 0x80</code> 或 <code>syscall</code> 指令）进入内核。</p>
</li>
<li><p>高频考察点：</p>
<ul>
<li>文件操作（<code>open</code>、<code>read</code>、<code>write</code>）。</li>
<li>进程管理（<code>fork</code>、<code>exec</code>、<code>wait</code>）。</li>
<li>网络通信（<code>socket</code>、<code>connect</code>、<code>bind</code>）。</li>
</ul>
</li>
<li><p>系统调用性能优化：</p>
<ul>
<li>使用批量操作（如 <code>readv</code> 和 <code>writev</code>）。</li>
<li>使用异步 I/O 减少阻塞。</li>
</ul>
</li>
</ul>
</li>
</ol>
<hr>
<h2 id="四-中断"><a href="#四-中断" class="headerlink" title="四. 中断"></a>四. 中断</h2><hr>
<h2 id="五-Linux"><a href="#五-Linux" class="headerlink" title="五. Linux"></a>五. Linux</h2><h3 id="5-1-基础操作"><a href="#5-1-基础操作" class="headerlink" title="5.1 基础操作"></a>5.1 基础操作</h3><h4 id="问：linux中有哪些常见的指令？"><a href="#问：linux中有哪些常见的指令？" class="headerlink" title="问：linux中有哪些常见的指令？"></a>问：linux中有哪些常见的指令？</h4><p><strong>1. 文件和目录操作</strong></p>
<table>
<thead>
<tr>
<th><strong>指令</strong></th>
<th><strong>功能</strong></th>
<th><strong>示例</strong></th>
</tr>
</thead>
<tbody><tr>
<td><code>ls</code></td>
<td>列出目录内容；列出文件或者目录的信息，目录的信息就是其中包含的文件。</td>
<td><code>ls -l</code></td>
</tr>
<tr>
<td><code>cd</code></td>
<td>切换目录</td>
<td><code>cd /home/user</code></td>
</tr>
<tr>
<td><code>pwd</code></td>
<td>显示当前工作目录</td>
<td><code>pwd</code></td>
</tr>
<tr>
<td><code>mkdir</code></td>
<td>创建目录</td>
<td><code>mkdir new_folder</code></td>
</tr>
<tr>
<td><code>rmdir</code></td>
<td>删除空目录</td>
<td><code>rmdir empty_folder</code></td>
</tr>
<tr>
<td><code>rm</code></td>
<td>删除文件或目录</td>
<td><code>rm -r folder</code></td>
</tr>
<tr>
<td><code>cp</code></td>
<td>复制文件或目录</td>
<td><code>cp source.txt dest.txt</code></td>
</tr>
<tr>
<td><code>mv</code></td>
<td>移动或重命名文件</td>
<td><code>mv oldname.txt newname.txt</code></td>
</tr>
<tr>
<td><code>touch</code></td>
<td>创建空文件</td>
<td><code>touch newfile.txt</code></td>
</tr>
<tr>
<td><code>find</code></td>
<td>查找文件</td>
<td><code>find / -name &quot;file.txt&quot;</code></td>
</tr>
<tr>
<td><code>locate</code></td>
<td>快速查找文件（需安装并更新数据库）</td>
<td><code>locate filename</code></td>
</tr>
<tr>
<td><code>stat</code></td>
<td>查看文件详细信息</td>
<td><code>stat file.txt</code></td>
</tr>
<tr>
<td><code>file</code></td>
<td>查看文件类型</td>
<td><code>file file.txt</code></td>
</tr>
<tr>
<td>cat</td>
<td>获取文件内容</td>
<td></td>
</tr>
</tbody></table>
<ul>
<li><p>grep：正则表达式</p>
<ul>
<li>```bash<br>$ grep [-acinv] [–color=auto] 搜寻字符串 filename<br>-c ： 统计匹配到行的个数<br>-i ： 忽略大小写<br>-n ： 输出行号<br>-v ： 反向选择，也就是显示出没有 搜寻字符串 内容的那一行<br>–color=auto ：找到的关键字加颜色显示<figure class="highlight sas"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">* ```bash</span></span><br><span class="line"><span class="comment">  $ grep -n &#x27;the&#x27; regular_express.txt</span></span><br><span class="line"><span class="comment">  8:I can&#x27;t finish the test.</span></span><br><span class="line"><span class="comment">  12:the symbol &#x27;*&#x27; is represented as start.</span></span><br><span class="line"><span class="comment">  15:You are the best is mean you are the no. 1.</span></span><br><span class="line"><span class="comment">  16:The world Happy is the same with &quot;glad&quot;.</span></span><br><span class="line"><span class="comment">  18:google is the best tools for search keyword</span></span><br></pre></td></tr></table></figure></li>
</ul>
</li>
<li><p>cut：对数据进行切分，取出想要的部分。</p>
<ul>
<li>```bash<br>$ cut<br>-d ：分隔符<br>-f ：经过 -d 分隔后，使用 -f n 取出第 n 个区间<br>-c ：以字符为单位取出区间<figure class="highlight gherkin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">  <span class="symbol">*</span> 切分过程一行一行地进行</span><br><span class="line"></span><br><span class="line"><span class="symbol">*</span><span class="symbol">*</span>2. 文件内容查看<span class="symbol">*</span><span class="symbol">*</span></span><br><span class="line"></span><br><span class="line">|<span class="string"> **指令** </span>|<span class="string"> **功能**                       </span>|<span class="string"> **示例**              </span>|</span><br><span class="line">|<span class="string"> -------- </span>|<span class="string"> ------------------------------ </span>|<span class="string"> --------------------- </span>|</span><br><span class="line">|<span class="string"> `cat`    </span>|<span class="string"> 查看文件内容                   </span>|<span class="string"> `cat file.txt`        </span>|</span><br><span class="line">|<span class="string"> `tac`    </span>|<span class="string"> 反向查看文件内容               </span>|<span class="string"> `tac file.txt`        </span>|</span><br><span class="line">|<span class="string"> `less`   </span>|<span class="string"> 分页查看文件                   </span>|<span class="string"> `less file.txt`       </span>|</span><br><span class="line">|<span class="string"> `more`   </span>|<span class="string"> 分页查看文件                   </span>|<span class="string"> `more file.txt`       </span>|</span><br><span class="line">|<span class="string"> `head`   </span>|<span class="string"> 查看文件的前几行               </span>|<span class="string"> `head -n 10 file.txt` </span>|</span><br><span class="line">|<span class="string"> `tail`   </span>|<span class="string"> 查看文件的后几行               </span>|<span class="string"> `tail -n 10 file.txt` </span>|</span><br><span class="line">|<span class="string"> `nl`     </span>|<span class="string"> 查看文件并显示行号             </span>|<span class="string"> `nl file.txt`         </span>|</span><br><span class="line">|<span class="string"> `wc`     </span>|<span class="string"> 统计文件的行数、单词数和字符数 </span>|<span class="string"> `wc -l file.txt`      </span>|</span><br><span class="line"></span><br><span class="line"><span class="symbol">*</span><span class="symbol">*</span>3. 权限管理<span class="symbol">*</span><span class="symbol">*</span></span><br><span class="line"></span><br><span class="line">|<span class="string"> **指令** </span>|<span class="string"> **功能**           </span>|<span class="string"> **示例**               </span>|</span><br><span class="line">|<span class="string"> -------- </span>|<span class="string"> ------------------ </span>|<span class="string"> ---------------------- </span>|</span><br><span class="line">|<span class="string"> `chmod`  </span>|<span class="string"> 修改文件或目录权限 </span>|<span class="string"> `chmod 755 file.txt`   </span>|</span><br><span class="line">|<span class="string"> `chown`  </span>|<span class="string"> 修改文件所有者     </span>|<span class="string"> `chown user file.txt`  </span>|</span><br><span class="line">|<span class="string"> `chgrp`  </span>|<span class="string"> 修改文件所属组     </span>|<span class="string"> `chgrp group file.txt` </span>|</span><br><span class="line">|<span class="string"> `umask`  </span>|<span class="string"> 设置默认权限掩码   </span>|<span class="string"> `umask 022`            </span>|</span><br><span class="line"></span><br><span class="line"><span class="symbol">*</span><span class="symbol">*</span>4. 压缩与解压<span class="symbol">*</span><span class="symbol">*</span></span><br><span class="line"></span><br><span class="line">|<span class="string"> **指令** </span>|<span class="string"> **功能**              </span>|<span class="string"> **示例**                       </span>|</span><br><span class="line">|<span class="string"> -------- </span>|<span class="string"> --------------------- </span>|<span class="string"> ------------------------------ </span>|</span><br><span class="line">|<span class="string"> `tar`    </span>|<span class="string"> 打包或解包            </span>|<span class="string"> `tar -cvf archive.tar folder/` </span>|</span><br><span class="line">|<span class="string"> `gzip`   </span>|<span class="string"> 压缩文件              </span>|<span class="string"> `gzip file.txt`                </span>|</span><br><span class="line">|<span class="string"> `gunzip` </span>|<span class="string"> 解压 `.gz` 文件       </span>|<span class="string"> `gunzip file.txt.gz`           </span>|</span><br><span class="line">|<span class="string"> `zip`    </span>|<span class="string"> 压缩为 `.zip` 文件    </span>|<span class="string"> `zip archive.zip file1 file2`  </span>|</span><br><span class="line">|<span class="string"> `unzip`  </span>|<span class="string"> 解压 `.zip` 文件      </span>|<span class="string"> `unzip archive.zip`            </span>|</span><br><span class="line">|<span class="string"> `xz`     </span>|<span class="string"> 压缩文件为 `.xz` 格式 </span>|<span class="string"> `xz file.txt`                  </span>|</span><br><span class="line">|<span class="string"> `unxz`   </span>|<span class="string"> 解压 `.xz` 文件       </span>|<span class="string"> `unxz file.txt.xz`             </span>|</span><br><span class="line"></span><br><span class="line"><span class="symbol">*</span><span class="symbol">*</span>5. 系统管理<span class="symbol">*</span><span class="symbol">*</span></span><br><span class="line"></span><br><span class="line">关机：</span><br><span class="line"></span><br><span class="line"><span class="symbol">*</span> who：先用 who 命令查看有没有其它用户在线。</span><br><span class="line"><span class="symbol">*</span> sync：为了加快对磁盘文件的读写速度，位于内存中的文件数据不会立即同步到磁盘，因此关机之前需要先进行 sync 同步操作。</span><br><span class="line"><span class="symbol">*</span> shutdown：`shutdown [-krhc] 时间 [信息]` 。</span><br><span class="line"></span><br><span class="line">|<span class="string"> **指令** </span>|<span class="string"> **功能**               </span>|<span class="string"> **示例**        </span>|</span><br><span class="line">|<span class="string"> -------- </span>|<span class="string"> ---------------------- </span>|<span class="string"> --------------- </span>|</span><br><span class="line">|<span class="string"> `df`     </span>|<span class="string"> 查看磁盘使用情况       </span>|<span class="string"> `df -h`         </span>|</span><br><span class="line">|<span class="string"> `du`     </span>|<span class="string"> 查看目录或文件大小     </span>|<span class="string"> `du -sh folder` </span>|</span><br><span class="line">|<span class="string"> `free`   </span>|<span class="string"> 查看内存使用情况       </span>|<span class="string"> `free -h`       </span>|</span><br><span class="line">|<span class="string"> `top`    </span>|<span class="string"> 实时查看系统进程       </span>|<span class="string"> `top`           </span>|</span><br><span class="line">|<span class="string"> `htop`   </span>|<span class="string"> 彩色增强版进程查看工具 </span>|<span class="string"> `htop`          </span>|</span><br><span class="line">|<span class="string"> `ps`     </span>|<span class="string"> 查看当前进程           </span>|<span class="string"> `ps aux`        </span>|</span><br><span class="line">|<span class="string"> `kill`   </span>|<span class="string"> 终止进程               </span>|<span class="string"> `kill -9 PID`   </span>|</span><br><span class="line">|<span class="string"> `uptime` </span>|<span class="string"> 查看系统运行时间       </span>|<span class="string"> `uptime`        </span>|</span><br><span class="line">|<span class="string"> `uname`  </span>|<span class="string"> 查看系统信息           </span>|<span class="string"> `uname -a`      </span>|</span><br><span class="line">|<span class="string"> `who`    </span>|<span class="string"> 查看当前登录用户       </span>|<span class="string"> `who`           </span>|</span><br><span class="line">|<span class="string"> `whoami` </span>|<span class="string"> 查看当前用户身份       </span>|<span class="string"> `whoami`        </span>|</span><br><span class="line"></span><br><span class="line"><span class="symbol">*</span><span class="symbol">*</span>6. 网络相关<span class="symbol">*</span><span class="symbol">*</span></span><br><span class="line"></span><br><span class="line">|<span class="string"> **指令**   </span>|<span class="string"> **功能**                       </span>|<span class="string"> **示例**                            </span>|</span><br><span class="line">|<span class="string"> ---------- </span>|<span class="string"> ------------------------------ </span>|<span class="string"> ----------------------------------- </span>|</span><br><span class="line">|<span class="string"> `ping`     </span>|<span class="string"> 测试网络连通性                 </span>|<span class="string"> `ping www.google.com`               </span>|</span><br><span class="line">|<span class="string"> `ifconfig` </span>|<span class="string"> 查看或配置网络接口（旧版工具） </span>|<span class="string"> `ifconfig`                          </span>|</span><br><span class="line">|<span class="string"> `ip`       </span>|<span class="string"> 查看或配置网络接口（推荐工具） </span>|<span class="string"> `ip addr`                           </span>|</span><br><span class="line">|<span class="string"> `netstat`  </span>|<span class="string"> 查看网络连接和端口使用情况     </span>|<span class="string"> `netstat -tuln`                     </span>|</span><br><span class="line">|<span class="string"> `ss`       </span>|<span class="string"> 替代 `netstat` 的现代网络工具  </span>|<span class="string"> `ss -tuln`                          </span>|</span><br><span class="line">|<span class="string"> `curl`     </span>|<span class="string"> 下载或发送网络请求             </span>|<span class="string"> `curl https://example.com`          </span>|</span><br><span class="line">|<span class="string"> `wget`     </span>|<span class="string"> 下载文件                       </span>|<span class="string"> `wget https://example.com/file.zip` </span>|</span><br><span class="line">|<span class="string"> `scp`      </span>|<span class="string"> 通过 SSH 传输文件              </span>|<span class="string"> `scp file.txt user@host:/path/`     </span>|</span><br><span class="line">|<span class="string"> `ssh`      </span>|<span class="string"> 远程登录                       </span>|<span class="string"> `ssh user@host`                     </span>|</span><br><span class="line"></span><br><span class="line"><span class="symbol">*</span><span class="symbol">*</span>7. 用户管理<span class="symbol">*</span><span class="symbol">*</span></span><br><span class="line"></span><br><span class="line">|<span class="string"> **指令**  </span>|<span class="string"> **功能**                                                     </span>|<span class="string"> **示例**           </span>|</span><br><span class="line">|<span class="string"> --------- </span>|<span class="string"> ------------------------------------------------------------ </span>|<span class="string"> ------------------ </span>|</span><br><span class="line">|<span class="string"> `adduser` </span>|<span class="string"> 添加用户                                                     </span>|<span class="string"> `adduser username` </span>|</span><br><span class="line">|<span class="string"> `deluser` </span>|<span class="string"> 删除用户                                                     </span>|<span class="string"> `deluser username` </span>|</span><br><span class="line">|<span class="string"> `passwd`  </span>|<span class="string"> 修改用户密码                                                 </span>|<span class="string"> `passwd username`  </span>|</span><br><span class="line">|<span class="string"> `su`      </span>|<span class="string"> 切换用户                                                     </span>|<span class="string"> `su username`      </span>|</span><br><span class="line">|<span class="string"> `sudo`    </span>|<span class="string"> 提升权限执行命令，允许一般用户使用 root 可执行的命令，不过只有在 /etc/sudoers 配置文件中添加的用户才能使用该指令 </span>|<span class="string"> `sudo apt update`  </span>|</span><br><span class="line">|<span class="string"> `id`      </span>|<span class="string"> 查看用户 ID 和组 ID                                          </span>|<span class="string"> `id username`      </span>|</span><br><span class="line"></span><br><span class="line"><span class="symbol">*</span><span class="symbol">*</span>8. 日志管理<span class="symbol">*</span><span class="symbol">*</span></span><br><span class="line"></span><br><span class="line">|<span class="string"> **指令**     </span>|<span class="string"> **功能**     </span>|<span class="string"> **示例**                  </span>|</span><br><span class="line">|<span class="string"> ------------ </span>|<span class="string"> ------------ </span>|<span class="string"> ------------------------- </span>|</span><br><span class="line">|<span class="string"> `dmesg`      </span>|<span class="string"> 查看内核日志 </span>|<span class="string"> `dmesg                    </span>|</span><br><span class="line">|<span class="string"> `journalctl` </span>|<span class="string"> 查看系统日志 </span>|<span class="string"> `journalctl -xe`          </span>|</span><br><span class="line">|<span class="string"> `tail`       </span>|<span class="string"> 实时查看日志 </span>|<span class="string"> `tail -f /var/log/syslog` </span>|</span><br><span class="line"></span><br><span class="line"><span class="symbol">*</span><span class="symbol">*</span>9. 权限与SELinux<span class="symbol">*</span><span class="symbol">*</span></span><br><span class="line"></span><br><span class="line">|<span class="string"> **指令**     </span>|<span class="string"> **功能**          </span>|<span class="string"> **示例**       </span>|</span><br><span class="line">|<span class="string"> ------------ </span>|<span class="string"> ----------------- </span>|<span class="string"> -------------- </span>|</span><br><span class="line">|<span class="string"> `getenforce` </span>|<span class="string"> 查看 SELinux 状态 </span>|<span class="string"> `getenforce`   </span>|</span><br><span class="line">|<span class="string"> `setenforce` </span>|<span class="string"> 设置 SELinux 模式 </span>|<span class="string"> `setenforce 0` </span>|</span><br><span class="line"></span><br><span class="line"><span class="symbol">*</span><span class="symbol">*</span>10. 包管理（以 Ubuntu/Debian 为例）<span class="symbol">*</span><span class="symbol">*</span></span><br><span class="line"></span><br><span class="line">|<span class="string"> **指令**      </span>|<span class="string"> **功能**           </span>|<span class="string"> **示例**                        </span>|</span><br><span class="line">|<span class="string"> ------------- </span>|<span class="string"> ------------------ </span>|<span class="string"> ------------------------------- </span>|</span><br><span class="line">|<span class="string"> `apt update`  </span>|<span class="string"> 更新软件包列表     </span>|<span class="string"> `sudo apt update`               </span>|</span><br><span class="line">|<span class="string"> `apt upgrade` </span>|<span class="string"> 升级已安装的软件包 </span>|<span class="string"> `sudo apt upgrade`              </span>|</span><br><span class="line">|<span class="string"> `apt install` </span>|<span class="string"> 安装软件包         </span>|<span class="string"> `sudo apt install package_name` </span>|</span><br><span class="line">|<span class="string"> `apt remove`  </span>|<span class="string"> 删除软件包         </span>|<span class="string"> `sudo apt remove package_name`  </span>|</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">#### 问：说一下Linux的启动方式？</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">1. <span class="symbol">*</span><span class="symbol">*</span>加电启动（BIOS/UEFI 阶段）开机BIOS自检<span class="symbol">*</span><span class="symbol">*</span></span><br><span class="line">   - <span class="symbol">*</span><span class="symbol">*</span>BIOS (Basic Input/Output System)<span class="symbol">*</span><span class="symbol">*</span> 或 <span class="symbol">*</span><span class="symbol">*</span>UEFI (Unified Extensible Firmware Interface)<span class="symbol">*</span><span class="symbol">*</span> 是硬件的初始化程序。</span><br><span class="line"></span><br><span class="line">   - 主要任务：</span><br><span class="line"></span><br><span class="line">     1. <span class="symbol">*</span><span class="symbol">*</span>初始化硬件设备<span class="symbol">*</span><span class="symbol">*</span>（CPU、内存、硬盘等）。</span><br><span class="line">     2. <span class="symbol">*</span><span class="symbol">*</span>检测并加载启动设备<span class="symbol">*</span><span class="symbol">*</span>。</span><br><span class="line">     3. <span class="symbol">*</span><span class="symbol">*</span>将控制权交给引导加载程序<span class="symbol">*</span><span class="symbol">*</span>（如 GRUB）。</span><br><span class="line">2. <span class="symbol">*</span><span class="symbol">*</span>引导加载程序（Bootloader 阶段）MBR引导、grub引导菜单<span class="symbol">*</span><span class="symbol">*</span></span><br><span class="line">   - <span class="symbol">*</span><span class="symbol">*</span>引导加载程序<span class="symbol">*</span><span class="symbol">*</span>是存储在<span class="symbol">*</span><span class="symbol">*</span>硬盘 MBR（主引导记录）<span class="symbol">*</span><span class="symbol">*</span>或 EFI 分区的一个小程序，用于加载操作系统内核。</span><br><span class="line"></span><br><span class="line">   - 常见引导加载程序：</span><br><span class="line"></span><br><span class="line">     - GRUB（GRUB Legacy 或 GRUB2）。</span><br><span class="line">     - LILO（已过时）。</span><br><span class="line">     - systemd-boot（适用于 systemd 系统）。</span><br><span class="line"></span><br><span class="line">   - 主要任务：</span><br><span class="line"></span><br><span class="line">     1. <span class="symbol">*</span><span class="symbol">*</span>显示启动菜单，让用户选择内核或操作系统<span class="symbol">*</span><span class="symbol">*</span>。</span><br><span class="line">     2. <span class="symbol">*</span><span class="symbol">*</span>加载内核（Kernel）和 initramfs/initrd（临时文件系统，用于初始化硬件）<span class="symbol">*</span><span class="symbol">*</span>。</span><br><span class="line">     3. <span class="symbol">*</span><span class="symbol">*</span>将控制权移交给内核<span class="symbol">*</span><span class="symbol">*</span>。</span><br><span class="line">3. <span class="symbol">*</span><span class="symbol">*</span>内核启动（Kernel 阶段）<span class="symbol">*</span><span class="symbol">*</span></span><br><span class="line">   - 内核是 Linux 操作系统的核心部分，负责硬件管理和提供系统功能。</span><br><span class="line"></span><br><span class="line">   - 主要任务：</span><br><span class="line"></span><br><span class="line">     1. <span class="symbol">*</span><span class="symbol">*</span>解压并加载内核到内存中。<span class="symbol">*</span><span class="symbol">*</span></span><br><span class="line">     2. <span class="symbol">*</span><span class="symbol">*</span>初始化内核数据结构和设备驱动。<span class="symbol">*</span><span class="symbol">*</span></span><br><span class="line">     3. <span class="symbol">*</span><span class="symbol">*</span>挂载根文件系统（通常由 initramfs 提供临时支持，稍后切换到实际的根文件系统）。<span class="symbol">*</span><span class="symbol">*</span></span><br><span class="line">     4. <span class="symbol">*</span><span class="symbol">*</span>启动第一个用户空间进程（通常是 `/sbin/init` 或等效进程）。<span class="symbol">*</span><span class="symbol">*</span></span><br><span class="line">4. 初始化进程（Init System 阶段）启动init进程、读取inittab文件</span><br><span class="line">   - 在 Linux 系统中，`init` 是第一个用户空间进程，进程号始终为 `1`。</span><br><span class="line"></span><br><span class="line">   - 常见的初始化系统：</span><br><span class="line"></span><br><span class="line">     1. <span class="symbol">*</span><span class="symbol">*</span>SysVinit<span class="symbol">*</span><span class="symbol">*</span>：传统的 init 系统，通过运行级别（runlevel）管理服务。</span><br><span class="line">     2. <span class="symbol">*</span><span class="symbol">*</span>Upstart<span class="symbol">*</span><span class="symbol">*</span>：改进版 init 系统，支持事件驱动（已逐步被淘汰）。</span><br><span class="line">     3. <span class="symbol">*</span><span class="symbol">*</span>systemd<span class="symbol">*</span><span class="symbol">*</span>（主流）：现代化的初始化系统，启动速度快，支持并行服务启动。</span><br><span class="line"></span><br><span class="line">   - 主要任务：</span><br><span class="line"></span><br><span class="line">     1. <span class="symbol">*</span><span class="symbol">*</span>读取配置文件（如 `/etc/inittab` 或 `/etc/systemd/system`）。<span class="symbol">*</span><span class="symbol">*</span></span><br><span class="line">     2. <span class="symbol">*</span><span class="symbol">*</span>根据运行级别或目标（target），启动相关服务和守护进程。<span class="symbol">*</span><span class="symbol">*</span></span><br><span class="line">     3. <span class="symbol">*</span><span class="symbol">*</span>准备用户登录环境。<span class="symbol">*</span><span class="symbol">*</span></span><br><span class="line">5. 启动用户空间服务（User Space Services 阶段）启动mingetty进程</span><br><span class="line">   - systemd 的作用：</span><br><span class="line"></span><br><span class="line">     - <span class="symbol">*</span><span class="symbol">*</span>加载必要的系统服务和守护进程（如网络管理、日志记录）。<span class="symbol">*</span><span class="symbol">*</span></span><br><span class="line">     - <span class="symbol">*</span><span class="symbol">*</span>启动目标单元（target），如多用户目标（multi-user.target）或图形界面目标（graphical.target）。<span class="symbol">*</span><span class="symbol">*</span></span><br><span class="line"></span><br><span class="line">   - 常见服务：</span><br><span class="line"></span><br><span class="line">     - 网络服务（`networkd`、`NetworkManager`）。</span><br><span class="line">     - 日志服务（`rsyslog`、`journald`）。</span><br><span class="line">     - 文件系统服务（挂载 NFS、自动挂载设备）。</span><br><span class="line">6. 提供登录界面（Login Prompt 阶段）登录系统</span><br><span class="line">   - 启动完成后，系统提供用户登录界面，允许用户登录使用。</span><br><span class="line"></span><br><span class="line">   - 登录方式：</span><br><span class="line"></span><br><span class="line">     1. <span class="symbol">*</span><span class="symbol">*</span>TTY 控制台<span class="symbol">*</span><span class="symbol">*</span>：文本模式的登录界面，通常在 `Ctrl + Alt + F1~F6` 提供。</span><br><span class="line">     2. <span class="symbol">*</span><span class="symbol">*</span>图形界面<span class="symbol">*</span><span class="symbol">*</span>：如 GNOME、KDE 等桌面环境提供的 GUI 登录界面。</span><br><span class="line"></span><br><span class="line">   - 登录后执行：</span><br><span class="line"></span><br><span class="line">     - 加载用户环境变量（如 `.bashrc`、`.profile`）。</span><br><span class="line">     - 提供交互式 shell 或桌面环境。</span><br><span class="line"></span><br><span class="line"><span class="symbol">*</span><span class="symbol">*</span>Linux 启动过程总结<span class="symbol">*</span><span class="symbol">*</span></span><br><span class="line"></span><br><span class="line">```plaintext</span><br><span class="line">BIOS/UEFI → Bootloader (如 GRUB) → Kernel → Init (如 systemd) → User Services → Login Prompt</span><br></pre></td></tr></table></figure></li>
</ul>
</li>
</ul>
<p><strong>Linux 常见启动方式</strong></p>
<ol>
<li><p>正常启动：默认引导加载程序按配置启动系统。</p>
</li>
<li><p>单用户模式 (Single-User Mode)：</p>
<ul>
<li>用于维护或修复系统，只启动必要的服务。</li>
<li>在 GRUB 中编辑内核参数，添加 <code>single</code> 或 <code>init=/bin/bash</code>。</li>
</ul>
</li>
<li><p>救援模式 (Rescue Mode)：用于修复无法正常启动的系统，加载最少的服务。</p>
</li>
<li><p>网络启动 (PXE Boot)：从网络服务器加载操作系统，常用于无盘工作站或批量部署。</p>
</li>
<li><p>安全模式：限制系统功能，仅启动核心服务，用于排查问题。</p>
</li>
<li><p>Live 模式：从可启动介质（如 USB 或光盘）直接运行操作系统，不影响现有系统。</p>
</li>
</ol>
<h4 id="问：select、poll、epoll有没有了解过，讲解一下？区别？"><a href="#问：select、poll、epoll有没有了解过，讲解一下？区别？" class="headerlink" title="问：select、poll、epoll有没有了解过，讲解一下？区别？"></a>问：select、poll、epoll有没有了解过，讲解一下？区别？</h4><p>在操作系统和网络编程中，**<code>select</code><strong>、</strong><code>poll</code>** 和 <strong><code>epoll</code></strong> 是三种常见的 I/O 多路复用机制，用于在一个线程中同时监控多个文件描述符（如网络套接字）的状态。这些机制广泛用于实现高并发服务器。</p>
<p><strong>总结</strong></p>
<ul>
<li><p><code>select</code>：</p>
<ul>
<li>简单易用，但性能和扩展性较差。</li>
<li>适用于文件描述符较少的应用。</li>
</ul>
</li>
<li><p><code>poll</code>：</p>
<ul>
<li>相比 <code>select</code> 更灵活，但性能依然受限于线性扫描。</li>
<li>适用于文件描述符数量中等的场景。</li>
</ul>
</li>
<li><p><code>epoll</code>：</p>
<ul>
<li>提供最高性能，适合高并发、大规模连接的服务器。</li>
<li>是现代 Linux 网络编程的首选。</li>
</ul>
</li>
</ul>
<p>选择哪种机制取决于场景和需求，推荐在高并发场景中使用 **<code>epoll</code>**。</p>
<ol>
<li><p>`select``</p>
<p><strong>概念</strong>：</p>
<ul>
<li>是最早期的 I/O 多路复用机制。</li>
<li>使用一个固定大小的文件描述符集合（<code>fd_set</code>），通过检查文件描述符的读、写、异常状态来决定是否可以进行 I/O 操作。</li>
</ul>
<p><strong>特点</strong>：</p>
<ol>
<li><p>文件描述符限制</p>
<p>：</p>
<ul>
<li>在大多数系统中，<code>select</code> 能处理的文件描述符数量有限（通常是 1024，<code>FD_SETSIZE</code> 可调整）。</li>
</ul>
</li>
<li><p>阻塞和非阻塞</p>
<p>：</p>
<ul>
<li>可以设为阻塞或指定超时时间（<code>timeout</code> 参数）。</li>
</ul>
</li>
<li><p>效率低下</p>
<p>：</p>
<ul>
<li>每次调用时，需要将文件描述符集合从用户态复制到内核态（开销较大）。</li>
<li>内核需要遍历整个文件描述符集合，效率较低。</li>
</ul>
</li>
<li><p>不支持边缘触发</p>
<p>：</p>
<ul>
<li>只能通过轮询检查状态，效率较差。</li>
</ul>
</li>
</ol>
<p><strong>调用示例</strong>：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">fd_set readfds;</span><br><span class="line">FD_ZERO(&amp;readfds);</span><br><span class="line">FD_SET(sock_fd, &amp;readfds);</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">timeval</span> <span class="title">timeout</span> =</span> &#123;<span class="number">5</span>, <span class="number">0</span>&#125;; <span class="comment">// 超时时间 5 秒</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> ret = select(sock_fd + <span class="number">1</span>, &amp;readfds, <span class="literal">NULL</span>, <span class="literal">NULL</span>, &amp;timeout);</span><br><span class="line"><span class="keyword">if</span> (ret &gt; <span class="number">0</span>) &#123;</span><br><span class="line">    <span class="keyword">if</span> (FD_ISSET(sock_fd, &amp;readfds)) &#123;</span><br><span class="line">        <span class="comment">// 处理可读事件</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<hr>
</li>
<li><p>``poll`</p>
<p><strong>概念</strong>：</p>
<ul>
<li>是 <code>select</code> 的改进版本，没有文件描述符数量限制。</li>
<li>使用一个数组（<code>pollfd</code>）代替 <code>fd_set</code>，数组中每个元素都包含文件描述符及其事件信息。</li>
</ul>
<p><strong>特点</strong>：</p>
<ol>
<li><p>无限制文件描述符</p>
<p>：</p>
<ul>
<li>不再受 <code>FD_SETSIZE</code> 限制。</li>
</ul>
</li>
<li><p>依然线性扫描</p>
<p>：</p>
<ul>
<li>内核仍需遍历所有文件描述符来检查状态，效率仍不高。</li>
</ul>
</li>
<li><p>动态数组</p>
<p>：</p>
<ul>
<li>文件描述符集合是动态分配的，不像 <code>select</code> 使用固定大小的集合。</li>
</ul>
</li>
</ol>
<p><strong>调用示例</strong>：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">pollfd</span> <span class="title">fds</span>[2];</span></span><br><span class="line">fds[<span class="number">0</span>].fd = sock_fd1;</span><br><span class="line">fds[<span class="number">0</span>].events = POLLIN; <span class="comment">// 关注可读事件</span></span><br><span class="line">fds[<span class="number">1</span>].fd = sock_fd2;</span><br><span class="line">fds[<span class="number">1</span>].events = POLLIN;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> ret = poll(fds, <span class="number">2</span>, <span class="number">5000</span>); <span class="comment">// 超时 5 秒</span></span><br><span class="line"><span class="keyword">if</span> (ret &gt; <span class="number">0</span>) &#123;</span><br><span class="line">    <span class="keyword">if</span> (fds[<span class="number">0</span>].revents &amp; POLLIN) &#123;</span><br><span class="line">        <span class="comment">// 处理 sock_fd1 的可读事件</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li><p><code>epoll</code></p>
<p><strong>概念</strong>：</p>
<ul>
<li>是 <code>poll</code> 的进一步优化，由 Linux 2.6 引入，专为高效 I/O 处理设计。</li>
<li>提供了更高效的事件通知机制，支持大规模文件描述符监控。</li>
</ul>
<p><strong>特点</strong>：</p>
<ol>
<li><p>无上限</p>
<p>：</p>
<ul>
<li>文件描述符数量不受限制（仅受系统资源限制）。</li>
</ul>
</li>
<li><p>事件驱动</p>
<p>：</p>
<ul>
<li>支持 <strong>水平触发（Level-Triggered, LT）</strong> 和 <strong>边缘触发（Edge-Triggered, ET）</strong>。</li>
<li>边缘触发可以避免重复通知，适合高性能场景。</li>
</ul>
</li>
<li><p>更高性能</p>
<p>：</p>
<ul>
<li>文件描述符状态变化后，内核通过事件通知机制将就绪事件加入一个就绪队列，避免重复扫描。</li>
</ul>
</li>
<li><p>分两步操作</p>
<p>：</p>
<ul>
<li>**<code>epoll_create</code>**：创建 <code>epoll</code> 实例。</li>
<li>**<code>epoll_ctl</code>**：注册、修改、删除监控的文件描述符。</li>
<li>**<code>epoll_wait</code>**：等待事件发生。</li>
</ul>
</li>
</ol>
<p><strong>调用示例</strong>：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> epfd = epoll_create(<span class="number">1</span>); <span class="comment">// 创建 epoll 实例</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">epoll_event</span> <span class="title">ev</span>, <span class="title">events</span>[10];</span></span><br><span class="line">ev.events = EPOLLIN;</span><br><span class="line">ev.data.fd = sock_fd;</span><br><span class="line"></span><br><span class="line">epoll_ctl(epfd, EPOLL_CTL_ADD, sock_fd, &amp;ev); <span class="comment">// 注册文件描述符</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> ret = epoll_wait(epfd, events, <span class="number">10</span>, <span class="number">5000</span>); <span class="comment">// 等待事件</span></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; ret; i++) &#123;</span><br><span class="line">    <span class="keyword">if</span> (events[i].events &amp; EPOLLIN) &#123;</span><br><span class="line">        <span class="comment">// 处理可读事件</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li><p>区别</p>
</li>
</ol>
<table>
<thead>
<tr>
<th>特性</th>
<th><code>select</code></th>
<th><code>poll</code></th>
<th><code>epoll</code></th>
</tr>
</thead>
<tbody><tr>
<td><strong>文件描述符限制</strong></td>
<td>固定大小（1024 或更高）</td>
<td>无限制（取决于系统资源）</td>
<td>无限制（取决于系统资源）</td>
</tr>
<tr>
<td><strong>性能</strong></td>
<td>扫描所有文件描述符</td>
<td>扫描所有文件描述符</td>
<td>事件驱动，无需遍历</td>
</tr>
<tr>
<td><strong>事件触发类型</strong></td>
<td>水平触发</td>
<td>水平触发</td>
<td>水平触发和边缘触发</td>
</tr>
<tr>
<td><strong>适用场景</strong></td>
<td>适用于少量描述符</td>
<td>适用于中等数量描述符</td>
<td>适用于大规模描述符监控</td>
</tr>
<tr>
<td><strong>内存复制</strong></td>
<td>每次调用复制 <code>fd_set</code></td>
<td>每次调用复制 <code>pollfd</code> 数组</td>
<td>一次注册后无需重复操作</td>
</tr>
<tr>
<td><strong>内核支持</strong></td>
<td>所有 Unix 系统</td>
<td>所有 Unix 系统</td>
<td>Linux 2.6 及以上</td>
</tr>
</tbody></table>
<h4 id="问：如何查看Linux系统运行状态？"><a href="#问：如何查看Linux系统运行状态？" class="headerlink" title="问：如何查看Linux系统运行状态？"></a>问：如何查看Linux系统运行状态？</h4><p><strong>1. 系统整体状态</strong></p>
<ul>
<li><p>**<code>top</code>**：</p>
<ul>
<li>显示实时的系统运行状态，包括 CPU、内存使用情况以及进程。</li>
<li>交互操作：<ul>
<li><code>q</code> 退出。</li>
<li><code>M</code> 按内存排序。</li>
<li><code>P</code> 按 CPU 使用率排序。</li>
</ul>
</li>
</ul>
</li>
<li><p>**<code>htop</code>**：</p>
<ul>
<li>类似 <code>top</code>，但界面更美观，操作更直观。</li>
<li>需要安装：<code>sudo apt install htop</code> 或 <code>sudo yum install htop</code>。</li>
</ul>
</li>
<li><p>**<code>uptime</code>**：</p>
<ul>
<li><p>显示系统运行时间、当前用户数量、系统平均负载。</p>
</li>
<li><p>示例输出：</p>
<figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="attribute">13</span>:<span class="number">05</span>:<span class="number">18</span> up <span class="number">2</span> days,  <span class="number">5</span>:<span class="number">30</span>,  <span class="number">3</span> users,  load average: <span class="number">0</span>.<span class="number">15</span>, <span class="number">0</span>.<span class="number">08</span>, <span class="number">0</span>.<span class="number">02</span></span><br></pre></td></tr></table></figure></li>
</ul>
</li>
<li><p>**<code>vmstat</code>**：</p>
<ul>
<li>提供 CPU、内存、I/O、进程的详细信息。</li>
<li>示例：<code>vmstat 1 5</code> 每秒刷新一次，共显示 5 次。</li>
</ul>
</li>
</ul>
<p><strong>2. CPU 相关状态</strong></p>
<ul>
<li>**<code>lscpu</code>**：<ul>
<li>显示 CPU 的架构、核心数量、线程数、频率等详细信息。</li>
</ul>
</li>
<li>**<code>mpstat</code>**（需安装 <code>sysstat</code> 包）：<ul>
<li>显示每个 CPU 的使用率。</li>
<li>示例：<code>mpstat -P ALL 1 5</code> 列出每个CPU的信息，每秒刷新一次，共显示 5 次。</li>
</ul>
</li>
<li>**<code>cat /proc/cpuinfo</code>**：<ul>
<li><strong>查看 CPU 的详细信息</strong>，如型号、频率等。</li>
</ul>
</li>
</ul>
<p><strong>3. 内存状态</strong></p>
<ul>
<li><p>**<code>free</code>**：</p>
<ul>
<li><p>显示系统内存使用情况。</p>
</li>
<li><p>示例：统计已用和空闲的内存</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">free -h</span><br></pre></td></tr></table></figure>

<p>（以人类可读格式显示）。</p>
<figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="attribute">total</span>        used        free      shared  buff/cache   available</span><br><span class="line"><span class="attribute">Mem</span>:          <span class="number">15</span>Gi        <span class="number">2</span>Gi       <span class="number">11</span>Gi       <span class="number">142</span>Mi       <span class="number">1</span>.<span class="number">3</span>Gi       <span class="number">12</span>Gi</span><br></pre></td></tr></table></figure></li>
</ul>
</li>
<li><p>**<code>cat /proc/meminfo</code>**：</p>
<ul>
<li>查看内存的详细信息，包括总量、空闲量、缓存等。</li>
</ul>
</li>
</ul>
<ul>
<li><code>$ vmstat 5    # 每隔5秒刷新</code>：<ul>
<li>统计CPU，内存及虚拟内存使用状态。</li>
</ul>
</li>
</ul>
<p><strong>4. 磁盘状态</strong></p>
<ul>
<li><p>**<code>df</code>**：</p>
<ul>
<li><p>显示磁盘分区的使用情况。</p>
</li>
<li><p>示例：</p>
<figure class="highlight ebnf"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="attribute">df -h</span></span><br></pre></td></tr></table></figure>

<p>（以人类可读格式显示）。</p>
<figure class="highlight gradle"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Filesystem      <span class="keyword">Size</span>  Used Avail Use% Mounted on</span><br><span class="line"><span class="regexp">/dev/</span>sda1       <span class="number">50</span>G   <span class="number">20</span>G   <span class="number">30</span>G   <span class="number">40</span>% /</span><br></pre></td></tr></table></figure></li>
</ul>
</li>
<li><p>**<code>du [OPTION] [DIR]</code>**：</p>
<ul>
<li>查看文件或目录占用的磁盘空间。查看指定目录下各子目录及文件的大小</li>
<li>示例：<code>du -sh /var/log</code> 查看 <code>/var/log</code> 目录的大小。</li>
</ul>
</li>
<li><p>**<code>lsblk</code>**：</p>
<ul>
<li>显示系统中的块设备（磁盘及其分区）信息。</li>
</ul>
</li>
<li><p>**<code>iostat [OPTION] [INTERVAL]</code>**（需安装 <code>sysstat</code> 包）：</p>
<ul>
<li>查看磁盘 I/O 读写情况。统计CPU及IO操作信息</li>
<li>示例：<code>iostat -d 1 5</code> 每秒刷新一次，共显示 5 次。</li>
</ul>
</li>
</ul>
<p><strong>5. 网络状态</strong></p>
<ul>
<li><strong><code>ifconfig</code></strong> 或 **<code>ip a</code>**：<ul>
<li>显示网络接口的状态和 IP 地址。</li>
</ul>
</li>
<li><strong><code>netstat</code></strong> 或 **<code>ss</code>**：<ul>
<li>查看网络连接，端口，Socket信息，监听状态。</li>
<li>示例：<code>ss -tuln</code> 显示监听的 TCP 和 UDP 端口。</li>
</ul>
</li>
<li>**<code>ping</code>**：<ul>
<li>测试网络连通性。</li>
<li>示例：<code>ping www.google.com</code>。</li>
</ul>
</li>
<li>**<code>traceroute</code>**：<ul>
<li>显示数据包到目标主机的路由。</li>
<li>示例：<code>traceroute www.google.com</code>。</li>
</ul>
</li>
<li>**<code>iftop</code>**：<ul>
<li>显示实时网络流量。</li>
<li>需要安装：<code>sudo apt install iftop</code>。</li>
</ul>
</li>
</ul>
<p><strong>6. 进程状态</strong></p>
<ul>
<li>**<code>ps</code>**：<ul>
<li>查看当前运行的进程，列出进程信息。</li>
<li>示例：<code>ps aux | grep apache</code> 查找与 <code>apache</code> 相关的进程。</li>
</ul>
</li>
<li>**<code>pidstat</code>**（需安装 <code>sysstat</code> 包）：<ul>
<li>查看进程的资源使用情况。</li>
<li>示例：<code>pidstat -u 1</code> 每秒刷新一次，显示 CPU 使用率。</li>
</ul>
</li>
<li>**<code>pgrep</code>**：<ul>
<li>按名称查找进程。</li>
<li>示例：<code>pgrep sshd</code>。</li>
</ul>
</li>
</ul>
<ul>
<li><code>$ pstree [OPTION]</code> ：显示进程树信息</li>
<li><code>$ pmap [OPTION] [PID]</code> ：显示每个进程的内存映射信息</li>
<li><code>$ top [OPTION]</code> ：动态显示进程列表</li>
</ul>
<p><strong>7. 系统日志</strong></p>
<ul>
<li>**<code>journalctl</code>**：<ul>
<li>查看系统日志（适用于 <code>systemd</code> 系统）。</li>
<li>示例：<code>journalctl -xe</code> 查看最近的错误日志。</li>
</ul>
</li>
<li>**<code>dmesg</code>**：<ul>
<li>查看内核启动消息和硬件相关信息。</li>
</ul>
</li>
</ul>
<p><strong>8. 用户和登录信息</strong></p>
<ul>
<li>**<code>who</code>**：<ul>
<li>显示当前登录用户。</li>
</ul>
</li>
<li>**<code>w</code>**：<ul>
<li>显示登录用户及其活动。</li>
</ul>
</li>
<li>**<code>last</code>**：<ul>
<li>查看用户登录历史。</li>
</ul>
</li>
</ul>
<p><strong>9. 其他综合工具</strong></p>
<ul>
<li>**<code>sar</code>**（需安装 <code>sysstat</code> 包）：<ul>
<li>收集和查看系统性能数据。</li>
<li>示例：<code>sar -u 1 5</code> 查看 CPU 使用率。</li>
</ul>
</li>
<li>**<code>glances</code>**：<ul>
<li>综合性能监控工具，类似于 <code>htop</code>，但功能更强大。</li>
<li>需要安装：<code>sudo apt install glances</code>。</li>
</ul>
</li>
</ul>
<h4 id="问：说一下Linux如何查找CPU故障？"><a href="#问：说一下Linux如何查找CPU故障？" class="headerlink" title="问：说一下Linux如何查找CPU故障？"></a>问：说一下Linux如何查找CPU故障？</h4><p>在 Linux 系统中，查找 CPU 故障需要结合系统日志、硬件状态检查工具以及性能监控工具。</p>
<p><strong>1. 检查系统日志</strong></p>
<p>系统日志通常是排查 CPU 故障的第一步，因为 CPU 故障可能导致内核报错或系统异常，日志中会记录相关信息。</p>
<ul>
<li><p><strong>查看内核消息</strong>：</p>
<ul>
<li><p>使用 <code>dmesg</code> 查看内核启动和运行过程中的信息：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">dmesg | grep -i cpu</span><br></pre></td></tr></table></figure>

<p>搜索与 CPU 相关的错误，例如 “CPU stuck”, “Machine Check Exception” (MCE) 等。</p>
</li>
</ul>
</li>
<li><p><strong>查看系统日志</strong>：</p>
<ul>
<li><p>使用 <code>journalctl</code> 查看系统日志：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">journalctl -k | grep -i cpu</span><br></pre></td></tr></table></figure>

<p>查找与 CPU 相关的警告或错误消息。</p>
</li>
</ul>
</li>
<li><p><strong>检查硬件日志</strong>：</p>
<ul>
<li>某些系统可能有硬件特定日志（如 <code>/var/log/messages</code> 或 <code>/var/log/syslog</code>），可以查找异常信息。</li>
</ul>
</li>
</ul>
<p><strong>2. 检查 CPU 温度和状态</strong></p>
<p>过热或硬件故障可能导致 CPU 异常。</p>
<ul>
<li><p><strong><code>lm-sensors</code> 工具</strong>：</p>
<ul>
<li><p>安装并使用 <code>sensors</code> 检查 CPU 温度：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">sudo apt install lm-sensors</span><br><span class="line">sensors</span><br></pre></td></tr></table></figure></li>
</ul>
<p>查看是否有温度过高或异常的情况。</p>
</li>
<li><p><strong><code>hwinfo</code> 工具</strong>：</p>
<ul>
<li><p>获取硬件详细信息，检查 CPU 的健康状况：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">sudo apt install hwinfo</span><br><span class="line">hwinfo --cpu</span><br></pre></td></tr></table></figure></li>
</ul>
</li>
</ul>
<p><strong>3. 检查 CPU 使用率和负载</strong></p>
<p>CPU 负载过高可能是某些问题的原因或结果。</p>
<ul>
<li><p>**<code>top</code> 或 <code>htop</code>**：</p>
<ul>
<li>查看实时 CPU 使用率，检查是否有异常的进程占用大量 CPU。</li>
</ul>
</li>
<li><p><strong><code>sar</code> 工具</strong>：</p>
<ul>
<li><p>查看 CPU 使用的历史记录：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sar -u 1 5</span><br></pre></td></tr></table></figure>

<p>检查是否有 CPU 使用率异常高的情况。</p>
</li>
</ul>
</li>
<li><p>**<code>mpstat</code>**：</p>
<ul>
<li><p>监控每个 CPU 核心的使用率：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mpstat -P ALL 1</span><br></pre></td></tr></table></figure></li>
</ul>
</li>
<li><p><strong>检查平均负载</strong>：</p>
<ul>
<li>使用 <code>uptime</code> 或 <code>top</code>检查系统平均负载是否异常：如果负载长期超过 CPU 核心数，可能存在性能问题。</li>
</ul>
</li>
</ul>
<p><strong>4. 检查 CPU 硬件错误</strong></p>
<ul>
<li><p><strong><code>mcelog</code> 工具</strong>：</p>
<ul>
<li><p>检查 CPU 硬件错误（如机器检查异常 - Machine Check Exception）。</p>
</li>
<li><p>安装并使用：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">sudo apt install mcelog</span><br><span class="line">sudo mcelog --ascii</span><br></pre></td></tr></table></figure>

<p>输出 CPU 错误日志，检测是否有硬件问题。</p>
</li>
</ul>
</li>
<li><p>**<code>/proc/cpuinfo</code>**：</p>
<ul>
<li><p>查看 CPU 详细信息，确认硬件特性：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cat /proc/cpuinfo</span><br></pre></td></tr></table></figure>

<p>检查是否有与硬件配置不符的地方。</p>
</li>
</ul>
</li>
<li><p><strong>BIOS/UEFI 检查</strong>：</p>
<ul>
<li>某些硬件故障可能需要检查 BIOS/UEFI 的日志或设置，确保 CPU 配置正常。</li>
</ul>
</li>
</ul>
<p><strong>5. 性能分析和瓶颈排查</strong></p>
<ul>
<li><p><strong><code>perf</code> 工具</strong>：</p>
<ul>
<li><p>性能分析工具，可深入分析 CPU 性能问题。</p>
</li>
<li><p>示例：记录一段时间的 CPU 性能数据并生成报告：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">perf record -a -g sleep 10</span><br><span class="line">perf report</span><br></pre></td></tr></table></figure></li>
</ul>
</li>
<li><p>**<code>strace</code> 和 <code>ltrace</code>**：</p>
<ul>
<li>跟踪特定进程的系统调用，排查导致 CPU 高负载的原因。</li>
</ul>
</li>
</ul>
<p><strong>6. 硬件健康检测</strong></p>
<ul>
<li><p><strong><code>stress</code> 工具</strong>：</p>
<ul>
<li><p>用于压力测试 CPU，验证 CPU 是否在高负载下运行正常。</p>
</li>
<li><p>安装并运行：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">sudo apt install stress</span><br><span class="line">stress --cpu 4 --timeout 60</span><br></pre></td></tr></table></figure>

<p>观察是否在高负载下系统会出现错误或崩溃。</p>
</li>
</ul>
</li>
<li><p>**<code>memtest86+</code>**：</p>
<ul>
<li>CPU 的问题可能与内存有关，可以运行内存测试工具检查。</li>
</ul>
</li>
</ul>
<p><strong>7. 内核参数和补丁检查</strong></p>
<ul>
<li><p>检查是否有未应用的内核补丁，尤其是与 CPU 微码相关的更新：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">sudo apt install intel-microcode  <span class="comment"># Intel CPU</span></span><br><span class="line">sudo apt install amd64-microcode <span class="comment"># AMD CPU</span></span><br></pre></td></tr></table></figure></li>
<li><p>查看当前内核参数：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cat /proc/cmdline</span><br></pre></td></tr></table></figure></li>
</ul>
<p><strong>8. 硬件故障处理</strong></p>
<p>如果怀疑是硬件故障，可以采取以下措施：</p>
<ol>
<li><p>清理和检查硬件连接：</p>
<ul>
<li>检查 CPU 风扇和散热片是否正常工作，清除灰尘。</li>
</ul>
</li>
<li><p>更换硬件：</p>
<ul>
<li>更换 CPU、主板，或者将 CPU 移至其他主机测试。</li>
</ul>
</li>
<li><p>联系厂商：</p>
<ul>
<li>如果 CPU 在保修期内，可联系厂商进行进一步的诊断和更换。</li>
</ul>
</li>
</ol>
<h3 id="5-2-磁盘"><a href="#5-2-磁盘" class="headerlink" title="5.2 磁盘"></a>5.2 磁盘</h3><h3 id="5-3-分区"><a href="#5-3-分区" class="headerlink" title="5.3 分区"></a>5.3 分区</h3><h3 id="5-4-文件系统"><a href="#5-4-文件系统" class="headerlink" title="5.4 文件系统"></a>5.4 文件系统</h3><h4 id="问：Linux文件系统有哪些？"><a href="#问：Linux文件系统有哪些？" class="headerlink" title="问：Linux文件系统有哪些？"></a>问：Linux文件系统有哪些？</h4><p>Linux 支持多种文件系统，不同的文件系统有其特定的设计目标、性能特点和使用场景。以下是 Linux 中常见的文件系统及其特点：</p>
<p><strong>1. 传统文件系统</strong></p>
<p><strong>1.1 ext（Extended File System）系列</strong></p>
<ul>
<li><strong>ext2</strong>:<ul>
<li>全称：Second Extended File System。</li>
<li>特点：<ul>
<li>是 Linux 的第一个商业文件系统。</li>
<li>不支持日志功能（Journal）。</li>
<li>适用于闪存等不需要日志的存储设备。</li>
</ul>
</li>
<li>使用场景：早期 Linux 系统。</li>
</ul>
</li>
<li><strong>ext3</strong>:<ul>
<li>全称：Third Extended File System。</li>
<li>特点：<ul>
<li>基于 ext2 增加了日志功能。</li>
<li>支持快速恢复，防止数据丢失。</li>
<li>向下兼容 ext2。</li>
</ul>
</li>
<li>使用场景：主流 Linux 系统（过时）。</li>
</ul>
</li>
<li><strong>ext4</strong>:<ul>
<li>全称：Fourth Extended File System。</li>
<li>特点：<ul>
<li>支持大文件（单文件大小可达 16TB）。</li>
<li>更快的性能，延迟分配（Delayed Allocation）。</li>
<li>向后兼容 ext3。</li>
</ul>
</li>
<li>使用场景：现代 Linux 系统默认文件系统之一。</li>
</ul>
</li>
</ul>
<p><strong>1.2 XFS</strong></p>
<ul>
<li><p>XFS:</p>
<ul>
<li>由 SGI 开发，适用于高性能场景。</li>
<li>特点：<ul>
<li>支持并行 I/O，性能优异。</li>
<li>支持大文件和大分区。</li>
<li>使用 B+ 树加速目录操作。</li>
</ul>
</li>
<li>使用场景：高性能和大规模存储系统，如媒体处理、数据库。</li>
</ul>
</li>
</ul>
<p><strong>1.3 ReiserFS</strong></p>
<ul>
<li><p>ReiserFS:</p>
<ul>
<li>特点：<ul>
<li>优化小文件存储。</li>
<li>高效的磁盘空间利用率。</li>
<li>支持日志功能。</li>
</ul>
</li>
<li>使用场景：曾经流行，但因开发停止逐渐被淘汰。</li>
</ul>
</li>
</ul>
<p><strong>1.4 JFS (Journaled File System)</strong></p>
<ul>
<li><p>JFS:</p>
<ul>
<li>IBM 开发的日志文件系统。</li>
<li>特点：<ul>
<li>高性能，适合大文件存储。</li>
<li>使用较少的 CPU 资源。</li>
</ul>
</li>
<li>使用场景：一些企业级应用。</li>
</ul>
</li>
</ul>
<p><strong>2. 新型文件系统</strong></p>
<p><strong>2.1 Btrfs (B-tree File System)</strong></p>
<ul>
<li><p>Btrfs:</p>
<ul>
<li>由 Oracle 开发，现代文件系统。</li>
<li>特点：<ul>
<li>支持快照、子卷、数据校验。</li>
<li>高度灵活，支持在线扩展和缩减。</li>
<li>原生支持 RAID。</li>
</ul>
</li>
<li>使用场景：需要快照和数据校验的场景，如云存储。</li>
</ul>
</li>
</ul>
<p><strong>2.2 ZFS</strong></p>
<ul>
<li><p>ZFS:</p>
<ul>
<li>由 Sun Microsystems 开发，现归 Oracle。</li>
<li>特点：<ul>
<li>支持快照、压缩、数据校验和自愈。</li>
<li>原生支持 RAID 功能。</li>
<li>需要更多内存资源。</li>
</ul>
</li>
<li>使用场景：存储服务器、大数据处理。</li>
</ul>
</li>
</ul>
<p><strong>3. 特殊用途文件系统</strong></p>
<p><strong>3.1 tmpfs</strong></p>
<ul>
<li><p>tmpfs:</p>
<ul>
<li>基于内存的文件系统，数据存储在内存中。</li>
<li>特点：<ul>
<li>高速读写。</li>
<li>数据随系统重启丢失。</li>
</ul>
</li>
<li>使用场景：临时文件存储，如 <code>/tmp</code>。</li>
</ul>
</li>
</ul>
<p><strong>3.2 procfs</strong></p>
<ul>
<li><p>procfs:</p>
<ul>
<li>虚拟文件系统，挂载在 <code>/proc</code>。</li>
<li>特点：<ul>
<li>提供系统和进程信息。</li>
<li>数据动态生成，不占用实际磁盘空间。</li>
</ul>
</li>
<li>使用场景：查看系统状态和配置。</li>
</ul>
</li>
</ul>
<p><strong>3.3 sysfs</strong></p>
<ul>
<li><p>sysfs:</p>
<ul>
<li>虚拟文件系统，挂载在 <code>/sys</code>。</li>
<li>特点：<ul>
<li>提供内核和硬件设备信息。</li>
<li>与 <code>procfs</code> 补充使用。</li>
</ul>
</li>
<li>使用场景：设备和驱动程序调试。</li>
</ul>
</li>
</ul>
<p><strong>3.4 cgroupfs</strong></p>
<ul>
<li><p>cgroupfs:</p>
<ul>
<li>提供控制组（Control Groups）信息。</li>
<li>特点：<ul>
<li>用于资源限制和监控（CPU、内存等）。</li>
</ul>
</li>
<li>使用场景：容器管理（如 Docker）。</li>
</ul>
</li>
</ul>
<p><strong>4. 网络文件系统</strong></p>
<p><strong>4.1 NFS (Network File System)</strong></p>
<ul>
<li><p>NFS:</p>
<ul>
<li>由 Sun Microsystems 开发，用于网络文件共享。</li>
<li>特点：<ul>
<li>支持远程文件访问。</li>
<li>适用于多台机器共享数据。</li>
</ul>
</li>
<li>使用场景：企业网络存储。</li>
</ul>
</li>
</ul>
<p><strong>4.2 CIFS/SMB</strong></p>
<ul>
<li><p>CIFS/SMB:</p>
<ul>
<li>Windows 网络文件共享协议，Linux 支持通过 <code>samba</code> 实现。</li>
<li>特点：<ul>
<li>支持 Windows 文件共享。</li>
</ul>
</li>
<li>使用场景：混合环境文件共享。</li>
</ul>
</li>
</ul>
<p><strong>4.3 GlusterFS 和 CephFS</strong></p>
<ul>
<li><p>分布式文件系统：</p>
<ul>
<li>GlusterFS 和 CephFS 是两种流行的分布式文件系统。</li>
<li>特点：<ul>
<li>支持大规模存储和高可用性。</li>
</ul>
</li>
<li>使用场景：云存储、分布式存储。</li>
</ul>
</li>
</ul>
<p><strong>5. FAT 系列文件系统</strong></p>
<ul>
<li><strong>FAT32 和 exFAT</strong>：<ul>
<li>特点：<ul>
<li>FAT32 支持最大 4GB 文件。</li>
<li>exFAT 支持更大文件且兼容性好。</li>
</ul>
</li>
<li>使用场景：USB、SD 卡等便携式存储。</li>
</ul>
</li>
<li><strong>NTFS</strong>:<ul>
<li>Windows 文件系统，Linux 支持通过 <code>ntfs-3g</code> 工具读写。</li>
<li>使用场景：跨平台存储访问。</li>
</ul>
</li>
</ul>
<p><strong>6. 文件系统对比</strong></p>
<table>
<thead>
<tr>
<th>文件系统</th>
<th>日志支持</th>
<th>文件大小限制</th>
<th>特点</th>
<th>使用场景</th>
</tr>
</thead>
<tbody><tr>
<td>ext4</td>
<td>是</td>
<td>16TB</td>
<td>稳定、高性能</td>
<td>通用场景</td>
</tr>
<tr>
<td>XFS</td>
<td>是</td>
<td>8EB</td>
<td>高性能并行 I/O</td>
<td>高性能、大数据</td>
</tr>
<tr>
<td>Btrfs</td>
<td>是</td>
<td>16EB</td>
<td>快照、RAID 支持，灵活管理</td>
<td>云存储、高可靠性</td>
</tr>
<tr>
<td>ZFS</td>
<td>是</td>
<td>16EB</td>
<td>数据校验、快照、自愈</td>
<td>存储服务器、大数据</td>
</tr>
<tr>
<td>tmpfs</td>
<td>否</td>
<td>取决于内存</td>
<td>基于内存的高速临时存储</td>
<td>临时文件</td>
</tr>
<tr>
<td>NFS</td>
<td>是</td>
<td>依赖底层 FS</td>
<td>网络文件共享</td>
<td>企业网络存储</td>
</tr>
</tbody></table>
<h4 id="问：文件系统的组成？inode-和-block-？"><a href="#问：文件系统的组成？inode-和-block-？" class="headerlink" title="问：文件系统的组成？inode 和 block ？"></a>问：文件系统的组成？inode 和 block ？</h4><p>对于 Ext2 文件系统，当要读取一个文件的内容时，先在 inode 中查找文件内容所在的所有 block，然后把所有 block 的内容读出来。而对于 FAT 文件系统，它没有 inode，每个 block 中存储着下一个 block 的编号。</p>
<p><strong>总结</strong></p>
<ul>
<li><strong>inode</strong> 是 Linux 文件系统管理文件的核心结构，用于存储文件元数据及指向数据块的指针。</li>
<li><strong>block</strong> 是存储文件实际数据的基本单元。</li>
<li>两者相辅相成，inode 管理文件结构和定位 block，而 block 负责实际的数据存储。</li>
</ul>
<p>Linux 文件系统的组成是一个复杂但高效的架构，主要包括元数据和数据两部分。关键概念如 <strong>inode</strong> 和 <strong>block</strong> 是理解文件系统工作的核心。以下是详细的解释：</p>
<p><strong>文件系统的组成</strong></p>
<ol>
<li><p><strong>超级块（Superblock）</strong>：记录文件系统的整体信息，包括 inode 和 block 的总量、使用量、剩余量，以及文件系统的格式与相关信息等；</p>
<ul>
<li>保存文件系统的全局信息。</li>
<li>包括：<ul>
<li>文件系统的类型（如 ext4、XFS）。</li>
<li>文件系统的大小。</li>
<li>已用和未用的 inode 和 block 数量。</li>
<li>文件系统的状态（是否干净）。</li>
<li>文件系统挂载点等信息。</li>
</ul>
</li>
</ul>
</li>
<li><p><strong>inode（索引节点）</strong>：一个文件占用一个 inode，记录文件的属性，同时记录此文件的内容所在的 block 编号；</p>
<ul>
<li>是文件的元数据结构，描述文件的属性。</li>
<li>每个文件或目录在文件系统中都有一个唯一的 inode。</li>
<li>存储信息：<ul>
<li>文件类型（普通文件、目录、符号链接等）。</li>
<li>权限（如 rwx）。</li>
<li>文件所有者（用户 ID 和组 ID）。</li>
<li>文件大小。</li>
<li>文件创建、修改、访问时间戳。</li>
<li>指向数据 block 的指针。</li>
</ul>
</li>
<li><strong>不存储文件名</strong>：文件名与 inode 的映射由目录项存储。</li>
</ul>
</li>
<li><p><strong>数据块（Data Block）</strong>：block：记录文件的内容，文件太大时，会占用多个 block。</p>
<ul>
<li>用于存储文件的实际内容（数据）。</li>
<li>每个文件的数据分为若干个 block 存储，大小通常是文件系统初始化时定义的（如 4KB）。</li>
<li>inode 中保存指向这些数据 block 的指针。</li>
</ul>
</li>
<li><p><strong>目录结构</strong>：</p>
<ul>
<li><p>目录本质上是一个特殊的文件，记录文件名与 inode 的映射关系。</p>
</li>
<li><p>例如：</p>
<figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">文件名:</span> <span class="string">test.txt</span> <span class="string">-&gt;</span> <span class="attr">inode:</span> <span class="number">1234</span></span><br></pre></td></tr></table></figure>

<p>目录项中存储了文件名和对应的 inode 号。</p>
</li>
</ul>
</li>
<li><p><strong>日志（Journal）</strong>（仅限日志型文件系统）：</p>
<ul>
<li>用于记录文件系统的元数据操作（如文件创建、删除）。</li>
<li>提供崩溃恢复能力，防止因断电或系统崩溃导致数据损坏。</li>
</ul>
</li>
<li><p><strong>位图（Bitmap）</strong>：block bitmap：记录 block 是否被使用的位图。</p>
<ul>
<li>inode 位图：记录 inode 的分配状态。</li>
<li>block 位图：记录数据 block 的分配状态。</li>
</ul>
</li>
</ol>
<p><strong>inode 和 block 的详细解析</strong></p>
<p><strong>1. inode（索引节点）</strong></p>
<ul>
<li><p><strong>结构</strong>： inode 是一个固定大小的结构体，文件系统中所有的文件和目录都通过 inode 号进行标识和管理。</p>
</li>
<li><p><strong>inode 包含的元数据</strong>：</p>
<table>
<thead>
<tr>
<th>属性</th>
<th>描述</th>
</tr>
</thead>
<tbody><tr>
<td>文件类型</td>
<td>文件、目录、符号链接、设备等</td>
</tr>
<tr>
<td>权限</td>
<td>读、写、执行权限（rwx）</td>
</tr>
<tr>
<td>用户 ID 和组 ID</td>
<td>文件的所有者和所属组</td>
</tr>
<tr>
<td>文件大小</td>
<td>以字节为单位的文件大小</td>
</tr>
<tr>
<td>时间戳</td>
<td>创建、修改、访问时间</td>
</tr>
<tr>
<td>链接计数</td>
<td>文件的硬链接数量</td>
</tr>
<tr>
<td>数据 block 指针</td>
<td>指向实际存储数据的 block</td>
</tr>
</tbody></table>
</li>
<li><p><strong>指针结构</strong>：</p>
<ul>
<li><strong>直接指针</strong>：指向实际数据块。</li>
<li><strong>间接指针</strong>：如果文件很大，inode 会使用间接指针（一级、二级、三级）指向更多的数据块。</li>
</ul>
</li>
</ul>
<p><strong>2. block（数据块）</strong></p>
<ul>
<li><strong>作用</strong>：<ul>
<li>数据块是用于存储文件数据的基本单元。</li>
<li>一个文件可能占用多个数据块。</li>
</ul>
</li>
<li><strong>块大小</strong>：<ul>
<li>文件系统初始化时设置（常见值为 1KB、2KB、4KB）。</li>
<li>块大小影响性能和空间利用率：<ul>
<li>小块：适合小文件，减少空间浪费。</li>
<li>大块：适合大文件，提高访问性能。</li>
</ul>
</li>
</ul>
</li>
<li><strong>block 的分配</strong>：<ul>
<li>文件系统使用 inode 中的指针管理数据块。</li>
<li>如果数据块不足，文件会通过间接指针扩展数据存储。</li>
</ul>
</li>
</ul>
<p><strong>inode 和 block 的关系</strong></p>
<ol>
<li><strong>inode 中指向 block</strong>：<ul>
<li>inode 中的指针用于定位存储文件数据的 block。</li>
<li>每个文件的所有数据 block 都由 inode 通过直接或间接指针管理。</li>
</ul>
</li>
<li><strong>block 存储实际数据</strong>：<ul>
<li>数据 block 存储文件的实际内容。</li>
<li>目录文件的 block 存储文件名与 inode 号的映射。</li>
</ul>
</li>
</ol>
<p><strong>inode 和 block 的区别</strong></p>
<table>
<thead>
<tr>
<th><strong>属性</strong></th>
<th><strong>inode</strong></th>
<th><strong>block</strong></th>
</tr>
</thead>
<tbody><tr>
<td>定义</td>
<td>文件的元数据</td>
<td>文件的实际数据存储区域</td>
</tr>
<tr>
<td>功能</td>
<td>描述文件属性并定位数据 block</td>
<td>存储文件的内容或目录的映射</td>
</tr>
<tr>
<td>大小</td>
<td>固定大小（如 128 字节、256 字节）</td>
<td>可配置（如 1KB、4KB）</td>
</tr>
<tr>
<td>数量</td>
<td>由文件系统设置，固定总数</td>
<td>根据磁盘大小和块大小计算得出</td>
</tr>
</tbody></table>
<p><strong>inode 和 block 的重要概念</strong></p>
<ol>
<li><strong>inode 表</strong>：<ul>
<li>文件系统中所有 inode 的集合。</li>
<li>每个 inode 占用固定空间。</li>
</ul>
</li>
<li><strong>文件存储原理</strong>：<ul>
<li>创建文件时：<ul>
<li>分配一个 inode。</li>
<li>分配数据块并更新 inode 的指针。</li>
</ul>
</li>
</ul>
</li>
<li><strong>磁盘空间浪费（碎片化）</strong>：<ul>
<li>文件大小小于块大小时，未用部分会浪费（内部碎片）。</li>
<li>小文件占用一个 inode 和一个 block，即使数据很少。</li>
</ul>
</li>
</ol>
<h4 id="问：如何进行数据恢复？"><a href="#问：如何进行数据恢复？" class="headerlink" title="问：如何进行数据恢复？"></a>问：如何进行数据恢复？</h4><p>数据恢复是指在数据丢失后，通过技术手段恢复丢失的文件或数据的过程。数据恢复的方法依赖于数据丢失的原因以及存储介质的类型。在操作系统层面或硬件存储层面，数据恢复通常包括以下几种场景和方法：</p>
<p><strong>一、数据丢失的常见原因</strong></p>
<ol>
<li><p>人为误操作：</p>
<ul>
<li>删除文件（<code>rm</code> 命令误操作）。</li>
<li>格式化存储设备。</li>
</ul>
</li>
<li><p>文件系统损坏：</p>
<ul>
<li>文件系统被破坏导致数据不可见。</li>
</ul>
</li>
<li><p>硬盘损坏：</p>
<ul>
<li>磁盘出现坏道。</li>
<li>硬盘机械故障。</li>
</ul>
</li>
<li><p>病毒或恶意软件攻击：</p>
<ul>
<li>文件被加密、删除或损坏。</li>
</ul>
</li>
<li><p>断电或系统崩溃：</p>
<ul>
<li>数据未写入磁盘或写入不完整。</li>
</ul>
</li>
<li><p>分区表损坏：</p>
<ul>
<li>分区表丢失或被覆盖。</li>
</ul>
</li>
</ol>
<p><strong>二、数据恢复的方法</strong></p>
<p>根据数据丢失的原因，可以选择适当的恢复方法。以下是具体操作方法：</p>
<p><strong>1. 从回收站或备份中恢复</strong></p>
<ul>
<li>如果文件被删除，但存储在<strong>回收站</strong>或其他临时存储区域，可以直接恢复。</li>
<li>如果有<strong>系统备份</strong>，可以通过备份工具恢复丢失的数据。</li>
</ul>
<p><strong>2. 文件删除后的恢复</strong></p>
<ul>
<li><p>在 Linux 中，文件被删除后，实际数据仍存储在硬盘上，除非被覆盖。</p>
</li>
<li><p>恢复方法：</p>
<ol>
<li><p>停止写操作：删除文件后立即停止对磁盘的任何写操作，以防止数据被覆盖。</p>
</li>
<li><p>使用恢复工具：</p>
<ul>
<li><p>extundelete</p>
<p>（针对 ext 文件系统）：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo extundelete /dev/sdX --restore-file &lt;filename&gt;</span><br></pre></td></tr></table></figure></li>
<li><p>TestDisk</p>
<p>（支持多种文件系统）：</p>
<ul>
<li><p>功能：恢复文件、修复分区表。</p>
</li>
<li><p>安装：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo apt install testdisk</span><br></pre></td></tr></table></figure></li>
<li><p>运行：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo testdisk</span><br></pre></td></tr></table></figure></li>
</ul>
</li>
</ul>
</li>
<li><p>dd 命令：</p>
<ul>
<li><p>用于创建磁盘的原始副本，便于后续数据分析。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo dd <span class="keyword">if</span>=/dev/sdX of=/path/to/backup.img</span><br></pre></td></tr></table></figure></li>
</ul>
</li>
</ol>
</li>
</ul>
<p><strong>3. 文件系统损坏后的恢复</strong></p>
<ul>
<li><p>文件系统损坏可能导致文件不可访问，但数据仍然存在。</p>
</li>
<li><p>恢复工具：</p>
<ul>
<li><p>fsck（文件系统检查工具）：</p>
<ul>
<li><p>修复文件系统损坏。</p>
</li>
<li><p>使用：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo fsck /dev/sdX</span><br></pre></td></tr></table></figure></li>
</ul>
</li>
<li><p>e2fsck（针对 ext 文件系统）：</p>
<ul>
<li><p>检查和修复文件系统。</p>
</li>
<li><p>使用：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo e2fsck -y /dev/sdX</span><br></pre></td></tr></table></figure></li>
</ul>
</li>
<li><p>photorec（基于文件签名恢复数据）：</p>
<ul>
<li>可恢复文件内容，即使文件系统损坏。</li>
</ul>
</li>
</ul>
</li>
<li><p>适合恢复图片、文档等已知类型文件。</p>
</li>
</ul>
<p><strong>4. 硬盘坏道或物理损坏</strong></p>
<ul>
<li><p>坏道检测与修复：</p>
<ul>
<li><p>使用 <code>badblocks</code> 工具检测坏道：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo badblocks -v /dev/sdX</span><br></pre></td></tr></table></figure></li>
<li><p>使用 <code>e2fsck</code> 标记坏道：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo e2fsck -c /dev/sdX</span><br></pre></td></tr></table></figure></li>
</ul>
</li>
<li><p>硬盘镜像与克隆：</p>
<ul>
<li><p>通过 <code>ddrescue</code> 工具创建硬盘镜像：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo ddrescue /dev/sdX /path/to/backup.img /path/to/logfile</span><br></pre></td></tr></table></figure></li>
</ul>
</li>
<li><p>专业服务：</p>
<ul>
<li>如果硬盘出现严重物理损坏（如磁头损坏、盘片划伤），需要联系专业数据恢复机构。</li>
</ul>
</li>
</ul>
<p><strong>5. 分区表丢失后的恢复</strong></p>
<ul>
<li><p>TestDisk：</p>
<ul>
<li>功能：扫描并恢复丢失的分区表。</li>
<li>使用：<ol>
<li>启动 TestDisk。</li>
<li>选择磁盘。</li>
<li>搜索丢失的分区。</li>
<li>修复分区表并保存。</li>
</ol>
</li>
</ul>
</li>
</ul>
<h4 id="6-RAID-数据恢复"><a href="#6-RAID-数据恢复" class="headerlink" title="6. RAID 数据恢复"></a><strong>6. RAID 数据恢复</strong></h4><ul>
<li><p>RAID 数据恢复比普通硬盘更复杂。</p>
</li>
<li><p>方法：</p>
<ul>
<li><p>使用 RAID 重建工具（如 mdadm）：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo mdadm --assemble --scan</span><br></pre></td></tr></table></figure></li>
<li><p>如果 RAID 阵列崩溃，需依赖专业数据恢复软件（如 R-Studio）。</p>
</li>
</ul>
</li>
</ul>
<p><strong>三、数据恢复的原则</strong></p>
<ol>
<li><p>及时停止写操作：</p>
<ul>
<li>文件被删除后，数据仍可能存在，写入新数据可能覆盖原始数据。</li>
</ul>
</li>
<li><p>备份磁盘镜像：</p>
<ul>
<li>使用 <code>dd</code> 或 <code>ddrescue</code> 备份磁盘镜像以保护原始数据。</li>
</ul>
</li>
<li><p>不要轻易修复原始磁盘：</p>
<ul>
<li>在修复之前，应备份数据，以防修复失败导致进一步损坏。</li>
</ul>
</li>
<li><p>优先尝试逻辑恢复：</p>
<ul>
<li>如果数据丢失是因误操作或文件系统损坏导致，应尝试逻辑恢复工具。</li>
</ul>
</li>
</ol>
<p><strong>四、常用数据恢复工具总结</strong></p>
<table>
<thead>
<tr>
<th>工具名称</th>
<th>功能</th>
<th>支持文件系统</th>
</tr>
</thead>
<tbody><tr>
<td><code>extundelete</code></td>
<td>恢复 ext 文件系统删除文件</td>
<td>ext2/ext3/ext4</td>
</tr>
<tr>
<td><code>TestDisk</code></td>
<td>分区表恢复、文件恢复</td>
<td>多种文件系统</td>
</tr>
<tr>
<td><code>PhotoRec</code></td>
<td>基于文件签名恢复文件</td>
<td>多种文件系统</td>
</tr>
<tr>
<td><code>fsck</code></td>
<td>修复文件系统错误</td>
<td>ext 系列、xfs 等</td>
</tr>
<tr>
<td><code>ddrescue</code></td>
<td>镜像与坏道数据恢复</td>
<td>通用</td>
</tr>
</tbody></table>
<p><strong>五、总结</strong></p>
<ul>
<li>数据恢复是一个技术性较强的过程，取决于数据丢失原因和存储设备状况。</li>
<li>小型数据丢失可通过工具如 <code>extundelete</code> 和 <code>TestDisk</code> 恢复。</li>
<li>硬件故障或大规模损坏情况下，优先备份磁盘镜像，再尝试恢复工具或联系专业机构。</li>
<li>最重要的是：<strong>防患于未然，定期备份数据！</strong></li>
</ul>
<h3 id="5-5-文件"><a href="#5-5-文件" class="headerlink" title="5.5 文件"></a>5.5 文件</h3><h4 id="问：Linux文件类型有哪些？"><a href="#问：Linux文件类型有哪些？" class="headerlink" title="问：Linux文件类型有哪些？"></a>问：Linux文件类型有哪些？</h4><p>常见的文件类型及其含义有：</p>
<ul>
<li>d：目录</li>
<li>-：文件</li>
<li>l：链接文件</li>
</ul>
<p>在 Linux 中，文件类型是操作系统用于区分不同文件的类别。这些文件类型可以通过命令行工具（如 <code>ls</code>）查看，也可以通过文件系统元数据识别。以下是 Linux 中的主要文件类型及其说明：</p>
<p><strong>Linux 文件类型</strong></p>
<p><strong>1. 普通文件（Regular File）</strong></p>
<ul>
<li><p>特征：</p>
<ul>
<li><p>包含普通数据，如文本、二进制文件、图像等。</p>
</li>
<li><p>文件类型标识：<code>-</code>（减号）。</p>
</li>
<li><p>例如：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">-rw-r--r--  1 user group 1024 Jan 12 10:00 example.txt</span><br></pre></td></tr></table></figure></li>
</ul>
</li>
<li><p>子分类：</p>
<ul>
<li><strong>文本文件</strong>：如 <code>.txt</code>、<code>.log</code>。</li>
<li><strong>二进制文件</strong>：如可执行文件、程序。</li>
<li><strong>压缩文件</strong>：如 <code>.zip</code>、<code>.tar.gz</code>。</li>
</ul>
</li>
</ul>
<p><strong>2. 目录文件（Directory File）</strong></p>
<ul>
<li><p>特征：</p>
<ul>
<li><p>用于存储其他文件和目录。</p>
</li>
<li><p>文件类型标识：<code>d</code>。</p>
</li>
<li><p>例如：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">drwxr-xr-x  2 user group 4096 Jan 12 10:00 mydir</span><br></pre></td></tr></table></figure></li>
</ul>
</li>
<li><p>说明：</p>
<ul>
<li>目录是一个特殊文件，存储文件名和对应 inode 的映射。</li>
</ul>
</li>
<li><p>可以通过 <code>cd</code> 命令访问。</p>
</li>
</ul>
<p><strong>3. 链接文件（Link File）</strong></p>
<ul>
<li><p>类型：</p>
<ul>
<li><p>硬链接（Hard Link）：</p>
<ul>
<li>指向文件的 inode 号。</li>
<li>和原文件共享同一数据，不占用额外空间。</li>
<li>删除原文件，硬链接仍然有效。</li>
</ul>
</li>
<li><p>符号链接（Symbolic Link 或 Soft Link）：</p>
<ul>
<li><p>指向文件的路径。</p>
</li>
<li><p>文件类型标识：<code>l</code>。</p>
</li>
<li><p>例如：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">lrwxrwxrwx  1 user group   10 Jan 12 10:00 symlink -&gt; example.txt</span><br></pre></td></tr></table></figure></li>
</ul>
</li>
</ul>
</li>
</ul>
<p><strong>4. 字符设备文件（Character Device File）</strong></p>
<ul>
<li><p>特征：</p>
<ul>
<li><p>用于与字符设备交互。</p>
</li>
<li><p>文件类型标识：<code>c</code>。</p>
</li>
<li><p>例如：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">crw-rw-rw-  1 root root 5, 1 Jan 12 10:00 /dev/tty</span><br></pre></td></tr></table></figure></li>
</ul>
</li>
<li><p>作用：</p>
<ul>
<li>提供逐字符输入/输出的设备，如终端、键盘。</li>
</ul>
</li>
</ul>
<p><strong>5. 块设备文件（Block Device File）</strong></p>
<ul>
<li><p>特征：</p>
<ul>
<li><p>用于与块设备交互。</p>
</li>
<li><p>文件类型标识：<code>b</code>。</p>
</li>
<li><p>例如：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">brw-rw----  1 root disk 8, 0 Jan 12 10:00 /dev/sda</span><br></pre></td></tr></table></figure></li>
</ul>
</li>
<li><p>作用：提供随机访问数据的设备，如硬盘、USB 驱动器。</p>
</li>
</ul>
<p><strong>6. 套接字文件（Socket File）</strong></p>
<ul>
<li><p>特征：</p>
<ul>
<li><p>用于进程间通信（IPC）。</p>
</li>
<li><p>文件类型标识：<code>s</code>。</p>
</li>
<li><p>例如：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">srwxrwxrwx  1 user group 0 Jan 12 10:00 my_socket</span><br></pre></td></tr></table></figure></li>
</ul>
</li>
<li><p>作用：</p>
<ul>
<li>允许两个进程通过网络或本地通信。</li>
</ul>
</li>
</ul>
<p><strong>7. 管道文件（FIFO，命名管道）</strong></p>
<ul>
<li><p>特征：</p>
<ul>
<li><p>用于进程间通信，通过先入先出的方式传递数据。</p>
</li>
<li><p>文件类型标识：<code>p</code>。</p>
</li>
<li><p>例如：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">prw-r--r--  1 user group 0 Jan 12 10:00 my_pipe</span><br></pre></td></tr></table></figure></li>
</ul>
</li>
<li><p>作用：</p>
<ul>
<li>实现简单的消息传递或数据流动。</li>
</ul>
</li>
</ul>
<p><strong>查看文件类型的方法</strong></p>
<p><strong>1. 使用 <code>ls</code> 命令</strong></p>
<ul>
<li><p>使用 <code>ls -l</code> 查看文件的类型标识：</p>
<p>输出示例：</p>
<figure class="highlight crmsh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">-rw-r--r--  <span class="number">1</span> <span class="keyword">user</span> <span class="title">group</span>  <span class="number">1024</span> Jan <span class="number">12</span> <span class="number">10</span>:<span class="number">00</span> file.txt</span><br><span class="line">drwxr-xr-x  <span class="number">2</span> <span class="keyword">user</span> <span class="title">group</span>  <span class="number">4096</span> Jan <span class="number">12</span> <span class="number">10</span>:<span class="number">00</span> mydir</span><br><span class="line">lrwxrwxrwx  <span class="number">1</span> <span class="keyword">user</span> <span class="title">group</span>    <span class="number">10</span> Jan <span class="number">12</span> <span class="number">10</span>:<span class="number">00</span> symlink -&gt; file.txt</span><br></pre></td></tr></table></figure></li>
</ul>
<p><strong>2. 使用 <code>file</code> 命令</strong></p>
<ul>
<li><p><code>file</code> 命令通过分析文件内容判断类型：<code>file filename</code></p>
<p>输出示例：</p>
<figure class="highlight livecodeserver"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">file</span>.txt: ASCII <span class="keyword">text</span></span><br><span class="line">mydir: <span class="built_in">directory</span></span><br><span class="line">symlink: symbolic link <span class="built_in">to</span> <span class="built_in">file</span>.txt</span><br></pre></td></tr></table></figure></li>
</ul>
<p><strong>3. 使用 <code>stat</code> 命令</strong></p>
<ul>
<li><code>stat</code> 提供详细的文件信息：<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">stat</span> filename</span><br></pre></td></tr></table></figure></li>
</ul>
<p><strong>文件类型标识对照表</strong></p>
<table>
<thead>
<tr>
<th><strong>文件类型</strong></th>
<th><strong>标识符</strong></th>
<th><strong>说明</strong></th>
</tr>
</thead>
<tbody><tr>
<td>普通文件</td>
<td><code>-</code></td>
<td>普通文本或二进制文件</td>
</tr>
<tr>
<td>目录文件</td>
<td><code>d</code></td>
<td>用于存储文件的目录</td>
</tr>
<tr>
<td>符号链接文件</td>
<td><code>l</code></td>
<td>指向其他文件的链接</td>
</tr>
<tr>
<td>字符设备文件</td>
<td><code>c</code></td>
<td>与字符设备交互</td>
</tr>
<tr>
<td>块设备文件</td>
<td><code>b</code></td>
<td>与块设备交互</td>
</tr>
<tr>
<td>套接字文件</td>
<td><code>s</code></td>
<td>进程间通信通道</td>
</tr>
<tr>
<td>管道文件</td>
<td><code>p</code></td>
<td>FIFO 命名管道</td>
</tr>
</tbody></table>
<p><strong>总结</strong></p>
<p>Linux 文件系统中，文件不仅仅指常规文件，还包括目录、链接、设备文件等特殊类型。通过 <code>ls</code>、<code>file</code> 等命令，我们可以轻松查看和区分文件类型。了解这些类型对于高效管理和使用 Linux 系统至关重要。</p>
<h4 id="问：说一下Linux软链接以及和硬链接的区别？"><a href="#问：说一下Linux软链接以及和硬链接的区别？" class="headerlink" title="问：说一下Linux软链接以及和硬链接的区别？"></a>问：说一下Linux软链接以及和硬链接的区别？</h4><p>Linux的文件链接分：</p>
<ul>
<li>硬链接：通过索引节点（inode）来识别文件。在 Linux 中，多个文件名指向同一索引节点是存在的，所以硬连接指通过索引节点来进行的连接，即每一个硬链接都是一个指向对应区域的文件。</li>
<li>软链接：软链接又叫符号链接，这个文件包含了另一个文件的路径名，软连接可以是任意文件或目录，可以链接不同文件系统的文件，在对符号文件进行读或写操作的时候，系统会自动把该操作转换为对源文件的操作，但删除链接文件时，系统仅仅删除链接文件，而不删除源文件本身，这一点类似于 Windows 操作系统下的快捷方式。</li>
</ul>
<table>
<thead>
<tr>
<th align="center"></th>
<th>软链接</th>
<th>硬链接</th>
</tr>
</thead>
<tbody><tr>
<td align="center">inode</td>
<td>原文件&amp;链接文件拥有不同的inode号，表明是不同文件</td>
<td>原文件和链接文件共用一个inode号，表示是同一个文件</td>
</tr>
<tr>
<td align="center">文件属性</td>
<td>明确写出是链接文件</td>
<td>未写出，因为本质上硬链接文件和原文件相同</td>
</tr>
<tr>
<td align="center">跨越文件系统建立</td>
<td>支持</td>
<td>不支持</td>
</tr>
<tr>
<td align="center">链接数目</td>
<td>链接数目不会增加，文件大小不一样</td>
<td>显示的大小与原文件相同</td>
</tr>
</tbody></table>
<p>在 Linux 文件系统中，软链接和硬链接是两种文件链接方式，用于指向文件或目录。以下是软链接和硬链接的详细说明及其区别：</p>
<p><strong>1. 软链接（Symbolic Link）</strong></p>
<p><strong>概念</strong></p>
<ul>
<li>软链接类似于 Windows 中的快捷方式，是指向目标文件路径的特殊文件。</li>
<li>如果目标文件被删除或移动，软链接将失效。</li>
</ul>
<p><strong>特点</strong></p>
<ol>
<li><p>独立文件：软链接是一个独立的文件，保存目标文件的路径信息。</p>
</li>
<li><p>跨文件系统：可以在不同的文件系统或分区之间创建软链接。</p>
</li>
<li><p>指向目录：软链接可以指向文件或目录。</p>
</li>
<li><p>删除目标文件的影响：如果目标文件被删除，软链接会变成“断链”，无法访问。</p>
</li>
</ol>
<p><strong>创建软链接</strong></p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ln -s &lt;目标文件&gt; &lt;软链接名&gt;</span><br></pre></td></tr></table></figure>

<p>示例：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ln -s /home/user/file.txt link_to_file</span><br></pre></td></tr></table></figure>

<p><strong>查看软链接</strong></p>
<ul>
<li><p>使用 <code>ls -l</code> 查看软链接：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ls -l link_to_file</span><br></pre></td></tr></table></figure>

<p>输出示例：</p>
<figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="attribute">lrwxrwxrwx</span> <span class="number">1</span> user group <span class="number">10</span> Jan <span class="number">12</span> <span class="number">10</span>:<span class="number">00</span> link_to_file -&gt; /home/user/file.txt</span><br></pre></td></tr></table></figure></li>
</ul>
<p><strong>2. 硬链接（Hard Link）</strong></p>
<p><strong>概念</strong></p>
<ul>
<li>硬链接是指向文件数据（inode）的另一个文件名，与原文件共享相同的 inode。</li>
</ul>
<p><strong>特点</strong></p>
<ol>
<li><p>共享 inode：硬链接和目标文件共享相同的 inode 号，因此指向相同的文件数据。</p>
</li>
<li><p>不能跨文件系统：硬链接只能在同一个文件系统内创建。</p>
</li>
<li><p>不能指向目录：硬链接只能指向文件，不能指向目录。</p>
</li>
<li><p>删除目标文件的影响：即使原文件被删除，硬链接仍然可以访问文件数据，文件不会丢失，直到最后一个硬链接被删除。</p>
</li>
</ol>
<p><strong>创建硬链接</strong></p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ln &lt;目标文件&gt; &lt;硬链接名&gt;</span><br></pre></td></tr></table></figure>

<p>示例：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ln /home/user/file.txt link_to_file</span><br></pre></td></tr></table></figure>

<p><strong>查看硬链接</strong></p>
<ul>
<li><p>使用 <code>ls -l</code> 查看文件的链接数：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ls -l</span><br></pre></td></tr></table></figure>

<p>输出示例：</p>
<figure class="highlight crmsh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">-rw-r--r-- <span class="number">2</span> <span class="keyword">user</span> <span class="title">group</span> <span class="number">1024</span> Jan <span class="number">12</span> <span class="number">10</span>:<span class="number">00</span> file.txt</span><br><span class="line">-rw-r--r-- <span class="number">2</span> <span class="keyword">user</span> <span class="title">group</span> <span class="number">1024</span> Jan <span class="number">12</span> <span class="number">10</span>:<span class="number">00</span> link_to_file</span><br></pre></td></tr></table></figure></li>
<li><p>第二列的 <code>2</code> 表示文件有两个硬链接。</p>
</li>
</ul>
<p><strong>3. 软链接与硬链接的区别</strong></p>
<table>
<thead>
<tr>
<th><strong>特性</strong></th>
<th><strong>软链接（Symbolic Link）</strong></th>
<th><strong>硬链接（Hard Link）</strong></th>
</tr>
</thead>
<tbody><tr>
<td><strong>指向</strong></td>
<td>文件路径</td>
<td>文件数据（inode）</td>
</tr>
<tr>
<td><strong>跨文件系统</strong></td>
<td>支持</td>
<td>不支持</td>
</tr>
<tr>
<td><strong>目录支持</strong></td>
<td>可以指向目录</td>
<td>不支持</td>
</tr>
<tr>
<td><strong>目标文件删除</strong></td>
<td>软链接失效</td>
<td>硬链接仍然有效</td>
</tr>
<tr>
<td><strong>存储位置</strong></td>
<td>创建一个新文件保存路径信息</td>
<td>与目标文件共享 inode</td>
</tr>
<tr>
<td><strong>文件大小</strong></td>
<td>软链接文件大小是路径字符串的长度</td>
<td>硬链接与原文件大小相同</td>
</tr>
</tbody></table>
<p><strong>4. 示例对比</strong></p>
<p><strong>创建软链接</strong></p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">ln -s /home/user/file.txt soft_link</span><br><span class="line">ls -l soft_link</span><br></pre></td></tr></table></figure>

<p>输出：</p>
<figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="attribute">lrwxrwxrwx</span> <span class="number">1</span> user group <span class="number">10</span> Jan <span class="number">12</span> <span class="number">10</span>:<span class="number">00</span> soft_link -&gt; /home/user/file.txt</span><br></pre></td></tr></table></figure>

<p><strong>创建硬链接</strong></p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">ln /home/user/file.txt hard_link</span><br><span class="line">ls -l</span><br></pre></td></tr></table></figure>

<p>输出：</p>
<figure class="highlight crmsh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">-rw-r--r-- <span class="number">2</span> <span class="keyword">user</span> <span class="title">group</span> <span class="number">1024</span> Jan <span class="number">12</span> <span class="number">10</span>:<span class="number">00</span> file.txt</span><br><span class="line">-rw-r--r-- <span class="number">2</span> <span class="keyword">user</span> <span class="title">group</span> <span class="number">1024</span> Jan <span class="number">12</span> <span class="number">10</span>:<span class="number">00</span> hard_link</span><br></pre></td></tr></table></figure>

<p><strong>删除目标文件</strong></p>
<ul>
<li><p>如果删除 </p>
<figure class="highlight gradle"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="regexp">/home/u</span>ser/<span class="keyword">file</span>.txt</span><br></pre></td></tr></table></figure>

<p>：</p>
<ul>
<li><strong>软链接</strong>：<code>soft_link</code> 失效，无法访问。</li>
<li><strong>硬链接</strong>：<code>hard_link</code> 可正常访问文件数据。</li>
</ul>
</li>
</ul>
<p><strong>5. 应用场景</strong></p>
<p><strong>软链接适用场景</strong></p>
<ul>
<li>快捷访问文件或目录。</li>
<li>跨分区、跨文件系统链接。</li>
<li>创建动态路径指向目标文件（路径会更新）。</li>
</ul>
<p><strong>硬链接适用场景</strong></p>
<ul>
<li>实现文件备份。</li>
<li>确保文件数据不会因误删而丢失（至少保留一个硬链接）。</li>
</ul>
<p><strong>总结</strong></p>
<p>软链接和硬链接各有优缺点，具体使用哪种取决于应用场景。软链接更灵活，适用于跨文件系统或目录指向；硬链接更安全，适用于数据备份或文件共享。了解两者的特性和差异，有助于在 Linux 文件管理中高效使用这两种工具。</p>
<h3 id="5-6-压缩与打包"><a href="#5-6-压缩与打包" class="headerlink" title="5.6 压缩与打包"></a>5.6 压缩与打包</h3><h3 id="5-7-Bash"><a href="#5-7-Bash" class="headerlink" title="5.7 Bash"></a>5.7 Bash</h3><h3 id="5-8-管道指令"><a href="#5-8-管道指令" class="headerlink" title="5.8 管道指令"></a>5.8 管道指令</h3><h4 id="问：说一下命名管道和匿名管道的特点和区别？"><a href="#问：说一下命名管道和匿名管道的特点和区别？" class="headerlink" title="问：说一下命名管道和匿名管道的特点和区别？"></a>问：说一下命名管道和匿名管道的特点和区别？</h4><p>在 Linux 和其他类 Unix 系统中，管道（Pipe）是一种进程间通信（IPC）机制，用于在两个进程之间传递数据。根据是否具备名称，管道分为 <strong>命名管道（Named Pipe，FIFO）</strong> 和 <strong>匿名管道（Anonymous Pipe）</strong>。以下是两者的特点及区别：</p>
<p><strong>1. 匿名管道</strong></p>
<p><strong>特点</strong></p>
<ol>
<li><p>无名称：匿名管道没有名字，仅存在于创建它的进程和相关进程之间。</p>
</li>
<li><p>父子进程之间通信：通常用于有亲缘关系的进程之间通信，例如父进程与子进程之间。</p>
</li>
<li><p>单向通信：数据流是单向的，从一端写入，另一端读取。</p>
</li>
<li><p>生命周期：当创建匿名管道的进程终止时，管道也随之销毁。</p>
</li>
<li><p>效率高：因为只在内存中存在，匿名管道通信效率较高。</p>
</li>
</ol>
<p><strong>创建与使用</strong></p>
<ul>
<li><p>通过系统调用 <code>pipe()</code> 创建：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> pipefd[<span class="number">2</span>];</span><br><span class="line">pipe(pipefd); <span class="comment">// 创建一个管道</span></span><br></pre></td></tr></table></figure></li>
<li><p><code>pipefd[0]</code> 用于读，<code>pipefd[1]</code> 用于写。</p>
</li>
</ul>
<p><strong>2. 命名管道（FIFO）</strong></p>
<p><strong>特点</strong></p>
<ol>
<li><p>有名称：命名管道以文件形式存在于文件系统中，可通过路径访问。</p>
</li>
<li><p>任意进程间通信：不要求进程之间存在亲缘关系，任何两个进程都可以通过命名管道通信。</p>
</li>
<li><p>单向或双向通信：默认单向通信，但可以通过多个管道实现双向通信。</p>
</li>
<li><p>持续存在：命名管道的文件在文件系统中持续存在，除非被显式删除。</p>
</li>
<li><p>易于调试：因为文件名可见，便于调试和使用。</p>
</li>
</ol>
<p><strong>创建与使用</strong></p>
<ul>
<li><p>使用 <code>mkfifo</code> 命令创建命名管道：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mkfifo my_fifo</span><br></pre></td></tr></table></figure></li>
<li><p>使用程序操作命名管道：</p>
<ul>
<li>通过标准文件操作（如 <code>open</code>、<code>read</code>、<code>write</code>）对管道进行读写。</li>
</ul>
</li>
</ul>
<p><strong>3. 区别对比</strong></p>
<table>
<thead>
<tr>
<th><strong>特性</strong></th>
<th><strong>匿名管道</strong></th>
<th><strong>命名管道（FIFO）</strong></th>
</tr>
</thead>
<tbody><tr>
<td><strong>是否具备名称</strong></td>
<td>无名称，只能在创建时使用文件描述符访问</td>
<td>有名称，可以通过路径访问</td>
</tr>
<tr>
<td><strong>通信进程</strong></td>
<td>仅限有亲缘关系的进程间通信</td>
<td>任意进程之间都可通信</td>
</tr>
<tr>
<td><strong>存在形式</strong></td>
<td>仅存在于内存中</td>
<td>文件系统中的特殊文件</td>
</tr>
<tr>
<td><strong>通信方向</strong></td>
<td>单向通信</td>
<td>默认单向通信，可通过多个管道实现双向</td>
</tr>
<tr>
<td><strong>生命周期</strong></td>
<td>随进程终止而销毁</td>
<td>管道文件持续存在，需手动删除</td>
</tr>
<tr>
<td><strong>创建方式</strong></td>
<td>使用 <code>pipe()</code> 系统调用</td>
<td>使用 <code>mkfifo</code> 命令或 <code>mkfifo()</code> 函数</td>
</tr>
<tr>
<td><strong>适用场景</strong></td>
<td>父子进程或兄弟进程间的简单通信</td>
<td>需要长时间存在的进程间通信</td>
</tr>
<tr>
<td><strong>性能</strong></td>
<td>更高，因为只在内存中操作</td>
<td>稍低，因为涉及文件系统操作</td>
</tr>
</tbody></table>
<p><strong>4. 示例</strong></p>
<p><strong>匿名管道示例</strong></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> pipefd[<span class="number">2</span>];</span><br><span class="line">    <span class="keyword">char</span> buffer[<span class="number">100</span>];</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span> (pipe(pipefd) == <span class="number">-1</span>) &#123;</span><br><span class="line">        perror(<span class="string">&quot;pipe&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">pid_t</span> pid = fork();</span><br><span class="line">    <span class="keyword">if</span> (pid == <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="comment">// 子进程 - 写入管道</span></span><br><span class="line">        close(pipefd[<span class="number">0</span>]); <span class="comment">// 关闭读端</span></span><br><span class="line">        write(pipefd[<span class="number">1</span>], <span class="string">&quot;Hello from child!&quot;</span>, <span class="number">18</span>);</span><br><span class="line">        close(pipefd[<span class="number">1</span>]);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">// 父进程 - 从管道读取</span></span><br><span class="line">        close(pipefd[<span class="number">1</span>]); <span class="comment">// 关闭写端</span></span><br><span class="line">        read(pipefd[<span class="number">0</span>], buffer, <span class="keyword">sizeof</span>(buffer));</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;Parent received: %s\n&quot;</span>, buffer);</span><br><span class="line">        close(pipefd[<span class="number">0</span>]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>命名管道示例</strong></p>
<p><strong>创建命名管道</strong>：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mkfifo my_fifo</span><br></pre></td></tr></table></figure>

<p><strong>写入数据</strong>：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">echo</span> <span class="string">&quot;Hello from writer!&quot;</span> &gt; my_fifo</span><br></pre></td></tr></table></figure>

<p><strong>读取数据</strong>：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cat my_fifo</span><br></pre></td></tr></table></figure>

<p><strong>5. 应用场景</strong></p>
<p><strong>匿名管道</strong></p>
<ul>
<li>父子进程间的数据交换。</li>
<li>简单任务中，效率更高的临时通信。</li>
</ul>
<p><strong>命名管道</strong></p>
<ul>
<li>不同进程之间的数据传递。</li>
<li>需要长时间运行的进程间通信。</li>
<li>数据流处理（如日志记录、实时监控）。</li>
</ul>
<p><strong>总结</strong></p>
<p>匿名管道适用于简单的、短期的父子进程通信，而命名管道适合复杂场景中的进程间通信。根据应用场景选择合适的管道方式，可以有效提高程序的效率和灵活性。</p>
<h3 id="5-9-正则表达式"><a href="#5-9-正则表达式" class="headerlink" title="5.9 正则表达式"></a>5.9 正则表达式</h3><h3 id="5-10-进程管理"><a href="#5-10-进程管理" class="headerlink" title="5.10 进程管理"></a>5.10 进程管理</h3><p>进程管理相关，僵尸进程与孤儿进程，SIGCHLD 。</p>
<p>进程管理是操作系统中的重要部分，其中 <strong>僵尸进程</strong> 和 <strong>孤儿进程</strong> 是需要关注的特殊情况。此外，信号 <strong>SIGCHLD</strong> 是处理子进程状态的重要工具。以下是详细解释：</p>
<p><strong>1. 僵尸进程（Zombie Process）</strong></p>
<p><strong>定义</strong></p>
<ul>
<li>僵尸进程是指子进程已经终止，但其退出状态尚未被父进程回收的进程。</li>
<li>僵尸进程会在系统中占用一个进程表项，但不会占用内存或其他资源。</li>
</ul>
<p><strong>成因</strong></p>
<ol>
<li>子进程终止后，会发送一个 <code>SIGCHLD</code> 信号通知父进程。</li>
<li>父进程未及时调用 <code>wait()</code> 或 <code>waitpid()</code> 回收子进程的退出状态。</li>
<li>系统无法清除子进程的进程表项，导致其变为僵尸状态。</li>
</ol>
<p><strong>危害</strong></p>
<ul>
<li>如果父进程未回收大量僵尸进程，进程表会被占满，导致系统无法创建新的进程。</li>
</ul>
<p><strong>解决方法</strong></p>
<ol>
<li><p>父进程回收子进程：</p>
<ul>
<li>使用 <code>wait()</code> 或 <code>waitpid()</code> 明确回收子进程的退出状态。</li>
</ul>
</li>
<li><p>忽略 SIGCHLD 信号：</p>
<ul>
<li><p>父进程可以通过设置 <code>SIGCHLD</code> 信号的处理方式为 <code>SIG_IGN</code>，让系统自动回收子进程。</p>
</li>
<li><p>示例代码：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">signal(SIGCHLD, SIG_IGN);</span><br></pre></td></tr></table></figure></li>
</ul>
</li>
<li><p>编写守护进程：</p>
<ul>
<li>如果父进程不负责直接管理子进程，可以将僵尸进程交由 <code>init</code> 进程（PID=1）处理。</li>
</ul>
</li>
</ol>
<p><strong>2. 孤儿进程（Orphan Process）</strong></p>
<p><strong>定义</strong></p>
<ul>
<li>孤儿进程是指其父进程已经终止，但子进程仍在运行的进程。</li>
</ul>
<p><strong>处理机制</strong></p>
<ul>
<li>孤儿进程会被操作系统自动托管，由 <code>init</code> 进程（PID=1）接管，并负责回收它的退出状态。</li>
<li>孤儿进程不会对系统资源造成危害，因为操作系统会自动处理它。</li>
</ul>
<p><strong>3. SIGCHLD 信号</strong></p>
<p><strong>定义</strong></p>
<ul>
<li><code>SIGCHLD</code> 是子进程状态发生变化时，向父进程发送的信号。</li>
<li>子进程终止、暂停或恢复运行都会触发此信号。</li>
</ul>
<p><strong>父进程对 SIGCHLD 的处理</strong></p>
<ol>
<li><p>默认行为：默认情况下，<code>SIGCHLD</code> 信号会被忽略，但子进程的状态依然需要父进程显式回收。</p>
</li>
<li><p>自定义信号处理：</p>
<ul>
<li><p>父进程可以捕获 <code>SIGCHLD</code> 信号，并在处理函数中调用 <code>wait()</code> 或 <code>waitpid()</code>。</p>
</li>
<li><p>示例代码：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;signal.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/wait.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">sigchld_handler</span><span class="params">(<span class="keyword">int</span> signum)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> status;</span><br><span class="line">    <span class="comment">// 回收子进程</span></span><br><span class="line">    <span class="keyword">while</span> (waitpid(<span class="number">-1</span>, &amp;status, WNOHANG) &gt; <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;Child process terminated\n&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    signal(SIGCHLD, sigchld_handler); <span class="comment">// 注册 SIGCHLD 信号处理函数</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (fork() == <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="comment">// 子进程</span></span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;Child process running\n&quot;</span>);</span><br><span class="line">        sleep(<span class="number">2</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">// 父进程</span></span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;Parent process waiting\n&quot;</span>);</span><br><span class="line">        <span class="keyword">while</span> (<span class="number">1</span>) &#123;</span><br><span class="line">            sleep(<span class="number">1</span>); <span class="comment">// 模拟长时间运行</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
</li>
</ol>
<p><strong>4. 僵尸进程和孤儿进程的对比</strong></p>
<table>
<thead>
<tr>
<th><strong>特性</strong></th>
<th><strong>僵尸进程</strong></th>
<th><strong>孤儿进程</strong></th>
</tr>
</thead>
<tbody><tr>
<td><strong>定义</strong></td>
<td>子进程已终止，但未被父进程回收</td>
<td>父进程已终止，但子进程仍在运行</td>
</tr>
<tr>
<td><strong>处理机制</strong></td>
<td>需要父进程调用 <code>wait()</code> 或 <code>waitpid()</code> 回收</td>
<td>自动由 <code>init</code> 进程接管，无需人工干预</td>
</tr>
<tr>
<td><strong>危害</strong></td>
<td>占用进程表项，可能导致系统无法创建新进程</td>
<td>不会造成危害</td>
</tr>
<tr>
<td><strong>解决方法</strong></td>
<td>父进程主动回收或忽略 <code>SIGCHLD</code> 信号</td>
<td>操作系统自动处理</td>
</tr>
</tbody></table>
<p><strong>5. 示例场景</strong></p>
<p><strong>僵尸进程示例</strong></p>
<p>父进程未回收子进程的退出状态：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (fork() == <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="comment">// 子进程</span></span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;Child process exiting\n&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">// 父进程</span></span><br><span class="line">        sleep(<span class="number">10</span>); <span class="comment">// 父进程没有及时回收子进程</span></span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;Parent process exiting\n&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>运行 <code>ps</code> 命令可以看到 <code>Z</code> 状态的僵尸进程。</p>
<p><strong>孤儿进程示例</strong></p>
<p>父进程终止后，子进程由 <code>init</code> 进程接管：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (fork() == <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="comment">// 子进程</span></span><br><span class="line">        sleep(<span class="number">5</span>);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;Orphan process running\n&quot;</span>);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">// 父进程</span></span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;Parent process exiting\n&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>通过 <code>ps</code> 查看子进程的 <code>PPID</code>，会发现它变为 <code>1</code>（<code>init</code> 进程的 PID）。</p>
<p><strong>总结</strong></p>
<ul>
<li>僵尸进程需要主动回收，否则可能占用系统资源。</li>
<li>孤儿进程由系统自动接管，不需人工干预。</li>
<li>使用 <code>SIGCHLD</code> 信号和相关函数可以有效管理子进程的生命周期，避免资源浪费。</li>
</ul>
<h4 id="问：说一下Linux进程间通信的方式？"><a href="#问：说一下Linux进程间通信的方式？" class="headerlink" title="问：说一下Linux进程间通信的方式？"></a>问：说一下Linux进程间通信的方式？</h4><p>答：管道，信号量，消息队列，共享内存，套接字。</p>
<p>中断与系统调用的概念</p>
<p><strong>中断</strong> 和 <strong>系统调用</strong> 是操作系统中两种重要的机制，主要用于处理硬件事件和提供内核服务。以下是它们的详细概念和区别：</p>
<p><strong>1. 中断（Interrupt）</strong></p>
<p><strong>定义</strong></p>
<ul>
<li><strong>中断</strong> 是一种机制，允许计算机硬件或软件通过向 CPU 发送信号打断当前的程序执行，并切换到特定的中断处理程序。</li>
<li>主要用于响应外部事件（硬件中断）或处理异常情况（软件中断）。</li>
</ul>
<p><strong>分类</strong></p>
<ol>
<li><p>硬件中断：</p>
<ul>
<li>由外部硬件设备（如键盘、鼠标、网卡等）触发。</li>
<li>示例：按下键盘、硬盘完成数据读写。</li>
</ul>
</li>
<li><p>软件中断：</p>
<ul>
<li>由指令触发，通常是程序主动请求操作系统的服务。</li>
</ul>
</li>
</ol>
<ul>
<li>示例：使用 <code>int</code> 指令在 x86 系统中触发系统调用。</li>
</ul>
<p><strong>工作流程</strong></p>
<ol>
<li><p>中断发生：</p>
<ul>
<li>硬件设备或软件产生中断信号。</li>
</ul>
</li>
<li><p>CPU保存上下文：</p>
<ul>
<li>保存当前程序的状态（如寄存器值、程序计数器）。</li>
</ul>
</li>
<li><p>调用中断处理程序：</p>
<ul>
<li>操作系统内核根据中断向量表跳转到对应的中断服务程序（ISR）。</li>
</ul>
</li>
<li><p>处理完成并恢复：</p>
<ul>
<li>恢复之前保存的状态，继续执行被打断的程序。</li>
</ul>
</li>
</ol>
<p><strong>特点</strong></p>
<ul>
<li><strong>异步性</strong>：中断可以随时发生，不受当前程序控制。</li>
<li><strong>优先级</strong>：中断有不同优先级，高优先级的中断会抢占低优先级的中断。</li>
<li><strong>硬件驱动</strong>：硬件设备依赖中断通知操作系统完成事件处理。</li>
</ul>
<p><strong>2. 系统调用（System Call）</strong></p>
<p><strong>定义</strong></p>
<ul>
<li>系统调用是用户程序向操作系统内核请求服务的接口，是操作系统功能对外的唯一入口。</li>
<li>用户态程序通过系统调用访问内核态资源，例如文件、进程、内存等。</li>
</ul>
<p><strong>常见分类</strong></p>
<ol>
<li><p>文件操作：</p>
<ul>
<li>打开/关闭文件：<code>open()</code>、<code>close()</code></li>
<li>读写文件：<code>read()</code>、<code>write()</code></li>
</ul>
</li>
<li><p>进程管理：</p>
<ul>
<li>创建/结束进程：<code>fork()</code>、<code>exit()</code></li>
<li>等待进程：<code>wait()</code></li>
</ul>
</li>
<li><p>内存管理：</p>
<ul>
<li>分配/释放内存：<code>mmap()</code>、<code>munmap()</code></li>
</ul>
</li>
<li><p>设备管理：</p>
<ul>
<li>设备读写：<code>ioctl()</code>、<code>read()</code>、<code>write()</code></li>
</ul>
</li>
<li><p>网络通信：</p>
<ul>
<li>套接字操作：<code>socket()</code>、<code>connect()</code>、<code>bind()</code>。</li>
</ul>
</li>
</ol>
<p><strong>工作流程</strong></p>
<ol>
<li><p>用户程序发起请求：</p>
<ul>
<li>调用系统提供的库函数（如 C 标准库中的 <code>printf()</code>，底层会调用 <code>write()</code>）。</li>
</ul>
</li>
<li><p>陷入内核态：</p>
<ul>
<li>用户态程序通过 <code>trap</code> 指令切换到内核态。</li>
</ul>
</li>
<li><p>内核处理请求：</p>
<ul>
<li>根据系统调用号定位相应的内核函数，执行服务。</li>
</ul>
</li>
<li><p>返回用户态：</p>
<ul>
<li>返回结果到用户态程序。</li>
</ul>
</li>
</ol>
<p><strong>特点</strong></p>
<ul>
<li><strong>同步性</strong>：系统调用是用户程序主动发起的，请求完成后继续执行。</li>
<li><strong>受控访问</strong>：通过系统调用访问内核资源，保证安全性和隔离性。</li>
<li><strong>跨越权限边界</strong>：从用户态切换到内核态，执行需要特权的操作。</li>
</ul>
<p><strong>3. 中断与系统调用的区别</strong></p>
<table>
<thead>
<tr>
<th><strong>特性</strong></th>
<th><strong>中断</strong></th>
<th><strong>系统调用</strong></th>
</tr>
</thead>
<tbody><tr>
<td><strong>触发方式</strong></td>
<td>由硬件事件或特殊指令触发</td>
<td>用户程序主动调用</td>
</tr>
<tr>
<td><strong>触发时机</strong></td>
<td>异步发生，与程序执行无直接关系</td>
<td>同步发生，由程序显式发起</td>
</tr>
<tr>
<td><strong>作用</strong></td>
<td>响应硬件事件或异常</td>
<td>提供内核服务，用户态程序访问操作系统资源</td>
</tr>
<tr>
<td><strong>执行环境</strong></td>
<td>中断服务程序运行在内核态</td>
<td>系统调用切换到内核态后运行</td>
</tr>
<tr>
<td><strong>优先级</strong></td>
<td>通常优先级较高，会抢占当前任务</td>
<td>按调用顺序执行，无优先级干预</td>
</tr>
<tr>
<td><strong>性能开销</strong></td>
<td>较小，因为只处理特定硬件事件</td>
<td>较大，因为涉及用户态与内核态切换</td>
</tr>
</tbody></table>
<p><strong>4. 示例</strong></p>
<p><strong>中断示例</strong></p>
<p>假设一个键盘输入触发中断：</p>
<ol>
<li>用户按下键盘。</li>
<li>键盘控制器向 CPU 发出中断信号。</li>
<li>CPU 暂停当前任务，调用对应的中断处理程序。</li>
<li>中断处理程序读取按键数据，并将其写入缓冲区。</li>
<li>恢复执行被打断的任务。</li>
</ol>
<p><strong>系统调用示例</strong></p>
<p>用户程序调用 <code>write()</code> 写入数据：</p>
<ol>
<li>用户程序调用 <code>write(fd, buffer, size)</code>。</li>
<li>通过 <code>trap</code> 指令切换到内核态。</li>
<li>操作系统根据文件描述符 <code>fd</code> 找到对应文件，并将数据写入。</li>
<li>返回写入字节数到用户态程序。</li>
</ol>
<p><strong>5. 总结</strong></p>
<table>
<thead>
<tr>
<th><strong>概念</strong></th>
<th><strong>中断</strong></th>
<th><strong>系统调用</strong></th>
</tr>
</thead>
<tbody><tr>
<td><strong>核心区别</strong></td>
<td>响应硬件或异常事件，主要用于异步处理</td>
<td>用户态程序请求内核服务的接口，用于受控访问操作系统资源</td>
</tr>
<tr>
<td><strong>执行路径</strong></td>
<td>硬件/软件中断 → CPU → 中断向量表 → 中断处理程序</td>
<td>用户程序 → 系统调用库函数 → <code>trap</code> → 内核处理</td>
</tr>
<tr>
<td><strong>典型场景</strong></td>
<td>硬盘读写完成、网络请求到达、中断处理异常等</td>
<td>打开文件、读写文件、创建进程、分配内存等</td>
</tr>
</tbody></table>
<p>通过区分 <strong>中断</strong> 和 <strong>系统调用</strong> 的触发方式和作用场景，可以更好地理解操作系统对硬件和软件的管理机制。</p>
<h3 id="问：用户态和内核态？为什么要有用户态和内核态？"><a href="#问：用户态和内核态？为什么要有用户态和内核态？" class="headerlink" title="问：用户态和内核态？为什么要有用户态和内核态？"></a>问：用户态和内核态？为什么要有用户态和内核态？</h3><p>通过<strong>系统调用</strong>将Linux整个体系分为用户态和内核态（或者说内核空间和用户空间）。那内核态到底是什么呢？其实从本质上说就是我们所说的内核，它是一种<strong>特殊的软件程序</strong>，特殊在哪儿呢？<strong>控制计算机的硬件资源，例如协调CPU资源，分配内存资源，并且提供稳定的环境供应用程序运行</strong>。</p>
<p>用户态就是提供应用程序运行的空间，为了使应用程序访问到内核管理的资源例如CPU，内存，I/O。内核必须提供一组通用的访问接口，这些接口就叫<strong>系统调用。</strong></p>
<p>内核态：cpu可以访问内存的所有数据，包括外围设备，例如硬盘，网卡，cpu也可以将自己从一个程序切换到另一个程序。</p>
<p>用户态：只能受限的访问内存，且不允许访问外围设备，占用cpu的能力被剥夺，cpu资源可以被其他程序获取。</p>
<p>为什么要有用户态和内核态？由于需要限制不同的程序之间的访问能力, 防止他们获取别的程序的内存数据, 或者获取外围设备的数据, 并发送到网络, CPU划分出两个权限等级 – 用户态和内核态。</p>
<p><strong>用户态和内核态概念</strong></p>
<p><strong>用户态（User Mode）</strong> 和 <strong>内核态（Kernel Mode）</strong> 是操作系统中两种不同的运行权限级别。它们的存在是为了保障系统的稳定性、安全性和资源隔离。</p>
<p><strong>1. 用户态（User Mode）</strong></p>
<p><strong>定义</strong></p>
<ul>
<li>用户态是程序运行在非特权级别下的一种状态。</li>
<li>在用户态中，程序不能直接访问硬件资源或执行特权指令，必须通过系统调用请求操作系统内核的服务。</li>
</ul>
<p><strong>特点</strong></p>
<ol>
<li><p>受限的权限：</p>
<ul>
<li>用户态的程序只能访问受保护的虚拟地址空间，无法直接操作底层硬件。</li>
</ul>
</li>
<li><p>安全性高：</p>
<ul>
<li>如果用户态程序崩溃，影响范围仅限于当前进程，不会导致系统崩溃。</li>
</ul>
</li>
<li><p>主要用途：</p>
<ul>
<li>用于运行用户应用程序（如浏览器、文本编辑器）。</li>
</ul>
</li>
</ol>
<p><strong>2. 内核态（Kernel Mode）</strong></p>
<p><strong>定义</strong></p>
<ul>
<li>内核态是操作系统运行在特权级别下的一种状态。</li>
<li>在内核态中，操作系统内核可以直接访问硬件资源，执行特权指令，以及管理系统资源。</li>
</ul>
<p><strong>特点</strong></p>
<ol>
<li><p>高权限：</p>
<ul>
<li>内核态程序可以直接操作内存、CPU寄存器以及外围设备。</li>
</ul>
</li>
<li><p>潜在风险：</p>
<ul>
<li>内核态的错误可能导致整个系统崩溃。</li>
</ul>
</li>
<li><p>主要用途：</p>
<ul>
<li>用于操作系统内核运行，处理硬件中断、执行系统调用等任务。</li>
</ul>
</li>
</ol>
<p><strong>3. 用户态与内核态的区别</strong></p>
<table>
<thead>
<tr>
<th><strong>特性</strong></th>
<th><strong>用户态</strong></th>
<th><strong>内核态</strong></th>
</tr>
</thead>
<tbody><tr>
<td><strong>权限级别</strong></td>
<td>非特权级别</td>
<td>高特权级别</td>
</tr>
<tr>
<td><strong>访问范围</strong></td>
<td>受限，仅能访问用户空间内存</td>
<td>可访问所有硬件资源和内存区域</td>
</tr>
<tr>
<td><strong>执行指令</strong></td>
<td>无法执行特权指令</td>
<td>可执行特权指令</td>
</tr>
<tr>
<td><strong>崩溃影响</strong></td>
<td>程序崩溃不会影响系统运行</td>
<td>内核崩溃可能导致整个系统崩溃</td>
</tr>
<tr>
<td><strong>用途</strong></td>
<td>运行用户应用程序</td>
<td>运行操作系统内核和处理底层任务</td>
</tr>
</tbody></table>
<p><strong>4. 为什么需要用户态和内核态？</strong></p>
<ol>
<li>安全性<ul>
<li>将应用程序限制在用户态运行，防止其直接操作硬件资源或执行特权指令。</li>
<li>通过权限分离，避免用户程序的错误影响操作系统核心的稳定性。</li>
</ul>
</li>
<li>稳定性<ul>
<li>如果程序在用户态崩溃，操作系统内核仍能正常运行。</li>
<li>系统可以通过隔离机制保护关键资源，避免资源竞争或恶意操作。</li>
</ul>
</li>
<li>系统资源管理<ul>
<li>内核态负责管理和调度硬件资源（CPU、内存、硬盘等）。</li>
<li>用户态通过系统调用请求资源，而不是直接控制资源，从而确保资源分配的公平性和高效性。</li>
</ul>
</li>
<li>抽象和简化<ul>
<li>用户态程序通过系统调用访问底层功能，无需关心硬件细节。</li>
<li>操作系统内核提供统一的接口，简化开发者对底层资源的访问和使用。</li>
</ul>
</li>
</ol>
<p><strong>5. 用户态与内核态的切换</strong></p>
<p><strong>切换场景</strong></p>
<ol>
<li><p>用户态 → 内核态</p>
<ul>
<li><p>系统调用：</p>
<ul>
<li>用户程序请求操作系统服务，例如文件操作、内存分配。</li>
</ul>
</li>
<li><p>中断：</p>
<ul>
<li>硬件设备触发中断信号（如键盘输入、网络数据到达）。</li>
</ul>
</li>
<li><p>异常：</p>
<ul>
<li>用户程序执行非法指令或出现除零等异常情况。</li>
</ul>
</li>
</ul>
</li>
<li><p>内核态 → 用户态</p>
<ul>
<li><p>系统调用返回：</p>
<ul>
<li>操作系统完成请求服务后，将控制权交还给用户程序。</li>
</ul>
</li>
<li><p>进程调度：</p>
<ul>
<li>操作系统将 CPU 控制权交给下一个用户程序。</li>
</ul>
</li>
</ul>
</li>
</ol>
<p><strong>切换过程</strong></p>
<ul>
<li><p>用户态切换到内核态的步骤：</p>
<ol>
<li>保存当前用户态程序的状态（寄存器、程序计数器等）。</li>
<li>切换到内核态，进入内核指定的入口点。</li>
<li>执行内核代码，完成中断处理或系统调用。</li>
</ol>
</li>
<li><p>内核态切换回用户态的步骤：</p>
<ol>
<li>恢复用户态程序的状态。</li>
</ol>
</li>
</ul>
<ol start="2">
<li>切换到用户态，继续执行用户程序。</li>
</ol>
<p><strong>切换开销</strong></p>
<ul>
<li>用户态与内核态的切换需要保存和恢复上下文，涉及硬件操作和内存访问，存在一定的性能开销。</li>
<li>为减少切换次数，部分系统调用（如 Linux 的 <code>getpid()</code>）通过用户态实现部分逻辑。</li>
</ul>
<p><strong>6. 示例：用户态与内核态切换</strong></p>
<p><strong>系统调用示例</strong></p>
<p>用户程序调用 <code>read()</code> 读取文件：</p>
<ol>
<li>用户程序执行 <code>read()</code>，触发系统调用。</li>
<li>通过 <code>trap</code> 指令切换到内核态。</li>
<li>操作系统内核读取文件数据，返回结果。</li>
<li>内核态切换回用户态，返回结果到用户程序。</li>
</ol>
<p><strong>中断示例</strong></p>
<p>键盘按下触发中断：</p>
<ol>
<li>键盘控制器发出中断信号。</li>
<li>CPU 响应中断，切换到内核态。</li>
<li>内核执行中断处理程序，将按键数据存入缓冲区。</li>
<li>中断处理完成后，切换回用户态程序。</li>
</ol>
<p><strong>7. 总结</strong></p>
<ul>
<li><strong>用户态和内核态</strong> 是操作系统实现安全性和稳定性的重要机制。</li>
<li>通过 <strong>权限分离</strong>，用户程序无法直接操作硬件资源，有效防止错误或恶意操作的扩散。</li>
<li><strong>切换代价</strong> 是用户态与内核态设计需要权衡的关键因素，高效的切换机制对系统性能至关重要。</li>
</ul>

    </div>

    
    
    

    <footer class="post-footer">
          

<div class="post-copyright">
<ul>
  <li class="post-copyright-author">
      <strong>本文作者： </strong>Lys
  </li>
  <li class="post-copyright-link">
      <strong>本文链接：</strong>
      <a href="http://linyishui.top/2019102701.html" title="面试整理——操作系统">http://linyishui.top/2019102701.html</a>
  </li>
  <li class="post-copyright-license">
    <strong>版权声明： </strong>本博客所有文章除特别声明外，均采用 <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/deed.zh" rel="noopener" target="_blank"><i class="fab fa-fw fa-creative-commons"></i>BY-NC-SA</a> 许可协议。转载请注明出处！
  </li>
</ul>
</div>

          <div class="post-tags">
              <a href="/tags/Q-A/" rel="tag"><i class="fa fa-tag"></i> Q&A</a>
              <a href="/tags/updating/" rel="tag"><i class="fa fa-tag"></i> updating</a>
          </div>

        

          <div class="post-nav">
            <div class="post-nav-item">
                <a href="/2019102601.html" rel="prev" title="面试整理——网络">
                  <i class="fa fa-chevron-left"></i> 面试整理——网络
                </a>
            </div>
            <div class="post-nav-item">
                <a href="/2019102801.html" rel="next" title="面试整理——分布式">
                  面试整理——分布式 <i class="fa fa-chevron-right"></i>
                </a>
            </div>
          </div>
    </footer>
  </article>
</div>






    <div class="comments utterances-container"></div>
</div>
  </main>

  <footer class="footer">
    <div class="footer-inner">


<div class="copyright">
  &copy; 2018 – 
  <span itemprop="copyrightYear">2025</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">Lys</span>
</div>
<div class="wordcount">
  <span class="post-meta-item">
    <span class="post-meta-item-icon">
      <i class="fa fa-chart-line"></i>
    </span>
      <span>站点总字数：</span>
    <span title="站点总字数">5.4m</span>
  </span>
  <span class="post-meta-item">
    <span class="post-meta-item-icon">
      <i class="fa fa-coffee"></i>
    </span>
      <span>站点阅读时长 &asymp;</span>
    <span title="站点阅读时长">82:05</span>
  </span>
</div>
  <div class="powered-by">由 <a href="https://hexo.io/" rel="noopener" target="_blank">Hexo</a> & <a href="https://theme-next.js.org/pisces/" rel="noopener" target="_blank">NexT.Pisces</a> 强力驱动
  </div>

    </div>
  </footer>

  
  <script src="https://cdn.jsdelivr.net/npm/animejs@3.2.1/lib/anime.min.js" integrity="sha256-XL2inqUJaslATFnHdJOi9GfQ60on8Wx1C2H8DYiN1xY=" crossorigin="anonymous"></script>
  <script src="https://cdn.jsdelivr.net/npm/jquery@3.6.0/dist/jquery.min.js" integrity="sha256-/xUj+3OJU5yExlq6GSYGSHk7tPXikynS7ogEvDej/m4=" crossorigin="anonymous"></script>
  <script src="https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@3.5.7/dist/jquery.fancybox.min.js" integrity="sha256-yt2kYMy0w8AbtF89WXb2P1rfjcP/HTHLT7097U8Y5b8=" crossorigin="anonymous"></script>
<script src="/js/comments.js"></script><script src="/js/utils.js"></script><script src="/js/motion.js"></script><script src="/js/next-boot.js"></script><script src="/js/bookmark.js"></script>

  
<script src="/js/third-party/search/local-search.js"></script>



  <script class="next-config" data-name="nprogress" type="application/json">{"enable":true,"spinner":true}</script>
  <script src="/js/third-party/nprogress.js"></script>

  




<script src="https://cdn.jsdelivr.net/npm/darkmode-js@1.5.7/lib/darkmode-js.min.js"></script>

<script>
var options = {
  bottom: '64px',
  right: '32px',
  left: 'unset',
  time: '0.5s',
  mixColor: 'transparent',
  backgroundColor: 'transparent',
  buttonColorDark: '#100f2c',
  buttonColorLight: '#fff',
  saveInCookies: true,
  label: '🌓',
  autoMatchOsTheme: true
}
const darkmode = new Darkmode(options);
window.darkmode = darkmode;
darkmode.showWidget();
</script>
<script class="next-config" data-name="utterances" type="application/json">{"enable":true,"repo":"LAILAIWA/LAILAIWA.github.io","issue_term":"pathname","theme":"github-light"}</script>
<script src="/js/third-party/comments/utterances.js"></script>



</body>
</html>
