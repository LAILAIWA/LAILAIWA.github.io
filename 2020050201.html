<!DOCTYPE html>
<html lang="zh-CN">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width">
<meta name="theme-color" content="#222">
<meta name="generator" content="Hexo 5.4.0">


  <link rel="apple-touch-icon" sizes="180x180" href="/images/gamepad%20playstation.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/Dig%20Dug.ico">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/gamepad%20playstation.png">
  <link rel="mask-icon" href="/images/gamepad%20playstation.svg" color="#222">

<link rel="stylesheet" href="/css/main.css">

<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Monda:300,300italic,400,400italic,700,700italic%7CMa+Shan+Zheng:300,300italic,400,400italic,700,700italic%7CNoto+Serif+SC:300,300italic,400,400italic,700,700italic&display=swap&subset=latin,latin-ext">

<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free@5.15.3/css/all.min.css" integrity="sha256-2H3fkXt6FEmrReK448mDVGKb3WW2ZZw35gI7vqHOE4Y=" crossorigin="anonymous">
  <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/animate.css@3.1.1/animate.min.css" integrity="sha256-PR7ttpcvz8qrF57fur/yAx1qXMFJeJFiA6pSzWi0OIE=" crossorigin="anonymous">
  <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@3.5.7/dist/jquery.fancybox.min.css" integrity="sha256-Vzbj7sDDS/woiFS3uNKo8eIuni59rjyNGtXfstRzStA=" crossorigin="anonymous">
  <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/nprogress@0.2.0/nprogress.css" integrity="sha256-no0c5ccDODBwp+9hSmV5VvPpKwHCpbVzXHexIkupM6U=" crossorigin="anonymous">
  <script src="https://cdn.jsdelivr.net/npm/nprogress@0.2.0/nprogress.js" integrity="sha256-a5YRB27CcBwBFcT5EF/f3E4vzIqyHrSR878nseNYw64=" crossorigin="anonymous"></script>

<script class="next-config" data-name="main" type="application/json">{"hostname":"linyishui.top","root":"/","images":"/images","scheme":"Pisces","version":"8.6.0","exturl":false,"sidebar":{"position":"left","display":"always","padding":18,"offset":12},"copycode":true,"bookmark":{"enable":true,"color":"#222","save":"manual"},"fancybox":true,"mediumzoom":false,"lazyload":false,"pangu":false,"comments":{"style":"tabs","active":"utterances","storage":true,"lazyload":false,"nav":null,"activeClass":"utterances"},"motion":{"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"fadeInDown","post_body":"fadeInDown","coll_header":"fadeInLeft","sidebar":"fadeInUp"}},"prism":false,"i18n":{"placeholder":"搜索...","empty":"没有找到任何搜索结果：${query}","hits_time":"找到 ${hits} 个搜索结果（用时 ${time} 毫秒）","hits":"找到 ${hits} 个搜索结果"},"path":"/search.xml","localsearch":{"enable":true,"trigger":"auto","top_n_per_article":1,"unescape":false,"preload":false}}</script><script src="/js/config.js"></script>
<meta name="description" content="整理面试中常问的MQ相关问题，持续更新中。">
<meta property="og:type" content="article">
<meta property="og:title" content="面试整理——MQ">
<meta property="og:url" content="http://linyishui.top/2020050201.html">
<meta property="og:site_name" content="俺的部落格">
<meta property="og:description" content="整理面试中常问的MQ相关问题，持续更新中。">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="https://pic-1258215793.cos.ap-shanghai.myqcloud.com/content/20200901/202009010153.png">
<meta property="og:image" content="https://pic-1258215793.cos.ap-shanghai.myqcloud.com/content/20200901/202009010158.png">
<meta property="og:image" content="https://pic-1258215793.cos.ap-shanghai.myqcloud.com/content/20201001/202010010143.png">
<meta property="og:image" content="https://pic-1258215793.cos.ap-shanghai.myqcloud.com/content/20201001/202010010149.png">
<meta property="og:image" content="c:/Users/hspcadmin/AppData/Roaming/Typora/typora-user-images/image-20210331171126692.png">
<meta property="og:image" content="c:/Users/hspcadmin/AppData/Roaming/Typora/typora-user-images/image-20210331171303814.png">
<meta property="og:image" content="c:/Users/hspcadmin/AppData/Roaming/Typora/typora-user-images/image-20210331171436966.png">
<meta property="og:image" content="c:/Users/hspcadmin/AppData/Roaming/Typora/typora-user-images/image-20210331171813344.png">
<meta property="og:image" content="c:/Users/hspcadmin/AppData/Roaming/Typora/typora-user-images/image-20210331172359303.png">
<meta property="og:image" content="c:/Users/hspcadmin/AppData/Roaming/Typora/typora-user-images/image-20210331172219234.png">
<meta property="og:image" content="c:/Users/hspcadmin/AppData/Roaming/Typora/typora-user-images/image-20210331214055800.png">
<meta property="og:image" content="c:/Users/hspcadmin/AppData/Roaming/Typora/typora-user-images/image-20210331214106354.png">
<meta property="article:published_time" content="2020-05-02T10:45:03.000Z">
<meta property="article:modified_time" content="2025-02-21T15:14:44.051Z">
<meta property="article:author" content="Lys">
<meta property="article:tag" content="Q&amp;A">
<meta property="article:tag" content="updating">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://pic-1258215793.cos.ap-shanghai.myqcloud.com/content/20200901/202009010153.png">


<link rel="canonical" href="http://linyishui.top/2020050201.html">



<script class="next-config" data-name="page" type="application/json">{"sidebar":"","isHome":false,"isPost":true,"lang":"zh-CN","comments":true,"permalink":"http://linyishui.top/2020050201.html","path":"2020050201.html","title":"面试整理——MQ"}</script>

<script class="next-config" data-name="calendar" type="application/json">""</script>
<title>面试整理——MQ | 俺的部落格</title>
  




  <noscript>
    <link rel="stylesheet" href="/css/noscript.css">
  </noscript>
<link rel="alternate" href="/atom.xml" title="俺的部落格" type="application/atom+xml">
<style>.darkmode--activated{--body-bg-color:#282828;--content-bg-color:#333;--card-bg-color:#555;--text-color:#ccc;--blockquote-color:#bbb;--link-color:#ccc;--link-hover-color:#eee;--brand-color:#ddd;--brand-hover-color:#ddd;--table-row-odd-bg-color:#282828;--table-row-hover-bg-color:#363636;--menu-item-bg-color:#555;--btn-default-bg:#222;--btn-default-color:#ccc;--btn-default-border-color:#555;--btn-default-hover-bg:#666;--btn-default-hover-color:#ccc;--btn-default-hover-border-color:#666;--highlight-background:#282b2e;--highlight-foreground:#a9b7c6;--highlight-gutter-background:#34393d;--highlight-gutter-foreground:#9ca9b6}.darkmode--activated img{opacity:.75}.darkmode--activated img:hover{opacity:.9}.darkmode--activated code{color:#69dbdc;background:0 0}button.darkmode-toggle{z-index:9999}</style></head>

<body itemscope itemtype="http://schema.org/WebPage" class="use-motion">
  <div class="headband"></div>

  <main class="main">
    <header class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="切换导航栏" role="button">
        <span class="toggle-line"></span>
        <span class="toggle-line"></span>
        <span class="toggle-line"></span>
    </div>
  </div>

  <div class="site-meta">

    <a href="/" class="brand" rel="start">
      <i class="logo-line"></i>
      <h1 class="site-title">俺的部落格</h1>
      <i class="logo-line"></i>
    </a>
      <p class="site-subtitle" itemprop="description">俺寻思俺需要记点东西</p>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger">
        <i class="fa fa-search fa-fw fa-lg"></i>
    </div>
  </div>
</div>



<nav class="site-nav">
  <ul class="main-menu menu">
        <li class="menu-item menu-item-home"><a href="/" rel="section"><i class="fa fa-home fa-fw"></i>首页</a></li>
        <li class="menu-item menu-item-about"><a href="/about/" rel="section"><i class="fa fa-user fa-fw"></i>关于</a></li>
        <li class="menu-item menu-item-tags"><a href="/tags/" rel="section"><i class="fa fa-tags fa-fw"></i>标签</a></li>
        <li class="menu-item menu-item-categories"><a href="/categories/" rel="section"><i class="fa fa-th fa-fw"></i>分类</a></li>
        <li class="menu-item menu-item-archives"><a href="/archives/" rel="section"><i class="fa fa-archive fa-fw"></i>归档</a></li>
        <li class="menu-item menu-item-sitemap"><a href="/sitemap.xml" rel="section"><i class="fa fa-sitemap fa-fw"></i>站点地图</a></li>
        <li class="menu-item menu-item-tools"><a href="/links/" rel="section"><i class="fa fa-link fa-fw"></i>工具</a></li>
        <li class="menu-item menu-item-books"><a href="/books/" rel="section"><i class="fa fa-book fa-fw"></i>书架</a></li>
        <li class="menu-item menu-item-movies"><a href="/movies/" rel="section"><i class="fa fa-video fa-fw"></i>剧院</a></li>
        <li class="menu-item menu-item-games"><a href="/games/" rel="section"><i class="fa fa-gamepad fa-fw"></i>游戏</a></li>
        <li class="menu-item menu-item-commonweal"><a href="/404/" rel="section"><i class="fa fa-heartbeat fa-fw"></i>公益</a></li>
      <li class="menu-item menu-item-search">
        <a role="button" class="popup-trigger"><i class="fa fa-search fa-fw"></i>搜索
        </a>
      </li>
  </ul>
</nav>



  <div class="search-pop-overlay">
    <div class="popup search-popup"><div class="search-header">
  <span class="search-icon">
    <i class="fa fa-search"></i>
  </span>
  <div class="search-input-container">
    <input autocomplete="off" autocapitalize="off" maxlength="80"
           placeholder="搜索..." spellcheck="false"
           type="search" class="search-input">
  </div>
  <span class="popup-btn-close" role="button">
    <i class="fa fa-times-circle"></i>
  </span>
</div>
<div class="search-result-container no-result">
  <div class="search-result-icon">
    <i class="fa fa-spinner fa-pulse fa-5x"></i>
  </div>
</div>

    </div>
  </div>

</div>
        
  
  <div class="toggle sidebar-toggle" role="button">
    <span class="toggle-line"></span>
    <span class="toggle-line"></span>
    <span class="toggle-line"></span>
  </div>

  <aside class="sidebar">

    <div class="sidebar-inner sidebar-nav-active sidebar-toc-active">
      <ul class="sidebar-nav">
        <li class="sidebar-nav-toc">
          文章目录
        </li>
        <li class="sidebar-nav-overview">
          站点概览
        </li>
      </ul>

      <div class="sidebar-panel-container">
        <!--noindex-->
        <div class="post-toc-wrap sidebar-panel">
            <div class="post-toc animated"><ol class="nav"><li class="nav-item nav-level-1"><a class="nav-link" href="#MQ"><span class="nav-text">MQ</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#%E6%B6%88%E6%81%AF%E9%98%9F%E5%88%97"><span class="nav-text">消息队列</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E9%97%AE%EF%BC%9A%E4%B8%BA%E4%BB%80%E4%B9%88%E4%BD%BF%E7%94%A8%E6%B6%88%E6%81%AF%E9%98%9F%E5%88%97%EF%BC%9F%E6%B6%88%E6%81%AF%E9%98%9F%E5%88%97%E7%9A%84%E4%BD%BF%E7%94%A8%E5%9C%BA%E6%99%AF-%E4%BD%9C%E7%94%A8%EF%BC%9F"><span class="nav-text">问：为什么使用消息队列？消息队列的使用场景&#x2F;作用？</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E9%97%AE%EF%BC%9A%E6%B6%88%E6%81%AF%E9%98%9F%E5%88%97%E7%9A%84%E4%BC%98%E7%BC%BA%E7%82%B9%EF%BC%9F"><span class="nav-text">问：消息队列的优缺点？</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E9%97%AE%EF%BC%9A%E5%B8%B8%E8%A7%81%E6%B6%88%E6%81%AF%E9%98%9F%E5%88%97%E5%AF%B9%E6%AF%94%EF%BC%9F"><span class="nav-text">问：常见消息队列对比？</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E9%97%AE%EF%BC%9A%E6%8E%A8%E6%A8%A1%E5%BC%8F%E4%B8%8E%E6%8B%89%E6%A8%A1%E5%BC%8F%EF%BC%9F"><span class="nav-text">问：推模式与拉模式？</span></a></li></ol></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#RabbitMQ"><span class="nav-text">RabbitMQ</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%9F%BA%E7%A1%80%E6%A6%82%E5%BF%B5%E5%92%8C%E5%B7%A5%E4%BD%9C%E5%8E%9F%E7%90%86"><span class="nav-text">基础概念和工作原理</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E9%97%AE%EF%BC%9A%E4%BB%80%E4%B9%88%E6%98%AF-RabbitMQ%EF%BC%9F%E5%AE%83%E6%98%AF%E5%A6%82%E4%BD%95%E5%B7%A5%E4%BD%9C%E7%9A%84%EF%BC%9F"><span class="nav-text">问：什么是 RabbitMQ？它是如何工作的？</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E9%97%AE%EF%BC%9ARabbitMQ-%E4%B8%8E-Kafka%E3%80%81ActiveMQ-%E7%AD%89%E6%B6%88%E6%81%AF%E9%98%9F%E5%88%97%E6%9C%89%E4%BD%95%E5%8C%BA%E5%88%AB%EF%BC%9F"><span class="nav-text">问：RabbitMQ 与 Kafka、ActiveMQ 等消息队列有何区别？</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E9%97%AE%EF%BC%9A%E4%BB%80%E4%B9%88%E6%98%AFBroker%E6%9E%B6%E6%9E%84%EF%BC%9FRabbitMQ%E6%9C%89%E5%93%AA%E4%BA%9B%E5%85%B3%E9%94%AE%E7%BB%84%E4%BB%B6%EF%BC%9FRabbitMQ-%E4%B8%AD%E7%9A%84-Producer%E3%80%81Consumer%E3%80%81Queue%E3%80%81Exchange%E3%80%81Binding-%E5%92%8C-Routing-Key-%E5%88%86%E5%88%AB%E6%98%AF%E4%BB%80%E4%B9%88%EF%BC%9F"><span class="nav-text">问：什么是Broker架构？RabbitMQ有哪些关键组件？RabbitMQ 中的 Producer、Consumer、Queue、Exchange、Binding 和 Routing Key 分别是什么？</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E9%97%AE%EF%BC%9AAMQP-%E5%8D%8F%E8%AE%AE%EF%BC%9F"><span class="nav-text">问：AMQP 协议？</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E9%97%AE%EF%BC%9ARabbitMQ%E7%9A%84vhost%E6%98%AF%E4%BB%80%E4%B9%88%EF%BC%8C%E6%9C%89%E4%BB%80%E4%B9%88%E4%BD%9C%E7%94%A8%EF%BC%9F"><span class="nav-text">问：RabbitMQ的vhost是什么，有什么作用？</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E9%97%AE%EF%BC%9ARabbitMQ-%E7%9A%84%E4%BA%A4%E6%8D%A2%E6%9C%BA%E7%B1%BB%E5%9E%8B%E6%9C%89%E5%93%AA%E4%BA%9B%EF%BC%9F%E5%90%84%E8%87%AA%E7%9A%84%E4%BD%9C%E7%94%A8%E6%98%AF%E4%BB%80%E4%B9%88%EF%BC%9F%E6%B6%88%E6%81%AF%E8%B7%AF%E7%94%B1%EF%BC%9F%E8%B7%AF%E7%94%B1%E8%A7%84%E5%88%99%E5%A6%82%E4%BD%95%E5%AE%9A%E4%B9%89%EF%BC%9F"><span class="nav-text">问：RabbitMQ 的交换机类型有哪些？各自的作用是什么？消息路由？路由规则如何定义？</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E9%97%AE%EF%BC%9ARabbitMQ-%E6%94%AF%E6%8C%81%E5%93%AA%E4%BA%9B%E6%B6%88%E6%81%AF%E6%A8%A1%E5%BC%8F%EF%BC%9F%E6%AF%94%E5%A6%82%E7%82%B9%E5%AF%B9%E7%82%B9%E3%80%81%E5%8F%91%E5%B8%83%E8%AE%A2%E9%98%85%E7%AD%89"><span class="nav-text">问：RabbitMQ 支持哪些消息模式？比如点对点、发布订阅等</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E9%97%AE%EF%BC%9ARabbitMQ-%E7%9A%84%E8%BF%9E%E6%8E%A5%E5%92%8C%E4%BF%A1%E9%81%93%EF%BC%88Channel%EF%BC%89%E6%9C%89%E4%BD%95%E5%8C%BA%E5%88%AB%EF%BC%9F%E4%B8%BA%E4%BB%80%E4%B9%88%E8%A6%81%E4%BD%BF%E7%94%A8%E4%BF%A1%E9%81%93%E8%80%8C%E4%B8%8D%E6%98%AF%E7%9B%B4%E6%8E%A5%E6%93%8D%E4%BD%9C%E8%BF%9E%E6%8E%A5%EF%BC%9F"><span class="nav-text">问：RabbitMQ 的连接和信道（Channel）有何区别？为什么要使用信道而不是直接操作连接？</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E9%97%AE%EF%BC%9A%E6%B6%88%E6%81%AF%E7%A1%AE%E8%AE%A4%E6%9C%BA%E5%88%B6%EF%BC%9F%E4%B8%BA%E4%BB%80%E4%B9%88%E9%9C%80%E8%A6%81%E7%A1%AE%E8%AE%A4%E6%9C%BA%E5%88%B6%EF%BC%9F"><span class="nav-text">问：消息确认机制？为什么需要确认机制？</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E9%97%AE%EF%BC%9A%E6%8C%81%E4%B9%85%E5%8C%96%E6%9C%BA%E5%88%B6%EF%BC%9F%E5%A6%82%E4%BD%95%E9%85%8D%E7%BD%AE%E6%8C%81%E4%B9%85%E5%8C%96%E6%B6%88%E6%81%AF%EF%BC%9F%E5%A6%82%E4%BD%95%E5%A4%84%E7%90%86-RabbitMQ-%E4%B8%AD%E7%9A%84%E6%B6%88%E6%81%AF%E4%B8%A2%E5%A4%B1%E9%97%AE%E9%A2%98%EF%BC%9F%E8%AE%BE%E7%BD%AE%E4%BA%86%E9%98%9F%E5%88%97%E5%92%8C%E6%B6%88%E6%81%AF%E6%8C%81%E4%B9%85%E5%8C%96%E8%83%BD%E4%BF%9D%E8%AF%81%E7%99%BE%E5%88%86%E7%99%BE%E4%B8%8D%E4%B8%A2%E5%A4%B1%E6%B6%88%E6%81%AF%E4%BA%86%E5%90%97%EF%BC%9F"><span class="nav-text">问：持久化机制？如何配置持久化消息？如何处理 RabbitMQ 中的消息丢失问题？设置了队列和消息持久化能保证百分百不丢失消息了吗？</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E9%97%AE%EF%BC%9A%E6%B6%88%E8%B4%B9%E8%80%85%E9%A2%84%E5%8F%96%EF%BC%88Prefetch%EF%BC%89%E6%9C%BA%E5%88%B6%EF%BC%9F%E5%A6%82%E4%BD%95%E9%85%8D%E7%BD%AE%EF%BC%9F"><span class="nav-text">问：消费者预取（Prefetch）机制？如何配置？</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E9%97%AE%EF%BC%9A%E6%AD%BB%E4%BF%A1%E9%98%9F%E5%88%97%EF%BC%88Dead-Letter-Queue-DLQ%EF%BC%89%EF%BC%9F%E5%A6%82%E4%BD%95%E4%BD%BF%E7%94%A8%E5%AE%83%EF%BC%9F%E5%A6%82%E4%BD%95%E5%A4%84%E7%90%86%E5%A4%B1%E8%B4%A5%E7%9A%84%E6%B6%88%E6%81%AF%EF%BC%9F"><span class="nav-text">问：死信队列（Dead Letter Queue, DLQ）？如何使用它？如何处理失败的消息？</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E9%97%AE%EF%BC%9A%E6%AD%BB%E4%BF%A1%E9%98%9F%E5%88%97%E5%A6%82%E4%BD%95%E8%AE%BE%E7%BD%AE%E6%B6%88%E6%81%AF%E7%9A%84-TTL%EF%BC%88Time-to-Live%EF%BC%89%EF%BC%9F"><span class="nav-text">问：死信队列如何设置消息的 TTL（Time to Live）？</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E9%97%AE%EF%BC%9A%E5%BB%B6%E8%BF%9F%E9%98%9F%E5%88%97%EF%BC%9F"><span class="nav-text">问：延迟队列？</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E9%AB%98%E5%8F%AF%E7%94%A8%E4%B8%8E%E5%88%86%E5%B8%83%E5%BC%8F"><span class="nav-text">高可用与分布式</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E9%97%AE%EF%BC%9ARabbitMQ-%E7%9A%84%E9%95%9C%E5%83%8F%E9%98%9F%E5%88%97%EF%BC%88Mirrored-Queues%EF%BC%89%E6%98%AF%E4%BB%80%E4%B9%88%EF%BC%9F%E5%A6%82%E4%BD%95%E4%BD%BF%E7%94%A8%EF%BC%9F"><span class="nav-text">问：RabbitMQ 的镜像队列（Mirrored Queues）是什么？如何使用？</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E9%97%AE%EF%BC%9A%E4%BB%80%E4%B9%88%E6%98%AF-RabbitMQ-%E7%9A%84%E9%9B%86%E7%BE%A4%E6%A8%A1%E5%BC%8F%EF%BC%9F%E5%AE%83%E5%A6%82%E4%BD%95%E5%B7%A5%E4%BD%9C%EF%BC%9F"><span class="nav-text">问：什么是 RabbitMQ 的集群模式？它如何工作？</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#%E4%B8%80%E3%80%81%E9%9B%86%E7%BE%A4%E6%A0%B8%E5%BF%83%E6%9E%B6%E6%9E%84"><span class="nav-text">一、集群核心架构</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E4%BA%8C%E3%80%81%E9%9B%86%E7%BE%A4%E5%B7%A5%E4%BD%9C%E5%8E%9F%E7%90%86"><span class="nav-text">二、集群工作原理</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E4%B8%89%E3%80%81%E9%9B%86%E7%BE%A4%E6%A8%A1%E5%BC%8F%E5%AF%B9%E6%AF%94"><span class="nav-text">三、集群模式对比</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E5%9B%9B%E3%80%81%E9%95%9C%E5%83%8F%E9%98%9F%E5%88%97%E7%9A%84%E8%AF%A6%E7%BB%86%E6%B5%81%E7%A8%8B"><span class="nav-text">四、镜像队列的详细流程</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E4%BA%94%E3%80%81%E5%85%B3%E9%94%AE%E6%B3%A8%E6%84%8F%E4%BA%8B%E9%A1%B9"><span class="nav-text">五、关键注意事项</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E5%85%AD%E3%80%81%E6%9C%80%E4%BD%B3%E5%AE%9E%E8%B7%B5"><span class="nav-text">六、最佳实践</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E4%B8%83%E3%80%81%E6%89%A9%E5%B1%95%E6%96%B9%E6%A1%88"><span class="nav-text">七、扩展方案</span></a></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E9%97%AE%EF%BC%9A%E5%A6%82%E4%BD%95%E5%9C%A8-RabbitMQ-%E4%B8%AD%E9%85%8D%E7%BD%AE%E9%AB%98%E5%8F%AF%E7%94%A8%E9%98%9F%E5%88%97%EF%BC%9F%E9%95%9C%E5%83%8F%E9%98%9F%E5%88%97%EF%BC%88Mirrored-Queue%EF%BC%89-%E4%B8%8E-%E4%BB%B2%E8%A3%81%E9%98%9F%E5%88%97%EF%BC%88Quorum-Queues%EF%BC%89-%EF%BC%9FTODODODODOD"><span class="nav-text">问：如何在 RabbitMQ 中配置高可用队列？镜像队列（Mirrored Queue） 与 仲裁队列（Quorum Queues） ？TODODODODOD</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E9%97%AE%EF%BC%9AFederation%EF%BC%88%E8%81%94%E9%82%A6%E6%8F%92%E4%BB%B6%EF%BC%89%E4%B8%8EShovel%EF%BC%88%E9%93%B2%E5%AD%90%E6%8F%92%E4%BB%B6%EF%BC%89%EF%BC%9F"><span class="nav-text">问：Federation（联邦插件）与Shovel（铲子插件）？</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#%E4%B8%80-Federation"><span class="nav-text">一. Federation</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E4%BA%8C-Shovel"><span class="nav-text">二. Shovel</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E4%BA%8C%E8%80%85%E5%AF%B9%E6%AF%94"><span class="nav-text">二者对比</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E4%B8%8E%E9%9B%86%E7%BE%A4%E7%9A%84%E5%AF%B9%E6%AF%94"><span class="nav-text">与集群的对比</span></a></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E9%97%AE%EF%BC%9ARabbitMQ-%E5%A6%82%E4%BD%95%E5%AE%9E%E7%8E%B0%E6%B6%88%E6%81%AF%E7%9A%84%E9%AB%98%E5%8F%AF%E7%94%A8%E6%80%A7%EF%BC%9F%E5%A6%82%E4%BD%95%E4%BF%9D%E8%AF%81-RabbitMQ-%E6%B6%88%E6%81%AF%E7%9A%84%E5%8F%AF%E9%9D%A0%E6%80%A7%EF%BC%9F"><span class="nav-text">问：RabbitMQ 如何实现消息的高可用性？如何保证 RabbitMQ 消息的可靠性？</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E9%97%AE%EF%BC%9ARabbitMQ-%E4%B8%AD%E7%9A%84%E8%8A%82%E7%82%B9%E6%95%85%E9%9A%9C%E6%81%A2%E5%A4%8D%E6%9C%BA%E5%88%B6%E6%98%AF%E4%BB%80%E4%B9%88%EF%BC%9F"><span class="nav-text">问：RabbitMQ 中的节点故障恢复机制是什么？</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E9%97%AE%EF%BC%9ARabbitMQ-%E9%9B%86%E7%BE%A4%E4%B8%8E%E6%8B%93%E6%89%91%E5%A6%82%E4%BD%95%E8%AE%BE%E8%AE%A1%EF%BC%8C%E5%A6%82%E4%BD%95%E9%80%89%E6%8B%A9%E4%B8%BB%E6%9C%BA%E6%95%B0%E9%87%8F%EF%BC%9F"><span class="nav-text">问：RabbitMQ 集群与拓扑如何设计，如何选择主机数量？</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E9%97%AE%EF%BC%9A%E8%84%91%E8%A3%82%E9%97%AE%E9%A2%98%EF%BC%9F"><span class="nav-text">问：脑裂问题？</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%80%A7%E8%83%BD%E5%92%8C%E4%BC%98%E5%8C%96"><span class="nav-text">性能和优化</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E9%97%AE%EF%BC%9A%E5%A6%82%E4%BD%95%E4%BC%98%E5%8C%96-RabbitMQ-%E7%9A%84%E6%80%A7%E8%83%BD%EF%BC%9F"><span class="nav-text">问：如何优化 RabbitMQ 的性能？</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E9%97%AE%EF%BC%9ARabbitMQ-%E4%B8%AD%E7%9A%84%E6%85%A2%E6%B6%88%E8%B4%B9%E8%80%85%E6%98%AF%E4%BB%80%E4%B9%88%EF%BC%9F%E5%A6%82%E4%BD%95%E8%A7%A3%E5%86%B3%E6%85%A2%E6%B6%88%E8%B4%B9%E8%80%85%E9%97%AE%E9%A2%98%EF%BC%9F"><span class="nav-text">问：RabbitMQ 中的慢消费者是什么？如何解决慢消费者问题？</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E9%97%AE%EF%BC%9A%E5%A6%82%E4%BD%95%E9%98%B2%E6%AD%A2-RabbitMQ-%E4%B8%AD%E5%87%BA%E7%8E%B0%E6%B6%88%E6%81%AF%E5%A0%86%E7%A7%AF%E5%92%8C%E9%98%9F%E5%88%97%E7%88%86%E7%82%B8%EF%BC%9F"><span class="nav-text">问：如何防止 RabbitMQ 中出现消息堆积和队列爆炸？</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E9%97%AE%EF%BC%9A%E5%A6%82%E4%BD%95%E7%9B%91%E6%8E%A7-RabbitMQ-%E9%9B%86%E7%BE%A4%E7%9A%84%E6%80%A7%E8%83%BD%EF%BC%9F"><span class="nav-text">问：如何监控 RabbitMQ 集群的性能？</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E9%97%AE%EF%BC%9ARabbitMQ-%E5%A6%82%E4%BD%95%E9%85%8D%E7%BD%AE%E6%B5%81%E6%8E%A7%E6%9C%BA%E5%88%B6%EF%BC%88Flow-Control%EF%BC%89%E6%9D%A5%E9%98%B2%E6%AD%A2%E6%B6%88%E6%81%AF%E5%A0%86%E7%A7%AF%EF%BC%9F"><span class="nav-text">问：RabbitMQ 如何配置流控机制（Flow Control）来防止消息堆积？</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E9%97%AE%EF%BC%9A%E9%80%9A%E8%BF%87%E9%9B%86%E7%BE%A4%E6%9D%A5%E6%B2%BB%E7%90%86%E6%B6%88%E6%81%AF%E5%A0%86%E7%A7%AF%EF%BC%9F"><span class="nav-text">问：通过集群来治理消息堆积？</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%AE%9E%E8%B7%B5%E9%97%AE%E9%A2%98"><span class="nav-text">实践问题</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E9%97%AE%EF%BC%9A%E5%A6%82%E4%BD%95%E4%BF%9D%E8%AF%81-RabbitMQ-%E6%B6%88%E6%81%AF%E7%9A%84%E9%A1%BA%E5%BA%8F%E6%80%A7%EF%BC%9F"><span class="nav-text">问：如何保证 RabbitMQ 消息的顺序性？</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E9%97%AE%EF%BC%9A%E5%A6%82%E4%BD%95%E5%9C%A8-RabbitMQ-%E4%B8%AD%E5%AE%9E%E7%8E%B0%E6%B6%88%E6%81%AF%E4%BC%98%E5%85%88%E7%BA%A7%EF%BC%88Message-Priority%EF%BC%89%EF%BC%9F"><span class="nav-text">问：如何在 RabbitMQ 中实现消息优先级（Message Priority）？</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E9%97%AE%EF%BC%9A%E5%A6%82%E4%BD%95%E5%9C%A8-RabbitMQ-%E4%B8%AD%E5%AE%9E%E7%8E%B0%E6%B6%88%E6%81%AF%E7%9A%84%E5%BB%B6%E6%97%B6%E5%8F%91%E9%80%81%EF%BC%9F%E5%A6%82%E4%BD%95%E4%BD%BF%E7%94%A8-RabbitMQ-%E5%AE%9E%E7%8E%B0%E5%BB%B6%E6%97%B6%E6%B6%88%E6%81%AF%E9%98%9F%E5%88%97%EF%BC%9F"><span class="nav-text">问：如何在 RabbitMQ 中实现消息的延时发送？如何使用 RabbitMQ 实现延时消息队列？</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E9%97%AE%EF%BC%9A%E5%A6%82%E4%BD%95%E4%BD%BF%E7%94%A8-RabbitMQ-%E5%AE%9E%E7%8E%B0%E5%BC%82%E6%AD%A5%E4%BB%BB%E5%8A%A1%E5%A4%84%E7%90%86%EF%BC%9F"><span class="nav-text">问：如何使用 RabbitMQ 实现异步任务处理？</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E9%97%AE%EF%BC%9ARabbitMQ-%E5%A6%82%E4%BD%95%E4%B8%8E%E5%85%B6%E4%BB%96%E7%B3%BB%E7%BB%9F%EF%BC%88%E5%A6%82-Redis%E3%80%81Kafka%EF%BC%89%E9%9B%86%E6%88%90%EF%BC%9F"><span class="nav-text">问：RabbitMQ 如何与其他系统（如 Redis、Kafka）集成？</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E9%97%AE%EF%BC%9A%E5%A6%82%E4%BD%95%E5%9C%A8-RabbitMQ-%E4%B8%AD%E8%BF%9B%E8%A1%8C%E6%B6%88%E6%81%AF%E9%87%8D%E8%AF%95%EF%BC%9F"><span class="nav-text">问：如何在 RabbitMQ 中进行消息重试？</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E9%97%AE%EF%BC%9A%E5%A6%82%E4%BD%95%E9%98%B2%E6%AD%A2-RabbitMQ-%E4%B8%AD%E7%9A%84%E6%B6%88%E6%81%AF%E9%87%8D%E5%A4%8D%E6%B6%88%E8%B4%B9%EF%BC%9F"><span class="nav-text">问：如何防止 RabbitMQ 中的消息重复消费？</span></a></li></ol></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E7%AC%AC%E4%B8%80%E8%8A%82-%E5%BE%85%E6%95%B4%E7%90%86"><span class="nav-text">第一节 待整理</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E9%97%AE%EF%BC%9ARocketMQ%E7%9A%84%E7%89%B9%E7%82%B9%E6%9C%89%E5%93%AA%E4%BA%9B%EF%BC%9F"><span class="nav-text">问：RocketMQ的特点有哪些？</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E9%97%AE%EF%BC%9ARocketMQ-%E7%94%B1%E5%93%AA%E4%BA%9B%E8%A7%92%E8%89%B2%E7%BB%84%E6%88%90%EF%BC%9F"><span class="nav-text">问：RocketMQ 由哪些角色组成？</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E9%97%AE%EF%BC%9Arocketmq-%E7%9A%84%E6%A8%A1%E5%9D%97%E5%8A%9F%E8%83%BD%EF%BC%9F"><span class="nav-text">问：rocketmq 的模块功能？</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E9%97%AE%EF%BC%9Arocketmq-%E7%9A%84%E9%AB%98%E5%8F%AF%E7%94%A8%E5%8F%8A%E9%AB%98%E6%80%A7%E8%83%BD%EF%BC%9F"><span class="nav-text">问：rocketmq 的高可用及高性能？</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E9%97%AE%EF%BC%9A%E6%B6%88%E8%B4%B9%E8%80%85%E8%8E%B7%E5%8F%96%E6%B6%88%E6%81%AF%E6%9C%89%E5%87%A0%E7%A7%8D%E6%A8%A1%E5%BC%8F%EF%BC%9F"><span class="nav-text">问：消费者获取消息有几种模式？</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E9%97%AE%EF%BC%9A%E8%AF%B4%E8%AF%B4%E4%BD%A0%E5%AF%B9Consumer%E7%9A%84%E4%BA%86%E8%A7%A3%EF%BC%9F"><span class="nav-text">问：说说你对Consumer的了解？</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E9%97%AE%EF%BC%9A%E4%BB%8B%E7%BB%8D%E4%B8%8BKafka%EF%BC%9FKafka%E7%9A%84%E4%BC%98%E7%82%B9%EF%BC%9FKafka-%E7%9A%84%E8%AE%BE%E8%AE%A1%E6%98%AF%E4%BB%80%E4%B9%88%E6%A0%B7%E7%9A%84%E5%91%A2%EF%BC%9F"><span class="nav-text">问：介绍下Kafka？Kafka的优点？Kafka 的设计是什么样的呢？</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E9%97%AE%EF%BC%9A%E4%BB%80%E4%B9%88%E6%98%AF%E5%88%86%E5%B8%83%E5%BC%8F%E6%97%A5%E5%BF%97%E6%9E%B6%E6%9E%84%EF%BC%9FELK"><span class="nav-text">问：什么是分布式日志架构？ELK</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E9%97%AE%EF%BC%9A%E4%BB%80%E4%B9%88%E6%83%85%E5%86%B5%E4%BC%9A%E5%AF%BC%E8%87%B4Kafka%E8%BF%90%E8%A1%8C%E5%8F%98%E6%85%A2%EF%BC%9F"><span class="nav-text">问：什么情况会导致Kafka运行变慢？</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E9%97%AE%EF%BC%9A%E8%AF%B4%E4%B8%80%E4%B8%8BKafka%E6%B6%88%E8%B4%B9%E8%80%85%E6%B6%88%E8%B4%B9%E8%BF%87%E7%A8%8B%EF%BC%9FKafka%E7%9A%84%E6%B6%88%E8%B4%B9%E8%80%85%E5%A6%82%E4%BD%95%E6%B6%88%E8%B4%B9%E6%95%B0%E6%8D%AE%EF%BC%9F"><span class="nav-text">问：说一下Kafka消费者消费过程？Kafka的消费者如何消费数据？</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E9%97%AE%EF%BC%9AKafka%E6%96%B0%E5%BB%BA%E7%9A%84%E5%88%86%E5%8C%BA%E4%BC%9A%E5%9C%A8%E5%93%AA%E4%B8%AA%E7%9B%AE%E5%BD%95%E4%B8%8B%E5%88%9B%E5%BB%BA%EF%BC%9F"><span class="nav-text">问：Kafka新建的分区会在哪个目录下创建？</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E9%97%AE%EF%BC%9AKafka-%E4%B8%8E%E4%BC%A0%E7%BB%9F%E6%B6%88%E6%81%AF%E7%B3%BB%E7%BB%9F%E4%B9%8B%E9%97%B4%E6%9C%89%E4%B8%89%E4%B8%AA%E5%85%B3%E9%94%AE%E5%8C%BA%E5%88%AB%EF%BC%9F"><span class="nav-text">问：Kafka 与传统消息系统之间有三个关键区别？</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E9%97%AE%EF%BC%9A%E8%AF%B7%E8%AF%A6%E7%BB%86%E8%AF%B4%E4%B8%80%E4%B8%8B%E6%8E%A8%E9%80%81%E6%A8%A1%E5%BC%8F%E5%92%8C%E6%8B%89%E5%8F%96%E6%A8%A1%E5%BC%8F%EF%BC%9F"><span class="nav-text">问：请详细说一下推送模式和拉取模式？</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E9%97%AE%EF%BC%9A-kafka%E6%B6%88%E6%81%AF%E5%8F%91%E9%80%81%E7%9A%84%E5%8F%AF%E9%9D%A0%E6%80%A7%E6%9C%BA%E5%88%B6%E6%9C%89%E5%87%A0%E7%A7%8D%EF%BC%9F"><span class="nav-text">问： kafka消息发送的可靠性机制有几种？</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E9%97%AE%EF%BC%9A%E5%88%86%E5%B8%83%E5%BC%8F%E5%A4%8D%E5%88%B6%E4%B8%8E%E4%BC%A0%E7%BB%9F%E6%84%8F%E4%B9%89%E4%B8%8A%E7%9A%84%E6%B6%88%E6%81%AF%E7%A1%AE%E8%AE%A4%E6%9C%BA%E5%88%B6"><span class="nav-text">问：分布式复制与传统意义上的消息确认机制</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%80%BB%E7%BB%93"><span class="nav-text">总结</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E9%97%AE%EF%BC%9AKafka%E5%A6%82%E4%BD%95%E5%88%A4%E6%96%AD%E4%B8%80%E4%B8%AA%E8%8A%82%E7%82%B9%E6%98%AF%E5%90%A6%E5%AD%98%E6%B4%BB%EF%BC%9F"><span class="nav-text">问：Kafka如何判断一个节点是否存活？</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E9%97%AE%EF%BC%9AKafka-%E6%95%B0%E6%8D%AE%E5%AD%98%E5%82%A8%E8%AE%BE%E8%AE%A1%EF%BC%9F"><span class="nav-text">问：Kafka 数据存储设计？</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E9%97%AE%EF%BC%9A%E4%B8%BA%E4%BD%95%E9%9C%80%E8%A6%81Kafka%E9%9B%86%E7%BE%A4%EF%BC%9F"><span class="nav-text">问：为何需要Kafka集群？</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E9%97%AE%EF%BC%9Akafka-%E5%90%8C%E6%97%B6%E8%AE%BE%E7%BD%AE%E4%BA%86-7-%E5%A4%A9%E5%92%8C-10G-%E6%B8%85%E9%99%A4%E6%95%B0%E6%8D%AE%EF%BC%8C%E5%88%B0%E7%AC%AC%E4%BA%94%E5%A4%A9%E7%9A%84%E6%97%B6%E5%80%99%E6%B6%88%E6%81%AF%E8%BE%BE%E5%88%B0%E4%BA%86-10G%EF%BC%8C%E8%BF%99%E4%B8%AA%E6%97%B6%E5%80%99-kafka%E5%B0%86%E5%A6%82%E4%BD%95%E5%A4%84%E7%90%86%EF%BC%9F"><span class="nav-text">问：kafka 同时设置了 7 天和 10G 清除数据，到第五天的时候消息达到了 10G，这个时候 kafka将如何处理？</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E9%97%AE%EF%BC%9A%E5%A6%82%E4%BD%95%E4%BF%9D%E9%9A%9C%E6%B6%88%E6%81%AF100-%E6%8A%95%E9%80%92%E6%88%90%E5%8A%9F%E3%80%81%E6%B6%88%E6%81%AF%E5%B9%82%E7%AD%89%E6%80%A7%EF%BC%9F"><span class="nav-text">问：如何保障消息100%投递成功、消息幂等性？</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#%E4%B8%80%E3%80%81%E7%94%9F%E4%BA%A7%E8%80%85%E7%AB%AF%EF%BC%9A%E7%A1%AE%E4%BF%9D%E6%B6%88%E6%81%AF%E5%8F%AF%E9%9D%A0%E5%8F%91%E5%87%BA"><span class="nav-text">一、生产者端：确保消息可靠发出</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E4%BA%8C%E3%80%81Broker%E7%AB%AF%EF%BC%9A%E7%A1%AE%E4%BF%9D%E6%B6%88%E6%81%AF%E6%8C%81%E4%B9%85%E5%8C%96"><span class="nav-text">二、Broker端：确保消息持久化</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E4%B8%89%E3%80%81%E6%B6%88%E8%B4%B9%E8%80%85%E7%AB%AF%EF%BC%9A%E7%A1%AE%E4%BF%9D%E5%8F%AF%E9%9D%A0%E5%A4%84%E7%90%86"><span class="nav-text">三、消费者端：确保可靠处理</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E5%9B%9B%E3%80%81%E8%A1%A5%E5%81%BF%E6%9C%BA%E5%88%B6%EF%BC%9A%E6%9C%80%E7%BB%88%E4%B8%80%E8%87%B4%E6%80%A7%E4%BF%9D%E9%9A%9C"><span class="nav-text">四、补偿机制：最终一致性保障</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E4%BA%94%E3%80%81%E5%85%A8%E9%93%BE%E8%B7%AF%E5%8E%8B%E6%B5%8B%E6%96%B9%E6%A1%88"><span class="nav-text">五、全链路压测方案</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E5%85%AD%E3%80%81%E4%B8%8D%E5%90%8C%E5%9C%BA%E6%99%AF%E7%9A%84%E5%8F%AF%E9%9D%A0%E6%80%A7%E6%9D%83%E8%A1%A1"><span class="nav-text">六、不同场景的可靠性权衡</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E4%B8%83%E3%80%81%E6%B3%A8%E6%84%8F%E4%BA%8B%E9%A1%B9"><span class="nav-text">七、注意事项</span></a></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E9%97%AE%EF%BC%9A%E6%B5%B7%E9%87%8F%E8%AE%A2%E5%8D%95%E4%BA%A7%E7%94%9F%E7%9A%84%E4%B8%9A%E5%8A%A1%E9%AB%98%E5%B3%B0%E6%9C%9F%EF%BC%8C%E5%A6%82%E4%BD%95%E9%81%BF%E5%85%8D%E6%B6%88%E6%81%AF%E7%9A%84%E9%87%8D%E5%A4%8D%E6%B6%88%E8%B4%B9%EF%BC%9F"><span class="nav-text">问：海量订单产生的业务高峰期，如何避免消息的重复消费？</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#%F0%9F%93%8C-1-%E6%B6%88%E6%81%AF%E5%8E%BB%E9%87%8D%E6%9C%BA%E5%88%B6"><span class="nav-text">📌 1. 消息去重机制</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%F0%9F%93%8C-2-%E6%B6%88%E6%81%AF%E5%8E%BB%E9%87%8DID"><span class="nav-text">📌 2. 消息去重ID</span></a></li></ol></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#MQ%E6%B6%88%E6%81%AF%E5%BC%80%E5%90%AFTrace"><span class="nav-text">MQ消息开启Trace</span></a></li></ol></li></ol></li></ol></div>
        </div>
        <!--/noindex-->

        <div class="site-overview-wrap sidebar-panel">
          <div class="site-overview">
            <div class="site-author site-overview-item animated" itemprop="author" itemscope itemtype="http://schema.org/Person">
    <img class="site-author-image" itemprop="image" alt="Lys"
      src="https://pic-1258215793.cos.ap-shanghai.myqcloud.com/cover/IMG_0759.JPG">
  <p class="site-author-name" itemprop="name">Lys</p>
  <div class="site-description" itemprop="description">记录编程点滴，写点生活中的酸甜</div>
</div>
<div class="site-state-wrap site-overview-item animated">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
          <a href="/archives/">
        
          <span class="site-state-item-count">340</span>
          <span class="site-state-item-name">日志</span>
        </a>
      </div>
      <div class="site-state-item site-state-categories">
            <a href="/categories/">
          
        <span class="site-state-item-count">13</span>
        <span class="site-state-item-name">分类</span></a>
      </div>
      <div class="site-state-item site-state-tags">
            <a href="/tags/">
          
        <span class="site-state-item-count">113</span>
        <span class="site-state-item-name">标签</span></a>
      </div>
  </nav>
</div>
  <div class="links-of-author site-overview-item animated">
      <span class="links-of-author-item">
        <a href="https://github.com/LAILAIWA" title="GitHub → https:&#x2F;&#x2F;github.com&#x2F;LAILAIWA" rel="noopener" target="_blank"><i class="fab fa-github fa-fw"></i>GitHub</a>
      </span>
      <span class="links-of-author-item">
        <a href="mailto:linyishui168@outlook.com" title="E-Mail → mailto:linyishui168@outlook.com" rel="noopener" target="_blank"><i class="fa fa-envelope fa-fw"></i>E-Mail</a>
      </span>
      <span class="links-of-author-item">
        <a href="https://weibo.com/u/5340162234" title="Weibo → https:&#x2F;&#x2F;weibo.com&#x2F;u&#x2F;5340162234" rel="noopener" target="_blank"><i class="fab fa-weibo fa-fw"></i>Weibo</a>
      </span>
      <span class="links-of-author-item">
        <a href="https://twitter.com/linyishui618" title="Twitter → https:&#x2F;&#x2F;twitter.com&#x2F;linyishui618" rel="noopener" target="_blank"><i class="fab fa-twitter fa-fw"></i>Twitter</a>
      </span>
      <span class="links-of-author-item">
        <a href="https://stackoverflow.com/users/13018339/lin-yishui" title="StackOverflow → https:&#x2F;&#x2F;stackoverflow.com&#x2F;users&#x2F;13018339&#x2F;lin-yishui" rel="noopener" target="_blank"><i class="fab fa-stack-overflow fa-fw"></i>StackOverflow</a>
      </span>
      <span class="links-of-author-item">
        <a href="https://instagram.com/linyishui618" title="Instagram → https:&#x2F;&#x2F;instagram.com&#x2F;linyishui618" rel="noopener" target="_blank"><i class="fab fa-instagram fa-fw"></i>Instagram</a>
      </span>
  </div>
  <div class="cc-license site-overview-item animated" itemprop="license">
    <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/deed.zh" class="cc-opacity" rel="noopener" target="_blank"><img src="https://cdn.jsdelivr.net/npm/@creativecommons/vocabulary@2020.11.3/assets/license_badges/small/by_nc_sa.svg" alt="Creative Commons"></a>
  </div>


  <div class="links-of-blogroll site-overview-item animated">
    <div class="links-of-blogroll-title"><i class="far fa-smile-wink fa-fw"></i>
      个人
    </div>
    <ul class="links-of-blogroll-list">
        <li class="links-of-blogroll-item">
          <a href="https://music.163.com/#/user/home?id=68425607" title="https:&#x2F;&#x2F;music.163.com&#x2F;#&#x2F;user&#x2F;home?id&#x3D;68425607" rel="noopener" target="_blank">网易云音乐</a>
        </li>
    </ul>
  </div>

          </div>
        </div>
    </div>
  </aside>
  <div class="sidebar-dimmer"></div>


    </header>

    
  <div class="back-to-top" role="button" aria-label="返回顶部">
    <i class="fa fa-arrow-up"></i>
    <span>0%</span>
  </div>
  <a role="button" class="book-mark-link book-mark-link-fixed"></a>

  <a href="https://github.com/LAILAIWA" class="github-corner" title="Follow me on GitHub" aria-label="Follow me on GitHub" rel="noopener" target="_blank"><svg width="80" height="80" viewBox="0 0 250 250" aria-hidden="true"><path d="M0,0 L115,115 L130,115 L142,142 L250,250 L250,0 Z"></path><path d="M128.3,109.0 C113.8,99.7 119.0,89.6 119.0,89.6 C122.0,82.7 120.5,78.6 120.5,78.6 C119.2,72.0 123.4,76.3 123.4,76.3 C127.3,80.9 125.5,87.3 125.5,87.3 C122.9,97.6 130.6,101.9 134.4,103.2" fill="currentColor" style="transform-origin: 130px 106px;" class="octo-arm"></path><path d="M115.0,115.0 C114.9,115.1 118.7,116.5 119.8,115.4 L133.7,101.6 C136.9,99.2 139.9,98.4 142.2,98.6 C133.8,88.0 127.5,74.4 143.8,58.0 C148.5,53.4 154.0,51.2 159.7,51.0 C160.3,49.4 163.2,43.6 171.4,40.1 C171.4,40.1 176.1,42.5 178.8,56.2 C183.1,58.6 187.2,61.8 190.9,65.4 C194.5,69.0 197.7,73.2 200.1,77.6 C213.8,80.2 216.3,84.9 216.3,84.9 C212.7,93.1 206.9,96.0 205.4,96.6 C205.1,102.4 203.0,107.8 198.3,112.5 C181.9,128.9 168.3,122.5 157.7,114.1 C157.9,116.9 156.7,120.9 152.7,124.9 L141.0,136.5 C139.8,137.7 141.6,141.9 141.8,141.8 Z" fill="currentColor" class="octo-body"></path></svg></a>

<noscript>
  <div class="noscript-warning">Theme NexT works best with JavaScript enabled</div>
</noscript>


    <div class="main-inner post posts-expand">


  


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://linyishui.top/2020050201.html">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="https://pic-1258215793.cos.ap-shanghai.myqcloud.com/cover/IMG_0759.JPG">
      <meta itemprop="name" content="Lys">
      <meta itemprop="description" content="记录编程点滴，写点生活中的酸甜">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="俺的部落格">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          面试整理——MQ
        </h1>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>

      <time title="创建时间：2020-05-02 18:45:03" itemprop="dateCreated datePublished" datetime="2020-05-02T18:45:03+08:00">2020-05-02</time>
    </span>
      <span class="post-meta-item">
        <span class="post-meta-item-icon">
          <i class="far fa-calendar-check"></i>
        </span>
        <span class="post-meta-item-text">更新于</span>
        <time title="修改时间：2025-02-21 23:14:44" itemprop="dateModified" datetime="2025-02-21T23:14:44+08:00">2025-02-21</time>
      </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">分类于</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/%E9%9D%A2%E8%AF%95%E6%95%B4%E7%90%86/" itemprop="url" rel="index"><span itemprop="name">面试整理</span></a>
        </span>
    </span>

  
      </div>
      <div class="post-meta">
    <span class="post-meta-item" title="本文字数">
      <span class="post-meta-item-icon">
        <i class="far fa-file-word"></i>
      </span>
      <span class="post-meta-item-text">本文字数：</span>
      <span>108k</span>
    </span>
    <span class="post-meta-item" title="阅读时长">
      <span class="post-meta-item-icon">
        <i class="far fa-clock"></i>
      </span>
      <span class="post-meta-item-text">阅读时长 &asymp;</span>
      <span>1:38</span>
    </span>
</div>

            <div class="post-description">整理面试中常问的MQ相关问题，持续更新中。</div>
        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
        <h1 id="MQ"><a href="#MQ" class="headerlink" title="MQ"></a>MQ</h1><h2 id="消息队列"><a href="#消息队列" class="headerlink" title="消息队列"></a>消息队列</h2><h4 id="问：为什么使用消息队列？消息队列的使用场景-作用？"><a href="#问：为什么使用消息队列？消息队列的使用场景-作用？" class="headerlink" title="问：为什么使用消息队列？消息队列的使用场景/作用？"></a>问：为什么使用消息队列？消息队列的使用场景/作用？</h4><p>为什么使用消息队列？</p>
<ol>
<li><strong>解耦（Decoupling）</strong><ul>
<li><strong>问题</strong>：如果系统之间高度耦合，A系统直接调用B系统，修改B系统时，A系统也需要调整，影响开发效率。</li>
<li><strong>解决</strong>：引入MQ后，A系统只需向队列发送消息，不关心B系统的实现，提升了模块的独立性和扩展性。</li>
<li><strong>示例</strong>：订单系统与库存系统解耦，订单创建后发送消息，库存系统根据消息进行扣减。</li>
</ul>
</li>
<li><strong>异步处理（Asynchronous Processing）</strong><ul>
<li><strong>问题</strong>：某些耗时操作（如发送邮件、生成报表）会阻塞主业务流程，降低系统性能。</li>
<li><strong>解决</strong>：使用MQ进行异步处理，主业务完成后立即响应，耗时操作在后台执行。</li>
<li><strong>示例</strong>：用户下单后，立即返回“下单成功”，通知服务异步发送短信。</li>
</ul>
</li>
<li><strong>削峰填谷（Traffic Shaping）</strong><ul>
<li><strong>问题</strong>：在高并发场景下，直接处理请求可能导致系统崩溃或性能瓶颈。</li>
<li><strong>解决</strong>：MQ作为缓冲层，削峰填谷，平衡系统的生产和消费速度，防止系统过载。</li>
<li><strong>示例</strong>：秒杀场景中，订单请求先写入MQ，后续慢慢消费，避免数据库压力过大。</li>
</ul>
</li>
<li><strong>数据可靠传输（Reliable Delivery）</strong><ul>
<li><strong>问题</strong>：在分布式系统中，网络异常、系统崩溃可能导致数据丢失。</li>
<li><strong>解决</strong>：MQ通常提供消息持久化、重试机制、确认机制，确保消息不丢失、不重复。</li>
<li><strong>示例</strong>：支付系统确保消息可靠送达，避免丢失订单。</li>
</ul>
</li>
</ol>
<p>场景：</p>
<p><strong>订单系统</strong></p>
<ul>
<li>下单成功后，异步通知库存、物流、用户短信等服务。</li>
</ul>
<p><strong>日志收集</strong></p>
<ul>
<li>大规模日志通过MQ汇总，异步存储到ES、HDFS等系统，提升写入效率。</li>
</ul>
<p><strong>用户行为分析</strong></p>
<ul>
<li>记录用户行为（点击、浏览）到MQ，离线批处理或实时分析。</li>
</ul>
<p><strong>支付系统</strong></p>
<ul>
<li>异步处理支付结果，确保支付状态一致性，保证消息可靠投递。</li>
</ul>
<p><strong>搜索引擎</strong></p>
<ul>
<li>数据变更时通过MQ更新索引，保持搜索引擎与数据库数据同步。</li>
</ul>
<p><strong>视频处理</strong></p>
<ul>
<li>视频上传后，异步触发转码、审核、通知，提升响应速度。</li>
</ul>
<h4 id="问：消息队列的优缺点？"><a href="#问：消息队列的优缺点？" class="headerlink" title="问：消息队列的优缺点？"></a>问：消息队列的优缺点？</h4><p>✅ <strong>一、消息队列的优点</strong></p>
<ol>
<li><strong>解耦（Decoupling）</strong></li>
</ol>
<ul>
<li><strong>优势</strong>：各系统模块之间可以通过消息进行通信，避免直接调用，降低系统耦合度，便于扩展和维护。</li>
<li><strong>示例</strong>：订单系统与库存系统解耦，订单服务只需向MQ发送消息，不关心库存服务的实现。</li>
</ul>
<ol start="2">
<li><strong>异步处理（Asynchronous Processing）</strong></li>
</ol>
<ul>
<li><strong>优势</strong>：适用于耗时操作（如短信通知、邮件发送、图片处理），避免主线程阻塞，提升系统吞吐量和用户响应速度。</li>
<li><strong>示例</strong>：用户下单后，立即返回“下单成功”，短信通知通过MQ异步发送。</li>
</ul>
<ol start="3">
<li><strong>削峰填谷（Traffic Shaping）</strong></li>
</ol>
<ul>
<li><strong>优势</strong>：应对流量突增，MQ作为缓冲区，平滑流量，避免系统崩溃。</li>
<li><strong>示例</strong>：双十一秒杀，订单请求先写入MQ，后台慢慢消费，保护数据库。</li>
</ul>
<ol start="4">
<li><strong>数据可靠性（Reliability）</strong></li>
</ol>
<ul>
<li><strong>优势</strong>：支持消息持久化、消息确认（ACK）、失败重试、死信队列，确保消息不丢失、不重复、不乱序。</li>
<li><strong>示例</strong>：支付系统通过RabbitMQ的<strong>发布确认机制</strong>，确保支付结果可靠传输。</li>
</ul>
<ol start="5">
<li><strong>扩展性（Scalability）</strong></li>
</ol>
<ul>
<li><strong>优势</strong>：支持多消费者、多队列扩展，可轻松增加节点来提升处理能力。</li>
<li><strong>示例</strong>：Kafka采用分区（Partition）机制，支持多Consumer Group并行消费，适配大数据场景。</li>
</ul>
<p>✅ <strong>二、消息队列的缺点</strong></p>
<ol>
<li><strong>系统复杂度增加</strong></li>
</ol>
<ul>
<li><strong>问题</strong>：引入MQ后，架构更复杂，需处理消息顺序、重复消费、丢失、消息积压等问题，增加开发和维护成本。</li>
<li><strong>示例</strong>：分布式事务需使用MQ实现<strong>事务补偿</strong>（如RocketMQ的<strong>事务消息</strong>）。</li>
</ul>
<ol start="2">
<li><strong>消息可靠性挑战</strong></li>
</ol>
<ul>
<li><strong>问题</strong>：尽管MQ支持消息持久化和重试，但若配置不当，仍可能丢失或重复消息，需设计<strong>幂等性</strong>机制。</li>
<li><strong>示例</strong>：订单服务需对消息ID去重，防止重复扣库存。</li>
</ul>
<ol start="3">
<li><strong>延迟问题</strong></li>
</ol>
<ul>
<li><strong>问题</strong>：消息从生产到消费存在一定延迟，影响实时性。</li>
<li><strong>示例</strong>：金融系统需低延迟，Kafka强一致性模式比直连调用慢。</li>
</ul>
<ol start="4">
<li><strong>运维成本高</strong></li>
</ol>
<ul>
<li><strong>问题</strong>：MQ涉及主从同步、数据备份、故障恢复、监控报警，运维复杂且资源消耗大。</li>
<li><strong>示例</strong>：Kafka的ISR（In-Sync Replicas）机制需监控同步副本，防止数据不一致。</li>
</ul>
<ol start="5">
<li><strong>一致性与事务复杂</strong></li>
</ol>
<ul>
<li><strong>问题</strong>：跨系统的分布式事务不再由数据库管理，需使用MQ实现事务一致性，常用<strong>事务消息</strong>或<strong>最终一致性</strong>方案。</li>
<li><strong>示例</strong>：订单扣款与库存更新需采用<strong>TCC事务</strong>或RocketMQ的<strong>半消息</strong>方案。</li>
</ul>
<p>✅ <strong>三、总结对比表</strong></p>
<table>
<thead>
<tr>
<th><strong>维度</strong></th>
<th><strong>优点</strong></th>
<th><strong>缺点</strong></th>
</tr>
</thead>
<tbody><tr>
<td><strong>解耦</strong></td>
<td>降低系统依赖，增强扩展性</td>
<td>系统间依赖消息协议，需管理消息版本</td>
</tr>
<tr>
<td><strong>异步</strong></td>
<td>提升响应速度，适配耗时操作</td>
<td>复杂业务需保证操作的有序性和一致性</td>
</tr>
<tr>
<td><strong>削峰填谷</strong></td>
<td>缓冲流量高峰，保护数据库</td>
<td>消息积压需监控，超时消息可能丢失</td>
</tr>
<tr>
<td><strong>数据可靠性</strong></td>
<td>持久化、ACK、重试，保障消息传递</td>
<td>网络抖动、磁盘故障仍可能导致消息丢失</td>
</tr>
<tr>
<td><strong>扩展性</strong></td>
<td>支持多节点扩展，适配大流量、高并发</td>
<td>扩展需考虑消息顺序与分区策略</td>
</tr>
<tr>
<td><strong>事务一致性</strong></td>
<td>通过MQ实现分布式事务，保证最终一致性</td>
<td>需额外实现TCC、事务消息，复杂度高</td>
</tr>
<tr>
<td><strong>运维复杂性</strong></td>
<td>支持监控与报警，保证系统可用性</td>
<td>需监控队列积压、消费者状态、重试策略</td>
</tr>
</tbody></table>
<p>✅ <strong>加分回答：如何优化消息队列的缺点？</strong></p>
<ol>
<li><strong>消息丢失</strong>：<ul>
<li>RabbitMQ开启**持久化（Persistent Messages）**和**发布确认（Publisher Confirm）**。</li>
<li>Kafka使用<strong>ISR</strong>和<strong>acks=-1</strong>确保多副本持久化。</li>
</ul>
</li>
<li><strong>重复消费</strong>：<ul>
<li>业务层实现<strong>幂等性</strong>，例如基于消息ID或业务ID去重。</li>
</ul>
</li>
<li><strong>消息积压</strong>：<ul>
<li>提升<strong>消费者并发数</strong>、<strong>扩展分区</strong>，或设置<strong>死信队列（DLQ）</strong>。</li>
<li>Kafka场景下，使用<strong>Consumer Group</strong>水平扩展消费能力。</li>
</ul>
</li>
<li><strong>分布式事务</strong>：<ul>
<li>使用<strong>TCC模式</strong>、<strong>RocketMQ事务消息</strong>或<strong>Seata</strong>框架实现事务一致性。</li>
</ul>
</li>
</ol>
<h4 id="问：常见消息队列对比？"><a href="#问：常见消息队列对比？" class="headerlink" title="问：常见消息队列对比？"></a>问：常见消息队列对比？</h4><p>在Java开发中，常见的消息队列有 <strong>ActiveMQ、RabbitMQ、RocketMQ、Kafka</strong>，每种消息队列各有特点，适用于不同的业务场景。在面试中，掌握它们的<strong>架构特点、性能对比、使用场景</strong>是加分项。</p>
<p>✅ <strong>一、消息队列概览</strong></p>
<table>
<thead>
<tr>
<th>特性</th>
<th><strong>ActiveMQ</strong></th>
<th><strong>RabbitMQ</strong></th>
<th><strong>RocketMQ</strong></th>
<th><strong>Kafka</strong></th>
</tr>
</thead>
<tbody><tr>
<td><strong>开发语言</strong></td>
<td>Java</td>
<td>Erlang</td>
<td>Java</td>
<td>Scala + Java</td>
</tr>
<tr>
<td><strong>协议支持</strong></td>
<td>JMS（Java Message Service）</td>
<td>AMQP（Advanced Message Queuing）</td>
<td>自研协议（基于TCP/IP）</td>
<td>自研协议（基于TCP/IP）</td>
</tr>
<tr>
<td><strong>消息模型</strong></td>
<td>点对点（P2P）、发布/订阅（Pub/Sub）</td>
<td>发布/订阅、路由、RPC</td>
<td>顺序消息、事务消息、延迟消息</td>
<td>基于日志的发布/订阅模式</td>
</tr>
<tr>
<td><strong>持久化</strong></td>
<td>JDBC、KahaDB（性能下降）</td>
<td>Mnesia（内存数据库）、磁盘持久化</td>
<td>文件存储（CommitLog + ConsumeQueue）</td>
<td>文件系统（Segment Log）</td>
</tr>
<tr>
<td><strong>事务支持</strong></td>
<td>支持</td>
<td>支持</td>
<td>支持本地事务、分布式事务（事务消息）</td>
<td>不支持传统事务，依赖于Producer端幂等</td>
</tr>
<tr>
<td><strong>性能</strong></td>
<td>中等，吞吐量适中（6000/单机）</td>
<td>中等，适合中小型业务（12000/单机）</td>
<td>高吞吐、低延迟，适配分布式大规模消息（10W/单机）</td>
<td>极高吞吐，适配大数据、实时计算（100W/单机）</td>
</tr>
<tr>
<td><strong>消息顺序</strong></td>
<td>支持</td>
<td>支持</td>
<td>支持严格顺序（全局或分区有序）</td>
<td>支持分区级顺序，不能保证全局顺序</td>
</tr>
<tr>
<td><strong>消费方式</strong></td>
<td>推模式（Push）</td>
<td>推拉都支持。官方推荐使用推模式</td>
<td>拉/推模式可选</td>
<td>拉模式（Pull）</td>
</tr>
<tr>
<td><strong>扩展性</strong></td>
<td>一般，主从架构</td>
<td>一般，节点扩展需额外配置</td>
<td>高扩展性，分布式架构</td>
<td>极高扩展性，分布式架构</td>
</tr>
<tr>
<td><strong>使用场景</strong></td>
<td>轻量级、Java应用、企业级应用（缺乏大规模运用、不推荐）</td>
<td>小型系统、金融、复杂路由、RPC调用（集群不支持动态扩展）</td>
<td>电商、支付、事务消息、海量消息、日志处理（性能好，但只能java）</td>
<td>日志收集、大数据、实时流、行为分析（天生分布式、性能最佳、大数据支持、运维难度大、带宽有一定要求）</td>
</tr>
</tbody></table>
<p>✅ <strong>二、核心特点与适用场景</strong></p>
<p>1️⃣ <strong>ActiveMQ</strong></p>
<ul>
<li><strong>架构特点</strong>：<ul>
<li>支持多种协议（JMS、AMQP、MQTT、STOMP）。</li>
<li>使用 <strong>KahaDB</strong> 进行消息持久化，支持 JDBC 方式持久化到数据库。</li>
<li>提供 <strong>主从模式（Master-Slave）</strong>，可实现高可用。</li>
</ul>
</li>
<li><strong>优点</strong>：<ul>
<li><strong>轻量级</strong>，适合中小型 Java 系统，易于集成。</li>
<li>支持 <strong>JMS 标准</strong>，与 Java EE 应用兼容性好。</li>
<li>提供事务、死信队列、消息重试、消息过滤等高级特性。</li>
</ul>
</li>
<li><strong>缺点</strong>：<ul>
<li>性能较差，吞吐量低，<strong>并发场景下容易出现瓶颈</strong>。</li>
<li><strong>扩展性一般</strong>，不适合大规模分布式部署。</li>
</ul>
</li>
<li><strong>使用场景</strong>：<ul>
<li>小型企业系统、简单消息传递、<strong>Java EE 系统</strong>。</li>
<li><strong>异步任务</strong>（如邮件、通知）、低流量场景。</li>
</ul>
</li>
</ul>
<p>2️⃣ <strong>RabbitMQ</strong></p>
<ul>
<li><strong>架构特点</strong>：<ul>
<li>基于 <strong>AMQP（高级消息队列协议）</strong>，消息模型灵活（Direct、Topic、Fanout、Headers）。</li>
<li><strong>Erlang</strong> 语言开发，原生支持高并发，消息存储采用 <strong>Mnesia</strong>。</li>
</ul>
</li>
<li><strong>优点</strong>：<ul>
<li><strong>消息路由复杂</strong>，支持多种消息模型（如 Topic、Fanout）。</li>
<li>支持<strong>延迟消息</strong>、<strong>消息优先级</strong>，<strong>确认机制（ACK）</strong>，确保消息可靠传输。</li>
<li><strong>插件机制</strong>丰富，可扩展性强，支持监控、管理。</li>
</ul>
</li>
<li><strong>缺点</strong>：<ul>
<li><strong>消息积压</strong>严重时性能会下降，磁盘 I/O 成为瓶颈。</li>
<li><strong>集群管理复杂</strong>，RabbitMQ Cluster 需要精细管理节点状态。</li>
</ul>
</li>
<li><strong>使用场景</strong>：<ul>
<li>复杂的<strong>业务解耦</strong>、<strong>异步消息</strong>、<strong>RPC 调用</strong>（如订单、库存、通知系统）。</li>
<li>需要<strong>多种消息模式</strong>，如 <strong>广播</strong>、<strong>分组</strong>、<strong>延迟队列</strong>的场景。</li>
</ul>
</li>
</ul>
<p>3️⃣ <strong>RocketMQ</strong></p>
<ul>
<li><strong>架构特点</strong>：<ul>
<li>阿里巴巴开源，<strong>分布式队列</strong>，适配海量消息处理。</li>
<li>消息存储采用<strong>CommitLog</strong>，多副本实现高可用。</li>
<li>支持<strong>事务消息</strong>、<strong>定时消息</strong>、<strong>顺序消息</strong>，适配复杂业务需求。</li>
</ul>
</li>
<li><strong>优点</strong>：<ul>
<li><strong>高性能</strong>，适配大数据量、高并发。</li>
<li>支持<strong>事务消息</strong>（TCC 事务、两阶段提交）。</li>
<li>消息存储使用 <strong>零拷贝</strong>，高效读写。</li>
</ul>
</li>
<li><strong>缺点</strong>：<ul>
<li>生态相对较弱，使用场景较窄。</li>
<li><strong>学习成本高</strong>，配置复杂，需深入理解其<strong>事务消息</strong>实现。</li>
</ul>
</li>
<li><strong>使用场景</strong>：<ul>
<li><strong>金融支付</strong>、<strong>订单系统</strong>，需要<strong>事务一致性</strong>的场景。</li>
<li><strong>延迟消息</strong>、<strong>顺序消息</strong>（如物流跟踪、订单处理）。</li>
</ul>
</li>
</ul>
<p>4️⃣ <strong>Kafka</strong></p>
<ul>
<li><strong>架构特点</strong>：<ul>
<li><strong>高吞吐</strong>、<strong>高扩展</strong>，设计为分布式日志系统，支持<strong>Producer-Consumer</strong>模式。</li>
<li>消息持久化采用<strong>分段日志（Segment Log）</strong>，高效读写，基于<strong>零拷贝</strong>技术提升性能。</li>
</ul>
</li>
<li><strong>优点</strong>：<ul>
<li><strong>极高吞吐量</strong>，百万级消息/秒，适配<strong>大数据</strong>、<strong>流处理</strong>。</li>
<li>支持<strong>多消费者组（Consumer Group）</strong>，消息重复消费。</li>
<li><strong>水平扩展性强</strong>，分区模型方便动态扩容。</li>
</ul>
</li>
<li><strong>缺点</strong>：<ul>
<li>不支持<strong>事务消息</strong>，仅能保证<strong>分区顺序</strong>，不能保证全局顺序。</li>
<li>消费模型为<strong>Pull</strong>，需要消费者主动拉取，实时性稍弱。</li>
</ul>
</li>
<li><strong>使用场景</strong>：<ul>
<li><strong>大数据</strong>、<strong>日志系统</strong>（如ELK）、<strong>实时流处理</strong>。</li>
<li><strong>用户行为分析</strong>、<strong>监控数据</strong>，需要高吞吐的场景。</li>
</ul>
</li>
</ul>
<p>✅ <strong>三、如何选择消息队列？</strong></p>
<table>
<thead>
<tr>
<th>需求</th>
<th>推荐消息队列</th>
</tr>
</thead>
<tbody><tr>
<td><strong>简单异步任务、轻量级</strong></td>
<td>ActiveMQ</td>
</tr>
<tr>
<td><strong>复杂路由、异步解耦、延迟消息</strong></td>
<td>RabbitMQ</td>
</tr>
<tr>
<td><strong>高并发、大规模事务、顺序消息</strong></td>
<td>RocketMQ</td>
</tr>
<tr>
<td><strong>大数据、日志、流式计算、监控</strong></td>
<td>Kafka</td>
</tr>
</tbody></table>
<p>✅ <strong>四、总结答题思路</strong></p>
<ol>
<li><strong>总览介绍</strong>：ActiveMQ、RabbitMQ、RocketMQ、Kafka 的核心特点和适用场景。</li>
<li><strong>对比分析</strong>：从<strong>性能、事务、扩展性、消息模型</strong>等角度深入对比。</li>
<li><strong>项目经验</strong>：结合<strong>DTL 系统</strong>，具体说明如何选择和应用 MQ。</li>
</ol>
<p>🎯 <strong>面试加分项</strong>：提到<strong>消息丢失、重复消费、事务处理、扩展方案</strong>，展示你的架构理解和问题解决能力。</p>
<h4 id="问：推模式与拉模式？"><a href="#问：推模式与拉模式？" class="headerlink" title="问：推模式与拉模式？"></a>问：推模式与拉模式？</h4><p>两种模式：</p>
<ul>
<li>推模式：采用 <code>Basic.Consume</code> 进行消费；</li>
<li>拉模式：采用 <code>Basic.Get</code> 进行消费。</li>
</ul>
<p>推模式：</p>
<p>通过持续订阅的方式消费消息，接收消息一般通过实现 <code>Consumer</code> 接口或者继承 <code>DefaultConsumer</code> 类来实现。不同的订阅采用不同的消费者标签（ConsumerTag）来区分彼此。</p>
<p>主要通过方法 <code>channel.basicConsume()</code> ：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">      </span><br><span class="line">      <span class="comment">//接收到消息之后进行显式 ack 操作 channel.basicAck 对于消费者很必要，防止消息不必要的消失</span></span><br><span class="line"><span class="keyword">boolean</span> autoAck = <span class="keyword">false</span>;</span><br><span class="line">      channel.basicQos(<span class="number">64</span>); <span class="comment">//设置客户端最多接收未被 ack 的消息的个数</span></span><br><span class="line">      channel.basicConsume(QUEUE_NAME, autoAck, <span class="string">&quot;myConsumerTag&quot;</span>,</span><br><span class="line">              <span class="keyword">new</span> DefaultConsumer(channel) &#123;</span><br><span class="line">                  <span class="meta">@Override</span></span><br><span class="line">                  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">handleDelivery</span><span class="params">(String consumerTag,</span></span></span><br><span class="line"><span class="params"><span class="function">                                             Envelope envelope,</span></span></span><br><span class="line"><span class="params"><span class="function">                                             AMQP.BasicProperties properties,</span></span></span><br><span class="line"><span class="params"><span class="function">                                             <span class="keyword">byte</span>[] body)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">                      String routingKey = envelope.getRoutingKey();</span><br><span class="line">                      String contentType = properties.getContentType();</span><br><span class="line">                      <span class="keyword">long</span> deliveryTag = envelope.getDeliveryTag();</span><br><span class="line">                      <span class="comment">// process the message components here ...</span></span><br><span class="line">                      channel.basicAck(envelope.getDeliveryTag(), <span class="keyword">false</span>);</span><br><span class="line">                  &#125;</span><br><span class="line">              &#125;);</span><br></pre></td></tr></table></figure>



<p>常用参数：</p>
<ul>
<li>queue：队列的名称；</li>
<li>autoAck：设置是否自动确认。建议设成 false ，即不自动确认；</li>
<li>consumerTag：消费者标签，用来区分多个消费者；</li>
<li>noLocal 设置为 true 则表示不能将同一个 Connection 中生产者发送的消息传送给这个 Connection 中的消费者；</li>
<li>exclusive：设置是否排他 ；</li>
<li>arguments：设置消费者的其他参数；</li>
<li>callback：设置消费者的回调函数。用来处理 RabbitMQ 推送过来的消息，比如 DefaultConsumer 使用时需要客户端重写其中的方法。</li>
</ul>
<p>消费者客户端可以重写多种方法：</p>
<ul>
<li><code>handleDelivery()</code></li>
<li><code>handleConsumerOk()</code> ：会在其他方法之前调用，返回消费者标签。</li>
<li><code>handleCancelOk()</code> ：消费端可以在显式地取消订阅的时候调用。</li>
<li><code>handleCancel()</code> ：消费端可以在隐式地取消订阅的时候调用</li>
<li><code>handleShutdownSignal()</code> ：当 Channel 或者 Connection 关闭的时候会调用。</li>
<li><code>handleRecoverOk()</code></li>
</ul>
<p>通过 <code>channel.basicCancel()</code> 显式地取消一个消费者的订阅，先触发 <code>handleConsumerOk()</code> ，然后是 <code>handleDelivery()</code> ，最后是 <code>handleCancelOk()</code> 。</p>
<p>和生产者一样，消费者客户端同样需要考虑线程安全的问题。消费者客户端的这些 callback 会被分配到与 Channel 不同的线程池上，这意味着消费者客户端可以安全地调用这些阻塞方法，比如 <code>channel.queueDeclare</code> ， <code>channel.basicCancel</code> 等。 </p>
<p>每个 Channel 都拥有自己独立的线程。最常用的做法是一个 Channel 对应一个消费者， 也就是意味着消费者彼此之间没有任何关联。当然也可以在一个 Channel 中维持多个消费者， 但是要注意一个问题，如果 Channel 中的一个消费者一直在运行，那么其他消费者的 callback 会被“耽搁”。</p>
<p><img src="https://pic-1258215793.cos.ap-shanghai.myqcloud.com/content/20200901/202009010153.png"></p>
<p>拉模式：</p>
<p>通过 <code>channel.basicGet()</code> 可以单条的获取消息（连续调用拉取多条消息），当 autoAck 设置为false，需要用 <code>channel.basicAck()</code> 来确认消息已被成功接收。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">GetResponse response = channel.basicGet(QUEUE_NAME, <span class="keyword">false</span>);</span><br><span class="line">System.out,println(<span class="keyword">new</span> String(response.getBody()));</span><br><span class="line">channel.basicAck(response.getEnvelope().getDeliveryTag(), <span class="keyword">false</span>);</span><br></pre></td></tr></table></figure>



<p><img src="https://pic-1258215793.cos.ap-shanghai.myqcloud.com/content/20200901/202009010158.png"></p>
<p><code>Basic.Consume</code> 将信道（Channel）置为接收模式，直到取消队列的订阅为止。在接收模式期间， RabbitMQ 会不断地推送消息给消费者，当然推送消息的个数还是会受到 <code>Basic.Qos</code> 的限制．如果只想从队列获得单条消息而不是持续订阅，建议还是使用 <code>Basic.Get</code> 进行消费．但是不能将 <code>Basic.Get</code> 放在一个循环里来代替 <code>Basic.Consume</code> ，这样做会严重影响 RabbitMQ 的性能．如果要实现高吞吐量，消费者理应使用 <code>Basic.Consume</code> 方法。</p>
<p>批量拉取：</p>
<ol>
<li>批量拉取循环的退出条件：达到数量上限，basicGet返回null。</li>
<li>使用basic批量ACK传递的参数是最后一条消息的deliveryTag。</li>
<li>与 <code>DefaultConsumer</code> 运行在Connection的线程池中不同，使用拉模式需要自己创建线程池。</li>
</ol>
<p>对比：</p>
<p>（1）生产者和服务节点间都是推模式</p>
<p>一般而言我们在谈论推拉模式的时候指的是 Comsumer 和 Broker 之间的交互。    Producer 与 Broker 之间都是推的方式，即 Producer 将消息推送给 Broker，而不是 Broker 主动去拉取消息。原因如下：</p>
<ol>
<li>如果需要 Broker 去拉取消息，那么 Producer 就必须在本地通过日志的形式保存消息来等待 Broker 的拉取，如果有很多生产者的话，那么消息的可靠性不仅仅靠 Broker 自身，还需要靠成百上千的 Producer。</li>
<li>Broker 还能靠多副本等机制来保证消息的存储可靠，而成百上千的 Producer 可靠性就有点难办了，所以默认的 Producer 都是推消息给 Broker。</li>
</ol>
<table>
<thead>
<tr>
<th><strong>MQ类别</strong></th>
<th><strong>推拉模式</strong></th>
</tr>
</thead>
<tbody><tr>
<td>RabbitMQ</td>
<td>推拉都支持。官方推荐使用推模式</td>
</tr>
<tr>
<td>RocketMQ</td>
<td>推拉都支持。（本质上，推模式也是拉模式）</td>
</tr>
<tr>
<td>Kafka</td>
<td>只有拉模式</td>
</tr>
</tbody></table>
<p>（2）推、拉模式的优缺点</p>
<ul>
<li><strong>推模式：</strong>指的是消息从 Broker 推向 Consumer，即 Consumer 被动的接收消息，由 Broker 来主导消息的发送。<ul>
<li>优点：<ol>
<li><strong>消息实时性高。</strong>Broker 接受完消息之后可以立马推送给 Consumer。</li>
<li><strong>对于消费者使用来说更简单。</strong>消息来了就消费即可。</li>
</ol>
</li>
<li>缺点：推送速率难以适应消费速率<ol>
<li>推模式的目标就是以最快的速度推送消息，当生产者往 Broker 发送消息的速率大于消费者消费消息的速率时，随着时间的增长消费者那边可能就“爆仓”了，因为根本消费不过来啊。当推送速率过快就像 DDos 攻击一样消费者就傻了。</li>
<li>不同的消费者的消费速率还不一样，身为 Broker 很难平衡每个消费者的推送速率，如果要实现自适应的推送速率那就需要在推送的时候消费者告诉 Broker ，我不行了你推慢点吧，然后 Broker 需要维护每个消费者的状态进行推送速率的变更。这其实就增加了 Broker 自身的复杂度。</li>
</ol>
</li>
<li>使用场景：推模式难以根据消费者的状态控制推送速率，适用于消息量不大、消费能力强要求实时性高的情况下。 </li>
</ul>
</li>
<li><strong>拉模式：</strong>指的是 Consumer 主动向 Broker 请求拉取消息，即 Broker 被动的发送消息给 Consumer。<ul>
<li>优点：<ol>
<li><strong>消费者可以根据自身的情况来发起拉取消息的请求。</strong>假设当前消费者觉得自己消费不过来了，它可以根据一定的策略停止拉取，或者间隔拉取都行。</li>
<li><strong>Broker 相对轻松了。</strong>它只管存生产者发来的消息，至于消费的时候自然由消费者主动发起，来一个请求就给它消息呗，从哪开始拿消息，拿多少消费者都告诉它，它就是一个没有感情的工具人，消费者要是没来取也不关它的事。</li>
<li><strong>可以更合适的进行消息的批量发送。</strong>基于推模式可以来一个消息就推送，也可以缓存一些消息之后再推送，但是推送的时候其实不知道消费者到底能不能一次性处理这么多消息。而拉模式就更加合理，它可以参考消费者请求的信息来决定缓存多少消息之后批量发送。</li>
</ol>
</li>
<li>缺点：<ol>
<li><strong>消息延迟。</strong>毕竟是消费者去拉取消息，但是消费者怎么知道消息到了呢？所以它只能不断地拉取，但是又不能很频繁地请求，太频繁了就变成消费者在攻击 Broker 了。因此需要降低请求的频率，比如隔个 2 秒请求一次，你看着消息就很有可能延迟 2 秒了。</li>
<li><strong>消息忙请求。</strong>忙请求就是比如消息隔了几个小时才有，那么在几个小时之内消费者的请求都是无效的，在做无用功。</li>
</ol>
</li>
<li>使用场景：消费者在某个条件成立时才能消费消息，以及需要批量拉取消息进行处理。</li>
</ul>
</li>
</ul>
<h2 id="RabbitMQ"><a href="#RabbitMQ" class="headerlink" title="RabbitMQ"></a>RabbitMQ</h2><h3 id="基础概念和工作原理"><a href="#基础概念和工作原理" class="headerlink" title="基础概念和工作原理"></a>基础概念和工作原理</h3><h4 id="问：什么是-RabbitMQ？它是如何工作的？"><a href="#问：什么是-RabbitMQ？它是如何工作的？" class="headerlink" title="问：什么是 RabbitMQ？它是如何工作的？"></a>问：什么是 RabbitMQ？它是如何工作的？</h4><p><strong>什么是 RabbitMQ？</strong></p>
<ul>
<li>RabbitMQ 是一个开源的 <strong>消息队列</strong>（Message Queue, MQ）软件，它实现了 <strong>AMQP</strong>（Advanced Message Queuing Protocol）协议，用于在分布式系统中实现消息的异步传递。</li>
<li>RabbitMQ 是一种常见的消息中间件，它<strong>将消息发送方（生产者）和接收方（消费者）解耦，从而使得系统各个部分可以独立运行，提升了系统的可靠性、可扩展性和灵活性</strong>。</li>
<li>RabbitMQ 可以用于 <strong>异步消息处理</strong>、<strong>任务队列</strong>、<strong>发布/订阅</strong> 等场景，是实现微服务架构、分布式系统的重要组成部分。</li>
</ul>
<p><strong>RabbitMQ 如何工作？</strong></p>
<ul>
<li><p>RabbitMQ 基于 AMQP 协议，采用了发布/订阅的消息传递模式。RabbitMQ 通过几个关键组件：Producer、Consumer、Queue、Exchange、Binding 和 Routing Key完成工作。</p>
</li>
<li><p>RabbitMQ 消息流转过程通常包括以下步骤：</p>
<ol>
<li><p><strong>生产者发送消息</strong>：生产者将消息发送到 RabbitMQ 服务器，并指定一个交换机。生产者可以选择不同类型的交换机，如 <strong>direct</strong>、<strong>topic</strong>、<strong>fanout</strong> 或 <strong>headers</strong>。</p>
</li>
<li><p><strong>交换机路由消息</strong>：交换机根据消息的 路由键 将消息路由到一个或多个队列。路由键的匹配规则取决于交换机的类型。</p>
<ul>
<li><strong>Direct Exchange</strong>：交换机将消息根据路由键直接路由到与之匹配的队列。</li>
<li><strong>Fanout Exchange</strong>：交换机会将消息发送到所有绑定的队列，不考虑路由键。</li>
<li><strong>Topic Exchange</strong>：交换机根据路由键的模式匹配，将消息路由到与模式匹配的队列。</li>
<li><strong>Headers Exchange</strong>：通过匹配消息头信息来路由消息。</li>
</ul>
</li>
<li><p><strong>消息存储在队列中</strong>：消息被交换机路由到相应的队列中。如果队列设置为持久化（durable），消息会被存储到磁盘上，即使 RabbitMQ 崩溃，消息也不会丢失。</p>
</li>
<li><p><strong>消费者获取消息</strong>：消费者连接到 RabbitMQ，并从队列中取出消息进行处理。消费者通过 <strong>acknowledgement（确认机制）</strong> 来告诉 RabbitMQ 消息已经成功消费并处理。</p>
</li>
<li><p><strong>消息确认和删除</strong>：</p>
<ul>
<li>消费者在处理完消息后，通过发送 <strong>ACK（确认）</strong> 告诉 RabbitMQ 该消息已经被成功消费。RabbitMQ 会从队列中删除该消息。</li>
<li>如果消费者没有确认消息（例如，处理失败），RabbitMQ 会重新将该消息放回队列或转入<strong>死信队列</strong>（DLQ）。</li>
</ul>
</li>
</ol>
</li>
<li><p><strong>RabbitMQ 的消息确认机制</strong>：用于确保消息不会丢失并且可以可靠传递。主要有两种确认机制：</p>
<ol>
<li><strong>生产者确认（Publisher Confirms）</strong>：生产者可以启用确认机制，以确保消息已经被成功接收并路由。通过 <code>confirmSelect</code> 命令，生产者可以接收到来自 RabbitMQ 服务器的确认消息。</li>
<li><strong>消费者确认（Consumer Acknowledgements）</strong>：消费者在处理完消息后，发送确认（ACK）告诉 RabbitMQ 消息已成功消费。如果消费者未能处理消息（如程序崩溃或连接断开），RabbitMQ 会将消息重新入队，或者将其转发到死信队列。</li>
</ol>
</li>
<li><p><strong>RabbitMQ 消息的可靠性保证</strong>：</p>
<ol>
<li><strong>消息持久化</strong>：消息可以设置为 <strong>持久化</strong>（Persistent），这样即使 RabbitMQ 服务器崩溃，消息也不会丢失。</li>
<li><strong>队列持久化</strong>：队列也可以设置为持久化，确保队列不会因服务重启而丢失。</li>
<li><strong>确认机制</strong>：通过消费者和生产者的确认机制，可以确保消息的可靠性，避免消息丢失。</li>
<li><strong>消息重试和死信队列</strong>：如果消息消费失败，可以通过 <strong>死信队列</strong>（DLQ）进行处理，或者重新入队进行重试。</li>
</ol>
</li>
<li><p><strong>RabbitMQ 的应用场景</strong>：</p>
<ul>
<li><strong>异步消息处理</strong>：用于任务队列、背景任务等，需要异步处理的场景。</li>
<li><strong>发布/订阅模式</strong>：将消息广播给多个消费者，如实时信息推送、日志收集等。</li>
<li><strong>微服务架构</strong>：在微服务中，RabbitMQ 用于不同服务之间的消息传递。</li>
<li><strong>限流和削峰填谷</strong>：通过队列缓冲大量请求，避免系统过载。</li>
<li><strong>工作队列</strong>：将任务分配给多个消费者处理，实现负载均衡。</li>
</ul>
</li>
</ul>
<p>RabbitMQ 是一个强大的消息队列系统，通过 AMQP 协议实现生产者与消费者之间的解耦。它提供了高可用性、可靠性和灵活的路由机制，能够满足各种复杂的消息传递需求。通过使用 RabbitMQ，可以有效地提升系统的可扩展性、解耦性和容错能力。  </p>
<h4 id="问：RabbitMQ-与-Kafka、ActiveMQ-等消息队列有何区别？"><a href="#问：RabbitMQ-与-Kafka、ActiveMQ-等消息队列有何区别？" class="headerlink" title="问：RabbitMQ 与 Kafka、ActiveMQ 等消息队列有何区别？"></a>问：RabbitMQ 与 Kafka、ActiveMQ 等消息队列有何区别？</h4><p>RabbitMQ、Kafka 和 ActiveMQ 都是常见的消息队列（Message Queue, MQ）系统，它们有不同的设计目标和应用场景。下面将从几个方面对它们进行对比：</p>
<p><strong>1. 协议和通信方式</strong></p>
<ul>
<li><p>RabbitMQ:</p>
<ul>
<li>实现了 <strong>AMQP</strong>（Advanced Message Queuing Protocol）协议。</li>
<li>使用<strong>请求-应答</strong>（request-response）模式通信，消息在传递过程中进行确认和应答。</li>
<li>支持多种通信模式（如<strong>点对点、发布订阅</strong>等）。</li>
</ul>
</li>
<li><p>Kafka:</p>
<ul>
<li>基于自定义的协议，不完全符合传统的消息队列协议。</li>
<li>采用 <strong>发布-订阅模式</strong>（Publish-Subscribe），并强调高吞吐量、高可扩展性。</li>
<li>Kafka 本质上是一个分布式日志系统，可以作为消息队列使用，但它更适用于日志和事件流的处理。</li>
</ul>
</li>
<li><p>ActiveMQ:</p>
<ul>
<li>实现了 <strong>JMS</strong>（Java Message Service）协议，同时也支持 AMQP、MQTT 等协议。</li>
</ul>
</li>
<li><p>适合用于中小型的消息传递和点对点通信，提供了高层的事务管理和可靠性保证。</p>
</li>
</ul>
<p><strong>2. 架构设计</strong></p>
<ul>
<li><p>RabbitMQ:</p>
<ul>
<li>基于 <strong>Broker</strong> 架构，消息通过 <strong>交换机（Exchange）</strong> 路由到队列（Queue）。</li>
<li>使用 <strong>队列</strong> 存储消息，消费者从队列获取消息。</li>
<li>支持多种交换机类型，如 <strong>Direct</strong>、<strong>Topic</strong>、<strong>Fanout</strong> 和 <strong>Headers</strong>，提供灵活的路由策略。</li>
</ul>
</li>
<li><p>Kafka:</p>
<ul>
<li>基于 <strong>分布式日志</strong> 架构，基于 <strong>Broker</strong> 架构，消息写入 <strong>Topic</strong>，消费者按 <strong>Consumer Group</strong> 分组消费消息。Kafka 集群中的一台服务器就是一个 broker，可以水平无限扩展，同一个 Topic 的消息可以分布在多个 broker 中；</li>
<li>每个消息都在 <strong>Topic</strong> 中保存一段时间（默认七天），消费者可以从任何位置读取历史消息。</li>
<li>Kafka 设计为分布式、横向扩展的高吞吐量系统，专注于流式处理和日志存储。</li>
</ul>
</li>
<li><p>ActiveMQ:</p>
<ul>
<li>基于 <strong>Broker</strong> 架构，支持点对点（Queue）和发布订阅（Topic）模式。</li>
<li>提供 <strong>JMS</strong> API 支持 Java 语言的消息服务，支持事务、消息持久化等高级特性。</li>
<li>ActiveMQ 通常用于传统的企业级消息队列系统。</li>
</ul>
</li>
</ul>
<p><strong>3. 性能与吞吐量</strong></p>
<ul>
<li><strong>RabbitMQ</strong>:<ul>
<li>对于低延迟和高可靠性消息处理性能较强，适合小规模到中规模的负载。</li>
<li>在高并发和高吞吐量场景下会面临一些性能瓶颈，特别是在消息确认和持久化的情况下。</li>
<li><strong>消息确认机制使得它在保证消息传递可靠性的同时，吞吐量相对较低</strong>。</li>
</ul>
</li>
<li><strong>Kafka</strong>:<ul>
<li>以<strong>高吞吐量</strong>为特点，能够在非常高并发的情况下处理大量的消息。</li>
<li>Kafka 的磁盘存储和分区机制使它能够高效地处理大规模数据，适合日志、事件流等数据流式处理场景。</li>
<li>Kafka 通过 <strong>分布式复制</strong> 来保证消息的可靠性。</li>
</ul>
</li>
<li><strong>ActiveMQ</strong>:<ul>
<li>吞吐量适中，适合企业级应用中需要较强事务性、可靠性保证的消息传递需求。</li>
<li>相比 RabbitMQ 和 Kafka，它的吞吐量较低，适合中等规模的负载。</li>
</ul>
</li>
</ul>
<p><strong>4. 消息持久化</strong></p>
<ul>
<li><p>RabbitMQ:</p>
<ul>
<li>支持消息和队列的持久化，可以确保即使在 RabbitMQ 重启时消息不丢失。</li>
<li>需要配置消息持久化（durable）和队列持久化（persistent）。</li>
</ul>
</li>
<li><p>Kafka:</p>
<ul>
<li>消息持久化是 Kafka 的一大特点，消息存储在磁盘中，默认可以保留七天，甚至可以配置为长期保留。</li>
<li>Kafka 的消息持久化和存储方式使它非常适合做日志存储和大数据流处理。</li>
</ul>
</li>
<li><p>ActiveMQ:</p>
<ul>
<li>也支持消息的持久化，可以将消息持久化到磁盘或数据库中。</li>
</ul>
</li>
<li><p>在持久化模式下，ActiveMQ 确保消息在 broker 崩溃时不丢失。</p>
</li>
</ul>
<p><strong>5. 消息的顺序性</strong></p>
<ul>
<li><p>RabbitMQ:</p>
<ul>
<li>在默认情况下，RabbitMQ 保证同一个队列中的消息按照生产者发送的顺序进行消费。</li>
<li>但如果消费者处理时间不均匀，或者多个消费者并行消费消息时，顺序可能会打乱。</li>
</ul>
</li>
<li><p>Kafka:</p>
<ul>
<li>Kafka 保证同一个 <strong>Partition</strong> 中的消息顺序性，即每个 Partition 内的消息按顺序消费。</li>
<li>但是如果消费者消费的是多个分区的数据，消息的顺序就无法得到保证。</li>
</ul>
</li>
<li><p>ActiveMQ:</p>
<ul>
<li>对于点对点（Queue）模式，ActiveMQ 保证消息的顺序性。</li>
</ul>
</li>
<li><p>对于发布/订阅（Topic）模式，顺序性无法得到保证，特别是在多个消费者并发消费的情况下。</p>
</li>
</ul>
<p><strong>6. 适用场景</strong></p>
<ul>
<li><p>RabbitMQ:</p>
<ul>
<li>适用于需要高可靠性、可靠消息传递和灵活路由的场景。</li>
<li>比如：任务队列、请求-应答模式、实时消息推送等。</li>
</ul>
</li>
<li><p>Kafka:</p>
<ul>
<li>适用于高吞吐量、大规模数据流处理和事件流的场景。</li>
<li>比如：日志收集、数据流处理、分布式日志系统、实时分析等。</li>
</ul>
</li>
<li><p>ActiveMQ:</p>
<ul>
<li>适用于中等规模的企业级消息队列，特别是对事务性和可靠性有较高需求的系统。</li>
</ul>
</li>
<li><p>比如：企业消息队列、应用集成、跨平台消息传递等。</p>
</li>
</ul>
<p><strong>7. 可扩展性</strong></p>
<ul>
<li><strong>RabbitMQ</strong>:<ul>
<li>RabbitMQ 支持 <strong>集群</strong> 模式，但在扩展性上通常不如 Kafka，尤其是当消息量较大时，性能可能会成为瓶颈。</li>
<li>适合规模适中的应用，但对于超大规模的场景，可能需要额外的优化。</li>
</ul>
</li>
<li><strong>Kafka</strong>:<ul>
<li>Kafka 本身是一个 <strong>分布式系统</strong>，具备水平扩展能力，可以轻松扩展到数百台机器。</li>
<li>Kafka 的分区和副本机制使其非常适合大规模应用，可以处理超大规模的消息流。</li>
</ul>
</li>
<li><strong>ActiveMQ</strong>:<ul>
<li>ActiveMQ 支持集群和分布式部署，但相较于 Kafka，扩展性较差。</li>
<li>适合中等规模的系统，扩展性相对有限。</li>
</ul>
</li>
</ul>
<p><strong>8. 高可用性和容错性</strong></p>
<ul>
<li><strong>RabbitMQ</strong>:<ul>
<li>RabbitMQ 支持 <strong>镜像队列</strong> 和 <strong>高可用集群</strong>，可以保证队列的高可用性。</li>
<li>在节点故障时，RabbitMQ 会自动进行故障转移，保证消息不会丢失。</li>
</ul>
</li>
<li><strong>Kafka</strong>:<ul>
<li>Kafka 通过 <strong>分区副本机制</strong>（Replication）提供高可用性，副本数可以配置，确保数据在节点故障时不丢失。</li>
<li>Kafka 设计为分布式的，天然支持水平扩展和高可用性。</li>
</ul>
</li>
<li><strong>ActiveMQ</strong>:<ul>
<li>ActiveMQ 也支持 <strong>主从模式</strong> 和 <strong>高可用集群</strong>。</li>
<li>在消息传递的可靠性方面，ActiveMQ 提供了事务保证，适合需要强一致性的场景。</li>
</ul>
</li>
</ul>
<p><strong>总结</strong></p>
<ul>
<li><strong>RabbitMQ</strong> 适合需要灵活消息路由、可靠消息传递的场景，特别是在中等规模和高可用性的系统中表现良好。</li>
<li><strong>Kafka</strong> 更适合高吞吐量、大数据流处理和日志系统，能够支持大规模的数据流和事件流处理。</li>
<li><strong>ActiveMQ</strong> 适用于传统企业级应用，支持 JMS 协议，适合中等规模的负载和需要事务保障的场景。</li>
</ul>
<p>选择哪种消息队列取决于具体的应用场景、系统需求以及扩展性要求。</p>
<h4 id="问：什么是Broker架构？RabbitMQ有哪些关键组件？RabbitMQ-中的-Producer、Consumer、Queue、Exchange、Binding-和-Routing-Key-分别是什么？"><a href="#问：什么是Broker架构？RabbitMQ有哪些关键组件？RabbitMQ-中的-Producer、Consumer、Queue、Exchange、Binding-和-Routing-Key-分别是什么？" class="headerlink" title="问：什么是Broker架构？RabbitMQ有哪些关键组件？RabbitMQ 中的 Producer、Consumer、Queue、Exchange、Binding 和 Routing Key 分别是什么？"></a>问：什么是Broker架构？RabbitMQ有哪些关键组件？RabbitMQ 中的 Producer、Consumer、Queue、Exchange、Binding 和 Routing Key 分别是什么？</h4><p><strong>Broker 架构</strong>是消息中间件的核心架构之一，广泛应用于分布式系统中，用于在不同应用之间异步传递消息。它的主要作用是<strong>解耦生产者（Producer）和消费者（Consumer）</strong>，提供可靠的消息传输、消息存储、路由等功能。</p>
<p><strong>核心概念</strong></p>
<ol>
<li><strong>Broker</strong><ul>
<li>Broker 是消息中间件的核心组件，用于接收、存储和转发消息。</li>
<li>一般情况下，Broker 会管理多个队列（Queue）或主题（Topic），以支持不同的消息传递模式。</li>
</ul>
</li>
<li><strong>Producer（生产者）</strong><ul>
<li>负责将消息发送到 Broker。</li>
<li>Producer 通常通过指定队列或主题，将消息推送到 Broker 中。</li>
</ul>
</li>
<li><strong>Consumer（消费者）</strong><ul>
<li>负责从 Broker 获取消息并处理。</li>
<li>消费者可以是多个，并支持负载均衡、广播等消费模式。</li>
</ul>
</li>
<li><strong>Message</strong><ul>
<li>Broker 中传递的基本单位。消息通常包含数据和元信息（如消息ID、优先级等）。</li>
</ul>
</li>
<li><strong>队列（Queue）/主题（Topic）</strong><ul>
<li><strong>队列</strong>：点对点模型（Point-to-Point），一个消息只能被一个消费者消费。</li>
<li><strong>主题</strong>：发布/订阅模型（Pub/Sub），一个消息可以被多个订阅者消费。</li>
</ul>
</li>
</ol>
<p><strong>架构设计</strong>，Broker 架构主要包括以下模块：</p>
<ol>
<li><strong>消息存储模块</strong><ul>
<li>持久化存储消息，例如使用磁盘、数据库等。</li>
<li>支持消息的高效读写，通常采用顺序写入和高效索引技术。</li>
</ul>
</li>
<li><strong>消息路由模块</strong><ul>
<li>根据路由规则（如 Routing Key、Binding 等）将消息转发给对应的队列或主题。</li>
</ul>
</li>
<li><strong>消费者管理模块</strong><ul>
<li>管理消费者的订阅关系。</li>
<li>处理消费者的连接、心跳检测、消息推送等。</li>
</ul>
</li>
<li><strong>消息投递模块</strong><ul>
<li>负责将消息可靠地投递到消费者。</li>
<li>提供消息重试机制，防止消息丢失。</li>
</ul>
</li>
<li><strong>消息队列管理</strong><ul>
<li>提供队列的创建、删除、监控功能。</li>
<li>支持队列的分片和集群扩展。</li>
</ul>
</li>
<li><strong>高可用模块</strong><ul>
<li>支持集群模式，保证 Broker 的高可用性。</li>
<li>常见实现包括主从复制、数据一致性保障等。</li>
</ul>
</li>
</ol>
<p><strong>常见的 Broker 实现</strong></p>
<ol>
<li><strong>RabbitMQ</strong><ul>
<li>基于 AMQP 协议。</li>
<li>提供丰富的路由规则和高可靠的消息传递。</li>
</ul>
</li>
<li><strong>Kafka</strong><ul>
<li>以日志为核心，支持高吞吐量的消息传递。</li>
<li>适合处理大数据流。</li>
</ul>
</li>
<li><strong>ActiveMQ</strong><ul>
<li>支持多种协议，提供强大的消息存储和转发功能。</li>
</ul>
</li>
<li><strong>RocketMQ</strong><ul>
<li>阿里巴巴开源的分布式消息队列，支持事务消息和顺序消息。</li>
</ul>
</li>
</ol>
<p><strong>特点和应用场景</strong></p>
<p><strong>特点</strong></p>
<ol>
<li><strong>解耦</strong>：生产者和消费者无需直接通信，可以独立扩展。</li>
<li><strong>可靠性</strong>：提供消息持久化和确认机制，确保消息不丢失。</li>
<li><strong>灵活性</strong>：支持多种消息模型（如点对点、发布订阅）。</li>
<li><strong>可扩展性</strong>：支持分布式架构和负载均衡，易于横向扩展。</li>
</ol>
<p><strong>应用场景</strong></p>
<ol>
<li><strong>异步处理</strong>：在用户请求中加入异步任务，提高系统响应速度。</li>
<li><strong>事件驱动架构</strong>：处理大量实时事件，如订单处理、日志收集等。</li>
<li><strong>分布式系统通信</strong>：作为不同微服务之间的桥梁。</li>
</ol>
<ol>
<li><strong>Producer（生产者）</strong>：生产者是消息的发送者。它将消息发布到指定的 <strong>交换机（Exchange）</strong>，由 <strong>Exchange</strong> 决定消息的路由方式。</li>
<li><strong>Exchange（交换机）</strong>：<ul>
<li>交换机是消息的路由器，它决定如何将消息路由到一个或多个队列。Exchange 根据配置的路由规则（如路由键）将消息发送到队列。</li>
<li>RabbitMQ 支持不同类型的交换机，包括 <strong>Direct Exchange</strong>、<strong>Topic Exchange</strong>、<strong>Fanout Exchange</strong> 和 <strong>Headers Exchange</strong>，每种交换机类型适用于不同的路由需求。<ul>
<li><strong>Direct Exchange</strong>：将消息路由到与 <strong>Routing Key</strong> 精确匹配的队列。点对点模式。</li>
<li><strong>Fanout Exchange</strong>：将消息路由到所有绑定的队列，不关心 <strong>Routing Key</strong>。发布订阅模式。</li>
<li><strong>Topic Exchange</strong>：将消息路由到匹配 <strong>Routing Key</strong> 模式的队列，支持更复杂的路由规则。主题模式。</li>
<li><strong>Headers Exchange</strong>：根据消息的头部信息路由消息，通常使用更复杂的规则。</li>
</ul>
</li>
</ul>
</li>
<li><strong>Queue（队列）</strong>：队列用于存储消息，消费者从队列中获取消息进行处理。消息在队列中按先进先出的顺序排列，直到被消费者处理完。多个消费者可以订阅同一个队列，队列中的消息会被<strong>平均分摊</strong>（Round-Robin，即轮询）给多个消费者处理，<strong>不是每个消费者都收到所有的消息并处理</strong>。</li>
<li><strong>Consumer（消费者）</strong>：消费者是消息的接收者，它从订阅的 <strong>Queue</strong> 中获取消息进行处理。消息处理完毕后通常会发送一个确认消息，多个消费者可以并发地处理队列中的消息。</li>
<li><strong>Binding（绑定）</strong>：绑定是交换机与队列之间的联系。通过绑定，交换机可以将消息路由到一个或多个队列。每个绑定通常包含一个 <strong>路由键</strong>（routing key），它是用来决定消息应该投递到哪个队列的关键因素。</li>
<li><strong>Routing Key（路由键）</strong>：路由键是生产者在发送消息时指定的字符串，交换机使用这个路由键将消息路由到相应的队列。例如，在使用 <strong>Direct Exchange</strong> 时，路由键可以直接与队列绑定，决定消息投递的目的地。</li>
</ol>
<p><strong>RabbitMQ 消息流动过程</strong></p>
<ol>
<li><strong>Producer</strong> 发送消息到 <strong>Exchange</strong>，附带一个 <strong>Routing Key</strong>（如果是 Direct 或 Topic 类型的 Exchange）。</li>
<li><strong>Exchange</strong> 根据 <strong>Routing Key</strong> 和 <strong>Binding</strong> 规则，将消息路由到相应的 <strong>Queue</strong>。</li>
<li><strong>Queue</strong> 存储消息，直到 <strong>Consumer</strong> 从队列中消费消息。</li>
<li><strong>Consumer</strong> 从队列中取出消息进行处理，通常会向 RabbitMQ 发送一个确认消息，表示该消息已经成功处理。</li>
</ol>
<h4 id="问：AMQP-协议？"><a href="#问：AMQP-协议？" class="headerlink" title="问：AMQP 协议？"></a>问：AMQP 协议？</h4><ul>
<li>什么是 RabbitMQ 的 AMQP 协议？<ul>
<li><strong>AMQP（Advanced Message Queuing Protocol，高级消息队列协议）</strong>是一个用于消息中间件的开放标准应用层协议，设计用于消息的中间传输。它定义了消息的格式、传输方式以及如何确保消息的可靠传递。RabbitMQ 是基于 AMQP 协议实现的一种高性能、可靠的消息队列系统。</li>
</ul>
</li>
<li>AMQP 的主要特性<ol>
<li><strong>开放性</strong>：<br>AMQP 是一个开放的标准协议，支持不同语言的客户端和消息中间件进行互操作。</li>
<li><strong>可靠性</strong>：<br>AMQP 提供多种可靠传输机制，包括消息确认（Acknowledgment）、事务支持、持久化存储等，确保消息不会丢失或重复。</li>
<li><strong>灵活性</strong>：<br>支持多种消息模式（点对点、发布/订阅等），以及路由和绑定规则，适应不同的业务需求。</li>
<li><strong>安全性</strong>：<br>支持 SSL/TLS 加密和多种认证机制，确保数据传输的安全性。</li>
</ol>
</li>
<li>AMQP 的核心组件<ol>
<li><strong>Producer（生产者）</strong>：<ul>
<li>负责发送消息到消息队列的发送端。</li>
<li>在 AMQP 中，生产者将消息发送到交换机（Exchange）。</li>
</ul>
</li>
<li><strong>Consumer（消费者）</strong>：<ul>
<li>负责从消息队列中获取消息并处理。</li>
<li>消费者从绑定到队列（Queue）的消息中消费。</li>
</ul>
</li>
<li><strong>Exchange（交换机）</strong>：<ul>
<li>生产者将消息发送到交换机，交换机根据绑定规则决定消息路由到哪些队列。</li>
<li>交换机的类型包括：<ul>
<li>Direct：直接交换</li>
<li>Fanout：扇出交换</li>
<li>Topic：主题交换</li>
<li>Headers：基于消息头的交换</li>
</ul>
</li>
</ul>
</li>
<li><strong>Queue（队列）</strong>：<ul>
<li>用于存储消息，直到被消费者消费。</li>
<li>队列可以绑定到多个交换机，并支持不同的路由规则。</li>
</ul>
</li>
<li><strong>Binding（绑定）</strong>：<ul>
<li>定义队列与交换机之间的路由规则。</li>
<li>路由规则通过 <code>Routing Key</code> 或其他策略指定。</li>
</ul>
</li>
<li><strong>Routing Key（路由键）</strong>：<ul>
<li>生产者发送消息时指定的键，交换机根据此键决定消息的路由路径。</li>
</ul>
</li>
<li><strong>Virtual Host（虚拟主机）</strong>：<ul>
<li>AMQP 中的逻辑分组，用于隔离不同的消息队列和交换机。</li>
</ul>
</li>
<li><strong>Connection（连接）和 Channel（信道）</strong>：<ul>
<li>生产者和消费者通过连接与 RabbitMQ 服务交互。</li>
<li>信道是复用连接的逻辑通道，用于发送和接收消息。</li>
</ul>
</li>
</ol>
</li>
<li>RabbitMQ 中 AMQP 的工作流程<ol>
<li><strong>连接与信道</strong>：<ul>
<li>客户端（生产者或消费者）通过 TCP 连接 RabbitMQ 服务。</li>
<li>在连接中创建多个信道（Channel）用于消息传输。</li>
</ul>
</li>
<li><strong>生产者发送消息</strong>：<ul>
<li>生产者将消息发送到指定的交换机，并附带 <code>Routing Key</code>。</li>
<li>如果交换机与队列没有绑定，消息会被丢弃。</li>
</ul>
</li>
<li><strong>交换机路由消息</strong>：<ul>
<li>交换机根据路由规则（绑定和路由键）将消息分发到队列。</li>
</ul>
</li>
<li><strong>队列存储消息</strong>：<ul>
<li>消息到达目标队列并等待消费者消费。</li>
</ul>
</li>
<li><strong>消费者获取消息</strong>：<ul>
<li>消费者通过订阅队列，获取消息并进行处理。</li>
</ul>
</li>
<li><strong>消息确认</strong>：<ul>
<li>消费者处理完消息后向 RabbitMQ 发送 ACK 确认，RabbitMQ 才会删除消息。</li>
</ul>
</li>
</ol>
</li>
<li>RabbitMQ 对 AMQP 的扩展<ol>
<li><strong>优先级队列</strong>：支持消息优先级。</li>
<li><strong>死信队列（DLQ）</strong>：支持对未成功消费的消息进行重定向处理。</li>
<li><strong>插件机制</strong>：支持通过插件扩展功能，例如监控、延时队列等。</li>
<li><strong>延时消息</strong>：支持定时消息投递。</li>
</ol>
</li>
<li>基于 AMQP的优势<ol>
<li><strong>灵活的消息路由</strong>：<ul>
<li>AMQP 提供的交换机和绑定机制让 RabbitMQ 的消息路由变得非常灵活，适合多种应用场景。</li>
</ul>
</li>
<li><strong>多语言支持</strong>：<ul>
<li>AMQP 是开放标准，支持多种语言的客户端库，与 RabbitMQ 完美兼容。</li>
</ul>
</li>
<li><strong>可靠性保障</strong>：<ul>
<li>RabbitMQ 基于 AMQP 提供事务支持、消息确认和持久化机制，确保消息的可靠性。</li>
</ul>
</li>
<li><strong>分布式扩展</strong>：<ul>
<li>RabbitMQ 支持集群部署，结合 AMQP 实现高性能和高可用性。</li>
</ul>
</li>
</ol>
</li>
</ul>
<h4 id="问：RabbitMQ的vhost是什么，有什么作用？"><a href="#问：RabbitMQ的vhost是什么，有什么作用？" class="headerlink" title="问：RabbitMQ的vhost是什么，有什么作用？"></a>问：RabbitMQ的vhost是什么，有什么作用？</h4><p>✅ <strong>RabbitMQ 中的 vhost 是什么？</strong></p>
<p><strong>vhost</strong>（<strong>Virtual Host</strong>，虚拟主机）是 RabbitMQ 中用于实现多租户隔离的逻辑概念，类似于关系型数据库中的 <strong>“数据库实例”</strong>，用于将不同的资源（如交换机、队列、绑定关系等）进行分区管理。</p>
<p>在 RabbitMQ 中，vhost 是消息路由的最小单位，每个 vhost 都可以有独立的 <strong>交换机（Exchange）、队列（Queue）、绑定关系（Binding）</strong>，并且相互隔离。</p>
<p>每个 RabbitMQ 服务器都能创建虚拟的消息服务器，我们称之为虚拟主机（virtual host，简称为 vhost)。</p>
<ul>
<li>每一个 vhost 本质上是一个独立的小型 RabbitMQ 服务器；</li>
<li>拥有自己独立的队列、交换器及绑定关系等；</li>
<li>井且它拥有自己独立的权限。 </li>
<li>vhost 之间是绝对隔离的，无法将 vhostl 中的交换器与 vhost2 中的队列进行绑定，既保证了安全性，又可以确保可移植性。</li>
<li>建议用户对业务功能、场景进行归类 区分，并为之分配独立的 vhost。</li>
<li>vhost 是 AMQP 概念的基础，客户端在连接的时候必须制定一个 vhost。</li>
<li>默认的 vhost 是 <code>/</code> ，使用默认的用户名 guest 和密码 guest 就可以访问它。</li>
</ul>
<p>✅ <strong>vhost 的作用</strong></p>
<ol>
<li><strong>资源隔离</strong><ul>
<li>不同的业务系统或应用可以使用不同的 vhost，避免资源冲突，互不干扰。</li>
<li>例如，支付系统、订单系统、通知系统各自使用独立的 vhost，互相隔离。</li>
</ul>
</li>
<li><strong>权限管理</strong><ul>
<li>每个 vhost 可以设置不同的用户权限（<strong>生产、消费、配置</strong>）。</li>
<li>RabbitMQ 提供 <strong>Virtual Host + 用户</strong> 的双层授权机制，确保数据安全。</li>
<li>例如，开发环境与生产环境使用不同的 vhost，限制用户访问权限。</li>
</ul>
</li>
<li><strong>多租户支持</strong><ul>
<li>支持在同一 RabbitMQ 实例下为多个应用提供服务，适配多租户模式。</li>
<li>例如，SaaS 平台为多个企业客户提供消息服务，每个企业使用独立 vhost。</li>
</ul>
</li>
<li><strong>环境隔离</strong><ul>
<li>在同一个 RabbitMQ 集群下，可以使用不同的 vhost 实现 <strong>开发、测试、生产</strong> 环境隔离。</li>
<li>例如，<code>dev-vhost</code>、<code>test-vhost</code>、<code>prod-vhost</code> 分别对应不同的环境。</li>
</ul>
</li>
</ol>
<p>✅ <strong>RabbitMQ vhost 工作原理</strong></p>
<ol>
<li><strong>消息生产</strong><ul>
<li>Producer 连接到某个 vhost，并将消息发送到该 vhost 下的 Exchange。</li>
</ul>
</li>
<li><strong>消息路由</strong><ul>
<li>Exchange 根据 Binding 规则，将消息路由到 vhost 下的队列。</li>
</ul>
</li>
<li><strong>消息消费</strong><ul>
<li>Consumer 只能消费与其 vhost 绑定的队列，无法访问其他 vhost。</li>
</ul>
</li>
<li><strong>用户与权限</strong><ul>
<li>RabbitMQ 的用户只能访问被授权的 vhost，未授权 vhost 不能读写消息。</li>
</ul>
</li>
</ol>
<p>✅ <strong>常用 RabbitMQ vhost 管理命令</strong></p>
<ol>
<li><p><strong>创建 vhost</strong></p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">rabbitmqctl add_vhost my_vhost</span><br></pre></td></tr></table></figure></li>
<li><p><strong>列出所有 vhost</strong></p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">rabbitmqctl list_vhosts</span><br></pre></td></tr></table></figure></li>
<li><p><strong>删除 vhost</strong></p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">rabbitmqctl delete_vhost my_vhost</span><br></pre></td></tr></table></figure></li>
<li><p><strong>为用户授权 vhost</strong></p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">rabbitmqctl set_permissions -p my_vhost my_user <span class="string">&quot;.*&quot;</span> <span class="string">&quot;.*&quot;</span> <span class="string">&quot;.*&quot;</span></span><br></pre></td></tr></table></figure>

<ul>
<li><code>-p my_vhost</code>：指定 vhost</li>
<li><code>my_user</code>：RabbitMQ 用户</li>
<li><code>&quot;.&quot;</code>：权限规则（正则匹配）<ul>
<li>第一个参数：配置权限（Exchange/Queue）</li>
<li>第二个参数：写入权限（Publish）</li>
<li>第三个参数：读取权限（Consume）</li>
</ul>
</li>
</ul>
</li>
</ol>
<p>✅ <strong>实际应用场景</strong></p>
<ol>
<li><strong>多环境隔离</strong>：开发、测试、生产使用不同 vhost，避免数据混淆。</li>
<li><strong>多系统隔离</strong>：订单系统、库存系统各自使用 vhost，防止交换机、队列混用。</li>
<li><strong>多租户模式</strong>：SaaS 平台不同客户使用独立 vhost，确保数据隔离。</li>
<li><strong>权限管理</strong>：根据 vhost 设置用户角色，限制敏感数据访问。</li>
</ol>
<p>✅ <strong>面试回答模板</strong></p>
<blockquote>
<p>RabbitMQ 中的 <strong>vhost（虚拟主机）</strong> 是用于实现<strong>资源隔离</strong>和<strong>权限管理</strong>的逻辑分区，类似于数据库中的<strong>数据库实例</strong>。每个 vhost 拥有独立的<strong>交换机、队列、绑定关系</strong>，互不干扰。它的主要作用包括多环境隔离、业务系统隔离、权限管理和多租户支持，确保 RabbitMQ 在复杂系统中安全、高效地运行。</p>
</blockquote>
<p>🎯 <strong>加分点</strong>：结合具体项目中的 vhost 使用场景，强调如何通过 vhost 提升系统安全性、数据隔离和运维效率。</p>
<h4 id="问：RabbitMQ-的交换机类型有哪些？各自的作用是什么？消息路由？路由规则如何定义？"><a href="#问：RabbitMQ-的交换机类型有哪些？各自的作用是什么？消息路由？路由规则如何定义？" class="headerlink" title="问：RabbitMQ 的交换机类型有哪些？各自的作用是什么？消息路由？路由规则如何定义？"></a>问：RabbitMQ 的交换机类型有哪些？各自的作用是什么？消息路由？路由规则如何定义？</h4><p>什么是 RabbitMQ 的消息路由？</p>
<ul>
<li><strong>RabbitMQ 的消息路由</strong> 是指根据一定的规则将生产者发送的消息路由到合适的队列，以便消费者能够消费这些消息。RabbitMQ 使用 <strong>交换器（Exchange）</strong> 来决定如何将消息路由到队列。交换器根据不同的 <strong>路由规则</strong> 来决定将消息转发到哪些队列。</li>
</ul>
<p>RabbitMQ 支持以下四种主要的交换机类型，每种类型都有不同的消息路由机制：</p>
<ol>
<li><p>Direct Exchange（直连交换机）</p>
<ul>
<li><p><strong>路由规则：</strong></p>
<ul>
<li>根据 <strong>Routing Key</strong> 精确匹配队列绑定的 Routing Key。</li>
</ul>
</li>
<li><p><strong>特点：</strong></p>
<ul>
<li>精确路由。</li>
<li>Routing Key 和队列绑定规则必须完全一致。</li>
<li>每条消息只会发送到 Routing Key 和队列绑定关系完全匹配的队列中。</li>
</ul>
</li>
<li><p><strong>使用场景：</strong>精确路由的场景</p>
<ul>
<li>订单系统，根据订单类型（<code>order.new</code>，<code>order.cancel</code>）将消息发送到特定队列。</li>
<li>日志系统中只需某类特定日志。</li>
</ul>
</li>
<li><p><strong>示例：</strong></p>
<ul>
<li>假设 Routing Key 为 <code>order.new</code>，只有绑定了相同 Routing Key 的队列才能收到该消息。</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">channel.exchangeDeclare(<span class="string">&quot;direct_exchange&quot;</span>, <span class="string">&quot;direct&quot;</span>);</span><br><span class="line">channel.queueBind(<span class="string">&quot;queue_1&quot;</span>, <span class="string">&quot;direct_exchange&quot;</span>, <span class="string">&quot;order.new&quot;</span>);</span><br></pre></td></tr></table></figure></li>
</ul>
</li>
<li><p>Fanout Exchange（广播交换机）</p>
<ul>
<li><p><strong>路由规则：</strong></p>
<ul>
<li>不考虑 Routing Key，消息广播到绑定到该交换机的所有队列。</li>
</ul>
</li>
<li><p><strong>特点：</strong></p>
<ul>
<li>所有绑定的队列都能收到消息。</li>
<li>简单高效，但无法选择性路由。</li>
</ul>
</li>
<li><p><strong>使用场景：</strong>广播消息给多个消费者的场景</p>
<ul>
<li>系统中将日志消息分发到多个存储服务。</li>
<li>通知系统中发送相同通知到所有服务模块。</li>
</ul>
</li>
<li><p><strong>示例：</strong></p>
<ul>
<li>绑定的所有队列都会接收到消息。</li>
</ul>
</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">channel.exchangeDeclare(<span class="string">&quot;fanout_exchange&quot;</span>, <span class="string">&quot;fanout&quot;</span>);</span><br><span class="line">channel.queueBind(<span class="string">&quot;queue_1&quot;</span>, <span class="string">&quot;fanout_exchange&quot;</span>, <span class="string">&quot;&quot;</span>);</span><br><span class="line">channel.queueBind(<span class="string">&quot;queue_2&quot;</span>, <span class="string">&quot;fanout_exchange&quot;</span>, <span class="string">&quot;&quot;</span>);</span><br></pre></td></tr></table></figure></li>
<li><p>Topic Exchange（主题交换机）</p>
<ul>
<li><p><strong>路由规则：</strong></p>
<ul>
<li><p>根据 Routing Key和绑定规则中的模式进行模糊匹配。</p>
<ul>
<li><code>*</code>：匹配一个单词。</li>
<li><code>#</code>：匹配零个或多个单词。</li>
</ul>
</li>
</ul>
</li>
<li><p><strong>特点：</strong></p>
<ul>
<li>支持模糊匹配，路由规则灵活。</li>
</ul>
</li>
<li><p><strong>使用场景：</strong>需要根据模式匹配的场景</p>
<ul>
<li>日志系统，将日志按模块和级别路由到不同的队列（如 <code>moduleA.info</code>，<code>moduleB.error</code>）。</li>
<li>新闻系统，按主题匹配消息，例如 <code>sports.football</code>，<code>sports.basketball</code>。</li>
</ul>
</li>
<li><p><strong>示例：</strong></p>
<ul>
<li>Routing Key 为 <code>log.error</code>，队列绑定规则为 <code>log.*</code> 或 <code>log.#</code> 时可以匹配。</li>
</ul>
</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">channel.exchangeDeclare(<span class="string">&quot;topic_exchange&quot;</span>, <span class="string">&quot;topic&quot;</span>);</span><br><span class="line">channel.queueBind(<span class="string">&quot;queue_1&quot;</span>, <span class="string">&quot;topic_exchange&quot;</span>, <span class="string">&quot;log.*&quot;</span>);</span><br><span class="line">channel.queueBind(<span class="string">&quot;queue_2&quot;</span>, <span class="string">&quot;topic_exchange&quot;</span>, <span class="string">&quot;log.#&quot;</span>);</span><br></pre></td></tr></table></figure></li>
<li><p>Headers Exchange（头部交换机）</p>
<ul>
<li><p><strong>路由规则：</strong></p>
<ul>
<li><p>根据消息的 Header 属性进行匹配。</p>
</li>
<li><p>可以设置 <code>x-match</code> 参数：</p>
<ul>
<li><code>all</code>：要求所有 Header 都匹配。</li>
<li><code>any</code>：只要匹配一个 Header 即可。</li>
</ul>
</li>
</ul>
</li>
<li><p><strong>特点：</strong></p>
<ul>
<li>不依赖 Routing Key，根据消息的 Header 属性进行匹配。</li>
<li>消息的 Header 属性需要和绑定的队列中的 Header 完全匹配（可以设置 <code>x-match</code> 参数为 <code>all</code> 或 <code>any</code>）。</li>
<li>灵活支持多维度路由。</li>
</ul>
</li>
<li><p><strong>使用场景：</strong>复杂匹配规则的场景</p>
<ul>
<li>消息中包含多个属性（如 <code>type=order</code>，<code>format=json</code>），需要多维度匹配。</li>
<li>精确路由消息到符合复杂条件的消费者。</li>
</ul>
</li>
<li><p><strong>示例：</strong></p>
<ul>
<li>消息的 Header 为 <code>&#123;&quot;type&quot;: &quot;order&quot;, &quot;format&quot;: &quot;json&quot;&#125;</code>，队列可以绑定类似的 Header。</li>
</ul>
</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">Map&lt;String, Object&gt; headers = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line">headers.put(<span class="string">&quot;type&quot;</span>, <span class="string">&quot;order&quot;</span>);</span><br><span class="line">headers.put(<span class="string">&quot;format&quot;</span>, <span class="string">&quot;json&quot;</span>);</span><br><span class="line">headers.put(<span class="string">&quot;x-match&quot;</span>, <span class="string">&quot;all&quot;</span>); <span class="comment">// all 表示完全匹配</span></span><br><span class="line">channel.exchangeDeclare(<span class="string">&quot;headers_exchange&quot;</span>, <span class="string">&quot;headers&quot;</span>);</span><br><span class="line">channel.queueBind(<span class="string">&quot;queue_1&quot;</span>, <span class="string">&quot;headers_exchange&quot;</span>, <span class="string">&quot;&quot;</span>, headers);</span><br></pre></td></tr></table></figure></li>
<li><p><strong>总结对比</strong></p>
</li>
</ol>
<table>
<thead>
<tr>
<th>类型</th>
<th>路由规则</th>
<th><strong>匹配方式</strong></th>
<th>优点</th>
<th>缺点</th>
<th><strong>使用场景</strong></th>
</tr>
</thead>
<tbody><tr>
<td><strong>Direct</strong></td>
<td>精确匹配 Routing Key</td>
<td>完全匹配</td>
<td>路由简单、精确</td>
<td>需要明确的 Routing Key</td>
<td>精确匹配的场景</td>
</tr>
<tr>
<td><strong>Fanout</strong></td>
<td>广播到所有绑定队列</td>
<td>无需匹配</td>
<td>简单高效，用于广播消息</td>
<td>消息不可过滤，所有队列都接收</td>
<td>广播消息</td>
</tr>
<tr>
<td><strong>Topic</strong></td>
<td>模式匹配 Routing Key</td>
<td>通配符匹配</td>
<td>灵活支持复杂路由规则</td>
<td>路由规则稍复杂</td>
<td>模糊匹配场景</td>
</tr>
<tr>
<td><strong>Headers</strong></td>
<td>匹配消息的 Header 属性</td>
<td>多维度匹配（支持复杂条件）</td>
<td>支持多维度的匹配规则</td>
<td>性能相对较低，配置复杂</td>
<td>复杂条件匹配的场景</td>
</tr>
</tbody></table>
<h4 id="问：RabbitMQ-支持哪些消息模式？比如点对点、发布订阅等"><a href="#问：RabbitMQ-支持哪些消息模式？比如点对点、发布订阅等" class="headerlink" title="问：RabbitMQ 支持哪些消息模式？比如点对点、发布订阅等"></a>问：RabbitMQ 支持哪些消息模式？比如点对点、发布订阅等</h4><p>RabbitMQ 支持多种消息模式，通过不同的 <strong>Exchange</strong> 类型和 <strong>Queue</strong> 的绑定关系来实现不同的消息传递模式。</p>
<ol>
<li><p><strong>点对点模式（Queue-based）</strong></p>
<ul>
<li><p><strong>定义</strong>：点对点模式（也称为 <strong>Work Queue</strong> 模式）是一种传统的消息传递模式，其中 <strong>Producer</strong> 发送消息到一个队列，<strong>Consumer</strong> 从该队列中获取消息进行处理。</p>
</li>
<li><p><strong>特点</strong>：在这种模式下，每个消息只能由一个消费者消费。即使有多个消费者，它们会竞争同一个队列中的消息。</p>
</li>
<li><p><strong>应用场景</strong>：适用于需要任务分发的场景，如任务调度、后台处理等。</p>
</li>
<li><p><strong>RabbitMQ 实现</strong>：通过 <strong>Direct Exchange</strong> 或者 <strong>默认的 Exchange</strong> 实现，生产者将消息发送到一个队列，多个消费者从该队列消费消息。</p>
<p><strong>流程</strong>：</p>
<ol>
<li>Producer 将消息发送到 <strong>Queue</strong>。</li>
<li>Consumer 从 <strong>Queue</strong> 中取出消息进行处理。</li>
</ol>
</li>
</ul>
</li>
<li><p><strong>发布/订阅模式（Publish/Subscribe）</strong></p>
<ul>
<li><p><strong>定义</strong>：发布/订阅模式是一种广播消息的模式，其中消息被发送到多个接收者（消费者）。在这个模式下，生产者发送消息时，消息会被路由到所有的队列中，所有的消费者都会接收到消息。注意每个消费者都要对应一个队列。</p>
</li>
<li><p><strong>特点</strong>：这种模式的特点是消息会被广播到多个订阅者，而不是只发送给一个接收者。</p>
</li>
<li><p><strong>应用场景</strong>：适用于消息需要被多个消费者处理的场景，如日志收集、实时通知等。</p>
</li>
<li><p><strong>RabbitMQ 实现</strong>：通过 <strong>Fanout Exchange</strong> 实现，生产者将消息发送到 <strong>Fanout Exchange</strong>，该 Exchange 会将消息广播到所有与其绑定的队列中。</p>
<p><strong>流程</strong>：</p>
<ol>
<li>Producer 将消息发送到 <strong>Fanout Exchange</strong>。</li>
<li><strong>Fanout Exchange</strong> 将消息广播到所有绑定的队列中。</li>
<li>每个 Consumer 从自己的队列中获取消息进行处理。</li>
</ol>
</li>
</ul>
</li>
<li><p><strong>路由模式（Routing）</strong></p>
<ul>
<li><p><strong>定义</strong>：路由模式是一种基于路由键（<strong>Routing Key</strong>）来控制消息传递的模式。在这种模式下，生产者发送消息时会附带一个路由键，<strong>Exchange</strong> 会根据路由键将消息路由到匹配的队列中。</p>
</li>
<li><p><strong>特点</strong>：不同的消费者根据路由键接收不同的消息。路由键用于精确匹配消息路由，通常用于有多个消费端但只想让某些消费者处理特定消息的场景。</p>
</li>
<li><p><strong>应用场景</strong>：适用于需要按条件进行消息路由的场景，如错误处理、订单处理等。</p>
</li>
<li><p><strong>RabbitMQ 实现</strong>：通过 <strong>Direct Exchange</strong> 实现，生产者发送带有特定 <strong>Routing Key</strong> 的消息，<strong>Direct Exchange</strong> 会根据 <strong>Routing Key</strong> 将消息路由到匹配的队列。</p>
<p><strong>流程</strong>：</p>
<ol>
<li>Producer 将消息发送到 <strong>Direct Exchange</strong>，并指定一个 <strong>Routing Key</strong>。</li>
<li><strong>Direct Exchange</strong> 根据路由键将消息发送到绑定了该路由键的队列。</li>
<li>Consumer 从队列中取出消息进行处理。</li>
</ol>
</li>
</ul>
</li>
<li><p><strong>主题模式（Topic）</strong></p>
<ul>
<li><p><strong>定义</strong>：主题模式是一种更加灵活的消息路由模式，支持复杂的路由规则。通过主题模式，生产者将消息发送到 <strong>Topic Exchange</strong>，并使用带有多个词段的路由键进行消息路由。消费者可以通过通配符匹配路由键来订阅特定类型的消息。</p>
</li>
<li><p><strong>特点</strong>：支持多级路由和模式匹配，允许消费者订阅一类或多类消息。</p>
</li>
<li><p><strong>应用场景</strong>：适用于需要根据多个维度进行消息过滤的场景，如日志分类、消息通知等。</p>
</li>
<li><p><strong>RabbitMQ 实现</strong>：通过 <strong>Topic Exchange</strong> 实现，生产者发送带有 <strong>Routing Key</strong> 的消息，消费者可以使用通配符（如 <code>*</code> 和 <code>#</code>）来匹配路由键。</p>
<p><strong>流程</strong>：</p>
<ol>
<li>Producer 将消息发送到 <strong>Topic Exchange</strong>，并附带一个多段的 <strong>Routing Key</strong>。</li>
<li><strong>Topic Exchange</strong> 根据路由键将消息路由到匹配的队列。</li>
<li>Consumer 使用通配符订阅特定的路由键，从队列中获取消息进行处理。</li>
</ol>
</li>
</ul>
</li>
<li><p><strong>延迟消息模式（Delayed Message）</strong></p>
<ul>
<li><p><strong>定义</strong>：延迟消息模式允许生产者将消息发送到队列中，但消息在指定的延迟时间后才会被消费者消费。</p>
</li>
<li><p><strong>特点</strong>：用于需要延迟处理的消息，避免过快地消费或为了某些特定的调度要求。</p>
</li>
<li><p><strong>应用场景</strong>：适用于需要定时任务、超时消息等场景。</p>
</li>
<li><p><strong>RabbitMQ 实现</strong>：RabbitMQ 可以通过 <strong>Dead Letter Exchange (DLX)</strong> 配合 <strong>TTL（Time-To-Live）</strong> 或 <strong>插件</strong>（如 <code>rabbitmq-delayed-message-exchange</code> 插件）来实现延迟消息。</p>
<p><strong>流程</strong>：</p>
<ol>
<li>Producer 将消息发送到带有延迟设置的 <strong>Exchange</strong>。</li>
<li>消息在指定的时间到达后会被转发到目标队列。</li>
<li>Consumer 从队列中取出消息进行处理。</li>
</ol>
</li>
</ul>
</li>
<li><p><strong>确认机制（Acknowledgment）</strong></p>
<ul>
<li><p><strong>定义</strong>：RabbitMQ 提供了消息的确认机制，用于确保消息在被消费后得到了正确处理。通过确认机制，消费者可以向 RabbitMQ 发送确认（acknowledge）信号，表示消息已被成功消费。</p>
</li>
<li><p><strong>特点</strong>：消费者在处理完消息后发送一个确认信号，如果没有确认消息，RabbitMQ 会重新将消息投递给其他消费者。</p>
</li>
<li><p><strong>应用场景</strong>：适用于确保消息不丢失的场景。</p>
</li>
<li><p>RabbitMQ 提供了两种确认机制：</p>
<ul>
<li>自动确认：消费者消费消息后自动发送确认。</li>
<li>手动确认：消费者处理完消息后显式发送确认信号。</li>
</ul>
</li>
</ul>
</li>
</ol>
<h4 id="问：RabbitMQ-的连接和信道（Channel）有何区别？为什么要使用信道而不是直接操作连接？"><a href="#问：RabbitMQ-的连接和信道（Channel）有何区别？为什么要使用信道而不是直接操作连接？" class="headerlink" title="问：RabbitMQ 的连接和信道（Channel）有何区别？为什么要使用信道而不是直接操作连接？"></a>问：RabbitMQ 的连接和信道（Channel）有何区别？为什么要使用信道而不是直接操作连接？</h4><p>📌 <strong>1. 什么是连接（Connection）？</strong></p>
<ul>
<li><strong>概念</strong>：连接是指 <strong>应用程序与 RabbitMQ Broker</strong> 之间建立的一个 <strong>TCP 连接</strong>，是消息通信的基础。<ul>
<li>每个连接使用一个 TCP 套接字（Socket）。</li>
<li>连接通过 AMQP 协议与 RabbitMQ 进行消息通信。</li>
</ul>
</li>
<li><strong>创建方式</strong>：通过 RabbitMQ 提供的客户端库（如 Java 中的 <code>ConnectionFactory</code>）建立连接。</li>
</ul>
<blockquote>
<p><strong>代码示例</strong>：</p>
</blockquote>
<figure class="highlight reasonml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">ConnectionFactory factory = <span class="keyword">new</span> <span class="constructor">ConnectionFactory()</span>;</span><br><span class="line">factory.set<span class="constructor">Host(<span class="string">&quot;localhost&quot;</span>)</span>;</span><br><span class="line">Connection connection = factory.<span class="keyword">new</span><span class="constructor">Connection()</span>;</span><br></pre></td></tr></table></figure>

<ul>
<li>特点：<ul>
<li>建立和关闭连接的<strong>开销大</strong>（涉及网络和协议握手）。</li>
<li><strong>一个客户端通常只维护少量连接</strong>，如微服务中通常每个应用维护一个长连接。</li>
<li>支持<strong>多通道复用</strong>，即在一个连接上可以创建多个 Channel。</li>
</ul>
</li>
</ul>
<p>📌 <strong>2. 什么是信道（Channel）？</strong></p>
<ul>
<li><strong>概念</strong>：信道是建立在<strong>连接之上的逻辑通道</strong>，RabbitMQ 使用信道来处理消息的发送、接收、队列声明等操作。<ul>
<li><strong>每个 AMQP 命令</strong>（如发布消息、消费消息）都是通过信道执行的。</li>
<li>一个 TCP 连接可以创建多个信道，<strong>每个信道是独立的</strong>。</li>
</ul>
</li>
<li><strong>创建方式</strong>：通过连接的 <code>createChannel()</code> 方法创建信道。</li>
</ul>
<blockquote>
<p><strong>代码示例</strong>：</p>
</blockquote>
<figure class="highlight reasonml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Channel channel = connection.create<span class="constructor">Channel()</span>;</span><br><span class="line">channel.queue<span class="constructor">Declare(<span class="string">&quot;myQueue&quot;</span>, <span class="params">false</span>, <span class="params">false</span>, <span class="params">false</span>, <span class="params">null</span>)</span>;</span><br><span class="line">channel.basic<span class="constructor">Publish(<span class="string">&quot;&quot;</span>, <span class="string">&quot;myQueue&quot;</span>, <span class="params">null</span>, <span class="string">&quot;Hello RabbitMQ&quot;</span>.<span class="params">getBytes</span>()</span>);</span><br></pre></td></tr></table></figure>

<ul>
<li>特点：<ul>
<li><strong>轻量级</strong>，比建立新连接的开销小。</li>
<li><strong>线程隔离</strong>，每个线程使用一个独立的 Channel 进行通信。</li>
<li>支持<strong>多通道并发</strong>，提高资源利用率。</li>
</ul>
</li>
</ul>
<p>📊 <strong>3. 连接（Connection）与信道（Channel）对比</strong></p>
<table>
<thead>
<tr>
<th>特性</th>
<th>连接（Connection）</th>
<th>信道（Channel）</th>
</tr>
</thead>
<tbody><tr>
<td><strong>本质</strong></td>
<td><strong>TCP 连接</strong>，应用与 RabbitMQ 服务器间的物理连接</td>
<td><strong>逻辑连接</strong>，在 TCP 连接之上的虚拟通道</td>
</tr>
<tr>
<td><strong>性能消耗</strong></td>
<td>创建和关闭成本<strong>高</strong>，涉及网络通信和握手</td>
<td>创建和关闭成本<strong>低</strong>，是连接的轻量级抽象</td>
</tr>
<tr>
<td><strong>多路复用</strong></td>
<td><strong>不支持</strong>，每个连接只能独立工作</td>
<td><strong>支持</strong>，一个连接上可以有<strong>多个信道</strong></td>
</tr>
<tr>
<td><strong>隔离性</strong></td>
<td><strong>跨线程不可共享</strong>，每个线程使用独立的连接</td>
<td><strong>线程隔离</strong>，每个线程使用自己的 Channel</td>
</tr>
<tr>
<td><strong>并发能力</strong></td>
<td><strong>差</strong>，适合小量长连接，<strong>不适合大量并发</strong></td>
<td><strong>强</strong>，一个连接可有多个 Channel，适合高并发</td>
</tr>
<tr>
<td><strong>使用场景</strong></td>
<td>长连接、服务级别通信，如<strong>微服务间通信</strong></td>
<td>消息发送、消费、队列管理，适合<strong>多线程环境</strong></td>
</tr>
<tr>
<td><strong>故障恢复</strong></td>
<td>连接断开时，需要重新建立连接</td>
<td>Channel 依赖于 Connection，需先恢复连接</td>
</tr>
<tr>
<td><strong>资源消耗</strong></td>
<td><strong>高</strong>，消耗 TCP 资源，每个连接约占 100 KB+</td>
<td><strong>低</strong>，每个信道仅占少量内存</td>
</tr>
<tr>
<td><strong>协议支持</strong></td>
<td>支持 AMQP 协议、TLS 加密等</td>
<td>仅处理 AMQP 命令，不涉及底层通信</td>
</tr>
</tbody></table>
<p>📌 <strong>4. 为什么要使用信道（Channel）而不是直接操作连接？</strong></p>
<p>✅ <strong>1. 提高性能，减少资源消耗</strong></p>
<ul>
<li>每建立一个 TCP <strong>连接</strong>，都需要进行<strong>三次握手、SSL 加密</strong>（如有），成本高。</li>
<li><strong>Channel 是轻量级</strong>，在同一个 TCP 连接上可以创建<strong>数万个信道</strong>，降低系统资源消耗。</li>
</ul>
<p>✅ <strong>2. 支持多线程并发</strong></p>
<ul>
<li><strong>多线程环境</strong>下，每个线程使用独立 Channel，可以实现<strong>多队列并发消费</strong>，而不需要为每个线程创建独立 TCP 连接。</li>
</ul>
<p>✅ <strong>3. 简化连接管理</strong></p>
<ul>
<li>RabbitMQ 有<strong>连接数限制</strong>（如默认最大连接数为 65536），使用 Channel 可以在单连接下处理多个消费者，避免连接爆炸。</li>
</ul>
<p>✅ <strong>4. 提高吞吐量</strong></p>
<ul>
<li>通过 <strong>多 Channel 并发</strong>，能有效提高消息的发布和消费速度，适合<strong>高并发场景</strong>。</li>
</ul>
<p>✅ <strong>5. 提升容错能力</strong></p>
<ul>
<li>如果某个信道发生异常（如<strong>消息处理失败</strong>），不会影响其他信道的消息传输，增强系统的<strong>稳定性和隔离性</strong>。</li>
</ul>
<p>📌 <strong>5. 实际开发中的最佳实践</strong></p>
<ol>
<li><strong>一个服务维护一个 TCP 连接，多个线程使用各自的 Channel</strong>。</li>
<li><strong>长连接、短信道</strong>：保持连接持久化，避免频繁建立连接，按需创建和释放 Channel。</li>
<li><strong>消费者-信道 1:1</strong>：每个消费者使用一个独立 Channel，避免多线程竞争。</li>
<li><strong>设置 Channel 预取值</strong>（<code>basicQos</code>）：优化消费速度，避免消息积压。</li>
<li><strong>异常处理</strong>：捕获 Channel 异常，自动重连，提升系统可靠性。</li>
</ol>
<p>📌 <strong>6. 面试高分回答示例</strong></p>
<blockquote>
<p>RabbitMQ 中，<strong>连接（Connection）</strong> 是与 Broker 建立的<strong>TCP 物理连接</strong>，而 <strong>信道（Channel）</strong> 是在连接上的<strong>逻辑通道</strong>，用于执行消息的发布、消费等操作。</p>
<p>在实际使用中，<strong>一个 TCP 连接可以复用多个 Channel</strong>，相比于直接操作连接，Channel <strong>创建成本更低、性能更好、支持多线程并发</strong>，可以有效提高 RabbitMQ 系统的吞吐量和稳定性。因此，我们通常会使用<strong>一个连接配多个 Channel</strong> 的方式来优化资源使用和并发能力。</p>
</blockquote>
<h4 id="问：消息确认机制？为什么需要确认机制？"><a href="#问：消息确认机制？为什么需要确认机制？" class="headerlink" title="问：消息确认机制？为什么需要确认机制？"></a>问：消息确认机制？为什么需要确认机制？</h4><ol>
<li><p>消息确认机制的作用？<strong>为什么需要确认机制？</strong></p>
<ul>
<li><strong>消息确认机制（Message Acknowledgment）确保消息不会丢失</strong></li>
<li>有助于解决以下问题：<ol>
<li><strong>消息丢失</strong>：如果消费者处理消息时出现故障，消息可能会丢失。消息确认机制确保只有在消息被成功处理后，才从队列中移除消息，从而避免丢失。</li>
<li><strong>重复消费</strong>：如果消费者没有确认消息，RabbitMQ 会认为该消息没有被成功消费，并会重新投递给其他消费者，防止消息丢失。</li>
<li><strong>事务一致性</strong>：在消费过程中出现的异常（如崩溃、超时等）可能导致未确认的消息需要重新投递，确保系统的一致性。</li>
</ol>
</li>
</ul>
</li>
<li><p>自动确认和手动确认机制？</p>
<ul>
<li><p><strong>自动确认（Auto-Acknowledge）</strong>：<strong>消费者从队列中取出消息</strong>后，RabbitMQ 会立即认为该消息已经被成功消费并自动确认。消费者不会主动发送确认信号。</p>
<ul>
<li>这种模式下，如果消费者处理消息时崩溃或发生其他错误，RabbitMQ 无法得知消息是否成功处理，从而可能导致消息丢失。</li>
<li><strong>缺点</strong>：<ul>
<li>消费者崩溃时，消息无法重新投递。</li>
<li>不适合有可靠性要求的场景。</li>
</ul>
</li>
<li><strong>适用场景</strong>：消息丢失不影响业务流程的场景（例如，日志收集等）。</li>
</ul>
</li>
<li><p><strong>手动确认（Manual Acknowledge）</strong>消费者在成功处理消息后，必须显式地向 RabbitMQ 发送一个 <strong>acknowledge</strong>（ack）信号，表示消息已被正确处理。如果消费者未确认消息，RabbitMQ 会认为该消息未成功消费，并会重新投递给其他消费者。如果消费者在处理消息时遇到异常，未确认的消息会被重新投递，保证消息不会丢失。</p>
<ul>
<li><strong>确认流程</strong>：<ol>
<li><strong>消费者接收消息</strong>：当消息从队列投递到消费者时，消息的状态是“未确认”（Unacknowledged）。</li>
<li><strong>消费者处理消息</strong>：消费者接收并处理消息。</li>
<li><strong>消费者发送确认信号</strong>：处理完毕后，消费者显式地向 RabbitMQ 发送一个确认信号。如果处理成功，消费者会通过 <code>basicAck</code> 向 RabbitMQ 发送确认信号。如果消费者失败或崩溃，RabbitMQ 会认为该消息未处理成功。<ul>
<li><code>basicAck</code>: 用于确认一条或多条消息已被成功处理，消息将从队列中移除。</li>
<li><code>basicNack</code>: 用于拒绝消息，并且可以选择是否重新排队（投递给其他消费者）</li>
</ul>
</li>
<li><strong>RabbitMQ 确认消息</strong>：RabbitMQ 收到确认信号后，从队列中移除该消息。</li>
<li><strong>消息重新投递</strong>：如果消费者未确认消息（例如消费者崩溃或处理失败），RabbitMQ 会将该消息重新投递给其他消费者，以确保消息不丢失。</li>
</ol>
</li>
<li><strong>优点</strong>：<ul>
<li>提供了更高的可靠性和灵活性，确保消息不会丢失。</li>
<li>如果消费者处理消息时崩溃，消息会被重新投递。</li>
</ul>
</li>
</ul>
<ul>
<li><strong>适用场景</strong>：对消息可靠性要求较高的场景，如财务交易、订单处理等。</li>
<li><strong>消息拒绝与重新投递</strong>，在手动确认机制中，消费者可以通过拒绝消息的方式让 RabbitMQ 重新投递消息。消息拒绝的方式有：<ul>
<li><code>basicReject</code>：直接拒绝一条消息，可以选择将消息重新放回队列或丢弃。</li>
<li><code>basicNack</code>：可以拒绝多条消息，并决定是否重新将这些消息放入队列。</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ol>
<ol start="3">
<li><p><strong>消息确认机制的优点与缺点</strong>？</p>
<p><strong>优点</strong></p>
<ul>
<li><strong>可靠性高</strong>：通过手动确认，能够确保只有在消息被正确处理后，才从队列中移除。</li>
<li><strong>消息不丢失</strong>：如果消费者崩溃或出现错误，未确认的消息会重新投递，保证消息不会丢失。</li>
<li><strong>灵活性</strong>：消费者可以控制何时确认消息，确保业务逻辑处理完毕后才确认。</li>
</ul>
<p><strong>缺点</strong></p>
<ul>
<li><strong>性能开销</strong>：手动确认会引入额外的操作和开销，因为需要发送确认信号和处理未确认消息的重新投递。</li>
<li><strong>消息积压</strong>：如果消费者处理不及时或者队列消费能力不足，未确认的消息会积压，可能导致系统压力增大。</li>
</ul>
</li>
</ol>
<h4 id="问：持久化机制？如何配置持久化消息？如何处理-RabbitMQ-中的消息丢失问题？设置了队列和消息持久化能保证百分百不丢失消息了吗？"><a href="#问：持久化机制？如何配置持久化消息？如何处理-RabbitMQ-中的消息丢失问题？设置了队列和消息持久化能保证百分百不丢失消息了吗？" class="headerlink" title="问：持久化机制？如何配置持久化消息？如何处理 RabbitMQ 中的消息丢失问题？设置了队列和消息持久化能保证百分百不丢失消息了吗？"></a>问：持久化机制？如何配置持久化消息？如何处理 RabbitMQ 中的消息丢失问题？设置了队列和消息持久化能保证百分百不丢失消息了吗？</h4><ul>
<li><p>什么是 RabbitMQ 的持久化机制？</p>
<ul>
<li><p><strong>RabbitMQ 的持久化机制</strong>是确保消息在 RabbitMQ 宕机或重启后不会丢失的关键功能。持久化机制通过将消息数据持久保存在磁盘中，从而确保在 RabbitMQ 重启或故障时，消息不会丢失，可以从磁盘恢复。</p>
</li>
<li><p>主要包括 <strong>队列持久化</strong> 和 <strong>消息持久化</strong>。</p>
<ol>
<li><p>队列持久化（Queue Durability）指队列本身是否会在 RabbitMQ 重启后保留。默认情况下，RabbitMQ 队列是非持久化的，意味着队列会在 RabbitMQ 重启时丢失。要确保队列在重启后不丢失，需要将队列设置为持久化（<code>durable</code>）。</p>
<ul>
<li><strong>队列持久化配置</strong>：当声明队列时，需要指定 <code>durable</code> 参数为 <code>true</code>。</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">channel.queueDeclare(<span class="string">&quot;myQueue&quot;</span>, <span class="keyword">true</span>, <span class="keyword">false</span>, <span class="keyword">false</span>, <span class="keyword">null</span>);</span><br></pre></td></tr></table></figure>

<ul>
<li><code>true</code>：表示队列是持久化的。</li>
<li><code>false</code>：表示队列是临时的，会在 RabbitMQ 重启时丢失。</li>
</ul>
<p><strong>注意</strong>：即使队列是持久化的，RabbitMQ 在重启后也只能恢复已持久化的消息。如果消息没有持久化，重启后这些消息将会丢失。</p>
</li>
<li><p>消息持久化（Message Persistence）指的是消息是否会在 RabbitMQ 重启后被保留。即使队列是持久化的，只有在消息本身被标记为持久化时，这条消息才会在 RabbitMQ 重启后得以恢复。</p>
<ul>
<li><strong>消息持久化配置</strong>：在发布消息时，可以设置 <code>delivery_mode</code> 为 <code>2</code>，表示消息是持久化的。</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">AMQP.BasicProperties properties = <span class="keyword">new</span> AMQP.BasicProperties.Builder()</span><br><span class="line">        .deliveryMode(<span class="number">2</span>)  <span class="comment">// 设置消息为持久化</span></span><br><span class="line">        .build();</span><br><span class="line">channel.basicPublish(<span class="string">&quot;&quot;</span>, <span class="string">&quot;myQueue&quot;</span>, properties, <span class="string">&quot;Persistent Message&quot;</span>.getBytes());</span><br></pre></td></tr></table></figure>

<ul>
<li><code>deliveryMode = 2</code>：表示消息持久化，RabbitMQ 会将消息写入磁盘。</li>
<li><code>deliveryMode = 1</code>（默认值）：表示消息是非持久化的，消息会存储在内存中。</li>
</ul>
<p><strong>注意</strong>：消息的持久化会导致性能开销，因为每条消息都要写入磁盘，可能会影响系统吞吐量。</p>
</li>
</ol>
</li>
</ul>
</li>
<li><p>持久化机制工作原理？</p>
<ul>
<li><strong>持久化队列</strong>：当队列声明为持久化时，RabbitMQ 会把队列的定义保存在磁盘上。即使 RabbitMQ 重启，持久化队列会被恢复。</li>
<li><strong>持久化消息</strong>：持久化的消息会被写入到磁盘上的日志文件（例如 <code>msg_store</code> 文件），而不是仅保存在内存中。（调用内核的 <code>fsync</code> 方法）</li>
<li><strong>内存和磁盘的结合</strong>：为了提升性能，RabbitMQ 会将一部分消息缓存到内存中，但是当内存满了或消息设置为持久化时，消息会被写入磁盘。</li>
</ul>
</li>
<li><p>使用场景</p>
<ul>
<li><p>适合持久化队列和消息：在需要确保消息不丢失，且即使 RabbitMQ 宕机，消息也能恢复的场景。</p>
<ul>
<li>例如：电子商务订单消息、支付事务消息等需要高可靠性的场景。</li>
</ul>
</li>
<li><p><strong>注意性能影响</strong>：持久化消息会导致性能开销。特别是在高吞吐量的场景中，如果对持久化有要求，可能会影响系统吞吐量。因此，在高性能要求场景下，需要仔细考虑是否启用持久化。</p>
</li>
</ul>
</li>
<li><p>如何配置持久化消息</p>
<ul>
<li><strong>队列持久化</strong>：<code>channel.queueDeclare(queueName, true, false, false, null);</code></li>
<li><strong>消息持久化</strong>：<code>AMQP.BasicProperties properties = new AMQP.BasicProperties.Builder().deliveryMode(2).build();</code></li>
</ul>
</li>
<li><p>设置了队列和消息持久化能保证百分百不丢失消息了吗？</p>
<p>不能：</p>
<ol>
<li><p><strong>消息未到达Broker就丢失</strong>：比如网络故障或生产者在basicPublish后崩溃。</p>
<ul>
<li>开启Publisher Confirm生产者确认。生产者将信道设置成 confirm （确认）模式，一旦信道进入 confirm 模式，所有在该信道上面发布的消息都会被指派一个唯一的ID （从1开始），一旦消息被投递到所有匹配的队列之后， RabbitMQ 会发送一个确认（ <code>Basic.Ack</code> ）给生产者（包含消息的唯一ID ），这就使得生产者知晓消息已经正确到达了目的地了。</li>
</ul>
</li>
<li><p><strong>消息写入磁盘前丢失</strong>：消息存入RabbitMQ后还需一段时间才能存入磁盘。未及时刷盘MQ就崩溃，消息丢失。磁盘发生故障，持久化消息无法恢复。</p>
<ul>
<li><p>开启强制刷盘（sync_flush），在rabbitmq.conf中添加<code>queue_master_locator = min-masters</code> 。RabbitMQ 默认采用<strong>异步刷盘</strong>，即消息先进入<strong>内存缓存（RAM Cache）</strong>，然后<strong>批量刷盘</strong>。<strong>开启强制刷盘</strong>后，RabbitMQ <strong>每次接收持久化消息</strong>时，都会<strong>立即调用 fsync()<strong>，将消息同步写入磁盘，确保数据不会因为缓存丢失。适用于对消息</strong>丢失零容忍</strong>的场景，但会显著降低 RabbitMQ 的<strong>性能</strong>。</p>
<figure class="highlight ini"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 队列镜像数据强制刷盘</span></span><br><span class="line"><span class="attr">queue_master_locator</span> = min-masters</span><br><span class="line"></span><br><span class="line"><span class="comment"># 强制每条消息都立即刷盘</span></span><br><span class="line"><span class="attr">disk_sync_interval</span> = <span class="number">0</span></span><br></pre></td></tr></table></figure></li>
<li><p>开启TX事务机制，但严重影响性能，基本不使用。</p>
</li>
<li><p>开启Publisher Confirm生产者确认。如果消息和队列是可持久化的，那么确认消息会在消息写入磁盘之后发出。RabbitMQ 回传给生产者的确认消息中的 deliveryTag 包含了确认消息的序号，此外 RabbitMQ 可以设置 <code>channel.basicAck</code> 方法中的 multiple 参数，表示到这个序号之前的所有消息都己经得到了处理。事务机制在一条消息发送之后会使发送端阻塞，以等待 RabbitMQ 的回应，之后才能继续发送下一条消息。相比之下，<strong>发送方确认机制最大的好处在于它是异步的</strong>，一旦发布一条消息， 生产者应用程序就可以在等信道返回确认的同时继续发送下一条消息，当消息最终得到确认之后，生产者应用程序便可以通过回调方法来处理该确认消息，如果 RabbitMQ 因为自身内部错误导致消息丢失，就会发送一条 nack ( <code>Basic.Nack</code> ）命令，生产者应用程序同样可以在回调方法中处理该 nack 命令。</p>
</li>
<li><p><strong>引入 RabbitMQ 镜像队列机制</strong>，相当于配置了副本，如果主节点（ master ）在此特殊时间内挂掉，可以自动切换到从节点，这样有效地保证了高可用性，除非整个集群都挂掉。虽然这样也不能完全保证 RabbitMQ 消息不丢失，但是配置了镜像队列要比没有配置镜像队列的可靠性要高很多，在实际生产环境中的关键业务队列一般都会设置镜像队列。</p>
</li>
</ul>
</li>
<li><p><strong>消息投递给消费者后丢失</strong>：消费者设置自动确认模式（autoAck=true），当消费者宕机，一样是消息丢失。</p>
<ul>
<li>设置autoAck=false开启手动确认</li>
</ul>
</li>
<li><p><strong>主从节点切换导致数据丢失</strong>：使用 <strong>镜像队列（Mirrored Queue）</strong> 实现高可用，但<strong>主节点崩溃但尚未同步消息</strong>到从节点，消息会丢失。<strong>脑裂</strong>现象，主从节点通信异常，部分消息可能丢失或重复。</p>
<ul>
<li>开启 <strong>镜像队列</strong> 并配置 <code>ha-mode</code> 和 <code>ha-sync-mode</code>。</li>
</ul>
</li>
<li><p><strong>消息 TTL 过期丢失</strong>：消息未及时消费会被自动丢弃。</p>
<ul>
<li>使用 <strong>死信队列（DLX, Dead Letter Exchange）</strong> 记录和处理超时消息。</li>
</ul>
</li>
</ol>
</li>
</ul>
<h4 id="问：消费者预取（Prefetch）机制？如何配置？"><a href="#问：消费者预取（Prefetch）机制？如何配置？" class="headerlink" title="问：消费者预取（Prefetch）机制？如何配置？"></a>问：消费者预取（Prefetch）机制？如何配置？</h4><ul>
<li><p>RabbitMQ 消费者预取（Prefetch）机制是什么？</p>
<ul>
<li><strong>预取（Prefetch）</strong>是 RabbitMQ 中的一个重要概念，它<strong>控制消费者每次从队列中获取的消息数量</strong>，<strong>避免消费者在处理一条消息时大量地占用队列中的其他消息</strong>。通过设置预取值，可以优化消费者的性能，<strong>避免消费者因处理慢而导致队列消息积压</strong>，或者避免消费者因过多的消息并发处理而造成资源浪费。</li>
</ul>
</li>
<li><p>为什么需要设置预取？</p>
<ol>
<li><strong>避免队列消息积压</strong>：当没有设置预取数量时，消费者可能会一次性获取队列中的所有消息。如果某个消费者处理消息过慢，它可能会被大量未处理的消息阻塞，导致系统负载过高，或者资源被浪费。</li>
<li><strong>平衡负载</strong>：通过设置预取数量，可以让多个消费者均匀地分配队列中的消息。如果某个消费者处理较慢，其他消费者仍然可以继续工作，避免单一消费者的负载过高。</li>
<li><strong>提升系统性能</strong>：适当的预取设置可以确保消息被及时消费，并且防止消费者因消息堆积过多而出现性能瓶颈。例如，如果某个消费者处理较慢，设置较低的预取数量可以让它专心处理少量的消息，从而减少错误和资源的浪费。</li>
<li><strong>资源优化</strong>：设置适当的预取数量能够帮助节省消费者端的内存和 CPU 资源。例如，在一些高流量的场景下，设置预取数量为 <code>1</code>，可以避免消费者一次处理大量消息而导致内存占用过大。</li>
</ol>
</li>
<li><p>预取机制的优缺点</p>
<p>优点：</p>
<ul>
<li><strong>提高吞吐量</strong>：通过控制消费者的并发消息量，预取可以帮助系统更平衡地分配消息，提升整体吞吐量。</li>
<li><strong>降低内存消耗</strong>：预取数量可以控制消费者在处理消息时占用的内存，避免过多消息堆积在消费者端，导致内存占用过高。</li>
<li><strong>优化性能</strong>：合理的预取设置可以有效减少消息积压，避免过多的消息积压导致消费者处理慢或者资源浪费。</li>
</ul>
<p>缺点：</p>
<ul>
<li><strong>可能导致消息处理不及时</strong>：如果设置的预取数量过低，消费者可能会因为处理较少的消息而未能及时消费队列中的其他消息，导致处理延迟。</li>
<li><strong>增加复杂性</strong>：需要根据实际负载和业务场景来调整预取数量，过高或过低的预取数量都可能影响系统性能。</li>
</ul>
</li>
<li><p>预取机制的工作原理？</p>
<ul>
<li><strong>默认行为</strong>：默认情况下，消费者会从队列中获取所有未被消费的消息，直到队列为空。这样做可能会导致消费者处理不及时时积压大量的消息，甚至导致内存溢出。</li>
<li><strong>预取设置</strong>：通过设置消费者的 <strong>预取数量（prefetch count）</strong>，消费者在收到消息时只会一次性获取指定数量的消息。当消费者处理完这些消息后，再向队列请求新的消息。通过限制消费者一次性获取消息的数量，可以平衡系统负载，避免过多消息堆积。</li>
</ul>
<p>预取机制的核心是通过限制消费者每次能够取走多少消息来控制消息的流量，防止消费者由于处理过慢或者不可控的负载而影响整体系统的稳定性。</p>
</li>
</ul>
<ul>
<li><p>如何配置？</p>
<p>消费者预取的配置</p>
<p>RabbitMQ 通过 <code>basic.qos</code> 方法来设置预取数量。该方法用于设置每个消费者每次从队列中获取的最大消息数量（<code>prefetch count</code>）和消息的预取策略。</p>
<p>配置方法：<code>basic.qos</code></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// channel.basicQos(prefetchCount, prefetchSize, global);</span></span><br><span class="line">channel.basicQos(<span class="number">1</span>);  <span class="comment">// 设置每个消费者最多只会预取 1 条消息</span></span><br></pre></td></tr></table></figure>

<ul>
<li>**<code>prefetchCount</code>**：表示每个消费者最多可以预取的消息数量。比如设置为 <code>1</code>，每次只允许消费者获取 1 条消息，直到处理完当前消息，消费者才会请求新消息。</li>
<li>**<code>prefetchSize</code>**：表示每个消费者最多可以预取的消息的字节数。通常这个参数不常用，主要用于限制消息的大小（例如，较大的消息）。</li>
<li>**<code>global</code>**：布尔值，表示是否对所有消费者生效。默认为 <code>false</code>，表示只对当前信道的消费者生效。如果设置为 <code>true</code>，则表示对该队列中的所有消费者都生效。</li>
</ul>
<p>如何配置消费者预取</p>
<ol>
<li><strong>设置预取数量（Prefetch Count）</strong></li>
</ol>
<p>你可以在消费者启动时通过 <code>basic.qos</code> 方法来设置每个消费者的预取数量，来限制消费者每次能接收多少消息。比如设置为 <code>1</code>，即每次消费者最多只能接收 1 条消息，直到消息处理完毕，才会请求新的消息。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 例如：设置每个消费者最多接收 1 条消息</span></span><br><span class="line">channel.basicQos(<span class="number">1</span>);</span><br></pre></td></tr></table></figure>

<p>这样，消费者每次处理 1 条消息后，才会接收新的消息，避免过度加载。</p>
<ol start="2">
<li><strong>全局设置预取数量</strong></li>
</ol>
<p>如果你希望设置队列中的所有消费者共享相同的预取数量，可以将 <code>global</code> 参数设置为 <code>true</code>。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 对所有消费者都设置预取数量</span></span><br><span class="line">channel.basicQos(<span class="number">1</span>, <span class="keyword">true</span>);  <span class="comment">// 全局设置预取数量为 1</span></span><br></pre></td></tr></table></figure>

<p>这时，无论有多少消费者，每个消费者都最多处理 1 条消息。</p>
</li>
<li></li>
</ul>
<h4 id="问：死信队列（Dead-Letter-Queue-DLQ）？如何使用它？如何处理失败的消息？"><a href="#问：死信队列（Dead-Letter-Queue-DLQ）？如何使用它？如何处理失败的消息？" class="headerlink" title="问：死信队列（Dead Letter Queue, DLQ）？如何使用它？如何处理失败的消息？"></a>问：死信队列（Dead Letter Queue, DLQ）？如何使用它？如何处理失败的消息？</h4><ul>
<li><p>什么是死信队列？</p>
<ul>
<li><p><strong>RabbitMQ 中的死信队列（Dead Letter Queue, DLQ）</strong> 是一种特殊的队列，用于<strong>存储那些由于某些原因无法被正常消费的消息</strong>。</p>
</li>
<li><p>这些消息通常会在以下几种情况发生时被转发到死信队列：</p>
<ul>
<li><strong>消息被拒绝或 nack</strong>：消息被消费者拒绝（<code>basic.reject</code> 或 <code>basic.nack</code>）并且没有重新入队（<code>requeue = false</code>）。</li>
<li><strong>队列溢出</strong>：队列达到了最大长度限制（<code>x-max-length</code>），最旧的消息会被丢弃。</li>
<li><strong>消息过期</strong>：队列中存在过期的消息（即 TTL ，Time To Live到期）。</li>
<li><strong>消息不可消费</strong>：当某些消息由于格式错误、缺失必要的信息或其他业务逻辑原因无法被消费者正常处理时，可能被放入死信队列。</li>
</ul>
</li>
</ul>
</li>
<li><p>使用场景：</p>
<ol>
<li><strong>消息重试机制</strong>：当某些消息由于消费者不可用或其它问题暂时无法处理时，可以将消息放入死信队列中，稍后再进行重试。可以在消息消费失败时将其重新入队，直到被成功处理。</li>
<li><strong>报警和监控</strong>：死信队列可以用于监控系统的异常情况。当消息被转发到死信队列时，可以通过监控警告机制告知开发人员某些消息未被成功消费，从而采取进一步的补救措施。</li>
<li><strong>数据恢复和备份</strong>：死信队列可用于保存无法消费的消息，以便在后期进行数据恢复或备份。系统管理员可以定期检查死信队列的内容并采取适当的措施（例如修复消息格式、重新入队等）。</li>
<li><strong>数据分析</strong>：死信队列中的消息通常是无法正常处理的，可以对这些消息进行分析，找出问题的根本原因，例如错误的消息格式、无效的业务数据等。</li>
</ol>
</li>
</ul>
<ul>
<li><p>如何配置死信队列（DLQ）？</p>
<ul>
<li><p>配置死信队列的步骤：</p>
<ol>
<li><strong>配置死信交换器（DLX）</strong>：设置死信交换器，定义消息当无法处理时应该转发到哪个交换器。</li>
<li><strong>配置死信队列</strong>：指定消息丢弃或未被消费时，将其转发到死信队列。</li>
<li><strong>配置普通队列的死信属性</strong>：指定哪些队列发生死信后发送到哪个死信交换器。OR <strong>配置死信路由键（DLRK）</strong>：设置消息转发到死信队列时的路由键。</li>
</ol>
</li>
<li><p>创建案例：假设我们有一个普通队列 <code>normal_queue</code> 和一个死信队列 <code>dead_letter_queue</code>，我们想把被丢弃或无法消费的消息发送到 <code>dead_letter_queue</code>。我们可以按照以下步骤进行配置。</p>
<ol>
<li><p><strong>创建死信交换器和队列</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 1.声明死信交换器</span></span><br><span class="line">channel.exchangeDeclare(<span class="string">&quot;dlx_exchange&quot;</span>, <span class="string">&quot;direct&quot;</span>);</span><br><span class="line"><span class="comment">// 2.声明死信队列</span></span><br><span class="line">channel.queueDeclare(<span class="string">&quot;dead_letter_queue&quot;</span>, <span class="keyword">true</span>, <span class="keyword">false</span>, <span class="keyword">false</span>, <span class="keyword">null</span>); </span><br><span class="line"></span><br><span class="line"><span class="comment">// 3.将死信队列绑定到一个交换器（可以选择默认交换器或者自定义的交换器）</span></span><br><span class="line">channel.queueBind(<span class="string">&quot;dead_letter_queue&quot;</span>, <span class="string">&quot;dlx_exchange&quot;</span>, <span class="string">&quot;dlx_routing_key&quot;</span>);</span><br><span class="line">channel.queueBind(<span class="string">&quot;dead_letter_queue&quot;</span>, <span class="string">&quot;&quot;</span>, <span class="string">&quot;dlx_routing_key&quot;</span>); </span><br></pre></td></tr></table></figure></li>
<li><p><strong>设置普通队列的死信参数</strong></p>
<ul>
<li>**<code>x-dead-letter-exchange</code>**：指定死信队列使用的交换机。</li>
<li>**<code>x-dead-letter-routing-key</code>**：指定将消息路由到死信队列的路由键。</li>
<li>**<code>x-message-ttl</code>**（可选）：设置消息的过期时间。</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 4.通过参数指定普通队列的死信属性</span></span><br><span class="line">Map&lt;String, Object&gt; args = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line">args.put(<span class="string">&quot;x-dead-letter-exchange&quot;</span>, <span class="string">&quot;dlx_exchange&quot;</span>); <span class="comment">// 死信交换机</span></span><br><span class="line">args.put(<span class="string">&quot;x-dead-letter-routing-key&quot;</span>, <span class="string">&quot;dlx_routing_key&quot;</span>); <span class="comment">// 死信路由键</span></span><br><span class="line">args.put(<span class="string">&quot;x-message-ttl&quot;</span>, <span class="number">60000</span>); <span class="comment">// 消息过期时间（可选）</span></span><br><span class="line">channel.queueDeclare(<span class="string">&quot;normal_queue&quot;</span>, <span class="keyword">true</span>, <span class="keyword">false</span>, <span class="keyword">false</span>, args);</span><br></pre></td></tr></table></figure></li>
<li><p><strong>消费者手动处理死信队列</strong>：</p>
<p>消费者可以根据需要从死信队列中消费消息并进行相应的处理：</p>
<ul>
<li><strong>日志记录</strong>：记录消息的失败原因、队列信息、消息内容等，便于后续排查。</li>
<li><strong>持久化存储</strong>：将失败消息存储到数据库或文件中，等待人工分析或重新处理。</li>
<li><strong>报警</strong>：通过邮件、短信、监控系统触发报警，提醒开发或运维团队。</li>
<li><strong>重新入队</strong>：在分析消息后，尝试将其重新发布到原队列或一个备用处理队列。</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 创建消费者处理死信队列</span></span><br><span class="line">channel.basicConsume(<span class="string">&quot;dead_letter_queue&quot;</span>, <span class="keyword">true</span>, (consumerTag, message) -&gt; &#123;</span><br><span class="line">    String msg = <span class="keyword">new</span> String(message.getBody(), <span class="string">&quot;UTF-8&quot;</span>);</span><br><span class="line">    System.out.println(<span class="string">&quot;Received from DLQ: &quot;</span> + msg);</span><br><span class="line">&#125;, consumerTag -&gt; &#123;&#125;);</span><br></pre></td></tr></table></figure></li>
</ol>
<p>完整：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> com.rabbitmq.client.*;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.HashMap;</span><br><span class="line"><span class="keyword">import</span> java.util.Map;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">DeadLetterQueueExample</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        ConnectionFactory factory = <span class="keyword">new</span> ConnectionFactory();</span><br><span class="line">        factory.setHost(<span class="string">&quot;localhost&quot;</span>);</span><br><span class="line">        <span class="keyword">try</span> (Connection connection = factory.newConnection(); Channel channel = connection.createChannel()) &#123;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 死信队列配置</span></span><br><span class="line">            channel.exchangeDeclare(<span class="string">&quot;dlx_exchange&quot;</span>, <span class="string">&quot;direct&quot;</span>);</span><br><span class="line">            channel.queueDeclare(<span class="string">&quot;dead_letter_queue&quot;</span>, <span class="keyword">true</span>, <span class="keyword">false</span>, <span class="keyword">false</span>, <span class="keyword">null</span>);</span><br><span class="line">            channel.queueBind(<span class="string">&quot;dead_letter_queue&quot;</span>, <span class="string">&quot;dlx_exchange&quot;</span>, <span class="string">&quot;dlx_routing_key&quot;</span>);</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 普通队列配置</span></span><br><span class="line">            Map&lt;String, Object&gt; args = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line">            args.put(<span class="string">&quot;x-dead-letter-exchange&quot;</span>, <span class="string">&quot;dlx_exchange&quot;</span>);</span><br><span class="line">            args.put(<span class="string">&quot;x-dead-letter-routing-key&quot;</span>, <span class="string">&quot;dlx_routing_key&quot;</span>);</span><br><span class="line">            args.put(<span class="string">&quot;x-message-ttl&quot;</span>, <span class="number">10000</span>); <span class="comment">// 10秒过期</span></span><br><span class="line">            channel.queueDeclare(<span class="string">&quot;normal_queue&quot;</span>, <span class="keyword">true</span>, <span class="keyword">false</span>, <span class="keyword">false</span>, args);</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 发送测试消息</span></span><br><span class="line">            String message = <span class="string">&quot;Hello, RabbitMQ!&quot;</span>;</span><br><span class="line">            channel.basicPublish(<span class="string">&quot;&quot;</span>, <span class="string">&quot;normal_queue&quot;</span>, <span class="keyword">null</span>, message.getBytes());</span><br><span class="line">            System.out.println(<span class="string">&quot;Sent: &quot;</span> + message);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li><p>配置注意事项：</p>
<ol>
<li><strong>死信队列和普通队列的区分</strong>：<ul>
<li>在 RabbitMQ 中，每个队列都有自己的配置，死信队列和普通队列是相互独立的。死信队列不会影响正常队列的消息流转，反之亦然。</li>
</ul>
</li>
<li><strong>避免死信队列的死循环</strong>：<ul>
<li>在一些情况下，消息可能会被连续地投递到死信队列，然后再从死信队列重新投递回原队列，这可能导致死信队列的死循环。为避免这种情况，需要合理设计消息的重试和回退策略。</li>
</ul>
</li>
<li><strong>死信队列的过期策略</strong>：<ul>
<li>死信队列中的消息也可能会设置 TTL（Time To Live）过期策略，一旦消息超过过期时间，也会被丢弃或转发到其他队列。</li>
</ul>
</li>
</ol>
</li>
<li></li>
</ul>
</li>
</ul>
<h4 id="问：死信队列如何设置消息的-TTL（Time-to-Live）？"><a href="#问：死信队列如何设置消息的-TTL（Time-to-Live）？" class="headerlink" title="问：死信队列如何设置消息的 TTL（Time to Live）？"></a>问：死信队列如何设置消息的 TTL（Time to Live）？</h4><ul>
<li><p>什么是TTL？</p>
<ul>
<li>在 RabbitMQ 中，<strong>消息的 TTL（Time to Live）</strong>即<strong>过期时间</strong>，是用来限制消息在队列中的存活时间。当消息超过 TTL 时间未被消费，就会被转移到死信队列（Dead Letter Queue, DLQ）。</li>
</ul>
</li>
<li><p>设置消息 TTL 的具体方法？</p>
<ol>
<li><p><strong>为整个队列设置消息 TTL</strong></p>
<ul>
<li><p>设置队列属性，队列中所有消息的 TTL 相同。</p>
</li>
<li><p>配置示例：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Map&lt;String, Object&gt; args = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line">args.put(<span class="string">&quot;x-message-ttl&quot;</span>, <span class="number">60000</span>); <span class="comment">// 消息的存活时间为 60 秒</span></span><br><span class="line">channel.queueDeclare(<span class="string">&quot;my-queue&quot;</span>, <span class="keyword">true</span>, <span class="keyword">false</span>, <span class="keyword">false</span>, args);</span><br></pre></td></tr></table></figure></li>
<li><p>优点：简单，适用于队列中所有消息有相同的过期时间。</p>
</li>
<li><p>缺点：无法对不同的消息设置不同的过期时间。</p>
</li>
</ul>
</li>
<li><p><strong>为单个消息设置 TTL</strong></p>
<ul>
<li><p>使用消息属性设置 <code>expiration</code>。</p>
</li>
<li><p>配置示例：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">AMQP.BasicProperties properties = <span class="keyword">new</span> AMQP.BasicProperties.Builder()</span><br><span class="line">        .expiration(<span class="string">&quot;60000&quot;</span>) <span class="comment">// 单个消息的存活时间为 60 秒</span></span><br><span class="line">        .build();</span><br><span class="line">channel.basicPublish(<span class="string">&quot;&quot;</span>, <span class="string">&quot;my-queue&quot;</span>, properties, messageBody);</span><br></pre></td></tr></table></figure></li>
<li><p>优点：灵活，支持为每条消息单独设置过期时间。</p>
</li>
<li><p>缺点：增加了生产者的逻辑复杂度。</p>
</li>
</ul>
</li>
</ol>
</li>
<li><p><strong>TTL 过期后消息的处理</strong></p>
<p>当消息超过 TTL 时间后：</p>
<ol>
<li>被删除：默认情况下，超过 TTL 的消息会被丢弃，不会进入死信队列。</li>
<li>转发到死信队列（DLQ）：如果队列配置了死信交换机（Dead Letter Exchange, DLX），消息会被转发到死信队列。</li>
</ol>
<p><strong>配置死信队列</strong></p>
<ol>
<li><p><strong>声明死信交换机和死信队列</strong>：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">channel.exchangeDeclare(<span class="string">&quot;dlx-exchange&quot;</span>, <span class="string">&quot;direct&quot;</span>, <span class="keyword">true</span>);</span><br><span class="line">channel.queueDeclare(<span class="string">&quot;dlx-queue&quot;</span>, <span class="keyword">true</span>, <span class="keyword">false</span>, <span class="keyword">false</span>, <span class="keyword">null</span>);</span><br><span class="line">channel.queueBind(<span class="string">&quot;dlx-queue&quot;</span>, <span class="string">&quot;dlx-exchange&quot;</span>, <span class="string">&quot;dlx-routing-key&quot;</span>);</span><br></pre></td></tr></table></figure></li>
<li><p><strong>将队列绑定到死信交换机</strong>：</p>
<p>为原始队列配置 <code>x-dead-letter-exchange</code> 和 <code>x-dead-letter-routing-key</code> ：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Map&lt;String, Object&gt; args = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line">args.put(<span class="string">&quot;x-message-ttl&quot;</span>, <span class="number">60000</span>); <span class="comment">// 设置消息的存活时间为 60 秒</span></span><br><span class="line">args.put(<span class="string">&quot;x-dead-letter-exchange&quot;</span>, <span class="string">&quot;dlx-exchange&quot;</span>); <span class="comment">// 配置死信交换机</span></span><br><span class="line">args.put(<span class="string">&quot;x-dead-letter-routing-key&quot;</span>, <span class="string">&quot;dlx-routing-key&quot;</span>); <span class="comment">// 配置死信路由键</span></span><br><span class="line">channel.queueDeclare(<span class="string">&quot;my-queue&quot;</span>, <span class="keyword">true</span>, <span class="keyword">false</span>, <span class="keyword">false</span>, args);</span><br></pre></td></tr></table></figure></li>
</ol>
<p><strong>验证 TTL 和死信队列</strong></p>
<ol>
<li>生产消息时，确认消息是否正确设置了 TTL。</li>
<li>消息过期后，检查是否转移到死信队列。</li>
</ol>
<p>通过设置消息 TTL 和配置死信队列，可以实现消息的过期控制和处理，提高消息队列的灵活性和可靠性。</p>
</li>
</ul>
<h4 id="问：延迟队列？"><a href="#问：延迟队列？" class="headerlink" title="问：延迟队列？"></a>问：延迟队列？</h4><p>延迟队列存储的对象是对应的延迟消息，所谓<strong>“延迟消息”是指当消息被发送以后，并不想让消费者立刻拿到消息，而是等待特定时间后，消费者才能拿到这个消息进行消费</strong>。</p>
<p>使用场景：</p>
<ul>
<li><strong>支付超时</strong>：在订单系统中， 一个用户下单之后通常有30分钟的时间进行支付，如果30分钟之内没有支付成功，那么这个订单将进行异常处理，这时就可以使用延迟队列来处理这些订单了。</li>
<li><strong>定时功能</strong>：用户希望通过手机远程遥控家里的智能设备在指定的时间进行工作。这时候就可以将用户指令发送到延迟队列，当指令设定的时间到了再将指令推送到智能设备。</li>
</ul>
<p><strong>延迟队列</strong>（Delayed Queue）用于让消息在一段时间后被消费者消费，常见场景包括订单超时、任务调度、重试机制等。RabbitMQ 本身<strong>没有直接的延迟队列</strong>实现，但可以通过以下两种方式实现延迟队列功能：</p>
<p>✅ <strong>方法一：TTL + DLX（死信队列实现延迟队列）</strong></p>
<p><strong>思路</strong>：</p>
<ol>
<li>使用 <code>x-message-ttl</code> 设置消息的<strong>存活时间</strong>，即消息在队列中等待的时间。</li>
<li>消息到达 TTL 时间后，若未被消费，RabbitMQ 将消息作为“<strong>死信</strong>”投递到绑定的<strong>死信交换机（DLX）</strong>，由消费者从死信队列中消费。</li>
</ol>
<p>📌 <strong>实现原理图</strong></p>
<figure class="highlight less"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">生产者 → <span class="selector-attr">[普通交换机]</span> → <span class="selector-attr">[延迟队列]</span> → (TTL到期) → <span class="selector-attr">[死信交换机]</span> → <span class="selector-attr">[死信队列]</span> → 消费者</span><br></pre></td></tr></table></figure>

<p>📋 <strong>代码示例</strong></p>
<figure class="highlight processing"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> com.rabbitmq.client.*;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.nio.charset.StandardCharsets;</span><br><span class="line"><span class="keyword">import</span> java.util.<span class="keyword">HashMap</span>;</span><br><span class="line"><span class="keyword">import</span> java.util.Map;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> class DelayedQueueDemo &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">String</span> DELAYED_EXCHANGE = <span class="string">&quot;delayed_exchange&quot;</span>;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">String</span> DELAYED_QUEUE = <span class="string">&quot;delayed_queue&quot;</span>;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">String</span> DLX_EXCHANGE = <span class="string">&quot;dlx_exchange&quot;</span>;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">String</span> DLX_QUEUE = <span class="string">&quot;dlx_queue&quot;</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> main(<span class="keyword">String</span>[] args) <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        ConnectionFactory factory = <span class="keyword">new</span> ConnectionFactory();</span><br><span class="line">        factory.setHost(<span class="string">&quot;localhost&quot;</span>);</span><br><span class="line">        <span class="keyword">try</span> (Connection connection = factory.newConnection();</span><br><span class="line">             Channel channel = connection.createChannel()) &#123;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 1. 创建死信交换机和队列</span></span><br><span class="line">            channel.exchangeDeclare(DLX_EXCHANGE, <span class="string">&quot;direct&quot;</span>);</span><br><span class="line">            channel.queueDeclare(DLX_QUEUE, <span class="keyword">true</span>, <span class="keyword">false</span>, <span class="keyword">false</span>, <span class="keyword">null</span>);</span><br><span class="line">            channel.queueBind(DLX_QUEUE, DLX_EXCHANGE, <span class="string">&quot;dlx_routing_key&quot;</span>);</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 2. 创建延迟队列，绑定死信交换机</span></span><br><span class="line">            Map&lt;<span class="keyword">String</span>, <span class="keyword">Object</span>&gt; argsMap = <span class="keyword">new</span> <span class="keyword">HashMap</span>&lt;&gt;();</span><br><span class="line">            argsMap.put(<span class="string">&quot;x-message-ttl&quot;</span>, <span class="number">10000</span>);  <span class="comment">// 消息延迟 10 秒</span></span><br><span class="line">            argsMap.put(<span class="string">&quot;x-dead-letter-exchange&quot;</span>, DLX_EXCHANGE);</span><br><span class="line">            argsMap.put(<span class="string">&quot;x-dead-letter-routing-key&quot;</span>, <span class="string">&quot;dlx_routing_key&quot;</span>);</span><br><span class="line">            channel.exchangeDeclare(DELAYED_EXCHANGE, <span class="string">&quot;direct&quot;</span>);</span><br><span class="line">            channel.queueDeclare(DELAYED_QUEUE, <span class="keyword">true</span>, <span class="keyword">false</span>, <span class="keyword">false</span>, argsMap);</span><br><span class="line">            channel.queueBind(DELAYED_QUEUE, DELAYED_EXCHANGE, <span class="string">&quot;delay_routing_key&quot;</span>);</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 3. 发送消息到延迟队列</span></span><br><span class="line">            <span class="keyword">String</span> message = <span class="string">&quot;Hello, delayed message!&quot;</span>;</span><br><span class="line">            channel.basicPublish(DELAYED_EXCHANGE, <span class="string">&quot;delay_routing_key&quot;</span>, <span class="keyword">null</span>,</span><br><span class="line">                    message.getBytes(StandardCharsets.UTF_8));</span><br><span class="line">            System.out.<span class="built_in">println</span>(<span class="string">&quot;Sent: &quot;</span> + message);</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 4. 消费死信队列中的消息</span></span><br><span class="line">            channel.basicConsume(DLX_QUEUE, <span class="keyword">true</span>, (consumerTag, delivery) -&gt; &#123;</span><br><span class="line">                System.out.<span class="built_in">println</span>(<span class="string">&quot;Received: &quot;</span> + <span class="keyword">new</span> <span class="keyword">String</span>(delivery.getBody(), StandardCharsets.UTF_8));</span><br><span class="line">            &#125;, consumerTag -&gt; &#123;</span><br><span class="line">            &#125;);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>📊 <strong>优缺点对比</strong></p>
<table>
<thead>
<tr>
<th>✅ <strong>优点</strong></th>
<th>❌ <strong>缺点</strong></th>
</tr>
</thead>
<tbody><tr>
<td>兼容性好，适配所有 RabbitMQ 版本</td>
<td>消息延迟精度受 TTL 时间限制（毫秒级）</td>
</tr>
<tr>
<td>不需要额外插件，简单易用</td>
<td>每种延迟时间需单独队列，无法动态修改</td>
</tr>
<tr>
<td>可用于多种场景，如订单超时、延迟任务</td>
<td>需要手动处理死信队列中的消息</td>
</tr>
</tbody></table>
<p>✅ <strong>方法二：RabbitMQ Delayed Message 插件</strong></p>
<p>RabbitMQ 官方提供了 <strong>Delayed Message Exchange</strong> 插件（需要手动安装），可以通过 <code>x-delayed-message</code> 类型交换机实现真正的延迟队列，支持<strong>任意延迟时间</strong>。</p>
<p>📌 <strong>实现原理图</strong></p>
<figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">生产者 → <span class="selector-attr">[x-delayed-message 交换机]</span> → <span class="selector-attr">[普通队列]</span> → 消费者</span><br></pre></td></tr></table></figure>

<p>📦 <strong>安装 Delayed Message 插件</strong></p>
<ol>
<li><p>下载并安装插件：</p>
<figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">rabbitmq-plugins <span class="builtin-name">enable</span> rabbitmq_delayed_message_exchange</span><br></pre></td></tr></table></figure></li>
<li><p>重启 RabbitMQ 服务：</p>
<figure class="highlight pgsql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo systemctl <span class="keyword">restart</span> rabbitmq-<span class="keyword">server</span></span><br></pre></td></tr></table></figure></li>
</ol>
<p>📋 <strong>代码示例</strong></p>
<figure class="highlight processing"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> com.rabbitmq.client.*;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.nio.charset.StandardCharsets;</span><br><span class="line"><span class="keyword">import</span> java.util.<span class="keyword">HashMap</span>;</span><br><span class="line"><span class="keyword">import</span> java.util.Map;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> class DelayedQueueWithPlugin &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">String</span> DELAYED_EXCHANGE = <span class="string">&quot;delayed_exchange&quot;</span>;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">String</span> DELAYED_QUEUE = <span class="string">&quot;delayed_queue&quot;</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> main(<span class="keyword">String</span>[] args) <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        ConnectionFactory factory = <span class="keyword">new</span> ConnectionFactory();</span><br><span class="line">        factory.setHost(<span class="string">&quot;localhost&quot;</span>);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">try</span> (Connection connection = factory.newConnection();</span><br><span class="line">             Channel channel = connection.createChannel()) &#123;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 1. 声明一个 x-delayed-message 类型的交换机</span></span><br><span class="line">            Map&lt;<span class="keyword">String</span>, <span class="keyword">Object</span>&gt; argsMap = <span class="keyword">new</span> <span class="keyword">HashMap</span>&lt;&gt;();</span><br><span class="line">            argsMap.put(<span class="string">&quot;x-delayed-type&quot;</span>, <span class="string">&quot;direct&quot;</span>);</span><br><span class="line">            channel.exchangeDeclare(DELAYED_EXCHANGE, <span class="string">&quot;x-delayed-message&quot;</span>, <span class="keyword">true</span>, <span class="keyword">false</span>, argsMap);</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 2. 声明队列并绑定交换机</span></span><br><span class="line">            channel.queueDeclare(DELAYED_QUEUE, <span class="keyword">true</span>, <span class="keyword">false</span>, <span class="keyword">false</span>, <span class="keyword">null</span>);</span><br><span class="line">            channel.queueBind(DELAYED_QUEUE, DELAYED_EXCHANGE, <span class="string">&quot;delayed_routing_key&quot;</span>);</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 3. 发送延迟消息（设置消息头 x-delay）</span></span><br><span class="line">            Map&lt;<span class="keyword">String</span>, <span class="keyword">Object</span>&gt; headers = <span class="keyword">new</span> <span class="keyword">HashMap</span>&lt;&gt;();</span><br><span class="line">            headers.put(<span class="string">&quot;x-delay&quot;</span>, <span class="number">10000</span>);  <span class="comment">// 延迟 10 秒</span></span><br><span class="line">            AMQP.BasicProperties props = <span class="keyword">new</span> AMQP.BasicProperties.Builder()</span><br><span class="line">                    .headers(headers)</span><br><span class="line">                    .build();</span><br><span class="line"></span><br><span class="line">            <span class="keyword">String</span> message = <span class="string">&quot;Hello, delayed message via plugin!&quot;</span>;</span><br><span class="line">            channel.basicPublish(DELAYED_EXCHANGE, <span class="string">&quot;delayed_routing_key&quot;</span>, props,</span><br><span class="line">                    message.getBytes(StandardCharsets.UTF_8));</span><br><span class="line">            System.out.<span class="built_in">println</span>(<span class="string">&quot;Sent: &quot;</span> + message);</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 4. 消费延迟队列中的消息</span></span><br><span class="line">            channel.basicConsume(DELAYED_QUEUE, <span class="keyword">true</span>, (consumerTag, delivery) -&gt; &#123;</span><br><span class="line">                System.out.<span class="built_in">println</span>(<span class="string">&quot;Received: &quot;</span> + <span class="keyword">new</span> <span class="keyword">String</span>(delivery.getBody(), StandardCharsets.UTF_8));</span><br><span class="line">            &#125;, consumerTag -&gt; &#123;</span><br><span class="line">            &#125;);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>📊 <strong>TTL + DLX vs Delayed Message 插件 对比</strong></p>
<table>
<thead>
<tr>
<th>特性</th>
<th>TTL + DLX 实现</th>
<th>Delayed Message 插件</th>
</tr>
</thead>
<tbody><tr>
<td>依赖插件</td>
<td>❌ 不需要插件</td>
<td>✅ 需要安装 <code>rabbitmq_delayed_message</code></td>
</tr>
<tr>
<td>延迟时间精度</td>
<td>毫秒级</td>
<td>毫秒级</td>
</tr>
<tr>
<td>动态设置延迟时间</td>
<td>❌ 需要为不同延迟时间创建不同的队列</td>
<td>✅ 可动态设置 <code>x-delay</code> 值</td>
</tr>
<tr>
<td>消息堆积</td>
<td>每种延迟时间需单独队列，队列多则性能下降</td>
<td>所有延迟时间共享一个队列，性能更优</td>
</tr>
<tr>
<td>适用场景</td>
<td>兼容性要求高，延迟时间固定的场景</td>
<td>需要灵活调整延迟时间、处理复杂延迟逻辑</td>
</tr>
</tbody></table>
<p>📌 <strong>面试高分回答示例</strong></p>
<blockquote>
<p>RabbitMQ 没有原生的延迟队列功能，但可以通过两种方式实现：</p>
<ol>
<li><strong>TTL + DLX</strong>（死信队列）：设置消息存活时间（TTL），消息过期后自动路由到死信队列。适用于延迟时间固定、兼容性要求高的场景。</li>
<li><strong>Delayed Message 插件</strong>：使用 <code>x-delayed-message</code> 交换机，支持动态延迟时间，适用于需要灵活延迟控制和大规模延迟任务的场景。</li>
</ol>
<p>在大多数业务中，如果 RabbitMQ 环境允许，我们推荐使用 <strong>Delayed Message 插件</strong>，因为它提供了更灵活的延迟时间设置和更高的性能。</p>
</blockquote>
<h3 id="高可用与分布式"><a href="#高可用与分布式" class="headerlink" title="高可用与分布式"></a>高可用与分布式</h3><h4 id="问：RabbitMQ-的镜像队列（Mirrored-Queues）是什么？如何使用？"><a href="#问：RabbitMQ-的镜像队列（Mirrored-Queues）是什么？如何使用？" class="headerlink" title="问：RabbitMQ 的镜像队列（Mirrored Queues）是什么？如何使用？"></a>问：RabbitMQ 的镜像队列（Mirrored Queues）是什么？如何使用？</h4><ul>
<li><p>什么是镜像队列？</p>
<ul>
<li><strong>镜像队列（Mirrored Queues）</strong>是 RabbitMQ 提供的一种高可用性队列机制，用于将一个队列的数据复制到多个节点（镜像节点）中，以确保在某个节点故障时队列仍然可用。普通集群中队列只会保存在某个节点，镜像队列则在每个节点都有一套副本。</li>
<li><strong>特点</strong><ol>
<li><strong>主队列与镜像</strong><ul>
<li>主队列（Master）：队列的主要存储节点，负责处理客户端的读写请求。</li>
<li>镜像（Mirror）：其他节点上的副本，跟随主队列进行消息同步。</li>
</ul>
</li>
<li><strong>同步机制</strong><ul>
<li><strong>同步数据：</strong> 主队列上的消息、绑定、元数据会实时同步到镜像队列。</li>
<li><strong>同步模式：</strong> 可以选择同步队列中的消息（Sync）或仅同步元数据。</li>
</ul>
</li>
<li><strong>故障转移</strong><ul>
<li>主队列所在节点宕机后，集群会自动选举一个镜像作为新的主队列。</li>
<li>客户端可重新连接到新的主队列，继续正常工作。</li>
</ul>
</li>
</ol>
</li>
</ul>
</li>
<li><p><strong>如何使用镜像队列</strong></p>
<ol>
<li><p><strong>安装和配置</strong></p>
<ul>
<li>确保 RabbitMQ 集群已启用并运行。</li>
<li>在 RabbitMQ 配置文件中启用高可用策略（HA Policy）。示例配置（<code>rabbitmqctl</code>）：</li>
</ul>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">rabbitmqctl set_policy ha-all <span class="string">&quot;.*&quot;</span> <span class="string">&#x27;&#123;&quot;ha-mode&quot;:&quot;all&quot;&#125;&#x27;</span></span><br></pre></td></tr></table></figure>

<ul>
<li><code>&quot;ha-mode&quot;: &quot;all&quot;</code> 表示所有队列都将被镜像到集群中的所有节点。</li>
</ul>
</li>
<li><p><strong>创建队列</strong></p>
<ul>
<li>使用定义的 HA 策略创建队列时，RabbitMQ 自动将其作为镜像队列。</li>
</ul>
</li>
<li><p><strong>客户端连接</strong></p>
<ul>
<li>客户端无需特殊操作，RabbitMQ 透明处理镜像队列的同步和故障转移。</li>
</ul>
</li>
</ol>
<p><strong>配置选项</strong></p>
<ol>
<li><p><strong>镜像策略选项</strong></p>
<p>在 RabbitMQ 中，镜像队列依赖于 <strong>队列策略（Policy）</strong> 进行配置，主要参数包括：</p>
<table>
<thead>
<tr>
<th>参数</th>
<th>含义</th>
</tr>
</thead>
<tbody><tr>
<td><code>ha-mode</code></td>
<td>镜像模式（all、exactly、nodes）</td>
</tr>
<tr>
<td><code>ha-params</code></td>
<td>镜像节点数量（exactly 模式使用）</td>
</tr>
<tr>
<td><code>ha-sync-mode</code></td>
<td>同步模式（自动 or 手动）</td>
</tr>
<tr>
<td><code>queue-master-locator</code></td>
<td>主队列选择策略（最少连接、随机）</td>
</tr>
</tbody></table>
<ul>
<li><p>ha-mode：定义哪些队列需要镜像。</p>
<ul>
<li><code>&quot;all&quot;</code>：所有节点都镜像。</li>
<li><code>&quot;exactly&quot;</code>：指定镜像的节点数量。</li>
<li><code>&quot;nodes&quot;</code>：指定特定节点进行镜像。</li>
</ul>
</li>
<li><p>ha-sync-mode：定义同步模式。</p>
<ul>
<li><code>&quot;automatic&quot;</code>：新镜像自动同步。</li>
<li><code>&quot;manual&quot;</code>：需手动触发同步。</li>
</ul>
</li>
</ul>
</li>
<li><p><strong>示例策略</strong></p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">rabbitmqctl set_policy ha-two <span class="string">&quot;^ha\.&quot;</span> <span class="string">&#x27;&#123;&quot;ha-mode&quot;:&quot;exactly&quot;,&quot;ha-params&quot;:2,&quot;ha-sync-mode&quot;:&quot;automatic&quot;&#125;&#x27;</span></span><br></pre></td></tr></table></figure>

<ul>
<li><code>ha-two</code>：匹配以 <code>ha.</code> 开头的队列。</li>
<li>镜像数量为 2，自动同步。</li>
</ul>
</li>
</ol>
</li>
<li><p><strong>优缺点</strong></p>
<p><strong>优点</strong></p>
<ol>
<li><strong>高可用性</strong><ul>
<li>节点宕机时，客户端连接可以快速切换到新主队列。</li>
</ul>
</li>
<li><strong>数据冗余</strong><ul>
<li>消息和元数据都被复制到多个节点，减少数据丢失风险。</li>
</ul>
</li>
</ol>
<p><strong>缺点</strong></p>
<ol>
<li><strong>性能开销</strong><ul>
<li>消息同步和镜像复制增加了网络和磁盘 I/O 开销。</li>
</ul>
</li>
<li><strong>存储消耗</strong><ul>
<li>每个镜像节点都需要存储完整的队列数据，增加存储需求。</li>
</ul>
</li>
<li><strong>复杂性</strong><ul>
<li>增加了系统的管理和故障处理复杂性。</li>
</ul>
</li>
</ol>
</li>
<li><p><strong>适用场景</strong></p>
<ol>
<li><strong>需要高可用性</strong><ul>
<li>电商系统中的订单处理，必须保证队列可用性。</li>
</ul>
</li>
<li><strong>关键业务数据</strong><ul>
<li>需要避免数据丢失的场景，例如支付、银行等核心系统。</li>
</ul>
</li>
<li><strong>节点间通信可靠</strong><ul>
<li>节点间网络质量较好时，镜像队列同步效率更高。</li>
</ul>
</li>
</ol>
<p><strong>注意事项</strong></p>
<ol>
<li><strong>节点选择</strong><ul>
<li>在大型集群中，建议限制镜像队列的节点数量以平衡性能和可用性。</li>
</ul>
</li>
<li><strong>监控</strong><ul>
<li>定期监控 RabbitMQ 集群的同步延迟和存储情况。</li>
</ul>
</li>
<li><strong>替代方案</strong><ul>
<li>如果性能开销较大，可以使用 <strong>Quorum Queues</strong>，基于 Raft 协议实现，性能和一致性更平衡</li>
</ul>
</li>
</ol>
</li>
</ul>
<h4 id="问：什么是-RabbitMQ-的集群模式？它如何工作？"><a href="#问：什么是-RabbitMQ-的集群模式？它如何工作？" class="headerlink" title="问：什么是 RabbitMQ 的集群模式？它如何工作？"></a>问：什么是 RabbitMQ 的集群模式？它如何工作？</h4><p><strong>RabbitMQ 的集群模式</strong>是一种通过将多个 RabbitMQ 节点组合在一起运行的方式，提供高可用性和可扩展性，以支持分布式消息传递系统。集群模式允许多个节点协作处理消息队列，提升系统的吞吐量和可靠性。</p>
<p>RabbitMQ 集群的设计目标是<strong>通过多节点协作实现高可用性、负载均衡和扩展性</strong>。其核心架构基于 Erlang/OTP 分布式特性，支持节点间的元数据共享和消息队列的镜像复制。</p>
<h5 id="一、集群核心架构"><a href="#一、集群核心架构" class="headerlink" title="一、集群核心架构"></a>一、集群核心架构</h5><p>1.<strong>节点类型</strong></p>
<ul>
<li><strong>普通节点（Disc Node）</strong>：<ul>
<li>存储完整的元数据（交换机、队列、绑定关系等）和消息数据。</li>
<li>默认将队列数据存储在磁盘（若配置为持久化）。</li>
</ul>
</li>
<li><strong>内存节点（RAM Node）</strong>：<ul>
<li>仅存储元数据在内存中，重启后从其他节点同步元数据。</li>
<li><strong>仅适用于高性能临时数据场景</strong>，不推荐作为主节点。</li>
</ul>
</li>
</ul>
<p>2.<strong>元数据同步</strong></p>
<ul>
<li>所有节点共享相同的元数据（通过 Erlang Mnesia 数据库同步）。</li>
<li><strong>元数据包括</strong>：<ul>
<li>交换机（Exchange）、队列（Queue）、绑定关系（Bindings）、用户权限等。</li>
</ul>
</li>
<li><strong>不包含</strong>队列中的实际消息内容（消息仅存储在队列所在节点）。</li>
</ul>
<p>3.<strong>队列的分布</strong></p>
<ul>
<li><strong>普通集群模式</strong>：<ul>
<li>队列仅存在于创建它的节点（主节点），其他节点仅保存元数据引用。</li>
<li><strong>缺点</strong>：主节点宕机时，队列不可用（需配合镜像队列解决）。</li>
</ul>
</li>
<li><strong>镜像队列（Mirrored Queue）</strong>：或Quorum Queue仲裁队列<ul>
<li>队列数据在多个节点间复制（主节点 + 镜像节点）。</li>
<li>主节点故障时，镜像节点自动接管（高可用）。</li>
</ul>
</li>
</ul>
<hr>
<h5 id="二、集群工作原理"><a href="#二、集群工作原理" class="headerlink" title="二、集群工作原理"></a>二、集群工作原理</h5><p>1.<strong>节点发现与通信</strong></p>
<ul>
<li><p><strong>基于 Erlang 节点</strong>：每个 RabbitMQ 节点是一个 Erlang 节点，通过 <code>.erlang.cookie</code> 文件实现认证。</p>
</li>
<li><p><strong>集群组建步骤</strong>：</p>
<ol>
<li>确保所有节点使用相同的 <code>.erlang.cookie</code>。</li>
<li>通过 <code>rabbitmqctl join_cluster</code> 命令将节点加入集群。</li>
</ol>
<figure class="highlight ruby"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 将节点加入集群（假设主节点为 rabbit<span class="doctag">@node</span>1）</span></span><br><span class="line">rabbitmqctl stop_app</span><br><span class="line">rabbitmqctl join_cluster rabbit<span class="variable">@node1</span></span><br><span class="line">rabbitmqctl start_app</span><br></pre></td></tr></table></figure></li>
</ul>
<p>2.<strong>镜像队列配置</strong></p>
<ul>
<li><p><strong>策略（Policy）</strong>：通过 <code>ha-mode</code> 定义镜像规则。</p>
<figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 设置镜像策略：所有队列在所有节点镜像</span></span><br><span class="line"><span class="attribute">rabbitmqctl</span> set_policy ha-<span class="literal">all</span> <span class="string">&quot;^&quot;</span> &#x27;&#123;<span class="string">&quot;ha-mode&quot;</span>:<span class="string">&quot;all&quot;</span>&#125;&#x27;</span><br></pre></td></tr></table></figure></li>
<li><p><strong>常用参数</strong>：</p>
<ul>
<li><code>ha-mode</code>：<code>all</code>（所有节点）、<code>exactly</code>（指定数量节点）、<code>nodes</code>（指定节点）。</li>
<li><code>ha-sync-mode</code>：<code>automatic</code>（自动同步）或 <code>manual</code>（手动同步）。</li>
</ul>
</li>
</ul>
<p>3.<strong>消息路由</strong></p>
<ul>
<li>客户端可连接任意节点：<ul>
<li>若请求的队列在本地节点，直接处理。</li>
<li>若队列在其他节点，节点作为代理转发请求。</li>
</ul>
</li>
</ul>
<p>4.<strong>故障处理</strong></p>
<ul>
<li><strong>主节点宕机</strong>：<ul>
<li>镜像队列自动选举新主节点（基于最早同步完成的镜像节点）。</li>
</ul>
</li>
<li><strong>网络分区（Network Partition）</strong>：<ul>
<li>RabbitMQ 提供 <code>pause-minority</code> 或 <code>autoheal</code> 模式处理脑裂问题。</li>
<li>建议通过 <code>rabbitmqctl cluster_status</code> 监控分区状态。</li>
</ul>
</li>
</ul>
<hr>
<h5 id="三、集群模式对比"><a href="#三、集群模式对比" class="headerlink" title="三、集群模式对比"></a>三、集群模式对比</h5><table>
<thead>
<tr>
<th align="left">模式</th>
<th align="left">特点</th>
<th align="left">适用场景</th>
</tr>
</thead>
<tbody><tr>
<td align="left"><strong>普通集群</strong></td>
<td align="left">元数据共享，消息仅存主节点；无高可用</td>
<td align="left">资源有限，允许临时队列不可用</td>
</tr>
<tr>
<td align="left"><strong>镜像队列</strong></td>
<td align="left">消息多节点复制；主节点故障自动切换</td>
<td align="left">高可用性要求严格的场景</td>
</tr>
<tr>
<td align="left"><strong>Federation 插件</strong></td>
<td align="left">跨集群消息同步（异地多活）</td>
<td align="left">多数据中心、混合云部署</td>
</tr>
<tr>
<td align="left"><strong>Shovel 插件</strong></td>
<td align="left">单向消息转发（点对点跨集群）</td>
<td align="left">特定队列的跨集群迁移</td>
</tr>
</tbody></table>
<hr>
<h5 id="四、镜像队列的详细流程"><a href="#四、镜像队列的详细流程" class="headerlink" title="四、镜像队列的详细流程"></a>四、镜像队列的详细流程</h5><ol>
<li><strong>消息写入</strong>：<ul>
<li>客户端发送消息到主节点。</li>
<li>主节点将消息同步到所有镜像节点（取决于 <code>ha-sync-mode</code>）。</li>
</ul>
</li>
<li><strong>消息确认</strong>：<ul>
<li>主节点收到所有镜像节点的 ACK 后（若配置 <code>confirm</code> 模式），向生产者返回确认。</li>
</ul>
</li>
<li><strong>故障转移</strong>：<ul>
<li>主节点宕机后，最早完成同步的镜像节点成为新主节点。</li>
<li>客户端自动重连到新主节点。</li>
</ul>
</li>
</ol>
<hr>
<h5 id="五、关键注意事项"><a href="#五、关键注意事项" class="headerlink" title="五、关键注意事项"></a>五、关键注意事项</h5><ol>
<li><strong>网络分区风险</strong>：<ul>
<li>使用 <code>pause-minority</code> 模式避免脑裂（少数节点自动暂停）。</li>
<li>配置 <code>cluster_partition_handling</code> 参数定义分区处理策略。</li>
</ul>
</li>
<li><strong>数据一致性</strong>：<ul>
<li>镜像队列的同步是异步的（除非配置 <code>ha-promote-on-shutdown: always</code>）。</li>
<li>强制同步命令：<code>rabbitmqctl sync_queue &lt;queue_name&gt;</code>。</li>
</ul>
</li>
<li><strong>资源消耗</strong>：<ul>
<li>镜像队列会增加网络带宽和磁盘 I/O。</li>
<li>合理选择 <code>ha-mode</code>（如 <code>exactly 2</code> 平衡可用性和性能）。</li>
</ul>
</li>
</ol>
<hr>
<h5 id="六、最佳实践"><a href="#六、最佳实践" class="headerlink" title="六、最佳实践"></a>六、最佳实践</h5><ol>
<li><p><strong>节点规划</strong>：</p>
<ul>
<li>至少 3 个节点组成集群，避免单点故障。</li>
<li>混合使用 Disc Node 和 RAM Node（如 2 个 Disc Node + 1 个 RAM Node）。</li>
</ul>
</li>
<li><p><strong>镜像策略优化</strong>：</p>
<ul>
<li>按队列重要性设置不同策略（如核心订单队列 <code>ha-mode: all</code>，日志队列不镜像）。</li>
</ul>
<p>bash</p>
<p>Copy</p>
<figure class="highlight jboss-cli"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 为订单队列设置镜像策略</span></span><br><span class="line">rabbitmqctl <span class="keyword">set</span>_policy ha-orders <span class="string">&quot;^order_queue&quot;</span> &#x27;&#123;<span class="string">&quot;ha-mode&quot;</span>:<span class="string">&quot;all&quot;</span>&#125;&#x27;</span><br></pre></td></tr></table></figure></li>
<li><p><strong>监控与维护</strong>：</p>
<ul>
<li>使用 Prometheus + Grafana 监控队列深度、节点状态。</li>
<li>定期清理无绑定队列，避免资源浪费。</li>
</ul>
</li>
</ol>
<hr>
<h5 id="七、扩展方案"><a href="#七、扩展方案" class="headerlink" title="七、扩展方案"></a>七、扩展方案</h5><ol>
<li><strong>跨集群同步</strong>：<ul>
<li><strong>Federation 插件</strong>：实现异地多活，支持双向同步。</li>
<li><strong>Shovel 插件</strong>：单向转发消息到远程集群。</li>
</ul>
</li>
<li><strong>Kubernetes 部署</strong>：<ul>
<li>使用 StatefulSet 部署 RabbitMQ 集群，结合持久化存储（如 PV/PVC）。</li>
</ul>
</li>
<li><strong>负载均衡</strong>：<ul>
<li>通过 HAProxy 或 Nginx 对外暴露集群 VIP，实现客户端透明连接。</li>
</ul>
</li>
</ol>
<h4 id="问：如何在-RabbitMQ-中配置高可用队列？镜像队列（Mirrored-Queue）-与-仲裁队列（Quorum-Queues）-？TODODODODOD"><a href="#问：如何在-RabbitMQ-中配置高可用队列？镜像队列（Mirrored-Queue）-与-仲裁队列（Quorum-Queues）-？TODODODODOD" class="headerlink" title="问：如何在 RabbitMQ 中配置高可用队列？镜像队列（Mirrored Queue） 与 仲裁队列（Quorum Queues） ？TODODODODOD"></a>问：如何在 RabbitMQ 中配置高可用队列？<strong>镜像队列（Mirrored Queue）</strong> 与 <strong>仲裁队列（Quorum Queues）</strong> ？TODODODODOD</h4><ul>
<li><p>为什么要在 RabbitMQ 中配置高可用队列？</p>
<ul>
<li>在 RabbitMQ 中配置<strong>高可用队列</strong>是为了确保在节点故障的情况下，队列和消息能够继续使用，从而提高系统的可靠性。</li>
</ul>
</li>
<li><p>如何在 RabbitMQ 中配置高可用队列？</p>
<p>高可用队列通常依赖于 <strong>镜像队列（Mirrored Queue）</strong> 或 <strong>仲裁队列（Quorum Queues）</strong> 机制。</p>
<ol>
<li><p>镜像队列（Mirrored Queue）已在4.0版本弃用，使用仲裁队列或流代替。</p>
<p><strong>概念</strong></p>
<ul>
<li>默认情况下，RabbitMQ 集群中队列的内容位于单个节点（声明队列的节点）上。交换器和绑定始终可以被视为位于所有节点上。队列可以选择在其他集群节点上运行镜像队列（附加副本）。</li>
<li>镜像队列会将主节点上的队列数据复制到集群中的其他节点上。</li>
<li>如果主节点宕机，其他节点的镜像队列会自动接管成为主节点，最旧的镜像将被提升为新的领导者。</li>
</ul>
<p><strong>配置方法</strong></p>
<ol>
<li><p><strong>声明队列并设置镜像策略：</strong> 使用 RabbitMQ 管理插件（<code>rabbitmqctl</code> 或 Web UI）或 CLI 来定义策略。</p>
<p>示例：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">rabbitmqctl set_policy ha-all <span class="string">&quot;^.*$&quot;</span> <span class="string">&#x27;&#123;&quot;ha-mode&quot;:&quot;all&quot;&#125;&#x27;</span></span><br></pre></td></tr></table></figure>

<ul>
<li><p><code>ha-mode</code>:</p>
<ul>
<li><code>&quot;all&quot;</code>: 所有节点都会镜像。</li>
<li><code>&quot;exactly&quot;</code>: 指定数量的节点镜像。</li>
<li><code>&quot;nodes&quot;</code>: 指定具体的节点。</li>
</ul>
</li>
<li><p><code>ha-sync-mode</code>:</p>
<ul>
<li><code>&quot;automatic&quot;</code>: 消费者会等待队列同步完成。</li>
<li><code>&quot;manual&quot;</code>: 手动同步。</li>
</ul>
</li>
</ul>
</li>
<li><p><strong>在代码中声明队列时使用镜像：</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Map&lt;String, Object&gt; args = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line">args.put(<span class="string">&quot;x-ha-policy&quot;</span>, <span class="string">&quot;all&quot;</span>); <span class="comment">// 表示在所有节点上镜像</span></span><br><span class="line">channel.queueDeclare(<span class="string">&quot;my-ha-queue&quot;</span>, <span class="keyword">true</span>, <span class="keyword">false</span>, <span class="keyword">false</span>, args);</span><br></pre></td></tr></table></figure></li>
</ol>
<p><strong>优点</strong></p>
<ul>
<li>提供故障容错能力，确保数据可靠。</li>
<li>主节点故障时，副本节点接管。</li>
</ul>
<p><strong>缺点</strong></p>
<ul>
<li>性能开销较大，消息复制会增加网络和磁盘的开销。</li>
<li>节点之间同步可能延迟。</li>
</ul>
</li>
<li><p><strong>仲裁队列</strong>（Quorum Queues）</p>
<p><strong>概念</strong></p>
<ul>
<li>Quorum Queues 是基于 Raft 共识算法的新一代高可用队列。实现优秀的数据安全，以及可靠、快速的领导者选举属性，以确保在升级或其他混乱情况下也能保持高可用性。</li>
<li>它避免了传统镜像队列的一些性能和可用性问题。</li>
<li>对于那些可以从复制和可重复读中受益的用例，<a target="_blank" rel="noopener" href="https://rabbitmq.cn/docs/streams">流</a> 可能是比仲裁队列更好的选择。某些情况下，不应使用仲裁队列。它们通常涉及：<ul>
<li>临时队列：短暂队列或独占队列，高队列更新率（声明和删除速率）</li>
<li>最低可能的延迟：底层共识算法由于其数据安全功能而具有固有的更高延迟</li>
<li>当数据安全不是优先事项时（例如，应用程序不使用 <a target="_blank" rel="noopener" href="https://rabbitmq.cn/docs/confirms">手动确认</a> 并且不使用发布者确认）</li>
<li>非常长的队列积压（超过 500 万条消息）（<a target="_blank" rel="noopener" href="https://rabbitmq.cn/docs/stream">流</a> 可能更适合）</li>
<li>大扇出：（<a target="_blank" rel="noopener" href="https://rabbitmq.cn/docs/stream">流</a> 可能更适合）</li>
</ul>
</li>
<li><a target="_blank" rel="noopener" href="https://en.wikipedia.org/wiki/Quorum_(distributed_computing)">仲裁</a> 在分布式系统中可以定义为大多数节点之间达成的协议（<code>(N/2)+1</code>，其中 <code>N</code> 是系统参与者的总数）。大多数副本（包括当前选定的队列领导者）都同意队列的状态及其内容。</li>
</ul>
<p><strong>配置方法</strong></p>
<ol>
<li><p><strong>创建 Quorum Queue：</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Map&lt;String, Object&gt; args = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line">args.put(<span class="string">&quot;x-queue-type&quot;</span>, <span class="string">&quot;quorum&quot;</span>); <span class="comment">// 声明队列类型为 quorum</span></span><br><span class="line">channel.queueDeclare(<span class="string">&quot;my-quorum-queue&quot;</span>, <span class="keyword">true</span>, <span class="keyword">false</span>, <span class="keyword">false</span>, args);</span><br></pre></td></tr></table></figure></li>
<li><p><strong>设置副本数量：</strong></p>
<ul>
<li><p>默认副本数量为 3。</p>
</li>
<li><p>配置副本数量：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">rabbitmqctl set_policy quorum <span class="string">&quot;^quorum-.*$&quot;</span> <span class="string">&#x27;&#123;&quot;quorum-queue&quot;: &#123;&quot;initial-group-size&quot;: 5&#125;&#125;&#x27;</span></span><br></pre></td></tr></table></figure></li>
</ul>
</li>
</ol>
<p><strong>优点</strong></p>
<ul>
<li>数据一致性强，副本通过共识算法同步。</li>
<li>不需要设置复杂的镜像策略。</li>
</ul>
<p><strong>缺点</strong></p>
<ul>
<li>比镜像队列需要更多存储和网络资源。</li>
<li>写入延迟可能稍高。</li>
</ul>
</li>
<li><p><strong>流</strong></p>
<p>概念：</p>
<ul>
<li>流是一个持久化的复制数据结构，可以完成与队列相同的功能：它们缓冲来自生产者的消息，这些消息会被消费者读取。但是，流在两个重要方面与队列不同：<strong>消息的存储和消费方式</strong>。</li>
</ul>
<p>使用场景：</p>
<ol>
<li><p><strong>大规模扇出</strong></p>
<p>当希望将相同的消息传递给多个订阅者时，用户当前必须为每个消费者绑定一个专用的队列。（<strong>即一个消息同时被多各消费者消费，需要为每一个消费者绑定一个新的队列</strong>）如果消费者的数量很大，这可能会变得效率低下，尤其是在需要持久性和/或复制时。流将允许任意数量的消费者以非破坏性的方式从同一个队列消费相同的消息，从而无需绑定多个队列。流消费者还可以从副本读取，从而将读取负载分散到集群中。</p>
</li>
<li><p><strong>回放（时间旅行）</strong></p>
<p>由于所有当前的 RabbitMQ 队列类型都具有破坏性消费行为，即当消费者完成消息处理后会将其从队列中删除，因此无法重新读取已消费的消息。流将允许消费者在日志中的任何点附加并从该点开始读取。</p>
</li>
<li><p><strong>吞吐量性能</strong></p>
<p>没有持久性队列类型能够提供可以与任何现有基于日志的消息传递系统相媲美的吞吐量。流的设计以性能为主要目标。</p>
</li>
<li><p><strong>大型积压</strong></p>
<p>大多数 RabbitMQ 队列旨在收敛到空状态并为此进行了优化，并且当给定队列上有数百万条消息时性能会下降。流旨在以有效的方式存储大量数据，并最大限度地减少内存开销。</p>
</li>
</ol>
<p>配置方法：</p>
<ol>
<li><p>声明流：先将<code>x-queue-type</code>队列参数设置为<code>stream</code>（默认值为<code>classic</code>）。会在每个配置的 RabbitMQ 节点上创建一个具有副本的流。流是仲裁系统，因此强烈建议集群大小不均匀。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">ConnectionFactory factory = <span class="keyword">new</span> ConnectionFactory();</span><br><span class="line">Connection connection = factory.newConnection();</span><br><span class="line">Channel channel = connection.createChannel();</span><br><span class="line">channel.queueDeclare(</span><br><span class="line">  <span class="string">&quot;my-stream&quot;</span>,</span><br><span class="line">  <span class="keyword">true</span>,         <span class="comment">// durable</span></span><br><span class="line">  <span class="keyword">false</span>, <span class="keyword">false</span>, <span class="comment">// not exclusive, not auto-delete</span></span><br><span class="line">  Collections.singletonMap(<span class="string">&quot;x-queue-type&quot;</span>, <span class="string">&quot;stream&quot;</span>)</span><br><span class="line">);</span><br></pre></td></tr></table></figure>

<p>流仍然是队列，可以绑定交换机，可以设置流的最大大小（以字节为单位）<code>x-max-length-bytes</code>，最大生存期<code>x-max-age</code>，流在磁盘上被划分为固定大小的段文件。<code>x-stream-max-segment-size-bytes</code> 此设置控制这些文件的大小。默认值：（500000000 字节）。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">Map&lt;String, Object&gt; arguments = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line">arguments.put(<span class="string">&quot;x-queue-type&quot;</span>, <span class="string">&quot;stream&quot;</span>);</span><br><span class="line">arguments.put(<span class="string">&quot;x-max-length-bytes&quot;</span>, <span class="number">20_000_000_000</span>); <span class="comment">// maximum stream size: 20 GB</span></span><br><span class="line">arguments.put(<span class="string">&quot;x-stream-max-segment-size-bytes&quot;</span>, <span class="number">100_000_000</span>); <span class="comment">// size of segment files: 100 MB</span></span><br><span class="line">channel.queueDeclare(</span><br><span class="line">  <span class="string">&quot;my-stream&quot;</span>,</span><br><span class="line">  <span class="keyword">true</span>,         <span class="comment">// durable</span></span><br><span class="line">  <span class="keyword">false</span>, <span class="keyword">false</span>, <span class="comment">// not exclusive, not auto-delete</span></span><br><span class="line">  arguments</span><br><span class="line">);</span><br></pre></td></tr></table></figure></li>
<li><p>消费操作：流永远<strong>不会删除任何消息</strong>，因此任何消费者都可以从日志中的任何点开始读取/消费。这由<code>x-stream-offset</code>消费者参数控制。如果未指定，则消费者将从消费者启动后写入日志的下一个偏移量开始读取。支持以下值</p>
<ul>
<li><code>first</code> - 从日志中第一个可用消息开始</li>
<li><code>last</code> - 这将从最后写入的消息“块”开始读取<em>（块是流中使用的存储和传输单元，简单来说，它是由几千条到几千条消息组成的一批消息，具体取决于入口）</em></li>
<li><code>next</code> - 与未指定任何偏移量相同</li>
<li>偏移量 - 指定要附加到日志的确切偏移量的数值。如果此偏移量不存在，它将分别钳位到日志的开头或结尾。</li>
<li>时间戳 - 指定要附加到日志的时间点的的时间戳值。它将钳位到最接近的偏移量，如果时间戳超出流的范围，它将分别钳位到日志的开头或结尾。使用 AMQP 0.9.1，使用的时间戳是 POSIX 时间，精度为一秒，即自 00:00:00 UTC、1970-01-01 以来经过的秒数。请注意，消费者可能会收到在指定时间戳之前发布的消息。</li>
<li>间隔 - 指定相对于当前时间要附加到日志的时间间隔的字符串值。使用与<code>x-max-age</code>相同的规范（请参阅<a target="_blank" rel="noopener" href="https://rabbitmq.cn/docs/streams#retention">保留</a>）</li>
</ul>
<p>使用<code>first</code>偏移量规范</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">channel.basicQos(<span class="number">100</span>); <span class="comment">// QoS must be specified</span></span><br><span class="line">channel.basicConsume(</span><br><span class="line">  <span class="string">&quot;my-stream&quot;</span>,</span><br><span class="line">  <span class="keyword">false</span>,</span><br><span class="line">  Collections.singletonMap(<span class="string">&quot;x-stream-offset&quot;</span>, <span class="string">&quot;first&quot;</span>), <span class="comment">// &quot;first&quot; offset specification</span></span><br><span class="line">  (consumerTag, message) -&gt; &#123;</span><br><span class="line">    <span class="comment">// message processing</span></span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">   channel.basicAck(message.getEnvelope().getDeliveryTag(), <span class="keyword">false</span>); <span class="comment">// ack is required</span></span><br><span class="line">  &#125;,</span><br><span class="line">  consumerTag -&gt; &#123; &#125;);</span><br></pre></td></tr></table></figure>

<p>了如何指定要从中消费的特定偏移量</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">channel.basicQos(<span class="number">100</span>); <span class="comment">// QoS must be specified</span></span><br><span class="line">channel.basicConsume(</span><br><span class="line">  <span class="string">&quot;my-stream&quot;</span>,</span><br><span class="line">  <span class="keyword">false</span>,</span><br><span class="line">  Collections.singletonMap(<span class="string">&quot;x-stream-offset&quot;</span>, <span class="number">5000</span>), <span class="comment">// offset value</span></span><br><span class="line">  (consumerTag, message) -&gt; &#123;</span><br><span class="line">    <span class="comment">// message processing</span></span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">   channel.basicAck(message.getEnvelope().getDeliveryTag(), <span class="keyword">false</span>); <span class="comment">// ack is required</span></span><br><span class="line">  &#125;,</span><br><span class="line">  consumerTag -&gt; &#123; &#125;);</span><br></pre></td></tr></table></figure>

<p>以下代码段显示了如何指定要从中消费的特定时间戳</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// an hour ago</span></span><br><span class="line">Date timestamp = <span class="keyword">new</span> Date(System.currentTimeMillis() - <span class="number">60</span> * <span class="number">60</span> * <span class="number">1_000</span>)</span><br><span class="line">channel.basicQos(<span class="number">100</span>); <span class="comment">// QoS must be specified</span></span><br><span class="line">channel.basicConsume(</span><br><span class="line">  <span class="string">&quot;my-stream&quot;</span>,</span><br><span class="line">  <span class="keyword">false</span>,</span><br><span class="line">  Collections.singletonMap(<span class="string">&quot;x-stream-offset&quot;</span>, timestamp), <span class="comment">// timestamp offset</span></span><br><span class="line">  (consumerTag, message) -&gt; &#123;</span><br><span class="line">    <span class="comment">// message processing</span></span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">   channel.basicAck(message.getEnvelope().getDeliveryTag(), <span class="keyword">false</span>); <span class="comment">// ack is required</span></span><br><span class="line">  &#125;,</span><br><span class="line">  consumerTag -&gt; &#123; &#125;);</span><br></pre></td></tr></table></figure></li>
<li><p>其它的流操作与队列操作大体一致。</p>
</li>
<li><p>流与队列对比：</p>
<table>
<thead>
<tr>
<th align="left">功能</th>
<th align="left">队列</th>
<th>流</th>
</tr>
</thead>
<tbody><tr>
<td align="left"><a target="_blank" rel="noopener" href="https://rabbitmq.cn/docs/queues">非持久队列</a></td>
<td align="left">是</td>
<td>否</td>
</tr>
<tr>
<td align="left"><a target="_blank" rel="noopener" href="https://rabbitmq.cn/docs/queues">排他性</a></td>
<td align="left">是</td>
<td>否</td>
</tr>
<tr>
<td align="left">每条消息的持久性</td>
<td align="left">每条消息</td>
<td>始终</td>
</tr>
<tr>
<td align="left">成员资格更改</td>
<td align="left">自动</td>
<td>手动</td>
</tr>
<tr>
<td align="left"><a target="_blank" rel="noopener" href="https://rabbitmq.cn/docs/ttl">TTL</a></td>
<td align="left">是</td>
<td>否（但请参见<a target="_blank" rel="noopener" href="https://rabbitmq.cn/docs/streams#retention">保留</a>）</td>
</tr>
<tr>
<td align="left"><a target="_blank" rel="noopener" href="https://rabbitmq.cn/docs/maxlength">队列长度限制</a></td>
<td align="left">是</td>
<td>否（但请参见<a target="_blank" rel="noopener" href="https://rabbitmq.cn/docs/streams#retention">保留</a>）</td>
</tr>
<tr>
<td align="left">将消息保存在内存中</td>
<td align="left">请参见<a target="_blank" rel="noopener" href="https://rabbitmq.cn/docs/classic-queues#memory">经典队列</a></td>
<td>从不</td>
</tr>
<tr>
<td align="left"><a target="_blank" rel="noopener" href="https://rabbitmq.cn/docs/priority">消息优先级</a></td>
<td align="left">是</td>
<td>否</td>
</tr>
<tr>
<td align="left"><a target="_blank" rel="noopener" href="https://rabbitmq.cn/docs/consumer-priority">消费者优先级</a></td>
<td align="left">是</td>
<td>否</td>
</tr>
<tr>
<td align="left"><a target="_blank" rel="noopener" href="https://rabbitmq.cn/docs/dlx">死信交换机</a></td>
<td align="left">是</td>
<td>否</td>
</tr>
<tr>
<td align="left">符合<a target="_blank" rel="noopener" href="https://rabbitmq.cn/docs/parameters#policies">策略</a></td>
<td align="left">是</td>
<td>（请参见<a target="_blank" rel="noopener" href="https://rabbitmq.cn/docs/streams#retention">保留</a>）</td>
</tr>
<tr>
<td align="left">对<a target="_blank" rel="noopener" href="https://rabbitmq.cn/docs/alarms">内存警报</a>做出反应</td>
<td align="left">是</td>
<td>否（使用最少的 RAM）</td>
</tr>
<tr>
<td align="left">毒性消息处理</td>
<td align="left">否</td>
<td>否</td>
</tr>
<tr>
<td align="left">全局<a target="_blank" rel="noopener" href="https://rabbitmq.cn/docs/streams#global-qos">QoS 预取</a></td>
<td align="left">是</td>
<td>否</td>
</tr>
</tbody></table>
</li>
</ol>
</li>
</ol>
</li>
</ul>
<h4 id="问：Federation（联邦插件）与Shovel（铲子插件）？"><a href="#问：Federation（联邦插件）与Shovel（铲子插件）？" class="headerlink" title="问：Federation（联邦插件）与Shovel（铲子插件）？"></a>问：Federation（联邦插件）与Shovel（铲子插件）？</h4><p>通常使用集群的部署方式来提高可靠性和吞吐量，不过集群只能部署在局域网内。</p>
<h5 id="一-Federation"><a href="#一-Federation" class="headerlink" title="一. Federation"></a>一. Federation</h5><p>异地使用：</p>
<p>Federation 插件的设计目标是<strong>使 RabbitMQ 在不同的 Broker 节点之间进行消息传递而无须建立集群</strong>。Federation 插件能够在不同管理域（可能设置了不同的用户和 vhost ，也可能运行在不同版本的 RabbitMQ Erlang 上）中的 Broker 或者集群之间传递消息。</p>
<p>例如有如下集群：broker1部署于北京，broker2部署于上海，broker3部署于广州，因为物理距离的问题，所以要考虑网络延迟问题。</p>
<ul>
<li>有一个广州的业务ClientA需要连接 broker3 ，并向其中的交换器 exchangeA 发送消息，此时的网络延迟很小，<strong>ClientA 可以迅速将消息发送至 exchangeA 中</strong>，就算在开启了 publisher confirm 机制或者事务机制的情况下，也可以迅速收到确认信息。</li>
<li>此时又有一个在北京的业务 ClientB 需要向 exchangeA 发送消息，那么 <strong>ClientB 与 broker3 之间有很大的网络延迟</strong>， ClientB 将发送消息至 exchangeA 会经历一定的延迟，尤其是在开启了 publisher confirm 机制或者事务机制的情况下， ClientB 会等待很长的延迟时间来接收 broker3 的确认信息，进而必然造成这条 发送线程的性能降低，甚至造成一定程度上的阻塞。</li>
<li>那么要<strong>怎么优化业务 ClientB <strong>呢？将业务 ClientB 部署到广州的机房中可以解决这个问题，但是如果 ClientB 调用的另一些服务都部署在北京，那么又会引发新的时延问题，总不见得将所有业务全部部署在一个机房，那么容灾又何以实现？这里</strong>使用 Federation 插件就可以很好地解决这个问题</strong>。</li>
<li>在广州的Broker3的交换器exchangeA和北京的 broker1 之间建立一条单向的 Federation link：<ul>
<li>broker1会创建一个同名exchangeA，以及一个交换器 <code>exchangeA-&gt;broker3 B</code> 两个交换器通过路由键 <code>rkA</code> 绑定。</li>
<li>还会在 broker1 上建立一个队列 <code>federation: exchangeA-&gt;broker3 B</code> 并与交换器 <code>exchangeA-&gt;broker3 B</code> 进行绑定。 </li>
<li>在队列 <code>federation: exchangeA-&gt;broker3 B</code> 与 broker3 中的交换器 exchangeA 之间建立一条 AMQP 连接来实时地消费队列 <code>federation: exchangeA-&gt;broker3 B</code> 中的数据。</li>
<li>当业务 ClientB请求exchangeA时，会连接北京的broker1，可以迅速发送完消息并收到确认信息。然后消息通过 Federation link 转发到 broker3（广州）的交换器 exchangeA 中。最终消息会存入与 exchangeA 绑定的队列 queueA 中，消费者最终可以消费队列 queueA 中的消息。</li>
</ul>
</li>
</ul>
<p>联邦队列：可以在多个 Broker 节点（或者集群）之间为单个队列提供均衡负载的功能。一个联邦队列可以连接一个或者多个上游队列（upstream queue），并从这些上游队列中获取消息以满足本地消费者消费消息的需求。<strong>既可以消费联邦队列，又可以消费上游队列，这种分布式队列的部署可以提高单个队列的容量</strong>。如果上游一端部署的消费者来不及消费上游队列的消息，下游的消费者可以帮其分担消费，有一定的负载均衡的效果。<strong>与联邦交换器不同的是，一条消息可以在联邦队列间转发无限次</strong>，因为队列可以互为联邦队列：消息会转向有多余消费能力的一方，所以可能会导致消费在队列间来回转发。</p>
<p>📋 <strong>使用场景</strong></p>
<ul>
<li><strong>异地数据同步</strong>（如主数据中心与灾备数据中心同步消息）。</li>
<li><strong>多活架构</strong>（多个集群共同服务，动态扩展流量）。</li>
<li><strong>跨集群共享消息</strong>（如将核心业务消息推送给多个区域集群）。</li>
</ul>
<h5 id="二-Shovel"><a href="#二-Shovel" class="headerlink" title="二. Shovel"></a>二. Shovel</h5><p>与 Federation 具备的数据转发功能类似， <strong>Shovel 能够可靠、持续地从一个 Broker 中的队列拉取数据并转发至另一个 Broker 中的交换器</strong>。 <strong>作为源端的队列和作为目的端的交换器可以同时位于同一个 Broker ，也可以位于不同的 Broker 上</strong>。Shovel 可以翻译为“铲子”，是一种比较形象的比喻，这个“铲子”可以将消息从一方“挖到”另一方。 Shovel 的行为就像优秀的客户端应用程序，能够负责连接源和目的地、负责消息的读写及负责连接失败问题的处理。</p>
<p>Shovel 的主要优势在于：</p>
<ul>
<li><strong>松耦合</strong>： Shovel 可以移动位于不同管理域中的 Broker（或者集群）上的消息，这些 Broker（或者集群）可以包含不同的用户和 vhost ，也可以使用不同的 RabbitMQ Erlang 版本。 </li>
<li><strong>支持广域网</strong>：Shovel 插件同样基于 AMQP 协议在 Broker 之间进行通信，被设计成可以容忍时断时续的连通情形，并且能够保证消息的可靠性。</li>
<li><strong>高度定制</strong>：当 Shovel 成功连接后，可以对其进行配置以执行相关的 AMQP 命令。</li>
</ul>
<p>Shovel 的结构示意图：两个Broker，broker1 中有交换器 exchange1 和队列 queue1 ，且这两者通过路由键 <code>rk1</code> 进行绑定；broker2 中有交换器 exchange2 和队列 queue2 ，且这两者通过路由键 <code>rk2</code> 进行绑定。在队列 queue1 和交换器 exchange2 之间配置一个 Shovel link，当一条内容为  <code>shovel test payload</code> 的消息从客户端发送至交换器 exchange1 的时候，这条消息会经过图 8-15 中的数据流转最后存储在队列 queue2 中。</p>
<p><img src="https://pic-1258215793.cos.ap-shanghai.myqcloud.com/content/20201001/202010010143.png"></p>
<p>通常情况下，使用 Shovel 时配置队列作为源端，交换器作为目的端，但同样可以<strong>将队列配置为目的端</strong>：（虽然看起来像队列queue1直接通过 Shovel link 将消息转发给queue2，但其实还经过了broker2的默认交换器转发）<strong>配置交换器为源端</strong>也可以，虽然看起来像交换器 exchange1 直接通过 Shovel link 将消息转发给 exchange2 ，但其实broker1会创建一个队列并绑定 exchange1 ，消息从 exchange1 过来后先存储在这个队列，然后Shovel再从这个队列中拉取消息并转发到exchange2。</p>
<p>🎯 <strong>工作原理</strong></p>
<ul>
<li><strong>源队列（Source Queue）</strong> → <strong>目标队列（Destination Queue）</strong></li>
<li><strong>主动推送</strong>消息，确保可靠传输，支持消息<strong>确认</strong>与<strong>重试</strong>。</li>
</ul>
<p>📋 <strong>使用场景</strong></p>
<ul>
<li><strong>数据迁移</strong>（将一个 RabbitMQ 集群的数据迁移到另一个集群）。</li>
<li><strong>灾备切换</strong>（主数据中心故障时，将消息搬运到备用中心）。</li>
<li><strong>跨环境复制</strong>（如开发环境数据同步到测试环境）。</li>
</ul>
<h5 id="二者对比"><a href="#二者对比" class="headerlink" title="二者对比"></a>二者对比</h5><p><strong>定义</strong>：</p>
<ul>
<li><strong>Federation</strong> 是一种<strong>按需拉取</strong>消息的机制，适用于松散耦合的多集群场景。</li>
<li><strong>Shovel</strong> 是一种<strong>持续搬运</strong>消息的工具，适用于可靠的消息复制与集群迁移。</li>
</ul>
<p><strong>核心区别</strong>：</p>
<ul>
<li><strong>传输粒度</strong>：Federation 支持 <strong>Exchange</strong> 和 <strong>Queue</strong>，Shovel 仅支持 <strong>Queue</strong>。</li>
<li><strong>传输方式</strong>：Federation 是<strong>按需拉取</strong>，Shovel 是<strong>实时搬运</strong>。</li>
<li><strong>可靠性</strong>：Shovel <strong>更可靠</strong>，适用于数据<strong>备份和灾难恢复</strong>。</li>
<li><strong>适用场景</strong>：Federation 适合<strong>多活集群</strong>，Shovel 适合<strong>队列迁移</strong>和<strong>数据备份</strong>。</li>
</ul>
<p><strong>总结</strong>：</p>
<ul>
<li>如果需要<strong>动态消费、负载均衡</strong>，推荐使用 <strong>Federation</strong>。</li>
<li>如果需要<strong>高可靠、跨集群消息搬运</strong>，推荐使用 <strong>Shovel</strong>。</li>
</ul>
<table>
<thead>
<tr>
<th><strong>需求</strong></th>
<th><strong>推荐方案</strong></th>
<th><strong>原因</strong></th>
</tr>
</thead>
<tbody><tr>
<td><strong>多集群共享消息</strong></td>
<td>Federation</td>
<td>支持动态拉取，消费者负载均衡</td>
</tr>
<tr>
<td><strong>消息可靠搬运、确保顺序</strong></td>
<td>Shovel</td>
<td>强一致性，严格消息传输和确认</td>
</tr>
<tr>
<td><strong>异地多活、灾备切换</strong></td>
<td>Federation</td>
<td>异地数据同步，支持多路径</td>
</tr>
<tr>
<td><strong>队列迁移（数据持久化）</strong></td>
<td>Shovel</td>
<td>消息迁移、可靠持久性</td>
</tr>
<tr>
<td><strong>负载均衡（动态需求）</strong></td>
<td>Federation</td>
<td>消费者按需拉取，性能更优</td>
</tr>
<tr>
<td><strong>消息实时复制、保持完整性</strong></td>
<td>Shovel</td>
<td>持久化保证消息不丢失</td>
</tr>
<tr>
<td><strong>临时集群对接（轻量操作）</strong></td>
<td>Federation</td>
<td>插件轻量，配置简单</td>
</tr>
</tbody></table>
<h5 id="与集群的对比"><a href="#与集群的对比" class="headerlink" title="与集群的对比"></a>与集群的对比</h5><table>
<thead>
<tr>
<th>Federation/Shovel</th>
<th>集群</th>
</tr>
</thead>
<tbody><tr>
<td>各个 Broke 节点之间逻缉分离</td>
<td>逻辑上是个 Broker 节点</td>
</tr>
<tr>
<td>各个 Broker 节点之间可以运行不同版本的 Erlang 和 RabbitMQ</td>
<td>各个 Broker 节点之间必须运行相同版本的 Erlang 和 RabbitMQ</td>
</tr>
<tr>
<td>各个 Broker 节点之间可以在广域网中相连，当然必须要授予适当的用户和权限</td>
<td>各个 Broker 节点之间必须在可信赖的局域网中相连，通过 Erlang 内部节点传递消息，但节点问需要有相同的 Erlang cookie</td>
</tr>
<tr>
<td>各个 Broker 节点之间能以任何拓扑逻辑部署，连接可以是单向的或者是双向的</td>
<td>所有 Broker 节点都双向连续所有其他节点</td>
</tr>
<tr>
<td>从 CAP 理论中选择可用性和分区耐受性，即 AP</td>
<td>从 CAP 理论中选择一致性和可用性，CA</td>
</tr>
<tr>
<td>一个 Broker 中的交换器可以是 Federation 生成的或者是本地的</td>
<td>集群中所有 Broker 节点中的交换器都是一样的，要么全有要么全无</td>
</tr>
<tr>
<td>客户端所能看到它所连接的 Broker 节点上的队列</td>
<td>客户端连接到集群中的任何 Broker 节点都可以看到所有 的队列</td>
</tr>
</tbody></table>
<h4 id="问：RabbitMQ-如何实现消息的高可用性？如何保证-RabbitMQ-消息的可靠性？"><a href="#问：RabbitMQ-如何实现消息的高可用性？如何保证-RabbitMQ-消息的可靠性？" class="headerlink" title="问：RabbitMQ 如何实现消息的高可用性？如何保证 RabbitMQ 消息的可靠性？"></a>问：RabbitMQ 如何实现消息的高可用性？如何保证 RabbitMQ 消息的可靠性？</h4><p>RabbitMQ 如何实现消息的高可用性？为了确保消息的 <strong>不丢失</strong>、<strong>不重复</strong>，以及在消费者出现故障时能够<strong>重新投递</strong>。主要通过<strong>持久化</strong>和<strong>集群高可用机制</strong>实现。</p>
<ol>
<li><p><strong>消息持久化</strong>（Message Persistence）和<strong>队列持久化</strong>。</p>
<ul>
<li><p><strong>作用</strong>：防止 RabbitMQ 服务或服务器重启导致的消息丢失。</p>
</li>
<li><p><strong>消息持久化</strong>：指的是将消息写入磁盘，以防 RabbitMQ 服务崩溃时丢失消息。</p>
</li>
<li><p><strong>队列持久化</strong>：确保在 RabbitMQ 重启后，队列的状态得以恢复。如果队列没有标记为持久化，则在 RabbitMQ 重启时，所有队列和消息都会丢失。</p>
</li>
</ul>
<ul>
<li><p><strong>设置方式</strong>：消息持久化会增加磁盘 I/O，可能对性能产生影响，因此需要在性能和可靠性之间进行权衡。</p>
<ul>
<li><p><strong>声明持久化队列</strong></p>
<ul>
<li><p>队列在声明时设置为持久化：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">channel.queueDeclare(<span class="string">&quot;persistent_queue&quot;</span>, <span class="keyword">true</span>, <span class="keyword">false</span>, <span class="keyword">false</span>, <span class="keyword">null</span>);</span><br></pre></td></tr></table></figure>

<p>参数说明：</p>
<ul>
<li>第二个参数 <code>durable</code> 属性 <code>true</code> 表示队列持久化。</li>
</ul>
</li>
</ul>
</li>
<li><p><strong>持久化消息</strong></p>
<ul>
<li><p>消息需要单独设置持久化属性：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">AMQP.BasicProperties properties = </span><br><span class="line">    <span class="keyword">new</span> AMQP.BasicProperties.Builder().deliveryMode(<span class="number">2</span>).build();</span><br><span class="line">channel.basicPublish(<span class="string">&quot;&quot;</span>, <span class="string">&quot;persistent_queue&quot;</span>, properties, messageBody);</span><br></pre></td></tr></table></figure>

<ul>
<li><code>channel.basicPublish(&quot;&quot;, queueName, true, false, null, message.getBytes());</code></li>
<li><code>deliveryMode = 2</code> 表示消息持久化。</li>
</ul>
</li>
</ul>
</li>
<li><p><strong>注意</strong>：消息持久化并不能完全避免消息丢失，比如 RabbitMQ 崩溃后，未写入磁盘的消息可能丢失。可以通过同步刷盘策略减少丢失概率。</p>
</li>
</ul>
</li>
</ul>
</li>
<li><p><strong>消息确认机制（Message Acknowledgment）</strong></p>
<ul>
<li><strong>作用</strong>：确保消息被消费者成功处理后才会从队列中删除，避免消息未消费时丢失。</li>
<li><strong>消费者端确认</strong>：使用 <code>basicAck</code> 确认消息已被处理。如果未确认的消息发生在消费者崩溃时，RabbitMQ 会重新投递该消息。</li>
<li><strong>生产者端确认</strong>：确保消息成功发送到 RabbitMQ 队列。生产者可以使用 <strong>Publisher Confirms</strong> 来确认消息是否成功写入服务器。</li>
<li><strong>批量确认</strong>：为了提高性能，可以采用批量确认消息。这意味着多个消息可以在一个确认批次中一起被确认。<ul>
<li>使用 <code>confirmSelect</code> 启用发布者确认，然后通过 <code>waitForConfirms</code> 等方法等待确认批次的返回。</li>
</ul>
</li>
<li><strong>设置方式</strong>：<ul>
<li>开启手动确认模式： <code>channel.basicConsume(&quot;queue_name&quot;, false, consumer);</code> <ul>
<li>第二个参数为 <code>false</code> 表示手动确认。</li>
</ul>
</li>
<li>消费完毕后，消费者端确认：<code>channel.basicAck(deliveryTag, false);</code><ul>
<li>若消费者宕机或未确认，消息会重新投递给其他消费者。</li>
</ul>
</li>
<li>消费者拒绝消息并重新入队：<code>channel.basicNack(deliveryTag, false, true);</code></li>
<li>生产者确认：<code>channel.confirmSelect();</code>（启用生产者确认）</li>
</ul>
</li>
</ul>
</li>
<li><p><strong>集群模式</strong></p>
<ul>
<li><strong>作用</strong>：RabbitMQ 支持多种集群模式，确保服务的高可用性。</li>
</ul>
<ul>
<li><strong>普通集群模式</strong><ul>
<li>队列的元数据（如队列名称、绑定关系）在集群中共享，但消息内容只存储在主节点上。会有单点问题。</li>
<li>优点：性能较高。</li>
<li>缺点：主节点宕机时，队列不可用。</li>
</ul>
</li>
<li><strong>镜像队列模式</strong><ul>
<li>队列的消息和元数据都同步到多个节点，主节点宕机后可切换到镜像节点。</li>
</ul>
</li>
</ul>
</li>
<li><p><strong>镜像队列（Mirrored Queues）</strong>或<strong>仲裁队列（Quorum Queues）</strong>、以及<strong>流</strong>。</p>
<ul>
<li><p><strong>作用</strong>：通过将队列镜像到集群中的多个节点，确保队列即使在某个节点宕机时仍然可用。</p>
</li>
<li><p><strong>实现方法</strong>：</p>
<ul>
<li><p>配置镜像策略：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">rabbitmqctl set_policy ha-all <span class="string">&quot;.*&quot;</span> <span class="string">&#x27;&#123;&quot;ha-mode&quot;:&quot;all&quot;&#125;&#x27;</span></span><br></pre></td></tr></table></figure>

<p>参数说明：</p>
<ul>
<li><code>.*</code>：匹配所有队列。</li>
<li><code>ha-mode: all</code>：所有队列都镜像到所有节点。</li>
</ul>
</li>
<li><p>镜像队列的故障恢复：</p>
<ul>
<li>主队列宕机后，自动选举新的主节点。</li>
</ul>
</li>
</ul>
</li>
<li><p><strong>注意</strong>：镜像队列会增加同步数据的网络和存储开销，适用于高可用性要求高但性能开销可接受的场景。</p>
</li>
</ul>
</li>
<li><p><strong>消息重试机制</strong> OR <strong>死信队列（Dead Letter Queue, DLQ）</strong></p>
<ul>
<li><strong>作用</strong>：当消息因某些原因（如 TTL 到期、队列满了）未被成功处理时，可将消息存入死信队列以避免丢失。</li>
<li><strong>死信队列（DLQ）</strong>：如果某条消息无法消费，或者达到最大重试次数，消息会被送到一个死信队列，便于后续处理或者审查。消费者出现异常时，消息不会丢失。可以使用 <strong>max-length</strong>、<strong>max-length-bytes</strong> 或 <strong>TTL</strong>（Time-To-Live）来控制死信队列的消息过期。</li>
</ul>
<ul>
<li><p><strong>实现方法</strong>：</p>
<ul>
<li><p>设置死信交换器和死信队列：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Map&lt;String, Object&gt; args = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line">args.put(<span class="string">&quot;x-dead-letter-exchange&quot;</span>, <span class="string">&quot;dlx_exchange&quot;</span>);</span><br><span class="line">channel.queueDeclare(<span class="string">&quot;normal_queue&quot;</span>, <span class="keyword">true</span>, <span class="keyword">false</span>, <span class="keyword">false</span>, args);</span><br></pre></td></tr></table></figure></li>
</ul>
</li>
</ul>
</li>
<li><p><strong>消息的幂等性</strong>：</p>
<ul>
<li><p><strong>全局唯一 ID</strong>：</p>
<p><strong>方法</strong>：为每条消息分配一个全局唯一的 ID（例如 UUID、业务唯一标识符等）。</p>
<p><strong>作用</strong>：消费者在处理消息时，通过这个唯一 ID 判断消息是否已经被处理。</p>
<p><strong>实现</strong>：</p>
<ul>
<li>消费者在处理消息前，查询存储系统（如数据库、Redis 等）是否已经存在这个 ID。</li>
<li>如果存在，说明是重复消息，可以忽略；如果不存在，则正常处理并记录该 ID。</li>
</ul>
<p><strong>适用场景</strong>：重复消息需要简单去重的场景。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Consumer</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> RedisService redisService;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">processMessage</span><span class="params">(String messageId, String messageContent)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 检查 Redis 去重表</span></span><br><span class="line">        <span class="keyword">if</span> (redisService.contains(messageId)) &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;Duplicate message, skipping: &quot;</span> + messageId);</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">// 处理消息</span></span><br><span class="line">            handleBusinessLogic(messageContent);</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 消息处理成功后记录到 Redis</span></span><br><span class="line">            redisService.recordMessageId(messageId);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            System.err.println(<span class="string">&quot;Failed to process message: &quot;</span> + e.getMessage());</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">handleBusinessLogic</span><span class="params">(String messageContent)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 实现具体的业务逻辑</span></span><br><span class="line">        System.out.println(<span class="string">&quot;Processing message: &quot;</span> + messageContent);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li><p><strong>幂等性设计</strong></p>
<p><strong>方法</strong>：在业务逻辑中设计幂等性处理，确保即使重复执行相同的操作，结果也保持一致。</p>
<p><strong>实现</strong>：</p>
<ul>
<li>数据库操作：使用数据库的唯一性约束，避免重复插入。</li>
<li>增量更新：通过 <code>UPDATE</code> 替代 <code>INSERT</code>，确保同样的更新操作多次执行不会影响最终状态。</li>
<li>结合全局唯一 ID 或去重表进一步加强。</li>
</ul>
</li>
<li><p><strong>结合事务或分布式锁</strong></p>
<p>如果业务逻辑中涉及多个步骤或系统，可以使用事务或分布式锁，确保重复消息在处理时只会执行一次。</p>
<p><strong>实现方式</strong>：</p>
<ul>
<li>数据库事务：将去重逻辑和消息处理逻辑放在一个事务中。</li>
<li>分布式锁：基于 Redis 或 ZooKeeper 的分布式锁机制，保证消息处理的互斥性。</li>
</ul>
</li>
</ul>
</li>
</ol>
<h4 id="问：RabbitMQ-中的节点故障恢复机制是什么？"><a href="#问：RabbitMQ-中的节点故障恢复机制是什么？" class="headerlink" title="问：RabbitMQ 中的节点故障恢复机制是什么？"></a>问：RabbitMQ 中的节点故障恢复机制是什么？</h4><p>RabbitMQ 中的节点故障恢复机制是什么？RabbitMQ 是一个分布式消息队列系统，当某个节点发生故障时，为了保证消息服务的高可用性和数据完整性，它提供了以下故障恢复机制：</p>
<ol>
<li><p>普通集群模式的故障恢复  </p>
<ul>
<li><strong>机制</strong><ul>
<li>在普通集群模式中，队列的元数据（队列名称、绑定关系等）在集群中的所有节点之间共享。</li>
<li>消息内容只存储在主节点（Master Node）上，当主节点宕机时，该队列的消息暂时不可用，直到主节点恢复。</li>
</ul>
</li>
<li><strong>恢复过程</strong><ul>
<li>如果主节点重启并恢复，它会继续承担该队列的主角色。</li>
<li>若节点无法恢复，用户需要通过其他手段（如备份或手动操作）进行数据恢复。</li>
</ul>
</li>
<li><strong>适用场景</strong><ul>
<li>消息可靠性要求不高，追求性能的应用场景。</li>
</ul>
</li>
</ul>
</li>
<li><p><strong>镜像队列模式的故障恢复</strong></p>
<ul>
<li><p><strong>机制</strong></p>
<ul>
<li>队列的元数据和消息内容会同步到集群中的多个节点。</li>
<li>如果主节点（Master）发生故障，集群会自动选举一个镜像节点（Mirror Node）作为新的主节点。</li>
</ul>
</li>
<li><p><strong>恢复过程</strong></p>
<ol>
<li><p>节点选举：RabbitMQ 使用 Raft 算法或类似协议选举一个镜像节点为新主节点。</p>
</li>
<li><p>服务切换：新的主节点开始接收生产者和消费者的消息。</p>
</li>
<li><p>数据同步：故障节点恢复后，原主节点会作为普通镜像节点加入队列，并重新同步数据。</p>
</li>
</ol>
</li>
<li><p><strong>优势</strong></p>
<ul>
<li>保证了队列的高可用性，即使主节点宕机也不会中断服务。</li>
</ul>
</li>
<li><p><strong>适用场景</strong></p>
<ul>
<li>高可靠性、高可用性要求的应用场景。</li>
</ul>
</li>
</ul>
</li>
<li><p><strong>死信队列（Dead Letter Queue, DLQ）</strong></p>
<ul>
<li><strong>作用</strong><ul>
<li>消息因 TTL 到期、队列满了等原因被丢弃时，可转入死信队列避免丢失。</li>
<li>即使某个节点发生故障，死信队列依然能够确保消息的可靠性。</li>
</ul>
</li>
<li><strong>故障恢复</strong><ul>
<li>节点恢复后，死信队列消息仍可被处理或重新路由到其他队列。</li>
</ul>
</li>
</ul>
</li>
<li><p><strong>仲裁队列（Quorum Queues）</strong></p>
<ul>
<li><p><strong>机制</strong></p>
<ul>
<li>RabbitMQ 引入的 Quorum Queues 基于 Raft 共识协议，适用于高可用性要求更高的场景。</li>
<li>队列数据被分片并分布到多个节点上，任何一个节点发生故障时，其他节点可继续服务。</li>
</ul>
</li>
<li><p><strong>恢复过程</strong></p>
<ol>
<li><p>共识协议：剩余节点通过 Raft 协议达成一致。</p>
</li>
<li><p>自动恢复：故障节点恢复后，会重新加入集群并同步数据。</p>
</li>
</ol>
</li>
<li><p><strong>优势</strong></p>
<ul>
<li>比镜像队列更高效，适合大规模、高并发的场景。</li>
</ul>
</li>
</ul>
</li>
<li><p><strong>自动重连与重试机制</strong></p>
<ul>
<li><p><strong>机制</strong></p>
<ul>
<li>RabbitMQ 客户端和服务器之间支持自动重连和重试机制，确保在节点故障时生产者和消费者尽量不中断。</li>
</ul>
</li>
<li><p><strong>恢复过程</strong></p>
<ul>
<li>客户端会尝试重新连接 RabbitMQ。</li>
<li>连接恢复后，客户端的消息或消费逻辑自动恢复。</li>
</ul>
</li>
<li><p><strong>配置</strong></p>
<ul>
<li><p>客户端库（如 Java 的 RabbitMQ Client）支持自动重连：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">ConnectionFactory factory = <span class="keyword">new</span> ConnectionFactory();</span><br><span class="line">factory.setAutomaticRecoveryEnabled(<span class="keyword">true</span>); <span class="comment">// 开启自动恢复</span></span><br><span class="line">factory.setNetworkRecoveryInterval(<span class="number">5000</span>); <span class="comment">// 每 5 秒重试一次</span></span><br></pre></td></tr></table></figure></li>
</ul>
</li>
</ul>
</li>
<li><p><strong>数据恢复与备份机制</strong></p>
<ul>
<li><strong>作用</strong><ul>
<li>如果节点宕机且无法恢复，可以通过数据备份恢复节点的服务。</li>
</ul>
</li>
<li><strong>备份与恢复方法</strong><ul>
<li>启用消息持久化（RDB 或 AOF）确保数据存储在磁盘上。</li>
<li>定期备份 RabbitMQ 的配置文件和数据目录。</li>
<li>使用 <code>rabbitmq-dump-queues</code> 工具导出数据并在恢复时导入。</li>
</ul>
</li>
</ul>
</li>
<li><p><strong>负载均衡与集群监控</strong></p>
<ul>
<li>配置负载均衡器（如 HAProxy 或 Nginx），确保当某个节点故障时，客户端可以自动切换到其他节点。</li>
<li>通过 RabbitMQ 的管理插件或 Prometheus 监控集群状态，及时发现和处理故障。</li>
</ul>
</li>
</ol>
<p>故障恢复优化建议</p>
<ul>
<li>配置镜像队列或 Quorum Queues 提升高可用性。</li>
<li>启用消息持久化，防止因节点宕机丢失消息。</li>
<li>使用自动重连机制，减少客户端因网络或节点故障导致的中断。</li>
<li>定期监控和备份 RabbitMQ 集群，确保即使多节点宕机也可恢复服务。</li>
</ul>
<h4 id="问：RabbitMQ-集群与拓扑如何设计，如何选择主机数量？"><a href="#问：RabbitMQ-集群与拓扑如何设计，如何选择主机数量？" class="headerlink" title="问：RabbitMQ 集群与拓扑如何设计，如何选择主机数量？"></a>问：RabbitMQ 集群与拓扑如何设计，如何选择主机数量？</h4><p>设计 RabbitMQ 集群拓扑和选择主机数量时，需要综合考虑<strong>业务需求、性能指标、可靠性、可扩展性和成本</strong>等因素。以下是详细的设计指导：</p>
<ol>
<li><p><strong>集群设计的关键考虑</strong>：</p>
<ul>
<li>1.1 <strong>业务需求</strong><ul>
<li><strong>消息量</strong>：预估每秒的消息发布和消费数量。</li>
<li><strong>消息大小</strong>：了解消息的平均大小以及峰值。</li>
<li><strong>延迟要求</strong>：确定消息从生产到消费的最大容忍延迟。</li>
</ul>
</li>
<li>1.2 <strong>性能与可靠性</strong><ul>
<li><strong>高可用性</strong>：是否需要在节点故障时，消息服务不受影响。</li>
<li><strong>数据安全性</strong>：消息是否需要持久化以应对断电或系统崩溃。</li>
</ul>
</li>
<li>1.3 <strong>扩展性</strong><ul>
<li>集群需要支持未来业务增长，增加节点是否会影响现有服务。</li>
</ul>
</li>
<li>1.4 <strong>成本</strong><ul>
<li>硬件、网络、存储和维护成本。</li>
</ul>
</li>
</ul>
</li>
<li><p><strong>RabbitMQ 集群与拓扑设计</strong></p>
<ul>
<li><p>2.1 <strong>普通集群模式</strong></p>
<ul>
<li><p>特性：</p>
<ul>
<li>队列元数据在所有节点上共享，消息数据只存储在主节点。</li>
<li>适合轻量级的消息处理，不需要高可靠性。</li>
</ul>
</li>
<li><p>优点：</p>
<ul>
<li>配置简单，性能高。</li>
<li>节省存储空间，因为消息只存储在主节点。</li>
</ul>
</li>
<li><p>缺点：</p>
<ul>
<li>如果主节点宕机，该队列无法使用。</li>
</ul>
</li>
</ul>
</li>
</ul>
<ul>
<li><p>2.2 <strong>镜像队列模式（Mirrored Queues）</strong></p>
<ul>
<li><p>特性：</p>
<ul>
<li>队列元数据和消息数据同步到多个节点。</li>
<li>主节点故障后，自动切换到镜像节点。</li>
</ul>
</li>
<li><p>优点：</p>
<ul>
<li>提供高可用性，即使节点故障，消息也不会丢失。</li>
</ul>
</li>
<li><p>缺点：</p>
<ul>
<li>数据同步会增加网络和存储开销。</li>
<li>性能相较普通集群稍低。</li>
</ul>
</li>
</ul>
</li>
<li><p>2.3 <strong>Quorum Queues 模式</strong></p>
<ul>
<li><p>特性：</p>
<ul>
<li>使用 Raft 协议，数据被分片并分布到多个节点。</li>
<li>高效且可靠，适合大规模、高可用场景。</li>
</ul>
</li>
<li><p>优点：</p>
<ul>
<li>比镜像队列更高效，减少同步开销。</li>
<li>提供严格的高可用性和数据一致性。</li>
</ul>
</li>
<li><p>缺点：</p>
<ul>
<li>配置复杂，对存储需求较高。</li>
</ul>
</li>
</ul>
</li>
<li><p>2.4 <strong>多数据中心部署</strong></p>
<ul>
<li><p>特性：</p>
<ul>
<li>支持跨数据中心的集群部署。</li>
<li>通过 Federation 或 Shovel 插件实现消息的跨数据中心传递。</li>
</ul>
</li>
<li><p>适用场景：</p>
<ul>
<li>需要灾备支持或者跨地域的消息分发。</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li><p><strong>主机数量的选择</strong></p>
<p>3.1 <strong>节点数量建议</strong></p>
<ul>
<li><p>普通集群模式：</p>
<ul>
<li>最低建议 3 个节点，确保基本的负载分担和容错能力。</li>
</ul>
</li>
<li><p>镜像队列模式：</p>
<ul>
<li>至少 2 个节点（主 + 镜像），推荐奇数节点（如 3 或 5），以便在故障时有足够的可用节点。</li>
</ul>
</li>
<li><p>Quorum Queues 模式：</p>
<ul>
<li>节点数必须为奇数（如 3、5、7），便于实现多数派（quorum）一致性。</li>
</ul>
</li>
</ul>
<p>3.2 <strong>硬件规格</strong></p>
<ul>
<li><strong>CPU</strong>：多核处理器，满足高并发的计算需求。</li>
<li><strong>内存</strong>：足够的内存以存储队列元数据和缓冲消息。</li>
<li><strong>磁盘</strong>：高速磁盘（如 SSD）以支持持久化和快速恢复。</li>
<li><strong>网络</strong>：低延迟、高带宽网络连接，以支持节点间的同步。</li>
</ul>
<p>3.3 <strong>节点分布</strong></p>
<ul>
<li><p>负载分配：</p>
<ul>
<li>每个节点处理的队列和消息量应均衡，避免单点瓶颈。</li>
</ul>
</li>
<li><p>故障容忍：</p>
<ul>
<li>节点数越多，集群对单节点故障的容忍度越高。</li>
</ul>
</li>
</ul>
</li>
<li><p><strong>性能优化建议</strong></p>
<p>4.1 <strong>队列划分</strong></p>
<ul>
<li><strong>分区队列</strong>：将队列分成多个分区，由不同节点处理，避免单队列性能瓶颈。</li>
<li><strong>消息路由</strong>：合理使用 <code>Exchange</code> 和 <code>Binding</code>，将消息均衡分发到不同队列。</li>
</ul>
<p>4.2 <strong>持久化策略</strong></p>
<ul>
<li>如果消息可靠性要求较低，可关闭持久化以提高性能。</li>
<li>对于高可靠性场景，使用 SSD 和优化磁盘写入。</li>
</ul>
<p>4.3 <strong>监控与扩展</strong></p>
<ul>
<li>部署监控工具（如 RabbitMQ Management、Prometheus）。</li>
<li>动态增加节点以应对负载增长。</li>
</ul>
</li>
<li><p><strong>示例设计方案</strong></p>
<p>场景：普通业务消息队列（中等流量、可靠性要求一般）</p>
<ul>
<li><p><strong>集群类型</strong>：普通集群模式</p>
</li>
<li><p><strong>节点数量</strong>：3 个</p>
</li>
<li><p>部署建议：</p>
<ul>
<li>使用负载均衡器将流量分发到不同节点。</li>
<li>配置消息自动重试和客户端自动重连。</li>
</ul>
</li>
</ul>
<p>场景：电商系统（高并发、可靠性要求高）</p>
<ul>
<li><p><strong>集群类型</strong>：镜像队列模式</p>
</li>
<li><p><strong>节点数量</strong>：5 个（3 主 2 镜像）</p>
</li>
<li><p>部署建议：</p>
<ul>
<li>启用持久化。</li>
<li>定期备份数据并监控节点健康状态。</li>
</ul>
</li>
</ul>
<p>场景：大规模分布式系统（全球业务、需要灾备）</p>
<ul>
<li><p><strong>集群类型</strong>：多数据中心 + Quorum Queues</p>
</li>
<li><p><strong>节点数量</strong>：每数据中心 5 个节点，总计 15 个节点。</p>
</li>
<li><p>部署建议：</p>
<ul>
<li>使用 Federation 插件实现跨数据中心的消息传递。</li>
<li>在每个数据中心实现高可用部署。</li>
</ul>
</li>
</ul>
</li>
</ol>
<h4 id="问：脑裂问题？"><a href="#问：脑裂问题？" class="headerlink" title="问：脑裂问题？"></a>问：脑裂问题？</h4><p>🧠 <strong>RabbitMQ 的脑裂问题（Split-Brain）详解</strong></p>
<p>📌 <strong>1. 什么是脑裂问题？</strong></p>
<p><strong>脑裂（Split-Brain）</strong> 是指在分布式系统中，因网络分区（Network Partition）或节点故障，导致 RabbitMQ 集群中的<strong>各个节点失去联系</strong>，产生<strong>多个主节点</strong>，引发数据不一致、消息丢失等问题。</p>
<p>🗂️ <strong>场景示例</strong></p>
<p>假设有一个由 3 个节点（<strong>A、B、C</strong>）组成的 RabbitMQ 集群，A 是主节点，B、C 是镜像节点：</p>
<ul>
<li>如果 A 和 B、C 之间的网络中断：<ul>
<li>A 认为自己是<strong>主节点</strong>，继续接收和处理消息。</li>
<li>B 和 C 无法联系 A，可能会选举新的<strong>主节点</strong>。</li>
<li>结果：<strong>A 和 B、C</strong> 都认为自己是主节点，产生<strong>数据分裂</strong>和<strong>消息不一致</strong>。</li>
</ul>
</li>
</ul>
<p>📊 <strong>2. RabbitMQ 脑裂问题的影响</strong></p>
<ol>
<li><strong>数据不一致</strong><ul>
<li>不同的主节点处理了各自的消息，数据分布于多个节点，导致消息丢失或重复。</li>
</ul>
</li>
<li><strong>消息丢失</strong><ul>
<li>网络恢复后，只有<strong>一个主节点</strong>被保留，其他节点上的未同步消息将被丢弃。</li>
</ul>
</li>
<li><strong>消息重复</strong><ul>
<li>如果两个主节点同时对外提供服务，可能会多次消费相同的消息，导致重复处理。</li>
</ul>
</li>
<li><strong>系统不可用</strong><ul>
<li>如果无法正确恢复，RabbitMQ 集群可能进入不可用状态，无法接收或消费消息。</li>
</ul>
</li>
</ol>
<p>🔍 <strong>3. RabbitMQ 脑裂产生的原因</strong></p>
<p>🕵️ <strong>常见原因</strong></p>
<ol>
<li><strong>网络分区</strong>：节点间网络中断，导致节点失联，无法正常通信。</li>
<li><strong>节点故障</strong>：RabbitMQ 某个节点负载高、磁盘故障、进程崩溃。</li>
<li><strong>镜像队列不一致</strong>：消息同步未完成，镜像节点数据不完整。</li>
<li><strong>集群配置不当</strong>：未使用适当的高可用策略（如 <code>ha-mode</code>、<code>queue-master-locator</code>）。</li>
</ol>
<p>⚙️ <strong>4. 如何防止 RabbitMQ 脑裂问题？</strong></p>
<p>✅ <strong>1. 使用 “Quorum Queues”（推荐）</strong></p>
<p>RabbitMQ 3.8 及以上版本引入了<strong>Quorum Queues（法定人数队列）</strong>，使用基于 <strong>Raft</strong> 共识算法，保证只有一个主节点。</p>
<p><strong>优点</strong>：</p>
<ul>
<li>防止脑裂，确保消息一致性。</li>
<li>自动选举新主节点，保证服务连续性。</li>
</ul>
<p><strong>创建 Quorum Queue 示例</strong>：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">channel.queueDeclare(<span class="string">&quot;task_queue&quot;</span>, <span class="keyword">true</span>, <span class="keyword">false</span>, <span class="keyword">false</span>, Map.of(<span class="string">&quot;x-queue-type&quot;</span>, <span class="string">&quot;quorum&quot;</span>));</span><br></pre></td></tr></table></figure>

<p>✅ <strong>2. 设置 “queue-master-locator” 策略</strong></p>
<p>控制新主节点的选择逻辑，避免脑裂后不一致的主节点。</p>
<ul>
<li><strong>min-masters</strong>（推荐）：选择<strong>镜像最少的节点</strong>作为主节点。</li>
<li><strong>client-local</strong>：选择与消费者最近的节点作为主节点。</li>
</ul>
<p><strong>设置示例</strong>：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">rabbitmqctl set_policy ha-policy <span class="string">&quot;.*&quot;</span> <span class="string">&#x27;&#123;&quot;ha-mode&quot;:&quot;all&quot;, &quot;queue-master-locator&quot;:&quot;min-masters&quot;&#125;&#x27;</span></span><br></pre></td></tr></table></figure>

<p>✅ <strong>3. 启用 “pause_if_all_down”</strong></p>
<p>RabbitMQ 3.7 版本引入此机制，网络分区时自动暂停受影响的节点，防止脑裂。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">rabbitmqctl set_policy ha <span class="string">&quot;.*&quot;</span> <span class="string">&#x27;&#123;&quot;ha-mode&quot;:&quot;all&quot;, &quot;ha-promote-on-shutdown&quot;:&quot;when-synced&quot;&#125;&#x27;</span></span><br></pre></td></tr></table></figure>

<ul>
<li><strong>when-synced</strong>：仅当镜像节点与主节点完全同步时才允许提升。</li>
<li><strong>always</strong>：始终允许镜像提升（不推荐，可能造成脑裂）。</li>
</ul>
<p>✅ <strong>4. 使用 “Cluster Partition Handling” 机制</strong></p>
<p>RabbitMQ 支持多种网络分区处理策略：</p>
<table>
<thead>
<tr>
<th>策略</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td>ignore</td>
<td>忽略网络分区（不推荐）</td>
</tr>
<tr>
<td>autoheal（推荐）</td>
<td>自动恢复，保留最多的分区节点</td>
</tr>
<tr>
<td>pause_minority</td>
<td>暂停少数派分区节点（强一致性）</td>
</tr>
</tbody></table>
<p><strong>设置 autoheal 示例</strong>：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">rabbitmqctl set_cluster_partition_handling autoheal</span><br></pre></td></tr></table></figure>

<p>✅ <strong>5. 设置镜像队列强制同步</strong></p>
<p>确保新主节点只有在镜像完全同步后才进行选举。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">rabbitmqctl set_policy ha-all <span class="string">&quot;.*&quot;</span> <span class="string">&#x27;&#123;&quot;ha-mode&quot;:&quot;all&quot;, &quot;ha-sync-mode&quot;:&quot;automatic&quot;&#125;&#x27;</span></span><br></pre></td></tr></table></figure>

<p>📈 <strong>5. RabbitMQ 脑裂问题的排查与解决</strong></p>
<p>🛠️ <strong>1. 检查集群状态</strong></p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">rabbitmqctl cluster_status</span><br></pre></td></tr></table></figure>

<p>查看节点是否处于 <code>running</code> 状态，是否有 <code>partitions</code>（分区情况）。</p>
<p>🛠️ <strong>2. 手动恢复节点</strong></p>
<p>如果节点脑裂，尝试移除并重新加入集群：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">rabbitmqctl stop_app</span><br><span class="line">rabbitmqctl reset</span><br><span class="line">rabbitmqctl join_cluster rabbit@node1</span><br><span class="line">rabbitmqctl start_app</span><br></pre></td></tr></table></figure>

<p>🛠️ <strong>3. 清理不一致数据</strong></p>
<p>若发现数据不一致，使用以下命令清理队列并恢复：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">rabbitmqctl forget_cluster_node rabbit@node2</span><br></pre></td></tr></table></figure>

<p>🎯 <strong>6. 面试高分回答模板</strong></p>
<blockquote>
<p><strong>Q: RabbitMQ 如何应对脑裂问题？</strong></p>
</blockquote>
<ol>
<li><strong>定义</strong>：<br> 脑裂是指 RabbitMQ 集群中，因<strong>网络分区</strong>导致出现多个主节点，产生<strong>数据不一致、消息丢失或重复消费</strong>的问题。</li>
<li><strong>原因</strong>：<ul>
<li>网络分区导致节点失联。</li>
<li>RabbitMQ 主节点崩溃或负载过高。</li>
<li>镜像队列未完全同步。</li>
</ul>
</li>
<li><strong>影响</strong>：<ul>
<li>数据不一致、消息丢失、重复消费。</li>
<li>集群进入不可用状态，业务中断。</li>
</ul>
</li>
<li><strong>解决方案</strong>：<ul>
<li><strong>Quorum Queues</strong>（基于 Raft 算法，强一致性）。</li>
<li>设置 <code>queue-master-locator</code>，防止错误主节点。</li>
<li>启用 <code>autoheal</code>，自动修复网络分区。</li>
<li><strong>pause_if_all_down</strong>：暂停故障节点，防止脑裂。</li>
<li>强制镜像队列同步（<code>ha-sync-mode</code>）。</li>
</ul>
</li>
<li><strong>总结</strong>：<br> RabbitMQ 通过<strong>合理策略设置</strong>（Quorum Queue、autoheal、pause_if_all_down）能有效防止和恢复脑裂问题，确保消息的<strong>高可用性和一致性</strong>。</li>
</ol>
<h3 id="性能和优化"><a href="#性能和优化" class="headerlink" title="性能和优化"></a>性能和优化</h3><h4 id="问：如何优化-RabbitMQ-的性能？"><a href="#问：如何优化-RabbitMQ-的性能？" class="headerlink" title="问：如何优化 RabbitMQ 的性能？"></a>问：如何优化 RabbitMQ 的性能？</h4><p>优化 RabbitMQ 的性能需要从硬件配置、消息队列设计、生产者与消费者设置、集群部署等多方面入手。以下是详细的优化思路：</p>
<ol>
<li><p><strong>硬件与系统层面优化</strong></p>
<p>1.1 <strong>硬件配置</strong></p>
<ul>
<li><strong>CPU</strong>：选择多核 CPU，RabbitMQ 是多线程的，可充分利用多核。</li>
<li><strong>内存</strong>：确保有足够的内存用于缓存队列元数据和消息。</li>
<li><strong>磁盘</strong>：使用高速 SSD，特别是对需要持久化的消息。</li>
<li><strong>网络</strong>：使用低延迟、高带宽网络，避免节点间通信瓶颈。</li>
</ul>
<p>1.2 <strong>系统设置</strong></p>
<ul>
<li><p><strong>文件描述符限制</strong>：增加文件描述符的限制，控制打开文件和网络连接的数量，避免因大量连接导致的瓶颈。<code>ulimit -n 65535</code> </p>
</li>
<li><p><strong>TCP 参数优化</strong>：调整系统的网络参数，如 <code>tcp_tw_recycle</code> 和 <code>tcp_fin_timeout</code>，以提高连接处理能力。</p>
</li>
<li><p><strong>分离磁盘 I/O</strong>：将持久化日志（如 <code>disk_free_limit</code>）和操作系统 I/O 分离到不同的磁盘。</p>
</li>
</ul>
</li>
<li><p><strong>RabbitMQ 配置优化</strong></p>
<p>2.1 <strong>持久化优化</strong></p>
<ul>
<li><strong>异步持久化</strong>：如果业务允许，启用 <code>lazy queues</code> 将消息写入磁盘而非内存。</li>
<li><strong>批量确认</strong>：生产者和消费者可以批量确认消息，减少网络通信开销。</li>
<li><strong>磁盘阈值设置</strong>：通过调整 <code>disk_free_limit</code> 参数，避免磁盘空间耗尽导致节点停机。</li>
</ul>
<p>2.2 <strong>连接与信道</strong></p>
<ul>
<li><strong>信道复用</strong>：使用信道（Channel）代替每次操作建立新连接，减少连接开销。</li>
<li><strong>长连接</strong>：尽量使用长连接代替短连接，减少频繁的连接建立和释放。</li>
</ul>
<p>2.3 <strong>消费者预取机制</strong></p>
<ul>
<li><p>配置 <code>prefetch_count</code> 限制每次从队列获取的消息数量，防止消费者过载。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">rabbitmqctl set_policy lazy <span class="string">&quot;^lazy-queue$&quot;</span> <span class="string">&#x27;&#123;&quot;queue-mode&quot;:&quot;lazy&quot;&#125;&#x27;</span> --apply-to queues</span><br></pre></td></tr></table></figure></li>
</ul>
<p>2.4 <strong>队列模式</strong></p>
<ul>
<li><strong>普通队列</strong>：消息保存在内存中，适合高性能、低延迟场景。</li>
<li><strong>懒队列（Lazy Queue）</strong>：消息直接写入磁盘，适合高吞吐、低内存消耗场景。</li>
</ul>
</li>
<li><p><strong>队列与交换机设计</strong></p>
<p>3.1 <strong>队列划分</strong></p>
<ul>
<li>将大队列分为多个小队列，通过多消费者并行处理，提高吞吐量。</li>
<li>使用分区队列（Sharding），通过自定义 <code>routing_key</code> 将消息分发到不同队列。</li>
</ul>
<p>3.2 <strong>交换机类型选择</strong></p>
<ul>
<li><strong>Fanout</strong>：适合广播消息场景。</li>
<li><strong>Direct</strong>：适合路由消息到特定队列。</li>
<li><strong>Topic</strong>：适合匹配复杂路由规则的场景。</li>
</ul>
<p>3.3 <strong>过期与死信队列</strong></p>
<ul>
<li>设置队列的 TTL 和 DLQ，减少队列中无效消息的堆积。</li>
</ul>
</li>
<li><p><strong>生产者与消费者优化</strong></p>
<p>4.1 <strong>生产者优化</strong></p>
<ul>
<li><strong>异步发送</strong>：生产者使用异步发送消息，提高吞吐量。</li>
<li><strong>批量发送</strong>：生产者合并小消息为大消息，减少网络请求次数。</li>
</ul>
<p>4.2 <strong>消费者优化</strong></p>
<ul>
<li><strong>并行消费</strong>：增加消费者实例数量，提升消费能力。</li>
<li><strong>批量消费</strong>：批量拉取消息并处理，减少与 RabbitMQ 的交互次数。</li>
<li><strong>手动确认</strong>：消费者在成功处理后再确认消息，避免消息丢失。</li>
</ul>
</li>
<li><p><strong>集群与负载均衡优化</strong></p>
<p>5.1 <strong>集群模式</strong></p>
<ul>
<li><strong>普通集群</strong>：适合高性能、低延迟需求。</li>
<li><strong>镜像队列集群</strong>：适合高可靠性需求。</li>
<li><strong>Quorum Queues</strong>：适合分布式环境下的高可用需求。</li>
</ul>
<p>5.2 <strong>负载均衡</strong></p>
<ul>
<li>使用负载均衡器（如 HAProxy 或 Nginx）将流量分发到不同节点。</li>
<li>确保队列负载均匀分布到多个节点，避免单点压力过大。</li>
</ul>
<p>5.3 <strong>跨数据中心</strong></p>
<ul>
<li>使用 Federation 或 Shovel 插件实现消息的跨数据中心传递。</li>
</ul>
</li>
<li><p><strong>监控与报警</strong></p>
<p>6.1 <strong>监控指标</strong></p>
<ul>
<li>消息堆积量：检查是否有队列消息积压。</li>
<li>CPU 和内存使用率：评估节点的负载情况。</li>
<li>消费者状态：检查消费者是否正常消费。</li>
</ul>
<p>6.2 <strong>监控工具</strong></p>
<ul>
<li>使用 RabbitMQ Management 插件或 Prometheus + Grafana 监控集群状态。</li>
<li>设置关键指标的报警阈值，提前发现问题。</li>
</ul>
</li>
<li><p><strong>示例优化场景</strong></p>
<p>场景：高并发短消息</p>
<ul>
<li><strong>队列模式</strong>：普通队列。</li>
<li><strong>批量发送</strong>：生产者合并消息批量发送。</li>
<li><strong>异步确认</strong>：消费者批量确认消息。</li>
</ul>
<p>场景：低延迟高可靠性</p>
<ul>
<li><strong>集群模式</strong>：镜像队列模式。</li>
<li><strong>持久化设置</strong>：启用磁盘持久化。</li>
<li><strong>Prefetch</strong>：合理配置 <code>prefetch_count</code> 限制消费者负载。</li>
</ul>
<p>场景：大消息吞吐量</p>
<ul>
<li><strong>队列模式</strong>：懒队列。</li>
<li><strong>分片队列</strong>：通过路由键分发消息到多个队列。</li>
</ul>
</li>
</ol>
<h4 id="问：RabbitMQ-中的慢消费者是什么？如何解决慢消费者问题？"><a href="#问：RabbitMQ-中的慢消费者是什么？如何解决慢消费者问题？" class="headerlink" title="问：RabbitMQ 中的慢消费者是什么？如何解决慢消费者问题？"></a>问：RabbitMQ 中的慢消费者是什么？如何解决慢消费者问题？</h4><ul>
<li><p>什么是 RabbitMQ 中的慢消费者？</p>
<ul>
<li><p>在 RabbitMQ 中，“慢消费者”是指消费速度较慢的消费者。它不能及时处理从队列中推送的消息，导致队列中的消息堆积或其他消费者无法获得均衡的消息负载。慢消费者会引发以下问题：</p>
<ol>
<li><strong>消息堆积</strong>：队列中未处理的消息会持续增加，占用内存或磁盘。</li>
<li><strong>高延迟</strong>：其他消费者可能因慢消费者拖累整体性能。</li>
<li><strong>资源占用</strong>：慢消费者消耗的连接和信道资源可能影响整个 RabbitMQ 集群的性能。</li>
</ol>
</li>
</ul>
</li>
<li><p>慢消费者的常见原因?</p>
<ol>
<li><strong>消费者处理能力不足</strong>：消费者的 CPU、内存等硬件资源不足。</li>
<li><strong>消费逻辑复杂</strong>：消费者在处理消息时执行复杂的业务逻辑或调用慢速 I/O 操作（如数据库或外部 API）。</li>
<li><strong>消息处理单线程</strong>：消费者未能并行处理消息，导致消费速度缓慢。</li>
<li><strong>网络瓶颈</strong>：消费者所在网络带宽不足或延迟较高。</li>
<li><strong>消息堆积</strong>：队列中已有大量消息，消费者难以快速处理完。</li>
</ol>
</li>
<li><p>如何解决慢消费者问题？</p>
<ol>
<li><p><strong>优化消费者性能</strong></p>
<ul>
<li><strong>简化处理逻辑</strong>：优化业务逻辑，减少复杂操作。</li>
<li><strong>减少 I/O 操作</strong>：使用批量写入数据库、缓存热点数据等方式，减少慢速 I/O 操作。</li>
<li><strong>并行处理</strong>：通过多线程或多进程并行处理消息，充分利用多核 CPU。</li>
</ul>
</li>
<li><p><strong>合理配置 RabbitMQ 参数</strong></p>
<ul>
<li><p>Prefetch 限制：设置 <code>prefetch_count</code> 参数，限制每次推送给消费者的消息数量，防止消费者处理不及时。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">channel.basicQos(prefetch_count=N);</span><br></pre></td></tr></table></figure></li>
<li><p><strong>消息优先级</strong>：为重要消息设置优先级，确保关键消息优先被处理。</p>
</li>
<li><p><strong>TTL 和死信队列</strong>：为消息设置过期时间和死信队列，防止无限堆积。</p>
</li>
</ul>
</li>
<li><p><strong>增加消费者实例</strong></p>
<ul>
<li><strong>水平扩展</strong>：增加消费者数量，分担消费压力。</li>
<li><strong>负载均衡</strong>：使用负载均衡器确保多个消费者均匀处理消息。</li>
</ul>
</li>
<li><p><strong>调整队列模式</strong></p>
<ul>
<li><strong>分片队列</strong>：将大队列拆分为多个小队列，减少每个队列的压力。</li>
<li><strong>Lazy Queue</strong>：对于需要持久化的消息，使用 <code>lazy queues</code> 将消息写入磁盘，减轻内存压力。</li>
</ul>
</li>
<li><p><strong>监控与报警</strong></p>
<ul>
<li>使用 RabbitMQ Management 插件、Prometheus + Grafana 等工具实时监控队列的消息堆积情况和消费者的消费速率。</li>
<li>设置报警规则，在队列堆积超过阈值时通知运维团队。</li>
</ul>
</li>
<li><p><strong>备选解决方案</strong></p>
<ul>
<li><strong>异步处理</strong>：将耗时操作拆分为异步任务，降低消费者的实时处理压力。</li>
<li><strong>快速确认模式</strong>：消费者先快速确认消息，再异步处理，防止 RabbitMQ 认为消息未处理完导致重发。</li>
</ul>
</li>
</ol>
</li>
<li><p>示例：慢消费者优化</p>
<ol>
<li><p><strong>问题现象</strong></p>
<ul>
<li>队列 <code>order-processing</code> 中有大量未处理消息。</li>
<li>单个消费者消费速度明显低于消息的产生速度。</li>
</ul>
</li>
<li><p><strong>解决方案</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 配置 prefetch</span></span><br><span class="line">channel.basicQos(<span class="number">10</span>); <span class="comment">// 每次最多处理 10 条消息</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 使用线程池并行消费</span></span><br><span class="line">ExecutorService executor = Executors.newFixedThreadPool(<span class="number">10</span>);</span><br><span class="line"><span class="keyword">while</span> (<span class="keyword">true</span>) &#123;</span><br><span class="line">    String message = queue.poll();</span><br><span class="line">    executor.submit(() -&gt; processMessage(message));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 批量数据库写入</span></span><br><span class="line">List&lt;Message&gt; batch = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; batchSize; i++) &#123;</span><br><span class="line">    batch.add(queue.poll());</span><br><span class="line">&#125;</span><br><span class="line">database.batchInsert(batch);</span><br></pre></td></tr></table></figure></li>
<li><p><strong>优化结果</strong></p>
<ul>
<li>消费速率提升，队列中消息堆积显著减少。</li>
<li>RabbitMQ 的性能和稳定性明显提高。</li>
</ul>
</li>
</ol>
</li>
</ul>
<h4 id="问：如何防止-RabbitMQ-中出现消息堆积和队列爆炸？"><a href="#问：如何防止-RabbitMQ-中出现消息堆积和队列爆炸？" class="headerlink" title="问：如何防止 RabbitMQ 中出现消息堆积和队列爆炸？"></a>问：如何防止 RabbitMQ 中出现消息堆积和队列爆炸？</h4><p>防止 RabbitMQ 中出现消息堆积和队列爆炸，可以从<strong>消息生产、队列配置、消费者优化</strong>以及<strong>监控与管理</strong>多个方面进行预防和优化。以下是详细策略和实践方案：</p>
<ol>
<li><p><strong>消息生产端优化</strong></p>
<p>限制生产速率</p>
<ul>
<li><strong>流控机制</strong>：通过 RabbitMQ 提供的 <code>channel.flow</code> 方法对生产者施加流量限制，避免生产过多消息。</li>
<li><strong>基于业务逻辑的限流</strong>：在业务层实现动态速率控制，根据消费者的消费能力调整消息生产速率。</li>
</ul>
<p>消息合并</p>
<ul>
<li><strong>批量发送</strong>：合并小消息为大消息，减少消息数量。</li>
<li><strong>合并队列</strong>：对于高频小消息，使用消息聚合机制合并处理。</li>
</ul>
</li>
<li><p><strong>队列配置优化</strong></p>
<p>配置消息 TTL（Time To Live）</p>
<ul>
<li><p>为消息设置过期时间，过期的消息会自动清理，防止队列中积压大量无效消息。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">arguments.put(<span class="string">&quot;x-message-ttl&quot;</span>, 60000); // 消息存活时间为 60 秒</span><br></pre></td></tr></table></figure></li>
</ul>
<p>设置队列长度限制</p>
<ul>
<li><p>使用 <code>x-max-length</code> 或 <code>x-max-length-bytes</code> 参数限制队列中消息的最大数量或大小，超出限制的消息会被丢弃或转入死信队列。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">arguments.put(<span class="string">&quot;x-max-length&quot;</span>, 10000); // 队列最大允许存储 10000 条消息</span><br></pre></td></tr></table></figure></li>
</ul>
<p>启用 Lazy Queue 模式</p>
<ul>
<li><p>将消息存储在磁盘而非内存中，适用于消息堆积可能性较大的场景，减轻内存压力。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">arguments.put(<span class="string">&quot;x-queue-mode&quot;</span>, <span class="string">&quot;lazy&quot;</span>);</span><br></pre></td></tr></table></figure></li>
</ul>
</li>
</ol>
<ol start="3">
<li><p><strong>消费者端优化</strong></p>
<p>增加消费者并发</p>
<ul>
<li><strong>水平扩展消费者</strong>：增加消费者实例以提高处理能力。</li>
<li><strong>多线程消费</strong>：单个消费者实例中增加消费线程数，充分利用硬件资源。</li>
</ul>
<p>优化消费逻辑</p>
<ul>
<li><strong>快速确认消息</strong>：消费者优先确认消息，然后异步处理，减少 RabbitMQ 对未确认消息的等待。</li>
<li><strong>批量处理</strong>：消费端支持批量获取消息，减少网络开销和单条消息处理时间。</li>
</ul>
<p>配置预取机制</p>
<ul>
<li><p>使用 <code>basicQos</code> 方法配置 <code>prefetch_count</code> 参数，限制单次推送的消息数量，防止消费者处理不及时导致消息堆积。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">channel.basicQos(10); // 每次最多推送 10 条消息</span><br></pre></td></tr></table></figure></li>
</ul>
</li>
</ol>
<ol start="4">
<li><p><strong>监控与管理</strong></p>
<p>实时监控队列</p>
<ul>
<li>使用 RabbitMQ Management 插件、Prometheus + Grafana 等工具监控队列长度、消息速率等指标，发现问题及时预警。</li>
</ul>
<p>设置报警机制</p>
<ul>
<li>配置队列长度阈值报警规则。例如，当队列长度超过 10,000 时，触发告警通知。</li>
</ul>
<p>使用死信队列</p>
<ul>
<li>为队列配置死信交换机（DLX），将处理失败或过期的消息转移到死信队列进行监控和分析。</li>
</ul>
</li>
<li><p><strong>应急措施</strong></p>
<p>消息限流或拒绝策略</p>
<ul>
<li>临时启用流控机制，限制生产者发送速率。</li>
<li>消息队列已接近爆炸时，生产者可以根据业务优先级，丢弃非关键消息。</li>
</ul>
<p>消息分片</p>
<ul>
<li>将一个大队列拆分为多个小队列，分布式消费，降低单个队列的压力。</li>
</ul>
<p>增加资源</p>
<ul>
<li>动态扩容 RabbitMQ 集群节点，分散队列压力。</li>
<li>增加消费者实例和处理能力。</li>
</ul>
</li>
<li><p>示例：防止消息堆积的配置代码</p>
<p>设置队列长度和消息 TTL</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Map&lt;String, Object&gt; args = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line">args.put(<span class="string">&quot;x-max-length&quot;</span>, <span class="number">10000</span>); <span class="comment">// 最大消息数</span></span><br><span class="line">args.put(<span class="string">&quot;x-message-ttl&quot;</span>, <span class="number">60000</span>); <span class="comment">// 消息过期时间 60 秒</span></span><br><span class="line">args.put(<span class="string">&quot;x-dead-letter-exchange&quot;</span>, <span class="string">&quot;dlx_exchange&quot;</span>); <span class="comment">// 配置死信交换机</span></span><br><span class="line">channel.queueDeclare(<span class="string">&quot;task_queue&quot;</span>, <span class="keyword">true</span>, <span class="keyword">false</span>, <span class="keyword">false</span>, args);</span><br></pre></td></tr></table></figure>

<p>配置消费者预取</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">channel.basicQos(<span class="number">10</span>); <span class="comment">// 每次最多接收 10 条消息</span></span><br></pre></td></tr></table></figure>

<p>消息合并发送</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">List&lt;Message&gt; batchMessages = getMessages(); <span class="comment">// 获取待发送的消息</span></span><br><span class="line"><span class="keyword">for</span> (Message msg : batchMessages) &#123;</span><br><span class="line">    channel.basicPublish(exchangeName, routingKey, <span class="keyword">null</span>, msg.toBytes());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>总结</p>
<p>通过限制生产速率、优化队列配置、提升消费者性能、加强监控与报警，以及制定合理的应急方案，可以有效防止 RabbitMQ 中出现消息堆积和队列爆炸问题。</p>
</li>
</ol>
<h4 id="问：如何监控-RabbitMQ-集群的性能？"><a href="#问：如何监控-RabbitMQ-集群的性能？" class="headerlink" title="问：如何监控 RabbitMQ 集群的性能？"></a>问：如何监控 RabbitMQ 集群的性能？</h4><ol>
<li><p><strong>监控 RabbitMQ 的关键指标</strong></p>
<p>1.1 消息指标</p>
<ul>
<li><strong>队列长度</strong>：队列中未消费的消息数量。过长可能导致消息堆积。</li>
<li><strong>消息发布速率</strong>：生产者发送消息的速率。</li>
<li><strong>消息消费速率</strong>：消费者消费消息的速率。</li>
<li><strong>消息确认速率</strong>：消费者确认消息的速率。</li>
<li><strong>消息堆积时间</strong>：消息从进入队列到被消费的平均时间。</li>
</ul>
<p>1.2 连接和信道指标</p>
<ul>
<li><strong>连接数量</strong>：当前活跃的客户端连接数。</li>
<li><strong>信道数量</strong>：当前使用的信道数。</li>
<li><strong>未确认的消息数量</strong>：消费者处理未完成的消息数量。</li>
</ul>
<p>1.3 集群资源使用</p>
<ul>
<li><strong>CPU 使用率</strong>：节点 CPU 的消耗情况。</li>
<li><strong>内存使用量</strong>：RabbitMQ 消耗的内存，包括缓存、队列等。</li>
<li><strong>磁盘使用量</strong>：消息持久化对磁盘的占用。</li>
<li><strong>网络流量</strong>：消息发布和消费带来的网络流量。</li>
</ul>
<p>1.4 集群状态</p>
<ul>
<li><strong>节点健康</strong>：集群中节点的存活状态。</li>
<li><strong>磁盘警告</strong>：是否触发磁盘使用量过高的警告。</li>
<li><strong>内存警告</strong>：是否触发内存使用量过高的警告。</li>
</ul>
</li>
<li><p><strong>监控工具</strong></p>
<p>2.1 RabbitMQ Management 插件</p>
<ul>
<li><strong>内置插件</strong>，提供 Web UI 和 HTTP API，可以实时查看 RabbitMQ 的状态和指标。</li>
<li>功能：<ul>
<li>查看队列、交换机、信道、连接等状态。</li>
<li>分析消息速率、队列长度等性能指标。</li>
<li>支持图表化展示性能趋势。</li>
</ul>
</li>
</ul>
<p>2.2 外部监控工具</p>
<ul>
<li>Prometheus + Grafana<ul>
<li>Prometheus 通过 RabbitMQ Exporter 收集监控数据，Grafana 可视化展示。</li>
<li>优点：支持长时间指标存储和自定义报警规则。</li>
</ul>
</li>
<li>ELK（Elasticsearch + Logstash + Kibana）<ul>
<li>收集 RabbitMQ 的日志数据进行集中分析。</li>
</ul>
</li>
<li>Zabbix / Nagios<ul>
<li>集成 RabbitMQ 监控脚本，监控系统资源和关键 RabbitMQ 指标。</li>
</ul>
</li>
<li>CloudAMQP<ul>
<li>专为 RabbitMQ 提供的托管服务，内置监控和报警功能。</li>
</ul>
</li>
</ul>
<p>2.3 CLI 工具</p>
<ul>
<li><code>rabbitmqctl</code><ul>
<li>本地命令行工具，支持节点状态、队列长度等基本信息查看。</li>
</ul>
</li>
<li><code>rabbitmq-diagnostics</code><ul>
<li>提供诊断功能，比如查看队列延迟、进程信息等。</li>
</ul>
</li>
</ul>
</li>
<li><p><strong>性能问题的监控与报警</strong></p>
<p>3.1 配置报警规则</p>
<ul>
<li><strong>队列长度过长</strong>：如果队列长度超过阈值，触发报警。</li>
<li><strong>CPU/内存使用率过高</strong>：系统资源接近瓶颈时报警。</li>
<li><strong>消息消费异常</strong>：如消费速率明显低于生产速率时报警。</li>
<li><strong>节点健康检查失败</strong>：节点宕机或未响应时报警。</li>
</ul>
<p>3.2 日志分析</p>
<ul>
<li><p>日志类型：</p>
<ul>
<li><code>rabbit.log</code>：系统日志，包括连接、信道等信息。</li>
<li><code>rabbit-sasl.log</code>：安全相关日志。</li>
</ul>
</li>
<li><p>关注点：</p>
<ul>
<li>消息确认失败。</li>
<li>队列或交换机无法找到。</li>
<li>节点间通信失败。</li>
</ul>
</li>
</ul>
<p>3.3 集群状态监控</p>
<ul>
<li><strong>分片节点状态</strong>：确保集群的分片节点（Shard）均健康运行。</li>
<li><strong>镜像队列同步</strong>：监控镜像队列的复制状态，避免同步延迟。</li>
</ul>
</li>
<li><p><strong>监控数据分析与优化</strong></p>
<p>4.1 性能瓶颈分析</p>
<ul>
<li><strong>高队列长度</strong>：增加消费者或优化消费逻辑。</li>
<li><strong>高 CPU 使用率</strong>：检查消息处理密集度，优化消息处理流程。</li>
<li><strong>高网络流量</strong>：分析是否有大批量消息发布或消费。</li>
</ul>
<p>4.2 调整 RabbitMQ 配置</p>
<ul>
<li><p>队列模式：</p>
<ul>
<li>使用 Lazy Queue 模式，将消息存储在磁盘而非内存中。</li>
</ul>
</li>
<li><p>资源分配：</p>
<ul>
<li>配置 <code>vm_memory_high_watermark</code>，优化内存使用。</li>
<li>配置磁盘报警阈值 <code>disk_free_limit</code>。</li>
</ul>
</li>
<li><p>消费者预取：</p>
<ul>
<li>通过调整 <code>basic.qos</code> 优化信道的消息分配。</li>
</ul>
</li>
</ul>
</li>
<li><p>示例：Prometheus + Grafana 配置 RabbitMQ 监控</p>
<ol>
<li><p>安装 RabbitMQ Exporter：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker run -d --name rabbitmq-exporter -e RABBITMQ_URL=http://&lt;username&gt;:&lt;password&gt;@&lt;rabbitmq_host&gt;:15672 kbudde/rabbitmq-exporter</span><br></pre></td></tr></table></figure></li>
<li><p>配置 Prometheus 抓取 RabbitMQ 数据：</p>
<figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">scrape_configs:</span></span><br><span class="line">  <span class="bullet">-</span> <span class="attr">job_name:</span> <span class="string">&#x27;rabbitmq&#x27;</span></span><br><span class="line">    <span class="attr">static_configs:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="attr">targets:</span> [<span class="string">&#x27;localhost:9419&#x27;</span>] <span class="comment"># RabbitMQ Exporter 的地址</span></span><br></pre></td></tr></table></figure></li>
<li><p>在 Grafana 中导入 RabbitMQ Dashboard：</p>
<ul>
<li>使用现有模板（例如 ID: 10991）快速创建 RabbitMQ 监控看板。</li>
</ul>
</li>
</ol>
</li>
</ol>
<p>总结：通过实时监控 RabbitMQ 的关键性能指标、使用合适的工具（如 Management 插件、Prometheus + Grafana），并配置报警和优化策略，可以全面保障 RabbitMQ 集群的性能和稳定性。</p>
<h4 id="问：RabbitMQ-如何配置流控机制（Flow-Control）来防止消息堆积？"><a href="#问：RabbitMQ-如何配置流控机制（Flow-Control）来防止消息堆积？" class="headerlink" title="问：RabbitMQ 如何配置流控机制（Flow Control）来防止消息堆积？"></a>问：RabbitMQ 如何配置流控机制（Flow Control）来防止消息堆积？</h4><p>RabbitMQ 提供了流控机制（Flow Control），可以通过<strong>动态调整客户端消息流速来防止消息堆积</strong>，从而避免系统性能下降甚至宕机。以下是 RabbitMQ 流控机制的原理及配置方法：</p>
<ol>
<li><p><strong>RabbitMQ 流控机制简介</strong></p>
<ul>
<li>流控机制<strong>通过检测节点的资源使用情况（如内存、磁盘）来触发控制措施，限制生产者的消息发送速率</strong>，确保系统能够在高负载情况下继续运行。</li>
</ul>
</li>
<li><p><strong>流控触发条件</strong></p>
<ol>
<li><strong>内存使用量</strong>：<ul>
<li>当节点使用的内存超过配置的阈值时，触发流控。</li>
<li>配置参数：<code>vm_memory_high_watermark</code>，以比例表示（如 0.4，表示内存的 40%）。</li>
</ul>
</li>
<li><strong>磁盘使用量</strong>：<ul>
<li>当磁盘可用空间小于配置的阈值时，触发流控。</li>
<li>配置参数：<code>disk_free_limit</code>，可以是绝对值（如 <code>50MB</code>）或百分比。</li>
</ul>
</li>
<li><strong>文件描述符使用量</strong>：<ul>
<li>当节点达到文件描述符上限时，可能导致连接问题，需要手动调整系统参数。</li>
</ul>
</li>
</ol>
</li>
<li><p><strong>流控的作用</strong></p>
<p>当触发流控时，RabbitMQ 会对生产者连接应用背压（back-pressure），限制消息的发送速率。具体表现为：</p>
<ul>
<li><strong>TCP 传输阻塞</strong>：RabbitMQ 将减少或暂停从生产者接收新消息。</li>
<li><strong>拒绝新连接</strong>：如果资源紧张，可能会拒绝新连接请求。</li>
<li><strong>告警日志</strong>：系统会生成相关日志，便于运维排查。</li>
</ul>
</li>
<li><p><strong>配置流控参数</strong></p>
<p>4.1 配置内存阈值</p>
<p>在配置文件 <code>rabbitmq.conf</code> 中设置内存阈值：</p>
<figure class="highlight ini"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">vm_memory_high_watermark.relative</span> = <span class="number">0.4</span>   <span class="comment"># 使用总内存的 40%</span></span><br></pre></td></tr></table></figure>

<p>或设置为绝对值：</p>
<figure class="highlight ini"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">vm_memory_high_watermark.absolute</span> = <span class="number">512</span>MB  <span class="comment"># 固定内存上限为 512MB</span></span><br></pre></td></tr></table></figure>

<p>4.2 配置磁盘阈值</p>
<p>设置磁盘可用空间的下限：</p>
<figure class="highlight ini"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">disk_free_limit.absolute</span> = <span class="number">1</span>GB   <span class="comment"># 磁盘剩余空间不足 1GB 时触发流控</span></span><br></pre></td></tr></table></figure>

<p>或设置为动态值（总磁盘的百分比）：</p>
<figure class="highlight ini"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">disk_free_limit.relative</span> = <span class="number">0.1</span>   <span class="comment"># 剩余空间不足 10% 时触发流控</span></span><br></pre></td></tr></table></figure>

<p>4.3 配置文件描述符限制</p>
<p>在系统层面调整文件描述符的上限：</p>
<ol>
<li><p>修改 <code>/etc/security/limits.conf</code> ：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">rabbitmq    soft    nofile  65536</span><br><span class="line">rabbitmq    hard    nofile  65536</span><br></pre></td></tr></table></figure></li>
<li><p>配置 <code>rabbitmq-env.conf</code>：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">RABBITMQ_ULIMIT_NOFILES=65536</span><br></pre></td></tr></table></figure></li>
</ol>
<p>4.4 开启磁盘报警（Disk Alarm）</p>
<p>RabbitMQ 默认启用磁盘报警，确保磁盘资源不足时发出警告。</p>
</li>
<li><p><strong>检测流控状态</strong></p>
<ol>
<li><p>使用 <code>rabbitmqctl</code> 工具查看节点状态：<code>rabbitmqctl status</code> 观察内存、磁盘和文件描述符的使用情况。</p>
</li>
<li><p>使用 RabbitMQ Management 插件：</p>
<ul>
<li>打开 Web UI（默认 <code>http://&lt;host&gt;:15672</code>）。</li>
<li>在 “Overview” 页面查看内存和磁盘使用情况，以及流控触发状态。</li>
</ul>
</li>
<li><p>检查日志文件：</p>
<ul>
<li><p>默认日志路径为 <code>/var/log/rabbitmq/rabbit@&lt;hostname&gt;.log</code>。</p>
</li>
<li><p>查看是否存在类似以下流控日志：</p>
</li>
</ul>
</li>
</ol>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">memory high watermark 0.4 reached</span><br><span class="line">disk free space below limit of 1GB</span><br></pre></td></tr></table></figure></li>
<li><p><strong>优化方案</strong></p>
<p>6.1 调整队列和消息设计</p>
<ul>
<li><strong>优化队列数量</strong>：减少不必要的队列，降低内存消耗。</li>
<li><strong>消息大小控制</strong>：避免发送过大的消息，尽量拆分为小消息。</li>
</ul>
<p>6.2 增加系统资源</p>
<ul>
<li>增加节点的内存和磁盘容量。</li>
<li>使用更高性能的磁盘（如 SSD）提升 IO 能力。</li>
</ul>
<p>6.3 使用 Lazy Queue</p>
<ul>
<li><p>将消息存储在磁盘而非内存中，适合大队列但消费速率低的场景：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">rabbitmqctl set_policy lazy-queues <span class="string">&quot;^lazy-.*&quot;</span> <span class="string">&#x27;&#123;&quot;queue-mode&quot;:&quot;lazy&quot;&#125;&#x27;</span></span><br></pre></td></tr></table></figure></li>
</ul>
<p>6.4 调整预取（Prefetch）值</p>
<ul>
<li><p>限制消费者一次性获取的消息数量，避免消息堆积。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">channel.basicQos(<span class="number">1</span>);  <span class="comment">// 设置每次只获取 1 条消息</span></span><br></pre></td></tr></table></figure></li>
</ul>
<p>6.5 分布式部署</p>
<ul>
<li>增加 RabbitMQ 节点，使用集群分担流量压力。</li>
<li>使用镜像队列（Mirrored Queues）提升高可用性。</li>
</ul>
</li>
<li><p><strong>流控的注意事项</strong></p>
<ul>
<li><strong>生产者需实现重试机制</strong>：触发流控时，生产者可能会收到错误，需要重试发送。</li>
<li><strong>消费者处理能力匹配</strong>：确保消费者消费速率不低于生产速率。</li>
<li><strong>负载均衡</strong>：对于高并发场景，可以通过分片或路由均衡流量。</li>
</ul>
</li>
</ol>
<h4 id="问：通过集群来治理消息堆积？"><a href="#问：通过集群来治理消息堆积？" class="headerlink" title="问：通过集群来治理消息堆积？"></a>问：通过集群来治理消息堆积？</h4><p><strong>消息堆积</strong>是在使用消息中间件过程中遇到的最正常不过的事情。消息堆积是一把双刃剑，适量的堆积可以有削峰、缓存之用 ，但是如果堆积过于严重，就可能影响到其他队列的使用，导致整体服务质量的下降。</p>
<p>对于一台普通的服务器来说，在一个队列中堆积1万至10万条消息，丝毫不会影响什么。但是如果这个队列中堆积超过1千万乃至一亿条消息时，可能会引起一些严 重的问题，比如引起内存或者磁盘告警而造成所有 Connection 阻塞。</p>
<p>解决方案：</p>
<ul>
<li>消息堆积严重时，可以选择清空队列，或者采用空消费程序丢弃掉部分消息。不过对于重要的数据而言，丢弃消息的方案并无用武之地。</li>
<li>另一种方案是增加下游消费者的消费能力，这个思路可以通过后期优化代码逻辑或者增加消费者的实例数来实现。但是后期的代码优化在面临紧急情况时总归是“远水解不了近渴”，并且有些业务场景也井非可以简单地通过增加消费实例而得以增强消费能力。</li>
<li>当某个队列中的消息堆积严重时，比如超过某个设定的阑值，就可以通过 Shovel 将队列中的消息移交给另一个集群。</li>
</ul>
<p>几种情形：</p>
<ul>
<li>情形1：当检测到当前运行集群 cluster1 中的队列 queue1 中有严重消息堆积，比如通过 <code>/api/queues/vhost/name</code> 接口获取到队列的消息个数（messages）超过2千万或者消息占用大小（messages_bytes）超过 10GB 时，就启用 shovel1 将队列 queue1 中的消息转发至备份集群 cluster2 中的队列 queue2。</li>
<li>情形2：紧随情形1，当检测到队列 queue1 中的消息个数低于1百万或者消息占用大小低于1GB 时就停止 shovel1，然后让原本队列 queue1 中的消费者慢慢处理剩余的堆积。</li>
<li>情形3：当检测到队列 queue1 中的消息个数低于 10 万或者消息占用大小低于100MB时， 就开启 shovel2 将队列 queue2 中暂存的消息返还给队列 queue1。</li>
<li>情形4：紧随情形3，当检测到队列 queue1 中的消息个数超过1百万或者消息占用大小高于 1GB 时就将 shovel2 停掉。</li>
</ul>
<p><img src="https://pic-1258215793.cos.ap-shanghai.myqcloud.com/content/20201001/202010010149.png"></p>
<p>如此，队列 queue1 就拥有了队列 queue2 这个“保镖”为它保驾护航。这里是一备一的情形，如果需要一备多，可以采用镜像队列或者引入 Federation。</p>
<h3 id="实践问题"><a href="#实践问题" class="headerlink" title="实践问题"></a>实践问题</h3><h4 id="问：如何保证-RabbitMQ-消息的顺序性？"><a href="#问：如何保证-RabbitMQ-消息的顺序性？" class="headerlink" title="问：如何保证 RabbitMQ 消息的顺序性？"></a>问：如何保证 RabbitMQ 消息的顺序性？</h4><p>RabbitMQ 本身是分布式的消息队列系统，在高并发、多个消费者和集群模式下，消息顺序可能会被打乱。以下是一些确保消息顺序性的策略：</p>
<ol>
<li><p><strong>消息顺序性的问题</strong></p>
<ul>
<li><p><strong>单一队列与单一消费者</strong>：如果只有一个队列和一个消费者，RabbitMQ 可以保证消息按照发送顺序消费。</p>
</li>
<li><p>多队列或多消费者：在多队列、多消费者模式下，消息顺序可能会因为以下原因被打乱：</p>
<ul>
<li>消息分发到多个队列。</li>
<li>消费者消费速度不同。</li>
<li>消费者处理失败重试，导致顺序错乱。</li>
</ul>
</li>
</ul>
</li>
<li><p><strong>保证消息顺序性的策略</strong></p>
<p><strong>2.1 使用单队列单消费者模式</strong></p>
<ul>
<li><p><strong>原理</strong>：一个队列只有一个消费者，消息按照发送的顺序依次处理。</p>
</li>
<li><p><strong>适用场景</strong>：消息量较小或对吞吐量要求不高的场景。</p>
</li>
<li><p>缺点：</p>
<ul>
<li>消费速率受限，吞吐量较低。</li>
<li>容易成为系统瓶颈。</li>
</ul>
</li>
</ul>
<p><strong>2.2 同一类型的消息路由到同一队列</strong></p>
<ul>
<li><p><strong>原理</strong>：通过设置 <code>Routing Key</code> 或自定义规则，将需要保证顺序性的消息路由到同一个队列。</p>
</li>
<li><p>实现：</p>
<ul>
<li>生产者发送消息时指定相同的 <code>Routing Key</code>。</li>
<li>使用 <code>Direct Exchange</code> 或 <code>Topic Exchange</code> 绑定规则，将消息路由到指定队列。</li>
</ul>
</li>
</ul>
<p><strong>2.3 使用消息分区（Partitioning）</strong></p>
<ul>
<li><p><strong>原理</strong>：按照某种规则（如用户 ID、订单 ID）将消息分组，每个分组的消息发送到不同的队列。</p>
</li>
<li><p>实现：</p>
<ul>
<li>根据消息的属性（如订单号），对队列进行哈希分区。</li>
<li>每个分区队列的消费者只处理对应的消息，保证分区内消息的顺序。</li>
</ul>
</li>
<li><p><strong>适用场景</strong>：需要在某些维度上保证顺序性（如同一用户的消息必须有序）。</p>
</li>
</ul>
<p><strong>2.4 保证消费过程的单线程</strong></p>
<ul>
<li><p><strong>原理</strong>：即使使用多个队列，也让每个队列的消费者使用单线程处理消息。</p>
</li>
<li><p>实现：</p>
<ul>
<li>设置消费者预取值（<code>Prefetch Count</code>）为 1，确保每次只消费一条消息。</li>
<li>业务逻辑中避免多线程并发处理消息。</li>
</ul>
</li>
</ul>
<p><strong>2.5 利用事务机制</strong></p>
<ul>
<li><p><strong>原理</strong>：通过 RabbitMQ 的事务机制（<code>Publisher Confirms</code> 和消息确认），确保消息可靠发送和顺序处理。</p>
</li>
<li><p>实现：</p>
<ul>
<li>生产者开启事务模式，逐条发送消息并等待 RabbitMQ 确认。</li>
<li>消费者处理后逐条确认消息（<code>Ack</code>）。</li>
</ul>
</li>
</ul>
<p><strong>2.6 消息重新排序</strong></p>
<ul>
<li><p><strong>原理</strong>：如果顺序被打乱，在消费端重新排序。</p>
</li>
<li><p>实现：</p>
<ul>
<li>每条消息带上顺序号或时间戳。</li>
<li>消费端缓存一段时间，按照顺序号或时间戳重新排列后处理。</li>
</ul>
</li>
<li><p>缺点：</p>
<ul>
<li>增加了消费端的复杂性。</li>
<li>存在延迟问题，不适合实时性要求高的场景。</li>
</ul>
</li>
</ul>
<p><strong>2.7 消费失败重试时的处理</strong></p>
<ul>
<li><p><strong>原理</strong>：防止消息处理失败后跳过当前消息，导致顺序错乱。</p>
</li>
<li><p>实现：</p>
<ul>
<li>使用死信队列（DLQ）存储失败消息，并重新投递到原队列中。</li>
<li>或者在消费端实现消息的延迟重试机制，确保按照顺序处理。</li>
</ul>
</li>
</ul>
</li>
<li><p><strong>结合场景选择策略</strong></p>
<ul>
<li><strong>顺序性强依赖</strong>：如订单支付流程，适合单队列单消费者或同一类型消息路由到同一队列。</li>
<li><strong>吞吐量要求高</strong>：如大规模日志收集，适合消息分区或消费端排序。</li>
<li><strong>容错性高要求</strong>：如库存扣减，适合使用死信队列+重试机制。</li>
</ul>
</li>
<li><p><strong>注意事项</strong></p>
<ul>
<li><strong>吞吐量与顺序性</strong>：顺序性和高吞吐量往往是矛盾的，需要权衡取舍。</li>
<li><strong>集群模式的影响</strong>：RabbitMQ 的集群模式中，队列的主从同步可能会影响消息顺序，建议将需要顺序性的队列绑定到固定节点上。</li>
<li><strong>消费端逻辑简化</strong>：消费端尽量减少复杂操作，避免人为造成顺序错乱。</li>
</ul>
</li>
</ol>
<h4 id="问：如何在-RabbitMQ-中实现消息优先级（Message-Priority）？"><a href="#问：如何在-RabbitMQ-中实现消息优先级（Message-Priority）？" class="headerlink" title="问：如何在 RabbitMQ 中实现消息优先级（Message Priority）？"></a>问：如何在 RabbitMQ 中实现消息优先级（Message Priority）？</h4><p>通过 <strong>消息优先级队列（Priority Queue）</strong> 实现消息的优先级处理。</p>
<ul>
<li><p>RabbitMQ 的优先级队列，根据消息的优先级属性对其进行排序，允许消费者优先处理具有较高优先级的消息。</p>
</li>
<li><p>配置步骤：</p>
<ol>
<li>配置优先级队列：声明队列时通过队列属性 <code>x-max-priority</code> 设置最大优先级值（0~255）。超过范围的消息优先级将被忽略或默认处理。</li>
</ol>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Map&lt;String, Object&gt; args = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line">args.put(<span class="string">&quot;x-max-priority&quot;</span>, <span class="number">10</span>); <span class="comment">// 设置队列的最大优先级为 10</span></span><br><span class="line"></span><br><span class="line">channel.queueDeclare(<span class="string">&quot;priority_queue&quot;</span>, <span class="keyword">true</span>, <span class="keyword">false</span>, <span class="keyword">false</span>, args);</span><br></pre></td></tr></table></figure>

<ol start="2">
<li>设置消息优先级：生产者在发送消息时，通过设置 <code>priority</code> 属性指定消息的优先级。</li>
</ol>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">AMQP.BasicProperties properties = <span class="keyword">new</span> AMQP.BasicProperties.Builder()</span><br><span class="line">    .priority(<span class="number">5</span>) <span class="comment">// 设置消息的优先级为 5</span></span><br><span class="line">    .build();</span><br><span class="line"></span><br><span class="line">channel.basicPublish(<span class="string">&quot;&quot;</span>, <span class="string">&quot;priority_queue&quot;</span>, properties, <span class="string">&quot;Message with priority&quot;</span>.getBytes());</span><br></pre></td></tr></table></figure>

<ol start="3">
<li>消费消息：消费者无需额外配置，RabbitMQ 自动按照优先级分发消息。优先级越高的消息越早被消费。</li>
</ol>
</li>
<li><p>特性与限制</p>
<ol>
<li><strong>优先级范围</strong>：RabbitMQ 的消息优先级支持 0 到 255 的范围，但通常推荐设置较小的优先级范围（如 1~10），过大的范围可能增加内存消耗。</li>
<li><strong>性能影响</strong>：优先级队列会增加内存和 CPU 开销，因为需要对消息进行排序。因此，优先级功能适用于小规模、高重要性的场景。</li>
<li><strong>低优先级消息延迟</strong>：高优先级消息可能导致低优先级消息长时间滞留队列，甚至无法被消费。</li>
</ol>
</li>
<li><p>使用场景：</p>
<ol>
<li><strong>任务调度</strong>：重要任务（如实时处理请求）优先于普通任务。</li>
<li><strong>报警系统</strong>：高危报警消息优先处理。</li>
<li><strong>订单系统</strong>：VIP 用户订单优先处理，普通用户次之。</li>
</ol>
</li>
<li><p>完整实现示例</p>
<ol>
<li>生产者代码</li>
</ol>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> com.rabbitmq.client.*;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.HashMap;</span><br><span class="line"><span class="keyword">import</span> java.util.Map;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Producer</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">static</span> String QUEUE_NAME = <span class="string">&quot;priority_queue&quot;</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        ConnectionFactory factory = <span class="keyword">new</span> ConnectionFactory();</span><br><span class="line">        factory.setHost(<span class="string">&quot;localhost&quot;</span>);</span><br><span class="line">        <span class="keyword">try</span> (Connection connection = factory.newConnection();</span><br><span class="line">             Channel channel = connection.createChannel()) &#123;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 声明优先级队列</span></span><br><span class="line">            Map&lt;String, Object&gt; argsMap = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line">            argsMap.put(<span class="string">&quot;x-max-priority&quot;</span>, <span class="number">10</span>);</span><br><span class="line">            channel.queueDeclare(QUEUE_NAME, <span class="keyword">true</span>, <span class="keyword">false</span>, <span class="keyword">false</span>, argsMap);</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 发送消息</span></span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= <span class="number">10</span>; i++) &#123;</span><br><span class="line">                <span class="keyword">int</span> priority = i % <span class="number">5</span>; <span class="comment">// 设置优先级</span></span><br><span class="line">                String message = <span class="string">&quot;Message with priority &quot;</span> + priority;</span><br><span class="line"></span><br><span class="line">                AMQP.BasicProperties properties = <span class="keyword">new</span> AMQP.BasicProperties.Builder()</span><br><span class="line">                        .priority(priority)</span><br><span class="line">                        .build();</span><br><span class="line"></span><br><span class="line">                channel.basicPublish(<span class="string">&quot;&quot;</span>, QUEUE_NAME, properties, message.getBytes());</span><br><span class="line">                System.out.println(<span class="string">&quot; [x] Sent &#x27;&quot;</span> + message + <span class="string">&quot;&#x27;&quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ol start="2">
<li>消费者代码</li>
</ol>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> com.rabbitmq.client.*;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Consumer</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">static</span> String QUEUE_NAME = <span class="string">&quot;priority_queue&quot;</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        ConnectionFactory factory = <span class="keyword">new</span> ConnectionFactory();</span><br><span class="line">        factory.setHost(<span class="string">&quot;localhost&quot;</span>);</span><br><span class="line">        <span class="keyword">try</span> (Connection connection = factory.newConnection();</span><br><span class="line">             Channel channel = connection.createChannel()) &#123;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 声明队列（需与生产者保持一致）</span></span><br><span class="line">            channel.queueDeclare(QUEUE_NAME, <span class="keyword">true</span>, <span class="keyword">false</span>, <span class="keyword">false</span>, <span class="keyword">null</span>);</span><br><span class="line"></span><br><span class="line">            System.out.println(<span class="string">&quot; [*] Waiting for messages...&quot;</span>);</span><br><span class="line"></span><br><span class="line">            DeliverCallback deliverCallback = (consumerTag, delivery) -&gt; &#123;</span><br><span class="line">                String message = <span class="keyword">new</span> String(delivery.getBody(), <span class="string">&quot;UTF-8&quot;</span>);</span><br><span class="line">                System.out.println(<span class="string">&quot; [x] Received &#x27;&quot;</span> + message + <span class="string">&quot;&#x27;&quot;</span>);</span><br><span class="line">            &#125;;</span><br><span class="line"></span><br><span class="line">            channel.basicConsume(QUEUE_NAME, <span class="keyword">true</span>, deliverCallback, consumerTag -&gt; &#123; &#125;);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li><p>注意事项</p>
<ol>
<li><p><strong>优先级消息的动态调整</strong>：<br>RabbitMQ 一旦入队，消息优先级不能动态调整。</p>
</li>
<li><p><strong>适用场景的权衡</strong>：<br>使用优先级队列需要根据业务需求权衡性能开销，避免滥用。</p>
</li>
<li><p><strong>非优先队列兼容性</strong>：<br>如果消息被发送到没有设置 <code>x-max-priority</code> 的队列，<code>priority</code> 属性将被忽略。</p>
</li>
</ol>
</li>
</ul>
<h4 id="问：如何在-RabbitMQ-中实现消息的延时发送？如何使用-RabbitMQ-实现延时消息队列？"><a href="#问：如何在-RabbitMQ-中实现消息的延时发送？如何使用-RabbitMQ-实现延时消息队列？" class="headerlink" title="问：如何在 RabbitMQ 中实现消息的延时发送？如何使用 RabbitMQ 实现延时消息队列？"></a>问：如何在 RabbitMQ 中实现消息的延时发送？如何使用 RabbitMQ 实现延时消息队列？</h4><ol>
<li><p>使用官方插件：<strong>RabbitMQ Delayed Message Plugin</strong>，支持动态设置消息的延迟时间。RabbitMQ 并没有直接内置的延时队列功能。</p>
<p><strong>实现步骤：</strong></p>
<ol>
<li><p><strong>安装插件：</strong></p>
<ul>
<li><p>下载并安装 RabbitMQ 的 <code>rabbitmq_delayed_message_exchange</code> 插件。</p>
</li>
<li><p>在 RabbitMQ 管理页面启用插件：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">rabbitmq-plugins <span class="built_in">enable</span> rabbitmq_delayed_message_exchange</span><br></pre></td></tr></table></figure></li>
</ul>
</li>
<li><p><strong>定义延迟交换机：</strong></p>
<ul>
<li>创建一个支持延迟功能的交换机（<code>x-delayed-message</code> 类型）。</li>
</ul>
</li>
<li><p><strong>消息发送时动态设置延迟时间：</strong></p>
<ul>
<li>在消息头中指定 <code>x-delay</code> 属性。</li>
</ul>
</li>
</ol>
<p><strong>代码示例：</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 创建延时交换机</span></span><br><span class="line">Map&lt;String, Object&gt; args = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line">args.put(<span class="string">&quot;x-delayed-type&quot;</span>, <span class="string">&quot;direct&quot;</span>);</span><br><span class="line">channel.exchangeDeclare(<span class="string">&quot;delayed_exchange&quot;</span>, <span class="string">&quot;x-delayed-message&quot;</span>, <span class="keyword">true</span>, <span class="keyword">false</span>, args);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 设置延时时间，并发送消息</span></span><br><span class="line">AMQP.BasicProperties.Builder props = <span class="keyword">new</span> AMQP.BasicProperties.Builder();</span><br><span class="line">props.headers(Map.of(<span class="string">&quot;x-delay&quot;</span>, <span class="number">5000</span>)); <span class="comment">// 延时时间 5 秒</span></span><br><span class="line">channel.basicPublish(<span class="string">&quot;delayed_exchange&quot;</span>, <span class="string">&quot;routing_key&quot;</span>, props.build(), <span class="string">&quot;Hello, Delayed!&quot;</span>.getBytes());</span><br><span class="line"></span><br><span class="line"><span class="meta">@Bean</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> CustomExchange <span class="title">delayedExchange</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    Map&lt;String, Object&gt; args = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line">    args.put(<span class="string">&quot;x-delayed-type&quot;</span>, <span class="string">&quot;direct&quot;</span>); <span class="comment">// 设置交换机类型为 direct</span></span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> CustomExchange(<span class="string">&quot;delayed_exchange&quot;</span>, <span class="string">&quot;x-delayed-message&quot;</span>, <span class="keyword">true</span>, <span class="keyword">false</span>, args);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Bean</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> Queue <span class="title">delayedQueue</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> Queue(<span class="string">&quot;delayed_queue&quot;</span>, <span class="keyword">true</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Bean</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> Binding <span class="title">delayedBinding</span><span class="params">(Queue delayedQueue, CustomExchange delayedExchange)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> BindingBuilder.bind(delayedQueue).to(delayedExchange).with(<span class="string">&quot;delayed_routing_key&quot;</span>).noargs();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 发送消息时设置延迟时间</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">sendDelayedMessage</span><span class="params">(String message, <span class="keyword">int</span> delay)</span> </span>&#123;</span><br><span class="line">    rabbitTemplate.convertAndSend(<span class="string">&quot;delayed_exchange&quot;</span>, <span class="string">&quot;delayed_routing_key&quot;</span>, message, msg -&gt; &#123;</span><br><span class="line">        msg.getMessageProperties().setHeader(<span class="string">&quot;x-delay&quot;</span>, delay); <span class="comment">// 设置延迟时间，单位为毫秒</span></span><br><span class="line">        <span class="keyword">return</span> msg;</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>优点：</strong></p>
<ul>
<li>简单易用，直接支持精确的延时控制。</li>
<li>支持动态延迟时间，灵活性强。</li>
<li>性能较好，不需要死信队列。</li>
</ul>
<p><strong>缺点：</strong></p>
<ul>
<li>需要额外安装插件，对现有环境可能有额外的部署要求，增加了一些运维成本。</li>
</ul>
</li>
<li><p>使用 TTL + 死信队列（最常用）</p>
<p>通过 RabbitMQ 的 <strong>TTL（Time To Live）</strong> 和 <strong>DLX（Dead Letter Exchange）</strong> 功能，也可以实现消息延时发送。</p>
<p><strong>实现步骤：</strong></p>
<ol>
<li><strong>创建两个队列：</strong><ul>
<li>一个用于存放延时消息（例如 <code>delay_queue</code>）。</li>
<li>一个用于实际消费的队列（例如 <code>consume_queue</code>）。</li>
</ul>
</li>
<li><strong>设置 TTL 和死信交换机：</strong><ul>
<li>在 <code>delay_queue</code> 上设置消息的 TTL（过期时间）。</li>
<li>配置死信交换机（DLX），将过期的消息路由到 <code>consume_queue</code>，消费者从普通队列中获取延时后的消息。</li>
</ul>
</li>
<li><strong>消息流转过程：</strong><ul>
<li>生产者将消息发送到 <code>delay_queue</code>，并设置消息的 TTL。</li>
<li>消息在 <code>delay_queue</code> 中等待 TTL 到期，转入死信交换机。</li>
<li>死信交换机将消息路由到实际消费的队列 <code>consume_queue</code>，供消费者处理。</li>
</ul>
</li>
</ol>
<p><strong>代码示例：</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 声明死信交换机</span></span><br><span class="line"><span class="meta">@Bean</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> DirectExchange <span class="title">dlxExchange</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> DirectExchange(<span class="string">&quot;dlx_exchange&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// channel.exchangeDeclare(&quot;dlx_exchange&quot;, &quot;direct&quot;, true);</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// 配置延时队列和死信队列</span></span><br><span class="line"><span class="meta">@Bean</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> Queue <span class="title">delayQueue</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> QueueBuilder.durable(<span class="string">&quot;delay_queue&quot;</span>)</span><br><span class="line">            .withArgument(<span class="string">&quot;x-dead-letter-exchange&quot;</span>, <span class="string">&quot;dlx_exchange&quot;</span>) <span class="comment">// 配置死信交换机</span></span><br><span class="line">            .withArgument(<span class="string">&quot;x-dead-letter-routing-key&quot;</span>, <span class="string">&quot;dlx_routing_key&quot;</span>) <span class="comment">// 配置死信路由键</span></span><br><span class="line">            .withArgument(<span class="string">&quot;x-message-ttl&quot;</span>, <span class="number">60000</span>) <span class="comment">// 消息的 TTL，单位为毫秒</span></span><br><span class="line">            .build();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Bean</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> Queue <span class="title">consumeQueue</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> QueueBuilder.durable(<span class="string">&quot;consume_queue&quot;</span>).build();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Bean</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> Binding <span class="title">dlxBinding</span><span class="params">(Queue consumeQueue, DirectExchange dlxExchange)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> BindingBuilder.bind(consumeQueue).to(dlxExchange).with(<span class="string">&quot;dlx_routing_key&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// channel.queueDeclare(&quot;dlx_queue&quot;, true, false, false, null);</span></span><br><span class="line"><span class="comment">// channel.queueBind(&quot;dlx_queue&quot;, &quot;dlx_exchange&quot;, &quot;dlx_routing_key&quot;);</span></span><br><span class="line"><span class="comment">// 声明 TTL 队列，并绑定到死信交换机</span></span><br><span class="line"><span class="comment">// Map&lt;String, Object&gt; args = new HashMap&lt;&gt;();</span></span><br><span class="line"><span class="comment">// args.put(&quot;x-dead-letter-exchange&quot;, &quot;dlx_exchange&quot;);</span></span><br><span class="line"><span class="comment">// args.put(&quot;x-dead-letter-routing-key&quot;, &quot;dlx_routing_key&quot;);</span></span><br><span class="line"><span class="comment">// args.put(&quot;x-message-ttl&quot;, 5000); // TTL 5 秒</span></span><br><span class="line"><span class="comment">// channel.queueDeclare(&quot;ttl_queue&quot;, true, false, false, args);</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// 发送消息到 TTL 队列</span></span><br><span class="line">channel.basicPublish(<span class="string">&quot;&quot;</span>, <span class="string">&quot;ttl_queue&quot;</span>, <span class="keyword">null</span>, <span class="string">&quot;Delayed Message&quot;</span>.getBytes());</span><br></pre></td></tr></table></figure>

<p><strong>优点：</strong></p>
<ul>
<li>配置灵活，可动态调整 TTL 和路由规则。</li>
<li>消息延迟精确到毫秒级别。</li>
<li>无需额外插件，依赖 RabbitMQ 内置功能即可实现。</li>
</ul>
<p><strong>缺点：</strong></p>
<ul>
<li>延迟时间是静态的，消息 TTL 是固定的。</li>
<li>消息堆积在 <code>delay_queue</code>，大量消息可能影响性能。</li>
<li>每种延时时间需要一个独立的 TTL 队列，可能导致队列数量膨胀。</li>
<li>延时的粒度是队列级别的，不支持对单个消息的精确控制。</li>
</ul>
</li>
<li><p>使用手动延迟的方案，即在应用层实现延迟逻辑，通过业务代码实现延迟队列逻辑，不依赖 RabbitMQ 的功能。</p>
<p><strong>实现步骤：</strong></p>
<ol>
<li><strong>延迟消息存储：</strong><ul>
<li>将消息存储到数据库或缓存（如 Redis）的延迟队列中。</li>
<li>消息的触发时间作为排序依据。</li>
</ul>
</li>
<li><strong>延迟任务触发：</strong><ul>
<li>定时扫描消息队列，判断消息是否达到触发时间。</li>
<li>如果达到触发时间，将消息投递到 RabbitMQ 的实际消费队列。</li>
</ul>
</li>
</ol>
<p><strong>代码示例：</strong></p>
<p>使用 Redis 的 <code>zset</code> 实现：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 存储延迟消息</span></span><br><span class="line">redisTemplate.opsForZSet().add(<span class="string">&quot;delay_queue&quot;</span>, message, System.currentTimeMillis() + delayTime);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 定时扫描任务</span></span><br><span class="line"><span class="meta">@Scheduled(fixedRate = 1000)</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">processDelayQueue</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">long</span> now = System.currentTimeMillis();</span><br><span class="line">    Set&lt;Object&gt; messages = redisTemplate.opsForZSet().rangeByScore(<span class="string">&quot;delay_queue&quot;</span>, <span class="number">0</span>, now);</span><br><span class="line">    <span class="keyword">for</span> (Object message : messages) &#123;</span><br><span class="line">        <span class="comment">// 发送到 RabbitMQ 实际队列</span></span><br><span class="line">        rabbitTemplate.convertAndSend(<span class="string">&quot;consume_queue&quot;</span>, message);</span><br><span class="line">        <span class="comment">// 删除已处理的消息</span></span><br><span class="line">        redisTemplate.opsForZSet().remove(<span class="string">&quot;delay_queue&quot;</span>, message);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>优点：</strong></p>
<ul>
<li>灵活性高，不依赖 RabbitMQ 的限制。</li>
<li>可以结合其他消息队列或存储技术。</li>
</ul>
<p><strong>缺点：</strong></p>
<ul>
<li>延时逻辑转移到应用层，可能影响系统复杂性。</li>
<li>延迟精度受限于扫描频率。</li>
<li>如果延时任务数量大，应用端性能可能受限。</li>
</ul>
</li>
<li><p><strong>对比与选择</strong></p>
</li>
</ol>
<table>
<thead>
<tr>
<th>方式</th>
<th>适用场景</th>
<th>优点</th>
<th>缺点</th>
</tr>
</thead>
<tbody><tr>
<td><strong>插件方案</strong></td>
<td>精确控制消息延时，生产延时任务较多</td>
<td>官方支持，易用，支持精确延时</td>
<td>需安装插件</td>
</tr>
<tr>
<td><strong>TTL + 死信队列</strong></td>
<td>延时需求简单，延时粒度较大</td>
<td>无需插件，灵活性高</td>
<td>每种延时需独立队列</td>
</tr>
<tr>
<td><strong>手动延迟</strong></td>
<td>简单延时逻辑，无需 RabbitMQ 处理</td>
<td>实现简单，灵活性高</td>
<td>延时逻辑转移到应用层，性能可能受限</td>
</tr>
</tbody></table>
<p><strong>推荐方案：</strong></p>
<ul>
<li><strong>插件方案</strong> 是首选，适合大部分延时需求。</li>
<li>在无法安装插件时，可采用 <strong>TTL + 死信队列</strong> 实现。</li>
</ul>
<h4 id="问：如何使用-RabbitMQ-实现异步任务处理？"><a href="#问：如何使用-RabbitMQ-实现异步任务处理？" class="headerlink" title="问：如何使用 RabbitMQ 实现异步任务处理？"></a>问：如何使用 RabbitMQ 实现异步任务处理？</h4><p>在 RabbitMQ 中实现异步任务处理是一种常见的应用场景，以下是详细步骤和实现方式：</p>
<ul>
<li><p>核心思路</p>
<ul>
<li><strong>任务生产者（Producer）</strong>：将任务消息发送到 RabbitMQ 队列。</li>
<li><strong>任务消费者（Consumer）</strong>：从 RabbitMQ 队列中取出消息并处理。</li>
<li>RabbitMQ 作为中间件，解耦生产者和消费者，提高系统的异步处理能力。</li>
</ul>
</li>
<li><p>实现步骤</p>
<ol>
<li><p>安装并配置 RabbitMQ：确保 RabbitMQ 已安装并运行，推荐使用 RabbitMQ 的管理插件监控任务处理过程。</p>
</li>
<li><p>创建队列：在 RabbitMQ 中为任务处理创建一个队列，例如 <code>task_queue</code>。</p>
</li>
<li><p>生产者（Producer）：生产者负责生成任务，并将任务信息以消息形式发送到 <code>task_queue</code>。</p>
</li>
</ol>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Autowired</span></span><br><span class="line"><span class="keyword">private</span> RabbitTemplate rabbitTemplate;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">sendTask</span><span class="params">(String task)</span> </span>&#123;</span><br><span class="line">    rabbitTemplate.convertAndSend(<span class="string">&quot;task_queue&quot;</span>, task);</span><br><span class="line">    System.out.println(<span class="string">&quot;Task sent: &quot;</span> + task);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ol start="4">
<li>消费者（Consumer）：消费者从 <code>task_queue</code> 队列中消费任务消息并执行具体任务逻辑。</li>
</ol>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@RabbitListener(queues = &quot;task_queue&quot;)</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">handleTask</span><span class="params">(String task)</span> </span>&#123;</span><br><span class="line">    System.out.println(<span class="string">&quot;Processing task: &quot;</span> + task);</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="comment">// 模拟任务处理</span></span><br><span class="line">        Thread.sleep(<span class="number">1000</span>);</span><br><span class="line">    &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">        Thread.currentThread().interrupt();</span><br><span class="line">    &#125;</span><br><span class="line">    System.out.println(<span class="string">&quot;Task completed: &quot;</span> + task);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ol start="5">
<li>配置 RabbitMQ 队列：使用 Spring Boot 或其他框架，可以通过注解或配置文件定义队列。</li>
</ol>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Bean</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> Queue <span class="title">taskQueue</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> Queue(<span class="string">&quot;task_queue&quot;</span>, <span class="keyword">true</span>); <span class="comment">// 队列持久化</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li><p>优化策略：</p>
<ol>
<li><strong>任务确认机制</strong><ul>
<li><strong>消息确认</strong>：确保消息被正确处理后才从队列中移除。</li>
<li>配置 <code>ack</code> 模式为手动确认。</li>
</ul>
</li>
</ol>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@RabbitListener(queues = &quot;task_queue&quot;, ackMode = &quot;MANUAL&quot;)</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">handleTask</span><span class="params">(String task, Channel channel, Message message)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;Processing task: &quot;</span> + task);</span><br><span class="line">        <span class="comment">// 模拟任务处理</span></span><br><span class="line">        Thread.sleep(<span class="number">1000</span>);</span><br><span class="line">        channel.basicAck(message.getMessageProperties().getDeliveryTag(), <span class="keyword">false</span>); <span class="comment">// 手动确认消息</span></span><br><span class="line">        System.out.println(<span class="string">&quot;Task completed: &quot;</span> + task);</span><br><span class="line">    &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">        channel.basicNack(message.getMessageProperties().getDeliveryTag(), <span class="keyword">false</span>, <span class="keyword">true</span>); <span class="comment">// 消息重新入队</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ol start="2">
<li><strong>消费者并发处理</strong>：通过设置消费者线程数提高处理能力。</li>
</ol>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@RabbitListener(queues = &quot;task_queue&quot;, concurrency = &quot;5-10&quot;)</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">handleTask</span><span class="params">(String task)</span> </span>&#123;</span><br><span class="line">    System.out.println(<span class="string">&quot;Processing task: &quot;</span> + task);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ol start="3">
<li><strong>消息持久化</strong></li>
</ol>
<p>确保队列和消息持久化，防止 RabbitMQ 服务重启时消息丢失。</p>
<p><strong>代码配置：</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Bean</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> Queue <span class="title">taskQueue</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> QueueBuilder.durable(<span class="string">&quot;task_queue&quot;</span>).build();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ol start="4">
<li><strong>负载均衡</strong></li>
</ol>
<p>通过多个消费者实例处理任务，RabbitMQ 自动负载均衡任务消息。</p>
<ol start="5">
<li><strong>预取机制</strong></li>
</ol>
<p>配置 <code>prefetch</code> 数量，限制每个消费者一次获取的未确认消息数量，防止单个消费者因任务过多而阻塞。</p>
<p><strong>配置示例：</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Bean</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> SimpleRabbitListenerContainerFactory <span class="title">rabbitListenerContainerFactory</span><span class="params">(ConnectionFactory connectionFactory)</span> </span>&#123;</span><br><span class="line">    SimpleRabbitListenerContainerFactory factory = <span class="keyword">new</span> SimpleRabbitListenerContainerFactory();</span><br><span class="line">    factory.setConnectionFactory(connectionFactory);</span><br><span class="line">    factory.setPrefetchCount(<span class="number">10</span>); <span class="comment">// 每次预取 10 条消息</span></span><br><span class="line">    <span class="keyword">return</span> factory;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li><p>异步任务处理的优势</p>
<ol>
<li><strong>解耦</strong>：生产者和消费者逻辑完全独立。</li>
<li><strong>异步处理</strong>：提高系统响应速度。</li>
<li><strong>可扩展性</strong>：通过增加消费者实例横向扩展处理能力。</li>
<li><strong>高可靠性</strong>：通过消息确认和持久化机制，保证消息不会丢失。</li>
</ol>
</li>
<li><p>典型应用场景</p>
<ol>
<li><strong>邮件发送</strong>：接收到请求后异步发送邮件，提升系统响应速度。</li>
<li><strong>日志处理</strong>：将日志数据异步存储到数据库或发送到监控系统。</li>
<li><strong>任务调度</strong>：分布式任务系统中的任务分发和执行。</li>
<li><strong>流量削峰</strong>：将高峰时的请求任务排队，逐步处理。</li>
</ol>
</li>
</ul>
<h4 id="问：RabbitMQ-如何与其他系统（如-Redis、Kafka）集成？"><a href="#问：RabbitMQ-如何与其他系统（如-Redis、Kafka）集成？" class="headerlink" title="问：RabbitMQ 如何与其他系统（如 Redis、Kafka）集成？"></a>问：RabbitMQ 如何与其他系统（如 Redis、Kafka）集成？</h4><ol>
<li><p>RabbitMQ 与 Redis 的集成</p>
<ul>
<li><p>典型应用场景</p>
<ul>
<li><p>缓存与消息队列结合：</p>
<ul>
<li>Redis 提供高速缓存功能，RabbitMQ 用于可靠的消息传递。</li>
<li>例如，将计算结果缓存到 Redis，使用 RabbitMQ 在服务之间传递任务。</li>
</ul>
</li>
<li><p>延时任务：</p>
<ul>
<li>使用 Redis 的 <code>Sorted Set</code> 存储延时消息，RabbitMQ 负责任务分发。</li>
</ul>
</li>
<li><p>限流与计数：</p>
<ul>
<li>Redis 可以实现分布式限流，RabbitMQ 用于分布式任务排队和消费。</li>
</ul>
</li>
</ul>
</li>
<li><p>集成方法</p>
<ul>
<li><p><strong>方式一：Redis 作为 RabbitMQ 的缓存层</strong></p>
<ul>
<li>生产者发送消息到 RabbitMQ 的同时，将消息状态存储到 Redis。</li>
<li>消费者从 RabbitMQ 消费消息后更新 Redis 中的状态。</li>
</ul>
<p><strong>实现示例</strong>：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 生产者发送消息到 RabbitMQ 并缓存</span></span><br><span class="line">rabbitTemplate.convertAndSend(<span class="string">&quot;task_queue&quot;</span>, task);</span><br><span class="line">redisTemplate.opsForValue().set(taskId, <span class="string">&quot;PENDING&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 消费者消费消息后更新缓存</span></span><br><span class="line"><span class="meta">@RabbitListener(queues = &quot;task_queue&quot;)</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">handleTask</span><span class="params">(String task)</span> </span>&#123;</span><br><span class="line">    processTask(task);</span><br><span class="line">    redisTemplate.opsForValue().set(taskId, <span class="string">&quot;COMPLETED&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li><p><strong>方式二：Redis 实现延时队列，RabbitMQ 消费任务</strong></p>
<ul>
<li>Redis 存储任务及其到期时间，定时扫描 Redis，将到期任务发送到 RabbitMQ。</li>
<li>RabbitMQ 负责分发和执行任务。</li>
</ul>
<p><strong>实现示例</strong>：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Redis 中插入延时任务</span></span><br><span class="line">redisTemplate.opsForZSet().add(<span class="string">&quot;delay_tasks&quot;</span>, task, System.currentTimeMillis() + delayTime);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 定时扫描任务并发送到 RabbitMQ</span></span><br><span class="line">Set&lt;Object&gt; tasks = redisTemplate.opsForZSet().rangeByScore(<span class="string">&quot;delay_tasks&quot;</span>, <span class="number">0</span>, System.currentTimeMillis());</span><br><span class="line"><span class="keyword">for</span> (Object task : tasks) &#123;</span><br><span class="line">    rabbitTemplate.convertAndSend(<span class="string">&quot;task_queue&quot;</span>, task);</span><br><span class="line">    redisTemplate.opsForZSet().remove(<span class="string">&quot;delay_tasks&quot;</span>, task);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
</li>
</ul>
</li>
<li><p>RabbitMQ 与 Kafka 的集成 </p>
<ul>
<li><p>典型应用场景</p>
<ul>
<li><p>高吞吐量与可靠性结合：</p>
<ul>
<li>Kafka 用于高吞吐量的数据采集和存储，RabbitMQ 用于实时处理和任务分发。</li>
</ul>
</li>
<li><p>数据流处理：</p>
<ul>
<li>Kafka 中的数据流可以通过 RabbitMQ 分发给多个不同的服务，完成复杂的业务逻辑。</li>
</ul>
</li>
<li><p>互补消息模型：</p>
<ul>
<li>Kafka 适用于事件流处理，RabbitMQ 适用于任务分发。</li>
</ul>
</li>
</ul>
</li>
<li><p>集成方法</p>
<ul>
<li><p><strong>方式一：Kafka 作为上游消息源，RabbitMQ 负责任务分发</strong></p>
<ul>
<li>使用 Kafka 消费者订阅 Kafka 主题，将消息转发到 RabbitMQ。</li>
</ul>
<p><strong>实现示例</strong>：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@KafkaListener(topics = &quot;kafka_topic&quot;, groupId = &quot;group_id&quot;)</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">handleKafkaMessage</span><span class="params">(String message)</span> </span>&#123;</span><br><span class="line">    rabbitTemplate.convertAndSend(<span class="string">&quot;task_queue&quot;</span>, message);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li><p><strong>方式二：RabbitMQ 作为上游，Kafka 实现数据存储和分发</strong></p>
<ul>
<li>RabbitMQ 消费者处理消息后，将结果发送到 Kafka 进行存储或下游分发。</li>
</ul>
<p><strong>实现示例</strong>：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@RabbitListener(queues = &quot;task_queue&quot;)</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">handleRabbitMessage</span><span class="params">(String message)</span> </span>&#123;</span><br><span class="line">    kafkaTemplate.send(<span class="string">&quot;kafka_topic&quot;</span>, message);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li><p><strong>方式三：Kafka 和 RabbitMQ 作为两端通信桥</strong></p>
<ul>
<li>Kafka 和 RabbitMQ 中间通过桥接器（如 Apache Camel）实现双向数据同步。</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li><p>综合设计与优化</p>
<ul>
<li><p>优势互补</p>
<ul>
<li><p>RabbitMQ：</p>
<ul>
<li>适用于可靠性要求高的任务调度和分发。</li>
<li>提供灵活的路由机制。</li>
</ul>
</li>
<li><p>Redis：</p>
<ul>
<li>适用于延时任务、缓存、计数等高速读写场景。</li>
</ul>
</li>
<li><p>Kafka：</p>
<ul>
<li>适用于高吞吐量、日志采集、事件流处理场景。</li>
</ul>
</li>
</ul>
</li>
<li><p>技术选择建议</p>
<ul>
<li>如果业务逻辑以任务调度为主，可以使用 RabbitMQ 配合 Redis 实现分布式延时队列。</li>
<li>如果需要高吞吐量的日志或事件流处理，可选择 Kafka 并结合 RabbitMQ 提供实时任务分发能力。</li>
<li>在分布式系统中，可以将 Redis 用于缓存和计数，RabbitMQ 用于实时任务处理，Kafka 用于批量数据处理和分析。</li>
</ul>
</li>
<li><p>监控与容错</p>
<ul>
<li>使用监控工具（如 Prometheus + Grafana）监控 RabbitMQ、Redis 和 Kafka 的状态。</li>
<li>设置重试机制和死信队列处理异常消息。</li>
<li>针对 Redis 或 RabbitMQ 的高可用性需求，配置主从架构或集群模式。</li>
</ul>
</li>
</ul>
</li>
</ol>
<h4 id="问：如何在-RabbitMQ-中进行消息重试？"><a href="#问：如何在-RabbitMQ-中进行消息重试？" class="headerlink" title="问：如何在 RabbitMQ 中进行消息重试？"></a>问：如何在 RabbitMQ 中进行消息重试？</h4><ol>
<li><p><strong>手动消息确认与重新发布</strong></p>
<ul>
<li><strong>原理</strong>：消费者在处理消息时，如果发生异常或处理失败，可以拒绝消息（<code>basicNack</code> 或 <code>basicReject</code>），然后重新将消息发布到队列，进行重试。</li>
<li><strong>实现步骤</strong>：<ul>
<li>消费者启用手动消息确认模式。</li>
<li>在处理失败时，通过 <code>basicNack</code> 或 <code>basicReject</code> 拒绝消息。</li>
<li>重新发布消息到队列。</li>
</ul>
</li>
<li><strong>示例代码</strong>：</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">channel.basicConsume(queueName, <span class="keyword">false</span>, (consumerTag, delivery) -&gt; &#123;</span><br><span class="line">    String message = <span class="keyword">new</span> String(delivery.getBody(), <span class="string">&quot;UTF-8&quot;</span>);</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="comment">// 处理消息</span></span><br><span class="line">        processMessage(message);</span><br><span class="line">        channel.basicAck(delivery.getEnvelope().getDeliveryTag(), <span class="keyword">false</span>);</span><br><span class="line">    &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">        <span class="comment">// 处理失败，拒绝消息并重新发布</span></span><br><span class="line">        channel.basicNack(delivery.getEnvelope().getDeliveryTag(), <span class="keyword">false</span>, <span class="keyword">false</span>);</span><br><span class="line">        <span class="comment">// 可选：重新发布消息到队列</span></span><br><span class="line">        channel.basicPublish(<span class="string">&quot;&quot;</span>, queueName, <span class="keyword">null</span>, delivery.getBody());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;, consumerTag -&gt; &#123; &#125;);</span><br></pre></td></tr></table></figure>

<ul>
<li>优缺点<ul>
<li>优点：简单易用，完全由消费者控制重试逻辑。</li>
<li>缺点：可能造成队列中重复消息增多。</li>
</ul>
</li>
</ul>
</li>
<li><p><strong>死信队列（DLQ）结合延迟队列实现重试</strong></p>
<ol>
<li><strong>原理</strong>：使用死信队列（DLQ）和延迟队列机制，当消息消费失败时，将其路由到死信队列，经过一定延迟后重新路由到原队列进行重试。</li>
<li><strong>实现步骤</strong>：<ul>
<li>配置死信队列，并绑定到原队列。</li>
<li>配置 TTL（消息的存活时间）和 <code>x-dead-letter-exchange</code> 属性。</li>
<li>消息处理失败后，进入死信队列，延迟一定时间后重新进入原队列。</li>
</ul>
</li>
<li><strong>队列声明示例（Java）</strong>：</li>
</ol>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">Map&lt;String, Object&gt; args = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line">args.put(<span class="string">&quot;x-dead-letter-exchange&quot;</span>, <span class="string">&quot;retry-exchange&quot;</span>); <span class="comment">// 死信路由到的交换机</span></span><br><span class="line">args.put(<span class="string">&quot;x-message-ttl&quot;</span>, <span class="number">10000</span>); <span class="comment">// 消息延迟时间（10秒）</span></span><br><span class="line"></span><br><span class="line">channel.queueDeclare(<span class="string">&quot;retry-queue&quot;</span>, <span class="keyword">true</span>, <span class="keyword">false</span>, <span class="keyword">false</span>, args);</span><br><span class="line">channel.queueBind(<span class="string">&quot;retry-queue&quot;</span>, <span class="string">&quot;retry-exchange&quot;</span>, <span class="string">&quot;retry-routing-key&quot;</span>);</span><br></pre></td></tr></table></figure>

<ul>
<li>优缺点<ul>
<li>优点：消息重试次数和间隔可以灵活配置。</li>
<li>缺点：实现较为复杂，对配置要求高。</li>
</ul>
</li>
</ul>
</li>
<li><p>延迟插件实现重试</p>
<ol>
<li><strong>原理</strong>：RabbitMQ 的延迟插件（RabbitMQ Delayed Message Plugin）允许直接在消息中设置延迟时间，从而实现消息的定时重试。</li>
<li><strong>实现步骤</strong>：<ul>
<li>安装 RabbitMQ Delayed Message Plugin。</li>
<li>声明支持延迟的交换机（<code>x-delayed-message</code> 类型）。</li>
<li>消息消费失败时，重新发布消息到延迟交换机，设置延迟时间。</li>
</ul>
</li>
<li><strong>交换机声明示例（Java）</strong>：</li>
</ol>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Map&lt;String, Object&gt; args = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line">args.put(<span class="string">&quot;x-delayed-type&quot;</span>, <span class="string">&quot;direct&quot;</span>);</span><br><span class="line">channel.exchangeDeclare(<span class="string">&quot;delayed-exchange&quot;</span>, <span class="string">&quot;x-delayed-message&quot;</span>, <span class="keyword">true</span>, <span class="keyword">false</span>, args);</span><br></pre></td></tr></table></figure>

<p><strong>发送延迟消息示例</strong>：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">AMQP.BasicProperties.Builder props = <span class="keyword">new</span> AMQP.BasicProperties.Builder();</span><br><span class="line">props.headers(Map.of(<span class="string">&quot;x-delay&quot;</span>, <span class="number">5000</span>)); <span class="comment">// 延迟 5 秒</span></span><br><span class="line"></span><br><span class="line">channel.basicPublish(<span class="string">&quot;delayed-exchange&quot;</span>, <span class="string">&quot;routing-key&quot;</span>, props.build(), message.getBytes());</span><br></pre></td></tr></table></figure>

<ul>
<li>优缺点：<ul>
<li>优点：实现简单，延迟时间可动态调整。</li>
<li>缺点：需要安装和配置插件，适用性受限。</li>
</ul>
</li>
</ul>
</li>
<li><p><strong>消息重试次数控制</strong>：在实际业务中，需要限制消息的最大重试次数，避免消息陷入无限重试的循环。可以通过以下方式实现：</p>
<ul>
<li><strong>利用消息头记录重试次数</strong>：<ul>
<li>在重新发布消息时，增加或更新消息头中的重试计数。</li>
<li>如果达到最大重试次数，将消息路由到死信队列或记录到日志。</li>
</ul>
</li>
<li><strong>示例代码</strong>：</li>
</ul>
</li>
</ol>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">Map&lt;String, Object&gt; headers = delivery.getProperties().getHeaders();</span><br><span class="line"><span class="keyword">int</span> retryCount = headers != <span class="keyword">null</span> &amp;&amp; headers.containsKey(<span class="string">&quot;x-retry-count&quot;</span>)</span><br><span class="line">    ? (<span class="keyword">int</span>) headers.get(<span class="string">&quot;x-retry-count&quot;</span>)</span><br><span class="line">    : <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (retryCount &gt;= MAX_RETRY_COUNT) &#123;</span><br><span class="line">    <span class="comment">// 达到最大重试次数，路由到死信队列</span></span><br><span class="line">    channel.basicPublish(<span class="string">&quot;dlx-exchange&quot;</span>, <span class="string">&quot;dlx-routing-key&quot;</span>, <span class="keyword">null</span>, delivery.getBody());</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="comment">// 增加重试次数并重新发布消息</span></span><br><span class="line">    Map&lt;String, Object&gt; newHeaders = <span class="keyword">new</span> HashMap&lt;&gt;(headers != <span class="keyword">null</span> ? headers : <span class="keyword">new</span> HashMap&lt;&gt;());</span><br><span class="line">    newHeaders.put(<span class="string">&quot;x-retry-count&quot;</span>, retryCount + <span class="number">1</span>);</span><br><span class="line">    AMQP.BasicProperties newProps = <span class="keyword">new</span> AMQP.BasicProperties.Builder()</span><br><span class="line">        .headers(newHeaders)</span><br><span class="line">        .build();</span><br><span class="line"></span><br><span class="line">    channel.basicPublish(<span class="string">&quot;&quot;</span>, <span class="string">&quot;retry-queue&quot;</span>, newProps, delivery.getBody());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>总结</p>
<ul>
<li><strong>手动消息确认</strong>：适合简单场景，但需注意可能的重复消息。</li>
<li><strong>死信队列结合延迟队列</strong>：灵活且高效，推荐用于复杂重试需求。</li>
<li><strong>延迟插件</strong>：实现简单，但需额外安装插件。</li>
<li><strong>重试次数控制</strong>：无论哪种方案，都建议结合重试次数控制，避免无限循环。</li>
</ul>
<h4 id="问：如何防止-RabbitMQ-中的消息重复消费？"><a href="#问：如何防止-RabbitMQ-中的消息重复消费？" class="headerlink" title="问：如何防止 RabbitMQ 中的消息重复消费？"></a>问：如何防止 RabbitMQ 中的消息重复消费？</h4><p>🎯 <strong>一、为什么会发生消息重复消费？</strong></p>
<ol>
<li>消息在生产时重复发送（生产者重试机制）。</li>
<li>网络抖动或超时：<ul>
<li>消费者已经成功处理消息，但 RabbitMQ <strong>未收到 ACK</strong>，因此重新投递消息。</li>
</ul>
</li>
<li>消费者处理失败或崩溃：<ul>
<li>消费者在处理消息时发生异常，未返回 ACK，RabbitMQ 认为消息未被消费，重新投递。</li>
</ul>
</li>
<li>手动 ACK 丢失：<ul>
<li>消费者忘记发送 <strong>ACK</strong>，导致 RabbitMQ 认为消息未被处理而重复发送。</li>
</ul>
</li>
<li>RabbitMQ 重启或 Broker 异常：<ul>
<li>RabbitMQ 节点故障，未处理完的消息会重新入队，等待消费者消费。</li>
<li><strong>集群故障转移</strong>：镜像队列切换时可能触发消息重新投递。</li>
</ul>
</li>
<li>消息并发消费：<ul>
<li>多个消费者同时监听同一个队列，可能会出现同一消息被多个消费者同时获取并处理的情况。</li>
</ul>
</li>
</ol>
<p>✅ <strong>二、如何防止消息重复消费？</strong></p>
<p>1️⃣ <strong>设置手动 ACK，确保正确确认消息</strong></p>
<p>默认情况下，RabbitMQ 使用 <strong>自动 ACK</strong>（<code>autoAck=true</code>），消费者一旦接收消息，RabbitMQ 就认为已消费，即使消费者处理失败也不会重试。</p>
<p>👉 <strong>解决方案</strong>：使用手动确认模式（<code>autoAck=false</code>），并在消息成功处理后手动发送 <code>basicAck()</code>。</p>
<p>📋 <strong>示例代码（手动 ACK）</strong></p>
<figure class="highlight reasonml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line">import com.rabbitmq.client.*;</span><br><span class="line"></span><br><span class="line">public <span class="keyword">class</span> ManualAckConsumer &#123;</span><br><span class="line">    <span class="keyword">private</span> static final String QUEUE_NAME = <span class="string">&quot;task_queue&quot;</span>;</span><br><span class="line"></span><br><span class="line">    public static void main(String<span class="literal">[]</span> args) throws Exception &#123;</span><br><span class="line">        ConnectionFactory factory = <span class="keyword">new</span> <span class="constructor">ConnectionFactory()</span>;</span><br><span class="line">        factory.set<span class="constructor">Host(<span class="string">&quot;localhost&quot;</span>)</span>;</span><br><span class="line">        <span class="keyword">try</span> (Connection connection = factory.<span class="keyword">new</span><span class="constructor">Connection()</span>;</span><br><span class="line">             Channel channel = connection.create<span class="constructor">Channel()</span>) &#123;</span><br><span class="line">            channel.queue<span class="constructor">Declare(QUEUE_NAME, <span class="params">true</span>, <span class="params">false</span>, <span class="params">false</span>, <span class="params">null</span>)</span>;</span><br><span class="line">            <span class="module-access"><span class="module"><span class="identifier">System</span>.</span></span>out.println(<span class="string">&quot;Waiting for messages...&quot;</span>);</span><br><span class="line"></span><br><span class="line">            DeliverCallback deliverCallback = (consumerTag, delivery) -&gt; &#123;</span><br><span class="line">                String message = <span class="keyword">new</span> <span class="constructor">String(<span class="params">delivery</span>.<span class="params">getBody</span>()</span>, <span class="string">&quot;UTF-8&quot;</span>);</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    <span class="module-access"><span class="module"><span class="identifier">System</span>.</span></span>out.println(<span class="string">&quot;Processing: &quot;</span> + message);</span><br><span class="line">                    <span class="comment">// 处理消息逻辑</span></span><br><span class="line">                    channel.basic<span class="constructor">Ack(<span class="params">delivery</span>.<span class="params">getEnvelope</span>()</span>.get<span class="constructor">DeliveryTag()</span>, <span class="literal">false</span>); <span class="comment">// 发送ACK</span></span><br><span class="line">                &#125; catch (Exception e) &#123;</span><br><span class="line">                    e.print<span class="constructor">StackTrace()</span>;</span><br><span class="line">                    channel.basic<span class="constructor">Nack(<span class="params">delivery</span>.<span class="params">getEnvelope</span>()</span>.get<span class="constructor">DeliveryTag()</span>, <span class="literal">false</span>, <span class="literal">true</span>); <span class="comment">// 重新入队</span></span><br><span class="line">                &#125;</span><br><span class="line">            &#125;;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// autoAck=false，启用手动确认</span></span><br><span class="line">            channel.basic<span class="constructor">Consume(QUEUE_NAME, <span class="params">false</span>, <span class="params">deliverCallback</span>, <span class="params">consumerTag</span> -&gt; &#123;&#125;)</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p><strong>注意</strong>：</p>
<ul>
<li><code>basicAck()</code>：确认消息已处理，RabbitMQ 删除该消息。</li>
<li><code>basicNack()</code>：拒绝消息，可选择是否重新入队（<code>requeue=true</code> 重新入队）。</li>
</ul>
</blockquote>
<p>2️⃣ <strong>使用消息幂等性，确保多次消费结果一致</strong></p>
<p>无论 RabbitMQ 是否重复投递，消费者都能确保消息的<strong>多次处理不会引起副作用</strong>，实现<strong>幂等性</strong>。</p>
<p>👉 <strong>解决方案</strong>：</p>
<ol>
<li><strong>为每个消息生成唯一 ID</strong>，如使用 <strong>消息 ID（<code>messageId</code>）</strong>。</li>
<li><strong>存储已处理的消息 ID</strong>，处理前先检查是否已消费。</li>
</ol>
<p>📋 <strong>示例代码（幂等性处理）</strong></p>
<figure class="highlight arduino"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">javaCopyEditimport java.util.Set;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.ConcurrentHashMap;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">IdempotentService</span> &#123;</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> Set&lt;<span class="keyword">String</span>&gt; processedMessages = ConcurrentHashMap.<span class="built_in">newKeySet</span>();</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">boolean</span> <span class="title">isProcessed</span><span class="params">(<span class="keyword">String</span> messageId)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> !processedMessages.<span class="built_in">add</span>(messageId);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">processMessage</span><span class="params">(<span class="keyword">String</span> messageId, <span class="keyword">String</span> message)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">isProcessed</span>(messageId)) &#123;</span><br><span class="line">            System.out.<span class="built_in">println</span>(<span class="string">&quot;Duplicate message, ignoring: &quot;</span> + messageId);</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 处理业务逻辑</span></span><br><span class="line">        System.out.<span class="built_in">println</span>(<span class="string">&quot;Processing message: &quot;</span> + message);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p><strong>最佳实践</strong>：</p>
<ul>
<li>消息 ID 可以使用 <strong>UUID</strong>、数据库主键或 **RabbitMQ 自带的 <code>MessageProperties.getMessageId()</code>**。</li>
<li>消息记录持久化到 <strong>Redis、MySQL</strong>，防止内存不足导致记录丢失。</li>
</ul>
</blockquote>
<p>3️⃣ <strong>合理设置 QoS（<code>basicQos</code>），避免消息并发混乱</strong></p>
<p>RabbitMQ 默认会将消息尽可能多地推送给消费者，可能导致单个消费者处理不过来，重复消费。</p>
<p>👉 <strong>解决方案</strong>：使用 <code>basicQos</code> 设置<strong>每次推送的消息数量（预取值）</strong>，确保每个消费者只接收能处理的消息。</p>
<p>📋 <strong>示例代码（设置 QoS 限制推送）</strong></p>
<figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="attribute">channel</span>.basicQos(<span class="number">1</span>); // 每次仅分发 <span class="number">1</span> 条消息，处理完才接收下一条</span><br></pre></td></tr></table></figure>

<blockquote>
<p><strong>注意</strong>：</p>
<ul>
<li>小值（如 1-10）适用于<strong>大任务、慢操作</strong>，避免超负荷。</li>
<li>大值适用于<strong>高吞吐量</strong>场景，减少网络往返。</li>
</ul>
</blockquote>
<p>4️⃣ <strong>使用事务或消息确认机制，确保数据一致性</strong></p>
<p>RabbitMQ 支持两种可靠投递方式，防止消息丢失或重复：</p>
<ul>
<li><strong>事务模式</strong>（<code>txSelect()</code> + <code>txCommit()</code>）：保证消息的原子性，但性能较低。</li>
<li><strong>Confirm 模式</strong>（<code>channel.confirmSelect()</code>）：异步确认消息投递成功，性能更好。</li>
</ul>
<p>👉 <strong>解决方案</strong>：推荐使用 <strong>Confirm 模式</strong>，在消息发布时确保消息成功到达队列。</p>
<p>📋 <strong>示例代码（Confirm 模式）</strong></p>
<figure class="highlight reasonml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">javaCopyEditchannel.confirm<span class="constructor">Select()</span>; <span class="comment">// 开启Confirm模式</span></span><br><span class="line">channel.basic<span class="constructor">Publish(<span class="params">exchange</span>, <span class="params">routingKey</span>, <span class="params">null</span>, <span class="params">message</span>.<span class="params">getBytes</span>(StandardCharsets.UTF_8)</span>);</span><br><span class="line"><span class="keyword">if</span> (!channel.wait<span class="constructor">ForConfirms()</span>) &#123;</span><br><span class="line">    <span class="module-access"><span class="module"><span class="identifier">System</span>.</span></span>err.println(<span class="string">&quot;Message delivery failed!&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>5️⃣ <strong>使用唯一标识和防重表</strong></p>
<p>将消息的唯一标识（如订单号、消息 ID）写入<strong>防重表</strong>（如 Redis 或 MySQL 中），消费前检查是否已处理过。</p>
<p>👉 <strong>示例：Redis 防重实现</strong></p>
<figure class="highlight processing"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">javaCopyEditpublic <span class="built_in">boolean</span> isDuplicate(<span class="keyword">String</span> messageId) &#123;</span><br><span class="line">    <span class="keyword">String</span> <span class="built_in">key</span> = <span class="string">&quot;message:&quot;</span> + messageId;</span><br><span class="line">    <span class="keyword">return</span> redisTemplate.opsForValue().setIfAbsent(<span class="built_in">key</span>, <span class="string">&quot;1&quot;</span>, <span class="number">1</span>, TimeUnit.HOURS) == <span class="keyword">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>📊 <strong>总结：防止 RabbitMQ 消息重复消费的最佳实践</strong></p>
<table>
<thead>
<tr>
<th>方法</th>
<th>方案描述</th>
<th>适用场景</th>
</tr>
</thead>
<tbody><tr>
<td>✅ 手动 ACK</td>
<td>消费成功后手动确认，失败拒绝重入队列</td>
<td>处理耗时任务，避免丢失消息</td>
</tr>
<tr>
<td>✅ 消息幂等性</td>
<td>使用唯一 ID 确保重复消费不影响业务</td>
<td>订单、支付等关键操作</td>
</tr>
<tr>
<td>✅ QoS 限流</td>
<td>使用 <code>basicQos</code> 控制每次推送的数量</td>
<td>大批量任务，防止超载</td>
</tr>
<tr>
<td>✅ Confirm 模式</td>
<td>发布消息时开启确认，确保成功投递</td>
<td>保证消息投递的可靠性</td>
</tr>
<tr>
<td>✅ 防重表</td>
<td>使用 Redis/MySQL 记录已消费的消息 ID</td>
<td>关键业务，防止重复扣费、下单</td>
</tr>
</tbody></table>
<hr>
<p><strong>🎤 面试高分回答示例</strong>：</p>
<blockquote>
<p>RabbitMQ 中消息可能因网络抖动、ACK 丢失等原因导致重复消费。为防止这一问题，我们通常采用以下措施：</p>
<ol>
<li><strong>手动 ACK</strong>：成功处理后发送 <code>basicAck()</code>，失败时使用 <code>basicNack()</code> 重新入队。</li>
<li><strong>幂等性设计</strong>：对消息设置唯一 ID，已处理的消息不再重复执行。</li>
<li><strong>QoS 控制</strong>：使用 <code>basicQos()</code> 限制未确认消息数，防止消息大量并发。</li>
<li><strong>Confirm 模式</strong>：保证消息可靠投递，避免重复发送。</li>
<li><strong>防重表</strong>：使用 Redis/MySQL 记录已处理的消息，确保业务幂等性。<br>这些措施结合使用，能有效防止 RabbitMQ 消息的重复消费问题。</li>
</ol>
</blockquote>
<p><strong>1. 幂等性的意义</strong></p>
<p>幂等性是指一个操作可以重复执行多次，而不会影响结果的一致性。在分布式系统中，重复消费可能导致数据重复写入或更新，从而引发数据不一致问题。</p>
<p><strong>2. 幂等性实现方式</strong></p>
<ol>
<li><p><strong>全局唯一消息 ID</strong>：</p>
<ul>
<li>在消息中包含一个全局唯一的 <code>message_id</code>（例如 UUID）。</li>
<li>在消费者处理消息时，将 <code>message_id</code> 存入数据库或缓存。</li>
<li>如果 <code>message_id</code> 已存在，说明该消息已被处理，直接跳过。</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (cache.contains(message_id)) &#123;</span><br><span class="line">    <span class="keyword">return</span>; <span class="comment">// 消息已处理，跳过</span></span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    processMessage(message); <span class="comment">// 处理消息</span></span><br><span class="line">    cache.put(message_id, <span class="keyword">true</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li><p><strong>基于数据库的去重</strong>：</p>
<ul>
<li><p>消息消费逻辑依赖数据库的主键约束或唯一索引，防止重复写入。</p>
</li>
<li><p>示例：</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> orders (id, product_id, user_id) </span><br><span class="line"><span class="keyword">VALUES</span> (?, ?, ?) </span><br><span class="line"><span class="keyword">ON</span> DUPLICATE KEY UPDATE update_time <span class="operator">=</span> NOW();</span><br></pre></td></tr></table></figure></li>
</ul>
</li>
<li><p><strong>分布式锁</strong>：</p>
<ul>
<li>利用 Redis 或 Zookeeper 实现分布式锁，确保同一条消息在多线程或多实例场景下只被处理一次。</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">String lockKey = <span class="string">&quot;lock:&quot;</span> + message_id;</span><br><span class="line"><span class="keyword">if</span> (redis.setnx(lockKey, <span class="string">&quot;locked&quot;</span>)) &#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        processMessage(message);</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        redis.del(lockKey);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li><p><strong>状态标记</strong>：</p>
<ul>
<li>为每条消息维护一个处理状态（如 <code>pending</code>, <code>processed</code>）。</li>
<li>消费者在处理消息时检查状态，避免重复处理。</li>
</ul>
</li>
<li><p><strong>使用幂等操作</strong>：</p>
<ul>
<li>在业务逻辑中，尽量使用幂等操作。例如：<ul>
<li><strong>增量更新</strong>（避免覆盖写入）。</li>
<li><strong>根据条件更新</strong>（<code>UPDATE ... WHERE</code>）。</li>
</ul>
</li>
</ul>
</li>
</ol>
<h2 id="第一节-待整理"><a href="#第一节-待整理" class="headerlink" title="第一节 待整理"></a>第一节 待整理</h2><h4 id="问：RocketMQ的特点有哪些？"><a href="#问：RocketMQ的特点有哪些？" class="headerlink" title="问：RocketMQ的特点有哪些？"></a>问：RocketMQ的特点有哪些？</h4><h4 id="问：RocketMQ-由哪些角色组成？"><a href="#问：RocketMQ-由哪些角色组成？" class="headerlink" title="问：RocketMQ 由哪些角色组成？"></a>问：RocketMQ 由哪些角色组成？</h4><h4 id="问：rocketmq-的模块功能？"><a href="#问：rocketmq-的模块功能？" class="headerlink" title="问：rocketmq 的模块功能？"></a><strong>问：rocketmq 的模块功能？</strong></h4><h4 id="问：rocketmq-的高可用及高性能？"><a href="#问：rocketmq-的高可用及高性能？" class="headerlink" title="问：rocketmq 的高可用及高性能？"></a><strong>问：rocketmq 的高可用及高性能？</strong></h4><h4 id="问：消费者获取消息有几种模式？"><a href="#问：消费者获取消息有几种模式？" class="headerlink" title="问：消费者获取消息有几种模式？"></a><strong>问：消费者获取消息有几种模式？</strong></h4><h4 id="问：说说你对Consumer的了解？"><a href="#问：说说你对Consumer的了解？" class="headerlink" title="问：说说你对Consumer的了解？"></a><strong>问：说说你对Consumer的了解？</strong></h4><h4 id="问：介绍下Kafka？Kafka的优点？Kafka-的设计是什么样的呢？"><a href="#问：介绍下Kafka？Kafka的优点？Kafka-的设计是什么样的呢？" class="headerlink" title="问：介绍下Kafka？Kafka的优点？Kafka 的设计是什么样的呢？"></a><strong>问：介绍下Kafka？Kafka的优点？Kafka 的设计是什么样的呢？</strong></h4><h4 id="问：什么是分布式日志架构？ELK"><a href="#问：什么是分布式日志架构？ELK" class="headerlink" title="问：什么是分布式日志架构？ELK"></a>问：什么是分布式日志架构？ELK</h4><p><strong>分布式日志架构</strong>是一种专门设计用来采集、存储、处理和分析分布式系统中日志数据的架构。它解决了分布式系统中多节点日志分散、难以统一管理和高效查询的问题，广泛应用于系统监控、故障排查和性能分析。</p>
<p>以下是分布式日志架构的详细介绍：</p>
<p><strong>核心目标</strong></p>
<ol>
<li><strong>统一收集</strong><br> 集中采集分布式系统中各节点产生的日志，解决日志分散问题。</li>
<li><strong>高效存储</strong><br> 设计高效的存储方案以支持日志的快速写入和查询。</li>
<li><strong>实时分析</strong><br> 提供日志的实时分析能力，快速定位问题。</li>
<li><strong>扩展性</strong><br> 支持海量日志数据的存储和处理，能够灵活扩展。</li>
</ol>
<p><strong>典型架构</strong></p>
<p>分布式日志系统的架构一般包括以下几个模块：</p>
<p><strong>1. 日志采集层</strong></p>
<ul>
<li><p><strong>作用</strong>：从各个分布式节点采集日志。</p>
</li>
<li><p>常用工具</p>
<p>：</p>
<ul>
<li><strong>Filebeat</strong>：轻量级日志采集器，常用于采集文件日志。</li>
<li><strong>Logstash</strong>：功能强大的日志处理工具，支持多种数据源。</li>
<li><strong>Fluentd</strong>：灵活的日志采集和传输工具。</li>
</ul>
</li>
</ul>
<p><strong>2. 日志传输层</strong></p>
<ul>
<li><p><strong>作用</strong>：将采集到的日志高效、可靠地传输到存储层。</p>
</li>
<li><p>技术选型</p>
<p>：</p>
<ul>
<li><strong>Kafka</strong>：分布式消息队列，适合高吞吐量日志传输。</li>
<li><strong>RabbitMQ</strong>：适合需要消息可靠性的场景。</li>
<li><strong>Pulsar</strong>：支持多租户，适用于复杂分布式环境。</li>
</ul>
</li>
</ul>
<p><strong>3. 日志存储层</strong></p>
<ul>
<li><p><strong>作用</strong>：对日志进行持久化存储，支持高效查询。</p>
</li>
<li><p>常用工具</p>
<p>：</p>
<ul>
<li><strong>Elasticsearch</strong>：全文搜索引擎，支持分布式日志存储和查询。</li>
<li><strong>HDFS</strong>：适用于海量日志的离线存储。</li>
<li><strong>ClickHouse</strong>：高性能列式存储数据库，适合日志分析。</li>
</ul>
</li>
</ul>
<p><strong>4. 日志处理与分析层</strong></p>
<ul>
<li><p><strong>作用</strong>：对日志进行实时或离线处理、分析。</p>
</li>
<li><p>技术选型</p>
<p>：</p>
<ul>
<li><strong>Spark Streaming</strong>：支持实时日志流处理。</li>
<li><strong>Flink</strong>：低延迟的分布式流处理框架。</li>
<li><strong>Logstash</strong>：可对日志进行格式化和过滤。</li>
</ul>
</li>
</ul>
<p><strong>5. 日志展示与管理层</strong></p>
<ul>
<li><p><strong>作用</strong>：提供可视化的日志查询和分析界面。</p>
</li>
<li><p>常用工具</p>
<p>：</p>
<ul>
<li><strong>Kibana</strong>：与 Elasticsearch 配合，用于日志可视化。</li>
<li><strong>Grafana</strong>：通用监控和可视化工具。</li>
<li><strong>Graylog</strong>：集中式日志管理和可视化工具。</li>
</ul>
</li>
</ul>
<p><strong>架构流程</strong></p>
<ol>
<li><strong>日志采集</strong><br> 各分布式节点通过日志采集工具（如 Filebeat）将日志发送到传输层。</li>
<li><strong>日志传输</strong><br> 日志传输层（如 Kafka）接收采集到的日志，并以高吞吐量将其分发到存储层。</li>
<li><strong>日志存储</strong><br> 存储层（如 Elasticsearch）将日志进行持久化存储，同时建立索引以支持快速查询。</li>
<li><strong>日志处理</strong><br> 使用流处理框架（如 Flink）对日志进行实时分析，或者通过批处理工具对历史日志进行离线分析。</li>
<li><strong>日志查询与展示</strong><br> 通过可视化工具（如 Kibana）进行日志的搜索和分析。</li>
</ol>
<p><strong>关键技术</strong></p>
<ol>
<li><strong>日志分片与索引</strong><ul>
<li>将日志数据按时间或节点分片，提升查询效率。</li>
<li>构建倒排索引以支持全文检索。</li>
</ul>
</li>
<li><strong>日志压缩与存储优化</strong><ul>
<li>对日志进行压缩存储，减少存储空间占用。</li>
<li>采用冷热分离策略，降低存储成本。</li>
</ul>
</li>
<li><strong>日志采样</strong><ul>
<li>对高频日志进行采样，减少处理和存储压力。</li>
</ul>
</li>
<li><strong>多级存储</strong><ul>
<li>将热日志存储在 Elasticsearch，冷日志存储在 HDFS 或对象存储中。</li>
</ul>
</li>
</ol>
<p><strong>应用场景</strong></p>
<ol>
<li><strong>系统监控</strong><br> 实时监控分布式系统的运行状态，发现异常。</li>
<li><strong>故障排查</strong><br> 快速查询分布式节点的日志，定位问题。</li>
<li><strong>性能分析</strong><br> 分析日志数据中的性能指标，优化系统性能。</li>
<li><strong>用户行为分析</strong><br> 对用户行为日志进行数据挖掘，提供业务支持。</li>
</ol>
<p><strong>挑战与优化</strong></p>
<ol>
<li><strong>海量日志的存储压力</strong><ul>
<li>采用分布式存储和压缩技术。</li>
<li>实现冷热数据分离。</li>
</ul>
</li>
<li><strong>高效的实时查询</strong><ul>
<li>优化索引策略，减少查询时间。</li>
<li>使用缓存加速热点数据查询。</li>
</ul>
</li>
<li><strong>分布式架构的高可用性</strong><ul>
<li>通过集群部署实现高可用。</li>
<li>提供备份和故障恢复机制。</li>
</ul>
</li>
<li><strong>日志延迟问题</strong><ul>
<li>优化传输和处理链路，减少日志处理延迟。</li>
</ul>
</li>
</ol>
<p><strong>总结</strong></p>
<p>分布式日志架构在现代分布式系统中起着关键作用，它的设计需要权衡性能、可靠性和成本。常用的工具链（如 ELK、Kafka、Fluentd 等）为分布式日志系统提供了强大的支持，而良好的架构设计能够有效提升系统的监控和运维能力。</p>
<h4 id="问：什么情况会导致Kafka运行变慢？"><a href="#问：什么情况会导致Kafka运行变慢？" class="headerlink" title="问：什么情况会导致Kafka运行变慢？"></a><strong>问：什么情况会导致Kafka运行变慢？</strong></h4><h4 id="问：说一下Kafka消费者消费过程？Kafka的消费者如何消费数据？"><a href="#问：说一下Kafka消费者消费过程？Kafka的消费者如何消费数据？" class="headerlink" title="问：说一下Kafka消费者消费过程？Kafka的消费者如何消费数据？"></a><strong>问：说一下Kafka消费者消费过程？Kafka的消费者如何消费数据？</strong></h4><h4 id="问：Kafka新建的分区会在哪个目录下创建？"><a href="#问：Kafka新建的分区会在哪个目录下创建？" class="headerlink" title="问：Kafka新建的分区会在哪个目录下创建？"></a><strong>问：Kafka新建的分区会在哪个目录下创建？</strong></h4><h4 id="问：Kafka-与传统消息系统之间有三个关键区别？"><a href="#问：Kafka-与传统消息系统之间有三个关键区别？" class="headerlink" title="问：Kafka 与传统消息系统之间有三个关键区别？"></a><strong>问：Kafka 与传统消息系统之间有三个关键区别？</strong></h4><p>Kafka 与传统消息系统（如 RabbitMQ、ActiveMQ 等）相比，有以下三个关键区别：</p>
<ol>
<li><strong>消息存储模型</strong></li>
</ol>
<ul>
<li><strong>传统消息系统</strong>：<ul>
<li>消息通常是临时的，消费者处理完后从队列中删除。</li>
<li>重点在于消息传递的实时性，侧重于 <strong>消息传递</strong>。</li>
</ul>
</li>
<li><strong>Kafka</strong>：<ul>
<li>消息持久化存储在磁盘中，可以根据需求反复消费。</li>
<li>Kafka 的主题日志保留策略允许消息在指定时间段内可供消费（即使已消费过）。</li>
<li>重点在于 <strong>消息存储</strong> 和 <strong>高吞吐的发布订阅</strong> 模型。</li>
</ul>
</li>
</ul>
<ol start="2">
<li><strong>消费模型</strong></li>
</ol>
<ul>
<li><strong>传统消息系统</strong>：<ul>
<li>通常实现点对点（P2P）或发布订阅模型。</li>
<li>消费模型较为简单，消息被消费后即不可用。</li>
<li>使用 <strong>Push 模式</strong> 推送消息给消费者。</li>
</ul>
</li>
<li><strong>Kafka</strong>：<ul>
<li>基于分区的发布订阅模式，每个分区的消费者独立处理消息。</li>
<li>消费者控制消息的消费进度（通过 offset），允许重新消费消息。</li>
<li>使用 <strong>Pull 模式</strong>，消费者主动拉取消息，提高灵活性。</li>
</ul>
</li>
</ul>
<ol start="3">
<li><strong>高吞吐设计</strong></li>
</ol>
<ul>
<li><strong>传统消息系统</strong>：<ul>
<li>主要为低延迟的实时消息传递设计，吞吐量受限。</li>
<li>通常为内存优化，不擅长大批量、高频率的消息传递。</li>
</ul>
</li>
<li><strong>Kafka</strong>：<ul>
<li>高吞吐量设计，可处理 TB 级数据。</li>
<li>使用分布式架构，每个主题分为多个分区，允许并行读写。</li>
<li>顺序写磁盘并利用零拷贝技术，极大提高吞吐量。</li>
<li>支持批量压缩消息，进一步优化性能。</li>
</ul>
</li>
</ul>
<p><strong>总结</strong></p>
<p>Kafka 相较于传统消息系统，具有以下优势：</p>
<ol>
<li>更适合日志聚合、流处理等需要 <strong>高吞吐量和消息存储</strong> 的场景。</li>
<li>提供分布式架构和灵活消费模型，适应性强。</li>
<li>在消息持久化和重新消费方面，比传统系统更加高效。</li>
</ol>
<h4 id="问：请详细说一下推送模式和拉取模式？"><a href="#问：请详细说一下推送模式和拉取模式？" class="headerlink" title="问：请详细说一下推送模式和拉取模式？"></a><strong>问：请详细说一下推送模式和拉取模式？</strong></h4><h4 id="问：-kafka消息发送的可靠性机制有几种？"><a href="#问：-kafka消息发送的可靠性机制有几种？" class="headerlink" title="问： kafka消息发送的可靠性机制有几种？"></a><strong>问： kafka消息发送的可靠性机制有几种？</strong></h4><p>Kafka 的消息发送可靠性机制主要体现在以下几个方面，确保消息在生产者、Broker 和消费者之间可靠地传递：</p>
<ol>
<li><strong>ACK机制（消息确认机制）</strong></li>
</ol>
<p>Kafka 使用 <code>acks</code> 参数控制生产者在发送消息时的确认级别：</p>
<ul>
<li><strong>acks = 0</strong>：<ul>
<li>生产者不会等待任何确认。</li>
<li>消息被写入 TCP 缓冲区后即返回成功，最快但不保证可靠性。</li>
<li>如果 Broker 宕机或消息丢失，生产者无法得知。</li>
</ul>
</li>
<li><strong>acks = 1</strong>：<ul>
<li>生产者等待主分区（Leader）写入成功后返回确认。</li>
<li>如果 Leader 写入成功但在同步到副本之前宕机，可能导致数据丢失。</li>
</ul>
</li>
<li><strong>acks = all</strong>（或 <code>acks = -1</code>）：<ul>
<li>生产者等待消息被所有同步副本（ISR）确认写入成功。</li>
<li>最可靠，但延迟较高，依赖 ISR 副本是否健康。</li>
</ul>
</li>
</ul>
<ol start="2">
<li><strong>重试机制</strong></li>
</ol>
<ul>
<li>生产者可以通过 <code>retries</code> 参数设置消息发送失败时的重试次数。</li>
<li>配合 <code>max.in.flight.requests.per.connection</code> 限制未确认消息的数量，以避免因重试导致的消息乱序问题。</li>
<li>可能的失败场景：<ul>
<li>网络抖动。</li>
<li>Broker 临时不可用。</li>
</ul>
</li>
</ul>
<ol start="3">
<li><strong>幂等性</strong></li>
</ol>
<ul>
<li>通过启用幂等性（<code>enable.idempotence = true</code>），生产者可以确保相同的消息（由 Producer ID 和 Sequence Number 标识）只会被写入一次。</li>
<li>消除由于重试导致的消息重复问题。</li>
<li>需要 Broker 支持 &gt;= 0.11.0。</li>
</ul>
<ol start="4">
<li><strong>事务机制</strong></li>
</ol>
<ul>
<li>Kafka 提供了事务机制（<code>transactional.id</code>）以确保多个消息在多个主题或分区上的一致性。</li>
<li>事务支持两种场景：<ol>
<li>消息的原子性写入。</li>
<li>在消费和生产之间实现“读-处理-写”操作的事务性。</li>
</ol>
</li>
<li>需要启用事务并使用 <code>initTransactions()</code>、<code>beginTransaction()</code> 和 <code>commitTransaction()</code>。</li>
</ul>
<ol start="5">
<li><strong>副本机制（Replication）</strong></li>
</ol>
<p>Kafka 的主题分区使用副本机制（Replication）提高可靠性：</p>
<ul>
<li>每个分区有一个主副本（Leader）和多个副本（Follower）。</li>
<li>副本分布在不同 Broker 上，避免单点故障。</li>
<li>ISR（同步副本集合）中的副本与 Leader 保持同步，<code>acks = all</code> 时写入所有 ISR 成员后确认。</li>
</ul>
<ol start="6">
<li><strong>消息持久化</strong></li>
</ol>
<ul>
<li>Kafka 消息默认持久化到磁盘，并通过顺序写入和零拷贝优化性能。</li>
<li>即使 Broker 崩溃或重启，已写入的消息不会丢失。</li>
</ul>
<p><strong>综合说明</strong></p>
<p>Kafka 通过 <strong>ACK机制</strong>、<strong>幂等性</strong>、<strong>事务机制</strong>、<strong>副本机制</strong> 和 <strong>持久化</strong> 提供了多层次的可靠性保障，用户可以根据业务需求权衡性能和可靠性：</p>
<ul>
<li>高吞吐要求：<code>acks = 1</code>，关闭幂等性。</li>
<li>高可靠性要求：<code>acks = all</code>，开启幂等性和事务机制。</li>
</ul>
<h4 id="问：分布式复制与传统意义上的消息确认机制"><a href="#问：分布式复制与传统意义上的消息确认机制" class="headerlink" title="问：分布式复制与传统意义上的消息确认机制"></a>问：分布式复制与传统意义上的消息确认机制</h4><p><strong>1. 分布式复制</strong></p>
<ul>
<li><strong>概念</strong>：分布式复制是指在分布式系统中将数据复制到多个节点，以实现数据的冗余存储和高可用性。</li>
<li><strong>工作机制</strong><ul>
<li>主从复制（Master-Slave Replication）：数据在主节点写入后，通过同步或异步方式复制到从节点。</li>
<li>多主复制（Multi-Master Replication）：多个节点都能进行写操作，节点之间通过一致性协议同步数据。</li>
<li>链式复制（Chain Replication）：数据沿链路从一个节点复制到下一个节点，常用于流量优化场景。</li>
</ul>
</li>
</ul>
<ul>
<li><p><strong>应用场景</strong></p>
<ul>
<li>数据库系统（如 MySQL 的主从复制、Redis 哨兵模式）。</li>
<li>分布式文件存储（如 HDFS 副本机制）。</li>
<li>消息队列（如 Kafka 的分区副本机制）。</li>
</ul>
</li>
<li><p><strong>优点</strong></p>
<ul>
<li>数据冗余：避免单点故障导致数据丢失。</li>
<li>高可用性：某个节点故障时，其他副本可以接管请求。</li>
<li>负载均衡：通过多个副本分担读请求。</li>
</ul>
</li>
<li><p><strong>缺点</strong></p>
<ul>
<li>数据一致性：复制延迟可能导致临时不一致。</li>
<li>资源开销：复制过程占用带宽和存储。</li>
</ul>
</li>
</ul>
<p><strong>2. 消息确认机制</strong></p>
<ul>
<li><strong>概念</strong>：消息确认机制确保消息从生产者到消费者的传递过程中不会丢失或重复，保证消息的可靠性。</li>
<li><strong>工作机制</strong><ul>
<li>生产者确认（Publisher Acknowledgements）：消息被队列接收后，生产者收到确认。</li>
<li>消费者确认（Consumer Acknowledgements）：消费者处理消息后发送确认，队列才认为消息已成功消费。</li>
<li>事务机制：确保生产和消费的完整性，避免中途失败。</li>
</ul>
</li>
</ul>
<ul>
<li><p><strong>应用场景</strong></p>
<ul>
<li>消息队列（如 RabbitMQ 的 <code>ack</code> 确认、Kafka 的消费位点提交）。</li>
<li>任务队列（如 Celery 的任务确认机制）。</li>
<li>流处理系统（如 Flink 的状态一致性）。</li>
</ul>
</li>
<li><p><strong>优点</strong></p>
<ul>
<li>消息可靠：保证消息不会丢失或重复处理。</li>
<li>流程可控：确认机制可与业务逻辑结合。</li>
</ul>
</li>
<li><p><strong>缺点</strong></p>
<ul>
<li>延迟：确认操作增加了网络往返时间。</li>
<li>开销：需要维护额外的状态或日志。</li>
</ul>
</li>
</ul>
<p><strong>对比</strong></p>
<table>
<thead>
<tr>
<th><strong>属性</strong></th>
<th><strong>分布式复制</strong></th>
<th><strong>消息确认机制</strong></th>
</tr>
</thead>
<tbody><tr>
<td><strong>目的</strong></td>
<td>数据冗余与高可用</td>
<td>确保消息可靠传递</td>
</tr>
<tr>
<td><strong>关注点</strong></td>
<td>数据的一致性、可用性</td>
<td>消息的完整性、顺序性</td>
</tr>
<tr>
<td><strong>实现方式</strong></td>
<td>数据副本同步到多个节点</td>
<td>确认消息的接收、处理</td>
</tr>
<tr>
<td><strong>应用场景</strong></td>
<td>数据库、分布式存储、分布式系统</td>
<td>消息队列、任务队列、流处理系统</td>
</tr>
<tr>
<td><strong>潜在问题</strong></td>
<td>复制延迟导致一致性问题</td>
<td>消息重复消费或确认超时</td>
</tr>
</tbody></table>
<p><strong>两者的结合</strong></p>
<p>在分布式消息队列系统（如 Kafka 和 RabbitMQ）中，分布式复制与消息确认机制往往是结合使用的：</p>
<ol>
<li><strong>分布式复制</strong>保证消息在多节点上的冗余存储，提升系统的高可用性。</li>
<li><strong>消息确认机制</strong>确保消息从生产到消费的可靠传递，避免消息丢失或重复消费。</li>
</ol>
<p>例如：</p>
<ul>
<li><strong>Kafka</strong>：使用分区副本实现分布式复制，同时通过消费位点（offset）管理消息确认。</li>
<li><strong>RabbitMQ</strong>：通过镜像队列实现复制，同时使用 <code>ack</code> 机制确保消费者可靠处理消息。</li>
</ul>
<hr>
<h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a><strong>总结</strong></h3><ul>
<li><strong>分布式复制</strong>更关注数据的冗余与高可用性，而<strong>消息确认机制</strong>则侧重于确保消息在传递过程中的完整性和可靠性。</li>
<li>在分布式系统中，两者通常结合使用以提供高可靠性和高可用性的服务。</li>
</ul>
<h4 id="问：Kafka如何判断一个节点是否存活？"><a href="#问：Kafka如何判断一个节点是否存活？" class="headerlink" title="问：Kafka如何判断一个节点是否存活？"></a><strong>问：Kafka如何判断一个节点是否存活？</strong></h4><h4 id="问：Kafka-数据存储设计？"><a href="#问：Kafka-数据存储设计？" class="headerlink" title="问：Kafka 数据存储设计？"></a><strong>问：Kafka 数据存储设计？</strong></h4><h4 id="问：为何需要Kafka集群？"><a href="#问：为何需要Kafka集群？" class="headerlink" title="问：为何需要Kafka集群？"></a><strong>问：为何需要Kafka集群？</strong></h4><h4 id="问：kafka-同时设置了-7-天和-10G-清除数据，到第五天的时候消息达到了-10G，这个时候-kafka将如何处理？"><a href="#问：kafka-同时设置了-7-天和-10G-清除数据，到第五天的时候消息达到了-10G，这个时候-kafka将如何处理？" class="headerlink" title="问：kafka 同时设置了 7 天和 10G 清除数据，到第五天的时候消息达到了 10G，这个时候 kafka将如何处理？"></a><strong>问：kafka 同时设置了 7 天和 10G 清除数据，到第五天的时候消息达到了 10G，这个时候 kafka将如何处理？</strong></h4><h4 id="问：如何保障消息100-投递成功、消息幂等性？"><a href="#问：如何保障消息100-投递成功、消息幂等性？" class="headerlink" title="问：如何保障消息100%投递成功、消息幂等性？"></a>问：如何保障消息100%投递成功、消息幂等性？</h4><p>在分布式系统中，保障消息100%投递成功是一个复杂但关键的问题。以下是一套完整的解决方案，涵盖生产者、Broker和消费者三端的可靠性设计，结合业务补偿机制实现最终可靠性：</p>
<h5 id="一、生产者端：确保消息可靠发出"><a href="#一、生产者端：确保消息可靠发出" class="headerlink" title="一、生产者端：确保消息可靠发出"></a>一、生产者端：确保消息可靠发出</h5><ol>
<li><p><strong>事务机制（慎用）</strong></p>
<ul>
<li><p><strong>适用场景</strong>：强一致性要求极高的场景（如金融交易）</p>
</li>
<li><p><strong>实现方式</strong>：</p>
<figure class="highlight reasonml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">channel.tx<span class="constructor">Select()</span>; <span class="comment">// 开启事务</span></span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">    channel.basic<span class="constructor">Publish(<span class="params">exchange</span>, <span class="params">routingKey</span>, MessageProperties.PERSISTENT_TEXT_PLAIN, <span class="params">msg</span>.<span class="params">getBytes</span>()</span>);</span><br><span class="line">    channel.tx<span class="constructor">Commit()</span>; <span class="comment">// 提交事务</span></span><br><span class="line">&#125; catch (Exception e) &#123;</span><br><span class="line">    channel.tx<span class="constructor">Rollback()</span>; <span class="comment">// 回滚事务</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li><p><strong>缺点</strong>：同步阻塞，性能下降200~300倍</p>
</li>
</ul>
</li>
<li><p><strong>Confirm确认模式（推荐）</strong></p>
<ul>
<li><p><strong>异步确认机制</strong>：通过回调确认消息是否成功写入Broker</p>
</li>
<li><p><strong>实现步骤</strong>：</p>
</li>
</ul>
<ol>
<li>开启Confirm模式：<code>channel.confirmSelect()</code></li>
<li>异步监听确认结果：</li>
</ol>
  <figure class="highlight less"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-tag">channel</span><span class="selector-class">.addConfirmListener</span>(new ConfirmListener() &#123;</span><br><span class="line">    <span class="variable">@Override</span></span><br><span class="line">    public void handleAck(long deliveryTag, boolean multiple) &#123;</span><br><span class="line">        <span class="comment">// 消息成功写入Broker，删除本地临时存储</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="variable">@Override</span></span><br><span class="line">    public void handleNack(long deliveryTag, boolean multiple) &#123;</span><br><span class="line">        <span class="comment">// 消息写入失败，触发重发</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>

<ul>
<li><strong>优化方案</strong>：结合本地消息表（Message Store）实现可靠重试</li>
</ul>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> producer_msg (</span><br><span class="line">    msg_id <span class="type">VARCHAR</span>(<span class="number">64</span>) <span class="keyword">PRIMARY</span> KEY,</span><br><span class="line">    content TEXT,</span><br><span class="line">    status ENUM(<span class="string">&#x27;pending&#x27;</span>, <span class="string">&#x27;confirmed&#x27;</span>),</span><br><span class="line">    created_time DATETIME</span><br></pre></td></tr></table></figure></li>
<li><p><strong>消息唯一标识</strong></p>
<ul>
<li>每条消息携带全局唯一ID（Snowflake算法/UUID）</li>
<li>用于去重和幂等性校验</li>
</ul>
</li>
</ol>
<h5 id="二、Broker端：确保消息持久化"><a href="#二、Broker端：确保消息持久化" class="headerlink" title="二、Broker端：确保消息持久化"></a>二、Broker端：确保消息持久化</h5><ol>
<li><p><strong>持久化三重保障</strong></p>
<figure class="highlight reasonml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 交换机持久化</span></span><br><span class="line">channel.exchange<span class="constructor">Declare(<span class="params">exchangeName</span>, <span class="string">&quot;direct&quot;</span>, <span class="params">true</span>)</span>;</span><br><span class="line"><span class="comment">// 队列持久化</span></span><br><span class="line">channel.queue<span class="constructor">Declare(<span class="params">queueName</span>, <span class="params">true</span>, <span class="params">false</span>, <span class="params">false</span>, <span class="params">null</span>)</span>;</span><br><span class="line"><span class="comment">// 消息持久化</span></span><br><span class="line">AMQP.BasicProperties props = <span class="keyword">new</span> AMQP.BasicProperties.<span class="constructor">Builder()</span></span><br><span class="line">        .delivery<span class="constructor">Mode(2)</span> <span class="comment">// 2=持久化</span></span><br><span class="line">        .build<span class="literal">()</span>;</span><br></pre></td></tr></table></figure></li>
<li><p><strong>镜像队列（Mirrored Queue）</strong></p>
<p>配置策略实现跨节点数据冗余</p>
<figure class="highlight ada"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">rabbitmqctl set_policy ha-<span class="keyword">all</span> <span class="string">&quot;^ha\.&quot;</span> &#x27;&#123;<span class="string">&quot;ha-mode&quot;</span>:<span class="string">&quot;all&quot;</span>,<span class="string">&quot;ha-sync-mode&quot;</span>:<span class="string">&quot;automatic&quot;</span>&#125;&#x27;</span><br></pre></td></tr></table></figure></li>
<li><p><strong>磁盘写入策略优化</strong></p>
<ul>
<li>配置<code>queue_index_embed_msgs_below</code>参数控制消息存储方式</li>
<li>使用RAID10或SSD提升磁盘IO性能</li>
</ul>
</li>
</ol>
<h5 id="三、消费者端：确保可靠处理"><a href="#三、消费者端：确保可靠处理" class="headerlink" title="三、消费者端：确保可靠处理"></a>三、消费者端：确保可靠处理</h5><ol>
<li><p><strong>手动ACK机制</strong></p>
<figure class="highlight reasonml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 关闭自动确认</span></span><br><span class="line">channel.basic<span class="constructor">Consume(<span class="params">queueName</span>, <span class="params">false</span>, <span class="params">consumer</span>)</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 正确处理后手动确认</span></span><br><span class="line">channel.basic<span class="constructor">Ack(<span class="params">deliveryTag</span>, <span class="params">false</span>)</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 处理失败拒绝并重试</span></span><br><span class="line">channel.basic<span class="constructor">Nack(<span class="params">deliveryTag</span>, <span class="params">false</span>, <span class="params">true</span>)</span>;</span><br></pre></td></tr></table></figure></li>
<li><p><strong>消费幂等设计</strong></p>
<p><strong>三级幂等保障</strong>：</p>
<ol>
<li><p>数据库唯一约束</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">ALTER</span> <span class="keyword">TABLE</span> orders <span class="keyword">ADD</span> <span class="keyword">UNIQUE</span> (biz_id);</span><br></pre></td></tr></table></figure></li>
<li><p>Redis原子操作</p>
<figure class="highlight reasonml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Boolean isProcessed = redisTemplate.ops<span class="constructor">ForValue()</span></span><br><span class="line">    .set<span class="constructor">IfAbsent(<span class="string">&quot;msg:&quot;</span>+<span class="params">msgId</span>, <span class="string">&quot;1&quot;</span>, 2, TimeUnit.HOURS)</span>;</span><br></pre></td></tr></table></figure></li>
<li><p>乐观锁更新</p>
<figure class="highlight pgsql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">UPDATE</span> account <span class="keyword">SET</span> balance = balance - <span class="number">100</span>, version = <span class="keyword">version</span> + <span class="number">1</span> </span><br><span class="line"><span class="keyword">WHERE</span> user_id = <span class="number">123</span> <span class="keyword">AND</span> version = <span class="number">5</span>;</span><br></pre></td></tr></table></figure></li>
</ol>
</li>
</ol>
<ol start="3">
<li><p><strong>死信队列监控</strong>：配置无法处理的消息进入DLX</p>
<figure class="highlight maxima"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Map&lt;String, Object&gt; <span class="built_in">args</span> = <span class="built_in">new</span> HashMap&lt;&gt;();</span><br><span class="line"><span class="built_in">args</span>.<span class="built_in">put</span>(<span class="string">&quot;x-dead-letter-exchange&quot;</span>, <span class="string">&quot;dlx.exchange&quot;</span>);</span><br><span class="line">channel.queueDeclare(<span class="string">&quot;business_queue&quot;</span>, <span class="literal">true</span>, <span class="literal">false</span>, <span class="literal">false</span>, <span class="built_in">args</span>);</span><br></pre></td></tr></table></figure></li>
</ol>
<h5 id="四、补偿机制：最终一致性保障"><a href="#四、补偿机制：最终一致性保障" class="headerlink" title="四、补偿机制：最终一致性保障"></a>四、补偿机制：最终一致性保障</h5><ol>
<li><p><strong>消息状态追踪系统</strong></p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> msg_trace (</span><br><span class="line">    msg_id <span class="type">VARCHAR</span>(<span class="number">64</span>) <span class="keyword">PRIMARY</span> KEY,</span><br><span class="line">    status ENUM(<span class="string">&#x27;sent&#x27;</span>,<span class="string">&#x27;consumed&#x27;</span>),</span><br><span class="line">    retry_count <span class="type">INT</span> <span class="keyword">DEFAULT</span> <span class="number">0</span>,</span><br><span class="line">    next_retry_time DATETIME</span><br><span class="line">);</span><br></pre></td></tr></table></figure></li>
<li><p><strong>定时对账任务</strong></p>
<ul>
<li>每小时扫描生产者的本地消息表</li>
<li>对比Broker中的消息状态</li>
<li>对未确认消息进行补偿重发</li>
</ul>
</li>
<li><p><strong>人工干预接口</strong></p>
<ul>
<li>提供消息查询页面</li>
<li>支持手动触发重发</li>
<li>报警阈值设置（如1小时内未确认消息&gt;100条触发SMS告警）</li>
</ul>
</li>
</ol>
<h5 id="五、全链路压测方案"><a href="#五、全链路压测方案" class="headerlink" title="五、全链路压测方案"></a>五、全链路压测方案</h5><table>
<thead>
<tr>
<th align="left">故障类型</th>
<th align="left">模拟手段</th>
<th align="left">验证指标</th>
</tr>
</thead>
<tbody><tr>
<td align="left">网络闪断</td>
<td align="left">随机断开生产者和Broker间网络</td>
<td align="left">消息重试成功率</td>
</tr>
<tr>
<td align="left">Broker磁盘故障</td>
<td align="left">手动触发节点宕机</td>
<td align="left">镜像队列切换时间</td>
</tr>
<tr>
<td align="left">消费者进程崩溃</td>
<td align="left">Kill -9 消费进程</td>
<td align="left">未ACK消息重新入队时间</td>
</tr>
<tr>
<td align="left">数据库主从延迟</td>
<td align="left">人工注入延迟</td>
<td align="left">幂等校验准确性</td>
</tr>
</tbody></table>
<h5 id="六、不同场景的可靠性权衡"><a href="#六、不同场景的可靠性权衡" class="headerlink" title="六、不同场景的可靠性权衡"></a>六、不同场景的可靠性权衡</h5><table>
<thead>
<tr>
<th align="left">场景</th>
<th align="left">推荐方案</th>
<th align="left">理论可靠性</th>
<th align="left">吞吐量</th>
</tr>
</thead>
<tbody><tr>
<td align="left">电商订单支付</td>
<td align="left">事务消息+本地消息表+三级幂等</td>
<td align="left">99.9999%</td>
<td align="left">500 TPS</td>
</tr>
<tr>
<td align="left">物联网设备上报</td>
<td align="left">异步Confirm+Redis去重</td>
<td align="left">99.99%</td>
<td align="left">10万 TPS</td>
</tr>
<tr>
<td align="left">日志采集</td>
<td align="left">批量发送+自动ACK</td>
<td align="left">99%</td>
<td align="left">50万 TPS</td>
</tr>
</tbody></table>
<h5 id="七、注意事项"><a href="#七、注意事项" class="headerlink" title="七、注意事项"></a>七、注意事项</h5><ol>
<li><strong>不要过度设计</strong>：根据业务实际需求选择可靠性级别</li>
<li><strong>监控比预防更重要</strong>：需建立完善的消息轨迹追踪系统</li>
<li><strong>CAP原则的妥协</strong>：绝对100%投递不存在，追求最终一致性</li>
<li><strong>成本考量</strong>：磁盘持久化、网络同步带来的性能损耗需要评估</li>
</ol>
<p>通过以上技术方案组合，可以在实际业务中达到<strong>5个9（99.999%）的消息可靠性</strong>。真正的100%可靠性需要业务侧参与设计补偿流程，形成完整的可靠性闭环。</p>
<h4 id="问：海量订单产生的业务高峰期，如何避免消息的重复消费？"><a href="#问：海量订单产生的业务高峰期，如何避免消息的重复消费？" class="headerlink" title="问：海量订单产生的业务高峰期，如何避免消息的重复消费？"></a>问：海量订单产生的业务高峰期，如何避免消息的重复消费？</h4><p>🐇 <strong>避免海量订单业务高峰期消息重复消费的解决方案</strong></p>
<p>在处理<strong>高并发</strong>和<strong>海量订单</strong>的业务高峰期时，消息的<strong>重复消费</strong>是一个常见问题，尤其是在<strong>消息队列</strong>系统（如 RabbitMQ）中。为了保证数据一致性和正确的业务流程，以下是几种避免消息重复消费的方法。</p>
<h5 id="📌-1-消息去重机制"><a href="#📌-1-消息去重机制" class="headerlink" title="📌 1. 消息去重机制"></a>📌 <strong>1. 消息去重机制</strong></h5><p>1.1 <strong>幂等性设计</strong></p>
<p>确保消费端是<strong>幂等的</strong>，即同一条消息多次消费不会改变业务结果。幂等性是解决消息重复消费问题的核心。</p>
<ul>
<li><p><strong>示例</strong>：假设我们在处理订单时，如果订单已处理过，返回<code>已完成</code>的状态，而不是重复创建订单。</p>
<p><strong>实现方式</strong>：</p>
<ul>
<li>在消费端通过订单号、消息唯一标识符（如消息ID）等，去查询是否已处理。</li>
<li>如果该订单或消息已经被处理，则跳过该消息的消费；否则，进行正常的处理。</li>
</ul>
</li>
</ul>
<p>1.2 <strong>幂等性实现示例：</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">OrderService</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> Set&lt;String&gt; processedOrders = <span class="keyword">new</span> HashSet&lt;&gt;();</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">processOrder</span><span class="params">(String orderId)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 检查订单是否已经处理</span></span><br><span class="line">        <span class="keyword">if</span> (processedOrders.contains(orderId)) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;  <span class="comment">// 已处理，跳过</span></span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 执行业务逻辑</span></span><br><span class="line">        processOrderInternal(orderId);</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 标记订单已处理</span></span><br><span class="line">        processedOrders.add(orderId);</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">processOrderInternal</span><span class="params">(String orderId)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 订单处理逻辑</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h5 id="📌-2-消息去重ID"><a href="#📌-2-消息去重ID" class="headerlink" title="📌 2. 消息去重ID"></a>📌 <strong>2. 消息去重ID</strong></h5><p>2.1 <strong>使用唯一标识符（Message ID）进行去重</strong></p>
<p>每个消息可以携带一个唯一的标识符（如订单号、消息ID等），用于标识该消息是否已经被处理过。消费者在消费前检查该消息ID，若该消息已经被消费，跳过该消息的处理。</p>
<ul>
<li><strong>示例</strong>：消费者可以将已消费消息的ID记录在<strong>数据库</strong>或<strong>缓存系统（如 Redis）</strong>中。</li>
<li><strong>Redis</strong>：通过 Redis 的 Set 存储消息标识符，Set 的特性使得重复的消息标识符不能被插入。</li>
<li><strong>数据库</strong>：将消息标识符作为字段保存，并利用数据库的唯一索引约束来避免重复消费。</li>
</ul>
<p>2.2 <strong>Redis 去重实现</strong></p>
<p>利用 Redis 存储已消费的消息 ID，设置<strong>过期时间</strong>来防止重复消费。消息 ID 可以存储在 Redis 的<strong>Set</strong>中，利用 Redis 的集合操作保证消息不被重复消费。</p>
<p><strong>Redis 去重的实现步骤</strong>：</p>
<ol>
<li><strong>消息消费前</strong>：消费者首先检查 Redis 中是否已经存在该消息的 ID。</li>
<li><strong>消息处理后</strong>：如果该消息 ID 不存在，则处理该消息，并将其 ID 存储到 Redis。</li>
<li><strong>过期设置</strong>：为防止 Redis 无限增长，设置消息 ID 在 Redis 中的<strong>过期时间</strong>，如 5 分钟，以便过期的消息 ID 自动清除。</li>
</ol>
<p><strong>代码示例</strong>：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> redis.clients.jedis.Jedis;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">OrderConsumer</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> Jedis jedis;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> String MESSAGE_SET_KEY = <span class="string">&quot;processed_messages&quot;</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">OrderConsumer</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.jedis = <span class="keyword">new</span> Jedis(<span class="string">&quot;localhost&quot;</span>);  <span class="comment">// 假设 Redis 在本地</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">processOrder</span><span class="params">(String messageId, String orderId)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 检查 Redis 中是否已经存在该消息 ID</span></span><br><span class="line">        <span class="keyword">if</span> (jedis.sismember(MESSAGE_SET_KEY, messageId)) &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;消息已处理，跳过&quot;</span>);</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;  <span class="comment">// 消息已处理，跳过</span></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 处理订单</span></span><br><span class="line">        processOrderInternal(orderId);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 将消息 ID 存储到 Redis 中，设置过期时间（如 5 分钟）</span></span><br><span class="line">        jedis.sadd(MESSAGE_SET_KEY, messageId);</span><br><span class="line">        jedis.expire(MESSAGE_SET_KEY, <span class="number">300</span>);  <span class="comment">// 过期时间 300 秒（5 分钟）</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">processOrderInternal</span><span class="params">(String orderId)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 订单处理逻辑</span></span><br><span class="line">        System.out.println(<span class="string">&quot;处理订单: &quot;</span> + orderId);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>通过这种方式，我们能确保消息在指定时间内只会被处理一次，避免了重复消费。</p>
<p>📌 <strong>3. 消息确认机制</strong></p>
<p>3.1 <strong>RabbitMQ 消息确认</strong></p>
<p>RabbitMQ 提供了消息确认机制来确保消息的<strong>可靠性</strong>和<strong>防止重复消费</strong>。消费者在处理完消息后，需要通过 <code>ack</code> 命令告知 RabbitMQ 消息已被成功消费。如果在消费者处理消息的过程中发生故障，RabbitMQ 会重新投递该消息，避免消息丢失，但这也可能导致重复消费。</p>
<p>为了防止重复消费，消费者可以在处理完任务后，使用 <code>manual ack</code> 确认消息。消费者处理过程可以通过一定的<strong>幂等性设计</strong>来保证即使消息被重新投递，业务结果也不重复。</p>
<p><strong>示例</strong>：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">channel.basicConsume(<span class="string">&quot;orderQueue&quot;</span>, <span class="keyword">false</span>, <span class="keyword">new</span> DefaultConsumer(channel) &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">handleDelivery</span><span class="params">(String consumerTag, Envelope envelope, AMQP.BasicProperties properties, <span class="keyword">byte</span>[] body)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">        String message = <span class="keyword">new</span> String(body, <span class="string">&quot;UTF-8&quot;</span>);</span><br><span class="line">        String messageId = properties.getMessageId();  <span class="comment">// 获取消息ID</span></span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 处理订单</span></span><br><span class="line">        <span class="keyword">boolean</span> processed = processOrder(messageId, message);</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">if</span> (processed) &#123;</span><br><span class="line">            <span class="comment">// 处理成功后手动确认消息</span></span><br><span class="line">            channel.basicAck(envelope.getDeliveryTag(), <span class="keyword">false</span>);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">// 处理失败时，拒绝并重新入队</span></span><br><span class="line">            channel.basicNack(envelope.getDeliveryTag(), <span class="keyword">false</span>, <span class="keyword">true</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>

<p>在上述代码中，<code>basicAck</code> 用于确认消息成功消费，<code>basicNack</code> 用于拒绝消息并重新入队。如果消费失败，消息会被重新投递，从而避免丢失消息。</p>
<p>📌 <strong>4. 消息去重的其他方法</strong></p>
<p>4.1 <strong>数据库唯一约束</strong></p>
<p>在某些情况下，消费者将消息的处理结果（例如订单的处理状态）存储到数据库时，可以利用数据库的<strong>唯一约束</strong>来避免重复插入。例如，在订单表中可以对<code>订单号</code>加上唯一索引，若重复插入相同的订单号，数据库会返回错误。</p>
<p><strong>示例</strong>：</p>
<ul>
<li>在数据库中对 <code>order_id</code> 添加唯一索引。</li>
<li>当插入订单时，如果订单已存在，则不会重复插入。</li>
</ul>
<p>4.2 <strong>使用分布式锁</strong></p>
<p>在处理高并发的情况下，可以考虑使用<strong>分布式锁</strong>来控制同一条消息只能被一个消费者处理。例如，利用 Redis 实现分布式锁，在消息消费时获得锁，处理完消息后释放锁。这样可以防止多个消费者同时处理同一条消息。</p>
<p><strong>Redis 分布式锁示例</strong>：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> redis.clients.jedis.Jedis;</span><br><span class="line"><span class="keyword">import</span> java.util.UUID;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">OrderService</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> Jedis jedis;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">OrderService</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.jedis = <span class="keyword">new</span> Jedis(<span class="string">&quot;localhost&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">processOrder</span><span class="params">(String orderId)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 生成唯一的锁ID</span></span><br><span class="line">        String lockId = UUID.randomUUID().toString();</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 获取分布式锁</span></span><br><span class="line">        <span class="keyword">if</span> (jedis.setnx(<span class="string">&quot;lock:&quot;</span> + orderId, lockId) == <span class="number">1</span>) &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                <span class="comment">// 处理订单</span></span><br><span class="line">                processOrderInternal(orderId);</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">            &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">                <span class="comment">// 释放锁</span></span><br><span class="line">                <span class="keyword">if</span> (lockId.equals(jedis.get(<span class="string">&quot;lock:&quot;</span> + orderId))) &#123;</span><br><span class="line">                    jedis.del(<span class="string">&quot;lock:&quot;</span> + orderId);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">// 锁已经被其他消费者持有，跳过处理</span></span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">processOrderInternal</span><span class="params">(String orderId)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 订单处理逻辑</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p>📌 <strong>5. 消费者负载均衡与高可用</strong></p>
<p>在高并发场景下，增加消费者数量并通过负载均衡策略分配消息，能够避免某些消费者因处理时间过长而阻塞其他消费者。</p>
<ol>
<li><strong>消息的公平分配</strong>：通过 <code>basicQos</code> 限制每个消费者每次处理的最大消息数量，避免单个消费者处理过多消息导致其他消费者的阻塞。</li>
<li><strong>消费者池</strong>：采用消费者池管理消费者实例，以便动态增加或减少消费者数量，保证系统的<strong>负载均衡</strong>。</li>
</ol>
<p>🛠️ <strong>总结与最佳实践</strong></p>
<ul>
<li><strong>幂等性设计</strong>：无论消息被处理多少次，处理结果始终一致。</li>
<li><strong>消息去重</strong>：通过 Redis 或数据库等存储介质，利用唯一标识符避免重复消费。</li>
<li><strong>手动消息确认</strong>：使用 <code>ack</code> 和 <code>nack</code> 机制确保消息的可靠消费，避免消息丢失。</li>
<li><strong>分布式锁</strong>：使用分布式锁来确保消息不会被多个消费者并发消费。</li>
</ul>
<p>通过这些方式，结合高可用的 RabbitMQ 集群配置，可以有效减少高并发场景下的<strong>重复消费</strong>问题，保证系统的稳定性和一致性。</p>
<h3 id="MQ消息开启Trace"><a href="#MQ消息开启Trace" class="headerlink" title="MQ消息开启Trace"></a>MQ消息开启Trace</h3><ol>
<li><p>连接linux服务器</p>
</li>
<li><p>输入指令 <code>rabbitmqctl status</code> 确认MQ状态</p>
<p><img src="C:\Users\hspcadmin\AppData\Roaming\Typora\typora-user-images\image-20210331171126692.png" alt="image-20210331171126692"></p>
</li>
<li><p>通过指令 <code>rabbitmq-plugins list</code> 查看MQ安装的插件，<code>E*</code> 表示已启用</p>
<p><img src="C:\Users\hspcadmin\AppData\Roaming\Typora\typora-user-images\image-20210331171303814.png" alt="image-20210331171303814"></p>
</li>
<li><p>找到 <code>rabbitmq_tracing</code> 确认是否启用，若未启用，则通过指令 <code>rabbitmq-plugins enable rabbitmq_tracing</code> 开启。</p>
<p><img src="C:\Users\hspcadmin\AppData\Roaming\Typora\typora-user-images\image-20210331171436966.png" alt="image-20210331171436966"></p>
</li>
<li><p>通过指令 <code>rabbitmqctl trace_on</code> 开启trace。</p>
</li>
<li><p>虚拟主机 server 开启trace：<code>rabbitmqctl trace_on -p server</code> ，添加完成后会多一个交换器：</p>
<p><img src="C:\Users\hspcadmin\AppData\Roaming\Typora\typora-user-images\image-20210331171813344.png" alt="image-20210331171813344"></p>
</li>
<li><p>RabbitMQ管理平台新建一个Trace，添加trace追踪文件信息：</p>
<p><img src="C:\Users\hspcadmin\AppData\Roaming\Typora\typora-user-images\image-20210331172359303.png" alt="image-20210331172359303"></p>
</li>
<li><p>创建的Trace文件：</p>
<p><img src="C:\Users\hspcadmin\AppData\Roaming\Typora\typora-user-images\image-20210331172219234.png" alt="image-20210331172219234"></p>
</li>
<li><p>重新触发消息发送。</p>
</li>
<li><p>查看步骤8的Trace文件，确认消息是否发送。</p>
</li>
</ol>
<p>添加Trace时报错</p>
<figure class="highlight dns"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">2021-03-31</span> <span class="number">20</span>:<span class="number">00:01.475</span> [info] &lt;<span class="number">0.19340.4</span>&gt; accepting AMQP connection &lt;<span class="number">0.19340.4</span>&gt; (<span class="number">172.24.19.124</span>:<span class="number">35267</span> -&gt; <span class="number">10.20.18.81</span>:<span class="number">5672</span>)</span><br><span class="line"><span class="number">2021-03-31</span> <span class="number">20:00:02.223</span> [info] &lt;<span class="number">0.19340.4</span>&gt; connection &lt;<span class="number">0.19340.4</span>&gt; (<span class="number">172.24.19.124</span>:<span class="number">35267</span> -&gt; <span class="number">10.20.18.81</span>:<span class="number">5672</span>): user &#x27;fa6&#x27; authenticated and granted access to vhost &#x27;client&#x27;</span><br><span class="line"><span class="number">2021-03-31</span> <span class="number">20</span>:<span class="number">01:08.413</span> [info] &lt;<span class="number">0.2285.0</span>&gt; Disabling tracing for vhost &#x27;server&#x27;</span><br><span class="line"><span class="number">2021-03-31</span> <span class="number">20</span>:<span class="number">01:11.453</span> [info] &lt;<span class="number">0.2285.0</span>&gt; Enabling tracing for vhost &#x27;server&#x27;</span><br><span class="line"><span class="number">2021-03-31</span> <span class="number">20</span>:<span class="number">01:11.481</span> [error] &lt;<span class="number">0.19570.4</span>&gt; CRASH REPORT Process &lt;<span class="number">0.19570.4</span>&gt; with <span class="number">0</span> neighbours exited with reason: no match of right hand value &#123;error,not_allowed&#125; in rabbit_tracing_consumer:init/<span class="number">1</span> line <span class="number">58</span> in gen_server:init_it/<span class="number">6</span> line <span class="number">352</span></span><br><span class="line"><span class="number">2021-03-31</span> <span class="number">20</span>:<span class="number">01:11.482</span> [error] &lt;<span class="number">0.19569.4</span>&gt; Supervisor &#123;&lt;<span class="number">0.19569.4</span>&gt;,rabbit_tracing_consumer_sup&#125; had child consumer started with rabbit_tracing_consumer:start_link([&#123;vhost,&lt;&lt;&quot;server&quot;&gt;&gt;&#125;,&#123;name,&lt;&lt;&quot;server-trace-log&quot;&gt;&gt;&#125;,&#123;format,&lt;&lt;&quot;text&quot;&gt;&gt;&#125;,&#123;pattern,&lt;&lt;&quot;#&quot;&gt;&gt;&#125;,&#123;&lt;&lt;&quot;for...&quot;&gt;&gt;,...&#125;,...]) at undefined exit with reason no match of right hand value &#123;error,not_allowed&#125; in rabbit_tracing_consumer:init/<span class="number">1</span> line <span class="number">58</span> in context start_error</span><br><span class="line"><span class="number">2021-03-31</span> <span class="number">20</span>:<span class="number">02:10.759</span> [warning] &lt;<span class="number">0.10199.4</span>&gt; closing AMQP connection &lt;<span class="number">0.10199.4</span>&gt; (<span class="number">172.24.20.49</span>:<span class="number">54661</span> -&gt; <span class="number">10.20.18.81</span>:<span class="number">5672</span>):</span><br><span class="line">missed heartbeats from client, timeout: <span class="number">30</span>s</span><br><span class="line"><span class="number">2021-03-31</span> <span class="number">20</span>:<span class="number">02:34.874</span> [info] &lt;<span class="number">0.19635.4</span>&gt; accepting AMQP connection &lt;<span class="number">0.19635.4</span>&gt; (<span class="number">172.24.20.49</span>:<span class="number">49512</span> -&gt; <span class="number">10.20.18.81</span>:<span class="number">5672</span>)</span><br><span class="line"><span class="number">2021-03-31</span> <span class="number">20</span>:<span class="number">02:35.021</span> [info] &lt;<span class="number">0.19635.4</span>&gt; connection &lt;<span class="number">0.19635.4</span>&gt; (<span class="number">172.24.20.49</span>:<span class="number">49512</span> -&gt; <span class="number">10.20.18.81</span>:<span class="number">5672</span>): user &#x27;fa6&#x27; authenticated and granted access to vhost &#x27;client&#x27;</span><br></pre></td></tr></table></figure>







<p>MQ的tracing插件默认使用guest用户，给它开下server权限应该就行了</p>
<p><img src="C:\Users\hspcadmin\AppData\Roaming\Typora\typora-user-images\image-20210331214055800.png" alt="image-20210331214055800"></p>
<p><img src="C:\Users\hspcadmin\AppData\Roaming\Typora\typora-user-images\image-20210331214106354.png" alt="image-20210331214106354"></p>

    </div>

    
    
    

    <footer class="post-footer">
          

<div class="post-copyright">
<ul>
  <li class="post-copyright-author">
      <strong>本文作者： </strong>Lys
  </li>
  <li class="post-copyright-link">
      <strong>本文链接：</strong>
      <a href="http://linyishui.top/2020050201.html" title="面试整理——MQ">http://linyishui.top/2020050201.html</a>
  </li>
  <li class="post-copyright-license">
    <strong>版权声明： </strong>本博客所有文章除特别声明外，均采用 <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/deed.zh" rel="noopener" target="_blank"><i class="fab fa-fw fa-creative-commons"></i>BY-NC-SA</a> 许可协议。转载请注明出处！
  </li>
</ul>
</div>

          <div class="post-tags">
              <a href="/tags/Q-A/" rel="tag"><i class="fa fa-tag"></i> Q&A</a>
              <a href="/tags/updating/" rel="tag"><i class="fa fa-tag"></i> updating</a>
          </div>

        

          <div class="post-nav">
            <div class="post-nav-item">
                <a href="/2020050101.html" rel="prev" title="面试整理——Spring Cloud">
                  <i class="fa fa-chevron-left"></i> 面试整理——Spring Cloud
                </a>
            </div>
            <div class="post-nav-item">
                <a href="/2020050301.html" rel="next" title="面试整理——Mybatis">
                  面试整理——Mybatis <i class="fa fa-chevron-right"></i>
                </a>
            </div>
          </div>
    </footer>
  </article>
</div>






    <div class="comments utterances-container"></div>
</div>
  </main>

  <footer class="footer">
    <div class="footer-inner">


<div class="copyright">
  &copy; 2018 – 
  <span itemprop="copyrightYear">2025</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">Lys</span>
</div>
<div class="wordcount">
  <span class="post-meta-item">
    <span class="post-meta-item-icon">
      <i class="fa fa-chart-line"></i>
    </span>
      <span>站点总字数：</span>
    <span title="站点总字数">5.4m</span>
  </span>
  <span class="post-meta-item">
    <span class="post-meta-item-icon">
      <i class="fa fa-coffee"></i>
    </span>
      <span>站点阅读时长 &asymp;</span>
    <span title="站点阅读时长">82:05</span>
  </span>
</div>
  <div class="powered-by">由 <a href="https://hexo.io/" rel="noopener" target="_blank">Hexo</a> & <a href="https://theme-next.js.org/pisces/" rel="noopener" target="_blank">NexT.Pisces</a> 强力驱动
  </div>

    </div>
  </footer>

  
  <script src="https://cdn.jsdelivr.net/npm/animejs@3.2.1/lib/anime.min.js" integrity="sha256-XL2inqUJaslATFnHdJOi9GfQ60on8Wx1C2H8DYiN1xY=" crossorigin="anonymous"></script>
  <script src="https://cdn.jsdelivr.net/npm/jquery@3.6.0/dist/jquery.min.js" integrity="sha256-/xUj+3OJU5yExlq6GSYGSHk7tPXikynS7ogEvDej/m4=" crossorigin="anonymous"></script>
  <script src="https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@3.5.7/dist/jquery.fancybox.min.js" integrity="sha256-yt2kYMy0w8AbtF89WXb2P1rfjcP/HTHLT7097U8Y5b8=" crossorigin="anonymous"></script>
<script src="/js/comments.js"></script><script src="/js/utils.js"></script><script src="/js/motion.js"></script><script src="/js/next-boot.js"></script><script src="/js/bookmark.js"></script>

  
<script src="/js/third-party/search/local-search.js"></script>



  <script class="next-config" data-name="nprogress" type="application/json">{"enable":true,"spinner":true}</script>
  <script src="/js/third-party/nprogress.js"></script>

  




<script src="https://cdn.jsdelivr.net/npm/darkmode-js@1.5.7/lib/darkmode-js.min.js"></script>

<script>
var options = {
  bottom: '64px',
  right: '32px',
  left: 'unset',
  time: '0.5s',
  mixColor: 'transparent',
  backgroundColor: 'transparent',
  buttonColorDark: '#100f2c',
  buttonColorLight: '#fff',
  saveInCookies: true,
  label: '🌓',
  autoMatchOsTheme: true
}
const darkmode = new Darkmode(options);
window.darkmode = darkmode;
darkmode.showWidget();
</script>
<script class="next-config" data-name="utterances" type="application/json">{"enable":true,"repo":"LAILAIWA/LAILAIWA.github.io","issue_term":"pathname","theme":"github-light"}</script>
<script src="/js/third-party/comments/utterances.js"></script>



</body>
</html>
